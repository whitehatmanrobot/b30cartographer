Protocol eRequesterProtocol);

	~CBasicQueryHandle();
	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer) = 0;
    virtual HRESULT LookupEnd() = 0;
    enumRequesterProtocol GetRequesterProtocol() const;
private:
    enumRequesterProtocol m_eRequesterProtocol;
};

inline CBasicQueryHandle::CBasicQueryHandle(
			enumRequesterProtocol eRequesterProtocol
			):
			CBaseContextType(CBaseContextType::eQueryHandleCtx),
			m_eRequesterProtocol(eRequesterProtocol)
{};

inline CBasicQueryHandle::~CBasicQueryHandle() {};

inline enumRequesterProtocol CBasicQueryHandle::GetRequesterProtocol() const
{
    return( m_eRequesterProtocol);
}


//-----------------------------------------------------------------------------------
//
//      CQueryHandle
//
//  This class is suitable for all queries, where locate next is referred 
//  directly to the DS (i.e. no additional translation or checking is required).
//
//-----------------------------------------------------------------------------------
class CQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CQueryHandle
    //
    //  hCursor             - a cursor returned from Locate Begin operation performed on the DS
    //  dwNoPropsInResult   - number of peroperties to be retrieve in each result
    CQueryHandle( 
               IN  HANDLE               hCursor,
               IN  DWORD                dwNoPropsInResult,
               IN  enumRequesterProtocol eRequesterProtocol
               );

	~CQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoPropsInResult;
    CDsQueryHandle      m_hCursor;

};

inline CQueryHandle::CQueryHandle( 
               IN  HANDLE               hCursor,
               IN  DWORD                dwNoPropsInResult,
               IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol), m_dwNoPropsInResult( dwNoPropsInResult)
{
    m_hCursor.SetHandle( hCursor);
}

inline CQueryHandle::~CQueryHandle()
{
};

inline HRESULT CQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}
//-----------------------------------------------------------------------------------
//
//      CUserCertQueryHandle
//
//  This class simulates query functionality on array of user-signed-certificates.
//-----------------------------------------------------------------------------------
class CUserCertQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CUserCertQueryHandle
    //
    //  pblob - a blob containing user-signed-certificates.
    CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
                IN enumRequesterProtocol eRequesterProtocol
               );

	~CUserCertQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoCertRead;
    BLOB                m_blobNT5UserCert;
    BLOB                m_blobNT4UserCert;

};

inline  CUserCertQueryHandle::CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
                IN enumRequesterProtocol eRequesterProtocol
                ): CBasicQueryHandle(eRequesterProtocol), 
                   m_dwNoCertRead(0)
{
    m_blobNT5UserCert.cbSize = pblobNT5User->cbSize;
    if ( m_blobNT5UserCert.cbSize != 0)
    {
        m_blobNT5UserCert.pBlobData = new BYTE[ m_blobNT5UserCert.cbSize];
        memcpy( m_blobNT5UserCert.pBlobData, pblobNT5User->pBlobData, m_blobNT5UserCert.cbSize);
    }
    else
    {
        m_blobNT5UserCert.pBlobData = NULL;
    }
    m_blobNT4UserCert.cbSize = pblobNT4User->cbSize;
    if ( m_blobNT4UserCert.cbSize != 0)
    {
        m_blobNT4UserCert.pBlobData = new BYTE[ m_blobNT4UserCert.cbSize];
        memcpy( m_blobNT4UserCert.pBlobData, pblobNT4User->pBlobData, m_blobNT4UserCert.cbSize);
    }
    else
    {
        m_blobNT4UserCert.pBlobData = NULL;
    }
}

inline CUserCertQueryHandle::~CUserCertQueryHandle()
{
    delete []m_blobNT5UserCert.pBlobData;
    delete []m_blobNT4UserCert.pBlobData;

}
inline HRESULT CUserCertQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}

//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
class CRoutingServerQueryHandle : public CBasicQueryHandle
{
public:
    CRoutingServerQueryHandle(
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  HANDLE hCursor,
                 IN  enumRequesterProtocol eRequesterProtocol
               );

	~CRoutingServerQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol;
    PROPID *            m_aCol;
    CDsQueryHandle      m_hCursor;
};


inline CRoutingServerQueryHandle::CRoutingServerQueryHandle(
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  HANDLE hCursor,
                 IN  enumRequesterProtocol eRequesterProtocol
                 ):  CBasicQueryHandle(eRequesterProtocol)

{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CRoutingServerQueryHandle::~CRoutingServerQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CRoutingServerQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CRoutingServerQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}



//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------

class CSiteQueryHandle : public CBasicQueryHandle
{
public:
    CSiteQueryHandle(
                 IN  HANDLE hCursor,
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               );

	~CSiteQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:

    HRESULT FillInOneResponse(
                IN   const GUID *          pguidSiteId,
                IN   LPCWSTR               pwcsSiteName,
                OUT  PROPVARIANT *         pbBuffer);


    CDsQueryHandle      m_hCursor;
    ULONG               m_cCol;
    PROPID *            m_aCol;
    BOOL                m_fSiteGatesRequired;
};


inline CSiteQueryHandle::CSiteQueryHandle(
                 IN  HANDLE hCursor,
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
                 ):  CBasicQueryHandle(eRequesterProtocol)

{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;

    m_fSiteGatesRequired = FALSE;
    for (DWORD i = 0; i < m_cCol; i++)
    {
        if ( m_aCol[i] == PROPID_S_GATES)
        {
            m_fSiteGatesRequired = TRUE;
            break;
        }
    }
    m_hCursor.SetHandle( hCursor);
}

inline 	CSiteQueryHandle::~CSiteQueryHandle()
{
    delete [] m_aCol;
}

inline DWORD  CSiteQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CSiteQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

//-------------------------------------------------------------------------
//
//        CConnectorQueryHandle
//
//
//  This query handle is used when locating a foreign
//  machine connectors.
//
//-------------------------------------------------------------------------


class CConnectorQueryHandle : public CBasicQueryHandle
{
public:
    CConnectorQueryHandle(
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  CSiteGateList *        pSiteGateList,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CConnectorQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;  // DS query handle
    DWORD               m_dwNumGatesReturned;   // index of the last gates returned
    CSiteGateList *     m_pSiteGateList;
};


inline CConnectorQueryHandle::CConnectorQueryHandle(
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  CSiteGateList *        pSiteGateList,
                 IN  enumRequesterProtocol eRequesterProtocol
             ):  CBasicQueryHandle(eRequesterProtocol),
                 m_pSiteGateList( pSiteGateList),
                 m_dwNumGatesReturned(0)

{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
}

inline 	CConnectorQueryHandle::~CConnectorQueryHandle()
{
    delete []m_aCol;
    delete m_pSiteGateList;
}

inline DWORD  CConnectorQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CConnectorQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CCNsQueryHandle
//
//
//  This query handle is used when locating a CNs
//
//-------------------------------------------------------------------------


class CCNsQueryHandle : public CBasicQueryHandle
{
public:
    CCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CCNsQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CCNsQueryHandle::CCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CCNsQueryHandle::~CCNsQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CCNsQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CCNsQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CMqxploreCNsQueryHandle
//
//
//  This query handle is used when MQXPLORE (MSMQ 1.0) locates all CNs
//
//-------------------------------------------------------------------------


class CMqxploreCNsQueryHandle : public CBasicQueryHandle
{
public:
    CMqxploreCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CMqxploreCNsQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CMqxploreCNsQueryHandle::CMqxploreCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CMqxploreCNsQueryHandle::~CMqxploreCNsQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CMqxploreCNsQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CMqxploreCNsQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}



//-------------------------------------------------------------------------
//
//        CCNsProtocolQueryHandle
//
//
//  This query handle is used when locating all CNs that support a specific protocol
//
//-------------------------------------------------------------------------


class CCNsProtocolQueryHandle : public CBasicQueryHandle
{
public:
    CCNsProtocolQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CCNsProtocolQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CCNsProtocolQueryHandle::CCNsProtocolQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CCNsProtocolQueryHandle::~CCNsProtocolQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CCNsProtocolQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CCNsProtocolQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CFilterLinkResultsHandle
//
//
//  This query handle is used when locating site links.
//  It used to filter out site-links that are no longer valid.
//
//-------------------------------------------------------------------------


class CFilterLinkResultsHandle : public CBasicQueryHandle
{
public:
    CFilterLinkResultsHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CFilterLinkResultsHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
    ULONG               m_indexNeighbor1Column;
    ULONG               m_indexNeighbor2Column;
};


inline CFilterLinkResultsHandle::CFilterLinkResultsHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;
    m_hCursor.SetHandle( hCursor);
    m_indexNeighbor1Column = m_cCol;
    m_indexNeighbor2Column = m_cCol;
    
    for ( DWORD i = 0; i < m_cCol; i++)
    {
        if ( m_aCol[i] == PROPID_L_NEIGHBOR1)
        {
            m_indexNeighbor1Column = i;
            continue;
        }
        if ( m_aCol[i] == PROPID_L_NEIGHBOR2)
        {
            m_indexNeighbor2Column = i;
            continue;
        }
    }

}

inline 	CFilterLinkResultsHandle::~CFilterLinkResultsHandle()
{
    delete []m_aCol;
}

inline DWORD  CFilterLinkResultsHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CFilterLinkResultsHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\ipsite.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ipsite.h

Abstract:

    Definitions of CIpSite class, finding NT5 sites of a machine given IP/Name

Author:

    Raanan Harari (RaananH)

--*/

#ifndef __IPSITE_H_
#define __IPSITE_H_

#include <Ex.h>

struct IPSITE_SiteArrayEntry
{
    AP<WCHAR> pwszSiteDN;
    GUID      guidSite;
    ULONG     ulIpAddress;
};

//----------------------------------------------------------------------------
//
// Structure describing several subnets.
//
// The most significant byte of an IP address is used to index into an array
// of SubTrees.  Each Subtree entry has either a pointer to the next level of
// the tree (to be indexed into with the next byte of the IP address) or a
// pointer to an IPSITE_SUBNET leaf identifying the subnet this IP address is on.
//
// Both pointers can be NULL indicating that the subnet isn't registered.
//
// Both pointers can be non-NULL indicating that both a non-specific and specific
// subnet may be available.  The most specific subnet available for a particular
// IP address should be used.
//
//
// Multiple entries can point to the same IPSITE_SUBNET leaf.  If the subnet mask is
// not an even number of bytes long, all of the entries represent IP addresses
// that correspond to the subnet mask will point to the subnet mask.
//

//
// Structure describing a single subnet.
//
struct IPSITE_SUBNET
{
    LIST_ENTRY Next;        // Link for m_SubnetList
    ULONG SubnetAddress;    // Subnet address. (Network bytes order)
    ULONG SubnetMask;       // Subnet mask. (Network byte order)
    AP<WCHAR> SiteDN;       // DN of site this subnet is in
    GUID SiteGuid;          // guid of site this subnet is in
    ULONG ReferenceCount;   // Reference Count
    BYTE SubnetBitCount;    // Number of bits in the subnet mask
};

struct IPSITE_SUBNET_TREE;  //fwd declaration
struct IPSITE_SUBNET_TREE_ENTRY
{
    IPSITE_SUBNET_TREE *Subtree;    // Link to the next level of the tree
    IPSITE_SUBNET *Subnet;          // Pointer to the subnet itself.
};

struct IPSITE_SUBNET_TREE
{
    IPSITE_SUBNET_TREE_ENTRY Subtree[256];
};

//
// Class that holds the tree & performs the translations site/subnet/ip
//
class CIpSite
{
public:
    CIpSite();
    virtual ~CIpSite();
    HRESULT Initialize( DWORD dwMinTimeToAllowNextRefresh,
                        BOOL fReplicationMode ) ;
    HRESULT Initialize(BOOL fReplicationMode);
    HRESULT FindSiteByIpAddress(IN ULONG ulIpAddress,
                                OUT LPWSTR * ppwszSiteDN,
                                OUT GUID * pguidSite);
    HRESULT FindSitesByComputerName(IN LPCWSTR pwszComputerName,
                                    IN LPCWSTR pwszComputerDnsName,
                                    OUT IPSITE_SiteArrayEntry ** prgSites,
                                    OUT ULONG * pcSites,
                                    OUT ULONG ** prgAddrs,
                                    OUT ULONG * pcAddrs);


private:
    HRESULT FillSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
    HRESULT AddSubnetSiteToTree(IN LPCWSTR pwszSubnetName,
                                IN LPCWSTR pwszSiteDN,
                                IN const GUID * pguidSite,
                                IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
    void FindSubnetEntry(IN LPCWSTR pwszSiteDN,
                         IN const GUID * pguidSite,
                         IN ULONG ulSubnetAddress,
                         IN ULONG ulSubnetMask,
                         IN BYTE bSubnetBitCount,
                         OUT IPSITE_SUBNET** ppSubnet);
    BOOL InternalFindSiteByIpAddress(IN ULONG ulIpAddress,
                                     OUT LPWSTR * ppwszSiteDN,
                                     OUT GUID * pguidSite);

    HRESULT Refresh();
    //
    //  Refresh the subnet tree cache
    //

    static void WINAPI RefrshSubnetTreeCache(
                IN CTimer* pTimer
               );



    CCriticalSection m_csTree;     // critical section for tree manipulation
    LIST_ENTRY m_SubnetList;       // List of all IPSITE_SUBNET entries
    IPSITE_SUBNET_TREE_ENTRY m_SubnetTree;     // Tree of subnets.
    DWORD m_dwMinTimeToAllowNextRefresh; // min time between subsequent refreshes (in millisecs)

    CTimer m_RefreshTimer;
    BOOL   m_fInitialize;          // indication that initialization succedded

};

//-----------------------------
#endif //__IPSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\ldaputil.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ldaputil.cpp

Abstract:

    Utility code for use with LDAP api.

Author:

    Doron Juster (DoronJ)

--*/

#include "ds_stdh.h"
#include "adstempl.h"
#include <winldap.h>

//+-------------------------------------------------------------------------
//
//   DSCoreGetLdapError()
//
//      dwErrStringLen - length, in unicode characters, of pwszErr buffer.
//
//+-------------------------------------------------------------------------

void  DSCoreGetLdapError( IN  LDAP     *pLdap,
                          OUT DWORD    *pdwErr,
                          IN  LPWSTR    pwszErr,
                          IN  DWORD     dwErrStringLen )
{
    if ((pdwErr == NULL) || (pwszErr == NULL) || (dwErrStringLen == 0))
    {
        return ;
    }

    PWCHAR  pString = NULL ;
    pwszErr[ 0 ] = 0 ;

    ULONG lStatus = ldap_get_option( pLdap,
                                     LDAP_OPT_SERVER_ERROR,
                                     (void*) &pString) ;
    if ((lStatus == LDAP_SUCCESS) && pString)
    {
        wcsncpy(pwszErr, pString, dwErrStringLen-1) ;
        pwszErr[ dwErrStringLen-1 ] = 0 ;
        ldap_memfree(pString) ;
    }

    lStatus = ldap_get_option( pLdap,
                               LDAP_OPT_SERVER_EXT_ERROR,
                               (void*) pdwErr ) ;
    if (lStatus != LDAP_SUCCESS)
    {
        *pdwErr = 0 ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\mqadsp.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqadsp.cpp

Abstract:

    MQADS DLL private internal functions for
    DS queries, etc.

Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "notify.h"
#include "fntoken.h"
#include <_secutil.h>
#include <mqsec.h>
#include <mqdsdef.h>
#include <lmaccess.h>
#include "strsafe.h"

#include "mqadsp.tmh"

static WCHAR *s_FN=L"mqdscore/mqadsp";

// this is the CRC table for the 5213724743 (0x136C32047) polynomial, seed(p/2)=9B619023
static const unsigned long CRCTable[256] = {
 0x00000000, 0x82E0FE45, 0x3302DCCD, 0xB1E22288, 0x6605B99A,	//   0 -   4
 0xE4E547DF, 0x55076557, 0xD7E79B12, 0xCC0B7334, 0x4EEB8D71,	//   5 -   9
 0xFF09AFF9, 0x7DE951BC, 0xAA0ECAAE, 0x28EE34EB, 0x990C1663,	//  10 -  14
 0x1BECE826, 0xAED5C62F, 0x2C35386A, 0x9DD71AE2, 0x1F37E4A7,	//  15 -  19
 0xC8D07FB5, 0x4A3081F0, 0xFBD2A378, 0x79325D3D, 0x62DEB51B,	//  20 -  24
 0xE03E4B5E, 0x51DC69D6, 0xD33C9793, 0x04DB0C81, 0x863BF2C4,	//  25 -  29
 0x37D9D04C, 0xB5392E09, 0x6B68AC19, 0xE988525C, 0x586A70D4,	//  30 -  34
 0xDA8A8E91, 0x0D6D1583, 0x8F8DEBC6, 0x3E6FC94E, 0xBC8F370B,	//  35 -  39
 0xA763DF2D, 0x25832168, 0x946103E0, 0x1681FDA5, 0xC16666B7,	//  40 -  44
 0x438698F2, 0xF264BA7A, 0x7084443F, 0xC5BD6A36, 0x475D9473,	//  45 -  49
 0xF6BFB6FB, 0x745F48BE, 0xA3B8D3AC, 0x21582DE9, 0x90BA0F61,	//  50 -  54
 0x125AF124, 0x09B61902, 0x8B56E747, 0x3AB4C5CF, 0xB8543B8A,	//  55 -  59
 0x6FB3A098, 0xED535EDD, 0x5CB17C55, 0xDE518210, 0xD6D15832,	//  60 -  64
 0x5431A677, 0xE5D384FF, 0x67337ABA, 0xB0D4E1A8, 0x32341FED,	//  65 -  69
 0x83D63D65, 0x0136C320, 0x1ADA2B06, 0x983AD543, 0x29D8F7CB,	//  70 -  74
 0xAB38098E, 0x7CDF929C, 0xFE3F6CD9, 0x4FDD4E51, 0xCD3DB014,	//  75 -  79
 0x78049E1D, 0xFAE46058, 0x4B0642D0, 0xC9E6BC95, 0x1E012787,	//  80 -  84
 0x9CE1D9C2, 0x2D03FB4A, 0xAFE3050F, 0xB40FED29, 0x36EF136C,	//  85 -  89
 0x870D31E4, 0x05EDCFA1, 0xD20A54B3, 0x50EAAAF6, 0xE108887E,	//  90 -  94
 0x63E8763B, 0xBDB9F42B, 0x3F590A6E, 0x8EBB28E6, 0x0C5BD6A3,	//  95 -  99
 0xDBBC4DB1, 0x595CB3F4, 0xE8BE917C, 0x6A5E6F39, 0x71B2871F,	// 100 - 104
 0xF352795A, 0x42B05BD2, 0xC050A597, 0x17B73E85, 0x9557C0C0,	// 105 - 109
 0x24B5E248, 0xA6551C0D, 0x136C3204, 0x918CCC41, 0x206EEEC9,	// 110 - 114
 0xA28E108C, 0x75698B9E, 0xF78975DB, 0x466B5753, 0xC48BA916,	// 115 - 119
 0xDF674130, 0x5D87BF75, 0xEC659DFD, 0x6E8563B8, 0xB962F8AA,	// 120 - 124
 0x3B8206EF, 0x8A602467, 0x0880DA22, 0x9B619023, 0x19816E66,	// 125 - 129
 0xA8634CEE, 0x2A83B2AB, 0xFD6429B9, 0x7F84D7FC, 0xCE66F574,	// 130 - 134
 0x4C860B31, 0x576AE317, 0xD58A1D52, 0x64683FDA, 0xE688C19F,	// 135 - 139
 0x316F5A8D, 0xB38FA4C8, 0x026D8640, 0x808D7805, 0x35B4560C,	// 140 - 144
 0xB754A849, 0x06B68AC1, 0x84567484, 0x53B1EF96, 0xD15111D3,	// 145 - 149
 0x60B3335B, 0xE253CD1E, 0xF9BF2538, 0x7B5FDB7D, 0xCABDF9F5,	// 150 - 154
 0x485D07B0, 0x9FBA9CA2, 0x1D5A62E7, 0xACB8406F, 0x2E58BE2A,	// 155 - 159
 0xF0093C3A, 0x72E9C27F, 0xC30BE0F7, 0x41EB1EB2, 0x960C85A0,	// 160 - 164
 0x14EC7BE5, 0xA50E596D, 0x27EEA728, 0x3C024F0E, 0xBEE2B14B,	// 165 - 169
 0x0F0093C3, 0x8DE06D86, 0x5A07F694, 0xD8E708D1, 0x69052A59,	// 170 - 174
 0xEBE5D41C, 0x5EDCFA15, 0xDC3C0450, 0x6DDE26D8, 0xEF3ED89D,	// 175 - 179
 0x38D9438F, 0xBA39BDCA, 0x0BDB9F42, 0x893B6107, 0x92D78921,	// 180 - 184
 0x10377764, 0xA1D555EC, 0x2335ABA9, 0xF4D230BB, 0x7632CEFE,	// 185 - 189
 0xC7D0EC76, 0x45301233, 0x4DB0C811, 0xCF503654, 0x7EB214DC,	// 190 - 194
 0xFC52EA99, 0x2BB5718B, 0xA9558FCE, 0x18B7AD46, 0x9A575303,	// 195 - 199
 0x81BBBB25, 0x035B4560, 0xB2B967E8, 0x305999AD, 0xE7BE02BF,	// 200 - 204
 0x655EFCFA, 0xD4BCDE72, 0x565C2037, 0xE3650E3E, 0x6185F07B,	// 205 - 209
 0xD067D2F3, 0x52872CB6, 0x8560B7A4, 0x078049E1, 0xB6626B69,	// 210 - 214
 0x3482952C, 0x2F6E7D0A, 0xAD8E834F, 0x1C6CA1C7, 0x9E8C5F82,	// 215 - 219
 0x496BC490, 0xCB8B3AD5, 0x7A69185D, 0xF889E618, 0x26D86408,	// 220 - 224
 0xA4389A4D, 0x15DAB8C5, 0x973A4680, 0x40DDDD92, 0xC23D23D7,	// 225 - 229
 0x73DF015F, 0xF13FFF1A, 0xEAD3173C, 0x6833E979, 0xD9D1CBF1,	// 230 - 234
 0x5B3135B4, 0x8CD6AEA6, 0x0E3650E3, 0xBFD4726B, 0x3D348C2E,	// 235 - 239
 0x880DA227, 0x0AED5C62, 0xBB0F7EEA, 0x39EF80AF, 0xEE081BBD,	// 240 - 244
 0x6CE8E5F8, 0xDD0AC770, 0x5FEA3935, 0x4406D113, 0xC6E62F56,	// 245 - 249
 0x77040DDE, 0xF5E4F39B, 0x22036889, 0xA0E396CC, 0x1101B444,	// 250 - 254
 0x93E14A01 };

static DWORD CalHashKey( IN LPCWSTR pwcsPathName)
/*++

Routine Description:
    Calculates a hash

Arguments:
    pwcsPathName - the string on which the hash is calculated

Return Value:
    hash value.

--*/
{
	unsigned long dwCrc = 0;
    WCHAR wcsLowChar[2];
    wcsLowChar[1] = '\0';
	unsigned char * pucLowCharBuf = ( unsigned char *)wcsLowChar;

	while( *pwcsPathName != '\0' )
	{
		wcsLowChar[0] = *pwcsPathName++;
		CharLower( wcsLowChar );	// convert one char to lowercase

		// compute the CRC on hi and lo bytes
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[1] ];
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[0] ];
	}

    return( dwCrc );
}
static HRESULT MQADSpComposeName(
               IN  LPCWSTR   pwcsPrefix,
               IN  LPCWSTR   pwcsSuffix,
               OUT LPWSTR * pwcsFullName
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  compose a distinguished name of an object
    //  format : CN=prefix, suffix
    //

    DWORD LenSuffix = lstrlen(pwcsSuffix);
    DWORD LenPrefix = lstrlen(pwcsPrefix);
    DWORD Length =
            x_CnPrefixLen +                   // "CN="
            LenPrefix +                       // "pwcsPrefix"
            1 +                               //","
            LenSuffix +                       // "pwcsSuffix"
            1;                                // '\0'

    *pwcsFullName = new WCHAR[Length];

    return StringCchPrintf(*pwcsFullName, Length,
         L"%s"             // "CN="
         L"%s"             // "pwcsPrefix"
         TEXT(",")
         L"%s",            // "pwcsSuffix"
        x_CnPrefix,
        pwcsPrefix,
        pwcsSuffix
        );

}

//+-------------------------------------------------------------------------
//
//  HRESULT  GetFullComputerPathName()
//
//  Query the DS to find full computer path name (its distinguished name).
//  When called from migration tool or replication service, then we already
//  have this path. So save an extra DS query.
//
//+-------------------------------------------------------------------------

HRESULT  GetFullComputerPathName(
                IN  LPCWSTR              pwcsComputerName,
                IN  enumComputerObjType  eComputerObjType,
                IN  const DWORD          cp,
                IN  const PROPID         aProp[  ],
                IN  const PROPVARIANT    apVar[  ],
                OUT LPWSTR *             ppwcsFullPathName,
                OUT DS_PROVIDER *        pCreateProvider )
{
    for ( DWORD j = 0 ; j < cp ; j++ )
    {
        if (aProp[ j ] == PROPID_QM_MIG_GC_NAME)
        {
            ASSERT(aProp[ j-1 ] == PROPID_QM_MIG_PROVIDER) ;
            *pCreateProvider = (enum DS_PROVIDER) apVar[ j-1 ].ulVal ;

            ASSERT(aProp[ j-2 ] == PROPID_QM_FULL_PATH) ;
            *ppwcsFullPathName = newwcs(apVar[ j-2 ].pwszVal);

            return MQ_OK ;
        }
    }

    HRESULT hr = MQADSpGetFullComputerPathName( pwcsComputerName,
                                                eComputerObjType,
                                                ppwcsFullPathName,
                                                pCreateProvider ) ;
    return LogHR(hr, s_FN, 10);
}


HRESULT MQADSpCreateMachineSettings(
            IN DWORD                dwNumSites,
            IN const GUID *         pSite,
            IN LPCWSTR              pwcsPathName,
            IN BOOL                 fRouter,         // [adsrv] DWORD                dwService,
            IN BOOL                 fDSServer,
            IN BOOL                 fDepClServer,
            IN BOOL                 fSetQmOldService,
            IN DWORD                dwOldService,
            IN  const GUID *        pguidObject,
            IN  const DWORD         cpEx,
            IN  const PROPID        aPropEx[  ],
            IN  const PROPVARIANT   apVarEx[  ],
            IN  CDSRequestContext * pRequestContext
            )
/*++

Routine Description:
    This routine creates settings object in each of the server's sites.

Arguments:

Return Value:
--*/
{
    HRESULT hr = MQ_OK;
    //
    //  Prepare the attributes of the setting object
    //
    DWORD dwNumofProps = 0 ;
    PROPID aSetProp[20];
    MQPROPVARIANT aSetVar[20];

    // [adsrv] Reformat Setting properties to include new server attributes
    for ( DWORD i = 0; i< cpEx ; i++)
    {
        switch (aPropEx[i])
        {
        case PROPID_SET_SERVICE_ROUTING:
        case PROPID_SET_SERVICE_DSSERVER:
        case PROPID_SET_SERVICE_DEPCLIENTS:
        case PROPID_SET_OLDSERVICE:
            break;

        default:
            aSetProp[dwNumofProps] = aPropEx[i];
            aSetVar[dwNumofProps]  = apVarEx[i];  // yes, there may be ptrs, but no problem - apVar is here
            dwNumofProps++;
            break;
        }
    }

    // [adsrv] It was added always
    aSetProp[ dwNumofProps ] = PROPID_SET_QM_ID;
    aSetVar[ dwNumofProps ].vt = VT_CLSID;
    aSetVar[ dwNumofProps ].puuid =  const_cast<GUID *>(pguidObject);
    dwNumofProps++ ;

    // [adsrv] Now we add new server type attributes
    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_ROUTING;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fRouter;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DSSERVER;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDSServer;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DEPCLIENTS;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDepClServer;
    dwNumofProps++;

    if (fSetQmOldService)
    {
        aSetProp[dwNumofProps] = PROPID_SET_OLDSERVICE;
        aSetVar[dwNumofProps].vt   = VT_UI4;
        aSetVar[dwNumofProps].ulVal = dwOldService;
        dwNumofProps++;
    }
    // [adsrv] end

    ASSERT(dwNumofProps <= 20) ;

    WCHAR *pwcsServerNameNB = const_cast<WCHAR *>(pwcsPathName);
    AP<WCHAR> pClean;
    //
    //  Is the computer name specified in DNS format ?
    //  If so, find the NetBios name and create the server object with
    //  "netbios" name, to be compatible with the way servers objects
    //  are created by dcpromo.
    //
    WCHAR * pwcsEndMachineName = wcschr( pwcsPathName, L'.');
    if ( pwcsEndMachineName != NULL)
    {
    DWORD cbSize= pwcsEndMachineName - pwcsPathName + 1;

        pClean = new WCHAR[ cbSize ];
        hr = StringCchCopyN( pClean, cbSize, pwcsPathName, cbSize-1);
        ASSERT(SUCCEEDED(hr));
        if(FAILED(hr))return HRESULT_CODE(hr);
        pwcsServerNameNB = pClean;
    }


    //
    //  Create a settings object in each of the server's sites
    //
    for ( i = 0; i < dwNumSites ; i++)
    {
        AP<WCHAR> pwcsSiteName;
        //
        //  Translate site-id to site name
        //
        hr = MQADSpGetSiteName(
            &pSite[i],
            &pwcsSiteName
            );
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
            return LogHR(hr, s_FN, 20);
        }
        DWORD len = wcslen(pwcsSiteName);
        const WCHAR x_wcsCnServers[] =  L"CN=Servers,";
        const DWORD x_wcsCnServersLength = (sizeof(x_wcsCnServers)/sizeof(WCHAR)) -1;
        AP<WCHAR> pwcsServersContainer =  new WCHAR [ len + x_wcsCnServersLength + 1];

        hr = StringCchPrintf(pwcsServersContainer, len + x_wcsCnServersLength + 1,
                             L"%s%s",
                             x_wcsCnServers,
                             pwcsSiteName.get()
                             );
        if( FAILED(hr) )
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
            return LogHR(hr, s_FN, 25);
        }

        //
        //  create MSMQ-Setting & server in the site container
        //
        PROPID prop = PROPID_SRV_NAME;
        MQPROPVARIANT var;
        var.vt = VT_LPWSTR;
        var.pwszVal = pwcsServerNameNB;

        hr = g_pDS->CreateObject(
                eLocalDomainController,
                pRequestContext,
                MSMQ_SERVER_CLASS_NAME,  // object class
                pwcsServerNameNB,        // object name (server netbiod name).
                pwcsServersContainer,    // parent name
                1,
                &prop,
                &var,
                NULL /*pObjInfoRequest*/,
                NULL /*pParentInfoRequest*/);
        if (FAILED(hr) && ( hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) &&   //BUGBUG alexdad: to throw after transition
                          ( hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))    ) // if server object exists it is ok
        {
            //
            //  BUGBUG - to clean computer configuration
            //
            return LogHR(hr, s_FN, 30);
        }

        AP<WCHAR> pwcsServerNameDN; // full distinguished name of server.
        hr = MQADSpComposeName(
                            pwcsServerNameNB,
                            pwcsServersContainer,
                            &pwcsServerNameDN);
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
           return LogHR(hr, s_FN, 40);
        }

        hr = g_pDS->CreateObject(
                eLocalDomainController,
                pRequestContext,
                MSMQ_SETTING_CLASS_NAME,   // object class
                x_MsmqSettingName,         // object name
                pwcsServerNameDN,          // parent name
                dwNumofProps,
                aSetProp,
                aSetVar,
                NULL /*pObjInfoRequest*/,
                NULL /*pParentInfoRequest*/);

        //
        //  If the object exists :Delete the object, and re-create it
        //  ( this can happen, if msmq-configuration was deleted and
        //   msmq-settings was not)
        //
        if ( hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        {
            DWORD dwSettingLen =  wcslen(pwcsServerNameDN) +
                                  x_MsmqSettingNameLen     +
                                  x_CnPrefixLen + 2 ;
            AP<WCHAR> pwcsSettingObject = new WCHAR[ dwSettingLen ] ;

            hr = StringCchPrintf(pwcsSettingObject, dwSettingLen,
                                 L"%s%s,%s",
                                 x_CnPrefix,
                                 x_MsmqSettingName,
                                 pwcsServerNameDN.get()
                                 );
            if( FAILED(hr) )
            {
                return LogHR(hr, s_FN, 45);
            }


            hr = g_pDS->DeleteObject(
                    eLocalDomainController,
                    e_ConfigurationContainer,
                    pRequestContext,
                    pwcsSettingObject,
                    NULL,
                    NULL,
                    NULL);
            if (SUCCEEDED(hr))
            {
                hr = g_pDS->CreateObject(
                        eLocalDomainController,
                        pRequestContext,
                        MSMQ_SETTING_CLASS_NAME,   // object class
                        x_MsmqSettingName,         // object name
                        pwcsServerNameDN,          // parent name
                        dwNumofProps,
                        aSetProp,
                        aSetVar,
                        NULL /*pObjInfoRequest*/,
                        NULL /*pParentInfoRequest*/);
            }
        }
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50);
        }

    }

    return LogHR(hr, s_FN, 60);
}

HRESULT MQADSpCreateQueue(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest
                 )
/*++

Routine Description:
    This routine creates a queue object under msmqConfiguration
    of the specified computer

Arguments:
    pwcsPathName : computer-name\queue-name
    cp :           size of aProp & apVar arrays
    aProp :        ids of specified queue properties
    apVar :        values of specified properties
    pQueueInfoRequest : request for queue info for notification (can be NULL)
    pQmInfoRequest    : request for owner-QM info for notification (can be NULL)

Return Value:
--*/
{
    HRESULT hr;
    DWORD cpInternal = cp;
    const PROPID * aPropInternal =  aProp;
    const PROPVARIANT *  apVarInternal = apVar;
    //
    //  Path name format is machine1\queue1.
    //  Split it into machine name and queue name
    //
    AP<WCHAR> pwcsMachineName;
    AP<WCHAR> pwcsQueueName;

    hr = MQADSpSplitAndFilterQueueName(
                      pwcsPathName,
                      &pwcsMachineName,
                      &pwcsQueueName
                      );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    //
    //  prepare full path name of the queue
    //
    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER createProvider;

    hr =  GetFullComputerPathName( pwcsMachineName,
                                   e_MsmqComputerObject,
                                   cp,
                                   aProp,
                                   apVar,
                                  &pwcsFullPathName,
                                  &createProvider ) ;
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 80);
        return(MQ_ERROR_INVALID_OWNER);
    }
    //
    //  add MSMQ-configuration
    //
    AP<WCHAR> pwcsMsmq;
    hr = MQADSpComposeName(
            x_MsmqComputerConfiguration,
            pwcsFullPathName,
            &pwcsMsmq
            );
    //
    //  Is the queue-name within the size limit of CN
    //
    DWORD len = wcslen(pwcsQueueName);
    WCHAR * pwcsPrefixQueueName = pwcsQueueName;
    AP<WCHAR> pwcsCleanPrefixQueueName;
    AP<WCHAR> pwcsSuffixQueueName;
    AP<PROPID> pCleanPropid;
    AP<PROPVARIANT> pCleanPropvariant;

    if ( len > x_PrefixQueueNameLength)
    {
        //
        //  Split the queue name
        //
        pwcsCleanPrefixQueueName = new WCHAR[ x_PrefixQueueNameLength + 1 + 1];
        DWORD dwSuffixLength =  len - ( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength);
        pwcsSuffixQueueName = new WCHAR[ dwSuffixLength + 1];
        pwcsPrefixQueueName =  pwcsCleanPrefixQueueName;
        memcpy( pwcsCleanPrefixQueueName, pwcsQueueName, (x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength) * sizeof(WCHAR));
        DWORD dwHash = CalHashKey(pwcsQueueName);
        hr = StringCchPrintf( pwcsCleanPrefixQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
                              x_SplitQNameIdLength+1,
                              L"-%08x",
                              dwHash);
        ASSERT(SUCCEEDED(hr));

        pwcsCleanPrefixQueueName[x_PrefixQueueNameLength + 1 ] = '\0';
        memcpy( pwcsSuffixQueueName , (pwcsQueueName + x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength), dwSuffixLength * sizeof(WCHAR));
        pwcsSuffixQueueName[ dwSuffixLength] = '\0';

        //
        //  insert the name suffix to the arrays of props and varaints
        //
        pCleanPropid = new PROPID[ cp + 1];
        pCleanPropvariant = new PROPVARIANT[ cp + 1];
        memcpy( pCleanPropid, aProp, sizeof(PROPID) * cp);
        memcpy( pCleanPropvariant, apVar, sizeof(PROPVARIANT) * cp);
        cpInternal = cp + 1;
        aPropInternal = pCleanPropid;
        apVarInternal = pCleanPropvariant;
        pCleanPropid[cp] =  PROPID_Q_NAME_SUFFIX;
        pCleanPropvariant[cp].vt = VT_LPWSTR;
        pCleanPropvariant[cp].pwszVal = pwcsSuffixQueueName;

    }


    hr = g_pDS->CreateObject(
            createProvider,
            pRequestContext,
            MSMQ_QUEUE_CLASS_NAME,   // object class
            pwcsPrefixQueueName,     // object name
            pwcsMsmq,   // msmq-configuration name
            cpInternal,
            aPropInternal,
            apVarInternal,
            pQueueInfoRequest,
            pQmInfoRequest);

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQ_ERROR_INVALID_OWNER, s_FN, 90);
    }

    return LogHR(hr, s_FN, 100);

}

HRESULT MQADSpCreateEnterprise(
                 IN  LPCWSTR            /*pwcsPathName*/,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    //
    //  Create MSMQ-service under configuration\services
    //
    //  Note - the caller supplied path-name is ignored,
    //  the object is created with
    //
    hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SERVICE_CLASS_NAME,   // object class
            x_MsmqServicesName,     // object name
            g_pwcsServicesContainer,
            cp,
            aProp,
            apVar,
            NULL /*pObjInfoRequest*/,
            NULL /*pParentInfoRequest*/);


    return LogHR(hr, s_FN, 110);

}


HRESULT MQADSpCreateSiteLink(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest,
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:
    This routine creates a site-link object. For that
    it composes the link name from the two site ids.

Arguments:

Return Value:
--*/
{
    //
    //  NO pathname is supplied
    //
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);

    //
    //  The link path name will be composed
    //  from the ids of the sites it links.
    //
    GUID * pguidNeighbor1 = NULL;
    GUID * pguidNeighbor2 = NULL;
    DWORD dwToFind = 2;
    for (DWORD i = 0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_L_NEIGHBOR1)
        {
            pguidNeighbor1 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
        if ( aProp[i] == PROPID_L_NEIGHBOR2)
        {
            pguidNeighbor2 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
    }
    ASSERT( pguidNeighbor1 != NULL);
    ASSERT( pguidNeighbor2 != NULL);
    //
    //  cn has a size limit of 64.
    //  Therefore guid format is without '-'
    //

const WCHAR x_GUID_FORMAT[] = L"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x";
const DWORD x_GUID_STR_LENGTH = (8 + 4 + 4 + 4 + 12 + 1);

    WCHAR strUuidSite1[x_GUID_STR_LENGTH];
    HRESULT hr = StringCchPrintf(
        strUuidSite1,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor1->Data1, pguidNeighbor1->Data2, pguidNeighbor1->Data3,
        pguidNeighbor1->Data4[0], pguidNeighbor1->Data4[1],
        pguidNeighbor1->Data4[2], pguidNeighbor1->Data4[3],
        pguidNeighbor1->Data4[4], pguidNeighbor1->Data4[5],
        pguidNeighbor1->Data4[6], pguidNeighbor1->Data4[7]
        );


    if( FAILED(hr))
    {
		TrERROR(DS, "strUuidSite1 - Buffer Overflow");
		return MQ_ERROR;
    }

    WCHAR strUuidSite2[x_GUID_STR_LENGTH];
    hr = StringCchPrintf(
        strUuidSite2,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor2->Data1, pguidNeighbor2->Data2, pguidNeighbor2->Data3,
        pguidNeighbor2->Data4[0], pguidNeighbor2->Data4[1],
        pguidNeighbor2->Data4[2], pguidNeighbor2->Data4[3],
        pguidNeighbor2->Data4[4], pguidNeighbor2->Data4[5],
        pguidNeighbor2->Data4[6], pguidNeighbor2->Data4[7]
        );

    if( FAILED(hr) )
    {
		TrERROR(DS, "strUuidSite2 - Buffer Overflow");
		return MQ_ERROR;
    }

    //
    //  The link name will start with the smaller site id
    //
    WCHAR strLinkName[2 * x_GUID_STR_LENGTH + 1];
    if ( wcscmp( strUuidSite1, strUuidSite2) < 0)
    {
        hr = StringCchPrintf(strLinkName, 2 * x_GUID_STR_LENGTH + 1,
                             L"%s%s",
                             strUuidSite1,
                             strUuidSite2
                             );

    }
    else
    {
        hr = StringCchPrintf(strLinkName, 2 * x_GUID_STR_LENGTH + 1,
                             L"%s%s",
                             strUuidSite2,
                             strUuidSite1
                             );
    }

    if( FAILED(hr) )
    {
		TrERROR(DS, "StringCchPrintf error");
		return MQ_ERROR;
    }

    //
    //  Create the link object under msmq-service
    //
    hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SITELINK_CLASS_NAME,   // object class
            strLinkName,     // object name
            g_pwcsMsmqServiceContainer,
            cp,
            aProp,
            apVar,
            pObjectInfoRequest,
            pParentInfoRequest);



    return LogHR(hr, s_FN, 120);
}


HRESULT MQADSpGetQueueProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
   AP<WCHAR> pwcsFullPathName;
   HRESULT hr = MQ_OK;

   DS_PROVIDER WhichDCProvider = eLocalDomainController;   // either local-DC or DC
   if  (pwcsPathName)
   {
        //
        //  Path name format is machine1\queue1.
        //  expand machine1 name to a full computer path name
        //
        hr =  MQADSpComposeFullPathName(
                MQDS_QUEUE,
                pwcsPathName,
                &pwcsFullPathName,
                &WhichDCProvider
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 130);
        }
    }
    //
    //  Try to retrieve properties from the local DC,
    //  if failed try the GC.
    //
    //  For most operation this will not add overhead.
    //  This solve problems like create queue on a DC which is not
    //  a GC followed by open queue. The open queue will succeed with
    //  out the GC replication delay.
    //

    BOOL firstTry = TRUE;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
            eLocalDomainController,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
        firstTry = FALSE;
    }
    if ( firstTry ||
        (pwcsPathName == NULL))
    {
        //
        //  We may get here:
        //  1) Queue's name == NULL ( in this case
        //     we didn't expand the queue name, and if it was not found on
        //     local-DC we try once more.
        //  2) Queue's name != NULL, and while expanding the queue name it was
        //     not found in the local-DC
        //
         hr = g_pDS->GetObjectProperties(
                eGlobalCatalog,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);

    }
    return LogHR(hr, s_FN, 140);

}

static HRESULT MQADSpGetCnNameAndProtocol(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext*  pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pwcsPathName);
    ASSERT((cp == 2) &&
           (aProp[0] == PROPID_CN_PROTOCOLID) &&
           ( aProp[1] == PROPID_CN_NAME));

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);

    //
    //  Get the site name and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 2;
    PROPID prop[cNumProperties] = { PROPID_S_FOREIGN, PROPID_S_PATHNAME};

    HRESULT hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        NULL,      // object name
            pguidIdentifier,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    //
    //  Return CN protocol id according site's foreign
    //
    ASSERT( prop[0] ==  PROPID_S_FOREIGN);
    apVar[0].vt = VT_UI1;
    if ( apVar[0].bVal != 0)
    {
        //
        //  It is a foreign site
        //
        apVar[0].bVal = FOREIGN_ADDRESS_TYPE;
    }
    else
    {
        //
        //  Assume IP address ( no support of IPX)
        //
        apVar[0].bVal = IP_ADDRESS_TYPE;
    }

    return LogHR(hr, s_FN, 150);
}

static HRESULT MQADSpGetCnGuidAndProtocol(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext *pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pguidIdentifier);
    ASSERT((cp == 2) &&
           (aProp[0] == PROPID_CN_GUID) &&
           ( aProp[1] == PROPID_CN_PROTOCOLID));

    ASSERT(pwcsPathName);

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);
    //
    //  Expand the site name into a full path name
    //
    HRESULT hr;
    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER dsTmp;
    hr =  MQADSpComposeFullPathName(
                MQDS_SITE,
                pwcsPathName,
                &pwcsFullPathName,
                &dsTmp
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }


    //
    //  Get the site guid and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 2;
    PROPID prop[cNumProperties] = { PROPID_S_SITEID, PROPID_S_FOREIGN };

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        pwcsFullPathName,      // object name
            NULL,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    //
    //  Return CN protocol id according site's foreign
    //
    ASSERT( prop[1] ==  PROPID_S_FOREIGN);
    apVar[1].vt = VT_UI1;
    if ( apVar[1].bVal != 0)
    {
        //
        //  It is a foreign site
        //
        apVar[1].bVal = FOREIGN_ADDRESS_TYPE;
    }
    else
    {
        //
        //  Assume IP address ( no support of IPX)
        //
        apVar[1].bVal = IP_ADDRESS_TYPE;
    }

    return LogHR(hr, s_FN, 170);
}


static HRESULT MQADSpGetCnName(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pwcsPathName);
    ASSERT((cp == 1) &&
           ( aProp[0] == PROPID_CN_NAME));

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);

    //
    //  Get the site name and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 1;
    PROPID prop[cNumProperties] = {  PROPID_S_PATHNAME};

    HRESULT hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        NULL,      // object name
            pguidIdentifier,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    return LogHR(hr, s_FN, 180);
}


HRESULT MQADSpGetCnProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  A limited support for backward compatability
    //

    if (( cp == 1) &&
        (aProp[0] == PROPID_CN_NAME))
    {
        //
        //  retrieve CN name
        //
        HRESULT hr2 = MQADSpGetCnName(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 190);

    }

    if ( ( cp == 2) &&
         (aProp[0] == PROPID_CN_PROTOCOLID) &&
         (aProp[1] == PROPID_CN_NAME))
    {
        //
        //  retrieve CN name and protocol
        //
        HRESULT hr2 = MQADSpGetCnNameAndProtocol(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 200);

    }

    if ((cp == 2) && (aProp[0] == PROPID_CN_GUID)
            && ( aProp[1] == PROPID_CN_PROTOCOLID))
    {
        ASSERT(pwcsPathName);
        ASSERT(!pguidIdentifier);

        //
        //  retrieve CN guid and protocol
        //
        HRESULT hr2 = MQADSpGetCnGuidAndProtocol(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 210);

    }

    if ((cp == 3)                     &&
        (aProp[0] == PROPID_CN_NAME)  &&
        (aProp[1] == PROPID_CN_GUID)  &&
        (aProp[2] == PROPID_CN_PROTOCOLID))
    {
        //
        // This query is done by nt4 mqxplore, after creating a foreign cn.
        // first retrieve guid, then internal name.
        //
        ASSERT(pwcsPathName) ;
        ASSERT(!pguidIdentifier) ;

        HRESULT hr2 = MQADSpGetCnGuidAndProtocol(
                                pwcsPathName,
                                pguidIdentifier,
                                2,
                               &(aProp[1]),
                                pRequestContext,
                               &(apVar[1]) ) ;
        if (FAILED(hr2))
        {
            return LogHR(hr2, s_FN, 1180);
        }

        GUID *pGuid = apVar[1].puuid ;

        hr2 = MQADSpGetCnName( pwcsPathName,
                               pGuid,
                               1,
                               aProp,
                               pRequestContext,
                               apVar );
        return LogHR(hr2, s_FN, 1190);
    }

    ASSERT(0) ;
    return LogHR(MQ_ERROR, s_FN, 220);
}


HRESULT MQADSpGetMachineProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;

    //
    // workaround - if no identifier is supplied for machine, get the
    // DS Server machine itself.
    //
    if ( (pwcsPathName == NULL) &&
         (pguidIdentifier == NULL))
    {
        pguidIdentifier = &g_guidThisServerQMId;
    }
    //
    //  Workaround
    //  This Get request is initiated by servers to learn on which
    //  addresses they should listen for topology broadcasts.
    //  It is important to  return all the addresses of the server.
    //
    //  Therefore ignore the protocol on which the RPC call was received,
    //  and return all the server's addresses
    //
    if ( ( cp == 3) &&
         ( aProp[0] == PROPID_QM_ADDRESS) &&
         ( aProp[1] == PROPID_QM_CNS) &&
         ( aProp[2] == PROPID_QM_SITE_ID))
    {
        pRequestContext->SetAllProtocols();
    }


    DS_PROVIDER WhichDCProvider = eLocalDomainController; // either local-DC or DC

    if  (pwcsPathName)
    {
        //
        //  Get full computer pathname
        //

        hr =  MQADSpComposeFullPathName(
                        MQDS_MACHINE,
                        pwcsPathName,
                        &pwcsFullPathName,
                        &WhichDCProvider
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 230);
        }

    }
    //
    //  Decide provider according to requested properties
    //
    DS_PROVIDER dsProvider = MQADSpDecideComputerProvider( cp, aProp);

    hr = MQDS_OBJECT_NOT_FOUND;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    //
    //  if we found the computer on the local-DC : get properties from it.
    //  ( it doesn't matter if  dsProvider is GC or not)
    //
    BOOL firstTry = TRUE;
    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
        firstTry = FALSE;
    }
    if ( firstTry ||
        (pwcsPathName == NULL))
    {
        //
        //  We may get here:
        //  1) Computer's name == NULL ( in this case
        //     we didn't expand the queue name, and if it was not found on
        //     local-DC we try once more.
        //  2) Computer's name != NULL, and while expanding the queue name it was
        //     not found in the local-DC
        //

        hr = g_pDS->GetObjectProperties(
                dsProvider,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
    }

    //
    //  BUGBUG - to add return code filtering
    //
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 240);
    }

    return LogHR(hr, s_FN, 250);

}

HRESULT MQADSpGetComputerProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;


    DS_PROVIDER WhichDCProvider = eLocalDomainController; // either local-DC or DC

    if  (pwcsPathName)
    {
        //
        //  Get full computer pathname
        //

        hr =  MQADSpGetFullComputerPathName(
                        pwcsPathName,
                        e_RealComputerObject,
                        &pwcsFullPathName,
                        &WhichDCProvider
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 260);
        }

    }
    hr = MQDS_OBJECT_NOT_FOUND;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    //
    //  if we found the computer on the local-DC : get properties from it.
    //  ( it doesn't matter if  dsProvider is GC or not)
    //
    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
    }
    hr = g_pDS->GetObjectProperties(
            eGlobalCatalog,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 270);
    }

    return LogHR(hr, s_FN, 280);

}


HRESULT MQADSpGetEnterpriseProperties(
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    //
    //  Note - pwcsPathName is ignored.
    //  Enterprise object is allways located
    //  under g_pwcsServicesContainer
    //
    //  Ignore  pguidIdentifier, this is done in order to over come
    //  changes of enterprise guid.
    //
    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,	
            pRequestContext,
 	        g_pwcsMsmqServiceContainer, // object name
            NULL,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 290);

}



HRESULT MQADSpQuerySiteFRSs(
                 IN  const GUID *         pguidSiteId,
                 IN  DWORD                dwService,
                 IN  ULONG                relation,
                 IN  const MQCOLUMNSET *  pColumns,
                 IN  CDSRequestContext *  pRequestContext,
                 OUT HANDLE         *     pHandle)
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    *pHandle = NULL;

    //
    //  Find all the FRSs under pguidSiteId site
    //
    MQRESTRICTION restrictionFRS;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionFRS.cRes = 1;
    restrictionFRS.paPropRes = &propertyRestriction;

    // [adsrv] start
    // The comment above is not exact - it is either finding FRSs, or finding DS servers.
    // To find FRSs, MSMQ1 uses PRGE with SERVICE_SRV
    // To find DS servers, MSMQ1 uses PRGT with SERVICE_SRV.
    // Explorer used also PRNE, but MSMQ2 B2 ignored it and it was OK, so ignoring too.
    // We must provide both.

    propertyRestriction.rel = PRNE;
    propertyRestriction.prval.ulVal = 0;   //VARIANT_BOOL boolVal
    propertyRestriction.prval.vt = VT_UI1;

    if (relation == PRGT)
    {
        // MSMQ1 was looking for DS Servers (>SERVICE_SRV)
        ASSERT(dwService == SERVICE_SRV);
        propertyRestriction.prop = PROPID_SET_SERVICE_DSSERVER;
    }
    else
    {
        // MSMQ1 was looking for FRSs (>=SERVICE_SRV)
        ASSERT(relation == PRGE);
        ASSERT(dwService == SERVICE_SRV);
        propertyRestriction.prop = PROPID_SET_SERVICE_ROUTING;
    }
    // [adsrv] end
    UNREFERENCED_PARAMETER( dwService);

    PROPID  prop = PROPID_SET_QM_ID;

    HANDLE hCursor;

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            pRequestContext,
            pguidSiteId,
            &restrictionFRS,
            NULL,
            1,
            &prop,
            &hCursor	        // result handle
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 300);
    }
    //
    // keep the result for lookup next
    //
    CRoutingServerQueryHandle * phQuery = new CRoutingServerQueryHandle(
                                              pColumns,
                                              hCursor,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;

    return(MQ_OK);

}



HRESULT MQADSpFilterSiteGates(
              IN  const GUID *      pguidSiteId,
              IN  const DWORD       dwNumGatesToFilter,
              IN  const GUID *      pguidGatesToFilter,
              OUT DWORD *           pdwNumGatesFiltered,
              OUT GUID **           ppguidGatesFiltered
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    HRESULT hr;
    *pdwNumGatesFiltered = 0;
    *ppguidGatesFiltered = NULL;

    //
    //  Find all the FRSs under pguidSiteId site
    //
    MQRESTRICTION restrictionFRS;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionFRS.cRes = 1;
    restrictionFRS.paPropRes = &propertyRestriction;

    propertyRestriction.rel = PRNE;
    propertyRestriction.prop = PROPID_SET_SERVICE_ROUTING;
    propertyRestriction.prval.vt = VT_UI1;
    propertyRestriction.prval.ulVal = 0;

    PROPID  prop = PROPID_SET_QM_ID;

    CDsQueryHandle hCursor;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            &requestDsServerInternal,     // should be performed according to DS server rights
            pguidSiteId,
            &restrictionFRS,
            NULL,
            1,
            &prop,
            hCursor.GetPtr()
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    DWORD cp;
    MQPROPVARIANT var;
    DWORD   dwNumGates = 0;
    AP<GUID> pguidGates = new GUID[ dwNumGatesToFilter];

    while (SUCCEEDED(hr))
    {
        //
        //  retrieve unique id of one FRS
        //
        cp = 1;
        var.vt = VT_NULL;
        hr = g_pDS->LocateNext(
                hCursor.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 320);
        }
        if ( cp == 0)   // no more results
        {
            break;
        }
        //
        //  is the FRS one of the site-gates
        //
        for ( DWORD j = 0; j < dwNumGatesToFilter; j++)
        {
            if( pguidGatesToFilter[j] == *var.puuid)
            {
                //
                //  verify that the msmq-setting object is not a duplicate
                //  ( this can happen, when the server object is morphed)
                //
                BOOL fAlreadyFound = FALSE;
                for ( DWORD k = 0; k < dwNumGates; k++)
                {
                    if (  pguidGates[k] == *var.puuid)
                    {
                        fAlreadyFound = TRUE;
                        break;
                    }
                }
                if (fAlreadyFound)
                {
                    break;
                }
                //
                //  copy into temporary buffer
                //
                pguidGates[ dwNumGates] = *var.puuid;
                dwNumGates++;
                break;

            }
        }
        delete var.puuid;
    }
    //
    //  return results
    //
    if ( dwNumGates)
    {
        *ppguidGatesFiltered = new GUID[ dwNumGates];
        memcpy( *ppguidGatesFiltered, pguidGates, sizeof(GUID) * dwNumGates);
        *pdwNumGatesFiltered = dwNumGates;
    }
    return(MQ_OK);

}

static HRESULT MQADSpGetUniqueIdOfComputer(
                IN  LPCWSTR             pwcsCNComputer,
                IN  CDSRequestContext * pRequestContext,
                OUT GUID* const         pguidId,
                OUT BOOL* const         pfServer,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    AP<WCHAR> pwcsFullPathName;

    hr = MQADSpComposeFullPathName(
                MQDS_MACHINE,
                pwcsCNComputer,
                &pwcsFullPathName,
                pSetAndDeleteProvider
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 330);
    }
    //
    //  Read the following two properties
    //


    PROPID  prop[] = {PROPID_QM_MACHINE_ID,
                      PROPID_QM_SERVICE_ROUTING,
                      PROPID_QM_SERVICE_DSSERVER};   // [adsrv] PROPID_QM_SERVICE
    const DWORD x_count = sizeof(prop)/sizeof(prop[0]);

    MQPROPVARIANT var[x_count];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;

    hr = g_pDS->GetObjectProperties(
                eGlobalCatalog,	
                pRequestContext,
 	            pwcsFullPathName,
                NULL,
                x_count,
                prop,
                var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }
    ASSERT( prop[0] == PROPID_QM_MACHINE_ID);
    P<GUID> pClean = var[0].puuid;
    *pguidId = *var[0].puuid;
    ASSERT( prop[1] == PROPID_QM_SERVICE_ROUTING);   // [adsrv] PROPID_QM_SERVICE
    ASSERT( prop[2] == PROPID_QM_SERVICE_DSSERVER);
    *pfServer = ( (var[1].bVal!=0) || (var[2].bVal!=0));  // [adsrv] SERVICE_SRV
    return(MQ_OK);
}

HRESULT MQADSpDeleteMachineObject(
                IN LPCWSTR           pwcsPathName,
                IN const GUID *      pguidIdentifier,
                IN CDSRequestContext * pRequestContext
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  If the computer is MSMQ server, then delete MSMQ-setting
    //  of that computer also.
    //
    HRESULT hr;
    GUID guidComputerId;
    BOOL fServer;

    DS_PROVIDER deleteProvider = eDomainController; // assumption - until we know more
    if ( pwcsPathName)
    {
        ASSERT( pguidIdentifier == NULL);
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = MQADSpGetUniqueIdOfComputer(
                    pwcsPathName,
                    &requestDsServerInternal,     // DS server operation
                    &guidComputerId,
                    &fServer,
                    &deleteProvider
                    );
        if (FAILED(hr))
        {
            TrWARNING(DS, "MQADSpDeleteMachineObject : cannot find computer %ls",pwcsPathName);
            return LogHR(hr, s_FN, 350);
        }
    }
    else
    {
        ASSERT( pwcsPathName == NULL);
        guidComputerId = *pguidIdentifier;
        //
        //  Assume it is a server
        //
        fServer = TRUE;
    }
    //
    //  BUGBUG - transaction !!!
    //

    //
    //  First delete queues
    //
    hr = g_pDS->DeleteContainerObjects(
            deleteProvider,
            e_RootDSE,
            pRequestContext,
            NULL,
            &guidComputerId,
            MSMQ_QUEUE_CLASS_NAME);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 360);
    }

    //
    //  delete MSMQ-configuration object
    //
    if (!(pRequestContext->IsKerberos()))
    {
        //
        // Wow, what's this for ???
        // look in DSCoreDeleteObject for details.
        //
        // Specific comments for uninstall of msmq:
        // When calling DeleteContainerObjects() above, we're binding with
        // guid, so use eDomainController, because server binding
        // (LDAP://server/guid=...) would eventually fail when calling
        // pContainer->Delete(queue).
        // But DeleteObject() use distinguished name, so here we must use
        // server binding if called from nt4 user.
        //
        deleteProvider = eLocalDomainController;
    }

    hr = g_pDS->DeleteObject(
                    deleteProvider,
                    e_RootDSE,
                    pRequestContext,
                    NULL,
                    &guidComputerId,
                    NULL /*pObjInfoRequest*/,
                    NULL /*pParentInfoRequest*/);
    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF))
        {
            return LogHR(MQDS_E_MSMQ_CONTAINER_NOT_EMPTY, s_FN, 370);
        }
        return LogHR(hr, s_FN, 380);
    }
    //
    //  delete MSMQ-setting
    //
    if ( fServer)
    {
        hr = MQADSpDeleteMsmqSetting(
                        &guidComputerId,
                        pRequestContext
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 390);
        }
    }
    return(MQ_OK);
}

HRESULT MQADSpComposeFullPathName(
                IN const DWORD          dwObjectType,
                IN LPCWSTR              pwcsPathName,
                OUT LPWSTR *            ppwcsFullPathName,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr = MQ_OK;
    *ppwcsFullPathName = NULL;
    *pSetAndDeleteProvider = eDomainController;

    switch( dwObjectType)
    {
        case MQDS_USER:
            ASSERT( pwcsPathName == NULL);
            hr = MQ_OK;
            break;

        case MQDS_QUEUE:
            {
                //
                //  complete the machine name to full computer path name
                //
                //  Path name format is machine1\queue1.
                //  Split it into machine name and queue name
                //
                AP<WCHAR> pwcsMachineName;
                AP<WCHAR> pwcsQueueName;

                hr = MQADSpSplitAndFilterQueueName(
                                  pwcsPathName,
                                  &pwcsMachineName,
                                  &pwcsQueueName
                                  );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 4400);
                }

                AP<WCHAR> pwcsFullComputerName;

                hr = MQADSpGetFullComputerPathName(
                                pwcsMachineName,
                                e_MsmqComputerObject,
                                &pwcsFullComputerName,
                                pSetAndDeleteProvider);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 400);
                }
                //
                //  concatenate msmq-configuration to the computer name
                //
                AP<WCHAR> pwcsMsmq;
                hr = MQADSpComposeName(
                        x_MsmqComputerConfiguration,
                        pwcsFullComputerName,
                        &pwcsMsmq
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 410);
                }
                //
                //  Does the queue-name exceeds the limit ?
                //
                DWORD len = wcslen(pwcsQueueName);
                if ( len == x_PrefixQueueNameLength + 1)
                {
                    //
                    //  Special case : we cannot differntiate
                    //  if the original queue name was 64, or if this is
                    //  the morphed queue name.
                    //

                    hr = MQADSpComposeFullQueueName(
                            pwcsMsmq,
                            pwcsQueueName,
                            ppwcsFullPathName
                            );
                    if (FAILED(hr))
                    {
                        return LogHR(hr, s_FN, 420);
                    }
                    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
                    hr = g_pDS->DoesObjectExists(
                                eDomainController,
                                e_RootDSE,
                                &requestDsServerInternal, // internal DS server operation
                                *ppwcsFullPathName
                                );
                    if (SUCCEEDED(hr))
                    {
                        return(hr);
                    }

                }
                if (len > x_PrefixQueueNameLength )
                {
                    //
                    //  Queue name was splitted to two attributes
                    //
                    //  Calculate the prefix part ( ASSUMMING unique
                    //  hash function)
                    //
                    DWORD dwHash = CalHashKey(pwcsQueueName);
                    //
                    //  Over-write the buffer
                    hr = StringCchPrintf(
                             pwcsQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
                             x_SplitQNameIdLength+1,
                             L"-%08x",
                             dwHash);
                    if( FAILED(hr) )
                    {
                        return LogHR(hr, s_FN, 425);
                    }
                }

                //
                //  concatenate  queue name
                //
                hr = MQADSpComposeFullQueueName(
                            pwcsMsmq,
                            pwcsQueueName,
                            ppwcsFullPathName
                            );
            }
            break;
        case MQDS_MACHINE:
            {
                //
                //  Retrieve full computer name
                //
                AP<WCHAR> pwcsComputerName;
                hr = MQADSpGetFullComputerPathName(
                            pwcsPathName,
                            e_MsmqComputerObject,
                            &pwcsComputerName,
                            pSetAndDeleteProvider);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 430);
                }
                hr =  MQADSpComposeName(
                            x_MsmqComputerConfiguration,
                            pwcsComputerName,
                            ppwcsFullPathName
                            );


            }
            break;

        case MQDS_SITE:
        case MQDS_CN:
            //
            // Full site path name.
            // MQDS_CN is supported for update of security of foreign sites.
            //
            hr =   MQADSpComposeName(
                        pwcsPathName,
                        g_pwcsSitesContainer,       // the site name
                        ppwcsFullPathName
                        );
            *pSetAndDeleteProvider = eLocalDomainController;
            break;

        case MQDS_ENTERPRISE:
            {
                DWORD len = lstrlen( g_pwcsMsmqServiceContainer);
                *ppwcsFullPathName = new WCHAR[ len + 1];
                hr = StringCchCopy( *ppwcsFullPathName, len+1, g_pwcsMsmqServiceContainer);
                ASSERT(SUCCEEDED(hr));
                if(FAILED(hr))return HRESULT_CODE(hr);
                *pSetAndDeleteProvider = eLocalDomainController;
            }
            break;
        case MQDS_SITELINK:
            {
                DWORD Length =
                        x_CnPrefixLen +                     // "CN="
                        wcslen(pwcsPathName) +              // the site-link name
                        1 +                                 //","
                        wcslen(g_pwcsMsmqServiceContainer)+ // "enterprise object"
                        1;                                  // '\0'

                *ppwcsFullPathName = new WCHAR[Length];

                hr = StringCchPrintf(*ppwcsFullPathName, Length,
                                    L"%s"             // "CN="
                                    L"%s"             // "the site-link name"
                                    TEXT(",")
                                    L"%s",            // "enterprise object"
                                    x_CnPrefix,
                                    pwcsPathName,
                                    g_pwcsMsmqServiceContainer.get()
                                    );

                *pSetAndDeleteProvider = eLocalDomainController;
            };
            break;


        default:
            ASSERT(0);
            hr = MQ_ERROR;
            break;
    }
    return LogHR(hr, s_FN, 440);
}

const WCHAR x_limitedChars[] = {L'\n',L'/',L'#',L'>',L'<', L'=', 0x0a, 0};
const DWORD x_numLimitedChars = sizeof(x_limitedChars)/sizeof(WCHAR) - 1;

/*====================================================
    FilterSpecialCharaters()
    Pares the object (queue) name and add escape character before limited chars

    If pwcsOutBuffer is NULL, the function allocates a new buffer and return it as
    return value. Otherwise, it uses pwcsOutBuffer, and return it. If pwcsOutBuffer is not
    NULL, it should point to a buffer of lenght dwNameLength*2 +1, at least.

  NOTE: dwNameLength does not contain existing escape characters, if any
=====================================================*/
WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer /* = 0 */,
            OUT    DWORD_PTR* pdwCharactersProcessed /* = 0 */)

{
    AP<WCHAR> pBufferToRelease;
    LPWSTR pname;

    if (pwcsOutBuffer != 0)
    {
        pname = pwcsOutBuffer;
    }
    else
    {
        pBufferToRelease = new WCHAR[ (dwNameLength *2) + 1];
        pname = pBufferToRelease;
    }

    const WCHAR * pInChar = pwcsObjectName;
    WCHAR * pOutChar = pname;
    for ( DWORD i = 0; i < dwNameLength; i++, pInChar++, pOutChar++)
    {
        //
        // Ignore current escape characters
        //
        if (*pInChar == L'\\')
        {
            *pOutChar = *pInChar;
            pOutChar++;
            pInChar++;
        }
        else
        {
            //
            // Add backslash before special characters, unless it was there
            // already.
            //
            if ( 0 != wcschr(x_limitedChars, *pInChar))
            {
                *pOutChar = L'\\';
                pOutChar++;
            }
        }

        *pOutChar = *pInChar;
    }
    *pOutChar = L'\0';

    pBufferToRelease.detach();

    if (pdwCharactersProcessed != 0)
    {
        *pdwCharactersProcessed = pInChar - pwcsObjectName;
    }
    return( pname);
}


HRESULT MQADSpSplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    if (pwcsPathName == NULL)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4450);
    }

    DWORD dwLen = lstrlen( pwcsPathName);
    LPCWSTR pChar= pwcsPathName + dwLen;


    //
    //  Skip the queue name
    //
    for (DWORD i = dwLen  ; i  ; i--, pChar--)
    {
        if (*pChar == PN_DELIMITER_C)
        {
            break;
        }
    }

    if (i == 0)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4470);
    }

    AP<WCHAR> pwcsMachineName = new WCHAR [i + 1];

    memcpy( pwcsMachineName, pwcsPathName, sizeof(WCHAR)* i);
    pwcsMachineName[i] = '\0';

    AP<WCHAR> pwcsQueueName = FilterSpecialCharacters((pwcsPathName + i + 1), dwLen - i - 1);


    *ppwcsMachineName = pwcsMachineName.detach();
    *ppwcsQueueName = pwcsQueueName.detach();
    return(MQ_OK);
}

//+----------------------------------------------
//
//  HRESULT SearchFullComputerPathName()
//
//+----------------------------------------------

HRESULT SearchFullComputerPathName(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN	LPCWSTR					pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName,
			OUT bool*						pfPartialMatch
            )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr2 = g_pDS->FindComputerObjectFullPath(
            provider,
            eComputerObjType,
			pwcsComputerDnsName,
            pRestriction,
            ppwcsFullPathName,
			pfPartialMatch
            );
    return LogHR(hr2, s_FN, 450);

}



HRESULT MQADSpGetFullComputerPathName(
                IN  LPCWSTR              pwcsComputerName,
                IN  enumComputerObjType  eComputerObjType,
                OUT LPWSTR *             ppwcsFullPathName,
                OUT DS_PROVIDER *        pCreateProvider
                )
/*++

Routine Description:

Arguments:
    eComputerObjType - indicate which computer object we're looking for.
      There is a "built-in" problem in mix-mode, or when a computer move
      between domains, that you may find two computers objects that represent
      the same single physical computer. In most cases, the msmqConfiguration
      object will be found under the computer object that was the first one
      created in the active directory forest.
      In that case, sometimes we need the object that contain the
      msmqConfiguration object and some other times we need the "real"
      computer object that represent the "real" physical computer in its
      present domain.
      For example- when looking for the "trust-for-delegation" bit, we want
      the "real" object, while when creating queues, we look for the computer
      object that contain the msmqConfiguration object.


Return Value:
    pProvider - if the object was found when performing the query
                against the local DC : eLocalDomainController,
                else eDomainController. This information is for create purposes.
--*/
{
    HRESULT hr;
    *pCreateProvider = eLocalDomainController;
    const WCHAR * pwcsComputerCN =  pwcsComputerName;
    const WCHAR * pwcsFullDNSName = NULL;
    AP<WCHAR> pwcsNetbiosName;
    //
    //   If computer name is specified in DNS format:
    //      perform a query according to the Netbios part of the computer
	//		dns name
    //
    //	 In both cases the query is comparing the netbios name + $
	//	to the samAccountName attribute of computer objects

    WCHAR * pwcsEndMachineCN = wcschr( pwcsComputerName, L'.');
    //
    //  Is the computer name is specified in DNS format
    //
    DWORD len, len1;
    if (pwcsEndMachineCN != NULL)
    {
        pwcsFullDNSName = pwcsComputerName;
        len1 = numeric_cast<DWORD>(pwcsEndMachineCN - pwcsComputerName);
    }
	else
    {
		len1 = wcslen(pwcsComputerCN);
    }

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    len = __min(len1, MAX_COM_SAM_ACCOUNT_LENGTH);

    pwcsNetbiosName = new WCHAR[len + 2];
    hr = StringCchCopyN(pwcsNetbiosName, len+1, pwcsComputerName, len);
    ASSERT(SUCCEEDED(hr));
    if(FAILED(hr))return HRESULT_CODE(hr);

    pwcsNetbiosName[len] = L'$';
    pwcsNetbiosName[len + 1] = L'\0';

    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prval.vt = VT_LPWSTR;
	propRestriction.prval.pwszVal = pwcsNetbiosName;
    propRestriction.prop = PROPID_COM_SAM_ACCOUNT;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

	bool fDCPartialMatch = false;

    //
    //  First perform the operation against the local domain controller
    //  then against the global catalog.
    //
    //  The purpose of this is to be able to "find" queue or machine
    //  that were created or modified on the local domain, and not
    //  yet replicated to the global catalog.
	//
	// if DNS information is suplied, NT4 machines will return fPartialMatch == true since they don't have DNS name in the AD.
	// in this case we will try to see if can find a perfect match (also a DNS match) against a .NET server by searching the also the GC.
    //
    hr = SearchFullComputerPathName(
            eLocalDomainController,
            eComputerObjType,
			pwcsFullDNSName,
            &restriction,
            ppwcsFullPathName,
			&fDCPartialMatch
            );

	if (SUCCEEDED(hr) && !fDCPartialMatch)
	{
		//
		// Found exact match
		//
		return LogHR(hr, s_FN, 460);
	}

	HRESULT hrDC = hr;
	bool fGCPartialMatch = false;
	AP<WCHAR> GCFullPathName;

    hr = SearchFullComputerPathName(
            eGlobalCatalog,
            eComputerObjType,
			pwcsFullDNSName,
            &restriction,
            &GCFullPathName,
			&fGCPartialMatch
            );

	if(SUCCEEDED(hrDC) && ((FAILED(hr) || fGCPartialMatch)))
	{
		//
		// We found partial matches in DC. We prefer the DC partial match over no match or a partial match in the GC
		//
		return LogHR(MQ_OK, s_FN, 460);
	}

	if(SUCCEEDED(hr))
	{
		//
		// We prefer a perfect match in the GC over no match or a partial match in the DC.
		// We prefer a partial match in the GC over no match in the DC.
		//
		delete [] *ppwcsFullPathName;
		*ppwcsFullPathName = GCFullPathName.detach();
	}

    *pCreateProvider = eDomainController;

    return LogHR(hr, s_FN, 460);
}

HRESULT MQADSpComposeFullQueueName(
                        IN  LPCWSTR        pwcsMsmqConfigurationName,
                        IN  LPCWSTR        pwcsQueueName,
                        OUT LPWSTR *       ppwcsFullPathName
                        )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  compose a distinguished name of a queue object
    //  format : CN=queue-name, msmq-configuration-distinguished name
    //

    DWORD LenComputer = lstrlen(pwcsMsmqConfigurationName);
    DWORD LenQueue = lstrlen(pwcsQueueName);
    DWORD Length =
            x_CnPrefixLen +                     // "CN="
            LenQueue +                          // "pwcsQueueName"
            1 +                                 //","
            LenComputer +                       // "pwcsMsmqConfigurationName"
            1;                                  // '\0'

    AP<WCHAR> apPath = new WCHAR[Length];

    HRESULT hr = StringCchPrintf(apPath, Length,
                                L"%s"             // "CN="
                                L"%s"             // "pwcsQueueName"
                                TEXT(",")
                                L"%s",            // "pwcsFullComputerNameName"
                                x_CnPrefix,
                                pwcsQueueName,
                                pwcsMsmqConfigurationName
                                );

    if( SUCCEEDED(hr) )
    {
        *ppwcsFullPathName = apPath.detach();
    }
    else
    {
        *ppwcsFullPathName = NULL;
    }
    return hr;
}




HRESULT MQADSpInitDsPathName()
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    AP<WCHAR> pwcsSchemaContainer;

    hr = g_pDS->GetRootDsName(
        &g_pwcsDsRoot,
        &g_pwcsLocalDsRoot,
        &pwcsSchemaContainer,
        &g_pwcsConfigurationContainer
        );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    //
    //  build services, sites and msmq-service path names
    //
    DWORD ConfigLen = wcslen(g_pwcsConfigurationContainer);

    g_pwcsServicesContainer = new WCHAR[ConfigLen +  x_ServicePrefixLen + 2];
    hr = StringCchPrintf(g_pwcsServicesContainer, ConfigLen +  x_ServicePrefixLen + 2,
                         L"%s"
                         TEXT(",")
                         L"%s",
                         x_ServicesPrefix,
                         g_pwcsConfigurationContainer.get()
                         );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 474);
    }

    g_pwcsMsmqServiceContainer = new WCHAR[ConfigLen + x_MsmqServicePrefixLen + 2];
    hr = StringCchPrintf(g_pwcsMsmqServiceContainer, ConfigLen + x_MsmqServicePrefixLen + 2,
                        L"%s"
                        TEXT(",")
                        L"%s",
                        x_MsmqServicePrefix,
                        g_pwcsConfigurationContainer.get()
                        );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 476);
    }

    g_pwcsSitesContainer = new WCHAR[ConfigLen +  x_SitesPrefixLen + 2];
    hr = StringCchPrintf(g_pwcsSitesContainer, ConfigLen +  x_SitesPrefixLen + 2,
                        L"%s"
                        TEXT(",")
                        L"%s",
                        x_SitesPrefix,
                        g_pwcsConfigurationContainer.get()
                        );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 478);
    }

	TrTRACE(DS, "DsRoot = %ls", g_pwcsDsRoot.get());
	TrTRACE(DS, "LocalDsRoot = %ls", g_pwcsLocalDsRoot.get());
	TrTRACE(DS, "SchemaContainer = %ls", pwcsSchemaContainer.get());
	TrTRACE(DS, "ConfigurationContainer = %ls", g_pwcsConfigurationContainer.get());
	TrTRACE(DS, "ServicesContainer = %ls", g_pwcsServicesContainer.get());
	TrTRACE(DS, "MsmqServiceContainer = %ls", g_pwcsMsmqServiceContainer.get());
	TrTRACE(DS, "SitesContainer = %ls", g_pwcsSitesContainer.get());

    //
    //  prepare the different object category names
    //
    DWORD len = wcslen( pwcsSchemaContainer);


    for ( DWORD i = e_MSMQ_COMPUTER_CONFIGURATION_CLASS; i < e_MSMQ_NUMBER_OF_CLASSES; i++)
    {
        *g_MSMQClassInfo[i].ppwcsObjectCategory = new WCHAR[ len + g_MSMQClassInfo[i].dwCategoryLen + 2];
        hr = StringCchPrintf(*g_MSMQClassInfo[i].ppwcsObjectCategory,
                             len + g_MSMQClassInfo[i].dwCategoryLen + 2,
                             L"%s"
                             TEXT(",")
                             L"%s",
                             g_MSMQClassInfo[i].pwcsCategory,
                             pwcsSchemaContainer.get()
                            );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 479);
        }
    }

    return(MQ_OK);
}



HRESULT MQADSpFilterAdsiHResults(
                         IN HRESULT hrAdsi,
                         IN DWORD   dwObjectType)
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    switch ( hrAdsi)
    {
        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):  //BUGBUG alexdad to throw after transition
        {
        //
        //  Object exists
        //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                return LogHR(MQ_ERROR_QUEUE_EXISTS, s_FN, 480);
                break;
            case MQDS_SITELINK:
                return LogHR(MQDS_E_SITELINK_EXISTS, s_FN, 490);
                break;
            case MQDS_USER:
                return LogHR(MQ_ERROR_INTERNAL_USER_CERT_EXIST, s_FN, 500);
                break;
            case MQDS_MACHINE:
            case MQDS_MSMQ10_MACHINE:
                return LogHR(MQ_ERROR_MACHINE_EXISTS, s_FN, 510);
                break;
            case MQDS_COMPUTER:
                return LogHR(MQDS_E_COMPUTER_OBJECT_EXISTS, s_FN, 520);
                break;
            default:
                return LogHR(hrAdsi, s_FN, 530);
                break;
            }
        }
        break;

        case HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        {
        //
        //  Object not found
        //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 540);
                break;
           case MQDS_MACHINE:
           case MQDS_MSMQ10_MACHINE:
                return LogHR(MQ_ERROR_MACHINE_NOT_FOUND, s_FN, 550);
                break;
            default:
                return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 560);
                break;
            }
        }
        break;

        case E_ADS_BAD_PATHNAME:
        {
            //
            //  wrong pathname
            //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                //
                // creating queue with not allowed chars
                //
                return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 570);
                break;

            default:
                return LogHR(hrAdsi, s_FN, 580);
                break;
            }

        }
        break;

        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 590);

            break;

        //
        // This is an internal warning that should not be returned out of the DS.
        // Returning it will cause NT4 Explorer to fail (Bug 3778, YoelA, 3-Jan-99)
        //
        case MQSec_I_SD_CONV_NOT_NEEDED:
            return(MQ_OK);
            break;

        default:
            return LogHR(hrAdsi, s_FN, 600);
            break;
    }
}


HRESULT  MQADSpDeleteMsmqSetting(
              IN const GUID *        pguidComputerId,
              IN CDSRequestContext * pRequestContext
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = const_cast<GUID*>(pguidComputerId);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpDeleteMsmqSetting : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 610);
    }
    //
    //  Read the results ( choose the first one)
    //

    DWORD cp = 1;
    MQPROPVARIANT var;
	HRESULT hr1 = MQ_OK;


    while (SUCCEEDED(hr))
	{
		var.vt = VT_NULL;

		hr  = g_pDS->LocateNext(
					hQuery.GetHandle(),
					&requestDsServerInternal,
					&cp,
					&var
					);
		if (FAILED(hr))
		{
			TrWARNING(DS, "MQADSpDeleteMsmqSetting : Locate next failed %lx",hr);
            return LogHR(hr, s_FN, 620);
		}
		if ( cp == 0)
		{
			//
			//  Not found -> nothing to delete.
			//
			return(MQ_OK);
		}
		AP<WCHAR> pClean = var.pwszVal;
		//
		//  delete the msmq-setting object
		//
		hr1 = g_pDS->DeleteObject(
						eLocalDomainController,
						e_ConfigurationContainer,
						pRequestContext,
						var.pwszVal,
						NULL,
						NULL /*pObjInfoRequest*/,
						NULL /*pParentInfoRequest*/
						);
		if (FAILED(hr1))
		{
			//
			//	just report it, and continue to next object
			//
			TrWARNING(DS, "MQADSpDeleteMsmqSetting : failed to delete %ls, hr = %lx", var.pwszVal, hr1);
		}
	}

    return LogHR(hr1, s_FN, 630);
}


DS_PROVIDER MQADSpDecideComputerProvider(
             IN  const DWORD   cp,
             IN  const PROPID  aProp[  ]
             )
/*++

Routine Description:
    The routine decides to retrieve the computer
    properties from the domain-controller or the
    global catalog.

Arguments:
    cp :    number of propids on aProp parameter
    aProp : array of PROPIDs

Return Value:
    the DS_PROVIDER on which to perform the retrieve
    operation

--*/
{
    const MQTranslateInfo* pTranslateInfo;
    const PROPID * pProp = aProp;

    for ( DWORD i = 0; i < cp; i++, pProp++)
    {
        if (g_PropDictionary.Lookup( *pProp, pTranslateInfo))
        {
            if ((!pTranslateInfo->fPublishInGC) &&
                 (pTranslateInfo->vtDS != ADSTYPE_INVALID))
            {
                return( eDomainController);
            }
        }
        else
        {
            ASSERT(0);
        }
    }
    return( eGlobalCatalog);
}


HRESULT MQADSpCreateComputer(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR            **ppwcsFullPathName
                 )
/*++

Routine Description:
    The routine creates computer object in the DS.
    Falcon creates computer object:
    1. During setup of Win95, if there isn't a computer
       object. Or setup of computer that belong to a nt4 domain so its
       computer object is not in the win2k active directory.
    2. During migration ( stub-computer objects) for
       computers that aren't in the DS.
    3. During replication between NT4 and Win2K (replication service).
    4. For Cluster virtual server.

Arguments:
    cp :    number of propids on aProp and apVar parameter
    aProp : array of PROPIDs
    apVar : array of propvariant
    cpEx  : number of extended aPropEx and apVarEx
    aPropEx : array of PROPIDs
    apVarEx : array of propvariants
    pRequestContext:
    ppwcsFullPathName:

Return Value:
    the DS_PROVIDER on which to perform the retrieve
    operation

--*/
{
    //
    //  The user can specify ( in the extended props) the
    //  container under which the computer object will be created
    //
    LPCWSTR  pwcsParentPathName;
    HRESULT  hr = S_OK;
    if ( cpEx > 0)
    {
        ASSERT( cpEx == 1);
        ASSERT( aPropEx[0] == PROPID_COM_CONTAINER);
        ASSERT( apVarEx[0].vt == VT_LPWSTR);
        if (aPropEx[0] !=  PROPID_COM_CONTAINER)
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 640);
        }
        pwcsParentPathName = apVarEx[0].pwszVal;
    }
    else
    {
        //
        //  we create the computer object in default container
        //
        static WCHAR * s_pwcsComputersContainer = NULL;
        if ( s_pwcsComputersContainer == NULL)
        {
            DWORD len = wcslen( g_pwcsLocalDsRoot) + x_ComputersContainerPrefixLength + 2;
            s_pwcsComputersContainer = new WCHAR [len];
            hr = StringCchPrintf(s_pwcsComputersContainer, len,
                                L"%s"             // "CN=Computers"
                                TEXT(",")
                                L"%s",            // g_pwcsDsRoot
                                x_ComputersContainerPrefix,
                                g_pwcsLocalDsRoot.get()
                                );
            if( FAILED(hr ))
            {
                return LogHR(hr, s_FN, 645);
            }
        }
        pwcsParentPathName =  s_pwcsComputersContainer;
    }

    //
    //  verify that  PROPID_COM_ACCOUNT_CONTROL is one of the properties
    //  if not add it ( otherwise MMC display red X on the computer
    //  object
    //
    BOOL fNeedToAddAccountControl = TRUE;
    for (DWORD i = 0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_COM_ACCOUNT_CONTROL)
        {
            fNeedToAddAccountControl = FALSE;
            break;
        }
    }
    DWORD dwCreateNum = cp;
    PROPID * pCreateProps = const_cast<PROPID *>(aProp);
    PROPVARIANT * pCreateVar = const_cast<PROPVARIANT *>(apVar);

    AP<PROPID> pNewProps;
    AP<PROPVARIANT> pNewVars;

    if ( fNeedToAddAccountControl)
    {
        pNewProps = new PROPID[ cp + 1];
        pNewVars = new PROPVARIANT[ cp + 1];
        memcpy( pNewProps, aProp, sizeof(PROPID) * cp);
        memcpy( pNewVars, apVar, sizeof(PROPVARIANT) * cp);
        //
        //  Set  PROPID_COM_ACCOUNT_CONTROL
        //
        pNewProps[ cp] = PROPID_COM_ACCOUNT_CONTROL;
        pNewVars[ cp].vt = VT_UI4;
        pNewVars[ cp].ulVal =  DEFAULT_COM_ACCOUNT_CONTROL;
        dwCreateNum = cp + 1;
        pCreateProps = pNewProps;
        pCreateVar = pNewVars;
    }

    DS_PROVIDER dsProvider = eDomainController ;
    if (!(pRequestContext->IsKerberos()))
    {
        //
        // Wow, what's that for ???
        // look in DSCoreDeleteObject for details.
        //
        dsProvider = eLocalDomainController ;
    }

    hr = g_pDS->CreateObject(
            dsProvider,
            pRequestContext,
            MSMQ_COMPUTER_CLASS_NAME,
            pwcsPathName,
            pwcsParentPathName,
            dwCreateNum,
            pCreateProps,
            pCreateVar,
            NULL /* pObjInfoRequest*/,
            NULL /* pParentInfoRequest*/);

    if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
    {
        return LogHR(hr, s_FN, 650);
    }

    //
    //  Get full path name
    //
    AP<WCHAR> pFullPathName;
    hr = MQADSpComposeName(pwcsPathName, pwcsParentPathName, &pFullPathName);

    if (SUCCEEDED(hr))
    {
        //
        // Grant the user creating the computer account the permission to
        // create child object (msmqConfiguration). that was done by the
        // DS itself by default up to beta3, and then disabled.
        // Ignore errors. If caller is admin, then the security setting
        // is not needed. If he's a non-admin, then you can always use
        // mmc and grant this permission manually. so go on even if this
        // call fail.
        //
        HRESULT hr1 = DSCoreSetOwnerPermission( pFullPathName,
                        (ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD) ) ;
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 48);

        if (ppwcsFullPathName != NULL)
        {
            (*ppwcsFullPathName) = pFullPathName.detach();
        }
    }

    return LogHR(hr, s_FN, 655);
}


HRESULT MQADSpTranslateLinkNeighbor(
                 IN  const GUID *    pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR**         ppwcsSiteDn)
/*++

Routine Description:
    The routine trnslate site id to site-DN.

Arguments:
    pguidSiteId:        the site id
    ppwcsSiteDn:        the site DN

Return Value:
    DS error codes

--*/
{
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;

    var.vt = VT_NULL;
    HRESULT hr = g_pDS->GetObjectProperties(
                    eLocalDomainController,	
                    pRequestContext,
 	                NULL,      // object name
                    pguidSiteId,      // unique id of object
                    1,
                    &prop,
                    &var);
    if (SUCCEEDED(hr))
    {
        *ppwcsSiteDn= var.pwszVal;
    }
    return LogHR(hr, s_FN, 660);
}


HRESULT MQADSpCreateSite(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        /*cpEx*/,
                 IN  const PROPID *      /*aPropEx[  ]*/,
                 IN  const PROPVARIANT*  /*apVarEx[  ]*/,
                 IN  CDSRequestContext *pRequestContext
                 )
/*++

Routine Description:
    This routine creates a site.

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SITE_CLASS_NAME,   // object class
            pwcsPathName,     // object name
            g_pwcsSitesContainer,
            cp,
            aProp,
            apVar,
            NULL /*pObjInfoRequest*/,
            NULL /*pParentInfoRequest*/);

   return LogHR(hr, s_FN, 670);
}


HRESULT  MQADSpDeleteMsmqSettingOfServerInSite(
              IN const GUID *        pguidComputerId,
              IN const WCHAR *       pwcsSite
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = const_cast<GUID*>(pguidComputerId);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpDeleteMsmqSetting : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 680);
    }
    //
    //  Read the results ( choose the first one)
    //
    while ( SUCCEEDED(hr))
    {
        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 690);
        }
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to delete.
            //
            return(MQ_OK);
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  Get the parent, which is the server object
        //
        AP<WCHAR> pwcsServerName;
        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            var.pwszVal,
            &pwcsServerName);
        if (FAILED(hr))
        {
            continue;
        }
        AP<WCHAR> pwcsServer;

        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            pwcsServerName,
            &pwcsServer);
        if (FAILED(hr))
        {
            continue;
        }
        //
        //  Get site name
        //
        AP<WCHAR> pwcsSiteDN;

        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            pwcsServer,
            &pwcsSiteDN);
        if (FAILED(hr))
        {
            continue;
        }

        //
        //  Is it the correct site
        //
        DWORD len = wcslen(pwcsSite);
        if ( (!wcsncmp( pwcsSiteDN + x_CnPrefixLen, pwcsSite, len)) &&
             ( pwcsSiteDN[ x_CnPrefixLen + len] == L',') )
        {

            //
            //  delete the msmq-setting object
            //
            hr = g_pDS->DeleteObject(
                            eLocalDomainController,
                            e_ConfigurationContainer,
                            &requestDsServerInternal,
                            var.pwszVal,
                            NULL,
                            NULL /*pObjInfoRequest*/,
                            NULL /*pParentInfoRequest*/
                            );
            break;
        }
    }

    return LogHR(hr, s_FN, 700);
}



HRESULT MQADSpSetMachinePropertiesWithSitesChange(
            IN  const  DWORD         dwObjectType,
            IN  DS_PROVIDER          provider,
            IN  CDSRequestContext *  pRequestContext,
            IN  LPCWSTR              lpwcsPathName,
            IN  const GUID *         pguidUniqueId,
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
            )
/*++

Routine Description:
    This routine creates a site.

Arguments:

Return Value:
--*/
{
    //
    //  First let's verify that this is a server and the
    //  current sites it belongs to
    //
    const DWORD cNum = 6;
    PROPID prop[cNum] = { PROPID_QM_SERVICE_DSSERVER,
                          PROPID_QM_SERVICE_ROUTING,
                          PROPID_QM_SITE_IDS,
                          PROPID_QM_MACHINE_ID,
                          PROPID_QM_PATHNAME,
                          PROPID_QM_OLDSERVICE};
    PROPVARIANT var[cNum];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    var[3].vt = VT_NULL;
    var[4].vt = VT_NULL;
    var[5].vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    HRESULT hr1 =  g_pDS->GetObjectProperties(
            eLocalDomainController,		
            &requestDsServerInternal,
 	        lpwcsPathName,
            pguidUniqueId,
            cNum,
            prop,
            var);
    if (FAILED(hr1))
    {
        hr1 =  g_pDS->GetObjectProperties(
            eGlobalCatalog,		
            &requestDsServerInternal,
 	        lpwcsPathName,
            pguidUniqueId,
            cNum,
            prop,
            var);
        if (FAILED(hr1))
        {
            return LogHR(hr1, s_FN, 710);
        }
    }
    AP<GUID> pguidOldSiteIds = var[2].cauuid.pElems;
    DWORD dwNumOldSites = var[2].cauuid.cElems;
    P<GUID> pguidMachineId = var[3].puuid;
    AP<WCHAR> pwcsMachineName = var[4].pwszVal;
    BOOL fNeedToOrganizeSettings = FALSE;

    if ( var[0].bVal > 0 ||   // ds server
         var[1].bVal > 0)     // routing server
    {
        fNeedToOrganizeSettings = TRUE;
    }

    //
    //  Set the machine properties
    //
    HRESULT hr;
    hr = g_pDS->SetObjectProperties(
                    provider,
                    pRequestContext,
                    lpwcsPathName,
                    pguidUniqueId,
                    cp,
                    pPropIDs,
                    pPropVars,
                    pObjInfoRequest
                    );

    MQADSpFilterAdsiHResults( hr, dwObjectType);

    if ( FAILED(hr) ||
         !fNeedToOrganizeSettings)
    {
        return LogHR(hr, s_FN, 720);
    }

    //
    //  Compare the old and new site lists
    //  and delete or create msmq-settings accordingly
    //
    GUID * pguidNewSiteIds = pPropVars[dwSiteIdsIndex].cauuid.pElems;
    DWORD dwNumNewSites = pPropVars[dwSiteIdsIndex].cauuid.cElems;

    for (DWORD i = 0; i <  dwNumNewSites; i++)
    {
        //
        //  Is it a new site
        //
        BOOL fOldSite = FALSE;
        for (DWORD j = 0; j < dwNumOldSites; j++)
        {
            if (pguidNewSiteIds[i] == pguidOldSiteIds[j])
            {
                fOldSite = TRUE;
                //
                // to indicate that msmq-setting should be left in this site
                //
                pguidOldSiteIds[j] = GUID_NULL;
                break;
            }
        }
        if ( !fOldSite)
        {
            //
            //  create msmq-setting in this new site
            //
            hr1 = MQADSpCreateMachineSettings(
                        1,  // number sites
                        &pguidNewSiteIds[i], // site guid
                        pwcsMachineName,
                        var[1].bVal > 0, // fRouter
                        var[0].bVal > 0, // fDSServer
                        TRUE,            // fDepClServer
                        TRUE,            // fSetQmOldService
                        var[5].ulVal,    // dwOldService
                        pguidMachineId,
                        0,               // cpEx
                        NULL,            // aPropEx
                        NULL,            // apVarEx
                        &requestDsServerInternal
                        );
            //
            //  ignore the error
			//	
			//	For foreign site this operation will always fail, because
			//	we don't create servers container and server objects for foreign sites.
			//
			//	For non-foreign sites, we just try the best we can.
            //
        }
    }
    //
    //  Go over th list of old site and for each old site that
    //  is not in-use, delete the msmq-settings
    //
    for ( i = 0; i < dwNumOldSites; i++)
    {
        if (pguidOldSiteIds[i] != GUID_NULL)
        {
            PROPID propSite = PROPID_S_PATHNAME;
            PROPVARIANT varSite;
            varSite.vt = VT_NULL;

            hr1 = g_pDS->GetObjectProperties(
                        eLocalDomainController,		
                        &requestDsServerInternal,
 	                    NULL,
                        &pguidOldSiteIds[i],
                        1,
                        &propSite,
                        &varSite);
            if (FAILED(hr1))
            {
                ASSERT(SUCCEEDED(hr1));
                LogHR(hr1, s_FN, 1611);
                continue;
            }
            AP<WCHAR> pCleanSite = varSite.pwszVal;

            //
            //  delete the msmq-setting in this site
            //
            hr1 = MQADSpDeleteMsmqSettingOfServerInSite(
                        pguidMachineId,
                        varSite.pwszVal
                        );
            ASSERT(SUCCEEDED(hr1));
            LogHR(hr1, s_FN, 1612);

        }
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\ipsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ipsite.cpp

Abstract:

    Implementation of CIpSite class, finding NT5 sites of a machine given IP/Name
    Major parts ported from NT5 netlogon service.
    List manipulation ported from nthack.h

    About the main algorithm ported from netlogon service (nlsite.c):

    The most significant byte of an IP address is used to index into an array
    of SubTrees.  Each Subtree entry has either a pointer to the next level of
    the tree (to be indexed into with the next byte of the IP address) or a
    pointer to an IPSITE_SUBNET leaf identifying the subnet this IP address is on.

    Both pointers can be NULL indicating that the subnet isn't registered.

    Both pointers can be non-NULL indicating that both a non-specific and specific
    subnet may be available.  The most specific subnet available for a particular
    IP address should be used.

    Multiple entries can point to the same IPSITE_SUBNET leaf.  If the subnet mask is
    not an even number of bytes long, all of the entries represent IP addresses
    that correspond to the subnet mask will point to the subnet mask.


Author:

    Raanan Harari (RaananH)
    Ilan Herbst    (ilanh)   9-July-2000

--*/

#include "ds_stdh.h"
#include "uniansi.h"
#include <activeds.h>
#include <winsock.h>
#include "dsutils.h"
#include "mqads.h"
#include "ipsite.h"
#include "mqdsname.h"
#include "_mqini.h"
#include "_registr.h"
#include "coreglb.h"
#include "utils.h"
#include "ex.h"
#include "autoclean.h"
#include "no.h"
#include "strsafe.h"
#include <adsiutl.h>

#include "ipsite.tmh"


static WCHAR *s_FN=L"mqdscore/ipsite";

//----------------------------------------------------------------------------

const LPCWSTR x_IPSITE_SUBNETS_DN = L"LDAP://CN=Subnets,CN=Sites,";

//----------------------------------------------------------------------------
// fwd static function declaration
//
static HRESULT ParseSubnetString(IN LPCWSTR pwszSubnetName,
                                 OUT ULONG * pulSubnetAddress,
                                 OUT ULONG * pulSubnetMask,
                                 OUT BYTE  * pbSubnetBitCount);
static void RefSubnet(IPSITE_SUBNET* pSubnet);
static void DerefSubnet(IPSITE_SUBNET* pSubnet);
static void DeleteSubnetSiteTree(IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi);
static HRESULT GetConfigurationDN(OUT LPWSTR * ppwszConfigDN);
//BUGBUG: move func below to utils.h & use it in conversions
static HRESULT VariantGuid2Guid(IN VARIANT * pvarGuid, OUT GUID * pguid);
//BUGBUG: move func below to utils.h, maybe someone needs it
/*====================================================
DestructElements of LPCWSTR
=====================================================*/
template<>
static void AFXAPI DestructElements(LPCWSTR* ppDNs, int n)
{
    for ( ; n--; )
        delete[] (WCHAR*)*ppDNs++;
}

/*====================================================
CompareElements  of LPCWSTR
=====================================================*/
template<>
static BOOL AFXAPI  CompareElements(const LPCWSTR* pwszDN1, const LPCWSTR* pwszDN2)
{
    return (CompareStringsNoCaseUnicode(*pwszDN1, *pwszDN2) == 0);
}

/*====================================================
HashKey  of LPCWSTR
=====================================================*/
template<>
UINT AFXAPI HashKey(LPCWSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}


/*====================================================
CGetSiteGuidFromDN - This class is used to convert DN Name to GUID.
    it keeps a cache of the names, and update it from ADSI
    when needed. (QFE 5462, YoelA, 16-Aug-2000)
=====================================================*/
class CGetSiteGuidFromDN
{
public:
    HRESULT GetSiteGuidFromDN(IN LPWSTR pwszDN, OUT GUID * pguid);

private:
    CMap<LPCWSTR, LPCWSTR, GUID, const GUID&> m_DNToGuidMap;

    HRESULT GetGuidFromDNInAdsi(IN LPCWSTR pwszDN, OUT GUID * pguid);
};


//----------------------------------------------------------------------------
//taken from nthack.h
//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry);
//
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//  VOID RemoveEntryList(PLIST_ENTRY Entry);
//
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//----------------------------------------------------------------------------
//helper auto classes

class CAutoEnumerator
/*++
    Auto release of IEnumVARIANT interface
--*/
{
public:
    CAutoEnumerator::CAutoEnumerator()
    {
        m_p = NULL;
    }

    CAutoEnumerator::~CAutoEnumerator()
    {
        if (m_p)
            ADsFreeEnumerator(m_p);
    }

    operator IEnumVARIANT*() const {return m_p;}
    IEnumVARIANT ** operator&()    {return &m_p;}
private:
    IEnumVARIANT * m_p;
};


class CAutoDerefSubnet
/*++
    Auto deref of subnet
--*/
{
public:
    CAutoDerefSubnet(
        CCriticalSection * pcCritSect,
        IPSITE_SUBNET* pSubnet
        )
    {
        m_pcCritSect = pcCritSect;
        m_pSubnet = pSubnet;
    }

    ~CAutoDerefSubnet()
    {
        CS lock(*m_pcCritSect);
        DerefSubnet(m_pSubnet);
    }

private:
    CCriticalSection * m_pcCritSect;
    IPSITE_SUBNET* m_pSubnet;
};


class CAutoDeleteSubnetTree
/*++
    Auto delete of subnets tree
--*/
{
public:
    CAutoDeleteSubnetTree(
        CCriticalSection * pcCritSect,
        IPSITE_SUBNET_TREE_ENTRY* pSubnetTree
        )
    {
        m_pSubnetTree = pSubnetTree;
        m_pcCritSect = pcCritSect;
    }

    ~CAutoDeleteSubnetTree()
    {
        if (m_pSubnetTree)
        {
            CS lock(*m_pcCritSect);
            DeleteSubnetSiteTree(m_pSubnetTree);
        }
    }

    IPSITE_SUBNET_TREE_ENTRY* detach()
    {
        IPSITE_SUBNET_TREE_ENTRY* pRetSubnetTree = m_pSubnetTree;
        m_pSubnetTree = NULL;
        return pRetSubnetTree;
    }

private:
    CCriticalSection * m_pcCritSect;
    IPSITE_SUBNET_TREE_ENTRY* m_pSubnetTree;
};


//----------------------------------------------------------------------------
//CIpSite implementation

CIpSite::CIpSite() :
        m_RefreshTimer(RefrshSubnetTreeCache),
        m_fInitialize(FALSE)
/*++

Routine Description:
    Class consructor. Sets the tree to an empty tree

Arguments:
    None

Return Value:
    None

--*/
{
    InitializeListHead(&m_SubnetList);
    ZeroMemory(&m_SubnetTree, sizeof(IPSITE_SUBNET_TREE_ENTRY));
    m_dwMinTimeToAllowNextRefresh = 0;
}


CIpSite::~CIpSite()
/*++

Routine Description:
    Class destructor. Deletes the subnet tree
    (also debug verifies there are no subnets left around)

Arguments:
    None

Return Value:
    None

--*/
{
    DeleteSubnetSiteTree(&m_SubnetTree);

    //
    // following list should be empty
    //
    // ISSUE-2000-08-22-yoela
    //         Initialize wakes up every hour (by default - can be changed using
    //         DSAdsRefreshIPSitesIntervalSecs in registry). If it happens to wake up
    //         during cleanup, the assert will be fired. g_pcIpSite is not protected
    //         by critical section to avoid that.
    //
    //         Bug # 5937
    //
    ASSERT(IsListEmpty(&m_SubnetList));

	ExCancelTimer(&m_RefreshTimer);
}


HRESULT CIpSite::Initialize(DWORD dwMinTimeToAllowNextRefresh,
                            BOOL  fReplicationMode)
/*++

Routine Description:
    Basic initialization. Fills the tree with information from the DS

Arguments:
    dwMinTimeToAllowNextRefresh -
        specify a period of time (in milliseconds) that has to pass since the last
        refresh in order to honor a subsequent refresh request.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // remember minimum time to allow next refresh
    //
    m_dwMinTimeToAllowNextRefresh = dwMinTimeToAllowNextRefresh;

    //
    // update the site tree from DS
    //
    hr = Refresh();
    if (FAILED(hr))
    {
        TrERROR(DS, "CIpSite::Initialize:Refresh()=%lx", hr);
        return LogHR(hr, s_FN, 10);
    }
    m_fInitialize = TRUE;

    //
    //  schedule a refresh of the subnet-tree-cache
	//
	if ( !g_fSetupMode && !fReplicationMode)
    {
	    ExSetTimer(
			&m_RefreshTimer,
			CTimeDuration::FromMilliSeconds(m_dwMinTimeToAllowNextRefresh)
			);
    }

    return S_OK;
}


HRESULT CIpSite::Initialize(BOOL fReplicationMode)
/*++

Routine Description:
    Basic initialization as above, but gets the interval from registry

Arguments:

Return Value:
    HRESULT

--*/
{
    //
    // Read minimum interval between successive ADS searches (seconds)
    //
    DWORD dwValue;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwDefault = MSMQ_DEFAULT_IPSITE_ADSSEARCH_INTERVAL ;
    LONG rc = GetFalconKeyValue( MSMQ_IPSITE_ADSSEARCH_INTERVAL_REGNAME,
                                 &dwType,
                                 &dwValue,
                                 &dwSize,
                                 (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        ASSERT(0);
        dwValue = dwDefault;
    }

    //
    // convert to millisec and initialize
    //
    dwValue *= 1000;
    HRESULT hr2 = Initialize(dwValue, fReplicationMode) ;
    return LogHR(hr2, s_FN, 20);

}


HRESULT CIpSite::Refresh()
/*++

Routine Description:
    This routine updates the tree of subnets. It uses a temporary tree, then
    sets the real tree with the temporary one

Arguments:
    None

Return Value:
    S_OK    - refresh was done
    S_FALSE - refresh was not done because last refresh operation was done very recently
               (i.e. done at less than m_dwMinTimeToAllowNextRefresh msecs ago)
    other HRESULT errors

--*/
{
    HRESULT hr;
    IPSITE_SUBNET_TREE_ENTRY TmpSubnetTree;

    //
    // we need to refresh
    //
    //
    // Init tmp tree
    //
    ZeroMemory(&TmpSubnetTree, sizeof(IPSITE_SUBNET_TREE_ENTRY));

    //
    // Clear this tmp tree on cleanup
    //
    CAutoDeleteSubnetTree cDelTree(&m_csTree, &TmpSubnetTree);

    //
    // Fill the temporary tree
    //
    hr = FillSubnetSiteTree(&TmpSubnetTree);
    if (FAILED(hr))
    {
        TrERROR(DS, "CIpSite::Refresh:FillSubnetSiteTree()=%lx", hr);
        return LogHR(hr, s_FN, 30);
    }

    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    //
    // Now we can delete the existing tree, and set the new one.
    //
    DeleteSubnetSiteTree(&m_SubnetTree);

    //
    // set the real tree from the temporary one by copying the root node
    //
    m_SubnetTree = TmpSubnetTree;


    //
    // we must not cleanup the temporary tree after we set it to the real tree
    //
    cDelTree.detach();

    return S_OK;
}


HRESULT CIpSite::FindSiteByIpAddress(IN ULONG ulIpAddress,
                                     OUT LPWSTR * ppwszSiteDN,
                                     OUT GUID * pguidSite)
/*++

Routine Description:
    This routine looks up the specified IP address and returns the site which
    contains this address.
    If requested it attempts to do a refresh and retry the lookup in case no site
    was found in the first try.

Arguments:
    ulIpAddress        - IP Address to lookup
    ppwszSiteDN        - Returned site DN
    pguidSite          - Returned site

Return Value:
    S_OK        - pguidSite,ppwszSiteDN set to the site
    S_FALSE     - no site for this address, pguidSite, ppwszSiteDN not set
    other       - HRESULT errors, pguidSite,ppwszSiteDN not set

--*/
{
    AP<WCHAR> pwszSiteDN;
    GUID guidSite;

    //
    // lookup the site for the ip address
    //
    BOOL fFound = InternalFindSiteByIpAddress(ulIpAddress, &pwszSiteDN, &guidSite);

    //
    //  Even though failed to find the site, we don't
    //  try to refresh the subnet-tree. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //

    //
    // if site was not found we return S_FALSE
    //
    if (!fFound)
    {
        LogBOOL(fFound, s_FN, 40);
        return S_FALSE;
    }

    //
    // return the site associated with the ipaddress
    //
    *ppwszSiteDN = pwszSiteDN.detach();
    *pguidSite = guidSite;
    return S_OK;
}


HRESULT CIpSite::FindSitesByComputerName(IN LPCWSTR pwszComputerName,
                                         IN LPCWSTR pwszComputerDnsName,
                                         OUT IPSITE_SiteArrayEntry ** prgSites,
                                         OUT ULONG * pcSites,
                                         OUT ULONG ** prgAddrs,
                                         OUT ULONG * pcAddrs)
/*++

Routine Description:
    This routine looks up the specified computer name and returns the site names
    it belongs to, along with the IP addresses that correspond to the sites

Arguments:
    pwszComputerName    - computer name to lookup
    pwszComputerDnsName - computer dns name to lookup ( optional)
    prgSites            - Returned sites array
    pcSites             - Returned number of sites in array
    prgAddrs            - Returned address array
    pcAddrs             - Returned number of addresses in array

Return Value:
    S_OK        - prgSites, pcSites are set
    other       - HRESULT errors. prgSites, pcSites are set

--*/
{
    //
    // Lookup Sock addresses for the computer
    //

    WSADATA WSAData;
    if(WSAStartup(MAKEWORD(2,0), &WSAData))
	{
		DWORD gle = WSAGetLastError();
        TrERROR(DS, "Start winsock 2.0 Failed, err = %!winerr!", gle);
        return LogHR(HRESULT_FROM_WIN32(gle), s_FN, 70);
	}

	//
	// Auto WSACleanup
	//
	CAutoWSACleanup cWSACleanup;

	//
	// We are using NoGetHostByName() without calling NoInitialize()
	// The only relevant initialization in NoInitialize() is WSAStartup()
	// There are other initializations in NoInitialize() that we don't
	// want to be done (initialization of notification window)
	// NoGetHostByName() doesn't ASSERT that NoInitialize() was called.
	//
	std::vector<SOCKADDR_IN> sockAddress;
    if (pwszComputerDnsName != NULL)
	{
		if (!NoGetHostByName(pwszComputerDnsName, &sockAddress))
		{
			TrERROR(DS, "NoGetHostByName Failed to resolve Address for %ls computer (dns name)", pwszComputerDnsName);
		}
	}

	if(sockAddress.empty() && (pwszComputerName != NULL))
	{
		//
		//  if either
		//  1) DNS name of the computer was not supplied
		//  2) Failed to get host name according to its DNS name
		//  then try according to netbios name
		//
		if (!NoGetHostByName(pwszComputerName, &sockAddress))
		{
			TrERROR(DS, "NoGetHostByName Failed to resolve Address for %ls computer (netbios name)", pwszComputerName);
		}
	}

    //
    // init returned variables
    //
    AP<IPSITE_SiteArrayEntry> rgSites;          // array of sites
    ULONG cSites = 0;                           // number of sites filled
    AP<ULONG> rgAddrs;                          // array of addresses
    ULONG cAddrs = 0;                           // number of addresses filled

    //
    // If NoGetHostByName() didn't returned address
    // we do nothing here because return values are already initialized for this case
    //

	if(sockAddress.size() > 0)
	{
		cAddrs = numeric_cast<DWORD>(sockAddress.size());

        //
        // save addresses from hostnet now (we might later make other winsock calls)
        //
        rgAddrs = new ULONG[cAddrs];
        for (ULONG ulTmp = 0; ulTmp < cAddrs; ulTmp++)
        {
            //
            // save the u_long member of the address
            //
			

            rgAddrs[ulTmp] = sockAddress[ulTmp].sin_addr.S_un.S_addr;
        }

        //
        // Allocate return array
        //
        rgSites = new IPSITE_SiteArrayEntry[cAddrs];
        IPSITE_SiteArrayEntry * pSite = rgSites;    // next site to fill

        //
        // loop over all addresses and find the sites
        //
        for (ulTmp = 0; ulTmp < cAddrs; ulTmp++)
        {
            AP<WCHAR> pwszSiteDN;
            GUID guidSite;

            HRESULT hr = FindSiteByIpAddress(rgAddrs[ulTmp], &pwszSiteDN, &guidSite);
            if (FAILED(hr))
            {
                TrERROR(DS, "CIpSite::FindSitesByComputerName:FindSiteByIpAddress(%lx)=%lx", rgAddrs[ulTmp], hr);
                return LogHR(hr, s_FN, 90);
            }

            //
            // hr can also be S_FALSE if ip address not known, so ignore this case
            //
            if (hr != S_FALSE)
            {
                //
                // Fill site entry
                //
                pSite->pwszSiteDN = pwszSiteDN.detach();
                pSite->guidSite = guidSite;
                pSite->ulIpAddress  = rgAddrs[ulTmp];
                cSites++;
                pSite++;
            }
        }
    }
	
    //
    // return the sites associated with the computer
    //
    *prgSites   = rgSites.detach();
    *pcSites    = cSites;
    if ( prgAddrs != NULL)
    {
        *prgAddrs = rgAddrs.detach();
    }
    if ( pcAddrs != NULL)
    {
        ASSERT( prgAddrs != NULL);
        *pcAddrs = cAddrs;
    }
    return S_OK;
}


HRESULT CIpSite::FillSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine fills a tree of subnets.

Arguments:
    pRootSubnetTree - tree to fill

Return Value:
    HRESULT

--*/
#ifndef DEBUG_NO_DS
{
    AP<WCHAR> pwszConfigDN;
    AP<WCHAR> pwszSubnetsDN;
    R<IADsContainer> pContSubnets;
    CAutoEnumerator pEnumSubnets;
    HRESULT hr;
    size_t  sizeCh = 0;

    //
    // compute DN of subnets container
    //
    hr = GetConfigurationDN(&pwszConfigDN);
    if (FAILED(hr))
    {
        TrERROR(DS, "FillSubnetSiteTree:GetConfigurationDN()=%lx", hr);
        return LogHR(hr, s_FN, 100);
    }

    sizeCh = 1+wcslen(x_IPSITE_SUBNETS_DN)+wcslen(pwszConfigDN);
    pwszSubnetsDN = new WCHAR[sizeCh];
    hr = StringCchPrintfW(pwszSubnetsDN, sizeCh, L"%s%s", x_IPSITE_SUBNETS_DN, pwszConfigDN.get());
    if( FAILED( hr ))
    {
        TrERROR(DS, "FillSubnetSiteTree:StringCchPrintfW()=%lx", hr);
        return LogHR(hr, s_FN, 105  );
    }

    //
    // bind to subnets container
    //

	AP<WCHAR> pEscapeAdsPathNameToFree;

	hr = ADsOpenObject(
		UtlEscapeAdsPathName(pwszSubnetsDN, pEscapeAdsPathNameToFree),
		NULL,
		NULL,
		ADS_SECURE_AUTHENTICATION,
		IID_IADsContainer,
		(void**)&pContSubnets
		);

	LogTraceQuery(pwszSubnetsDN, s_FN, 109);
    if (FAILED(hr))
    {
        TrERROR(DS, "FillSubnetSiteTree:ADsOpenObject(%ls)=%lx", (LPWSTR)pwszSubnetsDN, hr);
        return LogHR(hr, s_FN, 110);
    }

    //
    // build enumerator for contained subnets
    //
    hr = ADsBuildEnumerator(pContSubnets.get(), &pEnumSubnets);
    if (FAILED(hr))
    {
        TrERROR(DS, "FillSubnetSiteTree:ADsBuildEnumerator()=%lx", hr);
        return LogHR(hr, s_FN, 120);
    }

    //
    // loop over the subnets
    //
    BOOL fDone = FALSE;

    //
    // Site guid from site DN translator
    //
    CGetSiteGuidFromDN guidFromDNObj;

    while (!fDone)
    {
        CAutoVariant varSubnet;
        ULONG cSubnets;

        //
        // get next subnet
        //
        hr = ADsEnumerateNext(pEnumSubnets, 1, &varSubnet, &cSubnets);
        if (FAILED(hr))
        {
            TrERROR(DS, "FillSubnetSiteTree:ADsEnumerateNext()=%lx", hr);
            return LogHR(hr, s_FN, 130);
        }

        //
        // check if we are done
        //
        if (cSubnets < 1)
        {
            fDone = TRUE;
        }
        else
        {
            R<IADs> padsSubnet;
            BS bstrName;
            CAutoVariant varSubnetName, varSiteDN;
            GUID guidSite;

            //
            // get IADs interface
            //
            hr = V_DISPATCH(&varSubnet)->QueryInterface(IID_IADs, (void**)&padsSubnet);
            if (FAILED(hr))
            {
                TrERROR(DS, "FillSubnetSiteTree:QueryInterface(IADs)=%lx", hr);
                return LogHR(hr, s_FN, 140);
            }

            //
            // get subnet name
            //
            bstrName = L"name";
            hr = padsSubnet->Get(bstrName, &varSubnetName);
            if (hr == E_ADS_PROPERTY_NOT_FOUND)
            {
                // no name, ignore this subnet
                continue;
            }
            else if (FAILED(hr))
            {
                TrERROR(DS, "FillSubnetSiteTree:Get(name)=%lx", hr);
                return LogHR(hr, s_FN, 150);
            }

            //
            // get subnet site
            //
            bstrName = L"siteObject";
            hr = padsSubnet->Get(bstrName, &varSiteDN);
            if (hr == E_ADS_PROPERTY_NOT_FOUND)
            {
                // no site object, ignore this subnet
                continue;
            }
            else if (FAILED(hr))
            {
                TrERROR(DS, "FillSubnetSiteTree:Get(siteObject)=%lx", hr);
                return LogHR(hr, s_FN, 160);
            }

            //
            // get site guid from site dn
            //
            hr = guidFromDNObj.GetSiteGuidFromDN(V_BSTR(&varSiteDN), &guidSite);
            if (FAILED(hr))
            {
                // bad site DN, ignore this subnet
                TrERROR(DS, "FillSubnetSiteTree:GetSiteGuidFromDN(%ls)=%lx, skipping", V_BSTR(&varSiteDN), hr);
                LogHR(hr, s_FN, 1641);
                continue;
            }

            //
            // add subnet,site to tree
            //
            hr = AddSubnetSiteToTree(V_BSTR(&varSubnetName), V_BSTR(&varSiteDN), &guidSite, pRootSubnetTree);
            if (FAILED(hr))
            {
				//
				// Failure is due to bad Subnet string.
				// this can occur due to replication conflict
				// Don't return error in this case, ignore this subnet
				// returning an error will cause service startup failure
				//
                TrERROR(DS, "FillSubnetSiteTree:AddSubnetSiteToTree(%ls,%ls)=%lx", V_BSTR(&varSubnetName), V_BSTR(&varSiteDN), hr);
                LogHR(hr, s_FN, 170);
				continue;
            }
        }
    }

    //
    // return
    //
    return S_OK;
}
#else // ifndef DEBUG_NO_DS
{
    static LPSTR rgSubnets[] = {"157.59.184.0", "163.59.0.0", "163.59.224.0"};
    static ULONG rgbits[] = {22, 16, 20};
    static LPWSTR rgSiteDNs[]    = {L"SITE_157.59.184.0", L"SITE_163.59.0.0", L"SITE_163.59.224.0"};
    static GUID rgSiteGUIDs[]  = {(GUID)0, (GUID)1, (GUID)2};

    for (ULONG ulTmp = 0; ulTmp < 3; ulTmp++)
    {
        LPSTR pszTmp = rgSubnets[ulTmp];
        AP<WCHAR> pwszSubnet;
        pwszSubnet = new WCHAR[1+strlen(pszTmp)+30];
        int iTmp = MultiByteToWideChar(CP_ACP, 0, pszTmp, -1, pwszSubnet, 1+strlen(pszTmp));

        swprintf((LPWSTR)pwszSubnet + wcslen(pwszSubnet), L"/%ld", rgbits[ulTmp]);
        HRESULT hr = AddSubnetSiteToTree(pwszSubnet, rgSiteDNs[ulTmp], &rgSiteGUIDs[ulTmp], pRootSubnetTree);
    }

    //
    // return
    //
    return S_OK;
}
#endif // ifndef DEBUG_NO_DS


HRESULT CIpSite::AddSubnetSiteToTree(IN LPCWSTR pwszSubnetName,
                                     IN LPCWSTR pwszSiteDN,
                                     IN const GUID * pguidSite,
                                     IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine adds a subnet to a tree of subnets. Assumes it is a temporary
    tree, therefore doesn't lock the critical section for the tree, only locks
    the subnets list.

Arguments:
    pwszSubnetName  - subnet to be added
    pwszSiteDN      - DN of the site the subnet is in.
    pguidSite       - GUID of the site the subnet is in.
    pRootSubnetTree - tree to add to

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // Parse the subnet name
    //
    ULONG ulSubnetAddress, ulSubnetMask;
    BYTE bSubnetBitCount;
    hr = ParseSubnetString(pwszSubnetName, &ulSubnetAddress, &ulSubnetMask, &bSubnetBitCount);
    if (FAILED(hr))
    {
        TrERROR(DS, "AddSubnetSiteToTree:ParseSubnetString(%ls)=%lx", pwszSubnetName, hr);
        return LogHR(hr, s_FN, 180);
    }

    //
    // Find or allocate an entry for the subnet
    //
    IPSITE_SUBNET* pSubnet;
    FindSubnetEntry(pwszSiteDN, pguidSite, ulSubnetAddress, ulSubnetMask, bSubnetBitCount, &pSubnet);

    //
    // always deref it when done
    //
    CAutoDerefSubnet cDerefSubnet(&m_csTree, pSubnet);

    //
    // Loop for each byte in the subnet address
    //
    IPSITE_SUBNET_TREE_ENTRY* pSubnetTreeEntry = pRootSubnetTree;
    LPBYTE pbSubnetBytePointer = (LPBYTE) (&pSubnet->SubnetAddress);
    while (bSubnetBitCount != 0)
    {
        //
        // If there isn't a tree branch for the current node, create one.
        //
        if (pSubnetTreeEntry->Subtree == NULL)
        {
            pSubnetTreeEntry->Subtree = new IPSITE_SUBNET_TREE;
            ZeroMemory(pSubnetTreeEntry->Subtree, sizeof(IPSITE_SUBNET_TREE));
        }

        //
        // If this is the last byte of the subnet address,
        //  link the subnet onto the tree here.
        //
        if (bSubnetBitCount <= 8)
        {
            //
            // The caller indexes into this array with an IP address.
            // Create a link to our subnet for each possible IP addresses
            // that map onto this subnet.
            //
            // Between 1 and 128 IP addresses map onto this subnet address.
            //
            ULONG ulLoopCount = 1 << (8-bSubnetBitCount);

            for (ULONG iTmp=0; iTmp<ulLoopCount; iTmp++)
            {
                IPSITE_SUBNET_TREE_ENTRY* pSubtree;
                ULONG ulSubnetIndex;

                //
                // Compute which entry is to be updated.
                //
                ulSubnetIndex = (*pbSubnetBytePointer) + iTmp;
                ASSERT(ulSubnetIndex <= 255);
                pSubtree = &pSubnetTreeEntry->Subtree->Subtree[ulSubnetIndex];

                //
                // If there already is a subnet linked off the tree here,
                //  handle it.
                //
                if (pSubtree->Subnet != NULL)
                {
                    //
                    //  If the entry is for a less specific subnet
                    //  delete the current entry.
                    //
                    if (pSubtree->Subnet->SubnetBitCount < pSubnet->SubnetBitCount)
                    {
                        CS lock(m_csTree);
                        DerefSubnet(pSubtree->Subnet);
                        pSubtree->Subnet = NULL;
                    }
                    else
                    {
                        //
                        // Otherwise,
                        //  use the current entry since it is better than this one.
                        //
                        continue;
                    }
                }

                //
                // Link the subnet into the tree.
                // Increment the reference count.
                //
                {
                    CS lock(m_csTree);
                    RefSubnet(pSubnet);
                    pSubtree->Subnet = pSubnet;
                }
            }

            //
            // we are done going over the meaningful bytes of the subnet address
            //
            break;
        }

        //
        // Move on to the next meaningful byte of the subnet address
        //
        pSubnetTreeEntry = &pSubnetTreeEntry->Subtree->Subtree[*pbSubnetBytePointer];
        bSubnetBitCount -= 8;
        pbSubnetBytePointer++;
    }

    return S_OK;
}


void CIpSite::FindSubnetEntry(IN LPCWSTR pwszSiteDN,
                              IN const GUID * pguidSite,
                              IN ULONG ulSubnetAddress,
                              IN ULONG ulSubnetMask,
                              IN BYTE bSubnetBitCount,
                              OUT IPSITE_SUBNET** ppSubnet)
/*++

Routine Description:
    This routine finds a subnet entry for a particular subnet name.  If one
    does not exist, one is created.

Arguments:
    pwszSiteDN       - DN of the site the subnet covers.
    pguidSite        - GUID of the site the subnet covers.
    ulSubnetAddress  - Subnet Address for the subnet to find.
    ulSubnetMask     - Subnet mask for the subnet to find.
    ulSubnetBitCount - Subnet bit count for the subnet to find.
    ppSubnet       - Returned subnet entry, entry should be dereferenced when done.

Return Value:
    void

--*/
{
    PLIST_ENTRY pListEntry;
    P<IPSITE_SUBNET> pNewSubnet;

    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    //
    // If the subnet entry already exists, return a pointer to it.
    //
    for (pListEntry = m_SubnetList.Flink; pListEntry != &m_SubnetList; pListEntry = pListEntry->Flink)
    {
        IPSITE_SUBNET* pSubnet = CONTAINING_RECORD(pListEntry, IPSITE_SUBNET, Next);

        if ((pSubnet->SubnetAddress == ulSubnetAddress) &&
            (pSubnet->SubnetBitCount == bSubnetBitCount) &&
            (pSubnet->SubnetMask == ulSubnetMask) &&
            (pSubnet->SiteGuid == *pguidSite))
        {
            RefSubnet(pSubnet);    // reference it for caller
            *ppSubnet = pSubnet;
            return;
        }
    }

    //
    // If not, allocate one.
    //
    pNewSubnet = new IPSITE_SUBNET;

    //
    // Fill it in.
    //
    pNewSubnet->ReferenceCount    = 1;    // reference it for caller
    pNewSubnet->SubnetAddress     = ulSubnetAddress;
    pNewSubnet->SubnetMask        = ulSubnetMask;
    pNewSubnet->SubnetBitCount    = bSubnetBitCount;
    pNewSubnet->SiteDN            = newwcs(pwszSiteDN);
    pNewSubnet->SiteGuid          = *pguidSite;
    InsertHeadList(&m_SubnetList, &pNewSubnet->Next);

    //
    // return new subnet entry
    //
    *ppSubnet = pNewSubnet.detach();
    return;
}


BOOL CIpSite::InternalFindSiteByIpAddress(IN ULONG ulIpAddress,
                                          OUT LPWSTR * ppwszSiteDN,
                                          OUT GUID * pguidSite)
/*++

Routine Description:
    This routine looks up the specified IP address and returns the site which
    contains this address

Arguments:
    ulIpAddress     - IP Address to lookup
    ppwszSiteDN     - Returned site DN
    pguidSite       - Returned site

Return Value:
    TRUE        - pguidSite,ppwszSiteDN set to the site
    FALSE       - no site for this address, pguidSite, ppwszSiteDN not set

--*/
{
    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    IPSITE_SUBNET* pSubnet = NULL;
    IPSITE_SUBNET_TREE_ENTRY* pSubnetTreeEntry = &m_SubnetTree;
    //
    // Loop for each byte in the Ip address
    //
    for (ULONG ulByteIndex=0; ulByteIndex<sizeof(ulIpAddress); ulByteIndex++)
    {
        //
        // If there is no subtree, we're done.
        //
        ULONG ulSubnetIndex = ((LPBYTE)(&ulIpAddress))[ulByteIndex];
        if (pSubnetTreeEntry->Subtree == NULL)
        {
            break;
        }

        //
        // Compute which entry is being referenced
        //
        pSubnetTreeEntry = &pSubnetTreeEntry->Subtree->Subtree[ulSubnetIndex];

        //
        // If there already is a subnet linked off here, use it.
        // (but continue walking down the tree trying to find a more explicit entry.)
        //
        if (pSubnetTreeEntry->Subnet != NULL)
        {
            pSubnet = pSubnetTreeEntry->Subnet;
        }
    }

    //
    // If we didn't find a subnet, return S_FALSE
    //
    if (pSubnet == NULL)
    {
        LogBOOL(FALSE, s_FN, 190);
        return FALSE;
    }

    //
    // return the site associated with the subnet
    //
    AP<WCHAR> pwszSiteDN = newwcs(pSubnet->SiteDN);
    *ppwszSiteDN = pwszSiteDN.detach();
    *pguidSite = pSubnet->SiteGuid;
    return TRUE;
}

void WINAPI CIpSite::RefrshSubnetTreeCache(
                IN CTimer* pTimer
                   )
{
    CIpSite * pIpSite = CONTAINING_RECORD(pTimer, CIpSite, m_RefreshTimer);
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1609);
    //
    //  ignore failure -> reschedule
    //

    pIpSite->Refresh();

    //
    //  reschedule
	//
    ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pIpSite->m_RefreshTimer,
		CTimeDuration::FromMilliSeconds(pIpSite->m_dwMinTimeToAllowNextRefresh)
		);

}





//-----------------------------
//static functions
#if 0
static HRESULT GetSiteNameFromSiteDN(IN LPCWSTR pwszSiteDN,
                                     OUT LPWSTR * ppwszSiteName);
/*++

Routine Description:
    returns site name from site DN

Arguments:
    pwszSiteDN      - Site DN
    ppwszSiteName   - Returned site name

Return Value:
    HRESULT

--*/
{
    //
    // copy so we can change it
    //
    AP<WCHAR> pwszSite = new WCHAR[1+wcslen(pwszSiteDN)];
    wcscpy(pwszSite, pwszSiteDN);

    //
    // find the = in the first CN=
    //
    LPWSTR pwszStartSiteName = wcschr(pwszSite, L'=');
    if (!pwszStartSiteName)
    {
        TrERROR(DS, "GetSiteNameFromSiteDN:no = sign in %ls", (LPWSTR)pwszSite);
        return LogHR(E_FAIL, s_FN, 200);
    }
    pwszStartSiteName++;

    //
    // Replace the comma in CN=xxx, with NULL terminator
    //
    LPWSTR pwszEndSiteName = wcschr(pwszStartSiteName, L',');
    if (pwszEndSiteName)
    {
        *pwszEndSiteName = '\0';
    }

    //
    // create a copy of the name
    //
    AP<WCHAR> pwszName = new WCHAR[1+wcslen(pwszStartSiteName)];
    wcscpy(pwszName, pwszStartSiteName);

    //
    // return the name
    //
    *ppwszSiteName = pwszName.detach();
    return S_OK;
}
#endif

static HRESULT ParseSubnetString(IN LPCWSTR pwszSubnetName,
                                 OUT ULONG * pulSubnetAddress,
                                 OUT ULONG * pulSubnetMask,
                                 OUT BYTE  * pbSubnetBitCount)
/*++

Routine Description:
    Convert the subnet name to address and bit count.

Arguments:
    pwszSubnetName      - Subnet string
    pulSubnetAddress    - Returns the subnet number in Network byte order.
    pulSubnetMask       - Returns the subnet mask in network byte order
    pulSubnetBitCount   - Returns the number of leftmost significant bits in the
                           SubnetAddress

Return Value:
    HRESULT

--*/
{
    static ULONG BitMask[] =
        {0x00000000, 0x00000080, 0x000000C0, 0x000000E0, 0x000000F0, 0x000000F8, 0x000000FC, 0x000000FE,
         0x000000FF, 0x000080FF, 0x0000C0FF, 0x0000E0FF, 0x0000F0FF, 0x0000F8FF, 0x0000FCFF, 0x0000FEFF,
         0x0000FFFF, 0x0080FFFF, 0x00C0FFFF, 0x00E0FFFF, 0x00F0FFFF, 0x00F8FFFF, 0x00FCFFFF, 0x00FEFFFF,
         0x00FFFFFF, 0x80FFFFFF, 0xC0FFFFFF, 0xE0FFFFFF, 0xF0FFFFFF, 0xF8FFFFFF, 0xFCFFFFFF, 0xFEFFFFFF,
         0xFFFFFFFF };

    //
    // Copy the string to where we can munge it.
    //
    AP<WCHAR> pwszLocalSubnetName = newwcs(pwszSubnetName);

    //
    // Find the subnet bit count.
    //
    LPWSTR pwszSlashPointer = wcschr(pwszLocalSubnetName, L'/');
    if (!pwszSlashPointer)
    {
        TrERROR(DS, "ParseSubnetString: %ls: bit count missing", pwszSubnetName);
        return LogHR(MQ_ERROR, s_FN, 210);
    }

    //
    // Zero terminate the address portion of the subnet name.
    //
    *pwszSlashPointer = L'\0';

    //
    // Get the BitCount portion.
    //
    LPWSTR pwszEnd;
    ULONG ulLocalBitCount = wcstoul(pwszSlashPointer+1, &pwszEnd, 10);

    if ((ulLocalBitCount == 0) || (ulLocalBitCount > 32))
    {
        TrERROR(DS, "ParseSubnetString: %ls: bit count %ld is bad", pwszSubnetName, ulLocalBitCount);
        return LogHR(MQ_ERROR, s_FN, 220);
    }

    if (*pwszEnd != L'\0')
    {
        TrERROR(DS, "ParseSubnetString: %ls: bit count not at the end", pwszSubnetName);
        return LogHR(MQ_ERROR, s_FN, 230);
    }

    BYTE bSubnetBitCount = (BYTE)ulLocalBitCount;

    //
    // Convert the address portion to binary.
    //
#if 0
    SOCKADDR_IN SockAddrIn;
    INT iSockAddrSize = sizeof(SockAddrIn);

    INT iWsaStatus = WSAStringToAddressW(pwszLocalSubnetName,
                                         AF_INET,
                                         NULL,
                                         (PSOCKADDR)&SockAddrIn,
                                         &iSockAddrSize);
    if (iWsaStatus != 0)
    {
        iWsaStatus = WSAGetLastError();
        TrERROR(DS, "ParseSubnetString: %ls: WSAStringToAddressW()=%lx", (LPWSTR)pwszLocalSubnetName, (long)iWsaStatus);
        LogNTStatus(iWsaStatus, s_FN, 240);
        return MQ_ERROR;
    }

    if (SockAddrIn.sin_family != AF_INET)
    {
        TrERROR(DS, "ParseSubnetString: %ls: not AF_INET", (LPWSTR)pwszLocalSubnetName);
        return LogHR(MQ_ERROR, s_FN, 250);
    }

    ULONG ulSubnetAddress = SockAddrIn.sin_addr.S_un.S_addr;
#else
    AP<char> pszAnsiSubnetName;
    HRESULT hr = WideToAnsiStr(pwszLocalSubnetName, &pszAnsiSubnetName);
    if (FAILED(hr))
    {
        TrERROR(DS, "ParseSubnetString:WideToAnsiStr(%ls)=%lx", (LPWSTR)pwszLocalSubnetName, hr);
        return LogHR(hr, s_FN, 260);
    }

    ULONG ulSubnetAddress = inet_addr(pszAnsiSubnetName);
    if (ulSubnetAddress == INADDR_NONE)
    {
        TrERROR(DS, "ParseSubnetString: %ls: not a valid subnet address", (LPWSTR)pwszLocalSubnetName);
        return LogHR(MQ_ERROR, s_FN, 270);
    }
#endif //0
    ULONG ulSubnetMask = BitMask[bSubnetBitCount];

    //
    // Ensure there are no bits set that aren't included in the subnet mask.
    //
    if (ulSubnetAddress & (~ulSubnetMask))
    {
        TrERROR(DS, "ParseSubnetString: %ls: bits not in subnet mask %8.8lX %8.8lX", pwszSubnetName, ulSubnetAddress, ulSubnetMask);
        return LogHR(MQ_ERROR, s_FN, 280);
    }

    //
    // return values
    //
    *pbSubnetBitCount = bSubnetBitCount;
    *pulSubnetAddress = ulSubnetAddress;
    *pulSubnetMask    = ulSubnetMask;
    return S_OK;
}


static void RefSubnet(IPSITE_SUBNET* pSubnet)
/*++

Routine Description:
    Reference a subnet

Arguments:
    pSubnet  - Entry to be Referenced.

Return Value:
    None.

--*/
{
    pSubnet->ReferenceCount++;
}


static void DerefSubnet(IPSITE_SUBNET* pSubnet)
/*++

Routine Description:
    Dereference a subnet entry.
    If the reference count goes to zero, the subnet entry will be deleted.

Arguments:
    pSubnet  - Entry to be dereferenced.

Return Value:
    None.

--*/
{
    if ((--(pSubnet->ReferenceCount)) == 0)
    {
        //
        // Remove the subnet from the global list
        //
        RemoveEntryList(&pSubnet->Next);

        //
        // destruct the Subnet entry itself.
        //
        delete pSubnet;
    }
}


static void DeleteSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine deletes a tree of subnets recursively.
    Assumes critical section is locked.

Arguments:
    pRootSubnetTree - tree to delete, cannot be NULL.

Return Value:
    void

--*/
{
    //
    // pRootSubnetTree cannot be NULL
    //
    ASSERT(pRootSubnetTree);

    //
    // If there are children, delete them.
    //
    if (pRootSubnetTree->Subtree != NULL)
    {
        //
        // recurse into children
        // passed parameter is not NULL because it is an address
        //
        for (ULONG i=0; i<256; i++)
        {
            DeleteSubnetSiteTree(&pRootSubnetTree->Subtree->Subtree[i]);
        }

        delete pRootSubnetTree->Subtree;
        pRootSubnetTree->Subtree = NULL;
    }

    //
    // If there is a subnet, dereference it.
    //
    if (pRootSubnetTree->Subnet != NULL)
    {
        DerefSubnet(pRootSubnetTree->Subnet);
        pRootSubnetTree->Subnet = NULL;
    }
}


HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi)
/*++

Routine Description:
    Converts from wide char to ansi

Arguments:
    pwszUnicode - wide char string
    ppszAnsi    - returned ansi string

Return Value:
    HRESULT

--*/
{
    AP<char> pszAnsi;

    //
    // Get size of buffer
    //
    int iSize = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);
    pszAnsi = new char[iSize + 1];

    //
    // Perform conversion
    //
    int iRes = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszAnsi, iSize, NULL, NULL);
    if (iRes == 0)
    {
        HRESULT hr = GetLastError();
        TrERROR(DS, "WideToAnsiStr: WideCharToMultiByte(%ls)=%lx", pwszUnicode, hr);
        return LogHR(hr, s_FN, 290);
    }
    pszAnsi[iSize] = '\0';

    //
    // return results
    //
    *ppszAnsi = pszAnsi.detach();
    return S_OK;
}


static HRESULT GetConfigurationDN(OUT LPWSTR * ppwszConfigDN)
/*++

Routine Description:
      Finds the DN of the configuration container of the active directory

Arguments:
      ppwszConfigDN - where the configuration DN is put

Return Value:
    HRESULT

--*/
{
    HRESULT hr;
    R<IADs> pADs;
    BS      bstrTmp;
    CAutoVariant    varTmp;
    AP<WCHAR>       pwszConfigDN;

    //
    // Bind to the RootDSE to obtain information
    //
	//	( specify local server, to avoid access of remote server during setup)
    //
	ASSERT( g_pwcsServerName != NULL);
    DWORD sizeCh = x_providerPrefixLength + g_dwServerNameLength + x_RootDSELength + 2;
    AP<WCHAR> pwcsRootDSE = new WCHAR [ sizeCh ];


    hr = StringCchPrintfW(pwcsRootDSE, sizeCh, L"%s%s/%s",
            x_LdapProvider,
            g_pwcsServerName.get(),
			x_RootDSE);
    if( FAILED( hr ))
    {
        TrERROR(DS, "GetConfigDN:StringCchPrintfW=%lx", hr);
        return LogHR(hr, s_FN, 295);
    }

	hr = ADsOpenObject(
			pwcsRootDSE,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IADs,
			(void**)&pADs
			);


    LogTraceQuery(pwcsRootDSE, s_FN, 299);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetConfigDN:ADsOpenObject(LDAP://RootDSE)=%lx", hr);
        return LogHR(hr, s_FN, 300);
    }

    //
    // Setting value to BSTR
    //
    bstrTmp = TEXT("configurationNamingContext");
    //
    // Reading the property
    //
    hr = pADs->Get(bstrTmp, &varTmp);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetConfigDN:Get(configurationNamingContext)=%lx", hr);
        return LogHR(hr, s_FN, 310);
    }
    ASSERT(((VARIANT &)varTmp).vt == VT_BSTR);

    //
    // copy DN
    //
    pwszConfigDN  = newwcs(V_BSTR(&varTmp));

    //
    // Return configuration DN
    //
    *ppwszConfigDN  = pwszConfigDN.detach();
    return S_OK;
}


static HRESULT VariantGuid2Guid(IN VARIANT * pvarGuid, OUT GUID * pguid)
/*++

Routine Description:
      converts from VARIANT guid (i.e. safe array of bytes) to real guid

Arguments:
    pvarGuid - variant to convert
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // check the variant
    //
    if ((pvarGuid->vt != (VT_ARRAY | VT_UI1)) ||
        (!pvarGuid->parray))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 320);
    }
    else if (SafeArrayGetDim(pvarGuid->parray) != 1)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 330);
    }
    LONG lLbound, lUbound;
    if (FAILED(SafeArrayGetLBound(pvarGuid->parray, 1, &lLbound)) ||
        FAILED(SafeArrayGetUBound(pvarGuid->parray, 1, &lUbound)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 340);
    }
    if (lUbound - lLbound + 1 != sizeof(GUID))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 350);
    }

    //
    // Get the guid value
    //
    GUID guid;
    LPBYTE pTmp = (LPBYTE)&guid;
    for (LONG lTmp = lLbound; lTmp <= lUbound; lTmp++)
    {
        hr = SafeArrayGetElement(pvarGuid->parray, &lTmp, pTmp);
        if (FAILED(hr))
        {
            TrERROR(DS, "VariantGuid2Guid:SafeArrayGetElement(%ld)=%lx", lTmp, hr);
            return LogHR(hr, s_FN, 360);
        }
        pTmp++;
    }

    //
    // return values
    //
    *pguid = guid;
    return MQ_OK;
}


HRESULT CGetSiteGuidFromDN::GetGuidFromDNInAdsi(IN LPCWSTR pwszDN, OUT GUID * pguid)
/*++

Routine Description:
      gets the object's GUID given the object's DN. Does it by binding to it in ADSI.

Arguments:
    pwszDN   - Object's DN
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // Create ADSI path
    //
    AP<WCHAR> sPath = newwcscat(L"LDAP://", pwszDN);
    //
    // bind to the obj
    //
    R<IADs> pIADs;

	AP<WCHAR> pEscapeAdsPathNameToFree;
	
	hr = ADsOpenObject(
			UtlEscapeAdsPathName(sPath, pEscapeAdsPathNameToFree),
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADs,
			(void**)&pIADs
			);

    LogTraceQuery(sPath, s_FN, 369);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetGuidFromDNInAdsi:ADsOpenObject(%ls)=%lx", (LPWSTR)sPath, hr);
        return LogHR(hr, s_FN, 370);
    }

    //
    // Get GUID
    //
    CAutoVariant varGuid;
    BS bsName = x_AttrObjectGUID;
    hr = pIADs->Get(bsName, &varGuid);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetGuidFromDNInAdsi:pIADs->Get(guid)=%lx", hr);
        return LogHR(hr, s_FN, 380);
    }

    //
    // copy GUID
    //
    GUID guid;
    hr = VariantGuid2Guid(&varGuid, &guid);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetGuidFromDNInAdsi:VariantGuid2Guid()=%lx", hr);
        return LogHR(hr, s_FN, 390);
    }

    //
    // return values
    //
    *pguid = guid;
    return MQ_OK;
}

HRESULT CGetSiteGuidFromDN::GetSiteGuidFromDN(IN LPWSTR pwszDN, OUT GUID * pguid)
/*++

Routine Description:
      gets the object's GUID given the object's DN. Keeps a cache and looks at the cache or at ADSI.

Arguments:
    pwszDN   - Object's DN
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{
    //
    // Only the site name itself will be used as key. The site name begins
    // at the forth character (after "CN=") and ends before the first occurence
    // of ",". To avoid unnacessary copies, we use the original string and replace the first ","
    // by NULL to get a short string.
    //
    //
    // find the = in the first CN=
    //
    LPWSTR pwstrSiteName = wcschr(pwszDN, L'=');
    if (0 == pwstrSiteName)
    {
        TrERROR(DS, "GetSiteGuidFromDN:no = sign in %ls", pwszDN);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 400);
    }
    pwstrSiteName++;

    LPWSTR pwstrFirstComma = wcschr(pwstrSiteName, L',');
    if (0 == pwstrFirstComma)
    {
        //
        // Legal name should contain a comma
        //
        TrERROR(DS, "GetSiteGuidFromDN:no , sign in %ls", pwszDN);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 410);
    }
    ASSERT(*pwstrFirstComma == L',');

    //
    // Replace the comma with a NULL, so pwstrSiteName will point to the site name only
    // Then, we can perform the lookup. After the lookpup, put the comma back in, so
    // pwszDN will contain a valid value again.
    //
    *pwstrFirstComma = 0;
    BOOL fFound = m_DNToGuidMap.Lookup(pwstrSiteName, *pguid);
    *pwstrFirstComma = L',';

    if (fFound)
    {
        return MQ_OK;
    }

    HRESULT hr = GetGuidFromDNInAdsi(pwszDN, pguid);
    if (SUCCEEDED(hr))
    {
        //
        // Copy the name up to the first comma and use it as a key.
        //
        DWORD dwSiteNameLen = numeric_cast<DWORD>(pwstrFirstComma - pwstrSiteName);
        AP<WCHAR> wszDNKey = new WCHAR[dwSiteNameLen + 1];
        wcsncpy(wszDNKey, pwstrSiteName, dwSiteNameLen);
        wszDNKey[dwSiteNameLen] = 0;

        m_DNToGuidMap[wszDNKey.detach()] = *pguid;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\mqcmachn.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    mqcmachn.cpp

Abstract:

    MQDSCORE library,
    Internal functions for ADS operations on msmqConfiguration object.

Author:

    ronit hartmann (ronith)  (first version in mqadsp.cpp)
    Doron Juster   (DoronJ)  split files.

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "dscore.h"
#include <notify.h>
#include <lmaccess.h>

#include "mqcmachn.tmh"

static WCHAR *s_FN=L"mqdscore/mqcmachn";

//+-------------------------------------------
//
//  HRESULT  SetDefaultMachineSecurity()
//
//+-------------------------------------------

static
HRESULT  
SetDefaultMachineSecurity( 
	IN  DWORD           dwObjectType,
	IN  PSID            pComputerSid,
	IN OUT DWORD       *pcp,
	IN OUT PROPID       aProp[  ],
	IN OUT PROPVARIANT  apVar[  ],
	IN BOOL             fImpersonate,
    IN BOOL             fIncludeOwner,
	OUT PSECURITY_DESCRIPTOR* ppMachineSD 
	)
{
    //
    // If the computer sid is null, then most probably the setup will fail.
    // (that is, if we can't retrieve the computer sid, why would we be able
    // to create the msmqConfiguration object under the computer object.
    // failing to retrieve the sid may be the result of broken trust or because
    // the computer object really does not exist or was not yet replicated).
    // The "good" solution is to completely fail setup right now. But to
    // reduce risks and avoid regressions, let's build a security descriptor
    // without the computer sid and proceed with setup.
    // If setup do succeed, then the msmq service on the machine that run
    // setup may fail to update its own properties, if it need to update them.
    // the admin can always use mmc and add the computer account to the dacl.
    // bug 4950.
    //
    ASSERT(pComputerSid);

    //
    // If PROPID_QM_SECURITY already present, then return. This happen
    // in Migration code.
    //
    for (DWORD j = 0; j < *pcp; j++)
    {
        if (aProp[j] == PROPID_QM_SECURITY)
        {
            return MQ_OK;
        }
    }

    //
    // See if caller supply a Owner SID. If yes, then this SID is granted
    // full control on the msmq configuration object.
    // This "owner" is usually the user SID that run setup. The "owner" that
    // is retrieved below from the default security descriptor is usually
    // (for clients) the SID of the computer object, as the msmqConfiguration
    // object is created by the msmq service (on client machines).
    //
    PSID pUserSid = NULL ;
    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_OWNER_SID)
        {
            aProp[j] = PROPID_QM_DONOTHING ;
            pUserSid = apVar[j].blob.pBlobData ;
            ASSERT(IsValidSid(pUserSid)) ;
            break ;
        }
    }

    //
    // Build a security descriptor that include only owner and group.
    // Owner is needed to build the DACL.
    //
    PSECURITY_DESCRIPTOR  psdOwner ;

    HRESULT hr = MQSec_GetDefaultSecDescriptor( dwObjectType,
                                               &psdOwner,
                                                fImpersonate,
                                                NULL,
                                                DACL_SECURITY_INFORMATION,
                                                e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }
    P<BYTE> pTmp = (BYTE*) psdOwner ;

    PSID pOwner = NULL;
    BOOL bOwnerDefaulted = FALSE ;
    BOOL bRet = GetSecurityDescriptorOwner( psdOwner,
                                           &pOwner,
                                           &bOwnerDefaulted);
    ASSERT(bRet);

    PSID pWorldSid = MQSec_GetWorldSid();

    //
    // Build the default machine DACL.
    //
    DWORD dwAclSize = sizeof(ACL)                                +
              (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pOwner) ;

    if (pComputerSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pComputerSid) ;
    }
    if (pUserSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pUserSid) ;
    }

    AP<char> DACL_buff = new char[ dwAclSize ];
    PACL pDacl = (PACL)(char*)DACL_buff;
    InitializeAcl(pDacl, dwAclSize, ACL_REVISION);

    //
    // See if it's a foreign machine. If yes, then allow everyone to create
    // queue. a foreign machine is not a real msmq machine, so there is no
    // msmq service that can create queues on behalf of users that run on
    // that machine.
    // Similarly, check if it's a group on a cluster machine.
    //
    BOOL fAllowEveryoneCreateQ = FALSE ;

    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_FOREIGN)
        {
            if (apVar[j].bVal == FOREIGN_MACHINE)
            {
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
        else if (aProp[j] == PROPID_QM_GROUP_IN_CLUSTER)
        {
            if (apVar[j].bVal == MSMQ_GROUP_IN_CLUSTER)
            {
                aProp[j] = PROPID_QM_DONOTHING ;
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
    }

    DWORD dwWorldAccess = 0 ;

    if (fAllowEveryoneCreateQ)
    {
        dwWorldAccess = MQSEC_MACHINE_GENERIC_WRITE;
    }
    else
    {
        switch (dwObjectType)
        {
        case MQDS_MACHINE:
            dwWorldAccess = MQSEC_MACHINE_WORLD_RIGHTS ;
            break;

        case MQDS_MSMQ10_MACHINE:
            dwWorldAccess = MQSEC_MACHINE_GENERIC_WRITE;
            break;

        default:
            break;
        }
    }

    ASSERT(dwWorldAccess != 0) ;

    BOOL fAdd = AddAccessAllowedAce( pDacl,
                                     ACL_REVISION,
                                     dwWorldAccess,
                                     pWorldSid );
    ASSERT(fAdd) ;

    //
    // Add the owner with full control.
    //
    fAdd = AddAccessAllowedAce( pDacl,
                                ACL_REVISION,
                                MQSEC_MACHINE_GENERIC_ALL,
                                pOwner);
    ASSERT(fAdd) ;

    //
    // Add the computer account.
    //
    if (pComputerSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_SELF_RIGHTS,
                                    pComputerSid);
        ASSERT(fAdd) ;
    }

    if (pUserSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_GENERIC_ALL,
                                    pUserSid);
        ASSERT(fAdd) ;
    }

    //
    // build absolute security descriptor.
    //
    SECURITY_DESCRIPTOR  sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    if (fIncludeOwner)
    {
		bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
		ASSERT(bRet);

		PSID pGroup = NULL;
		BOOL bGroupDefaulted = FALSE;

		bRet = GetSecurityDescriptorGroup( psdOwner,
										  &pGroup,
										  &bGroupDefaulted);
		ASSERT(bRet && IsValidSid(pGroup));

		bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
		ASSERT(bRet);
    }

    bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
    ASSERT(bRet);

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwSDLen = 0;
    hr = MQSec_MakeSelfRelative( (PSECURITY_DESCRIPTOR) &sd,
                                  ppMachineSD,
                                 &dwSDLen ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }
    ASSERT(dwSDLen != 0) ;

    aProp[ *pcp ] = PROPID_QM_SECURITY ;
    apVar[ *pcp ].blob.cbSize = dwSDLen ;
    apVar[ *pcp ].blob.pBlobData = (BYTE*) *ppMachineSD ;
    (*pcp)++ ;

    return MQ_OK ;
}

//+--------------------------------------------
//
//  HRESULT MQADSpCreateMachineComputer()
//
//+--------------------------------------------

HRESULT MQADSpCreateMachineComputer(
                IN  LPCWSTR         pwcsPathName,
                IN  CDSRequestContext *pRequestContext,
                OUT WCHAR **        ppwcsFullPathName
                                    )
/*++

Routine Description:
    This routine creates computer object for a specific MSMQ-machine.

Arguments:

Return Value:
--*/
{

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
	DWORD len = __min(wcslen(pwcsPathName), MAX_COM_SAM_ACCOUNT_LENGTH);
    AP<WCHAR> pwcsMachineNameWithDollar = new WCHAR[len + 2];
	wcsncpy(pwcsMachineNameWithDollar, pwcsPathName, len);
	pwcsMachineNameWithDollar[len] = L'$';
	pwcsMachineNameWithDollar[len + 1] = L'\0';

    const DWORD xNumCreateCom = 2;
    PROPID propCreateComputer[xNumCreateCom];
    PROPVARIANT varCreateComputer[xNumCreateCom];
    DWORD j = 0;
    propCreateComputer[ j] = PROPID_COM_SAM_ACCOUNT;
    varCreateComputer[j].vt = VT_LPWSTR;
    varCreateComputer[j].pwszVal = pwcsMachineNameWithDollar;
    j++;

    propCreateComputer[j] = PROPID_COM_ACCOUNT_CONTROL ;
    varCreateComputer[j].vt = VT_UI4 ;
    varCreateComputer[j].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    j++;
    ASSERT(j == xNumCreateCom);

    HRESULT hr = MQADSpCreateComputer(
             pwcsPathName,
             j,
             propCreateComputer,
             varCreateComputer,
             0,
             NULL,
             NULL,
             pRequestContext,
             ppwcsFullPathName
             );

    return LogHR(hr, s_FN, 30);
}

//+-------------------------------------
//
//  HRESULT MQADSpCreateMachine()
//
//+-------------------------------------

HRESULT 
MQADSpCreateMachine(
     IN  LPCWSTR            pwcsPathName,
     IN  DWORD              dwObjectType,
     IN  const DWORD        cp,
     IN  const PROPID       aProp[  ],
     IN  const PROPVARIANT  apVar[  ],
     IN  const DWORD        cpEx,
     IN  const PROPID       aPropEx[  ],
     IN  const PROPVARIANT  apVarEx[  ],
     IN  CDSRequestContext *pRequestContext,
     IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
     IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
     )
/*++

Routine Description:
    This routine creates MQDS_MACHINE.
    For independent clients: msmqConfiguration is created under the computer object.
    For servers: in addition to msmqConfiguration, msmqSettings is created under site\servers

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    BOOL    fLookForWorkgroup = TRUE;

    //
    // This function can be called recursively.
    // When a workgoup machine join domain, we need to create the
    // msmqConfiguration object on a GC server. That's exactly same
    // requirement as for migrated objects. so we call CreateMigratedObject().
    // CreateMigratedObject() will call us, after it find a proper GC server.
    // So make sure we don't enter endless recursion.
    //
    for (DWORD jcp = 0; jcp < cp; jcp++)
    {
        if (aProp[jcp] == PROPID_QM_MIG_PROVIDER)
        {
            //
            // we're called from CreateMigratedObject().
            //
            fLookForWorkgroup = FALSE;
            break;
        }
    }

    if (fLookForWorkgroup)
    {
        for (DWORD jcp = 0; jcp < cp; jcp++)
        {
            if (aProp[jcp] == PROPID_QM_WORKGROUP_ID)
            {
                //
                // Need to call CreateMigratedObject().
                //
                hr = DSCoreCreateMigratedObject(
                                dwObjectType,
                                pwcsPathName,
                                cp,
                                const_cast<PROPID*>      (aProp),
                                const_cast<PROPVARIANT*> (apVar),
                                cpEx,
                                const_cast<PROPID*>      (aPropEx),
                                const_cast<PROPVARIANT*> (apVarEx),
                                pRequestContext,
                                pObjectInfoRequest,
                                pParentInfoRequest,
                                FALSE,
                                FALSE,
                                NULL,
                                NULL
								);
                return LogHR(hr, s_FN, 50);
            }
        }
    }

    ASSERT(pParentInfoRequest == NULL); // not used at present.

    //
    // Find out the type of service provided by this QM service and
    // the machine's sites
    //
    BOOL fServer = FALSE;
    DWORD dwService; 
	DWORD dwOldService = 0;
    const GUID * pSite = NULL;
    DWORD dwNumSites = 0;
    GUID * pCNs = NULL;
    DWORD dwNumCNs = 0;
    BOOL fCheckIfNeedToCreateComputerObject = FALSE;

    // [adsrv] We may get either old PROPID_QM_SERVICE or new 3 server-type-specific booleans
    // We must write 3 new specific ones
    BOOL fRouter      = FALSE,      // values
         fDSServer    = FALSE,
         fDepClServer = FALSE,
         fSetQmOldService = FALSE;

    BOOL fSetSiteIDs = TRUE;
    BOOL fForeign = FALSE;

#define MAX_NEW_PROPS  31

    //
    // We will reformat properties to include new server type control and
    // maybe SITE_IDS and maybe computer SID. and QM_SECURITY.
    //
    ASSERT((cp + 6)   < MAX_NEW_PROPS);
    ASSERT((cpEx + 4) < MAX_NEW_PROPS);

    DWORD        cp1 = 0;
    PROPID       aProp1[MAX_NEW_PROPS];
    PROPVARIANT  apVar1[MAX_NEW_PROPS];

    //
    //  We need to handle both new and old setups.
    //  Some may pass PROPID_QM_SITE_ID and some
    //  PROPID_QM_SITE_IDS
    //

    for (DWORD i = 0; i< cp ; i++)
    {
        BOOL fCopy = TRUE;
        switch (aProp[i])
        {
        // [adsrv] Even if today we don't get new server-type-specific props, we may tomorrow.
        case PROPID_QM_SERVICE_ROUTING:
            fRouter = (apVar[i].bVal != 0);
            fCopy   = FALSE;
            break;

        case PROPID_QM_SERVICE_DSSERVER:
            fDSServer  = (apVar[i].bVal != 0);
            fCopy      = FALSE;
            break;

        case PROPID_QM_SERVICE_DEPCLIENTS:
            fDepClServer = (apVar[i].bVal != 0);
            fCopy        = FALSE;
            break;

        case PROPID_QM_SERVICE:
            switch (apVar[i].ulVal)
            {
                case SERVICE_SRV:
                    fRouter = TRUE;
                    fDepClServer = TRUE;
                    dwService = apVar[i].ulVal;
                    break;

                case SERVICE_BSC:
                case SERVICE_PSC:
                case SERVICE_PEC:
                    fDSServer = TRUE;
                    fRouter = TRUE;
                    fDepClServer = TRUE;
                    dwService = apVar[i].ulVal;
                    break;

                default:
                    break;
            }

            fCopy = FALSE;
            break;

        case PROPID_QM_OLDSERVICE:
            dwOldService = apVar[i].ulVal;
            fSetQmOldService  = TRUE;
            break;

        case PROPID_QM_SITE_ID:
            pSite = apVar[i].puuid;
            dwNumSites = 1;
            fCopy = FALSE;
            //
            //  PROPID_QM_SITE_ID is used only by old setup.
            //  For old setup we need to check if computer object
            //  exist in the DS ( and if not to create one).
            //  This support is required for Win9x computers.
            //
            fCheckIfNeedToCreateComputerObject = TRUE;
            break;

        case PROPID_QM_SITE_IDS:
            pSite = apVar[i].cauuid.pElems;
            dwNumSites = apVar[i].cauuid.cElems;
            fSetSiteIDs = FALSE;
            break;

        case PROPID_QM_CNS:
            pCNs = apVar[i].cauuid.pElems;
            dwNumCNs = apVar[i].cauuid.cElems;
            break;

        case PROPID_QM_FOREIGN:
            fForeign = (apVar[i].bVal != 0);
            break;

        default:
            break;

        }
        // Copy property to the new array
        if (fCopy)
        {
            aProp1[cp1] = aProp[i];
            apVar1[cp1] = apVar[i];  // yes, there may be ptrs, but no problem - apVar is here
            cp1++;
        }

    }

    if (fRouter || fDSServer)
    {
        fServer = TRUE;  // For the case it was set by new attributes
    }

    //
    // For foreign machine definition of sites in NT5 is equal to CNs in NT4.
    // If this machine is foreign and we got PROPID_QM_CNS (it means that
    // creation was performed on NT4 PSC/BSC) we have to define PROPID_QM_SITE_IDS
    //
    if(fForeign && fSetSiteIDs)
    {
        ASSERT(dwNumCNs);
        aProp1[cp1] = PROPID_QM_SITE_IDS;
        apVar1[cp1].vt = VT_CLSID|VT_VECTOR;
        apVar1[cp1].cauuid.pElems = pCNs;
        apVar1[cp1].cauuid.cElems = dwNumCNs;
        cp1++;
    }
	else if ( fSetSiteIDs)
	{
		ASSERT(	pSite != 0);
        aProp1[cp1] = PROPID_QM_SITE_IDS;
        apVar1[cp1].vt = VT_CLSID|VT_VECTOR;
        apVar1[cp1].cauuid.pElems = const_cast<GUID *>(pSite);
        apVar1[cp1].cauuid.cElems = dwNumSites;
        cp1++;
	}

    // [adsrv] Now we add new server type attributes
    aProp1[cp1] = PROPID_QM_SERVICE_ROUTING;
    apVar1[cp1].bVal = (UCHAR)fRouter;
    apVar1[cp1].vt = VT_UI1;
    cp1++;

    aProp1[cp1] = PROPID_QM_SERVICE_DSSERVER;
    apVar1[cp1].bVal = (UCHAR)fDSServer;
    apVar1[cp1].vt = VT_UI1;
    cp1++;

    aProp1[cp1] = PROPID_QM_SERVICE_DEPCLIENTS;
    apVar1[cp1].bVal = (UCHAR)fDepClServer;
    apVar1[cp1].vt = VT_UI1;
    cp1++;
    // [adsrv] end

    DWORD dwNumofProps = cp1;

    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER createProvider;

    hr =  GetFullComputerPathName( 
				pwcsPathName,
				e_RealComputerObject,
				dwNumofProps,
				aProp1,
				apVar1,
				&pwcsFullPathName,
				&createProvider 
				);
    //
    //  If computer object not found and the
    //  caller is MSMQ 1.0 setup : create computer object
    //
    bool fDoNotImpersonateConfig = false;

    if ( (hr == MQDS_OBJECT_NOT_FOUND) &&
          fCheckIfNeedToCreateComputerObject)
    {
        hr = MQADSpCreateMachineComputer(
                    pwcsPathName,
                    pRequestContext,
                    &pwcsFullPathName
                    );

        if (SUCCEEDED(hr))
        {
            //
            // A computer object was successfully created, while
            // impersonating the caller. The MQADSpCreateMachineComputer()
            // code grant the caller the permission to create child objects
            // below the computer object (i.e., the msmqConfiguration object).
            // So we know caller can create the configuration object.
            // We also know that for msmq1.0 setup, the configuration object
            // must be created with given GUID, which need the special
            // add-guid permission. The caller usually do not have the
            // add-guid permission, but the local system account does have
            // it. So do not impersonate while creating the msmqConfigration
            // object and let the local msmq service do it.
            // bug 6294.
            //
            fDoNotImpersonateConfig = true;
        }

    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }
    //
    //  Create Computer-MSMQ-Configuration under the computer
    //
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest = NULL;
    MQDS_OBJ_INFO_REQUEST  sMachineInfoRequest;
    CAutoCleanPropvarArray cCleanQmPropvars;
    PROPID sMachineGuidProps[] = {PROPID_QM_MACHINE_ID};
    ULONG idxQmGuid = 0; //index of qm guid property in requested qm object info

    if (pObjectInfoRequest)
    {
        ASSERT(pObjectInfoRequest->cProps == ARRAY_SIZE(sMachineGuidProps));
        ASSERT(pObjectInfoRequest->pPropIDs[0] == sMachineGuidProps[0]);

        pObjInfoRequest = pObjectInfoRequest;
    }
    else if (fServer)
    {
        //
        // fetch the QM id while creating it
        //
        sMachineInfoRequest.cProps = ARRAY_SIZE(sMachineGuidProps);
        sMachineInfoRequest.pPropIDs = sMachineGuidProps;
        sMachineInfoRequest.pPropVars =
                 cCleanQmPropvars.allocClean(ARRAY_SIZE(sMachineGuidProps));

        pObjInfoRequest = &sMachineInfoRequest;
    }

    //
    // After msmqConfiguration object is created, Grant the computer account
    // read/write rights on the object. That's necessary in order for the
    // MSMQ service (on the new machine) to be able to update its type and
    // other properties, while it's talking with a domain controller from a
    // different domain.
    //
    // First, read computer object SID from ActiveDirectory.
    //
    CDSRequestContext RequestContextSid(e_DoNotImpersonate, e_ALL_PROTOCOLS);
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;
    P<BYTE> pSid = NULL;

    hr = g_pDS->GetObjectProperties( 
					createProvider,
					&RequestContextSid,
					pwcsFullPathName,
					NULL, // pGuid
					1,    // cPropIDs
					&propidSid,
					&PropVarSid 
					);
    if (SUCCEEDED(hr))
    {
        pSid = PropVarSid.blob.pBlobData;
        aProp1[dwNumofProps] = PROPID_COM_SID;
        apVar1[dwNumofProps] = PropVarSid;
        dwNumofProps++;
    }

    //
    // Time to create the default security descriptor.
    //
    P<BYTE> pMachineSD = NULL;
    BOOL fIncludeOwner = TRUE;
    if (pRequestContext->NeedToImpersonate() && fDoNotImpersonateConfig)
    {
        //
        // By default, include owner component in the security descriptor.
        // Do not include it if called from RPC (i.e., need impersonation),
        // and we decided to create the msmqConfiguration object without
        // impersonation. This is for bug 6294.
        //
        fIncludeOwner = FALSE;
    }

    //
    // Include the owner and group in security descriptor only if we're
    // going to impersonate when creating the configuration object.
    //

    hr = SetDefaultMachineSecurity( 
				dwObjectType,
				pSid,
				&dwNumofProps,
				aProp1,
				apVar1,
				pRequestContext->NeedToImpersonate(),
				 fIncludeOwner,
				(PSECURITY_DESCRIPTOR*) &pMachineSD 
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    ASSERT(dwNumofProps < MAX_NEW_PROPS);

    CDSRequestContext RequestContextConfig = *pRequestContext;
    if (fDoNotImpersonateConfig)
    {
        RequestContextConfig.SetDoNotImpersonate2();
    }

    hr = g_pDS->CreateObject(
            createProvider,
            &RequestContextConfig,
            MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME,   // object class
            x_MsmqComputerConfiguration,     // object name
            pwcsFullPathName,                // the computer name
            dwNumofProps,
            aProp1,
            apVar1,
            pObjInfoRequest,
            NULL /*pParentInfoRequest*/
			);

    if (!fServer)
    {
        return LogHR(hr, s_FN, 80);
    }

    //
    //  For servers only!
    //  Find all sites which match this server addresses and create the
    //  MSMQSetting object.
    //

    GUID guidObject;

    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||       // BUGBUG: alexdad
             hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))  // to throw away after transition
        {
            //
            // The MSMQConfiguration object already exist. So create the
            // MSMQSetting objects. This case may happen, for example, if
            // server setup was terminated before its end.
            // First step, get the MSMQConfiguration guid.
            //
            PROPID       aPropTmp[1] = {PROPID_QM_MACHINE_ID};
            PROPVARIANT  apVarTmp[1];

            apVarTmp[0].vt = VT_CLSID;
            apVarTmp[0].puuid = &guidObject;
            CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
            hr =  MQADSpGetMachineProperties( 
						pwcsPathName,
						NULL,  // guid
						1,
						aPropTmp,
						&requestDsServerInternal,
						apVarTmp
						);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 90);
            }
        }
        else
        {
            return LogHR(hr, s_FN, 100);
        }
    }
    else
    {
        ASSERT(pObjInfoRequest);
        hr = RetreiveObjectIdFromNotificationInfo( 
					pObjInfoRequest,
					idxQmGuid,
					&guidObject 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 110);
        }
    }

    hr = MQADSpCreateMachineSettings(
            dwNumSites,
            pSite,
            pwcsPathName,
            fRouter,              // [adsrv] dwService,
            fDSServer,
            fDepClServer,
            fSetQmOldService,
            dwOldService,
            &guidObject,
            cpEx,
            aPropEx,
            apVarEx,
            pRequestContext
            );

    return LogHR(hr, s_FN, 120);

#undef MAX_NEW_PROPS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\mqadsp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	mqadsp.h

Abstract:
    MQADS DLL private internal functions for
    DS queries, etc.

Author:
    ronith


--*/


#ifndef __MQADSP_H__
#define __MQADSP_H__
#include "siteinfo.h"
#include "dsads.h"
#include "dsreqinf.h"

//
//  Deletes a user object according to its digest
//
HRESULT MQADSpDeleteUserObject(
                 IN const GUID *      pDigest,
                 IN CDSRequestContext * pRequestContext
                 );

HRESULT MQADSpCreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                 );


HRESULT SearchFullComputerPathName(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN	LPCWSTR					pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName,
			OUT bool*						pfPartialMatch
            ) ;

/*====================================================

FilterSpecialCharacters

  Put escape codes before special characters (like #, =, /) in an object name

Arguments:
        pwcsObjectName :  Name of original object
        dwNameLength   :  Length of original object
        pwcsOutBuffer  :  Optional output buffer. If NULL, the function allocates an output buffer
                          and return it (caller must release). Otherwise, it writes the output to the
                          output buffer and returns it.

=====================================================*/
WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer = 0,
            OUT    DWORD_PTR* pdwCharactersProcessed = 0);

/*====================================================

MQADSpGetFullComputerPathName

Arguments:
        pwcsComputerCn :  the cn value of the computer object
        ppwcsFullPathName :  the full path name of the computer object

  It is the caller responsibility to release ppwcsFullPathName.

=====================================================*/

HRESULT MQADSpGetFullComputerPathName(
                IN  LPCWSTR                    pwcsComputerCn,
                IN  enum  enumComputerObjType  eCopmuterObjType,
                OUT LPWSTR *                   ppwcsFullPathName,
                OUT DS_PROVIDER *              pProvider
                );


/*====================================================

MQADSpSplitAndFilterQueueName

Arguments:
        pwcsPathName :  the queue name. Format machine1\queue1
        pwcsMachineName :  the machine portion of the name
        pwcsQueueName :    the queue portion of the name

  It is the caller responsibility to release pwcsMachineName and
  pwcsQueueName.

=====================================================*/
HRESULT MQADSpSplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                );


HRESULT MQADSpCreateQueue(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest
                 );

HRESULT MQADSpCreateEnterprise(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                 );

HRESULT MQADSpCreateSiteLink(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest,
                 IN  CDSRequestContext *   pRequestContext
                 );

HRESULT MQADSpGetQueueProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               );
HRESULT MQADSpGetCnProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               );
HRESULT MQADSpGetSiteProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );

HRESULT MQADSpGetMachineProperties(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext *   pRequestContext,
               OUT PROPVARIANT   apVar[]
               );

HRESULT MQADSpGetComputerProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpGetEnterpriseProperties(
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpGetSiteLinkProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );

HRESULT MQADSpGetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpQuerySiteFRSs(
                 IN  const GUID *         pguidSiteId,
                 IN  DWORD                dwService,
                 IN  ULONG                relation,
                 IN  const MQCOLUMNSET *  pColumns,
                 IN  CDSRequestContext *  pRequestContext,
                 OUT HANDLE         *     pHandle
                 );

HRESULT MQADSpGetSiteSignPK(
                 IN  const GUID  *pguidSiteId,
                 OUT BYTE       **pBlobData,
                 OUT DWORD       *pcbSize ) ;

HRESULT MQADSpGetSiteGates(
                 IN  const GUID * pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT DWORD *      pdwNumSiteGates,
                 OUT GUID **      ppaSiteGates
                 );

HRESULT MQADSpFindLink(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                );

HRESULT QueryParser(
                 IN  LPWSTR          pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle
                 );


HRESULT MQADSpCreateMachine(
                 IN  LPCWSTR            pwcsPathName,
                 IN  DWORD              dwObjectType,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
                 );

HRESULT MQADSpCreateComputer(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR            **ppwcsFullPathName
                 );

/*====================================================

MQADSpDeleteMachineObject

Arguments:
        pwcsPathName :  the cn of the computer object (may be NULL)
        pguidIdentifier : the unique id of the computer object ( may be NULL)

        Either pwcsPathName or pguidIdentifier must be not NULL ( but not both)

=====================================================*/
HRESULT MQADSpDeleteMachineObject(
                IN LPCWSTR           pwcsPathName,
                IN const GUID *      pguidIdentifier,
                IN  CDSRequestContext * pRequestContext
                );



HRESULT MQADSpDeleteMsmqSetting(
                IN const GUID *        pguidIdentifier,
                IN  CDSRequestContext *pRequestContext
                );


HRESULT MQADSpComposeFullPathName(
                IN const DWORD          dwObjectType,
                IN LPCWSTR              pwcsPathName,
                OUT LPWSTR *            ppwcsFullPathName,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                );

HRESULT MQADSpQueryNeighborLinks(
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN  CDSRequestContext *pRequestContext,
                        IN OUT CSiteGateList * pSiteGateList
                        );


/*====================================================

MQADSpComposeFullQueueName

Arguments:
        pwcsFullComputerNameName : full distinguished name of the computer object
        pwcsQueueName : the queue name (cn)

        ppwcsFullPathName : full distinguished name of the queue object

  It is the caller responsibility to release ppwcsFullPathName
=====================================================*/
HRESULT MQADSpComposeFullQueueName(
                        IN  LPCWSTR        pwcsFullComputerNameName,
                        IN  LPCWSTR        pwcsQueueName,
                        OUT LPWSTR *       ppwcsFullPathName
                        );

HRESULT MQADSpInitDsPathName();

HRESULT MQADSpGetSiteName(
        IN const GUID *       pguidSite,
        OUT LPWSTR *          ppwcsSiteName
        );


HRESULT MQADSpFilterAdsiHResults(
                         IN HRESULT hrAdsi,
                         IN DWORD   dwObjectType);


DS_PROVIDER MQADSpDecideComputerProvider(
             IN  const DWORD   cp,
             IN  const PROPID  aProp[  ]
             );

HRESULT MQADSpTranslateLinkNeighbor(
                 IN  const GUID *    pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR**         ppwcsSiteDn);


HRESULT MQADSpCreateSite(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext
                 );

HRESULT MQADSpCreateCN(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext
                 ) ;

HRESULT MQADSpFilterSiteGates(
              IN  const GUID *      pguidSiteId,
              IN  const DWORD       dwNumGatesToFilter,
              IN  const GUID *      pguidGatesToFilter,
              OUT DWORD *           pdwNumGatesFiltered,
              OUT GUID **           ppguidGatesFiltered
              );

HRESULT LocateUser(
                 IN  BOOL            fOnlyLocally,
                 IN  BOOL            fOnlyInGC,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  CDSRequestContext *pRequestContext,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps = NULL,
                 OUT BOOL           *pfUserFound = NULL
                 );

HRESULT MQADSpCreateMachineSettings(
            IN DWORD                dwNumSites,
            IN const GUID *         pSite,
            IN LPCWSTR              pwcsPathName,
            IN BOOL                 fRouter,         // [adsrv] DWORD                dwService,
            IN BOOL                 fDSServer,
            IN BOOL                 fDepClServer,
            IN BOOL                 fSetQmOldService,
            IN DWORD                dwOldService,
            IN  const GUID *        pguidObject,
            IN  const DWORD         cpEx,
            IN  const PROPID        aPropEx[  ],
            IN  const PROPVARIANT   apVarEx[  ],
            IN  CDSRequestContext * pRequestContext
            ) ;

HRESULT MQADSpSetMachinePropertiesWithSitesChange(
            IN  const  DWORD         dwObjectType,
            IN  DS_PROVIDER          provider,
            IN  CDSRequestContext *  pRequestContext,
            IN  LPCWSTR              lpwcsPathName,
            IN  const GUID *         pguidUniqueId,
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
            );

HRESULT  SetDefaultMachineSecurity( IN  DWORD           dwObjectType,
                                    IN  PSID            pComputerSid,
                                    IN OUT DWORD       *pcp,
                                    IN OUT PROPID       aProp[  ],
                                    IN OUT PROPVARIANT  apVar[  ],
                                    OUT PSECURITY_DESCRIPTOR* ppMachineSD ) ;

HRESULT  GetFullComputerPathName(
                IN  LPCWSTR                    pwcsComputerName,
                IN  enum  enumComputerObjType  eCopmuterObjType,
                IN  const DWORD                cp,
                IN  const PROPID               aProp[  ],
                IN  const PROPVARIANT          apVar[  ],
                OUT LPWSTR *                   ppwcsFullPathName,
                OUT DS_PROVIDER *              pCreateProvider ) ;

HRESULT MQADSpTranslateGateDn2Id(
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\mqcuser.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqcuser.cpp

Abstract:

    MQDSCORE library,
    private internal functions for DS operations of user objects.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include <aclapi.h>
#include "..\..\mqsec\inc\permit.h"
#include "strsafe.h"

#include "mqcuser.tmh"

static WCHAR *s_FN=L"mqdscore/mqcuser";

//+-------------------------------------
//
//  HRESULT _LocateUserByProvider()
//
//+-------------------------------------

static HRESULT _LocateUserByProvider(
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  CDSRequestContext *pRequestContext,
                 IN  DS_PROVIDER     eDSProvider,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps,
                 OUT BOOL           *pfUserFound )
{
    *pfUserFound = FALSE ;
    CDsQueryHandle hCursor;

    HRESULT hr = g_pDS->LocateBegin(
            eSubTree,	
            eDSProvider,
            pRequestContext,
            NULL,
            pRestriction,
            NULL,
            pColumns->cCol,
            pColumns->aCol,
            hCursor.GetPtr()
            );
    if (FAILED(hr))
    {
        TrERROR(DS, "_LocateUserByProvider: LocateBegin(prov- %lut) failed, hr- %lx", (ULONG) eDSProvider, hr);
        return LogHR(hr, s_FN, 10);
    }
    //
    //  read the user certificate attribute
    //
    DWORD cp = 1;
    DWORD *pcp = pdwNumofProps ;
    if (!pcp)
    {
        pcp = &cp ;
    }

    pvar->vt = VT_NULL;

    hr =  g_pDS->LocateNext(
                hCursor.GetHandle(),
                pRequestContext,
                pcp,
                pvar
                );
    if (FAILED(hr))
    {
        TrERROR(DS, "_LocateUserByProvider: LocateNext() failed, hr- %lx", hr);
        return LogHR(hr, s_FN, 20);
    }

	if (*pcp == 0)
	{
		//
		// Didn't find any certificate.
		//
		pvar->blob.cbSize = 0 ;
		pvar->blob.pBlobData = NULL ;
	}
    else
    {
        *pfUserFound = TRUE ;
    }

    return (MQ_OK);
}
//+------------------------------------------------------------------------
//
//  HRESULT LocateUser()
//
// Input Parameters:
//   IN  BOOL  fOnlyLocally- TRUE if caller want to locate the user object
//      only locally, in local replica of domain controller. that feature
//      is used when handling NT4 machines or users that do not support
//      Kerberos and can not delegate to other domain controllers.
//
//+------------------------------------------------------------------------

HRESULT LocateUser( IN  BOOL               fOnlyLocally,
                    IN  BOOL               fOnlyInGC,
                    IN  MQRESTRICTION     *pRestriction,
                    IN  MQCOLUMNSET       *pColumns,
                    IN  CDSRequestContext *pRequestContext,
                    OUT PROPVARIANT       *pvar,
                    OUT DWORD             *pdwNumofProps,
                    OUT BOOL              *pfUserFound )
{
    //
    // first query in local domain conroller.
    //
    DWORD dwNumOfProperties = 0 ;
    if (pdwNumofProps)
    {
        dwNumOfProperties = *pdwNumofProps;
    }
    BOOL fUserFound ;
    BOOL *pfFound = pfUserFound ;
    if (!pfFound)
    {
        pfFound = &fUserFound ;
    }
    *pfFound = FALSE ;

    DS_PROVIDER  eDSProvider = eLocalDomainController ;
    if (fOnlyInGC)
    {
        eDSProvider = eGlobalCatalog ;
    }

    HRESULT hr = _LocateUserByProvider( pRestriction,
                                        pColumns,
                                        pRequestContext,
                                        eDSProvider,
                                        pvar,
                                        pdwNumofProps,
                                        pfFound ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (*pfFound)
    {
        return LogHR(hr, s_FN, 40);
    }
    else if (fOnlyLocally || fOnlyInGC)
    {
        //
        // Don't look (again) in Global Catalog.
        // Search only in local domain controller, or ONLY in GC. done!
        //
        return LogHR(hr, s_FN, 50);
    }

    //
    // If user not found in local domain controller, then query GC.
    //
    if (pdwNumofProps)
    {
        *pdwNumofProps = dwNumOfProperties;
    }
    hr = _LocateUserByProvider( pRestriction,
                                pColumns,
                                pRequestContext,
                                eGlobalCatalog,
                                pvar,
                                pdwNumofProps,
                                pfFound ) ;
    return LogHR(hr, s_FN, 60);
}


HRESULT FindUserAccordingToSid(
                IN  BOOL            fOnlyLocally,
                IN  BOOL            fOnlyInGC,
                IN  BLOB *          pblobUserSid,
                IN  PROPID          propSID,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user or MQUser object according to SID, and retrieves
    the requested properties

Arguments:
    pblobUserSid - the user SID


Return Value:
    The status of the ds operation.

--*/
{
    //
    // Only one of these two flags can be true.
    //
    ASSERT(!(fOnlyLocally && fOnlyInGC)) ;

    //
    //  Find the user object according to its SID
    //
    HRESULT hr;
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = propSID;
    propertyRestriction.prval.vt = VT_BLOB;
    propertyRestriction.prval.blob = *pblobUserSid;

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = { dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = LocateUser( fOnlyLocally,
                     fOnlyInGC,
                     &restriction,
                     &Columns,
                     &requestDsServerInternal,
                     varResults,
                    &dwNumResults,
                    &fUserFound ) ;

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 80);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}

HRESULT FindUserAccordingToDigest(
                IN  BOOL            fOnlyLocally,
                IN  const GUID *    pguidDigest,
                IN  PROPID          propDigest,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user object according to digest, and retrieves
    the requested properties

Arguments:


Return Value:
    The status of the ds operation.

--*/
{
    //
    //  Find the user object according to its digest
    //
    HRESULT hr;
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = propDigest;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = const_cast<GUID *>(pguidDigest);

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = {dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;

    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate,
                                               e_IP_PROTOCOL );
    hr = LocateUser( fOnlyLocally,
                     FALSE, // fOnlyInGC
                    &restriction,
                     &Columns,
                     &requestDsServerInternal,
                     varResults,
                    &dwNumResults,
                    &fUserFound ) ;

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 100);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}

BOOL GetTextualSid(
    IN      PSID pSid,            // binary Sid
    IN      LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT  LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:
    The routine translates a Sid to a textual string

Arguments:
    pSid        - the user SID
    TextualSid  - string buffer
    lpdwBufferLen - IN: buffer length, OUT string length

Return Value:

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD  dwSubAuthorities;
    DWORD  dwSidRev=SID_REVISION;
    DWORD  dwCounter;
    DWORD  dwSidSize;
    LPTSTR szDestStr  = TextualSid;
    size_t dwSizeLeft = numeric_cast<size_t>(*lpdwBufferLen);

    // Validate the binary SID.

    if(!IsValidSid(pSid)) return LogBOOL(FALSE, s_FN, 110);

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (dwSizeLeft < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return LogBOOL(FALSE, s_FN, 120);
    }

    // Add 'S' prefix and revision number to the string.

    HRESULT hr = StringCchPrintfEx(szDestStr, dwSizeLeft, &szDestStr, &dwSizeLeft, 0,
                                   TEXT("S-%lu-"),
                                   dwSidRev );
    if( FAILED(hr ) )
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return LogBOOL(FALSE, s_FN, 121);
    }

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        hr = StringCchPrintfEx(szDestStr, dwSizeLeft, &szDestStr, &dwSizeLeft, 0,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
        if( FAILED(hr ) )
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return LogBOOL(FALSE, s_FN, 122);
        }
    }
    else
    {
        hr = StringCchPrintfEx(szDestStr, dwSizeLeft, &szDestStr, &dwSizeLeft, 0,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
        if( FAILED(hr ) )
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return LogBOOL(FALSE, s_FN, 123);
        }
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        hr = StringCchPrintfEx(szDestStr, dwSizeLeft, &szDestStr, &dwSizeLeft, 0,
                               TEXT("-%lu"),
                               *GetSidSubAuthority(pSid, dwCounter) );
        if( FAILED(hr ) )
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return LogBOOL(FALSE, s_FN, 124);
        }
    }

    *lpdwBufferLen = numeric_cast<DWORD>(szDestStr - TextualSid + 1);
    
    return TRUE;
}

static HRESULT PrepareUserName(
                IN  PSID        pSid,
                OUT WCHAR **    ppwcsUserName
                               )
/*++

Routine Description:
    The routine prepare a name string for a mq-user object
    according to its sid

Arguments:
    pSid        - the user SID
    ppwcsUserName  - name string

Return Value:

--*/
{
    //
    //  First try to translate sid to user name
    //
    const DWORD  cLen = 512;
    WCHAR  szTextualSid[cLen ];
    DWORD  dwTextualSidLen = cLen ;
    //
    //  Translate the SID into a string
    //
    if (GetTextualSid(
        pSid,
        szTextualSid,
        &dwTextualSidLen
        ))
    {
        //
        //  return to the user the last 64 WCHARs ( length limit of cn attribute)
        //
        if ( dwTextualSidLen < 64)
        {
            *ppwcsUserName = newwcs(szTextualSid);
        }
        else
        {
            *ppwcsUserName = newwcs(&szTextualSid[dwTextualSidLen - 64 - 1]);
        }
        return(MQ_OK);
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 140);
    }
}

//+--------------------------------
//
//  void  _PrepareCert()
//
//+--------------------------------

void  _PrepareCert(
            IN  PROPVARIANT * pvar,
            IN  GUID *        pguidDigest,
            IN  GUID *        pguidId,
            OUT BYTE**        ppbAllocatedCertBlob
            )
/*++

Routine Description:
    The routine prepares the certificate blob according to the structure
    that we keep in the DS

Arguments:

Return Value:

--*/
{
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( pvar->blob.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   pvar->blob.cbSize,
                                   pvar->blob.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
    CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pUserCertBlob->MarshaleIntoBuffer( pbTmp);
    pvar->blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;
    *ppbAllocatedCertBlob = pbTmp;
    pvar->blob.pBlobData= pbTmp.detach();

}

//+----------------------------------
//
//   HRESULT _CreateMQUser()
//
//+----------------------------------

HRESULT _CreateMQUser(
            IN CDSRequestContext   *pRequestContext,
            IN LPCWSTR              pwcsUserName,       // object name
            IN LPCWSTR              pwcsParentPathName, // object parent name
            IN DWORD                cPropIDs,           // number of attributes
            IN const PROPID        *pPropIDs,           // attributes
            IN const MQPROPVARIANT *pPropVars )         // attribute values
{
    HRESULT hr = g_pDS->CreateObject( eLocalDomainController,
                                    pRequestContext,
                                    MSMQ_MQUSER_CLASS_NAME,
                                    pwcsUserName,
                                    pwcsParentPathName,
                                    cPropIDs,
                                    pPropIDs,
                                    pPropVars,
                                    NULL,    /* pObjInfoRequest*/
                                    NULL ) ; /* pParentInfoRequest*/
    return LogHR(hr, s_FN, 150);
}

//+------------------------------------------
//
//   HRESULT  MQADSpCreateMQUser()
//
//+------------------------------------------

HRESULT  MQADSpCreateMQUser(
                 IN  LPCWSTR            pwcsPathName,
                 IN  DWORD              dwIndexSidProp,
                 IN  DWORD              dwIndexCertProp,
                 IN  DWORD              dwIndexDigestProp,
                 IN  DWORD              dwIndexIdProp,
                 IN  const DWORD        cp,
                 IN  const PROPID       aPropIn[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                                   )
{
    ASSERT(pwcsPathName == NULL);
	DBG_USED(pwcsPathName);

    //
    //  translate the SID into a user name
    //
    PSID pUserSid = apVar[ dwIndexSidProp].blob.pBlobData ;
    ASSERT(IsValidSid(pUserSid)) ;

    AP<WCHAR> pwcsUserName;
    HRESULT hr =  PrepareUserName( pUserSid,
                                  &pwcsUserName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    DWORD     sizeCh = wcslen(g_pwcsLocalDsRoot) + x_msmqUsersOULen + 2;
    AP<WCHAR> pwcsParentPathName = new WCHAR[sizeCh] ;
    hr = StringCchPrintf(pwcsParentPathName, sizeCh,
                        L"%s,%s",
                        x_msmqUsersOU,
                        g_pwcsLocalDsRoot.get()
            			);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 165);
    }
    //
    //  Prepare the certificate attribute
    //
    DWORD cNewProps = cp + 1 ;
    P<PROPID> pPropId = new PROPID[ cNewProps ] ;
    memcpy( pPropId, aPropIn, sizeof(PROPID) * cp);
    AP<PROPVARIANT> pvarTmp = new PROPVARIANT[ cNewProps ];
    memcpy( pvarTmp, apVar, sizeof(PROPVARIANT) * cp);

    AP<BYTE> pCleanBlob;
    _PrepareCert(
            &pvarTmp[dwIndexCertProp],
            pvarTmp[dwIndexDigestProp].puuid,
            pvarTmp[dwIndexIdProp].puuid,
            &pCleanBlob
            );

    //
    // Prepare security descriptor.
    // This code may be called from the upgrade wizard or replication service
    // so we can not impersonte in order to get user sid. Instead, we'll
    // create an input security descriptor that contain only the owner.
    //
    SECURITY_DESCRIPTOR sd ;
    BOOL fSec = InitializeSecurityDescriptor( &sd,
                                            SECURITY_DESCRIPTOR_REVISION ) ;
    ASSERT(fSec) ;
    fSec = SetSecurityDescriptorOwner( &sd, pUserSid, TRUE ) ;
    ASSERT(fSec) ;

    pPropId[ cp ] = PROPID_MQU_SECURITY ;
    PSECURITY_DESCRIPTOR psd = NULL ;

    hr =  MQSec_GetDefaultSecDescriptor( MQDS_MQUSER,
                                         &psd,
                                         FALSE, /* fImpersonate */
                                         &sd,
                                         (OWNER_SECURITY_INFORMATION |
                                          GROUP_SECURITY_INFORMATION),
                                         e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }
    ASSERT(psd && IsValidSecurityDescriptor(psd)) ;
    P<BYTE> pAutoDef = (BYTE*) psd ;
    pvarTmp[ cp ].blob.pBlobData = (BYTE*) psd ;
    pvarTmp[ cp ].blob.cbSize = GetSecurityDescriptorLength(psd) ;

    hr = _CreateMQUser( pRequestContext,
                        pwcsUserName,
                        pwcsParentPathName,
                        cNewProps,
                        pPropId,
                        pvarTmp ) ;

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
    {
        //
        // Ignore the object guid when creating the msmqMigratedUser object.
        // Why don't I change this property in the first call ?
        // to avoid regressions.
        // Using the object guid is fine if we're running on a GC. Migration
        // code (both wizard and replication service) run on GC so they
        // should be fine with first call. Only msmq server on non-GC domain
        // controllers will see this problem, when users will try to register
        // certificate for the first time (when this object doesn't yet
        // exist). So for these cases, try again without the guid.
        //
        pPropId[ dwIndexIdProp ] = PROPID_QM_DONOTHING  ;

        hr = _CreateMQUser( pRequestContext,
                            pwcsUserName,
                            pwcsParentPathName,
                            cNewProps,
                            pPropId,
                            pvarTmp ) ;
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        //
        //  try to create msmqUsers ( it is probably not there)
        //  and try again to recreate the user
        //
        hr = g_pDS->CreateOU(
                eLocalDomainController,
                pRequestContext,
                x_msmqUsers,
                g_pwcsLocalDsRoot,
                L"Default container for MSMQ certificates of Windows NT 4.0 domain users");
        if (FAILED(hr))
        {
            TrERROR(DS, "mqcuser.cpp, Failed to create msmqUsers OU, hr- %lx", hr);

            return LogHR(hr, s_FN, 175);
        }

        hr = _CreateMQUser( pRequestContext,
                            pwcsUserName,
                            pwcsParentPathName,
                            cNewProps,
                            pPropId,
                            pvarTmp ) ;
    }

    return LogHR(hr, s_FN, 180);
}

//+---------------------------------------
//
//  HRESULT _DeleteUserObject()
//
//+---------------------------------------

static  HRESULT _DeleteUserObject(
                        IN const GUID *         pDigest,
                        IN  CDSRequestContext  *pRequestContext,
                        IN  PROPID             *propIDs,
                        IN  PROPID              propDigest )
/*++

Routine Description:
    The routine deletes user object according to its digest

Arguments:
    pDigest - the digest of the user object to be deleted

Return Value:
    The status of the ds operation.

--*/
{
    HRESULT hr;
    //
    //  This routine deletes a user certificate according to its
    //  digest.
    //  A user object may contain multiple digests and certificates
    //

    //
    //  Find the user object
    //
    DWORD cp = 3;
    MQPROPVARIANT propvar[3];
    propvar[0].vt = VT_NULL;    // BUGBUG - to define a init routine
    propvar[1].vt = VT_NULL;
    propvar[2].vt = VT_NULL;

    hr =  FindUserAccordingToDigest(
                    FALSE,  // fOnlyLocally
                    pDigest,
                    propDigest,
                    cp,
                    propIDs,
                    propvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    ASSERT( propvar[0].vt == VT_CLSID);
    P<GUID> pguidUserId = propvar[0].puuid;

    ASSERT( propvar[1].vt == (VT_CLSID | VT_VECTOR));
    AP<GUID> pDigestArray = propvar[1].cauuid.pElems;

    ASSERT( propvar[2].vt == VT_BLOB);
    P<BYTE> pbyteCertificate = propvar[2].blob.pBlobData;

    if ( propvar[1].cauuid.cElems == 1)
    {
        //
        //  Last digest and certificate
        //
        propvar[1].cauuid.cElems = 0;
        propvar[2].blob.cbSize = 0;
    }
    else
    {
        BOOL fFoundDigest = FALSE;
        //
        //  remove the requested digest for the digest-vector
        //
        for ( DWORD i = 0 ; i < propvar[1].cauuid.cElems; i++)
        {
            if ( propvar[1].cauuid.pElems[i] == *pDigest)
            {
                fFoundDigest = TRUE;
                //
                //  found the entry to remove
                //
                for ( DWORD j = i + 1; j < propvar[1].cauuid.cElems; j++)
                {
                    propvar[1].cauuid.pElems[ j - 1] = propvar[1].cauuid.pElems[j];
                }
                break;
            }
        }
        propvar[1].cauuid.cElems--;
        ASSERT( fFoundDigest);
        //
        //  Remove the certificate
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( propvar[2].blob.pBlobData);

        DWORD dwSizeToRemoveFromBlob;
        hr = pUserCertBlob->RemoveCertificateFromBuffer(
                            pDigest,
                            propvar[2].blob.cbSize,
                            &dwSizeToRemoveFromBlob);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 200);
        }
        propvar[2].blob.cbSize -=  dwSizeToRemoveFromBlob;

    }

    //
    //  Update user properties with new values
    //
    hr =  g_pDS->SetObjectProperties(
                eDomainController,
                pRequestContext,
                NULL,             // object name
                pguidUserId,      // unique id of object
                2,
                &propIDs[1],
                &propvar[1],
                NULL /*pObjInfoRequest*/);

   return LogHR(hr, s_FN, 210);
}

//+----------------------------------------
//
//  HRESULT MQADSpDeleteUserObject()
//
//+----------------------------------------

HRESULT MQADSpDeleteUserObject(
                         IN const GUID *        pDigest,
                         IN CDSRequestContext  *pRequestContext
                         )
/*++

Routine Description:
    The routine deletes user object.
    It first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

Arguments:
    pDigest - the digest of the user object to be deleted
    pRequestContext - the requester context

Return Value:
    The status of the ds operation.

--*/
{
    //
    // First try to delete from a User object.
    //
    PROPID UserProp[3] = { PROPID_U_ID,
                           PROPID_U_DIGEST,
                           PROPID_U_SIGN_CERT};

    HRESULT hr = _DeleteUserObject( pDigest,
                                    pRequestContext,
                                    UserProp,
                                    PROPID_U_DIGEST) ;

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // User objectnot found. Try computer object.
        //
        PROPID ComUserProp[3] = { PROPID_COM_ID,
                                  PROPID_COM_DIGEST,
                                  PROPID_COM_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( pDigest,
                                pRequestContext,
                                ComUserProp,
                                PROPID_COM_DIGEST ) ;
    }

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Computer objectnot found. Try msmqUser object.
        //
        PROPID MQUserProp[3] = { PROPID_MQU_ID,
                                 PROPID_MQU_DIGEST,
                                 PROPID_MQU_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( pDigest,
                                pRequestContext,
                                MQUserProp,
                                PROPID_MQU_DIGEST ) ;
    }

    return LogHR(hr, s_FN, 220);
}

//+-------------------------------------------
//
//  HRESULT _GetUserProperties()
//
//+-------------------------------------------

static HRESULT _GetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidDigest,
               IN  PROPID        propidDigest,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * /*pRequestContext*/,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);
    HRESULT hr;
    //
    //  Find the user object according to the digest
    //

    CAutoCleanPropvarArray propArray;
    MQPROPVARIANT * ppropvar = new MQPROPVARIANT[ cp];
    propArray.attachClean( cp, ppropvar);

    hr = FindUserAccordingToDigest(
                    FALSE,  // fOnlyLocally
                    pguidDigest,
                    propidDigest,
                    cp,
                    aProp,
                    ppropvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }
    //
    //  Is one of the properties is PROPID_U_SIGN_CERT ?
    //
    DWORD i;
    BOOL  fGetCert = FALSE;
    for ( i =0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_U_SIGN_CERT   ||
             aProp[i] == PROPID_COM_SIGN_CERT ||
             aProp[i] == PROPID_MQU_SIGN_CERT)
        {
            fGetCert = TRUE;
            break;
        }
    }
    //
    //  Parse the user certificates array, and return only the certificate
    //  associate with the requested digest
    //
    if( fGetCert)
    {
        ASSERT( i < cp);
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( ppropvar[i].blob.pBlobData);

        const CUserCert * pUserCert = NULL;
        hr = pUserCertBlob->GetUserCert( pguidDigest,
                                         &pUserCert );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 240);
        }
        hr = pUserCert->CopyIntoBlob(&apVar[i]);
        {
            if ( FAILED(hr))
            {
                return LogHR(hr, s_FN, 250);
            }
        }
    }

    //
    //  Copy the rest of proerties
    //
    for ( DWORD j = 0; j < cp; j++)
    {
        //
        //  don't copy the user cert property
        //
        if ( j != i)
        {
            apVar[j] = ppropvar[j];
            ppropvar[j].vt = VT_NULL;    // not to free allocated buffers
        }
    }


   return(MQ_OK);


}

//+-----------------------------------------
//
//  HRESULT MQADSpGetUserProperties()
//
//+-----------------------------------------

HRESULT MQADSpGetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:
    The routine retrieve user object.
    It first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

Arguments:
    pDigest - the digest of the user object to be deleted
    pRequestContext - the requester context

Return Value:
    The status of the ds operation.

--*/
{
    //
    //  BUGBUG - performance : two impersonations
    //
    HRESULT hr = _GetUserProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        PROPID_U_DIGEST,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in a computer object.
        //
        // Change propid from _U_ property to _COM_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_COM_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_COM_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_COM_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_COM_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    PROPID_COM_DIGEST,
                    cp,
                    tmpProp,
                    pRequestContext,
                    apVar
                    );
    }

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in the msmqUsers container
        //
        // Change propid from _U_ property to _MQU_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_MQU_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_MQU_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    PROPID_MQU_DIGEST,
                    cp,
                    tmpProp,
                    pRequestContext,
                    apVar
                    );
    }

    return LogHR(hr, s_FN, 260);
}

//+----------------------------------------
//
//   HRESULT  _CreateUserObject()
//
//+----------------------------------------

static HRESULT  _CreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);
    //
    //  search the user according to its SID
    //
    DWORD dwNeedToFind = 3;
    BLOB blobUserSid;
    BLOB blobSignCert = {0, 0};
    GUID * pguidDigest = NULL;
    GUID * pguidId = NULL;  // if the caller doesn't supply it, use the digest as
                            // the id

    PROPID propSID = (PROPID)-1;
    for ( DWORD i = 0 ; i < cp; i++)
    {
        if ( (aProp[i] == PROPID_U_SID)    ||
             (aProp[i] == PROPID_COM_SID)  ||
             (aProp[i] == PROPID_MQU_SID) )
        {
            blobUserSid= apVar[i].blob;
            propSID = aProp[i];
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_SIGN_CERT)   ||
             (aProp[i] == PROPID_COM_SIGN_CERT) ||
             (aProp[i] == PROPID_MQU_SIGN_CERT) )
        {
            blobSignCert = apVar[i].blob;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_DIGEST)   ||
             (aProp[i] == PROPID_COM_DIGEST) ||
             (aProp[i] == PROPID_MQU_DIGEST) )
        {
            pguidDigest = apVar[i].puuid;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_ID)   ||
             (aProp[i] == PROPID_COM_ID) ||
             (aProp[i] == PROPID_MQU_ID) )
        {
            pguidId = apVar[i].puuid;
        }
    }

    PROPID propDigest = PROPID_U_DIGEST;
    if (propSID == PROPID_COM_SID)
    {
        propDigest = PROPID_COM_DIGEST;
    }
    else if (propSID == PROPID_MQU_SID)
    {
        propDigest = PROPID_MQU_DIGEST;
    }

    if ( dwNeedToFind != 0)
    {
        TrERROR(DS, "_CreateUserObject : Wrong input properties");
        return LogHR(MQ_ERROR, s_FN, 270);
    }
    if ( pguidId == NULL)
    {
        //
        //  Use the digest as the id ( for replication to NT4 only)
        //
        pguidId = pguidDigest;
    }
    //
    //  Find the user object according to its SID
    //
    HRESULT hr;
    const DWORD cNumProperties = 3;
    PROPID prop[cNumProperties] = { propDigest,
                                    PROPID_U_SIGN_CERT,
                                    PROPID_U_ID};
    MQPROPVARIANT var[ cNumProperties];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    ASSERT( cNumProperties == 3);

    hr =  FindUserAccordingToSid(
                 FALSE,  // fOnlyLocally
                 FALSE,  // fOnlyInGC
                &blobUserSid,
                propSID,
                cNumProperties,
                prop,
                var
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
    AP<GUID> pCleanDigest =  var[0].cauuid.pElems;
    AP<BYTE> pCleanCert = var[1].blob.pBlobData;
    P<GUID> pCleanId =  var[2].puuid;

    //
    // Check if it's a new user certificate or one that is already registered.
    // Control panel code first try to register old certificate (to verify
    // that user indeed has write permission in the active directory to do
    // that) and only then create a new certificate and register it. So
    // this case (trying to register an existing certificate) is legitimate
    // and mqrt.dll + control panel handle it correctly.
    //
    DWORD dwSize = var[0].cauuid.cElems;
    for ( DWORD j = 0; j < dwSize; j++)
    {
        if ( pCleanDigest[j] == *pguidDigest)
        {
            return LogHR(MQDS_CREATE_ERROR, s_FN, 290); // for compatability : RT translates to MQ_ERROR_INTERNAL_USER_CERT_EXIST
        }
    }

    //
    //  Now add the digest and certificate to the array of values
    //
    //
    //  First digest array
    //
    AP<GUID> pGuids = new GUID[ dwSize  + 1];
    if ( dwSize)
    {
        memcpy( pGuids, pCleanDigest, dwSize * sizeof(GUID));  // old array content
    }
    memcpy( &pGuids[ dwSize], pguidDigest, sizeof(GUID));    // new addition
    var[0].cauuid.cElems += 1;
    var[0].cauuid.pElems = pGuids;
    //
    //  Second user certificate
    //
    ASSERT( prop[1] == PROPID_U_SIGN_CERT);

    dwSize = var[1].blob.cbSize;
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( blobSignCert.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   blobSignCert.cbSize,
                                   blobSignCert.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    if ( dwSize)
    {
        pbTmp = new BYTE[ dwSize + ulUserCertBufferSize];
        //
        //  there are already certificates for this user
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( var[1].blob.pBlobData);

        pUserCertBlob->IncrementNumCertificates();
        memcpy( pbTmp, var[1].blob.pBlobData, dwSize);
        pUserCert->MarshaleIntoBuffer( &pbTmp[ dwSize]);
        var[1].blob.cbSize = dwSize + ulUserCertBufferSize;

    }
    else
    {
        pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
        CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                    pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        pUserCertBlob->MarshaleIntoBuffer( pbTmp);
        var[1].blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;

    }

    var[1].blob.pBlobData = pbTmp;

    //
    //  Update the user object with the new values
    //
    hr = g_pDS->SetObjectProperties(
                eDomainController,
                pRequestContext,
                NULL,
                var[2].puuid,      // unique id of this user
                2,
                prop,
                var,
                NULL /*pObjInfoRequest*/);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpCreateUser : failed to update user props %lx", hr);
    }
    return LogHR(hr, s_FN, 300);
}

//+------------------------------------
//
//  HRESULT MQADSpCreateUserObject()
//
//  Register a certificate.
//
//+------------------------------------

HRESULT MQADSpCreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
{
    //
    // First try "standard" user objects.
    //
    HRESULT hr = _CreateUserObject(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext
                         );
    if (hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 310);
    }

    for (DWORD i = 0 ; i < cp ; i++ )
    {
        if (aProp[i] == PROPID_COM_SID)
        {
            //
            // Computer object for registering a certificate from service
            // must be found in the Active Directory. If not found, it's
            // a weird error. quit !
            //
            return LogHR(hr, s_FN, 320);
        }
    }

    //
    // try to find the user object in the msmqUsers container
    //
    // create new PROPID array with PROPID_MQU_* property
    // instead of PROPID_U_*
    //
    DWORD dwSIDPropNum = cp;
    DWORD dwCertPropNum = cp;
    DWORD dwDigestPropNum = cp;
    DWORD dwIdPropNum = cp;
    AP<PROPID> tmpProp = new PROPID[ cp ];
    for ( i=0; i<cp; i++)
    {
        switch ( aProp[i])
        {
            case PROPID_U_SID:
                dwSIDPropNum = i;
                tmpProp[i] = PROPID_MQU_SID;
                break;
            case PROPID_U_SIGN_CERT:
                dwCertPropNum = i;
                tmpProp[i] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_MASTERID:
                tmpProp[i] = PROPID_MQU_MASTERID;
                break;
            case PROPID_U_SEQNUM:
                tmpProp[i] = PROPID_MQU_SEQNUM;
                break;
            case PROPID_U_DIGEST:
                dwDigestPropNum = i;
                tmpProp[i] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_ID:
                dwIdPropNum = i;
                tmpProp[i] = PROPID_MQU_ID;
                break;
            default:
                ASSERT(0);
                break;
        }
    }

    if ( (dwSIDPropNum == cp) || (dwDigestPropNum == cp) ||
         (dwIdPropNum == cp) ||  (dwCertPropNum == cp))
    {
        TrERROR(DS, "MQADSpCreateUser : Wrong input properties");
        return LogHR(MQ_ERROR, s_FN, 330);
    }
    hr = _CreateUserObject(
                     pwcsPathName,
                     cp,
                     tmpProp,
                     apVar,
                     pRequestContext
                     );
    if ( hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 340);
    }
    //
    //  No User or MQUser object were found (for this SID).
    //  We assume it is a NT4 user and we'll create MQUser for
    //  it (in which we'll store the certificates).
    //  Creating the msmqMigratedUser (and its OU) are done in the context
    //  of the msmq service (or migration code), not in the context of the
    //  user. That's similar to regular Windows users, that are not the
    //  owner of their user object and have no permissions on that object.
    //
    CDSRequestContext RequestContextOU ( e_DoNotImpersonate,
                                         e_ALL_PROTOCOLS ) ;
    hr = MQADSpCreateMQUser(
                     pwcsPathName,
                     dwSIDPropNum,
                     dwCertPropNum,
                     dwDigestPropNum,
                     dwIdPropNum,
                     cp,
                     tmpProp,
                     apVar,
                     &RequestContextOU
                     );
    return LogHR(hr, s_FN, 350);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\mqcsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqcsite.cpp

Abstract:

    MQDSCORE library,
    private internal functions for DS queries of site objects.

Author:

    ronit hartmann (ronith)  (first version in mqadsp.cpp)
    Doron Juster   (DoronJ)  split files and add sign key query.

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "dscore.h"

#include "mqcsite.tmh"

static WCHAR *s_FN=L"mqdscore/mqcsite";

//+-------------------------------------
//
//  HRESULT MQADSpGetSiteProperties()
//
//+-------------------------------------

HRESULT MQADSpGetSiteProperties(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT   apVar[] )
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;

    if (pwcsPathName)
    {
        //
        //  Path name format is machine1\queue1.
        //  expand machine1 name to a full computer path name
        //
        DS_PROVIDER not_in_use_provider;

        hr =  MQADSpComposeFullPathName(
                        MQDS_SITE,
                        pwcsPathName,
                        &pwcsFullPathName,
                        &not_in_use_provider );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 10);
        }
    }

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 20);

}


HRESULT MQADSpGetSiteLinkProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    AP<WCHAR> pwcsFullPathName;

    if  (pwcsPathName)
    {
        //
        //  expand link name to a full DN name
        //
        DS_PROVIDER not_in_use_provider;

        hr =  MQADSpComposeFullPathName(
                MQDS_SITELINK,
                pwcsPathName,
                &pwcsFullPathName,
                &not_in_use_provider
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 30);
        }
    }

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        pwcsFullPathName,
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 40);
}

HRESULT MQADSpGetSiteGates(
                 IN  const GUID * pguidSiteId,
                 IN  CDSRequestContext * /*pRequestContext*/,
                 OUT DWORD *      pdwNumSiteGates,
                 OUT GUID **      ppaSiteGates
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  Is it my site
    //
    if ( g_pMySiteInformation->IsThisSite(pguidSiteId))
    {
        //
        //  return the list of session concentration site-gates
        //  ( i.e. site-gates that belong to this site only)
        //  on any of this site links
        //
        HRESULT hr2 = g_pMySiteInformation->FillSiteGates(
                pdwNumSiteGates,
                ppaSiteGates
                );
        return LogHR(hr2, s_FN, 50);
    }

    //
    //  another site
    //
    *pdwNumSiteGates = 0;
    *ppaSiteGates = NULL;
    CSiteGateList SiteGateList;
    HRESULT hr;
    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,     // internal operation of the DS server
 	            NULL,      // object name
                pguidSiteId,      // unique id of object
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpGetSiteGates : Failed to retrieve the DN of the site %lx", hr);
        return LogHR(hr, s_FN, 60);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;


    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-1
    //
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        &requestDsServerInternal,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpGetSiteGates : Failed to query neighbor1 links %lx", hr);
        return LogHR(hr, s_FN, 70);

    }

    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-2
    //
    CDSRequestContext requestDsServerInternal2( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        &requestDsServerInternal2,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpGetSiteGates : Failed to query neighbor2 links %lx", hr);
        return LogHR(hr, s_FN, 80);

    }

    //
    //  Fill in the results
    //
    AP<GUID> pguidLinkSiteGates;
    DWORD dwNumLinkSiteGates = 0;

    SiteGateList.CopySiteGates(
               &pguidLinkSiteGates,
               &dwNumLinkSiteGates
               );

    if ( dwNumLinkSiteGates == 0)
    {
        *pdwNumSiteGates = 0;
        *ppaSiteGates = NULL;
        return(MQ_OK);
    }
    //
    //  Filter the list of site-gates,
    //  and return only gates that belong
    //  to the requested site ( they may
    //  belong to more than one site)
    //
    hr = MQADSpFilterSiteGates(
            pguidSiteId,
            dwNumLinkSiteGates,
            pguidLinkSiteGates,
            pdwNumSiteGates,
            ppaSiteGates
            );
    return LogHR(hr, s_FN, 90);

}

//+----------------------------------
//
// HRESULT MQADSpGetSiteName()
//
//+----------------------------------

HRESULT MQADSpGetSiteName(
                IN const GUID *     pguidSite,
                OUT LPWSTR *        ppwcsSiteName )
{

    //
    //  Find site
    //
    MQRESTRICTION restrictionSite;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionSite.cRes = 1;
    restrictionSite.paPropRes = &propertyRestriction;

    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = PROPID_S_SITEID;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = const_cast<GUID*>(pguidSite);

    PROPID  prop = PROPID_S_FULL_NAME;

    CDsQueryHandle  hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restrictionSite,
            NULL,
            1,
            &prop,
            hQuery.GetPtr()
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }
    DWORD cp = 1;
    MQPROPVARIANT var;
    var.vt = VT_NULL;

    hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

	if(cp == 0)
	{
        TrERROR(DS, "Failed to get site name for SiteGuid = %!guid!", pguidSite);
        return MQDS_UNKNOWN_SITE_ID;
	}

    ASSERT(cp == 1);
    ASSERT(var.vt == VT_LPWSTR);

    *ppwcsSiteName = var.pwszVal;
    return(MQ_OK);
}

HRESULT MQADSpTranslateGateDn2Id(
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        )
/*++

Routine Description:
    This routine translate PROPID_L_GATES_DN into unique-id array
    of the gates.

Arguments:
    pvarGatesDN -   varaint containing PROPID_L_GATES_DN

Return Value:
--*/
{
    //
    //  For each gate translate its DN to unique id
    //
    if ( pvarGatesDN->calpwstr.cElems == 0)
    {
        *pdwNumLinkSiteGates = 0;
        *ppguidLinkSiteGates = NULL;
        return( MQ_OK);
    }
    //
    //  there are gates
    //
    AP<GUID> pguidGates = new GUID[ pvarGatesDN->calpwstr.cElems];
    PROPID prop = PROPID_QM_MACHINE_ID;
    DWORD  dwNextToFill = 0;
    PROPVARIANT var;
    var.vt = VT_CLSID;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    for ( DWORD i = 0; i < pvarGatesDN->calpwstr.cElems; i++)
    {
        var.puuid = &pguidGates[ dwNextToFill];

        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,		    // local DC or GC
                    &requestDsServerInternal,
 	                pvarGatesDN->calpwstr.pElems[i],      // object name
                    NULL,      // unique id of object
                    1,
                    &prop,
                    &var);
        if ( SUCCEEDED(hr))
        {
            dwNextToFill++;
        }


    }
    if ( dwNextToFill > 0)
    {
        //
        //  succeeded to translate some or all gates, return them
        //
        *pdwNumLinkSiteGates = dwNextToFill;
        *ppguidLinkSiteGates = pguidGates.detach();
        return( MQ_OK);

    }
    //
    //  Failed to translate gates
    //
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    return MQ_OK;
}


HRESULT MQADSpQueryLinkSiteGates(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    HRESULT hr;
    //
    //  BUGBUG - performance: to do impersonation only once
    //
    //
    //  First translate site id to site DN
    //
    AP<WCHAR> pwcsNeighbor1Dn;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpTranslateLinkNeighbor(
                 pguidSiteId1,
                 &requestDsServerInternal,    // internal DS operation
                 &pwcsNeighbor1Dn);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    AP<WCHAR> pwcsNeighbor2Dn;
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpTranslateLinkNeighbor(
                 pguidSiteId2,
                 &requestDsServerInternal1,    // internal DS operation
                 &pwcsNeighbor2Dn);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 140);
    }

    //
    //  Prepare a restriction where neighbor1_DN == pwcsNeighbor1Dn
    //  and neighbor2_DN == pwcsNeighbor2Dn
    //
    MQPROPERTYRESTRICTION propRestriction[2];
    propRestriction[0].rel = PREQ;
    propRestriction[0].prop = PROPID_L_NEIGHBOR1_DN;
    propRestriction[0].prval.vt = VT_LPWSTR;
    propRestriction[0].prval.pwszVal = pwcsNeighbor1Dn;

    propRestriction[1].rel = PREQ;
    propRestriction[1].prop = PROPID_L_NEIGHBOR2_DN;
    propRestriction[1].prval.vt = VT_LPWSTR;
    propRestriction[1].prval.pwszVal = pwcsNeighbor2Dn;

    MQRESTRICTION restriction;
    restriction.cRes = 2;
    restriction.paPropRes = propRestriction;

    PROPID prop = PROPID_L_GATES_DN;

    CDsQueryHandle hQuery;

    hr = g_pDS->LocateBegin(
            eOneLevel,	
            eLocalDomainController,	
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpQueryLinkSiteGates : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 150);
    }
    //
    //  Read the result ( maximim one result)
    //
    DWORD cp = 1;
    CMQVariant var;
    var.SetNULL();

    hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                pRequestContext,
                &cp,
                var.CastToStruct()
                );
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpQueryLinkSiteGates : Locate next failed %lx", hr);
        return LogHR(hr, s_FN, 160);
    }
    ASSERT( cp <= 1);
    if ( cp == 1)
    {
        HRESULT hr2 = MQADSpTranslateGateDn2Id(
                var.CastToStruct(),
                ppguidLinkSiteGates,
                pdwNumLinkSiteGates);
        return LogHR(hr2, s_FN, 170);

    }
    return(MQ_OK);

}


HRESULT MQADSpFindLink(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkGates,
                OUT DWORD *      pdwNumLinkGates
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    //
    //  The link between the two site can be
    //  either s1<->s2 or s2<->s1
    //  But not as both!!! (BUGBUG is this assumption still valid)
    //
    HRESULT hr;
    //
    //  Query link between neighbor1 and neighbor2
    //
    hr = MQADSpQueryLinkSiteGates(
                pguidSiteId1,
                pguidSiteId2,
                pRequestContext,
                ppguidLinkGates,
                pdwNumLinkGates
                );
    if (FAILED(hr) || (*pdwNumLinkGates == 0))
    {

    //
    //  Query link between neighbor2 and neighbor1
    //
        hr = MQADSpQueryLinkSiteGates(
                    pguidSiteId2,
                    pguidSiteId1,
                    pRequestContext,
                    ppguidLinkGates,
                    pdwNumLinkGates
                    );

    }
    return LogHR(hr, s_FN, 180);
}

//+------------------------------------------
//
//  HRESULT MQADSpQueryNeighborLinks()
//
//+------------------------------------------

HRESULT MQADSpQueryNeighborLinks(
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN  CDSRequestContext *pRequestContext,
                        IN OUT CSiteGateList * pSiteGateList
                        )

/*++

Routine Description:

Arguments:
        eLinkNeighbor :  specify according to which neighbor property, to perform
                         the locate ( PROPID_L_NEIGHBOR1 or PROPID_L_NEIGHBOR2)
        pwcsNeighborDN : the DN name of the site

        CSiteGateList : list of site-gates

Return Value:
--*/
{
    //
    //  Query the gates on all the links of a specific site ( pwcsNeighborDN).
    //  But only on links where the site is specified as
    //  neighbor-i ( 1 or 2)
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;

    if ( LinkNeighbor == eLinkNeighbor1)
    {
        propRestriction.prop = PROPID_L_NEIGHBOR1_DN;
    }
    else
    {
        propRestriction.prop = PROPID_L_NEIGHBOR2_DN;
    }

    propRestriction.prval.vt = VT_LPWSTR;
    propRestriction.prval.pwszVal = const_cast<WCHAR*>(pwcsNeighborDN);


    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_L_GATES_DN;

    CDsQueryHandle hQuery;
    HRESULT hr;

    hr = g_pDS->LocateBegin(
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        TrWARNING(DS, "MQADSpQueryNeighborLinks : MsmqServices not found %lx", hr);
        return(MQ_OK);
    }
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpQueryNeighborLinks : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 190);
    }
    //
    //  Read the results one by one
    //

    DWORD cp = 1;

    while (SUCCEEDED(hr))
    {
        cp = 1;
        CMQVariant var;
        var.SetNULL();

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    pRequestContext,
                    &cp,
                    var.CastToStruct()
                    );
        if (FAILED(hr))
        {
            TrWARNING(DS, "MQADSpQueryNeighborLinks : Locate next failed %lx", hr);
            return LogHR(hr, s_FN, 200);
        }
        if ( cp == 0)
        {
            //
            //  no more results
            //
            break;
        }
        //
        //  Add to list
        //

        if ( var.GetCALPWSTR()->cElems > 0)
        {
            AP<GUID> pguidGates;
            DWORD    dwNumGates;
            HRESULT hr1 = MQADSpTranslateGateDn2Id(
                var.CastToStruct(),
                &pguidGates,
                &dwNumGates);
            if (SUCCEEDED(hr1) && (dwNumGates > 0))
            {
                ASSERT( dwNumGates > 0);

                pSiteGateList->AddSiteGates(
                         dwNumGates,
                         pguidGates
                         );
            }
        }
    }

    return(MQ_OK);
}

//+------------------------------------------------------
//
//  HRESULT DSCoreGetNT4PscName()
//
//  Retrieve the name of a NT4 PSC, given its site guid.
//
//+------------------------------------------------------

HRESULT DSCoreGetNT4PscName( IN  const GUID   *pguidSiteId,
                             IN  LPCWSTR       pwszSiteName,
                             OUT WCHAR       **pwszServerName )
{
    #define NUMOF_REST  3
    MQPROPERTYRESTRICTION propertyRestriction[ NUMOF_REST ];

    MQRESTRICTION restrictionNT4Psc;
    restrictionNT4Psc.cRes = NUMOF_REST ;
    restrictionNT4Psc.paPropRes = propertyRestriction;

    ULONG cIndex = 0 ;
    propertyRestriction[ cIndex ].rel = PREQ ;
    propertyRestriction[ cIndex ].prop = PROPID_SET_OLDSERVICE;
    propertyRestriction[ cIndex ].prval.vt = VT_UI4;
    propertyRestriction[ cIndex ].prval.ulVal = SERVICE_PSC;
    cIndex++ ;

    propertyRestriction[ cIndex ].rel = PREQ ;
    propertyRestriction[ cIndex ].prop = PROPID_SET_NT4;
    propertyRestriction[ cIndex ].prval.vt = VT_UI4;
    propertyRestriction[ cIndex ].prval.ulVal = 1;
    cIndex++ ;

    if (pguidSiteId)
    {
        propertyRestriction[ cIndex ].rel = PREQ ;
        propertyRestriction[ cIndex ].prop = PROPID_SET_MASTERID;
        propertyRestriction[ cIndex ].prval.vt = VT_CLSID;
        propertyRestriction[ cIndex ].prval.puuid =
                                       const_cast<GUID*> (pguidSiteId) ;
    }
    else if (pwszServerName)
    {
        propertyRestriction[ cIndex ].rel = PREQ ;
        propertyRestriction[ cIndex ].prop = PROPID_SET_SITENAME ;
        propertyRestriction[ cIndex ].prval.vt = VT_LPWSTR ;
        propertyRestriction[ cIndex ].prval.pwszVal =
                                     const_cast<LPWSTR> (pwszSiteName) ;
    }
    else
    {
        ASSERT(0) ;
    }
    cIndex++ ;
    ASSERT(cIndex == NUMOF_REST) ;

    //
    // start search
    //
    CDsQueryHandle hCursor; // auto close.

    DWORD cProps = 1 ;
    PROPID propId = PROPID_SET_FULL_PATH ;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    HRESULT hr = g_pDS->LocateBegin( eSubTree,	
                                   eLocalDomainController,
                                   &requestDsServerInternal,
                                   NULL,
                                   &restrictionNT4Psc,
                                   NULL,
                                   cProps,
                                  &propId,
                                   hCursor.GetPtr()	) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    MQPROPVARIANT var ;
    var.vt = VT_NULL ;

    hr =  g_pDS->LocateNext( hCursor.GetHandle(),
                           &requestDsServerInternal,
                           &cProps,
                           &var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }
    else if (cProps != 1)
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 230);
    }

    ASSERT( var.vt == VT_LPWSTR );

    P<WCHAR> pwcsSettingName = var.pwszVal;
    P<WCHAR> pwcsServerName;
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetParentName( eLocalDomainController,
                             e_ConfigurationContainer,
                             &requestDsServerInternal1,        // local DS server operation
                             pwcsSettingName,
                            &pwcsServerName );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }

    //
    // Yeah, do some text processing to isolate server name from full DN.
    //
    WCHAR  *pwcsStartServer = pwcsServerName + x_CnPrefixLen;
    WCHAR  *pwcsEndServer = pwcsStartServer ;
    while ( *pwcsEndServer != L',')
    {
        pwcsEndServer++;
    }

    DWORD_PTR dwSize = (pwcsEndServer - pwcsStartServer) + 1 ;
    WCHAR *pServerName = new WCHAR[ dwSize ] ;
    memcpy(pServerName, pwcsStartServer, (dwSize * sizeof(WCHAR))) ;
    pServerName[ dwSize-1 ] = 0 ;

    *pwszServerName = pServerName ;

    return LogHR(hr, s_FN, 250);
}

//+---------------------------------------------------
//
//  HRESULT MQADSpGetSiteSignPK()
//
//  Retrieve the signing public key of the PSC.
//
//+---------------------------------------------------

HRESULT MQADSpGetSiteSignPK(
                 IN  const GUID  *pguidSiteId,
                 OUT BYTE       **pBlobData,
                 OUT DWORD       *pcbSize )
{
    //
    // first, retrieve PSC name from site guid.
    //
    P<WCHAR> pwszServerName = NULL ;
    HRESULT hr = DSCoreGetNT4PscName( pguidSiteId,
                                      NULL,
                                      &pwszServerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    //
    // Now retrieve the public key from machine object.
    //
    PROPID PscSignPk = PROPID_QM_SIGN_PK;
    PROPVARIANT PscSignPkVar ;
	PscSignPkVar.vt = VT_NULL ;	

    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  DSCoreGetProps( MQDS_MACHINE,
                          pwszServerName,
                          NULL,
                          1,
                          &PscSignPk,
                          &requestDsServerInternal,
                          &PscSignPkVar ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    *pBlobData = PscSignPkVar.blob.pBlobData ;
    *pcbSize   = PscSignPkVar.blob.cbSize ;

    return LogHR(hr, s_FN, 280);
}

//+-------------------------------------------------------------------
//
//  HRESULT MQADSpCreateCN()
//
//  Create only foreign CN. Reject calls to create IP or IPX cns,
//  as these ones are supported anymore on win2k.
//
//+-------------------------------------------------------------------

HRESULT MQADSpCreateCN(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext )
{
	for (DWORD j = 0 ; j < cp ; j++ )
	{
		if (aProp[j] == PROPID_CN_PROTOCOLID)
		{
			if (apVar[j].uiVal != FOREIGN_ADDRESS_TYPE)
			{
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 400) ;
			}
			else
			{
				break;
			}
		}
	}

    if (j == cp)
    {
        //
        // protocol id not found in input.
        //
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 410) ;
    }

	//
	// we are here if this CN is foreign CN.
    // Convert CN properties to Site ones.
	//
    #define MAX_SITE_PROPS  6
	DWORD cIndex = 0;
	
    PROPID       aSiteProp[ MAX_SITE_PROPS ] ;
    PROPVARIANT  apSiteVar[ MAX_SITE_PROPS ] ;

	for (j = 0 ; j < cp ; j++ )
	{
        if (cIndex >= MAX_SITE_PROPS)
        {
            ASSERT(cIndex < MAX_SITE_PROPS) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 420) ;
        }

		switch (aProp[j])
		{
		case PROPID_CN_PROTOCOLID:
			aSiteProp[ cIndex ] = PROPID_S_FOREIGN;		
            apSiteVar[ cIndex ].vt = VT_UI1 ;
            apSiteVar[ cIndex ].bVal = TRUE ;
            cIndex++ ;
			break;

		case PROPID_CN_NAME:
			aSiteProp[ cIndex ] = PROPID_S_PATHNAME;			
            apSiteVar[ cIndex ] = apVar[ j ] ;
            cIndex++ ;
			break;

		case PROPID_CN_GUID:
            //
            // Ignore guid. no one really need this one specifically.
            // This is to support legacy nt4 code that supply the guid
            // when calling DSCreateObject.
            // All our tools (mqxplore and mqforgn) will live ok with
            // guid that are generated by the active directory.
            //
			break;
			
		case PROPID_CN_SEQNUM:
		case PROPID_CN_MASTERID:
            //
            // note relevant on win2k.
            //
			break;

		default:
            //
            // This fucntion was added to support nt4 mqxplore and the
            // mqforgn tool that was supplied to level8.
            // These tools do not use any other propid than those
            // handled above.
            //
			ASSERT(0);
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 460) ;
			break;
		}
	}

    HRESULT hr = MQADSpCreateSite( pwcsPathName,
                                   cIndex,
                                   aSiteProp,
                                   apSiteVar,
                                   cpEx,
                                   aPropEx,
                                   apVarEx,
                                   pRequestContext );
    return LogHR(hr, s_FN, 440) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\reqparse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	reqparse.cpp

Abstract:
	Parser of DS locate requests
	
	Each request is handled separtly
Author:

    Ronit Hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "dsads.h"
#include "hquery.h"
#include "mqadsp.h"
#include "coreglb.h"

#include "reqparse.tmh"

static WCHAR *s_FN=L"mqdscore/reqparse";

/*====================================================


QueryLinks()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryLinks( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET*     /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 1);
    ASSERT( (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR1) ||
            (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR2));

    //
    //  Translate the site-id to the site DN
    //
    PROPID prop = PROPID_S_FULL_NAME;

    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		        // local DC or GC
                &requestDsServerInternal,
 	            NULL,                               // object name
                pRestriction->paPropRes[0].prval.puuid,  
                1,                                  // number of attributes to retreive
                &prop,                              // attributes to retreive
                &var);                              // output variant array
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    AP<WCHAR> pClean = var.pwszVal;
    //
    //  Prepare a query according to the neighbor DN
    //
    MQRESTRICTION restriction;
    restriction.cRes = 1;

    MQPROPERTYRESTRICTION proprstr;
    proprstr.rel = PREQ;
    proprstr.prop = (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR1) ?
                    PROPID_L_NEIGHBOR1_DN : PROPID_L_NEIGHBOR2_DN;
    proprstr.prval.vt = VT_LPWSTR;
    proprstr.prval.pwszVal = var.pwszVal;
    restriction.paPropRes = &proprstr;

    //
    //  Locate all the links
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,	
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
                                                hCursor,
                                                pColumns,
                                                pRequestContext->GetRequesterProtocol()
                                                );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 20);
}


/*====================================================


QueryMachineQueues()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryMachineQueues( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET*     /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of the machine
    //
    //  PROPID_Q_QMID is the unique id of machine\msmq-computer-configuration
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_Q_QMID);

    //
    //  Locate all the queues of that machine under the msmq-configuration
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eSpecificObjectInGlobalCatalog,
            pRequestContext, 
            pRestriction->paPropRes[0].prval.puuid,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle( hCursor,
                                                   pColumns->cCol,
                                                   pRequestContext->GetRequesterProtocol()
                                                   );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 30);
}
/*====================================================


QuerySiteName()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteName( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of a site
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_S_SITEID);


    //
    //  Query the site name, even though we know its unique id
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 40);
}

/*====================================================


QueryForeignSites()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryForeignSites( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of a site
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_S_FOREIGN);


    //
    //  Query all foreign sites
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 50);
}

/*====================================================


QuerySiteLinks()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteLinks( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pRestriction == NULL);
    UNREFERENCED_PARAMETER( pRestriction);

    HRESULT hr;
    *pHandle = NULL;
    //
    //  Retrieve all site-links
    //
    //
    //  All the site-links are under the MSMQ-service container
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 60);
}
/*====================================================


QueryEntepriseName()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryEntepriseName( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Retrieve all site-links
    //
    ASSERT( pRestriction == NULL);
    UNREFERENCED_PARAMETER( pRestriction);
    //
    //  All the site-links are under the MSMQ-service container
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,
            eLocalDomainController,
            pRequestContext,
            NULL,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 70);
}


/*====================================================


QuerySites()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySites( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{

    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);

    //
    //  Need to find all the sites 
    //

    HANDLE hCursor;
    PROPID prop[2] = { PROPID_S_SITEID, PROPID_S_PATHNAME};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            2,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CSiteQueryHandle * phQuery = new CSiteQueryHandle(
                                                hCursor,
                                                pColumns,
                                                pRequestContext->GetRequesterProtocol()
                                                );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 80);
}

/*====================================================


QueryCNs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryCNs( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);
    ASSERT( pColumns->aCol[0] == PROPID_CN_PROTOCOLID);
    ASSERT( pColumns->aCol[1] == PROPID_CN_GUID);
    ASSERT( pColumns->cCol == 2);

    //
    //  Each non-foreign site will be returned as IP CN.
    //  
    HANDLE hCursor;
    PROPID prop[2] = { PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            2,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CCNsQueryHandle * phQuery = new CCNsQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 90);
}


/*====================================================


MqxploreQueryCNs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MqxploreQueryCNs( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    //
    //  Supporting MQXPLORE (MSMQ 1.0) CNs query
    //
    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);

	if (pColumns->cCol == 4)
	{
        //
        // this query is done by the mqxpore when it display the CN
        // folder. And yes, it asks for PROPID_CN_NAME twice.
        // That's a mqxplore bug, Ignore it.
        //
		ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
		ASSERT( pColumns->aCol[1] == PROPID_CN_NAME);
		ASSERT( pColumns->aCol[2] == PROPID_CN_GUID);
		ASSERT( pColumns->aCol[3] == PROPID_CN_PROTOCOLID);
    }
	else if (pColumns->cCol == 3)
	{
        //
        // This query is done when displaying the  the network tab of a
        // computer object in nt4 mqxplore or when trying to create a foreign
        // computer from mqxplore.
        //
        ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
        ASSERT( pColumns->aCol[1] == PROPID_CN_PROTOCOLID);
        ASSERT( pColumns->aCol[2] == PROPID_CN_GUID);
    }
    else
    {
        ASSERT(0) ;
    }

    //
    //  Each non-foreign site will be returned as IP CN.
    //  
    HANDLE hCursor;
    const DWORD xNumProps = 3;
    PROPID prop[xNumProps] = { PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            xNumProps,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CMqxploreCNsQueryHandle * phQuery = new CMqxploreCNsQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 100);
}
/*====================================================


QueryCNsProtocol()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryCNsProtocol( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pwcsContext == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pwcsContext);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_CN_PROTOCOLID);
    UNREFERENCED_PARAMETER( pRestriction);

    ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
    ASSERT( pColumns->aCol[1] == PROPID_CN_GUID);
    ASSERT( pColumns->cCol == 2);


    //
    //  BUGBUG  : ignoring IPX 
    //  
    HANDLE hCursor;
    PROPID prop[3] = { PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            3,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CCNsProtocolQueryHandle * phQuery = new CCNsProtocolQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 110);
}

/*====================================================


QueryUserCert()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryUserCert( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get all the user certificates
    //  In NT5, a single attribute PROPID_U_SIGN_CERTIFICATE
    //  containes all the certificates
    //  
    PROPVARIANT varNT5User;
    hr = LocateUser(
				 FALSE,  // fOnlyLocally
				 FALSE,  // fOnlyInGC
                 pRestriction,
                 pColumns,
                 pRequestContext,    
                 &varNT5User
                 );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }
    //
    //  Get all the user certificates of MQUser
    //  A single attribute PROPID_MQU_SIGN_CERTIFICATE
    //  containes all the certificates
    //  
    pRestriction->paPropRes[0].prop = PROPID_MQU_SID;
    switch(pColumns->aCol[0])
    {
        case PROPID_U_SIGN_CERT:
            pColumns->aCol[0] = PROPID_MQU_SIGN_CERT;
            break;
        case PROPID_U_DIGEST:
            pColumns->aCol[0] = PROPID_MQU_DIGEST;
            break;
        default:
            ASSERT(0);
            break;
    }

    PROPVARIANT varMqUser;
    hr = LocateUser(
				 FALSE,  // fOnlyLocally
				 FALSE,  // fOnlyInGC
                 pRestriction,
                 pColumns,
                 pRequestContext,    
                 &varMqUser
                 );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    AP<BYTE> pClean = varNT5User.blob.pBlobData;
    AP<BYTE> pClean1 = varMqUser.blob.pBlobData;
    //
    // keep the result for lookup next
    //
    CUserCertQueryHandle * phQuery = new CUserCertQueryHandle(
                                              &varNT5User.blob,
                                              &varMqUser.blob,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;
    
    return(MQ_OK);
}


/*====================================================


NullRestrictionParser()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI NullRestrictionParser( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pRestriction == NULL);
    HRESULT hr;
    //
    //  Identify the query according to the requested
    //  properties
    //
	//  IMPORTANT: if this switch is changed, then please update
	//    (if necessray) mqads\mqdsapi.cpp, LookupBegin(), to continue
	//     support of nt4 (ntlm) clients.
	//
    switch (pColumns->aCol[0])
    {
        case PROPID_L_NEIGHBOR1:
            hr = QuerySiteLinks(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_S_SITEID:
        case PROPID_S_PATHNAME:
            hr = QuerySites(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_CN_PROTOCOLID:
            hr = QueryCNs(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_CN_NAME:
            hr = MqxploreQueryCNs(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_E_NAME:
        case PROPID_E_ID:
		case PROPID_E_VERSION:
            hr = QueryEntepriseName(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_Q_INSTANCE:
        case PROPID_Q_TYPE:
        case PROPID_Q_PATHNAME:
        case PROPID_Q_JOURNAL:
        case PROPID_Q_QUOTA:
        case PROPID_Q_BASEPRIORITY:
        case PROPID_Q_JOURNAL_QUOTA:
        case PROPID_Q_LABEL:
        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
        case PROPID_Q_AUTHENTICATE:
        case PROPID_Q_PRIV_LEVEL:
        case PROPID_Q_TRANSACTION:
            {
                HANDLE hCursur;
                hr =  g_pDS->LocateBegin( 
                        eSubTree,
                        eGlobalCatalog,
                        pRequestContext,
                        NULL,      
                        pRestriction,   
                        pSort,
                        pColumns->cCol,                 
                        pColumns->aCol,           
                        &hCursur);
                if ( SUCCEEDED(hr))
                {
                    CQueryHandle * phQuery = new CQueryHandle( hCursur,
                                                               pColumns->cCol,
                                                               pRequestContext->GetRequesterProtocol()
                                                               );
                    *pHandle = (HANDLE)phQuery;
                }
            }
            break;

        default:
        	TrERROR(DS, "Illegal requested property (propid = %x) passed to BeginLocate", pColumns->aCol[0]);
            hr = MQ_ERROR_INVALID_PARAMETER;
            break; 
    }
    return LogHR(hr, s_FN, 140);
}
/*====================================================


QuerySiteFRSs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteFRSs( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    *pHandle = NULL;

    ASSERT( pRestriction->paPropRes[0].prop == PROPID_QM_SERVICE);   //[adsrv] Not changing - because this comes from MSMQ1
    ASSERT( pRestriction->paPropRes[1].prop == PROPID_QM_SITE_ID);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);

    //
    //  Find all the FRSs under \configuration\Sites\MySite\servers  
    //
    HRESULT hr2 = MQADSpQuerySiteFRSs( 
                 pRestriction->paPropRes[1].prval.puuid,
                 pRestriction->paPropRes[0].prval.ulVal,
                 pRestriction->paPropRes[0].rel,
                 pColumns,
                 pRequestContext,
                 pHandle
                 );

    return LogHR(hr2, s_FN, 150);
}
/*====================================================


QueryConnectors()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryConnectors( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    ASSERT( pwcsContext == NULL);
    UNREFERENCED_PARAMETER( pwcsContext);
    //
    //  In the restriction there is the list of the foreign
    //  machine's sites.
    //
    //  BUGBUG - the code handles one site only
    CACLSID  * pcauuidSite;
    if ( pRestriction->paPropRes[1].prop == PROPID_QM_CNS)
    {
        pcauuidSite =  &pRestriction->paPropRes[1].prval.cauuid;
    }
    else if ( pRestriction->paPropRes[2].prop == PROPID_QM_CNS)
    {
        pcauuidSite =  &pRestriction->paPropRes[2].prval.cauuid;
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 160);
    }
    UNREFERENCED_PARAMETER( pRestriction);
    ASSERT( pcauuidSite->cElems == 1);
    //
    HRESULT hr;
    *pHandle = NULL;
    P<CSiteGateList> pSiteGateList = new CSiteGateList;

    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                &requestDsServerInternal,
 	            NULL,      // object name
                pcauuidSite->pElems,      // unique id of object
                1,          
                &prop,       
                &var);
    if (FAILED(hr))
    {
        TrERROR(DS, "QueryConnectors : Failed to retrieve the DN of the site %lx", hr);
        return LogHR(hr, s_FN, 170);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;

    hr = MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        pRequestContext,
                        pSiteGateList
                        );
    if ( FAILED(hr))
    {
        TrTRACE(DS, "QueryConnectors : Failed to query neighbor1 links %lx", hr);
        return LogHR(hr, s_FN, 180);
    }

    hr = MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        pRequestContext,
                        pSiteGateList
                        );
    if ( FAILED(hr))
    {
        TrTRACE(DS, "QueryConnectors : Failed to query neighbor2 links %lx", hr);
        return LogHR(hr, s_FN, 190);
    }
    
    //
    // keep the results for lookup next
    //
    CConnectorQueryHandle * phQuery = new CConnectorQueryHandle(
                                              pColumns,
                                              pSiteGateList,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;
    pSiteGateList.detach();
    
    return(MQ_OK);

}
/*====================================================


QueryNT4MQISServers()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryNT4MQISServers( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 2);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_SET_SERVICE);
    ASSERT( pRestriction->paPropRes[1].prop == PROPID_SET_NT4);

    // [adsrv] We must be sure to keep PROPID_SET_OLDSERVICE with existing service type attribute
    // BUGBUG 

    pRestriction->paPropRes[0].prop = PROPID_SET_OLDSERVICE;          //[adsrv] PROPID_SET_SERVICE 

    //
    //  Query NT4 MQIS Servers (PSCs or BSCs according to restriction)
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eSubTree,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 200);
}


/*====================================================


QuerySiteMachines()

Arguments:

Return Value:

This support is required for backward compatibility of
MSMQ 1.0 explorer. 
=====================================================*/
HRESULT WINAPI QuerySiteMachines( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_QM_SITE_ID);

    //
    //  Locate all machine that belong to a specific site
    //
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
   
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = PROPID_QM_SITE_IDS;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = pRestriction->paPropRes[0].prval.puuid;


    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eSubTree,	
            eGlobalCatalog,	
            pRequestContext,
            NULL,
            &restriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 210);
}



//
//  BugBug - fill in

//
QUERY_FORMAT SupportedQueriesFormat[] = {
//
// no-rest | handler              | rest 1                 | rest 2                 | rest 3                 | rest 4                 | rest 5                 | rest 6                 | rest 7                 | rest 8                 | rest 9                 | rest 10                | DS_CONTEXT       |
//---------|----------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------|
{ 1,        QueryMachineQueues  ,  PREQ, PROPID_Q_QMID,     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_RootDSE},
{ 2,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 1,        QuerySiteName       ,  PREQ, PROPID_S_SITEID,   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 1,        QueryUserCert       ,  PREQ, PROPID_U_SID,      0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 4,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAll, PROPID_QM_CNS, PRGE, PROPID_QM_OS,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_SitesContainer},
{ 4,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAny, PROPID_QM_CNS, PRGE, PROPID_QM_OS,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAll, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 2,        QuerySiteFRSs       ,  PRGT, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PRGE, PROPID_QM_OS,      0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 2,        QueryConnectors     ,  PRGE, PROPID_QM_SERVICE, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 3,        QueryConnectors     ,  PRGE, PROPID_QM_OS,      PRGE, PROPID_QM_SERVICE, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryForeignSites   ,  PREQ, PROPID_S_FOREIGN,  0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryCNsProtocol    ,  PREQ, PROPID_CN_PROTOCOLID,0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 2,        QueryNT4MQISServers ,  PREQ, PROPID_SET_SERVICE,PRGE, PROPID_SET_NT4,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 2,        QueryNT4MQISServers ,  PREQ, PROPID_SET_SERVICE,PREQ, PROPID_SET_NT4,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryLinks          ,  PREQ, PROPID_L_NEIGHBOR1,0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_ConfigurationContainer},           
{ 1,        QueryLinks          ,  PREQ, PROPID_L_NEIGHBOR2,0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_ConfigurationContainer},
{ 1,        QuerySiteMachines   ,  PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_RootDSE}
};

//+-------------------------
//
//  BOOL  FindQueryIndex()
//
//+-------------------------

BOOL FindQueryIndex( IN  MQRESTRICTION  *pRestriction,
					 OUT DWORD          *pdwIndex,
					 OUT DS_CONTEXT     *pdsContext )
{
    DWORD noQueries = sizeof(SupportedQueriesFormat) /
			                            sizeof(QUERY_FORMAT) ;
    DWORD index = 0;
    //
    //  Check if the query match one of the "known" queries.
    //
    if ( pRestriction != NULL)
    {
        ASSERT(pRestriction->cRes <= NO_OF_RESTRICITIONS);
        while ( index < noQueries)
        {
            //
            //  Make sure that number of restrictions match
            //

            if ( pRestriction->cRes == SupportedQueriesFormat[index].dwNoRestrictions)
            {
                BOOL fFoundMatch = TRUE;
                for ( DWORD i = 0; i < pRestriction->cRes; i++)
                {
                    //
                    //  ASSUMPTION : order of restrictions is fixed
                    //
                    if (( pRestriction->paPropRes[i].prop !=
                          SupportedQueriesFormat[index].restrictions[i].propId) ||
                        ( pRestriction->paPropRes[i].rel !=
                          SupportedQueriesFormat[index].restrictions[i].rel))
                    {
                        fFoundMatch = FALSE;
                        break;
                    }
                }
                if ( fFoundMatch)
                {
					*pdwIndex = index ;
					if (pdsContext)
					{
							*pdsContext = SupportedQueriesFormat[index].queryContext ;
					}
                    return TRUE ;
                }
            }
            //
            // Try next query
            //
            index++;
        }
    }

	return FALSE ;
}

/*====================================================


QueryParser()

Arguments:

Return Value:

=====================================================*/

HRESULT QueryParser(
                 IN  LPWSTR          pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    DWORD dwIndex = 0;
    //
    //  Check if the query match one of the "known" queries.
    //
	BOOL fFound = FindQueryIndex( pRestriction,
								 &dwIndex,
								  NULL ) ;
	if (fFound)
	{
        HRESULT hr2 = SupportedQueriesFormat[dwIndex].QueryRequestHandler(
                                         pwcsContext,
                                         pRestriction,
                                         pColumns,
                                         pSort,
                                         pRequestContext,
                                         pHandle );
        return LogHR(hr2, s_FN, 220);
    }

    //
    //  If doesn't match any of the pre-defined formats, check
    //  is it a free-format queue locate query.
    //
    HRESULT hr = MQ_ERROR;
    if ( pRestriction)
    {
        BOOL fQueueQuery = TRUE;
        for ( DWORD i = 0; i < pRestriction->cRes; i++)
        {
            if (( pRestriction->paPropRes[i].prop <= PROPID_Q_BASE) ||
                ( pRestriction->paPropRes[i].prop > LAST_Q_PROPID))
            {
                fQueueQuery = FALSE;
                break;
            }
        }
        if ( !fQueueQuery)
        {
            //
            //  The query PROPID_QM_SERVICE == SERVICE_PEC is not supported
            //  ( and shouldn't generate an assert). This query is generated
            //  by MSMQ 1.0 explorer, and doesn't have meaning in NT5
            //  environment. 
            //
#ifdef _DEBUG
            if (!( ( pRestriction->cRes == 1) &&
                   ( pRestriction->paPropRes[0].prop == PROPID_QM_SERVICE) &&
                   ( pRestriction->paPropRes[0].prval.ulVal == SERVICE_PEC)))
            {
                ASSERT( hr == MQ_OK); // to catch unhandled queries
            }
#endif
            return LogHR(hr, s_FN, 230);
        }

        HANDLE hCursur;
        hr =  g_pDS->LocateBegin( 
                eSubTree,	
                eGlobalCatalog,	
                pRequestContext,
                NULL,      
                pRestriction,   
                pSort,
                pColumns->cCol,                 
                pColumns->aCol,           
                &hCursur);
        if ( SUCCEEDED(hr))
        {
            CQueryHandle * phQuery = new CQueryHandle( hCursur,
                                                       pColumns->cCol,
                                                       pRequestContext->GetRequesterProtocol()
                                                       );
            *pHandle = (HANDLE)phQuery;
        }
        return LogHR(hr, s_FN, 240);
    }
    else
    {
        //
        //  Other queries with no restirctions
        //
        hr =  NullRestrictionParser( 
                     pwcsContext,
                     pRestriction,
                     pColumns,
                     pSort,
                     pRequestContext,
                     pHandle);
    }


    return LogHR(hr, s_FN, 250);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\notify.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    notify.cpp

Abstract:
    notifications to owners of changed objects

Author:

    Raanan Harari (raananh)
    Ilan Herbst    (ilanh)   9-July-2000

--*/
#include "ds_stdh.h"
#include "bupdate.h"
#include "dsutils.h"
#include "mqads.h"
#include "coreglb.h"
#include "privque.h"
#include "pnotify.h"
#include "notify.h"
#include "dscore.h"
#include "rpccli.h"

#include "notify.tmh"

const UCHAR x_bDS_NOTIFICATION_MSG_PRIORITY = DEFAULT_M_PRIORITY;
const DWORD x_dwDS_NOTIFICATION_MSG_TIMEOUT = (5 * 60);    /* 5 min */

static WCHAR *s_FN=L"mqdscore/notify";

//
// queue properties that are needed for create queue notification
//
extern const PROPID g_rgNotifyCreateQueueProps[] =
{
    PROPID_Q_TYPE,
    PROPID_Q_INSTANCE,
    PROPID_Q_BASEPRIORITY,
    PROPID_Q_JOURNAL,
    PROPID_Q_QUOTA,
    PROPID_Q_JOURNAL_QUOTA,
    PROPID_Q_CREATE_TIME,
    PROPID_Q_MODIFY_TIME,
    PROPID_Q_SECURITY,
    PROPID_Q_PATHNAME,
    PROPID_Q_LABEL,
    PROPID_Q_AUTHENTICATE,
    PROPID_Q_PRIV_LEVEL,
    PROPID_Q_TRANSACTION
};
extern const ULONG g_cNotifyCreateQueueProps = ARRAY_SIZE(g_rgNotifyCreateQueueProps);
static enum // keep in the same order as above array
{
    e_idxQType,
    e_idxQInstance,
    e_idxQBasePriority,
    e_idxQJournal,
    e_idxQQuota,
    e_idxQJournalQuota,
    e_idxQCreateTime,
    e_idxQModifyTime,
    e_idxQSecurity,
    e_idxQPathname,
    e_idxQLabel,
    e_idxQAuthenticate,
    e_idxQPrivLevel,
    e_idxQTransaction
};
extern const ULONG g_idxNotifyCreateQueueInstance = e_idxQInstance;

//
// QM properties that are needed for notifications
//
extern const PROPID g_rgNotifyQmProps[] =
{
    PROPID_QM_MACHINE_ID,
    PROPID_QM_FOREIGN
};
extern const ULONG g_cNotifyQmProps = ARRAY_SIZE(g_rgNotifyQmProps);
static enum // keep in the same order as above array
{
    e_idxQmId,
    e_idxQmForeign
};

//
// queue properties that are needed for create queue write request
// same as notify, but with PROPID_Q_SCOPE
//
const PROPID x_rgWritereqCreateQueueProps[] =
{
    PROPID_Q_TYPE,
    PROPID_Q_INSTANCE,
    PROPID_Q_BASEPRIORITY,
    PROPID_Q_JOURNAL,
    PROPID_Q_QUOTA,
    PROPID_Q_JOURNAL_QUOTA,
    PROPID_Q_CREATE_TIME,
    PROPID_Q_MODIFY_TIME,
    PROPID_Q_SECURITY,
    PROPID_Q_PATHNAME,
    PROPID_Q_LABEL,
    PROPID_Q_AUTHENTICATE,
    PROPID_Q_PRIV_LEVEL,
    PROPID_Q_TRANSACTION,
    PROPID_Q_SCOPE
};
const ULONG x_cWritereqCreateQueueProps = ARRAY_SIZE(x_rgWritereqCreateQueueProps);

//
// queue properties that are needed for update queue notification
//
const PROPID x_rgNotifyUpdateQueueProps[] =
{
    PROPID_Q_QMID,
};
const ULONG x_cNotifyUpdateQueueProps = ARRAY_SIZE(x_rgNotifyUpdateQueueProps);
static enum // keep in the same order as above array
{
    e_idxQueueQmId
};

//
// describes where to take the notification value for update notification props
//
static enum
{
    e_ValueInUpdProps,    // value is in original update props supplied by caller
    e_ValueInRequestProps // value is in props requested from the DS upon setting
};

//
// fwd declaration of static funcs
//
static HRESULT BuildSendNotification(
                      IN GUID*               pguidDestinationQmId,
                      IN unsigned char       ucOperation,
                      IN LPCWSTR             pwcsPathName,
                      IN const GUID*         pguidIdentifier,
                      IN ULONG               cProps,
                      IN const PROPID *      rgPropIDs,
                      IN const PROPVARIANT * rgPropVars);
//-------------------------------------------------------------
// Functions
//-------------------------------------------------------------


HRESULT NotifyCreateQueue(IN const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName)
/*++

Routine Description:
    Sends a notification for the owner QM of the queue that was created

Arguments:
    pQueueInfoRequest - queue props as defined in g_rgNotifyCreateQueueProps
    pQmInfoRequest    - owner qm props as defined in g_rgNotifyQmProps
    pwcsPathName      - pathname of created queue

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pQueueInfoRequest->hrStatus) ||
        FAILED(pQmInfoRequest->hrStatus))
    {
        TrERROR(DS, "NotifyCreateQueue:notification prop request failed Q:%lx QM:%lx", pQueueInfoRequest->hrStatus, pQmInfoRequest->hrStatus);
        LogHR(pQueueInfoRequest->hrStatus, s_FN, 10);
        LogHR(pQmInfoRequest->hrStatus, s_FN, 11);
        return MQ_ERROR;
    }

    //
    // send notification only if owner QM not foreign
    //
    if (!(pQmInfoRequest->pPropVars[e_idxQmForeign].bVal))
    {
        //
        // send notification to owner QM
        //
        ASSERT( g_rgNotifyQmProps[ e_idxQmId] ==  PROPID_QM_MACHINE_ID);

        hr = BuildSendNotification(
                      pQmInfoRequest->pPropVars[e_idxQmId].puuid,
                      DS_UPDATE_CREATE,
                      pwcsPathName,
                      NULL /*pguidIdentifier*/,
                      pQueueInfoRequest->cProps,
                      pQueueInfoRequest->pPropIDs,
                      pQueueInfoRequest->pPropVars);
        if (FAILED(hr))
        {
            TrERROR(DS, "NotifyCreateQueue:BuildSendNotification()=%lx", hr);
            return LogHR(hr, s_FN, 20);
        }
    }

    return MQ_OK;
}


HRESULT NotifyDeleteQueue(IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName,
                          IN const GUID *                  pguidIdentifier)
/*++

Routine Description:
    Sends a notification for the owner QM of the queue that was deleted

Arguments:
    pQmInfoRequest    - owner qm props as defined in g_rgNotifyQmProps
    pwcsPathName      - pathname of deleted queue
    pguidIdentifier   - guid of deleted queue (incase pwcsPathName is NULL)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pQmInfoRequest->hrStatus))
    {
        TrERROR(DS, "NotifyDeleteQueue:notification prop request failed QM:%lx", pQmInfoRequest->hrStatus);
        LogHR(pQmInfoRequest->hrStatus, s_FN, 30);
        return MQ_ERROR;
    }

    //
    // send notification only if owner QM not foreign
    //
    ASSERT( g_rgNotifyQmProps[ e_idxQmForeign] ==  PROPID_QM_FOREIGN);
    if (!(pQmInfoRequest->pPropVars[e_idxQmForeign].bVal))
    {
        //
        // Got to have 2 props, and the second prop MUST be PROPID_D_OBJTYPE
        // (used by pUpdate->GetObjectType() when it is a delete notification)
        // about the first prop - I'm not sure if it used at all by QM1.0, but
        // DS1.0 sent it to QM1.0, and we want to do the same.
        //
        static const PROPID rgPropIDs[] = {PROPID_D_SCOPE, PROPID_D_OBJTYPE};
        PROPVARIANT rgPropVars[ARRAY_SIZE(rgPropIDs)];
        rgPropVars[0].vt = VT_UI1;
        rgPropVars[0].bVal = ENTERPRISE_SCOPE;
        rgPropVars[1].vt = VT_UI1;
        rgPropVars[1].bVal = MQDS_QUEUE;

        //
        // send notification to owner QM
        //
        hr = BuildSendNotification(
                      pQmInfoRequest->pPropVars[e_idxQmId].puuid,
                      DS_UPDATE_DELETE,
                      pwcsPathName,
                      pguidIdentifier,
                      ARRAY_SIZE(rgPropIDs),
                      rgPropIDs,
                      rgPropVars);
        if (FAILED(hr))
        {
            TrERROR(DS, "NotifyDeleteQueue:BuildSendNotification()=%lx", hr);
            return LogHR(hr, s_FN, 40);
        }
    }

    return MQ_OK;
}


HRESULT NotifyUpdateObj(IN DWORD                         dwObjectType,
                        IN const MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
                        IN LPCWSTR                       pwcsPathName,
                        IN const GUID *                  pguidIdentifier,
                        IN ULONG                         cUpdProps,    /*debug only*/
                        IN const PROPID *                rgUpdPropIDs, /*debug only*/
                        IN const PROPVARIANT *           rgUpdPropVars,
                        IN ULONG                         cNotifyProps,
                        IN const PROPID *                rgNotifyPropIDs,
                        IN const MQDS_NotifyTable *      rgNotifyPropTbl)
/*++

Routine Description:
    Sends a notification for the owner QM of the object that was updated.
    The notification props are given. Where to take their values (i.e. from the
    original update props or from the info request props) is determined by the given
    notification table.

Arguments:
    dwObjectType      - object type (queue, QM)
    pObjInfoRequest   - requested obj props
    pwcsPathName      - pathname of updated obj
    pguidIdentifier   - guid of updated obj (incase pwcsPathName is NULL)
    cUpdProps         - updated props (count)
    rgUpdPropIDs      - updated props (propids)
    rgUpdPropVars     - updated props (propvars)
    cNotifyProps      - notification props (count)
    cNotifyPropIDs    - notification props (propids)
    rgNotifyPropTbl   - notification props (value location)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pObjInfoRequest->hrStatus))
    {
        TrERROR(DS, "NotifyUpdateObj:notification prop request failed: %lx", pObjInfoRequest->hrStatus);
        LogHR(pObjInfoRequest->hrStatus, s_FN, 50);
        return MQ_ERROR;
    }

    //
    // exit if no properties for the notification
    //
    if (cNotifyProps == 0)
    {
        return MQ_OK;
    }

    //
    // we need to check whether the owner QM is foreign, and get an index
    // to the owner QM prop in the requested props
    //
    BOOL fQmForeign;
    ULONG idxQmId;
    switch(dwObjectType)
    {
    case MQDS_QUEUE:
        {
            //
            // we have the owner QM guid in the queue info request, and we go to the DS
            //
            static const PROPID rgPropIDs[] = {PROPID_QM_FOREIGN};
            CMQVariant varForeign;

            CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
            hr = DSCoreGetProps(
                        MQDS_MACHINE,
                         NULL,
                        pObjInfoRequest->pPropVars[e_idxQueueQmId].puuid,
                        ARRAY_SIZE(rgPropIDs),
                        const_cast<PROPID *>(rgPropIDs),
                        &requestDsServerInternal,
                        varForeign.CastToStruct());
            if (FAILED(hr))
            {
                TrERROR(DS, "NotifyUpdateObj:DSCoreGetProps(foreign)=%lx", hr);
                LogHR(hr, s_FN, 60);
                return MQ_ERROR;
            }

            fQmForeign = (varForeign.CastToStruct())->bVal;
        }
        idxQmId = e_idxQueueQmId; //index of QM id in queue info request
        break;

    case MQDS_MACHINE:
        //
        // we have the foreign property in the QM info request
        //
        fQmForeign = pObjInfoRequest->pPropVars[e_idxQmForeign].bVal;
        idxQmId = e_idxQmId;      //index of QM id in QM info request
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 70);
        break;
    }

    //
    // don't send notifications to foreign QM
    //
    if (fQmForeign)
    {
        return MQ_OK;
    }

    //
    // create notification prop values arrays and fill the values for the
    // notification props from the appropriate place
    //
    AP<PROPVARIANT> rgNotifyPropVars = new PROPVARIANT[cNotifyProps];
    for (ULONG ulTmp = 0; ulTmp < cNotifyProps; ulTmp++)
    {
        const MQDS_NotifyTable * pNotifyPropTbl = &rgNotifyPropTbl[ulTmp];
        const PROPVARIANT * pvarsArray;
        const PROPID * pidArray;
        ULONG cArray;

        //
        // the location of the value is in the notification table
        //
        switch (pNotifyPropTbl->wValueLocation)
        {

        case e_ValueInUpdProps:
            //
            // value is in original update props supplied by caller
            //
            pvarsArray = rgUpdPropVars;
            pidArray = rgUpdPropIDs;
            cArray = cUpdProps;
            break;

        case e_ValueInRequestProps:
            //
            // value is in props requested from the DS upon setting
            //
            pvarsArray = pObjInfoRequest->pPropVars;
            pidArray = pObjInfoRequest->pPropIDs;
            cArray = pObjInfoRequest->cProps;
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 80);
            break;
        }

        //
        // set the value in the notification propvar array from the appropriate array
        // the index of the value is in the notification table
        // we don't duplicate the new propvar, just use it as is,
        // consequently we don't need to clear it afterwards
        //
        ASSERT(pNotifyPropTbl->idxValue < cArray);
        ASSERT(rgNotifyPropIDs[ulTmp] == pidArray[pNotifyPropTbl->idxValue]);
        rgNotifyPropVars[ulTmp] = pvarsArray[pNotifyPropTbl->idxValue];
    }

    //
    // send notification to owner QM
    //
    hr = BuildSendNotification(
                      pObjInfoRequest->pPropVars[idxQmId].puuid,
                      DS_UPDATE_SET,
                      pwcsPathName,
                      pguidIdentifier,
                      cNotifyProps,
                      rgNotifyPropIDs,
                      rgNotifyPropVars);
    if (FAILED(hr))
    {
        TrERROR(DS, "NotifyUpdateObj:BuildSendNotification()=%lx", hr);
        return LogHR(hr, s_FN, 90);
    }

    return MQ_OK;
}


static HRESULT BuildSendNotification(
                      IN GUID*               pguidDestinationQmId,
                      IN unsigned char       ucOperation,
                      IN LPCWSTR             pwcsPathName,
                      IN const GUID*         pguidIdentifier,
                      IN ULONG               cProps,
                      IN const PROPID *      rgPropIDs,
                      IN const PROPVARIANT * rgPropVars)
/*++

Routine Description:
    Sends a notification for destination QM

Arguments:
    pguidDestinationQmId - guid of destination QM
    ucOperation          - operation (create, delete, etc)
    pwcsPathName         - pathname of object
    pguidIdentifier      - guid of object (incase pwcsPathName is NULL)
    cProps               - notification props (count)
    rgPropIDs            - notification props (propids)
    rgPropVars           - notification props (propvars)

Return Value:
    HRESULT

--*/
{
	HRESULT hr;
    CDSBaseUpdate cUpdate;
    CSeqNum snSmallestValue;    // dummy
    GUID guidNULL = GUID_NULL;

    if (pwcsPathName)
    {
        hr = cUpdate.Init(
                        &guidNULL,             // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,                 // not applicable
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,   // the Update class will be deleted here, before data expires
                        const_cast<LPWSTR>(pwcsPathName),
                        cProps,
                        const_cast<PROPID *>(rgPropIDs),
                        const_cast<PROPVARIANT *>(rgPropVars));
    }
    else
    {
        hr = cUpdate.Init(
                        &guidNULL,             // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,                 // not applicable
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,   // the Update class will be deleted here, before data expires
                        pguidIdentifier,
                        cProps,
                        const_cast<PROPID *>(rgPropIDs),
                        const_cast<PROPVARIANT *>(rgPropVars));
    }
    if (FAILED(hr))
    {
        TrERROR(DS, "BuildSendNotification:cUpdate.Init()=%lx", hr);
        return LogHR(hr, s_FN, 100);
    }

    //
    //  Prepare the packet
    //  Currently it contains one notification only
    //
    DWORD size, tmpSize;
    size = sizeof(CNotificationHeader);
    hr = cUpdate.GetSerializeSize(&tmpSize);
    if (FAILED(hr))
    {
        TrERROR(DS, "BuildSendNotification:cUpdate.GetSerializeSize()=%lx", hr);
        return LogHR(hr, s_FN, 110);
    }

    size += tmpSize;
    AP<unsigned char> pBuffer = new unsigned char[size];
    CNotificationHeader * pNotificationHeader = (CNotificationHeader *)( unsigned char *)pBuffer;
    pNotificationHeader->SetVersion( DS_NOTIFICATION_MSG_VERSION);
    pNotificationHeader->SetNoOfNotifications(1);
    hr = cUpdate.Serialize(pNotificationHeader->GetPtrToData(), &tmpSize, FALSE);
    if (FAILED(hr))
    {
        TrERROR(DS, "BuildSendNotification:cUpdate.Serialize()=%lx", hr);
        return LogHR(hr, s_FN, 120);
    }

    //
    //  send the message
    //

    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 125);   // MQ_E_GET_RPC_HANDLE
    }
    ASSERT(hBind);

    //
    //  Prepare queue format - notification will be sent to private queue - notify_queue$.
    //
    QUEUE_FORMAT NotificationQueueFormat(*pguidDestinationQmId, NOTIFICATION_QUEUE_ID);

	hr = QMRpcSendMsg(
				hBind,
				&NotificationQueueFormat, // &QueueFormat
				size,
				pBuffer,
				x_dwDS_NOTIFICATION_MSG_TIMEOUT,
				MQMSG_ACKNOWLEDGMENT_NONE,
				x_bDS_NOTIFICATION_MSG_PRIORITY,
				NULL		// RespQueue
				);

    if (FAILED(hr))
    {
        TrERROR(DS, "BuildSendNotification:QMSendPacket()=%lx", hr);
        return LogHR(hr, s_FN, 130);
    }

    return MQ_OK;
}


HRESULT RetreiveQueueInstanceFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN  ULONG                         idxQueueGuid,
                          OUT GUID *                        pguidObject)
/*++

Routine Description:
    Fill the queue's instance

Arguments:
    pQueueInfoRequest - queue props as defined in g_rgNotifyUpdateQueueProps
    idxQueueGuid      - index of PROPID_Q_INSTANCE in above info request
    pguidObject       - place to fill in he queue's instance

Return Value:
    HRESULT

--*/
{
    ASSERT(pQueueInfoRequest->pPropIDs[idxQueueGuid] == PROPID_Q_INSTANCE);
    //
    // bail if info requests failed
    //
    if (FAILED(pQueueInfoRequest->hrStatus))
    {
        LogHR(pQueueInfoRequest->hrStatus, s_FN, 140);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pguidObject = *pQueueInfoRequest->pPropVars[idxQueueGuid].puuid;
    return MQ_OK;
}


HRESULT RetreiveObjectIdFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                          IN  ULONG                         idxObjectGuid,
                          OUT GUID *                        pguidObject)
/*++

Routine Description:
    Fill the object's instance

Arguments:
    pObjectInfoRequest - object props
    idxObjectGuid      - index of object's unique id property in above info request
    pguidObject        - place to fill in he queue's instance

Return Value:
    HRESULT

--*/
{
    //
    // bail if info requests failed
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 150);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pguidObject = *pObjectInfoRequest->pPropVars[idxObjectGuid].puuid;
    return MQ_OK;
}


HRESULT GetNotifyUpdateObjProps(IN DWORD dwObjectType,
                                IN ULONG cUpdProps,
                                IN const PROPID * rgUpdPropIDs,
                                OUT ULONG * pcObjRequestProps,
                                OUT PROPID ** prgObjRequestPropIDs,
                                OUT ULONG * pcNotifyProps,
                                OUT PROPID ** prgNotifyPropIDs,
                                OUT MQDS_NotifyTable ** prgNotifyPropTbl)
/*++

Routine Description:
    returns the props that should be requested for the object upon setting, the props
    that should be notified to the owner QM, and a notification table that for each
    notification prop describes from where to take the value to notify, whether from
    the original update props, or from the requested-upon-setting props

Arguments:
    dwObjectType          - object type (queue, QM)
    cUpdProps             - props to set (count)
    rgUpdPropIDs          - props to set (propids)
    pcObjRequestProps     - props to request back upon set (count)
    prgObjRequestPropIDs  - props to request back upon set (propids)
    pcNotifyProps         - notification props (count)
    pcNotifyPropIDs       - notification props (propids)
    prgNotifyPropTbl      - notification props (value location)

Return Value:
    HRESULT

--*/
{
    const PROPID * pMustRequestProps;
    ULONG cMustRequestProps;

    switch (dwObjectType)
    {
    case MQDS_QUEUE:
        pMustRequestProps = x_rgNotifyUpdateQueueProps;
        cMustRequestProps = x_cNotifyUpdateQueueProps;
        break;
    case MQDS_MACHINE:
        pMustRequestProps = g_rgNotifyQmProps;
        cMustRequestProps = g_cNotifyQmProps;
        break;
    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 160);
        break;
    }

    //
    // init requested props. The must props have to be there,
    // we need to keep place for the replacing props as well, and the worst
    // case is that all of the update props need to be replaced.
    //
    AP<PROPID> rgObjRequestPropIDs = new PROPID [cMustRequestProps + cUpdProps];

    //
    // first copy must request props
    //
    memcpy((PROPID *)rgObjRequestPropIDs, pMustRequestProps, sizeof(PROPID)*cMustRequestProps);
    ULONG cObjRequestProps = cMustRequestProps;

    //
    // init notification props. the worst case is that all of the update props
    // or their replacements need to be notified.
    //
    AP<PROPID> rgNotifyPropIDs = new PROPID [cUpdProps];
    AP<MQDS_NotifyTable> rgNotifyPropTbl = new MQDS_NotifyTable [cUpdProps];
    ULONG cNotifyProps = 0;

    //
    // loop over the update props. for each property find out how to notify
    // it to QM1.0
    //
    for (ULONG ulTmp = 0; ulTmp < cUpdProps; ulTmp++)
    {
        //
        // find translation info for the property
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(rgUpdPropIDs[ulTmp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 170);
        }

        //
        // check how to notify to QM1.0
        //
        switch(pTranslate->wQM1Action)
        {

        case e_NOTIFY_WRITEREQ_QM1_AS_IS:
            //
            // notify property as is
            // add the property to the notification props
            // value should be taken from the UPDATE props
            //
            rgNotifyPropIDs[cNotifyProps] = rgUpdPropIDs[ulTmp];
            rgNotifyPropTbl[cNotifyProps].wValueLocation = e_ValueInUpdProps;
            rgNotifyPropTbl[cNotifyProps].idxValue = ulTmp;
            cNotifyProps++;
            break;

        case e_NOTIFY_WRITEREQ_QM1_REPLACE:
            {
                //
                // add the REPLACING property to the notification props
                // value should be taken from the REQUEST props
                //
                ASSERT(pTranslate->propidReplaceNotifyQM1 != 0);
                //
                // check that we don't have the replacing property already in the notification props.
                // this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
                //
                BOOL fReplacingPropNotFoundYet = TRUE;
                for (ULONG ulTmp1 = 0; (ulTmp1 < cNotifyProps) && fReplacingPropNotFoundYet; ulTmp1++)
                {
                    if (rgNotifyPropIDs[ulTmp1] == pTranslate->propidReplaceNotifyQM1)
                    {
                        //
                        // the replacing prop is already in the notification props, exit loop.
                        //
                        fReplacingPropNotFoundYet = FALSE;
                    }
                }

                //
                // add the replacing property to the notification props only if it wasn't there already
                //
                if (fReplacingPropNotFoundYet)
                {
                    rgNotifyPropIDs[cNotifyProps] = pTranslate->propidReplaceNotifyQM1;
                    rgNotifyPropTbl[cNotifyProps].wValueLocation = e_ValueInRequestProps;
                    rgNotifyPropTbl[cNotifyProps].idxValue = cObjRequestProps;
                    cNotifyProps++;
                    //
                    // request the replacing property upon setting
                    //
                    rgObjRequestPropIDs[cObjRequestProps] = pTranslate->propidReplaceNotifyQM1;
                    cObjRequestProps++;
                }
            }
            break;

        case e_NO_NOTIFY_NO_WRITEREQ_QM1:
        case e_NO_NOTIFY_ERROR_WRITEREQ_QM1:
            //
            // ignore this property
            //
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 180);
            break;
        }
    }

    //
    // return values
    //
    *pcObjRequestProps = cObjRequestProps;
    *prgObjRequestPropIDs = rgObjRequestPropIDs.detach();
    *pcNotifyProps = cNotifyProps;
    *prgNotifyPropIDs = rgNotifyPropIDs.detach();
    *prgNotifyPropTbl = rgNotifyPropTbl.detach();
    return MQ_OK;
}


HRESULT ConvertToNT4Props(ULONG cProps,
                          const PROPID * rgPropIDs,
                          const PROPVARIANT * rgPropVars,
                          ULONG * pcNT4Props,
                          PROPID ** prgNT4PropIDs,
                          PROPVARIANT ** prgNT4PropVars)
/*++

Routine Description:
    replaces NT5 props with the corresponding NT4 props (if possible) and removes
    NT5 specific props that don't have NT4 match.

Arguments:
    cProps               - given props (count)
    rgPropIDs            - given props (propids)
    rgPropVars           - given props (propvars)
    pcNT4CreateProps     - returned NT4 props (count)
    prgNT4CreatePropIDs  - returned NT4 props (propids)
    prgNT4CreatePropVars - returned NT4 props (propvars)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;
    //
    // Alloc place for converted NT4 props with propvar release
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    PROPVARIANT * rgNT4PropVars = cCleanNT4Props.allocClean(cProps);
    AP<PROPID> rgNT4PropIDs = new PROPID[cProps];
    ULONG cNT4Props = 0;

    //
    // Init replacing props. Since there are situations where several NT5 props can map
    // to the same NT4 prop (like in QM_SERVICE) we make sure only one replacing prop is
    // generated.
    //
    AP<PROPID> rgReplacingPropIDs = new PROPID[cProps];
    ULONG cReplacingProps = 0;

    for (ULONG ulProp = 0; ulProp < cProps; ulProp++)
    {
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(rgPropIDs[ulProp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 190);
        }

        //
        // Check what we need to do with this property
        //
        switch (pTranslate->wQM1Action)
        {
        case e_NOTIFY_WRITEREQ_QM1_REPLACE:
            //
            // it is NT5 only property which has a similar property in NT4
            // Convert it to NT4 property (may lose information on the way)
            //
            {
                ASSERT(pTranslate->propidReplaceNotifyQM1 != 0);
                ASSERT(pTranslate->QM1SetPropertyHandle);

                //
                // check that we didn't generate the replacing property already.
                // this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
                //
                BOOL fReplacingPropNotFoundYet = TRUE;
                for (ULONG ulTmp = 0; (ulTmp < cReplacingProps) && fReplacingPropNotFoundYet; ulTmp++)
                {
                    if (rgReplacingPropIDs[ulTmp] == pTranslate->propidReplaceNotifyQM1)
                    {
                        //
                        // the replacing prop is already in the notification props, exit loop.
                        //
                        fReplacingPropNotFoundYet = FALSE;
                    }
                }

                //
                // generate replacing property if not generated yet
                //
                if (fReplacingPropNotFoundYet)
                {
                    if (pTranslate->QM1SetPropertyHandle)
                    {
                        hr = pTranslate->QM1SetPropertyHandle(cProps,
                                                              rgPropIDs,
                                                              rgPropVars,
                                                              ulProp,
                                                              &rgNT4PropVars[cNT4Props]);
                        if (FAILED(hr))
                        {
                            TrERROR(DS, "ConvertToNT4Props:pTranslate->ConvertToQM1Handle(%lx)=%lx", rgPropIDs[ulProp], hr);
                            return LogHR(hr, s_FN, 200);
                        }
                        rgNT4PropIDs[cNT4Props] = pTranslate->propidReplaceNotifyQM1;
                        //
                        // increment NT4 props
                        //
                        cNT4Props++;

                        //
                        // mark that the replacing property was already generated
                        //
                        rgReplacingPropIDs[cReplacingProps] = pTranslate->propidReplaceNotifyQM1;
                        cReplacingProps++;
                    }
                }
            }
            break;

        case e_NOTIFY_WRITEREQ_QM1_AS_IS:
            {
                //
                // it is a property that NT4 understands.
                // duplicate the property into auto release propvar
                //
                CMQVariant varTmp(rgPropVars[ulProp]);
                //
                // put it in the propvars array, and detach the auto release propvar
                //
                rgNT4PropVars[cNT4Props] = *(varTmp.CastToStruct());
                varTmp.CastToStruct()->vt = VT_EMPTY;
                //
                // copy the propid
                //
                rgNT4PropIDs[cNT4Props] = rgPropIDs[ulProp];
                //
                // increment NT4 props
                //
                cNT4Props++;
            }
            break;

        case e_NO_NOTIFY_NO_WRITEREQ_QM1:
            //
            // it is a dummy property, ignore it
            //
            break;

        case e_NO_NOTIFY_ERROR_WRITEREQ_QM1:
            //
            // it is NT5 only property, we cannot put it in a write request
            // so we generate an error
            //
            return LogHR(MQ_ERROR, s_FN, 210); //BUGBUG: we need to have a better error code
            break;

        default:
            ASSERT(0);
            break;
        }
    }

    //
    // return values
    //
    *pcNT4Props = cNT4Props;
    if (cNT4Props > 0)
    {
        *prgNT4PropIDs = rgNT4PropIDs.detach();
        *prgNT4PropVars = rgNT4PropVars;
        cCleanNT4Props.detach();
    }
    else
    {
        *prgNT4PropIDs = NULL;
        *prgNT4PropVars = NULL;
    }
    return MQ_OK;
}


PROPVARIANT * FindPropInArray(PROPID propid,
                              ULONG cProps,
                              const PROPID * rgPropIDs,
                              PROPVARIANT * rgPropVars)
/*++

Routine Description:
    finds a value for a property in given props.

Arguments:
    propid - propid to search
    cProps               - given props (count)
    rgPropIDs            - given props (propids)
    rgPropVars           - given props (propvars)

Return Value:
    If property was found - a pointer to its value
    otherwise - NULL

--*/
{
    for (ULONG ulProp = 0; ulProp < cProps; ulProp++)
    {
        if (rgPropIDs[ulProp] == propid)
        {
            return (&rgPropVars[ulProp]);
        }
    }
    return NULL;
}


HRESULT GetNT4CreateQueueProps(ULONG cProps,
                               const PROPID * rgPropIDs,
                               const PROPVARIANT * rgPropVars,
                               ULONG * pcNT4CreateProps,
                               PROPID ** prgNT4CreatePropIDs,
                               PROPVARIANT ** prgNT4CreatePropVars)
/*++

Routine Description:
    Gets create-queue props (might contain QM2.0 props), and returns props suitable
    for create-queue-write-request to an NT4 PSC.
    It replaces NT5 props with the corresponding NT4 props (if possible), removes
    NT5 specific props that don't have NT4 match, and adds default values to props
    that are needed and not supplied (in NT5 we put in the DS only values that are
    not default)

Arguments:
    cProps               - given create-queue props (count)
    rgPropIDs            - given create-queue props (propids)
    rgPropVars           - given create-queue props (propvars)
    pcNT4CreateProps     - returned NT4 create-queue props (count)
    prgNT4CreatePropIDs  - returned NT4 create-queue props (propids)
    prgNT4CreatePropVars - returned NT4 create-queue props (propvars)

Return Value:
    HRESULT

--*/
{
    //
    // Convert given props to NT4 props
    //
    ULONG cNT4Props;
    AP<PROPID> rgNT4PropIDs;
    PROPVARIANT * rgNT4PropVars;
    HRESULT hr = ConvertToNT4Props(cProps,
                                   rgPropIDs,
                                   rgPropVars,
                                   &cNT4Props,
                                   &rgNT4PropIDs,
                                   &rgNT4PropVars);
    if (FAILED(hr))
    {
        TrERROR(DS, "GetNT4CreateQueueProps:ConvertToNT4Props()=%lx", hr);
        return LogHR(hr, s_FN, 220);
    }
    //
    // remember to free converted NT4 props
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    cCleanNT4Props.attach(cNT4Props, rgNT4PropVars);

    //
    // alloc new propvars, the size of the create queue write request props
    //
    CAutoCleanPropvarArray cCleanNT4CreateProps;
    PROPVARIANT * rgNT4CreatePropVars = cCleanNT4CreateProps.allocClean(x_cWritereqCreateQueueProps);
    AP<PROPID> rgNT4CreatePropIDs = new PROPID[x_cWritereqCreateQueueProps];
    ULONG cNT4CreateProps = 0;

    //
    // fill the create queue propvars
    //
    time_t tCurTime = time(NULL);
    PROPVARIANT * pNT4CreatePropVar = rgNT4CreatePropVars;
    for (ULONG ulTmp = 0; ulTmp < x_cWritereqCreateQueueProps; ulTmp++)
    {
        PROPID propid = x_rgWritereqCreateQueueProps[ulTmp];
        BOOL fPropIsFilled = FALSE;

        //
        // fill prop
        //
        switch(propid)
        {
        case PROPID_Q_INSTANCE:
            {
                //
                // for PROPID_Q_INSTANCE we get a new GUID
                //
                pNT4CreatePropVar->puuid = new GUID;
                pNT4CreatePropVar->vt = VT_CLSID;
                RPC_STATUS rpcstat = UuidCreate(pNT4CreatePropVar->puuid);
                if (rpcstat != RPC_S_OK)
                {
                    TrERROR(DS, "Failed to create queue UUID, UuidCreate=%lx", (DWORD)rpcstat);
                    LogRPCStatus(rpcstat, s_FN, 230);
                    return MQ_ERROR;
                }
                fPropIsFilled = TRUE;
            }
            break;

        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
            //
            // set current time
            //
            pNT4CreatePropVar->lVal = INT_PTR_TO_INT(tCurTime); //BUGBUG bug year 2038
            pNT4CreatePropVar->vt = VT_I4;
            fPropIsFilled = TRUE;
            break;

        case PROPID_Q_SCOPE:
            //
            // set to enterprise scope
            // IMPORTANT, without using this property in the write request, the queue
            // on MSMQ 1.0 PSC will not replicate.
            // somehow this property is still used in MSMQ 1.0 PSC replication even
            // though it should have been disabled there.
            //
            pNT4CreatePropVar->bVal = ENTERPRISE_SCOPE;
            pNT4CreatePropVar->vt = VT_UI1;
            fPropIsFilled = TRUE;
            break;

        default:
            {
                //
                // not a special prop, use the given property if exists, or a default value
                //
                PROPVARIANT * pNT4PropVar = FindPropInArray(propid,
                                                        cNT4Props,
                                                        rgNT4PropIDs,
                                                        rgNT4PropVars);
                if (pNT4PropVar)
                {
                    //
                    // we have the property in the converted props. Since the converted
                    // props are temporary, we use it w/o allocating, and nullify the temporary
                    // converted prop.
                    //
                    *pNT4CreatePropVar = *pNT4PropVar;
                    pNT4PropVar->vt = VT_EMPTY;
                    fPropIsFilled = TRUE;
                }
                else
                {
                    //
                    // property was not supplied. We check if we have a default value for it
                    // Get property info
                    //
                    const MQTranslateInfo *pTranslate;
                    if(!g_PropDictionary.Lookup(propid, pTranslate))
                    {
                        ASSERT(0);
                        return LogHR(MQ_ERROR, s_FN, 240);
                    }
                    if (pTranslate->pvarDefaultValue)
                    {
                        //
                        // we have a default value, duplicate it
                        //
                        CMQVariant varTmp(*pTranslate->pvarDefaultValue);
                        *pNT4CreatePropVar = *(varTmp.CastToStruct());
                        varTmp.CastToStruct()->vt = VT_EMPTY;
                        fPropIsFilled = TRUE;
                    }
                    else
                    {
                        //
                        // the property was not given, and no default value.
                        // ignore this property.
                        //
                        ASSERT(0);
                        //return LogHR(MQ_ERROR, s_FN, 250);
                    }
                }
            }
            break;
        }

        //
        // finish handling the property
        //
        if (fPropIsFilled)
        {
            pNT4CreatePropVar++;
            rgNT4CreatePropIDs[cNT4CreateProps] = propid;
            cNT4CreateProps++;
        }
    }

    //
    // return results
    //
    *pcNT4CreateProps = cNT4CreateProps;
    if (cNT4CreateProps > 0)
    {
        *prgNT4CreatePropIDs = rgNT4CreatePropIDs.detach();
        *prgNT4CreatePropVars = rgNT4CreatePropVars;
        cCleanNT4CreateProps.detach();
    }
    else
    {
        *prgNT4CreatePropIDs = NULL;
        *prgNT4CreatePropVars = NULL;
    }
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\siteinfo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siteinfo.cpp

Abstract:

    Site information Class

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (ilanh)   9-July-2000 


--*/
#include "ds_stdh.h"
#include "siteinfo.h"
#include "cs.h"
#include "hquery.h"
#include "mqads.h"
#include "mqadsp.h"
#include "adserr.h"
#include "mqutil.h"
#include "dsutils.h"
#include "ex.h"

#include "siteinfo.tmh"

//
//  refreshinterval of site gates info of a site
//
const DWORD cRefreshSiteInformation ( 1 * 60 * 60 * 1000); /* 1 hour */

static WCHAR *s_FN=L"mqdscore/siteinfo";


/*====================================================

CSiteInformation::CSiteInformation

Arguments:

Return Value:

=====================================================*/
CSiteInformation::CSiteInformation():
                  m_pguidSiteGates(NULL),
                  m_dwNumSiteGates(0),
                  m_fInitialized(FALSE),
                  m_RefreshTimer( RefreshSiteInfo)
{
    //
    //  The object is left in an uninitialized state.
    //  DS operation will be performed in the init method.
    //
}

/*====================================================

CSiteInformation::~CSiteInformation

Arguments:

Return Value:

=====================================================*/
CSiteInformation::~CSiteInformation()
{
    delete [] m_pguidSiteGates;

	ExCancelTimer(&m_RefreshTimer);
}


/*====================================================

CSiteInformation::Init

Arguments:

Return Value:

=====================================================*/

HRESULT CSiteInformation::Init(BOOL fReplicationMode)
{
    ASSERT( m_fInitialized == FALSE);
    HRESULT hr;
    //
    //  First find the unique id of this site
    //
    ASSERT( g_pwcsServerName != NULL);
    //
    //  Find the server in the configuration\sites folder.
    //
    //  In setup mode we just find the first server object with this computer
    //  name.
    //
    //  Not in setup mode, a server object with this computer name may appear
    //  in several sites, and only in some of them msmq-settings is defined.
    //  This can happen in migration.
    //  Therefore we locate the msmq-settings according to this QM-Id
    //
    AP<WCHAR> pwcsServerContainerName;
    if ( g_fSetupMode)
    {
        //
        //  Next find this server in the configuration\sites folder
        //
        MQPROPERTYRESTRICTION propRestriction;
        propRestriction.rel = PREQ;
        propRestriction.prop = PROPID_SRV_NAME;
        propRestriction.prval.vt = VT_LPWSTR;
        propRestriction.prval.pwszVal = g_pwcsServerName;


        MQRESTRICTION restriction;
        restriction.cRes = 1;
        restriction.paPropRes = &propRestriction;

        PROPID prop = PROPID_SRV_FULL_PATH;

        CDsQueryHandle hQuery;
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

        hr = g_pDS->LocateBegin(
                eSubTree,	
                eLocalDomainController,	
                &requestDsServerInternal,     // internal DS server operation
                NULL,
                &restriction,
                NULL,
                1,
                &prop,
                hQuery.GetPtr());
        if (FAILED(hr))
        {
            TrERROR(DS, "CSiteInformation::init : Locate begin failed %lx", hr);
            return LogHR(hr, s_FN, 10);
        }
        //
        //  Read the results
        //  BUGBUG - assuming one result ( no support of DC in multiple sites)
        //

        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            TrWARNING(DS, "CSiteInformation::Init : Locate next failed %lx", hr);
            return LogHR(hr, s_FN, 20);
        }
        if ( cp != 1)
        {
            //
            //  This DS server object was not found
            //
            TrWARNING(DS, "CSiteInformation::Init : server object not found");
            return LogHR(MQ_ERROR, s_FN, 30);
        }
        AP<WCHAR> pwcsServerFullPath = var.pwszVal;      // for clean-up purposes
        //
        //  From the unique id of the server get the server container name
        //
        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsServerFullPath,
                &pwcsServerContainerName
                );
        if (FAILED(hr))
        {
            TrERROR(DS, "CSiteInformation::Init : cannot get servers container name");
            LogHR(hr, s_FN, 40);
            return MQ_ERROR;
        }
    }
    else
    {
        //
        //  Not in setup mode
        //
        DWORD dwValueType = REG_BINARY ;
        DWORD dwValueSize = sizeof(GUID);
        GUID guidQMId;

        LONG rc = GetFalconKeyValue(MSMQ_QMID_REGNAME,
                                   &dwValueType,
                                   &guidQMId,
                                   &dwValueSize);

        if (rc != ERROR_SUCCESS)
        {
            TrERROR(DS,"CSiteInformation::Init Can't read QM Guid. Error %d", GetLastError());
            LogNTStatus(rc, s_FN, 50);
            return MQ_ERROR;
        }

        MQPROPERTYRESTRICTION propRestriction;
        propRestriction.rel = PREQ;
        propRestriction.prop = PROPID_SET_QM_ID;
        propRestriction.prval.vt = VT_CLSID;
        propRestriction.prval.puuid = &guidQMId;


        MQRESTRICTION restriction;
        restriction.cRes = 1;
        restriction.paPropRes = &propRestriction;

        PROPID prop = PROPID_SET_FULL_PATH;

        CDsQueryHandle hQuery;
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

        hr = g_pDS->LocateBegin(
                eSubTree,	
                eLocalDomainController,
                &requestDsServerInternal,     // internal DS server operation
                NULL,
                &restriction,
                NULL,
                1,
                &prop,
                hQuery.GetPtr());
        if (FAILED(hr))
        {
            TrERROR(DS, "CSiteInformation::init : Locate begin failed %lx", hr);
            return LogHR(hr, s_FN, 60);
        }
        //
        //  Read the results
        //  BUGBUG - assuming one result ( no support of DC in multiple sites)
        //

        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            TrWARNING(DS, "CSiteInformation::Init : Locate next failed %lx", hr);
            return LogHR(hr, s_FN, 70);
        }
        if ( cp != 1)
        {
            //
            //  This server msmq-setting object was not found
            //
            TrWARNING(DS, "CSiteInformation::Init : server object not found");
            return LogHR(MQ_ERROR, s_FN, 80);
        }
        AP<WCHAR> pwcsSettingName = var.pwszVal;
        AP<WCHAR> pwcsServerName;

        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsSettingName,
                &pwcsServerName
                );

        if (FAILED(hr))
        {
            TrERROR(DS, "CSiteInformation::Init : cannot get server name");
            LogHR(hr, s_FN, 90);
            return MQ_ERROR;
        }

        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsServerName,
                &pwcsServerContainerName
                );

        if (FAILED(hr))
        {
            TrERROR(DS, "CSiteInformation::Init : cannot get server container name");
            LogHR(hr, s_FN, 100);
            return MQ_ERROR;
        }

    }

    AP<WCHAR> pwcsSiteName;
    //
    //  Get the site name ( site object is the container of the servers container)
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_ConfigurationContainer,
            &requestDsServerInternal,        // local DS server operation
            pwcsServerContainerName,
            &pwcsSiteName
            );
    if (FAILED(hr))
    {
        TrERROR(DS, "CSiteInformation::Init : cannot get site name");
        LogHR(hr, s_FN, 110);
        return MQ_ERROR;
    }

    //
    //  Finally, from the site-name get the site id
    //
    PROPID prop = PROPID_S_SITEID;
    PROPVARIANT var;
    var.vt = VT_NULL;

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,	
                &requestDsServerInternal,     // internal operation of the DS server
 	            pwcsSiteName,
                NULL,
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        TrERROR(DS, "CSiteInformation::Init : cannot get site unique id");
        LogHR(hr, s_FN, 120);
        return MQ_ERROR;
    }
    m_guidSiteId = *var.puuid;


    //
    //  Query the site-gates
    //
    hr = RefreshSiteInfoInternal();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    m_fInitialized = TRUE;

    //
    //  schedule a refresh
	//
    if ( !g_fSetupMode && !fReplicationMode )
    {
		ExSetTimer(
			&m_RefreshTimer, 
			CTimeDuration::FromMilliSeconds(cRefreshSiteInformation)
			);
    }

    return(MQ_OK);
}



HRESULT CSiteInformation::QueryLinkGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                )
{
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    CSiteGateList SiteGateList;
    HRESULT hr;
    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,     // internal operation of the DS server
 	            NULL,      // object name
                &m_guidSiteId,      // unique id of object
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        TrERROR(DS, "CSiteInformation::QueryLinkGates : Failed to retrieve the DN of the site %lx", hr);
        return LogHR(hr, s_FN, 140);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;


    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-1
    //
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        &requestDsServerInternal,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        TrERROR(DS, "CSiteInformation::QueryLinkGates : Failed to query neighbor1 links %lx", hr);
        return LogHR(hr, s_FN, 150);

    }

    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-2
    //
    CDSRequestContext requestDsServerInternal2( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        &requestDsServerInternal2,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        TrERROR(DS, "CSiteInformation::QueryLinkGates : Failed to query neighbor2 links %lx", hr);
        return LogHR(hr, s_FN, 160);

    }

    //
    //  Fill in the results
    //
    SiteGateList.CopySiteGates(
               ppguidLinkSiteGates,
               pdwNumLinkSiteGates
               );

    return(MQ_OK);

}


HRESULT CSiteInformation::RefreshSiteInfoInternal()
{
    //
    //  retrieve new info
    //

    DWORD dwNumSiteGates;
    AP<GUID> pguidSiteGates;
    HRESULT hr;

    hr = QueryLinkGates(
                &pguidSiteGates,
                &dwNumSiteGates
                );
    if (FAILED(hr))
    {
        TrWARNING(DS, "CSiteInformation::RefreshSiteInfo :  failed to retrieve new info");
        return LogHR(hr, s_FN, 170);
    }
    DWORD dwNumThisSiteGates = 0;
    AP<GUID> pGuidThisSiteGates;
    if (dwNumSiteGates > 0)
    {
        //
        //  Filter the list of site-gates,
        //  and return only gates that belong
        //  to the this site ( they may
        //  belong to more than one site)
        //
        hr = MQADSpFilterSiteGates(
                &m_guidSiteId,
                dwNumSiteGates,
                pguidSiteGates,
                &dwNumThisSiteGates,
                &pGuidThisSiteGates
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 180);
        }
    }

    //
    //  Replace old info with new one
    //
    CS  lock( m_cs);
    delete [] m_pguidSiteGates;
    if ( dwNumThisSiteGates > 0)
    {
        m_pguidSiteGates = pGuidThisSiteGates.detach();
    }
    else
    {
        m_pguidSiteGates = NULL;
    }
    m_dwNumSiteGates = dwNumThisSiteGates;
    return LogHR(hr, s_FN, 190);

}


void WINAPI CSiteInformation::RefreshSiteInfo(
                IN CTimer* pTimer
                   )
{
    CSiteInformation * pSiteInfo = CONTAINING_RECORD(pTimer, CSiteInformation, m_RefreshTimer);;
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1613);
    //
    //  ignore failure -> reschedule
    //

    pSiteInfo->RefreshSiteInfoInternal();

    //
    //  reschedule
	//
	ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pSiteInfo->m_RefreshTimer, 
		CTimeDuration::FromMilliSeconds(cRefreshSiteInformation)
		);

}


BOOL CSiteInformation::CheckMachineIsSitegate(
                        IN const GUID * pguidMachine)
/*++

Routine Description:
    checks whether a machine is a sitegate

Arguments:
    pguidMachine     -  the unique id of the machine

Return Value:
    TRUE - if the requested machine is a site-gate, false otherwise

--*/
{
    CS lock(m_cs);
    for ( DWORD i = 0; i <  m_dwNumSiteGates; i++)
    {
        if ( *pguidMachine ==  m_pguidSiteGates[i])
        {
            return(TRUE);
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\sitedb.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ctdb.h

Abstract:

    CCTDB Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "ds_stdh.h"
#include "routtbl.h"
#include "_rstrct.h"
#include "dscore.h"
#include "adserr.h"

#include "sitedb.tmh"

CCost   g_InfiniteCost(0xffffffff);

#ifdef _DEBUG
extern BOOL g_fSetupMode ;
#endif

static WCHAR *s_FN=L"mqdscore/sitedb";

/*====================================================

GetStartNeighborPosition

Arguments:

Return Value:

Thread Context: main

=====================================================*/
POSITION    CSiteDB::GetStartNeighborPosition(IN const CSiteRoutingNode* pSrc)
{

    const CSiteRoutingNode* pSrcSite = (const CSiteRoutingNode *) pSrc;
    GUID guid;
    CSiteLinksInfo *pLinksInfo;

    m_pos = 0;

    guid = pSrcSite->GetNode();

    if (!(m_SiteLinksMap.Lookup(guid,pLinksInfo)))
    {
        return(NULL);
    }

    if (pLinksInfo->GetNoOfNeighbors() == 0)
    {
        return(NULL);
    }

    return((POSITION)pLinksInfo);
}

/*====================================================

GetNextNeighborAssoc

Arguments:

Return Value:

Thread Context: main

=====================================================*/
void    CSiteDB::GetNextNeighborAssoc(  IN OUT POSITION& pos,
                                        OUT const CSiteRoutingNode*& pKey,
                                        OUT CCost& val,
                                        OUT CSiteGate& SiteGate)
{


    DWORD   dwNeighbors;
    CSiteLinksInfo  *pLinksInfo = (CSiteLinksInfo*) pos;
    ASSERT(pos != NULL);

    pos = NULL;

    dwNeighbors = pLinksInfo->GetNoOfNeighbors();
    ASSERT(m_pos < dwNeighbors);


    CCost cost(pLinksInfo->GetCost(m_pos));
    CSiteGate sitegate(pLinksInfo->IsThereSiteGate(m_pos));
    pKey = pLinksInfo->GetNeighbor(m_pos);
    val = cost;
    SiteGate = sitegate;
    if (m_pos + 1 < dwNeighbors)
    {
        m_pos++;
        pos = (POSITION) pLinksInfo;
    }

    return;

}

//
//  Helper class
//
class CClearCALWSTR
{
public:
    CClearCALWSTR( PROPVARIANT * pVar)    { m_pVar = pVar; }
    ~CClearCALWSTR();
private:
    PROPVARIANT * m_pVar;
};

CClearCALWSTR::~CClearCALWSTR()
{
    for(DWORD i = 0; i < m_pVar->calpwstr.cElems; i++)
    {
        delete[] m_pVar->calpwstr.pElems[i];
    }
    delete [] m_pVar->calpwstr.pElems;

}


/*====================================================

GetAllSiteLinks

Arguments:

Return Value:

Thread Context: main

=====================================================*/
HRESULT CSiteDB::GetAllSiteLinks( )
{
extern HRESULT WINAPI QuerySiteLinks(
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle);

    HANDLE hQuery;
#define MAX_NO_OF_PROPS 30
    DWORD   dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT result[ MAX_NO_OF_PROPS];
    PROPVARIANT*    pvar;
    DWORD i,nCol;
    HRESULT hr;


    //
    // read all site links information
    //

    //
    //  set Column Set values
    //
    CColumns Colset1;

    Colset1.Add(PROPID_L_NEIGHBOR1);
    Colset1.Add(PROPID_L_NEIGHBOR2);
    Colset1.Add(PROPID_L_COST);
    Colset1.Add(PROPID_L_GATES_DN);
    nCol = 4;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr =  QuerySiteLinks(
                  NULL,
                  NULL,
                  Colset1.CastToStruct(),
                  0,
                  &requestDsServerInternal,
                  &hQuery);


    if ( FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            //
            // In "normal" mode, this call should succeed. If there are no
            // site linkes then the following "LookupNext" will not return
            // any value. that's legal.
            // However, in setup mode, on fresh machine, the above function
            // will fail because the "msmqService" object is not yet defined.
            // So we return MQ_OK always but assert for setup-mode.
            //
            ASSERT(g_fSetupMode) ;
            return MQ_OK ;
        }
        return LogHR(hr, s_FN, 10);
    }



    while ( SUCCEEDED ( hr = DSCoreLookupNext( hQuery, &dwProps, result)))
    {
        //
        //  No more results to retrieve
        //
        if (!dwProps)
            break;
        pvar = result;

        //
        //      Set the link information
        //
        for     ( i=dwProps/nCol; i > 0 ; i--,pvar+=nCol)
        {
            CClearCALWSTR pClean( (pvar+3));
            //
            //  Verify that this is a valid link ( both sites were
            //  not deleted)
            //
            if ( pvar->vt == VT_EMPTY ||
                 (pvar+1)->vt == VT_EMPTY)
            {
                continue;
            }
            //
            //  Set it in neighbor1
            //
            CSiteLinksInfo * pSiteLinkInfo;
            
            if (!m_SiteLinksMap.Lookup(*(pvar->puuid), pSiteLinkInfo))
            {
                pSiteLinkInfo = new CSiteLinksInfo();
                m_SiteLinksMap[*(pvar->puuid)] = pSiteLinkInfo;
            }
            
            pSiteLinkInfo->AddNeighbor(
                                *((pvar + 1)->puuid),
                                (pvar+2)->ulVal,
                                ((pvar+3)->calpwstr.cElems > 0)? TRUE : FALSE);



            //
            //  Set it in neighbor2
            //
            if ( !m_SiteLinksMap.Lookup(*((pvar + 1)->puuid), pSiteLinkInfo))
            {
                pSiteLinkInfo = new CSiteLinksInfo();
                m_SiteLinksMap[*((pvar+1)->puuid)] = pSiteLinkInfo;
            }

            pSiteLinkInfo->AddNeighbor(
                                    *(pvar->puuid),
                                    (pvar+2)->ulVal,
                                    ((pvar+3)->calpwstr.cElems)? TRUE : FALSE);


        }
    }


    // close the query handle
    hr = DSCoreLookupEnd( hQuery);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }
    return(hr);

}


/*====================================================

DestructElements of CSiteLinksMap

Arguments:

Return Value:


=====================================================*/

template<>
void AFXAPI DestructElements(CSiteLinksInfo ** ppLinksInfo, int n)
{
    int i;
    for (i=0;i<n;i++)
        delete *ppLinksInfo++;
}
/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/

template<>
BOOL AFXAPI  CompareElements(CSiteRoutingNode * const * ppRoutingNode1, CSiteRoutingNode * const * ppRoutingNode2)
{

    return ((**ppRoutingNode1)==(**ppRoutingNode2));

}
/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/

template<>
void AFXAPI DestructElements(CNextHop ** ppNextHop, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete *ppNextHop++;

}

/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/

template<>
void AFXAPI DestructElements(CSiteRoutingNode ** ppRoutingNode, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete *ppRoutingNode++;

}



/*====================================================

HashKey For CRoutingNode

Arguments:

Return Value:


=====================================================*/
template<>
UINT AFXAPI HashKey(CSiteRoutingNode* key)
{
    return (key->GetHashKey());
}
/*====================================================

Duplicate:

Arguments:

Return Value:


=====================================================*/
CNextHop * CNextHop::Duplicate() const
{
    return (new CNextHop(m_pNextNode,m_Cost,m_SiteGate));
};

/*====================================================

Const'

Arguments:

Return Value:


=====================================================*/

void CSiteLinksInfo::AddNeighbor(
                     IN GUID &        uuidNeighbor,
                     IN unsigned long ulCost,
                     IN BOOL          fSiteGates)
{
    DWORD   i;
#define NO_OF_LINKS 10


    if ( m_NoOfNeighbors >= m_NoAllocated)
    {
        if (m_NoAllocated == 0) m_NoAllocated = NO_OF_LINKS;
        AP<CSiteRoutingNode> aNeighbors = new CSiteRoutingNode[m_NoAllocated * 2];
        AP<unsigned long> aCosts = new unsigned long[m_NoAllocated *2];
        AP<BOOL> aSiteGates = new BOOL[m_NoAllocated *2];

        for(i=0; i < m_NoOfNeighbors ; i++)
        {
            aNeighbors[i].SetNode(m_pNeighbors[i].GetNode());
            aCosts[i] =  m_pCosts[i];
            aSiteGates[i] = m_pfSiteGates[i];
        }
        delete [] m_pNeighbors;
        delete [] m_pCosts;
        delete []m_pfSiteGates;

        m_pNeighbors = aNeighbors.detach();
        m_pCosts = aCosts.detach();
        m_pfSiteGates = aSiteGates.detach();

        m_NoAllocated *= 2;

    }
    m_pNeighbors[ m_NoOfNeighbors].SetNode( uuidNeighbor );
    m_pCosts[ m_NoOfNeighbors] =   ulCost;
    m_pfSiteGates[ m_NoOfNeighbors] = fSiteGates;
    m_NoOfNeighbors++;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\siterout.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siterout.cpp

Abstract:

    Site routing table  Class

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (ilanh)   9-July-2000 


--*/
#include "ds_stdh.h"
#include "siterout.h"
#include "cs.h"
#include "dijkstra.h"
#include "dsutils.h"
#include "coreglb.h"
#include "ex.h"

#include "siterout.tmh"

const time_t x_refreshDeltaTime = ( 1 * 60 * 60 * 1000); /* 1 hours */

static WCHAR *s_FN=L"mqdscore/siterout";

CSiteRoutingInformation::~CSiteRoutingInformation()
/*++

Routine Description:
    destructor.

Arguments:

Return Value:

--*/
{

	ExCancelTimer(&m_RefreshTimer);

}



HRESULT CSiteRoutingInformation::Init(
                IN const GUID *     pguidThisSiteId,
                IN BOOL             fReplicationMode )
/*++

Routine Description:
    Iniitalize site routing table.

Arguments:
    pguidThisSiteId     - site guid

Return Value:
MQ_OK - success
Other HRESULT errors

--*/
{
    m_guidThisSiteId = *pguidThisSiteId;

    HRESULT hr = RefreshSiteRoutingTableInternal();
    if (SUCCEEDED(hr))
    {
        m_fInitialized = TRUE;
        //
        //  schedule a refresh of the site-route-table
		//
		if ( !g_fSetupMode && !fReplicationMode)
        {
			ExSetTimer(
				&m_RefreshTimer, 
				CTimeDuration::FromMilliSeconds(x_refreshDeltaTime)
				);
        }
    }
    return LogHR(hr, s_FN, 10);

}

HRESULT CSiteRoutingInformation::CheckIfSitegateOnRouteToSite(
                        IN const GUID * pguidSite,
						OUT BOOL * pfSitegateOnRoute)
/*++

Routine Description:
    checks if there is a sitegate on the route to a site.
    attempts a refresh if the site is not found.

Arguments:
    pguidSite          - site guid
    pfSitegateOnRoute   - return whether there is a sitegate on the route

Return Value:
MQ_OK - success
MQDS_UNKNOWN_SITE_ID - pguidSite is not found
Other HRESULT errors

--*/
{
    //
    //  Is it a known site
    //
    CSiteRoutingNode Site( *pguidSite);
    CNextHop * pNextHop;

    CS lock(m_cs);
    if ( m_SiteRoutingTable.Lookup( &Site, pNextHop))
    {
        CSiteGate SiteGate = pNextHop->GetSiteGate();
        *pfSitegateOnRoute = SiteGate.IsThereASiteGate();
        return( MQ_OK);
    }
    //
    //  Even though failed to find the site, we don't
    //  try to refresh the site-routing table. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //

    return LogHR(MQDS_UNKNOWN_SITE_ID, s_FN, 20);

}

HRESULT CSiteRoutingInformation::FindBestSiteFromHere(
                                IN const ULONG   cSites,
	                            IN const GUID *  pguidSites,
            	                OUT GUID *       pguidBestSite,
                        	    OUT BOOL *       pfSitegateOnRoute)
/*++

Routine Description:
    finds the site with the least cost from a given array of site, and whether there is a sitegate on the route to it.
    attempts a refresh if no site is found.

Arguments:
    cSites              - number of sites in the passed array
    rgguidSites        - array of sites
    pguidBestSite      - returned site with least cost from here
    pfSitegateOnRoute   - return whether there is a sitegate on the route

Return Value:
	MQ_OK - success
	MQDS_UNKNOWN_SITE_ID - no site was found

	Other HRESULT errors

--*/

{
    CCost costMinimal(0xffffffff);
    ULONG indexMinimal = cSites + 1;
    CNextHop * pMinimalHop = NULL;

    CS lock(m_cs);
    for ( ULONG i = 0; i < cSites; i++)
    {

        CSiteRoutingNode Site( pguidSites[i]);
        CNextHop * pNextHop;
        //
        //  Is it a known site
        //
        if ( m_SiteRoutingTable.Lookup( &Site, pNextHop))
        {
            //
            //  Is it less than the other sites costs
            //
            CCost cost = pNextHop->GetCost();
            if ( cost < costMinimal)
            {
                costMinimal = cost;
                indexMinimal = i;
                pMinimalHop = pNextHop;
            }
        }
    }
    //
    //  Even though failed to find the site, we don't
    //  try to refresh the site-routing table. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //


    //
    //  if no site was found, return error
    //
    if ( pMinimalHop == NULL)
    {
        return LogHR(MQDS_UNKNOWN_SITE_ID, s_FN, 30);
    }

    ASSERT( indexMinimal < cSites);
    *pguidBestSite = pguidSites[ indexMinimal];
    CSiteGate SiteGate = pMinimalHop->GetSiteGate();
    *pfSitegateOnRoute = SiteGate.IsThereASiteGate();
    return( MQ_OK);
}

HRESULT CSiteRoutingInformation::RefreshSiteRoutingTableInternal()
{
    HRESULT hr = MQ_OK;

    //
    //  rebuild routing table
    //

    CSiteDB SiteDB;
    hr = SiteDB.Init( m_guidThisSiteId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    CS lock(m_cs);
    hr = Dijkstra(&SiteDB, &m_SiteRoutingTable);


    return LogHR(hr, s_FN, 50);

}


void WINAPI CSiteRoutingInformation::RefrshSiteRouteTable(
                IN CTimer* pTimer
                   )
{
    CSiteRoutingInformation * pSiteRouteInfo = CONTAINING_RECORD(pTimer, CSiteRoutingInformation, m_RefreshTimer);
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1614);
    //
    //  ignore failure -> reschedule
    //

    pSiteRouteInfo->RefreshSiteRoutingTableInternal();

    //
    //  reschedule
	//
    ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pSiteRouteInfo->m_RefreshTimer, 
		CTimeDuration::FromMilliSeconds(x_refreshDeltaTime)
		);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\siteinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siteinfo.h

Abstract:

    Site information Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SITEINFO_H__
#define __SITEINFO_H__

#include <Ex.h>

class CSiteGateList
{
    public:
        CSiteGateList();
        ~CSiteGateList();
        HRESULT AddSiteGates(
                    IN const DWORD  num,
                    IN const GUID * pguidGates
                    );
        HRESULT CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const;

        const GUID * GetSiteGate(
                IN  const DWORD  dwIndex
                ) const;

        DWORD GetNumberOfGates() const;

    private:
        DWORD   m_dwNumAllocated;
        DWORD   m_dwNumFilled;
        GUID *  m_pguidGates;

};

inline CSiteGateList::CSiteGateList() :
                      m_dwNumAllocated(0),
                      m_dwNumFilled(0),
                      m_pguidGates(NULL)
{
}

inline DWORD CSiteGateList::GetNumberOfGates() const
{
    return( m_dwNumFilled);
}


inline HRESULT CSiteGateList::AddSiteGates(
                    IN const DWORD  dwNum,
                    IN const GUID * pguidGates
                    )
{
    const DWORD cNumToAllocate = 20;

    //
    //  Not enough space allocated
    //
    if ( m_dwNumFilled + dwNum > m_dwNumAllocated)
    {
        DWORD dwToAllocate = ( m_dwNumFilled + dwNum > m_dwNumAllocated + cNumToAllocate) ?
            m_dwNumFilled + dwNum : m_dwNumAllocated + cNumToAllocate;
        GUID * pguidTmp = new GUID [dwToAllocate];
        //
        //  copy old list if exist
        //
        if ( m_pguidGates)
        {
            memcpy( pguidTmp, m_pguidGates,  m_dwNumFilled * sizeof(GUID));
            delete [] m_pguidGates;
        }
        m_pguidGates = pguidTmp;
        m_dwNumAllocated = dwToAllocate;
    }
    //
    //  add gates
    //
    memcpy( &m_pguidGates[ m_dwNumFilled], pguidGates, dwNum * sizeof(GUID));
    m_dwNumFilled += dwNum;
    return(MQ_OK);
}

inline HRESULT CSiteGateList::CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const
{
    //
    //  allocate the output buffer and copy the site-gates
    //
    if ( m_dwNumFilled)
    {
        *ppguidLinkSiteGates = new GUID[ m_dwNumFilled];
        memcpy( *ppguidLinkSiteGates, m_pguidGates, m_dwNumFilled * sizeof(GUID));
        *pdwNumLinkSiteGates =  m_dwNumFilled;
    }
    return(MQ_OK);
}



inline CSiteGateList::~CSiteGateList()
{
    delete [] m_pguidGates;
}

inline const GUID * CSiteGateList::GetSiteGate(
                IN  const DWORD  dwIndex
                ) const
{
    ASSERT( dwIndex < m_dwNumFilled);
    return( &m_pguidGates[dwIndex]);
}


enum eLinkNeighbor
{
    eLinkNeighbor1,
    eLinkNeighbor2
};

//
//  BUGBUG CSiteInformation - one site only ( what if DC belongs to two sites ?)
//
class CSiteInformation
{
    public:
		CSiteInformation();
        ~CSiteInformation();

        HRESULT Init(BOOL fReplicationMode);

        BOOL IsThisSite (
                const GUID * guidSiteId
                );

        const GUID * GetSiteId();

        //
        //  This routine returns the list and number of site-gates
        //
        //  The routines allocate the site-gates array and
        //  it is the responsibility of the caller to release it
        //
        HRESULT FillSiteGates(
                OUT DWORD * pdwNumSiteGates,
                OUT GUID ** ppguidSiteGates
                );


        BOOL CheckMachineIsSitegate(
                        IN const GUID * pguidMachine);


    private:
        //
        //  Refresh the list of the site-gates that
        //  belong to this site.
        //
        //  The site-gates of this site are all the session
        //  concentration site-gates
        //  ( i.e. site-gates that belong to this site only)
        //  on any of this site links
        //

        static void WINAPI RefreshSiteInfo(
                IN CTimer* pTimer
                   );

        HRESULT RefreshSiteInfoInternal();

        HRESULT QueryLinkGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                );

        GUID                m_guidSiteId;
        GUID *              m_pguidSiteGates;
        DWORD               m_dwNumSiteGates;
	    CCriticalSection	m_cs;
        BOOL                m_fInitialized;

        CTimer m_RefreshTimer;


};

inline BOOL CSiteInformation::IsThisSite (
                const GUID * guidSiteId
                )
{
    return( m_guidSiteId == *guidSiteId);
}


inline  HRESULT CSiteInformation::FillSiteGates(
                OUT DWORD * pdwNumSiteGates,
                OUT GUID ** ppguidSiteGates
                )
{
    CS lock(m_cs);
    if (  m_dwNumSiteGates)
    {
        *ppguidSiteGates = new GUID[ m_dwNumSiteGates];
        memcpy( *ppguidSiteGates, m_pguidSiteGates, m_dwNumSiteGates * sizeof(GUID));
    }
    else
    {
        *ppguidSiteGates = NULL;
    }

    *pdwNumSiteGates = m_dwNumSiteGates;
    return(MQ_OK);
}

inline const GUID * CSiteInformation::GetSiteId()
{
    return (&m_guidSiteId);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\siterout.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siterout.h

Abstract:

    Sites' routing information Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SITEROUT_H__
#define __SITEROUT_H__

#include <Ex.h>
#include "routtbl.h"

class CSiteRoutingInformation
{
    public:
		CSiteRoutingInformation();

        ~CSiteRoutingInformation();

        HRESULT Init(
                IN const GUID *     pguidThisSiteId,
                IN BOOL             freplicationMode );

        HRESULT CheckIfSitegateOnRouteToSite(
                        IN const GUID * pguidSite,
						OUT BOOL * pfSitegateOnRoute);

        HRESULT FindBestSiteFromHere(
                                IN const ULONG   cSites,
	                            IN const GUID *  pguidSites,
            	                OUT GUID *       pguidBestSite,
                        	    OUT BOOL *       pfSitegateOnRoute);


    private:
        //
        //  Refresh the site route table
        //

        static void WINAPI RefrshSiteRouteTable(
                IN CTimer* pTimer
                   );

        HRESULT RefreshSiteRoutingTableInternal();


	    CCriticalSection	m_cs;
        CRoutingTable       m_SiteRoutingTable;
        GUID                m_guidThisSiteId;

        CTimer              m_RefreshTimer;
        BOOL                m_fInitialized;     // indication of successful init


};
inline 		CSiteRoutingInformation::CSiteRoutingInformation():
            m_RefreshTimer( RefrshSiteRouteTable),
            m_fInitialized(FALSE)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\traninfo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    traninfo.cpp

Abstract:

    Translation information of MSMQ 1.0 properties into MSMQ 2.0 attributes

Author:

    ronit hartmann ( ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "mqprops.h"
#include "mqattrib.h"
#include "_mqini.h"
#include "tranrout.h"
#include "xlatqm.h"

#include "traninfo.tmh"

static WCHAR *s_FN=L"mqdscore/traninfo";

GUID guidNull = {0,0,0,{0,0,0,0,0,0,0,0}};
//----------------------------------------------------------
//  defaultVARIANT
//
//  This structure is equivalent in size and order of variables 
//  to MQPROPVARIANT.
//
//  MQPROPVARIANT contains a union, and the size first member of
//  the union is smaller than other members of the union.
//  Therefore MQPROVARIANT cannot be initialized at compile time
//  with union members other than the smallest one.
//
//----------------------------------------------------------
struct defaultVARIANT {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    ULONG_PTR l1;
    ULONG_PTR l2;
};

C_ASSERT(sizeof(defaultVARIANT) == sizeof(MQPROPVARIANT));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l1) == FIELD_OFFSET(MQPROPVARIANT, caub.cElems));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l2) == FIELD_OFFSET(MQPROPVARIANT, caub.pElems));

//
//      Default values for queue properties
//
const defaultVARIANT varDefaultQType = { VT_CLSID, 0,0,0, (LONG_PTR)&guidNull, 0};
const defaultVARIANT varDefaultQJournal = { VT_UI1, 0,0,0, DEFAULT_Q_JOURNAL, 0};
const defaultVARIANT varDefaultQQuota = { VT_UI4, 0,0,0, DEFAULT_Q_QUOTA, 0};
const defaultVARIANT varDefaultQBasePriority = { VT_I2, 0,0,0, DEFAULT_Q_BASEPRIORITY, 0};
const defaultVARIANT varDefaultQJQuota = { VT_UI4, 0,0,0, DEFAULT_Q_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQJLabel = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQAuthenticate = { VT_UI1, 0,0,0, DEFAULT_Q_AUTHENTICATE, 0};
const defaultVARIANT varDefaultQPrivLevel = { VT_UI4, 0,0,0, DEFAULT_Q_PRIV_LEVEL, 0};
const defaultVARIANT varDefaultQTransaction = { VT_UI1, 0,0,0, DEFAULT_Q_TRANSACTION, 0};

MQTranslateInfo   QueueTranslateInfo[] = {
// PROPID                | attribute-name               | vartype   | adstype                   | Translation routine                  | multivalue| InGC | default value                            | Set routine | Create routine | QM1 action                   | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-----------|---------------------------|--------------------------------------|-----------|------|------------------------------------------|-------------|----------------|------------------------------|--------------------|-----------------|
{PROPID_Q_INSTANCE       ,MQ_Q_INSTANCE_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_INSTANCE_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_TYPE           ,MQ_Q_TYPE_ATTRIBUTE           ,VT_CLSID   ,MQ_Q_TYPE_ADSTYPE          ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQType          ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_PATHNAME       ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueName               ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_JOURNAL        ,MQ_Q_JOURNAL_ATTRIBUTE        ,VT_UI1     ,MQ_Q_JOURNAL_ADSTYPE       ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJournal       ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_QUOTA          ,MQ_Q_QUOTA_ATTRIBUTE          ,VT_UI4     ,MQ_Q_QUOTA_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQQuota         ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_BASEPRIORITY   ,MQ_Q_BASEPRIORITY_ATTRIBUTE   ,VT_I2      ,MQ_Q_BASEPRIORITY_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQBasePriority  ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_JOURNAL_QUOTA  ,MQ_Q_JOURNAL_QUOTA_ATTRIBUTE  ,VT_UI4     ,MQ_Q_JOURNAL_QUOTA_ADSTYPE ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJQuota        ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_LABEL          ,MQ_Q_LABEL_ATTRIBUTE          ,VT_LPWSTR  ,MQ_Q_LABEL_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJLabel        ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_CREATE_TIME    ,MQ_Q_CREATE_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_CREATE_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_MODIFY_TIME    ,MQ_Q_MODIFY_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_MODIFY_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_AUTHENTICATE   ,MQ_Q_AUTHENTICATE_ATTRIBUTE   ,VT_UI1     ,MQ_Q_AUTHENTICATE_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQAuthenticate  ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_PRIV_LEVEL     ,MQ_Q_PRIV_LEVEL_ATTRIBUTE     ,VT_UI4     ,MQ_Q_PRIV_LEVEL_ADSTYPE    ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQPrivLevel     ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_TRANSACTION    ,MQ_Q_TRANSACTION_ATTRIBUTE    ,VT_UI1     ,MQ_Q_TRANSACTION_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQTransaction   ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SCOPE          ,NULL                          ,VT_UI1     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_QMID           ,NULL                          ,VT_CLSID   ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueQMid               ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_MASTERID       ,MQ_Q_MASTERID_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_MASTERID_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SEQNUM         ,NULL                          ,VT_BLOB    ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_HASHKEY        ,NULL                          ,VT_UI4     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_LABEL_HASHKEY  ,NULL                          ,VT_UI4     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SECURITY       ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_Q_SECURITY   ,MQADSpQM1SetSecurity},
{PROPID_Q_NT4ID          ,MQ_Q_NT4ID_ATTRIBUTE          ,VT_CLSID   ,MQ_Q_NT4ID_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_DONOTHING      ,NULL                          ,VT_UI1     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_FULL_PATH      ,MQ_Q_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR  ,MQ_Q_FULL_PATH_ADSTYPE     ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},            
{PROPID_Q_NAME_SUFFIX    ,MQ_Q_NAME_EXT                 ,VT_LPWSTR  ,MQ_Q_NAME_EXT_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},            
{PROPID_Q_OBJ_SECURITY   ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_Q_SECURITY_INFORMATION  ,NULL                   ,VT_UI1     ,ADSTYPE_INVALID            ,MQADSpRetrieveNothing                 ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_PATHNAME_DNS   ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueDNSName            ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL}
};

//
//      Default values for machine properties
//

const defaultVARIANT varDefaultQMService = { VT_UI4, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceRout = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};    //[adsrv]
const defaultVARIANT varDefaultQMServiceDs   = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceDep  = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMInFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMOutFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMQuota = { VT_UI4, 0,0,0, DEFAULT_QM_QUOTA, 0};
const defaultVARIANT varDefaultQMJQuota = { VT_UI4, 0,0,0, DEFAULT_QM_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQMForeign = { VT_UI1, 0,0,0, DEFAULT_QM_FOREIGN, 0};
const defaultVARIANT varDefaultQMOs = { VT_UI4, 0,0,0, DEFAULT_QM_OS, 0};
const defaultVARIANT varDefaultQMMType = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQMSignPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMEncryptPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMSiteIDs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};


MQTranslateInfo   MachineTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                         | Set routine            | Create routine          | QM1 action                   | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|---------------------------------------|------------------------|-------------------------|------------------------------|--------------------|-----------------|
{PROPID_QM_SITE_ID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineSite               ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineSite    ,MQADSpCreateMachineSite  ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MACHINE_ID    ,MQ_QM_ID_ATTRIBUTE            ,VT_CLSID           ,MQ_QM_ID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_PATHNAME      ,MQ_QM_PATHNAME_ATTRIBUTE      ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineName               ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CONNECTION    ,NULL                          ,VT_LPWSTR|VT_VECTOR,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ENCRYPTION_PK ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ADDRESS       ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineAddresses          ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CNS           ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineCNs                ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_OUTFRS        ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineOutFrs             ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineOutFrss ,MQADSpCreateMachineOutFrss,e_NOTIFY_WRITEREQ_QM1_AS_IS  ,0                   ,NULL},
{PROPID_QM_INFRS         ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineInFrs              ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineInFrss  ,MQADSpCreateMachineInFrss,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
// [adsrv] Next one is for asking old-style QM Service - to be calculated
// TBD: is it OK to keep 2 attributes with the same names (different IDs)?
{PROPID_QM_SERVICE       ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,ADSTYPE_INVALID,            MQADSpRetrieveQMService                 ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADSpSetMachineService ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},  // [adsrv] TBD notification
// [adsrv] Next one provides access to the old PROPID_SET_SERVICE from migration and replication, like QueryNt4PSCs
{PROPID_QM_OLDSERVICE    ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,MQ_QM_SERVICE_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADSpSetMachineService ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
// [adsrv] Next are 3 new separate bits for server functionality
{PROPID_QM_SERVICE_DSSERVER   ,MQ_QM_SERVICE_DSSERVER_ATTRIBUTE    ,VT_UI1,MQ_QM_SERVICE_DSSERVER_ADSTYPE   ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDs ,MQADSpSetMachineServiceDs,NULL                    ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_SERVICE_ROUTING    ,MQ_QM_SERVICE_ROUTING_ATTRIBUTE     ,VT_UI1,MQ_QM_SERVICE_ROUTING_ADSTYPE    ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceRout,MQADSpSetMachineServiceRout,NULL                 ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_SERVICE_DEPCLIENTS ,MQ_QM_SERVICE_DEPCLIENTS_ATTRIBUTE  ,VT_UI1,MQ_QM_SERVICE_DEPCLIENTS_ADSTYPE ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDep  ,NULL                  ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_MASTERID      ,MQ_QM_MASTERID_ATTRIBUTE      ,VT_CLSID           ,MQ_QM_MASTERID_ADSTYPE     ,MQADSpRetrieveMachineMasterId           ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_HASHKEY       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_SEQNUM        ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_QUOTA         ,MQ_QM_QUOTA_ATTRIBUTE         ,VT_UI4             ,MQ_QM_QUOTA_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMQuota     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_JOURNAL_QUOTA ,MQ_QM_JOURNAL_QUOTA_ATTRIBUTE ,VT_UI4             ,MQ_QM_JOURNAL_QUOTA_ADSTYPE,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMJQuota    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MACHINE_TYPE  ,MQ_QM_MACHINE_TYPE_ATTRIBUTE  ,VT_LPWSTR          ,MQ_QM_MACHINE_TYPE_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMMType     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CREATE_TIME   ,MQ_QM_CREATE_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_CREATE_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MODIFY_TIME   ,MQ_QM_MODIFY_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_MODIFY_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_FOREIGN       ,MQ_QM_FOREIGN_ATTRIBUTE       ,VT_UI1             ,MQ_QM_FOREIGN_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMForeign   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_OS            ,MQ_QM_OS_ATTRIBUTE            ,VT_UI4             ,MQ_QM_OS_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOs        ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_SECURITY      ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_SECURITY  ,MQADSpQM1SetSecurity},
{PROPID_QM_SIGN_PK       ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_ENCRYPT_PK    ,MQ_QM_ENCRYPT_PK_ATTRIBUTE    ,VT_BLOB            ,MQ_QM_ENCRYPT_PK_ADSTYPE   ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_FULL_PATH     ,MQ_QM_FULL_PATH_ATTRIBUTE     ,VT_LPWSTR          ,MQ_QM_FULL_PATH_ADSTYPE    ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_QM_SITE_IDS      ,MQ_QM_SITES_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_QM_SITES_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSiteIDs   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_SITE_ID   ,MQADSpQM1SetMachineSite},
{PROPID_QM_OUTFRS_DN     ,MQ_QM_OUTFRS_ATTRIBUTE        ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOutFrs    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_OUTFRS    ,MQADSpQM1SetMachineOutFrss},
{PROPID_QM_INFRS_DN      ,MQ_QM_INFRS_ATTRIBUTE         ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMInFrs     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_INFRS     ,MQADSpQM1SetMachineInFrss},
{PROPID_QM_NT4ID         ,MQ_QM_NT4ID_ATTRIBUTE         ,VT_CLSID           ,MQ_QM_NT4ID_ADSTYPE        ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_DONOTHING     ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_OBJ_SECURITY  ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_QM_SECURITY_INFORMATION   ,NULL                 ,VT_UI1             ,ADSTYPE_INVALID            ,MQADSpRetrieveNothing                   ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ENCRYPT_PKS   ,MQ_QM_ENCRYPT_PK_ATTRIBUTE    ,VT_BLOB            ,MQ_QM_ENCRYPT_PK_ADSTYPE   ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_SIGN_PKS      ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_PATHNAME_DNS  ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineDNSName            ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_WORKGROUP_ID  ,MQ_QM_WORKGROUP_ID_ATTRIBUTE  ,VT_CLSID           ,MQ_QM_WORKGROUP_ID_ADSTYPE ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_DESCRIPTION   ,MQ_QM_DESCRIPTION_ATTRIBUTE   ,VT_LPWSTR          ,MQ_QM_DESCRIPTION_ADSTYPE  ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMDescription ,NULL                  ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL}
};   

 

 
//
//      Default values for enterprise properties
//

const defaultVARIANT varDefaultENameStyle = { VT_UI1, 0,0,0, DEFAULT_E_NAMESTYLE, 0};
const defaultVARIANT varDefaultECspName = { VT_LPWSTR, 0,0,0, (LONG_PTR)DEFAULT_E_DEFAULTCSP, 0};
const defaultVARIANT varDefaultELongLive = { VT_UI4, 0,0,0, MSMQ_DEFAULT_LONG_LIVE, 0};
const defaultVARIANT varDefaultEVersion = { VT_UI2, 0,0,0, DEFAULT_E_VERSION, 0};
const defaultVARIANT varDefaultEInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultEInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};
                                                                                                                                                                                                                         
MQTranslateInfo   EnterpriseTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                    | Translation routine                    | multivalue| InGC | default value                         | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|----------------------------|----------------------------------------|-----------|------|---------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_E_NAME           ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID             ,MQADSpRetrieveEnterpriseName            ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_NAMESTYLE      ,MQ_E_NAMESTYLE_ATTRIBUTE      ,VT_UI1             ,MQ_E_NAMESTYLE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultENameStyle  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CSP_NAME       ,MQ_E_CSP_NAME_ATTRIBUTE       ,VT_LPWSTR          ,MQ_E_CSP_NAME_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultECspName    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_PECNAME        ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID             ,MQADSpRetrieveEnterprisePEC             ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_S_INTERVAL1    ,MQ_E_INTERVAL1                ,VT_UI2             ,MQ_E_INTERVAL1_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval1  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_S_INTERVAL2    ,MQ_E_INTERVAL2                ,VT_UI2             ,MQ_E_INTERVAL2_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval2  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_ID             ,MQ_E_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_E_ID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CRL            ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CSP_TYPE       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_ENCRYPT_ALG    ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SIGN_ALG       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_HASH_ALG       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CIPHER_MODE    ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_LONG_LIVE      ,MQ_E_LONG_LIVE_ATTRIBUTE      ,VT_UI4             ,MQ_E_LONG_LIVE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultELongLive   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_VERSION        ,MQ_E_VERSION_ATTRIBUTE        ,VT_UI2             ,MQ_E_VERSION_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEVersion    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_NT4ID          ,MQ_E_NT4ID_ATTRIBUTE          ,VT_CLSID           ,MQ_E_NT4ID_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SECURITY       ,MQ_E_SECURITY_ATTRIBUTE       ,VT_BLOB            ,MQ_E_SECURITY_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL}
};


const defaultVARIANT varDefaultLGatesDN = { VT_LPWSTR|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLGates = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};

MQTranslateInfo   SiteLinkTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                  | Set routine           | Creare routine          | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|--------------------------------|-----------------------|-------------------------|------------|--------------------|-----------------|
{PROPID_L_NEIGHBOR1      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkNeighbor1             ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkNeighbor1 ,MQADSpCreateLinkNeighbor1,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR2      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkNeighbor2             ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkNeighbor2 ,MQADSpCreateLinkNeighbor2,0           ,0                   ,NULL},
{PROPID_L_COST           ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkCost                  ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkCost      ,MQADSpCreateLinkCost     ,0           ,0                   ,NULL},
{PROPID_L_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_ID             ,MQ_L_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_L_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_GATES_DN       ,MQ_L_SITEGATES_ATTRIBUTE      ,VT_LPWSTR|VT_VECTOR,MQ_L_SITEGATES_ADSTYPE     ,NULL                                    ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGatesDN,NULL                ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR1_DN   ,MQ_L_NEIGHBOR1_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR2_DN   ,MQ_L_NEIGHBOR2_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_DESCRIPTION    ,MQ_L_DESCRIPTION_ATTRIBUTE    ,VT_LPWSTR          ,MQ_L_DESCRIPTION_ADSTYPE   ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultLDescription,NULL            ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_FULL_PATH      ,MQ_L_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_FULL_PATH_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},            
{PROPID_L_ACTUAL_COST    ,MQ_L_COST_ATTRIBUTE           ,VT_UI4             ,MQ_L_COST_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_GATES          ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkGates                 ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGates,NULL                  ,NULL                     ,0           ,0                   ,NULL}
};


const defaultVARIANT varDefaultUserSignCert = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultUserDigest = { VT_VECTOR | VT_CLSID, 0,0,0,0,0};

MQTranslateInfo   UserTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_U_SID            ,MQ_U_SID_ATTRIBUTE            ,VT_BLOB            ,MQ_U_SID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_SIGN_CERT      ,MQ_U_SIGN_CERT_ATTRIBUTE      ,VT_BLOB            ,MQ_U_SIGN_CERT_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_DIGEST         ,MQ_U_DIGEST_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_U_DIGEST_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_ID             ,MQ_U_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_U_ID_ADSTYPE            ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   MQUserTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_MQU_SID          ,MQ_MQU_SID_ATTRIBUTE          ,VT_BLOB            ,MQ_MQU_SID_ADSTYPE         ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SIGN_CERT    ,MQ_MQU_SIGN_CERT_ATTRIBUTE    ,VT_BLOB            ,MQ_MQU_SIGN_CERT_ADSTYPE   ,NULL                                     ,FALSE     ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_MASTERID     ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                     ,FALSE     ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SEQNUM       ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                     ,FALSE     ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_DIGEST       ,MQ_MQU_DIGEST_ATTRIBUTE       ,VT_CLSID|VT_VECTOR ,MQ_MQU_DIGEST_ADSTYPE      ,NULL                                     ,TRUE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_ID           ,MQ_MQU_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_MQU_ID_ADSTYPE          ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SECURITY     ,MQ_MQU_SECURITY_ATTRIBUTE     ,VT_BLOB            ,MQ_MQU_SECURITY_ADSTYPE    ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

const defaultVARIANT varDefaultSForeign = { VT_UI1, 0,0,0, 0, 0};
const defaultVARIANT varDefaultSInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultSInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};


MQTranslateInfo   SiteTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                     | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|-----------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_S_PATHNAME       ,MQ_S_NAME_ATTRIBUTE           ,VT_LPWSTR          ,MQ_S_NAME_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SITEID         ,MQ_S_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_S_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_PSC            ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_INTERVAL1      ,MQ_S_INTERVAL1                ,VT_UI2             ,MQ_S_INTERVAL1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval1,NULL       ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_INTERVAL2      ,MQ_S_INTERVAL2                ,VT_UI2             ,MQ_S_INTERVAL2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval2,NULL       ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SECURITY       ,MQ_S_SECURITY_ATRRIBUTE       ,VT_BLOB            ,MQ_S_SECURITY_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_PSC_SIGNPK     ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,MQADSpRetrieveSiteSignPK                ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_GATES          ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveSiteGates                 ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_FULL_NAME      ,MQ_S_FULL_NAME_ATTRIBUTE      ,VT_LPWSTR          ,MQ_S_FULL_NAME_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_NT4_STUB       ,MQ_S_NT4_STUB_ATTRIBUTE       ,VT_UI2             ,MQ_S_NT4_STUB_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_FOREIGN        ,MQ_S_FOREIGN_ATTRIBUTE        ,VT_UI1             ,MQ_S_FOREIGN_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSForeign,NULL         ,NULL            ,0           ,0                   ,NULL},                                         
{PROPID_S_DONOTHING      ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   CnTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                     | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|-----------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_CN_SECURITY       ,MQ_S_SECURITY_ATRRIBUTE       ,VT_BLOB            ,MQ_S_SECURITY_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   ServerTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_SRV_NAME         ,MQ_SRV_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SRV_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SRV_ID           ,MQ_SRV_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_SRV_ID_ADSTYPE          ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},                              
{PROPID_SRV_FULL_PATH    ,MQ_SRV_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SRV_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}                              
};

MQTranslateInfo   SettingTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_SET_NAME         ,MQ_SET_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SET_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
// [adsrv] Next one provides access to the old PROPID_SET_SERVICE from migration and replication, like QueryNt4PSCs
{PROPID_SET_OLDSERVICE    ,MQ_SET_SERVICE_ATTRIBUTE      ,VT_UI4             ,MQ_SET_SERVICE_ADSTYPE     ,NULL                                   ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}, // [adsrv] TBD notification
{PROPID_SET_SERVICE_ROUTING   ,MQ_SET_SERVICE_ROUTING_ATTRIBUTE   ,VT_UI1 ,MQ_SET_SERVICE_ROUTING_ADSTYPE     ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_SERVICE_DSSERVER  ,MQ_SET_SERVICE_DSSERVER_ATTRIBUTE  ,VT_UI1 ,MQ_SET_SERVICE_DSSERVER_ADSTYPE    ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_SERVICE_DEPCLIENTS,MQ_SET_SERVICE_DEPCLIENTS_ATTRIBUTE,VT_UI1 ,MQ_SET_SERVICE_DEPCLIENTS_ADSTYPE  ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_QM_ID        ,MQ_SET_QM_ID_ATTRIBUTE        ,VT_CLSID           ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_APPLICATION  ,MQ_SET_APPLICATION_ATTRIBUTE  ,VT_LPWSTR          ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_FULL_PATH    ,MQ_SET_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SET_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},          
{PROPID_SET_NT4          ,MQ_SET_NT4_ATTRIBUTE          ,VT_UI4             ,MQ_SET_NT4_ADSTYPE         ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_MASTERID     ,MQ_SET_MASTERID_ATTRIBUTE     ,VT_CLSID           ,MQ_SET_MASTERID_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_SITENAME     ,MQ_SET_SITENAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_SET_SITENAME_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo ComputerTranslateInfo[] = {
// PROPID                   | attribute-name                   | vartype           | adstype                       | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//--------------------------|----------------------------------|-------------------|-------------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_COM_FULL_PATH       ,MQ_COM_FULL_PATH_ATTRIBUTE        ,VT_LPWSTR          ,MQ_COM_FULL_PATH_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SAM_ACCOUNT     ,MQ_COM_SAM_ACCOUNT_ATTRIBUTE      ,VT_LPWSTR          ,MQ_COM_SAM_ACCOUNT_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_CONTAINER       ,NULL                              ,VT_LPWSTR          ,ADSTYPE_INVALID                ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_ACCOUNT_CONTROL ,MQ_COM_ACCOUNT_CONTROL_ATTRIBUTE  ,VT_UI4             ,MQ_COM_ACCOUNT_CONTROL_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_DNS_HOSTNAME    ,MQ_COM_DNS_HOSTNAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_COM_DNS_HOSTNAME_ADSTYPE    ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SID             ,MQ_COM_SID_ATTRIBUTE              ,VT_BLOB            ,MQ_COM_SID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SIGN_CERT       ,MQ_COM_SIGN_CERT_ATTRIBUTE        ,VT_BLOB            ,MQ_COM_SIGN_CERT_ADSTYPE       ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_DIGEST          ,MQ_COM_DIGEST_ATTRIBUTE           ,VT_CLSID|VT_VECTOR ,MQ_COM_DIGEST_ADSTYPE          ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_ID              ,MQ_COM_ID_ATTRIBUTE               ,VT_CLSID           ,MQ_COM_ID_ADSTYPE              ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

//-----------------------------------------------------
// Helper macro to get the number of elements in a static array
//
//-----------------------------------------------------
#define ARRAY_SIZE(array)   (sizeof(array)/sizeof(array[0]))

//
//  An array that keeps the category strings of the classes
//
AP<WCHAR> pwcsCategory[e_MSMQ_NUMBER_OF_CLASSES];

//-----------------------------------------------------
// MSMQ classes
// keep in the same order as the enum in mqads.h
//-----------------------------------------------------
const MQClassInfo g_MSMQClassInfo[e_MSMQ_NUMBER_OF_CLASSES] = {
// class name                          | properties table       | number of properties in table       | get translation object routine | context                  | dwObjType        | ObjectCategory  | category                                | Category Len
//-------------------------------------|------------------------|-------------------------------------|--------------------------------|--------------------------|------------------|-----------------|-----------------------------------------|---------------------
{MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME, MachineTranslateInfo,    ARRAY_SIZE(MachineTranslateInfo),     GetMsmqQmXlateInfo,            e_RootDSE,                   MQDS_MACHINE,     &pwcsCategory[0], x_ComputerConfigurationCategoryName,     x_ComputerConfigurationCategoryLength},
{MSMQ_QUEUE_CLASS_NAME,                  QueueTranslateInfo,      ARRAY_SIZE(QueueTranslateInfo),       GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_QUEUE,       &pwcsCategory[1], x_QueueCategoryName,                     x_QueueCategoryLength},
{MSMQ_SERVICE_CLASS_NAME,                EnterpriseTranslateInfo, ARRAY_SIZE(EnterpriseTranslateInfo),  GetDefaultMsmqObjXlateInfo,    e_ServicesContainer,         MQDS_ENTERPRISE,  &pwcsCategory[2], x_ServiceCategoryName,                   x_ServiceCategoryLength},
{MSMQ_SITELINK_CLASS_NAME,               SiteLinkTranslateInfo,   ARRAY_SIZE(SiteLinkTranslateInfo),    GetDefaultMsmqObjXlateInfo,    e_MsmqServiceContainer,      MQDS_SITELINK,    &pwcsCategory[3], x_LinkCategoryName,                      x_LinkCategoryLength},
{MSMQ_USER_CLASS_NAME,                   UserTranslateInfo,       ARRAY_SIZE(UserTranslateInfo),        GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_USER,        &pwcsCategory[4], x_UserCategoryName,                      x_UserCategoryLength},
{MSMQ_SETTING_CLASS_NAME,                SettingTranslateInfo,    ARRAY_SIZE(SettingTranslateInfo),     GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            0,                &pwcsCategory[5], x_SettingsCategoryName,                  x_SettingsCategoryLength},
{MSMQ_SITE_CLASS_NAME,                   SiteTranslateInfo,       ARRAY_SIZE(SiteTranslateInfo),        GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            MQDS_SITE,        &pwcsCategory[6], x_SiteCategoryName,                      x_SiteCategoryLength},
{MSMQ_SERVER_CLASS_NAME,                 ServerTranslateInfo,     ARRAY_SIZE(ServerTranslateInfo),      GetDefaultMsmqObjXlateInfo,    e_ConfigurationContainer,    0,                &pwcsCategory[7], x_ServerCategoryName,                    x_ServerCategoryLength},
{MSMQ_COMPUTER_CLASS_NAME,               ComputerTranslateInfo,   ARRAY_SIZE(ComputerTranslateInfo),    GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   0,                &pwcsCategory[8], x_ComputerCategoryName,                  x_ComputerCategoryLength},
{MSMQ_MQUSER_CLASS_NAME,                 MQUserTranslateInfo,     ARRAY_SIZE(MQUserTranslateInfo),      GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_MQUSER,      &pwcsCategory[9], x_MQUserCategoryName,                    x_MQUserCategoryLength},
{MSMQ_SITE_CLASS_NAME,                   CnTranslateInfo,         ARRAY_SIZE(CnTranslateInfo),          GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            MQDS_CN,          &pwcsCategory[6], x_SiteCategoryName,                      x_SiteCategoryLength}
};

//-----------------------------------------------------
// Number of MSMQ classes
//
//-----------------------------------------------------
extern const ULONG g_cMSMQClassInfo = ARRAY_SIZE(g_MSMQClassInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\routtbl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routtbl.h

Abstract:

    Routing Table declarations
        
Author:

    Lior Moshaiov (LiorM)

--*/

#ifndef __ROUTTBL_H__
#define __ROUTTBL_H__

class CSiteRoutingNode 
{
    public:
        CSiteRoutingNode();
        CSiteRoutingNode(const GUID& guid);
        ~CSiteRoutingNode();
        UINT            GetHashKey() const;
        void            Print() const;
        int             operator==(IN const CSiteRoutingNode & other) const;
        CSiteRoutingNode *  Duplicate() const;

        const GUID& GetNode()   const;
        void    SetNode(IN const GUID & guid);

    private:
        CSiteRoutingNode(const CSiteRoutingNode &other);                // no definition - to find out unintentionaly copies
        void    operator=(const CSiteRoutingNode &other);               // no definition - to find out unintentionaly copies

        GUID    m_Guid;
            
};

class CSiteGate
{
    public:
        CSiteGate(BOOL fSiteGate=FALSE);
        ~CSiteGate();
        CSiteGate operator+(const CSiteGate &second) const;
        void operator =(IN BOOL fSiteGate);
        void    Print() const;
        BOOL    IsThereASiteGate() const;

        
    private:
        BOOL  operator<(const CSiteGate &second) const;    // no definition - to find out unintentionaly usage
        int  operator==( IN const CSiteGate &second) const;  // no definition - to find out unintentionaly usage

        BOOL    m_fSiteGate;
            
};

class CCost
{
    public:
        CCost(DWORD cost=0);
        ~CCost();
        CCost operator+(const CCost &second) const;
        BOOL  operator<(const CCost &second) const;
        int  operator==( IN const CCost &second) const;
        void operator =(IN DWORD cost);
        void    Print() const;

        
    private:

        DWORD m_Cost;
            
};

class CNextHop
{
    public:
        
        CNextHop(const CSiteRoutingNode* pNextNode);
        CNextHop(const CSiteRoutingNode* pNextNode, const CCost& Cost, const CSiteGate& SiteGate);
        ~CNextHop();

        
        CNextHop * Duplicate() const;
        const   CSiteRoutingNode* GetNextNode() const;
        const   CCost& GetCost()        const;
        void    Print()                 const;
        const   CSiteGate& GetSiteGate() const;
        
    private:
        CNextHop(const CNextHop &other);            // no definition - to find out unintentionaly copies
        void    operator=(const CNextHop &other);   // no definition - to find out unintentionaly copies

        CSiteRoutingNode*   m_pNextNode;
        CCost               m_Cost;
        CSiteGate           m_SiteGate;
            
};

typedef CMap<CSiteRoutingNode*,CSiteRoutingNode*,CNextHop*,CNextHop*> CRoutingTable;
template<>
BOOL AFXAPI CompareElements(CSiteRoutingNode * const * ppRoutingNode1, CSiteRoutingNode * const * ppRoutingNode2);
template<>
UINT AFXAPI HashKey(CSiteRoutingNode* key);
template<>
void AFXAPI DestructElements(CSiteRoutingNode ** ppRoutingNode, int n);
template<>
void AFXAPI DestructElements(CNextHop ** ppNextHop, int n);

class CSiteLinksInfo
{
    public:
        CSiteLinksInfo( );
                    
        ~CSiteLinksInfo();

        void AddNeighbor( GUID & uuidNeighbor,
                     unsigned long ulCost,
                     BOOL          fSiteGates);

        DWORD       GetNoOfNeighbors()  const ;
        DWORD       GetCost(IN DWORD i) const;
        DWORD       IsThereSiteGate(IN DWORD i) const;
        CSiteRoutingNode*   GetNeighbor(IN DWORD i)const ;

    private:

        DWORD               m_NoAllocated;
        DWORD               m_NoOfNeighbors;
        CSiteRoutingNode*   m_pNeighbors;
        DWORD*              m_pCosts;
        BOOL*               m_pfSiteGates;
};

typedef CMap<GUID, const GUID&, CSiteLinksInfo*,CSiteLinksInfo*> CSiteLinksMap;
template<>
extern void AFXAPI DestructElements(CSiteLinksInfo ** ppLinksInfo, int n);

class CSiteDB 
{
    public:
        CSiteDB();
        ~CSiteDB();
        HRESULT    Init(   IN const GUID& MySite);
        const CSiteRoutingNode* GetMyNode() const;
        POSITION            GetStartNeighborPosition(IN const CSiteRoutingNode* pSrc) ;
        void                GetNextNeighborAssoc(   IN OUT POSITION& pos,
                                                    OUT const CSiteRoutingNode*& pKey,
                                                    OUT CCost& val,
                                                    OUT CSiteGate& SiteGate);

    private:
       HRESULT GetAllSiteLinks( );
       CSiteDB(const CSiteDB &other);              // no definition - to find out unintentionaly copies
        void    operator=(const CSiteDB &other);    // no definition - to find out unintentionaly copies

        CSiteRoutingNode    m_MySiteNode;
        CSiteLinksMap       m_SiteLinksMap;
        DWORD               m_pos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\routtbl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routtbl.cpp

Abstract:

    Routing Table implementation

Author:

    Shai Kariv  (shaik)  05-Apr-2001

--*/

#include "ds_stdh.h"
#include "routtbl.h"

#include "routtbl.tmh"


//
// Class CSiteRoutingNode
//

CSiteRoutingNode::CSiteRoutingNode()
{
    memset(&m_Guid,0,sizeof(GUID));
};

CSiteRoutingNode::CSiteRoutingNode(const GUID& guid)
{
    m_Guid=guid;
};

CSiteRoutingNode::~CSiteRoutingNode()
{
};

UINT    CSiteRoutingNode::GetHashKey() const
{
        return((UINT)m_Guid.Data1);
};

void    CSiteRoutingNode::Print() const
{
        TrTRACE(ROUTING, "SiteNode %!guid!", &m_Guid);
};

int     CSiteRoutingNode::operator==(const CSiteRoutingNode & other) const
{
    const CSiteRoutingNode* pOther = (const CSiteRoutingNode *) &other;
    return (!(memcmp((const GUID *)&m_Guid, (const GUID *) &pOther->m_Guid, sizeof(GUID))));
};

CSiteRoutingNode*    CSiteRoutingNode::Duplicate() const
{
    return (new CSiteRoutingNode(m_Guid));
};

const GUID&  CSiteRoutingNode::GetNode() const
{
    return ((const GUID &)m_Guid);
};

void CSiteRoutingNode::SetNode(IN const GUID& guid)
{
    m_Guid=guid;
};


//
// Class CSiteGate
//

CSiteGate::CSiteGate(BOOL fSiteGate):m_fSiteGate(fSiteGate)
{
};

CSiteGate::~CSiteGate()
{
};

CSiteGate 
CSiteGate::operator+(const CSiteGate& second) const 
{
    return m_fSiteGate | second.m_fSiteGate;
};


void  
CSiteGate::Print() const 
{ 
    TrTRACE(ROUTING, "sitegate %u ",m_fSiteGate);
};


void
CSiteGate::operator=(IN BOOL fSiteGate)
{
    m_fSiteGate = fSiteGate;
}

BOOL
CSiteGate::IsThereASiteGate() const
{
    return( m_fSiteGate);
}

//
// Class CCost
//

CCost::CCost(DWORD cost):m_Cost(cost)
{
};

CCost::~CCost()
{
};

CCost 
CCost::operator+(const CCost& second) const 
{
    return m_Cost + second.m_Cost;
};

BOOL  
CCost::operator<(const CCost& second) const 
{
    return m_Cost < second.m_Cost;
};

void  
CCost::Print() const 
{ 
    TrTRACE(ROUTING, "cost %u ",m_Cost);
};

int  
CCost::operator==(const CCost & other) const
{
    return (!(memcmp((const DWORD *)&m_Cost, (const DWORD *) &other.m_Cost, sizeof(DWORD))));
};

void
CCost::operator=(IN DWORD cost)
{
    m_Cost = cost;
}

//
// Class CNextHop
//

CNextHop::~CNextHop()
{
    delete m_pNextNode;
};

CNextHop::CNextHop(const CSiteRoutingNode* pNextNode) : m_Cost(0)
{
    m_pNextNode = pNextNode->Duplicate();
};

CNextHop::CNextHop(const CSiteRoutingNode* pNextNode, const CCost& Cost, 
                           const CSiteGate& SiteGate)
{
    m_Cost = Cost;
    m_SiteGate = SiteGate;
    m_pNextNode = pNextNode->Duplicate();
};

const   CCost&  CNextHop::GetCost() const
{
    return m_Cost;
};

const   CSiteGate& CNextHop::GetSiteGate() const
{
    return m_SiteGate;
}

const   CSiteRoutingNode*   CNextHop::GetNextNode() const
{
    return m_pNextNode;
};

void    CNextHop::Print() const
{
    m_pNextNode->Print();
    m_Cost.Print();
    m_SiteGate.Print();
};

//
// Class CSiteLinksInfo
//

CSiteLinksInfo::CSiteLinksInfo() : m_NoAllocated(0),
                                          m_NoOfNeighbors(0),
                                          m_pNeighbors(NULL),
                                          m_pCosts(NULL),
                                          m_pfSiteGates(NULL)
{
}

CSiteLinksInfo::~CSiteLinksInfo()
{
    delete []m_pNeighbors;
    delete []m_pCosts;
    delete []m_pfSiteGates;
}

DWORD   CSiteLinksInfo::GetNoOfNeighbors()  const
{
    return(m_NoOfNeighbors);
}

DWORD   CSiteLinksInfo::GetCost(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(m_pCosts[i]);
}

DWORD  CSiteLinksInfo::IsThereSiteGate(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(m_pfSiteGates[i]);
}

CSiteRoutingNode*   CSiteLinksInfo::GetNeighbor(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(&m_pNeighbors[i]);
}

//
// Class
//

CSiteDB::CSiteDB(): m_pos(0)
{
};

CSiteDB::~CSiteDB()
{
};


HRESULT    CSiteDB::Init(  IN const GUID& guidMySite)
{
    m_MySiteNode.SetNode(guidMySite);
    //
    //  Read site links info
    //
    return(GetAllSiteLinks());
}

const CSiteRoutingNode* CSiteDB::GetMyNode() const
{
    return &m_MySiteNode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\tranrout.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.cpp

Abstract:


    Translation routines for properties not in NT5 DS


Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "coreglb.h"
#include <winsock.h>
#include "mqadsp.h"
#include "mqattrib.h"
#include "xlatqm.h"
#include <strsafe.h>

#include "tranrout.tmh"

static WCHAR *s_FN=L"mqdscore/tranrout";

/*====================================================

MQADSpRetrieveEnterpriseName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveEnterpriseName(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    DWORD len = wcslen( g_pwcsDsRoot);
    ppropvariant->pwszVal = new WCHAR[ len+ 1];
    HRESULT hr =StringCchCopy( ppropvariant->pwszVal, len+1, g_pwcsDsRoot);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveEnterprisePEC

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveEnterprisePEC(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    ppropvariant->pwszVal = new WCHAR[3];
    HRESULT hr = StringCchCopy( ppropvariant->pwszVal, 3,  L"");
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}


/*====================================================

MQADSpRetrieveSiteSignPK

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpRetrieveSiteSignPK(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *       ppropvariant)
{
   ASSERT( ppropvariant->vt == VT_NULL );

   HRESULT hr = MQADSpGetSiteSignPK(
                         pcMsmqObjXlateInfo->ObjectGuid(),
                        &ppropvariant->blob.pBlobData,
                        &ppropvariant->blob.cbSize ) ;
   ppropvariant->vt = VT_BLOB ;

   return LogHR(hr, s_FN, 10);
}


/*====================================================
MQADSpRetrieveSiteGates

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveSiteGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{

   ASSERT( ppropvariant->vt == VT_NULL);
   CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

   HRESULT hr = MQADSpGetSiteGates(
                   pcMsmqObjXlateInfo->ObjectGuid(),
                   &requestDsServerInternal,            // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
                   &ppropvariant->cauuid.cElems,
                   &ppropvariant->cauuid.pElems
                   );

    ppropvariant->vt = VT_CLSID|VT_VECTOR;
    return LogHR(hr, s_FN, 20);
}

/*====================================================

MQADSpRetrieveNothing

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpRetrieveNothing(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    ppropvariant->vt = VT_EMPTY ;
    return MQ_OK ;
}

/*====================================================

MQADSpRetrieveQueueQMid

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueQMid(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
    //
    //  Skip the queue name
    //
    while ( *pchar != L',' )
    {
		ASSERT(*pchar != NULL);
        pchar++;
    }
    pchar++;

    PROPID prop = PROPID_QM_MACHINE_ID;
    //
    //  To be on the safe side we'd better leave the vt as is, cause it can also be VT_CLSID
    //  if prop requestor allocated the guid (common practice).
    //  The propvariant in this translation routine is the prop requestor propvariant.
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    //
    //  Is the computer in the local domain?
    //
    const WCHAR * pwcsQueueName = pcMsmqObjXlateInfo->ObjectDN();
    WCHAR * pszDomainName = wcsstr(pwcsQueueName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;

    if ((pszDomainName != NULL) && !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
    {
        //
        //   try local DC
        //

        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,	
                &requestDsServerInternal,     // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                pchar,
                NULL,
                1,
                &prop,
                ppropvariant);         // output variant array
    }
    else
    {
        hr = g_pDS->GetObjectProperties(
            eGlobalCatalog,	
            &requestDsServerInternal,     // This routine is called from
                                    // DSADS:LookupNext or DSADS::Get..
                                    // impersonation, if required,
                                    // has already been performed.
            pchar,
            NULL,
            1,
            &prop,
            ppropvariant);         // output variant array
    }
    return LogHR(hr, s_FN, 30);
}

/*====================================================

MQADSpRetrieveQueueName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
      const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    build pathname
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
		    ASSERT(pwcsEndQueue != NULL);
			pwcsEndQueue++;
      }
      //
      //    Find machine name
      //
      const WCHAR * pwcsStartMachine = pwcsEndQueue + 2*(1 + x_CnPrefixLen)
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      const WCHAR * pwcsEndMachine = pwcsStartMachine;
      while ( *pwcsEndMachine != ',')
      {
   		    ASSERT(*pwcsEndMachine != NULL);
            pwcsEndMachine++;
      }
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcMsmqObjXlateInfo->GetDsProp(
                       MQ_Q_NAME_EXT,
                       ADSTYPE_CASE_EXACT_STRING,
                       VT_LPWSTR,
                       FALSE,
                       &varNameExt);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 40);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }

      ppropvariant->pwszVal = new WCHAR[2 + (pwcsEndMachine - pwcsStartMachine)
                                          + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      memcpy( ptmp, pwcsStartMachine, sizeof(WCHAR)*(pwcsEndMachine - pwcsStartMachine));
      ptmp += (pwcsEndMachine - pwcsStartMachine );
      *ptmp = PN_DELIMITER_C;
      ptmp++;

      //
      //    skip escape chars
      //
      while (pwcsStartQueue < pwcsEndQueue) 
      {
          if (*pwcsStartQueue != L'\\')
          {
            *ptmp = *pwcsStartQueue;
            ptmp++;
          }
          pwcsStartQueue++;

      }

      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}

/*====================================================

MQADSpRetrieveQueueDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueDNSName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
      const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    get the queue name from it, for the DNS name of
      //    the computer, retrieve dNSHostName
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
            pwcsEndQueue++;
      }
      const WCHAR * pwcsComputerName = pwcsEndQueue + 2 + x_CnPrefixLen
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcMsmqObjXlateInfo->GetDsProp(
                       MQ_Q_NAME_EXT,
                       ADSTYPE_CASE_EXACT_STRING,
                       VT_LPWSTR,
                       FALSE,
                       &varNameExt);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 50);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }
      //
      //    Read the computer DNS name
      //
      AP<WCHAR> pwcsDnsName;

      HRESULT hr =  MQADSpGetComputerDns(
                pwcsComputerName,
                &pwcsDnsName
                );

     if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
      {
          //
          //    The dNSHostName attribute doesn't have value
          //
          ppropvariant->vt = VT_EMPTY;
          return MQ_OK;
      }
      if (FAILED(hr))
      {
          return LogHR(hr, s_FN, 60);
      }
      DWORD lenComputer = wcslen(pwcsDnsName);

	  size_t BufferLength = 2 + lenComputer + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen;
      ppropvariant->pwszVal = new WCHAR[BufferLength];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      hr = StringCchCopy( ptmp, BufferLength, pwcsDnsName);
	  ASSERT(SUCCEEDED(hr));
      ptmp += lenComputer;
      *ptmp = PN_DELIMITER_C;
      ptmp++;
      memcpy( ptmp, pwcsStartQueue, sizeof(WCHAR)*(pwcsEndQueue - pwcsStartQueue));
      ptmp += (pwcsEndQueue - pwcsStartQueue );
      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}


/*====================================================

RetrieveSiteLink

Arguments:

Return Value:

=====================================================*/
static HRESULT RetrieveSiteLink(
           IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           )
{
    HRESULT hr;

    MQPROPVARIANT varSiteDn;
    varSiteDn.vt = VT_NULL;
    //
    //  Retrieve the DN of the site-link
    //
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   pwcsAttributeName,
                   ADSTYPE_DN_STRING,
                   VT_LPWSTR,
                   FALSE,
                   &varSiteDn);
    if (FAILED(hr))
    {
        //
        //  Site-link is a mandatory property, therefore if not found it is
        //  a problem
        //
        TrERROR(DS, "RetrieveSiteLink:GetDsProp(%ls)=%lx", pwcsAttributeName, hr);
        return LogHR(hr, s_FN, 70);
    }
    AP<WCHAR> pClean = varSiteDn.pwszVal;

    //
    //  Translate the DN of the site link into unique id
    //
    PROPID prop = PROPID_S_SITEID;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,           // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                varSiteDn.pwszVal,
                NULL,
                1,
                &prop,
                ppropvariant
                );
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) || 
         hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX))
    {
        //
        //  To enable admin to identify a state where one
        //  of the link's sites was deleted.
        //
        ppropvariant->vt = VT_EMPTY;
        ppropvariant->pwszVal = NULL;
        hr = MQ_OK;   // go on to next result
    }
    return LogHR(hr, s_FN, 80);
}

/*====================================================

MQADSpRetrieveLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkNeighbor1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    HRESULT hr2 = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                MQ_L_NEIGHBOR1_ATTRIBUTE,
                ppropvariant
                );
    return LogHR(hr2, s_FN, 90);
}

/*====================================================

MQADSpRetrieveLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkNeighbor2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    HRESULT hr2 = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                MQ_L_NEIGHBOR2_ATTRIBUTE,
                ppropvariant
                );
    return LogHR(hr2, s_FN, 100);
}

/*====================================================

MQADSpSetLinkNeighbor

Arguments:

Return Value:

=====================================================*/
static HRESULT MQADSpSetLinkNeighbor(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPVARIANT      *pNewPropVar)
{
    PROPID prop = PROPID_S_FULL_NAME;
    pNewPropVar->vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    HRESULT hr2 = g_pDS->GetObjectProperties(
                    eLocalDomainController,	
                    &requestDsServerInternal,     // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
 	                NULL,      // object name
                    pPropVar->puuid,      // unique id of object
                    1,
                    &prop,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 110);
}
/*====================================================

MQADSpCreateLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR1_DN;
    HRESULT hr2 = MQADSpSetLinkNeighbor(
                    pPropVar,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 120);
}

/*====================================================

MQADSpSetLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADSpCreateLinkNeighbor1(
                    pPropVar,
					pdwNewPropID,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 130);
}
/*====================================================

MQADSpCreateLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR2_DN;
    HRESULT hr2 = MQADSpSetLinkNeighbor(
                    pPropVar,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 140);
}

/*====================================================

MQADSpSetLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADSpCreateLinkNeighbor2(
                    pPropVar,
					pdwNewPropID,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 150);
}

static BOOL IsNeighborForeign(
           IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
           IN  LPCWSTR          pwcsAttributeName
           )
{
    //
    //  Check if a site-link neighbor is a foreign site
    //  BUGBUG : future improvment- to cache foreign site info.
    //
    //  Start with getting the neighbor's site-id
    //  
    PROPVARIANT varNeighbor;
    GUID    guidNeighbor;
    varNeighbor.vt = VT_CLSID;
    varNeighbor.puuid = &guidNeighbor;
    HRESULT hr;
    hr = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                pwcsAttributeName,
                &varNeighbor
                );

    if (FAILED(hr))
    {
        //
        //  Assume it is not a foreign site
        //
        return FALSE;
    }
    //
    //  Is it a foreign site?
    //
    PROPID prop = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,           // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                NULL,
                &guidNeighbor,
                1,
                &prop,
                &var
                );
    if (FAILED(hr))
    {
        //
        //  assume it is no a foreign site
        //
        return FALSE;
    }
    return (var.bVal > 0);
}


/*====================================================

MQADSpRetrieveLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkCost(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    //
    //  Is it a link to a foreign site, if yes increment the cost
    //  otherwise return the cost as is.
    //

    //
    //  First read the cost
    //
    HRESULT hr;
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   MQ_L_COST_ATTRIBUTE,
                   MQ_L_COST_ADSTYPE,
                   VT_UI4,
                   FALSE,
                   ppropvariant);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    if ( IsNeighborForeign(
           pcMsmqObjXlateInfo,
           MQ_L_NEIGHBOR1_ATTRIBUTE))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    if ( IsNeighborForeign(
           pcMsmqObjXlateInfo,
           MQ_L_NEIGHBOR2_ATTRIBUTE))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    return MQ_OK;
}

/*====================================================

MQADpRetrieveLinkGates

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    //
    //  Is it a link to a foreign site, if yes increment the cost
    //  otherwise return the cost as is.
    //

    //
    //  First read the cost
    //
    CMQVariant varLinkGatesDN;
    HRESULT hr;
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   MQ_L_SITEGATES_ATTRIBUTE,
                   MQ_L_SITEGATES_ADSTYPE,
                   VT_VECTOR|VT_LPWSTR,
                   TRUE,
                   varLinkGatesDN.CastToStruct());
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
      ppropvariant->cauuid.pElems = NULL;
      ppropvariant->cauuid.cElems = 0;
      ppropvariant->vt = VT_CLSID|VT_VECTOR;
      return MQ_OK;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }
    //
    //  Translate the gates DNs to gates-ids
    //
    hr =  MQADSpTranslateGateDn2Id(
                varLinkGatesDN.CastToStruct(),
                &ppropvariant->cauuid.pElems,
                &ppropvariant->cauuid.cElems
                );
    if (SUCCEEDED(hr))
    {
            ppropvariant->vt = VT_CLSID|VT_VECTOR;
    }
    return LogHR(hr, s_FN, 190);
}

/*====================================================

MQADSpCreateLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    *pdwNewPropID = PROPID_L_ACTUAL_COST;
    *pNewPropVar = *pPropVar;
    return MQ_OK;
}

/*====================================================

MQADSpSetLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    UNREFERENCED_PARAMETER( pAdsObj);
	HRESULT hr2 = MQADSpCreateLinkCost(
				pPropVar,
				pdwNewPropID,
				pNewPropVar);
    return LogHR(hr2, s_FN, 170);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\usercert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    usercert.h

Abstract:
    Classes to manipulate use certificate blob


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __USERCERT_H__
#define __USERCERT_H__
//-----------------------------------------
// User object : certificate attribute structure
//
// In MSMQ each user has a certificate per machine,
// In NT5 there is one user object per user.
// Therefore msmq-certificate property in NT5 will contain
// multiple values
//-----------------------------------------


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CUserCert {
public:

    inline CUserCert( const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert);

	inline CUserCert();
    inline CUserCert( const CUserCert& other);
    static ULONG CalcSize(
            IN DWORD dwCertLen);

    inline HRESULT CopyIntoBlob( OUT MQPROPVARIANT * pvar) const;

    inline BOOL DoesDigestMatch(
                IN  const GUID *       pguidDigest) const;

    inline DWORD GetSize() const;

    inline BYTE * MarshaleIntoBuffer(
                    IN BYTE * pbBuffer);

private:

    GUID           m_guidDigest;
    GUID           m_guidId;
    DWORD          m_dwCertLength;
    BYTE           m_Cert[0];       // variable length
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


inline CUserCert::CUserCert(
                      const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert)
{
    memcpy(&m_guidDigest, &guidDigest, sizeof(GUID));
    memcpy(&m_guidId, &guidId, sizeof(GUID));
    memcpy(&m_dwCertLength, &dwCertLength, sizeof(DWORD));
    memcpy(m_Cert, pCert, dwCertLength);
}

inline CUserCert::CUserCert(
                  const CUserCert& other)
{
    memcpy(&m_guidDigest, &other.m_guidDigest, sizeof(GUID));
    memcpy(&m_guidId, &other.m_guidId, sizeof(GUID));
    memcpy(&m_dwCertLength, &other.m_dwCertLength, sizeof(DWORD));
    memcpy(m_Cert, &other.m_Cert, m_dwCertLength);
}

inline CUserCert::CUserCert()
{
}

inline HRESULT CUserCert::CopyIntoBlob( OUT MQPROPVARIANT * pvar) const
{
    if ( pvar->vt != VT_NULL)
    {
        return(MQ_ERROR);
    }
    if ( m_dwCertLength == 0)
    {
        return(MQ_ERROR);
    }
    //
    //  allocate memory
    //
    pvar->blob.pBlobData = new BYTE[ m_dwCertLength];
    memcpy( pvar->blob.pBlobData, &m_Cert,  m_dwCertLength);
    pvar->blob.cbSize =  m_dwCertLength;
    pvar->vt = VT_BLOB;
    return( MQ_OK);
}

inline BOOL CUserCert::DoesDigestMatch(
                 IN  const GUID *  pguidDigest) const
{
    return(memcmp(&m_guidDigest, pguidDigest, sizeof(GUID)) == 0);
}

inline DWORD CUserCert::GetSize() const
{
    return( sizeof( CUserCert) +  m_dwCertLength);
}

inline ULONG CUserCert::CalcSize(
                   IN DWORD dwCertLen)
{
    return( sizeof(CUserCert) + dwCertLen);
}

inline BYTE * CUserCert::MarshaleIntoBuffer(
                         IN BYTE * pbBuffer)
{
    BYTE * pNextToFill = pbBuffer;
    memcpy( pNextToFill, &m_guidDigest, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_guidId, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_dwCertLength, sizeof(DWORD));
    pNextToFill += sizeof(DWORD);
    memcpy( pNextToFill, &m_Cert, m_dwCertLength);
    pNextToFill += m_dwCertLength;
    return( pNextToFill);

}


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CUserCertBlob {
public:
    inline CUserCertBlob(
                    IN const CUserCert *     pUserCert);
    inline CUserCertBlob();
    static ULONG CalcSize( void);

    inline HRESULT GetUserCert( IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const;

    inline DWORD GetNumberOfCerts();

    inline HRESULT GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          );

    inline void MarshaleIntoBuffer(
                  IN BYTE * pbBuffer);
    inline void IncrementNumCertificates();

    inline HRESULT RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize);

private:

    DWORD           m_dwNumCert;
    CUserCert       m_userCert;
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCertBlob::CUserCertBlob(
              IN const CUserCert *     pUserCert):
              m_userCert(*pUserCert)
{
    m_dwNumCert = 1;
}

inline CUserCertBlob::CUserCertBlob()
{
}

inline HRESULT CUserCertBlob::GetUserCert(
                         IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const
{
    if ( m_dwNumCert == 0)
    {
        return(MQ_ERROR);
    }
    const CUserCert * pUserCert = &m_userCert;
    for (DWORD i = 0; i < m_dwNumCert; i++)
    {
        if (pUserCert->DoesDigestMatch( pguidDigest))
        {
            *ppUserCert = pUserCert;
            return( MQ_OK);
        }
        //
        //  Move to next certificate
        //
        BYTE *pBuf = (BYTE*) pUserCert ;
        pBuf += pUserCert->GetSize();
        pUserCert = (const CUserCert*) pBuf ;
    }
    //
    //  No match digest in the user cert blob
    //
    return(MQ_ERROR);

}
inline DWORD CUserCertBlob::GetNumberOfCerts()
{
    return( m_dwNumCert);
}

inline HRESULT CUserCertBlob::GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          )
{
    HRESULT hr;

    if ( dwCertificateNumber > m_dwNumCert)
    {
        return(MQ_ERROR);
    }
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Move to certificate number dwCertificateNumber
    //
    for (DWORD i = 0; i < dwCertificateNumber; i++)
    {
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    pvar->vt = VT_NULL;
    hr = pUserCert->CopyIntoBlob(
                            pvar
                            );
    return(hr);
}

inline ULONG CUserCertBlob::CalcSize( void)
{
    //
    //  Just the size of CUserCertBlob without
    //  the size of m_userCert
    //
    return( sizeof(CUserCertBlob) - CUserCert::CalcSize(0));
}

inline void CUserCertBlob::MarshaleIntoBuffer(
                  IN BYTE * pbBuffer)
{
    ASSERT( m_dwNumCert == 1);
    memcpy( pbBuffer, &m_dwNumCert, sizeof(DWORD));
    m_userCert.MarshaleIntoBuffer( pbBuffer + sizeof(DWORD));

}
inline void CUserCertBlob::IncrementNumCertificates()
{
    m_dwNumCert++;
}

inline HRESULT CUserCertBlob::RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize)
{
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Find the certificate to be removed according to its digest
    //
    BOOL fFoundCertificate = FALSE;
    for ( DWORD i = 0; i < m_dwNumCert; i++)
    {
        if ( pUserCert->DoesDigestMatch( pguidDigest))
        {
            fFoundCertificate = TRUE;
            break;
        }
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    if ( !fFoundCertificate)
    {
        return MQDS_OBJECT_NOT_FOUND;
    }
    //
    //  copy buffer ( i.e. copy the remaining certificates over the removed one)
    //
    DWORD dwCertSize =  pUserCert->GetSize();
    DWORD_PTR dwSizeToCopy =  dwTotalSize -
                         (((const unsigned char *)pUserCert) - ((const unsigned char *)&m_userCert))
                         - dwCertSize - sizeof(m_dwNumCert);
    if ( dwSizeToCopy)
    {
        memcpy( (unsigned char *)pUserCert,
                (unsigned char *)pUserCert + dwCertSize,
                dwSizeToCopy);
    }
    *pdwCertSize = dwCertSize;
    m_dwNumCert--;
    return(MQ_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\tranrout.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.h

Abstract:

    Translation routines for properties not in NT5 DS

Author:

    ronit hartmann ( ronith)

--*/
#ifndef __tranrout_h__
#define __tranrout_h__


HRESULT WINAPI MQADSpRetrieveEnterpriseName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveEnterprisePEC(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteSignPK(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteInterval1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteInterval2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);



HRESULT WINAPI MQADSpRetrieveQueueQMid(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);


HRESULT WINAPI MQADSpRetrieveQueueName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveQueueDNSName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveNothing(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkNeighbor1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkNeighbor2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpRetrieveLinkCost(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\utils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsutils.h

Abstract:
	General declarations and utilities for MqAds project

Author:
    AlexDad

--*/


#ifndef __UTILS_H__
#define __UTILS_H__

//-----------------------------
//  Misc routines
//-----------------------------


// Translation from MQPropValue to OLE Variant
extern HRESULT MqVal2Variant(
      OUT VARIANT *pvProp, 
      IN  const MQPROPVARIANT *pPropVar,
      ADSTYPE adsType);

// Translation from MqPropValue to wide string
extern HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal); 

// Translation from OLE variant to MQPropValue
extern HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT *   pMqVar,
      IN   VARIANT *         pOleVar,
      IN   const ADSTYPE     adstype,
      IN   const VARTYPE     vartype
      );

// Translation from MQPropValue to ADSI Variant
extern HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue, 
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc);

// Translation from ADSI Value to MQPropValue
extern HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget, 
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue);

extern void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\utils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsutils.cpp

Abstract:

    Implementation of utilities used in MQADS dll.

Author:

    Alexander Dadiomov (AlexDad)

--*/
#include "ds_stdh.h"
#include "iads.h"
#include "dsutils.h"
#include "adstempl.h"
#include "autorel.h"
#include "mqsec.h"
#include "_secutil.h"
#include <math.h>
#include "_propvar.h"
#include "utils.h"
#include <strsafe.h>
#include "utils.tmh"

static WCHAR *s_FN=L"mqdscore/utils";

#define CHECK_ALLOCATION(p, point)              \
    if (p == NULL)                              \
    {                                           \
        LogIllegalPoint(s_FN, point);           \
        return MQ_ERROR_INSUFFICIENT_RESOURCES; \
    }

//-------------------------------------------
// TimeFromSystemTime:
//
//  This routine convertes SYSTEMTIME structure into time_t
//-------------------------------------------
static inline time_t TimeFromSystemTime(const SYSTEMTIME * pstTime)
{
	SYSTEMTIME LocalTime;

	SystemTimeToTzSpecificLocalTime (NULL, (LPSYSTEMTIME)pstTime, &LocalTime);

	tm tmTime;
        //
        // year in struct tm starts from 1900
        //
	tmTime.tm_year  = LocalTime.wYear - 1900;
        //
        // month in struct tm is zero based 0-11 (in SYSTEMTIME it is 1-12)
        //
	tmTime.tm_mon   = LocalTime.wMonth - 1;
	tmTime.tm_mday  = LocalTime.wDay;
	tmTime.tm_hour  = LocalTime.wHour; 
	tmTime.tm_min   = LocalTime.wMinute;
	tmTime.tm_sec   = LocalTime.wSecond; 
        //
        // time is in UTC, no need to adjust daylight savings time
        //
	tmTime.tm_isdst = 0;
        return mktime(&tmTime);
}

//-------------------------------------------
// TimeFromOleDate:
//
//  This routine convertes DATE into time_t
//-------------------------------------------
static BOOL TimeFromOleDate(DATE dtSrc, time_t *ptime)
{
	SYSTEMTIME stTime;
	if (!VariantTimeToSystemTime(dtSrc, &stTime))
	{
		return LogBOOL(FALSE, s_FN, 200);
	}
        *ptime = TimeFromSystemTime(&stTime);
	return TRUE;
}

//------------------------------------------------------------
// SetWStringIntoAdsiValue: puts wide string into ADSValue according to ADSType
//------------------------------------------------------------
static HRESULT SetWStringIntoAdsiValue(
   ADSTYPE adsType,
   PADSVALUE pADsValue,
   LPWSTR wsz,
   PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul      = (wcslen(wsz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 10);
        CopyMemory(pwszTmp,  wsz,  ul);
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 210);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 220);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}

//------------------------------------------------------------
// SetStringIntoAdsiValue: puts string into ADSValue according to ADSType
//------------------------------------------------------------
static HRESULT SetStringIntoAdsiValue(
    ADSTYPE adsType,
    PADSVALUE pADsValue,
    LPSTR sz,
    PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul = (strlen(sz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 20);
        mbstowcs(pwszTmp, sz, ul/sizeof(WCHAR) );
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 230);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 240);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}



//------------------------------------------------------------
//    MqVal2Variant()
//    Translates MQPropVal into OLE Variant value
//------------------------------------------------------------
HRESULT MqVal2Variant(
      OUT VARIANT       *pOleVar,
      IN  const MQPROPVARIANT *pMqVar,
      ADSTYPE           adstype)
{
    LPWSTR wsz;
    ULONG  ul;
    HRESULT hr;

    switch (pMqVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pOleVar->vt = VT_BOOL;
#pragma warning(disable: 4310)
                pOleVar->boolVal = (pMqVar->bVal ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310)
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pOleVar->vt = VT_I4;
                pOleVar->lVal = pMqVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 250);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 260);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 270);
           }
           break;

       case(VT_BOOL):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_BOOL;
               pOleVar->boolVal = pMqVar->boolVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 280);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->lVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 290);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               CopyMemory(&pOleVar->lVal, &pMqVar->ulVal, sizeof(ULONG));
           }
           else if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //pOleVar->vt = VT_DATE;
               //CopyMemory(&pOleVar->date, &pMqVar->ulVal, sizeof(ULONG));
               //
               // BUGBUG - The code above was wrong, We can't assign ULONG into OLE Date.
               // Currently we never get to here because all of our time props ar read-only,
               // but this needs to be changed when we add a writable time property
               // to the the DS. (RaananH)
               // 
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 300);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 310);
           }
           break;

       case(VT_DATE):
		   ASSERT (("We should not put time values into active directory until we know the time zone",0));
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               pOleVar->vt = VT_DATE;
               pOleVar->date = pMqVar->date;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 320);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->bstrVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 330);
           }
           break;

       case(VT_LPSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               ul = strlen(pMqVar->pszVal) + 1;
               wsz = new WCHAR[ul * sizeof(WCHAR)];
               mbstowcs( wsz, pMqVar->pszVal, ul );
               pOleVar->bstrVal = SysAllocString(wsz);
               delete [] wsz;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 340);
           }
           break;

       case(VT_LPWSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->pwszVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 350);
           }
           break;

       case(VT_LPWSTR|VT_VECTOR):
           if (adstype ==  ADSTYPE_DN_STRING)
           {

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->calpwstr.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 30);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with strings
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->calpwstr.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;
                   pvarTmp->bstrVal = BS_SysAllocString(pMqVar->calpwstr.pElems[lTmp]);
                   pvarTmp->vt = VT_BSTR;

                   //
                   // Add to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2000);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 360);
           }
           break;

       case(VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
			   pOleVar->vt = VT_ARRAY | VT_UI1;
			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			   CHECK_ALLOCATION(pOleVar->parray, 40);
				
			   for (long i=0; i<16; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    ((unsigned char *)pMqVar->puuid)+i);
                   if (FAILED(hr))
                   {
                       return LogHR(hr, s_FN, 2010);
                   }
			   }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 370);
           }
           break;

       case(VT_BLOB):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT( pMqVar->blob.cbSize > 0);
			   pOleVar->vt = VT_ARRAY | VT_UI1;
               DWORD len = pMqVar->blob.cbSize;

			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, len);
			   CHECK_ALLOCATION(pOleVar->parray, 50);
               ASSERT( ((long)len) > 0);
				
			   for (long i=0; i<(long)len; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    pMqVar->blob.pBlobData+i);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2020);
                   }
               }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 380);
           }
           break;

       case(VT_VECTOR|VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
                //
                //  Can't set array size to be zero ( ADSI limitation)
                //
                if ( pMqVar->cauuid.cElems == 0)
                {
                    return LogHR(MQ_ERROR, s_FN, 390);
                }

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->cauuid.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 60);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with GUIDs ( each GUID is a safe array)
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->cauuid.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;

			       pvarTmp->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			       CHECK_ALLOCATION(pvarTmp->parray, 70);
			       pvarTmp->vt = VT_ARRAY | VT_UI1;

			       for (long i=0; i<16; i++)
			       {
				       hr = SafeArrayPutElement(
					            pvarTmp->parray,
						        &i,
						        ((unsigned char *)(pMqVar->cauuid.pElems + lTmp))+i);
                       if (FAILED(hr))
                       {
                            return LogHR(hr, s_FN, 2030);
                       }
			       }
                   //
                   // Add safearray variant to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2040);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 400);
           }
           break;

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 410);
    }
    return MQ_OK;
}


HRESULT ArrayOfLpwstr2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 420);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<LPWSTR> pElems = new LPWSTR[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 430);
           }

           //
           // translate the variant (RECURSION)
           //
           PROPVARIANT var;
           hr = Variant2MqVal(&var, &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 440);
           }

           //
           // Fill element in array of results
           //
           pElems[ulTmp] = var.pwszVal;
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_LPWSTR;
       pMqVar->calpwstr.cElems = cElems;
       pMqVar->calpwstr.pElems = pElems.detach();
       return(MQ_OK);
}

HRESULT ArrayOfClsid2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 450);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<GUID> pElems = new GUID[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 460);
               return MQ_ERROR;
           }

           //
           // translate the variant (RECURSION)
           //
           CMQVariant MQVarTmp;
           hr = Variant2MqVal(MQVarTmp.CastToStruct(), &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 470);
               return MQ_ERROR;
           }

           //
           // Fill element in array of results
           //
           pElems[ulTmp] = *(MQVarTmp.GetCLSID());
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_CLSID;
       pMqVar->cauuid.cElems = cElems;
       pMqVar->cauuid.pElems = pElems.detach();
       return(MQ_OK);
}


//------------------------------------------------------------
//    Variant2MqVal()
//    Translates OLE Variant into MQPropVal value
//------------------------------------------------------------
HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT * pMqVar,
      IN   VARIANT  *      pOleVar,
      IN const ADSTYPE     adstype,
      IN const VARTYPE     vartype)
{

    switch (pOleVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pMqVar->vt = VT_I4;
                pMqVar->lVal = pOleVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 480);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 490);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               if ( vartype == VT_I2)
               {
                   pMqVar->vt = VT_I2;
                   pMqVar->iVal = pOleVar->iVal;
               }
               else if ( vartype == VT_UI2)
               {
                   pMqVar->vt = VT_UI2;
                   pMqVar->iVal = pOleVar->uiVal;
               }
               else
               {
                   ASSERT(( vartype == VT_I4) || (vartype == VT_UI4));
                   pMqVar->vt = vartype;
                   pMqVar->lVal = pOleVar->lVal;
               }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 500);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 510);
           }
           break;

       case(VT_BOOL):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 520);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               CopyMemory(&pMqVar->lVal, &pOleVar->ulVal, sizeof(ULONG));
           }
           else if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //pMqVar->vt = VT_DATE;
               //CopyMemory(&pMqVar->date, &pOleVar->ulVal, sizeof(ULONG));
               //
               // BUGBUG - The code above is wrong, We can't assign ULONG into OLE Date.
               // Currently we never get to here because all of our time props ar read-only,
               // but this needs to be changed when we add a writable time property
               // to the the DS. (RaananH)
               // 
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 530);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 540);
           }
           break;

       case(VT_DATE):
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //
               //   convert date->time_t
               //
               time_t tTime;
               if (!TimeFromOleDate(pOleVar->date, &tTime))
               {
                   return LogHR(MQ_ERROR, s_FN, 550);
               }
               pMqVar->lVal = INT_PTR_TO_INT(tTime); //BUGBUG bug year 2038
               pMqVar->vt = VT_I4;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 560);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pMqVar->vt = VT_LPWSTR;
			   size_t len = 1 + wcslen(pOleVar->bstrVal);
               pMqVar->pwszVal = new WCHAR[len];
               HRESULT hr = StringCchCopy(pMqVar->pwszVal, len, pOleVar->bstrVal);
			   ASSERT(SUCCEEDED(hr));
			   DBG_USED(hr);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 570);
           }
           break;

       case(VT_ARRAY):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT(0);
               //pMqVar->vt = VT_BSTR;
               //pMqVar->bstrVal = SysAllocStringByteLen(NULL, pOleVar->parray->...);
               //CopyMemory(pMqVar->bstrVal, pOleVar->parray...ptr.., pOleVar->parray...size);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 580);
           }
           break;

       case(VT_ARRAY|VT_UI1):
           if (adstype == ADSTYPE_OCTET_STRING)
           {
                ASSERT(SafeArrayGetDim( pOleVar->parray) == 1);
                LONG    lUbound;
                LONG    lLbound;

                SafeArrayGetUBound(pOleVar->parray, 1, &lUbound);
                SafeArrayGetLBound(pOleVar->parray, 1, &lLbound);

                LONG len = lUbound - lLbound + 1;
                unsigned char * puc = NULL;
                if ( vartype == VT_CLSID)
                {
                    ASSERT( len == sizeof(GUID));
                    //
                    //  This is a special case where we do not necessarily allocate the memory for the guid
                    //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
                    //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
                    //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
                    //
                    if (pMqVar->vt != VT_CLSID)
                    {
                        ASSERT(((pMqVar->vt == VT_NULL) || (pMqVar->vt == VT_EMPTY)));
                        pMqVar->puuid = new GUID;
                        pMqVar->vt = VT_CLSID;
                    }
                    else if ( pMqVar->puuid == NULL)
                    {
                        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 590);
                    }
                    puc = ( unsigned char *)pMqVar->puuid;
                }
                else if (vartype == VT_BLOB)
                {
                    pMqVar->caub.cElems = len;
                    pMqVar->caub.pElems = new unsigned char[ len];
                    puc = pMqVar->caub.pElems;
                    pMqVar->vt = VT_BLOB;
                }
                ASSERT( puc != NULL);
                for ( long i = 0; i < len; i++)
                {
                    SafeArrayGetElement(pOleVar->parray, &i, puc + i);

                }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 600);
           }
           break;
       case(VT_ARRAY|VT_VARIANT):
           {
               //
               // this is a multi-valued property, each variant is one of the values.
               // target must be a vector.
               //
               if (!(vartype & VT_VECTOR))
               {
                   ASSERT(0);
                   return LogHR(MQ_ERROR, s_FN, 610);
               }

               //
               // get target type of each element
               //
               VARTYPE vartypeElement;
               vartypeElement = vartype;
               vartypeElement &= (~VT_VECTOR);

               if (( vartypeElement == VT_CLSID) &&
                   (adstype == ADSTYPE_OCTET_STRING))
               {
                    HRESULT hr2 = ArrayOfClsid2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 620);
              }

              if (( vartypeElement == VT_LPWSTR) &&
                   (adstype == ADSTYPE_DN_STRING))
              {
                    HRESULT hr2 = ArrayOfLpwstr2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 630);
              }

              //
              // currently we support only VT_CLSID  and VT_LPWSTR
              // here we may need to check for other types when we support them
              //
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 640);
              break;
           }

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 650);
    }
    return MQ_OK;
}


//------------------------------------------------------------
//    MqVal2AdsiVal()
//    Translates MQPropVal into ADSI value
//------------------------------------------------------------
HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue,
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc)
{
    HRESULT hr;
    ULONG   i;
    PADSVALUE pADsValue = NULL;

    // Allocate ADS value  for a single case
    if (!(pPropVar->vt & VT_VECTOR))
    {
          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 80);
          pADsValue->dwType = adsType;
          *pdwNumValues     = 1;
          *ppADsValue       = pADsValue;
    }

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          if (adsType != ADSTYPE_INTEGER &&
              adsType != ADSTYPE_BOOLEAN )
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 660);
          }
          pADsValue->Integer = pPropVar->bVal;
          break;

      case(VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 670);
          }
          pADsValue->Integer = pPropVar->iVal;
          break;

      case(VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 680);
          }
          pADsValue->Integer = pPropVar->uiVal;
          break;

      case(VT_BOOL):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 700);
          }
          pADsValue->Boolean = (pPropVar->boolVal ? TRUE : FALSE);
          //BUGBUG: is it the same representation?
          break;

      case(VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 710);
          }
          // BUGBUG Signed long may loose sign while copied to DWORD
          pADsValue->Integer = pPropVar->lVal; // may loose sign here!
          break;

      case(VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 720);
          }
          pADsValue->Integer = pPropVar->ulVal;
          break;

      case(VT_HRESULT):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 730);
          }
          pADsValue->Integer = pPropVar->scode;
          break;

      case(VT_DATE):
          if (adsType != ADSTYPE_UTC_TIME)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 740);
          }
          if (!VariantTimeToSystemTime(pPropVar->date, &pADsValue->UTCTime))
          {
               ASSERT(0);
               pADsValue->dwType = ADSTYPE_INVALID;
               return LogHR(MQ_ERROR, s_FN, 750);
          }
          break;

      case(VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 760);
          }
          pADsValue->OctetString.dwLength = sizeof(GUID);
          pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 90);
          CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->puuid,  sizeof(CLSID));
          break;

      case(VT_BLOB):
          if (adsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
          {
              pADsValue->SecurityDescriptor.dwLength = pPropVar->blob.cbSize;
              pADsValue->SecurityDescriptor.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->SecurityDescriptor.lpValue, 100);
              CopyMemory(pADsValue->SecurityDescriptor.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else if (adsType == ADSTYPE_OCTET_STRING)
          {
              pADsValue->OctetString.dwLength = pPropVar->blob.cbSize;
              pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 110);
              CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 770);
          }
          break;

      case(VT_BSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->bstrVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 780);
          }
          break;

      case(VT_LPSTR):
          hr = SetStringIntoAdsiValue(adsType, pADsValue, pPropVar->pszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 790);
          }
          break;

      case(VT_LPWSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->pwszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 800);
          }
          break;

      case(VT_VECTOR | VT_UI1):
          switch(adsType)
          {
                  case ADSTYPE_OCTET_STRING:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 120);
                      pADsValue->dwType = adsType;

                      pADsValue->OctetString.dwLength = pPropVar->caub.cElems;
                      pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 130);
                      CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->caub.pElems,  pPropVar->caub.cElems);

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = 1;
                      break;

                  case ADSTYPE_INTEGER:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 140);

                      for (i=0; i<pPropVar->caub.cElems; i++)
                      {
                          pADsValue[i].Integer = pPropVar->caub.pElems[i];
                          pADsValue[i].dwType = adsType;
                      }

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = pPropVar->caub.cElems;
                      break;

                  default:
                      ASSERT(0);
                      return LogHR(MQ_ERROR, s_FN, 810);
          }

          break;

      case(VT_VECTOR | VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 820);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cai.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 150)
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cai.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->cai.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cai.cElems;
          break;

      case(VT_VECTOR | VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 830);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caui.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 160)

          for (i=0; i<pPropVar->caui.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caui.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caui.cElems;
          break;

      case(VT_VECTOR | VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 840);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cal.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 170);

          for (i=0; i<pPropVar->cal.cElems; i++)
          {
              // BUGBUG:  may loose sign
              pADsValue[i].Integer = pPropVar->cal.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cal.cElems;
          break;

      case(VT_VECTOR | VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 850);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caul.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 180);

          for (i=0; i<pPropVar->caul.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caul.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caul.cElems;
          break;

      case(VT_VECTOR | VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 860);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cauuid.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 190);
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cauuid.cElems; i++)
          {
              pADsValue[i].OctetString.dwLength = sizeof(GUID);
              pADsValue[i].dwType = adsType;
              pADsValue[i].OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
              CHECK_ALLOCATION(pADsValue[i].OctetString.lpValue, 200);
              CopyMemory(pADsValue[i].OctetString.lpValue,  &pPropVar->cauuid.pElems[i],  sizeof(GUID));
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cauuid.cElems;
          break;

      case(VT_VECTOR | VT_BSTR):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 870);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cabstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 210);


          for (i=0; i<pPropVar->cabstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->cabstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(MQ_ERROR, s_FN, 880);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cabstr.cElems;
          break;

      case(VT_VECTOR | VT_LPWSTR):
          if (adsType != ADSTYPE_DN_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 890);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->calpwstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 220);

          for (i=0; i<pPropVar->calpwstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->calpwstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(hr, s_FN, 900);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->calpwstr.cElems;
          break;

      case(VT_VARIANT):
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          // NIY
          break;

    case(VT_EMPTY):
    case VT_NULL:

      default:
        ASSERT(0);
        pADsValue->dwType = ADSTYPE_INVALID;
        return LogHR(MQ_ERROR, s_FN, 910);
    }

    return MQ_OK;
}
const WCHAR x_True[] = L"TRUE";
const DWORD x_TrueLength = (sizeof( x_True) /sizeof(WCHAR)) -1;
const WCHAR x_False[] = L"FALSE";
const DWORD x_FalseLength = (sizeof( x_False) /sizeof(WCHAR)) -1;
const DWORD x_NumberLength = 256;
const WCHAR x_Null[] = L"\\00";
const DWORD x_NullLength = (sizeof( x_Null)/sizeof(WCHAR)) -1;

static void StringToSearchFilter(
      IN  MQPROPVARIANT *pPropVar,
      OUT LPWSTR *       ppwszVal
)
/*++

Routine Description:
    Translate a string variant restirction to a LDAP search filter
    according to RFC 2254

Arguments:
    pPropVar    : varaint containing the string
    ppwszVal    : output, the search filter

Return Value:
    none

--*/
{
    //
    //  NUL string should be replace with \00
    //
    if ( wcslen( pPropVar->pwszVal) == 0)
    {
	  size_t len = x_NullLength + 1;
      *ppwszVal = new WCHAR[len];
      HRESULT hr = StringCchCopy(*ppwszVal, len, x_Null);
	  ASSERT(SUCCEEDED(hr));
	  DBG_USED(hr);
      return;
    }
    DWORD len = wcslen( pPropVar->pwszVal);
    *ppwszVal = new WCHAR[ 3 * len + 1];
    WCHAR * pNextChar = *ppwszVal;
    //
    //  Chars *,(,),\ should be escaped in a special way
    //
    for ( DWORD i = 0; i < len; i++)
    {
        switch( pPropVar->pwszVal[i])
        {
        case L'*':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'a';
            break;
        case L'(':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'8';
            break;
        case L')':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'9';
            break;
        case '\\':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'5';
            *pNextChar++ = L'c';
            break;
        default:
            *pNextChar++ = pPropVar->pwszVal[i];
            break;
        }
    }

    *pNextChar = L'\0';
    return;
}
//------------------------------------------------------------
//    MqVal2String()
//    Translates MQPropVal into string
//------------------------------------------------------------
HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal)
{
    HRESULT hr;

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          {
              if ( adsType == ADSTYPE_BOOLEAN)
              {
                  if ( pPropVar->bVal)
                  {
                      *ppwszVal = new WCHAR[x_TrueLength + 1];
                      hr = StringCchCopy(*ppwszVal, x_TrueLength + 1, x_True);
					  ASSERT(SUCCEEDED(hr));
                  }
                  else
                  {
                      *ppwszVal = new WCHAR[x_FalseLength + 1];
                      hr = StringCchCopy(*ppwszVal, x_FalseLength + 1, x_False);
					  ASSERT(SUCCEEDED(hr));
                  }
              }
              else
              {
                  *ppwszVal = new WCHAR[x_NumberLength + 1];
				  hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->bVal);
				  ASSERT(SUCCEEDED(hr));
              }
          }
          break;

      case(VT_I2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->iVal);
		  ASSERT(SUCCEEDED(hr));
          break;

      case(VT_UI2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->uiVal);
		  ASSERT(SUCCEEDED(hr));
          break;

      case(VT_BOOL):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->boolVal);
		  ASSERT(SUCCEEDED(hr));
          break;

      case(VT_I4):
		  if ( adsType == ADSTYPE_INTEGER)
		  {
			  *ppwszVal = new WCHAR[ x_NumberLength + 1];
			  hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->lVal);
			  ASSERT(SUCCEEDED(hr));
		  }
		  else if ( adsType == ADSTYPE_UTC_TIME)
		  {
			  struct tm  * ptmTime;
			  time_t tTime = pPropVar->lVal; //BUGBUG bug year 2038
			  ptmTime = gmtime( &tTime);
			  if ( ptmTime == NULL)
			  {
                  return LogHR(MQ_ERROR, s_FN, 920);
			  }
			  *ppwszVal = new WCHAR[ 20];
			  //
			  // the format should be
			  //  990513102200Z i.e 13.5.99 10:22:00
			  //
			  hr = StringCchPrintf(
					*ppwszVal,
					20,
					L"%02d%02d%02d%02d%02d%02dZ",
					(ptmTime->tm_year + 1900) % 100,   //year in struct tm starts from 1900
					ptmTime->tm_mon + 1,			   //month in struct tm starts from 0
					ptmTime->tm_mday,
					ptmTime->tm_hour ,			       //hour in struct tm starts from 0
					ptmTime->tm_min ,			       //minute in struct tm starts from 0
					ptmTime->tm_sec                    //second in struct tm starts from 0
					);
			  ASSERT(SUCCEEDED(hr));
		  }
		  else
		  {
			  ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 930);
		  }
          break;

      case(VT_UI4):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->ulVal);
		  ASSERT(SUCCEEDED(hr));
          break;

      case(VT_HRESULT):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          hr = StringCchPrintf(*ppwszVal, x_NumberLength + 1, L"%d", pPropVar->scode);
		  ASSERT(SUCCEEDED(hr));
          break;

      case(VT_CLSID):
          {
              ADsFree  pwcsGuid;
              hr = ADsEncodeBinaryData(
                    (unsigned char *)pPropVar->puuid,
                    sizeof(GUID),
                    &pwcsGuid
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 940);
              }
			  size_t len = wcslen( pwcsGuid) + 1;
              *ppwszVal = new WCHAR[len];
              StringCchCopy(*ppwszVal, len, pwcsGuid);
          }
          break;

      case(VT_BLOB):
          {

              ADsFree  pwcsBlob;
              hr = ADsEncodeBinaryData(
                    pPropVar->blob.pBlobData,
                    pPropVar->blob.cbSize,
                    &pwcsBlob
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 950);
              }
			  size_t len = wcslen( pwcsBlob) + 1;
              *ppwszVal = new WCHAR[len];
              StringCchCopy(*ppwszVal, len, pwcsBlob);
          }

          break;

      case(VT_LPWSTR):
          StringToSearchFilter(
                    pPropVar,
                    ppwszVal
                    );
          break;


      default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 960);
    }

    return MQ_OK;
}

static LPWSTR GetWStringFromAdsiValue(
      IN  ADSTYPE       AdsType,
      IN  PADSVALUE     pADsValue)
{
    switch(AdsType)
    {
    case ADSTYPE_DN_STRING:
        return pADsValue->DNString;

    case ADSTYPE_CASE_EXACT_STRING:
        return pADsValue->CaseExactString;

    case ADSTYPE_CASE_IGNORE_STRING:
        return pADsValue->CaseIgnoreString;

    case ADSTYPE_PRINTABLE_STRING:
        return pADsValue->PrintableString;

    case ADSTYPE_NUMERIC_STRING:
        return pADsValue->NumericString;

    case ADSTYPE_OBJECT_CLASS:
        return pADsValue->ClassName;

    default:
        ASSERT(0);
        return NULL;
    }
}

static HRESULT AdsiStringVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{
    LPWSTR pwsz;

    if (vtTarget == VT_LPWSTR)
    {
        if (dwNumValues == 1)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, pADsValue);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 970);
            }

            pPropVar->vt      = VT_LPWSTR;
			size_t len = wcslen(pwsz) + 1; 
            pPropVar->pwszVal = new WCHAR[len];
            StringCchCopy(pPropVar->pwszVal, len, pwsz);
			return(MQ_OK);
        }
		else
		{
			ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 980);
		}
	}
    else if (vtTarget == (VT_LPWSTR | VT_VECTOR))
    {
        pPropVar->vt    = VT_LPWSTR | VT_VECTOR;
        AP<LPWSTR> pElems = new LPWSTR[dwNumValues];
        CWcsArray pClean( dwNumValues,  pElems);
        for(DWORD i = 0; i < dwNumValues; i++)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, &pADsValue[i]);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 990);
            }

			size_t len = wcslen(pwsz) + 1;
            pElems[i] = new WCHAR[len];
            StringCchCopy(pElems[i], len, pwsz);
        }

        (pPropVar->calpwstr).cElems = dwNumValues;
        pClean.detach();
        (pPropVar->calpwstr).pElems = pElems.detach();
        return MQ_OK;
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1000);
    }
}


static
void
SetIntegerIntoMqPropVar(
    VARTYPE vtTarget,
    MQPROPVARIANT* pPropVar,
    ULONG ulValue
    )
{
	pPropVar->vt = vtTarget;

    switch(vtTarget)
    {
    case(VT_UI1):
        pPropVar->bVal = (unsigned char)ulValue;
        return;

    case(VT_I2):
        pPropVar->iVal = (short)ulValue;
        return;

    case(VT_UI2):
        pPropVar->uiVal = (unsigned short)ulValue;
        return;

    case(VT_I4):
        pPropVar->lVal = (long)ulValue;
        return;

    case(VT_UI4):
        pPropVar->ulVal = ulValue;
        return;

    case(VT_HRESULT):
        pPropVar->scode = (SCODE)ulValue;
        return;

    default:
        ASSERT(0);
        pPropVar->vt = VT_EMPTY;
        return;
    }
}


static
void
AdsiIntegerVal2MqVal(
	OUT MQPROPVARIANT *pPropVar,
	IN  VARTYPE       vtTarget,
	IN  DWORD         dwNumValues,
	IN  PADSVALUE     pADsValue
	)
{
	for(DWORD i = 0; i < dwNumValues; ++i)
	{
		SetIntegerIntoMqPropVar(vtTarget, pPropVar, pADsValue[i].Integer);
    }
}


//------------------------------------------------------------
//    AdsiVal2MqVal()
//    Translates ADSI value into MQ PropVal
//------------------------------------------------------------
HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  ADSVALUE *    pADsValue)
{
    HRESULT hr2;

    switch (AdsType)
    {
    case ADSTYPE_DN_STRING:
    case ADSTYPE_CASE_EXACT_STRING:
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_OBJECT_CLASS:
        hr2 = AdsiStringVal2MqVal(
                  pPropVar,
                  vtTarget,
                  AdsType,
                  dwNumValues,
                  pADsValue);
        return LogHR(hr2, s_FN, 1040);

    case ADSTYPE_INTEGER:
        AdsiIntegerVal2MqVal(pPropVar, vtTarget, dwNumValues, pADsValue);
        return MQ_OK;

    case ADSTYPE_BOOLEAN:
        if (dwNumValues == 1)
        {
            if (vtTarget == VT_BOOL)
            {
                pPropVar->vt      = VT_BOOL;
#pragma warning(disable: 4310)
                pPropVar->boolVal = (pADsValue->Boolean ? VARIANT_TRUE : VARIANT_FALSE);  //BUGBUG: are values the same?
#pragma warning(default: 4310)
            }
            else if (vtTarget == VT_UI1)
            {
                pPropVar->vt      = VT_UI1;
                pPropVar->bVal = (pADsValue->Boolean ? (unsigned char)1 : (unsigned char)0);  //BUGBUG: are values the same?
            }
            else
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1060);
            }
        }
        else
        {
            ASSERT(0);  // There is no VT_BOOL | VT_VECTOR case on MQPROPVARIANT
            return LogHR(MQ_ERROR, s_FN, 1070);
        }
        break;

    case ADSTYPE_OCTET_STRING:
        if (vtTarget == VT_BLOB)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR, s_FN, 1080);
            }
            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->OctetString.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->OctetString.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == VT_CLSID)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR, s_FN, 1090);
            }
            ASSERT(pADsValue->OctetString.dwLength == 16);

            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if (pPropVar->vt != VT_CLSID)
            {
                ASSERT(((pPropVar->vt == VT_NULL) || (pPropVar->vt == VT_EMPTY)));
                pPropVar->vt    = VT_CLSID;
                pPropVar->puuid = new GUID;
            }   
            else if ( pPropVar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1100);
            }

            CopyMemory(pPropVar->puuid,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == (VT_CLSID|VT_VECTOR))
        {
            ASSERT( pADsValue->OctetString.dwLength == sizeof(GUID));
            DWORD num = dwNumValues;
            pPropVar->cauuid.pElems = new GUID[ num];
            pPropVar->cauuid.cElems = num;
            pPropVar->vt = VT_CLSID|VT_VECTOR;


            for (DWORD i = 0 ; i < num; i++, pADsValue++)
            {
                CopyMemory(&pPropVar->cauuid.pElems[i],
                           pADsValue->OctetString.lpValue,
                           sizeof(GUID));
            }

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1110);
        }
        break;

    case ADSTYPE_UTC_TIME:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR, s_FN, 1120);
        }

        if (vtTarget == VT_DATE)
        {
            pPropVar->vt      = VT_DATE;
            if (!SystemTimeToVariantTime(&pADsValue->UTCTime, &pPropVar->date))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1130);
            }
        }
        else if (vtTarget == VT_I4)
        {
            //
            //   convert SYSTEMTIME->time_t
            //
            pPropVar->vt = VT_I4;
            pPropVar->lVal = INT_PTR_TO_INT(TimeFromSystemTime(&pADsValue->UTCTime)); //BUGBUG bug year 2038

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1140);
        }
        break;

    case ADSTYPE_LARGE_INTEGER:
        // No such thing in MQ!
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1150);

	case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR, s_FN, 1160);
        }

        if (vtTarget == VT_BLOB)
        {
#ifdef _DEBUG
            SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                                    pADsValue->SecurityDescriptor.lpValue ;
            DWORD dwSDLen = GetSecurityDescriptorLength(pSD) ;

            ASSERT(IsValidSecurityDescriptor(pSD)) ;
            ASSERT(dwSDLen == pADsValue->SecurityDescriptor.dwLength) ;
#endif

            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->SecurityDescriptor.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->SecurityDescriptor.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->SecurityDescriptor.lpValue,
                       pADsValue->SecurityDescriptor.dwLength);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        // No such thing in MQ!
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1170);

    default:
        return LogHR(MQ_ERROR, s_FN, 1180);

    }
    return MQ_OK;
}




void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), RPC STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), BOOL: 0x%x", wszFileName, usPoint, b);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}

void LogIllegalPointValue(DWORD_PTR dw3264, LPCWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), Illegal point Value=%Ix", wszFileName, usPoint, dw3264);
}

void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint)
{
	TrTRACE(LOG, "%ls(%u), Trace query %ls", wszFileName, usPoint, wszStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\xlatqm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Implementation of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "mqattrib.h"
#include "xlatqm.h"
#include "coreglb.h"
#include "dsutils.h"
#include "ipsite.h"
#include "_propvar.h"
#include "utils.h"
#include "adstempl.h"
#include "mqdsname.h"
#include "winsock.h"
#include "uniansi.h"
#include <mqsec.h>
#include <nspapi.h>
#include <wsnwlink.h>

#include "Ev.h"
#include <strsafe.h>

#include "xlatqm.tmh"

static WCHAR *s_FN=L"mqdscore/xlatqm";

HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi);


//----------------------------------------------------------------------
//
// Static routines
//
//----------------------------------------------------------------------

static HRESULT GetMachineNameFromQMObject(LPCWSTR pwszDN, LPWSTR * ppwszMachineName)
/*++

Routine Description:
    gets the machine name from the object's DN

Arguments:
    pwszDN              - Object's DN
    ppwszMachineName    - returned name for the object

Return Value:
    HRESULT

--*/
{
    //
    // copy to tmp buf so we can munge it
    //
	size_t len = 1 + wcslen(pwszDN);
    AP<WCHAR> pwszTmpBuf = new WCHAR[len];
    HRESULT hr = StringCchCopy(pwszTmpBuf, len, pwszDN);
	ASSERT(SUCCEEDED(hr));

    //
    // skip "CN=msmq,CN="
    // BUGBUG: need to write a parser for DN's
    //
    LPWSTR pwszTmp = wcschr(pwszTmpBuf, L',');
    if (pwszTmp)
        pwszTmp = wcschr(pwszTmp, L'=');
    if (pwszTmp)
        pwszTmp++;

    //
    // sanity check
    //
    if (pwszTmp == NULL)
    {
        TrERROR(DS, "GetMachineNameFromQMObject:Bad DN for QM object (%ls)", pwszDN);
        return LogHR(MQ_ERROR, s_FN, 10);
    }

    LPWSTR pwszNameStart = pwszTmp;

    //
    // remove the ',' at the end of the name
    //
    pwszTmp = wcschr(pwszNameStart, L',');
    if (pwszTmp)
        *pwszTmp = L'\0';

    //
    // save name
    //
	len = 1+wcslen(pwszNameStart);
    AP<WCHAR> pwszMachineName = new WCHAR[len];
    hr = StringCchCopy(pwszMachineName, len, pwszNameStart);
	ASSERT(SUCCEEDED(hr));

    //
    // return values
    //
    *ppwszMachineName = pwszMachineName.detach();
    return S_OK;
}

/*++

Routine Description:
    gets the computer DNS name

Arguments:
    pwcsComputerName    - the computer name
    ppwcsDnsName        - returned DNS name of the computer

Return Value:
    HRESULT

--*/
HRESULT MQADSpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                OUT WCHAR **    ppwcsDnsName
                )
{
    *ppwcsDnsName = NULL;
    PROPID prop = PROPID_COM_DNS_HOSTNAME;
    PROPVARIANT varDnsName;
    varDnsName.vt = VT_NULL;
    //
    //  Is the computer in the local domain?
    //
    WCHAR * pszDomainName = wcsstr(pwcsComputerName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;

    if ( (pszDomainName != NULL) && !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
    {
        //
        //   try local DC
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            &requestDsServerInternal,
 	        pwcsComputerName,      // the computer object name
            NULL,     
            1,
            &prop,
            &varDnsName);
    }
    else
    {

        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr =  g_pDS->GetObjectProperties(
                    eGlobalCatalog,
                    &requestDsServerInternal,
 	                pwcsComputerName,      // the computer object name
                    NULL,    
                    1,
                    &prop,
                    &varDnsName);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    // return value
    //
    *ppwcsDnsName = varDnsName.pwszVal;
    return MQ_OK;
}

static HRESULT GetMachineNameAndDnsFromQMObject(LPCWSTR pwszDN,
                                                LPWSTR * ppwszMachineName,
                                                LPWSTR * ppwszMachineDnsName)
/*++

Routine Description:
    gets the machine name and dns name from the object's DN

Arguments:
    pwszDN              - Object's DN
    ppwszMachineName    - returned name for the object
    ppwszMachineDnsName - returned dns name for the object

Return Value:
    HRESULT

--*/
{
    *ppwszMachineName = NULL;
    *ppwszMachineDnsName = NULL;

    DWORD len = wcslen(pwszDN);

    //
    // skip "CN=msmq,CN="
    // BUGBUG: need to write a parser for DN's
    //
    LPWSTR pwszTmp = wcschr(pwszDN, L',');
    if (pwszTmp)
        pwszTmp = wcschr(pwszTmp, L'=');
    if (pwszTmp)
        pwszTmp++;

    //
    // sanity check
    //
    if (pwszTmp == NULL)
    {
        TrERROR(DS, "GetMachineNameAndDnsFromQMObject:Bad DN for QM object (%ls)", pwszDN);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 30);
    }

    LPWSTR pwszNameStart = pwszTmp;

    //
    // find the ',' at the end of the name
    //
    pwszTmp = wcschr(pwszNameStart, L',');
	if(pwszTmp == NULL)
	{
        TrERROR(DS, "Bad DN passed to function. %ls", pwszTmp);
		ASSERT(("Bad DN parameter.", 0));
        return MQ_ERROR_INVALID_PARAMETER;
	}

    //
    // save name
    //
    AP<WCHAR> pwszMachineName = new WCHAR[1 + len];

    DWORD_PTR dwSubStringLen = pwszTmp - pwszNameStart;
    wcsncpy( pwszMachineName, pwszNameStart, dwSubStringLen);
    pwszMachineName[ dwSubStringLen] = L'\0';

    //
    //  For the dns name of the computer read dNSHostName of its computer
    //  object ( father object)
    //
    pwszTmp = wcschr(pwszDN, L',') ;    // the computer name
	if(pwszTmp == NULL)
	{
        TrERROR(DS, "Bad DN passed to function. %ls", pwszTmp);
		ASSERT(("Bad DN parameter.", 0));
        return MQ_ERROR_INVALID_PARAMETER;
	}

	pwszTmp++;

    MQADSpGetComputerDns(
                pwszTmp,
                ppwszMachineDnsName
                );
    //
    //  ignore the result ( in case of failure a null string is returned)

    //
    // return values
    //
    *ppwszMachineName = pwszMachineName.detach();
    return S_OK;

}



//----------------------------------------------------------------------
//
// CMsmqQmXlateInfo class
//
//----------------------------------------------------------------------


struct XLATQM_ADDR_SITE
//
// Describes an address in a site
//
{
    GUID        guidSite;
    USHORT      AddressLength;
    USHORT      usAddressType;
    sockaddr    Address;
};

class CMsmqQmXlateInfo : public CMsmqObjXlateInfo
//
// translate object for the QM DS object. It contains common info needed for
// for translation of several properties in the QM object
//
{
public:
    CMsmqQmXlateInfo(
        LPCWSTR             pwszObjectDN,
        const GUID*         pguidObjectGuid,
        CDSRequestContext * pRequestContext);
    ~CMsmqQmXlateInfo();
    HRESULT ComputeBestSite();
    HRESULT ComputeAddresses();
    HRESULT ComputeCNs();

    const GUID *                 BestSite();
    const XLATQM_ADDR_SITE *     Addrs();
    ULONG                        CountAddrs();
    const GUID *                 CNs();

    HRESULT RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           );


private:
    HRESULT GetDSSites(OUT ULONG *pcSites,
                       OUT GUID ** prgguidSites);

    HRESULT RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  pvar
           );

    HRESULT FetchMachineParameters(
                OUT BOOL *      pfForeignMachine,
                OUT BOOL *      pfRoutingServer,
                OUT LPWSTR *    ppwszMachineName,
                OUT LPWSTR *    ppwszMachineDnsName);

   HRESULT ComputeSiteGateAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);

   HRESULT ComputeRoutingServerAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);

   HRESULT ComputeIDCAddresses(
                    BOOL                            fThisLocalServer,
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);


    //
    // the following are set by ComputeBestSite
    //
    GUID m_guidBestSite;
    BOOL m_fSitegateOnRouteToBestSite;
    BOOL m_fComputedBestSite;

    AP<GUID> m_rgguidSites;
    ULONG    m_cSites;

    //
    //  the following are set by CoputeAddresses
    //
    AP<XLATQM_ADDR_SITE> m_rgAddrs;
    ULONG m_cAddrs;
    BOOL m_fComputedAddresses;
    BOOL m_fMachineIsSitegate;
    BOOL m_fForeignMachine;

    //
    // the following are set by ComputeCNs
    //
    AP<GUID> m_rgCNs;
    BOOL m_fComputedCNs;
};


inline const GUID * CMsmqQmXlateInfo::BestSite()
{
    return &m_guidBestSite;
}


inline const XLATQM_ADDR_SITE * CMsmqQmXlateInfo::Addrs()
{
    return (m_rgAddrs);
}


inline ULONG CMsmqQmXlateInfo::CountAddrs()
{
    return m_cAddrs;
}


inline const GUID * CMsmqQmXlateInfo::CNs()
{
    return (m_rgCNs);
}


CMsmqQmXlateInfo::CMsmqQmXlateInfo(LPCWSTR          pwszObjectDN,
                                   const GUID*      pguidObjectGuid,
                                   CDSRequestContext * pRequestContext)
/*++

Routine Description:
    Class consructor. constructs base object, and initilaizes class

Arguments:
    pwszObjectDN    - DN of object in DS
    pguidObjectGuid - GUID of object in DS

Return Value:
    None

--*/
 : CMsmqObjXlateInfo(pwszObjectDN, pguidObjectGuid, pRequestContext)
{
    m_fComputedBestSite = FALSE;
    m_fComputedAddresses = FALSE;
    m_fComputedCNs = FALSE;
	
	m_cSites = 0;
}


CMsmqQmXlateInfo::~CMsmqQmXlateInfo()
/*++

Routine Description:
    Class destructor

Arguments:
    None

Return Value:
    None

--*/
{
    //
    // members are auto delete classes
    //
}


HRESULT CMsmqQmXlateInfo::GetDSSites(OUT ULONG *pcSites,
                                     OUT GUID  ** prgguidSites)
/*++

Routine Description:
    Returns the sites of the QM as written in the DS

Arguments:
    pcSites       - returned number of sites in returned array
    prgguidSites - returned array of site guids

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get the sites stored in the DS for the computer
    //
    CMQVariant propvarResult;
    PROPVARIANT * ppropvar = propvarResult.CastToStruct();
    hr = GetDsProp(MQ_QM_SITES_ATTRIBUTE,
                   ADSTYPE_OCTET_STRING,
                   VT_VECTOR|VT_CLSID,
                   TRUE /*fMultiValued*/,
                   ppropvar);
    if (FAILED(hr) && (hr != E_ADS_PROPERTY_NOT_FOUND))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::GetDSSites:GetDsProp(%ls)=%lx", MQ_QM_SITES_ATTRIBUTE, hr);
        return LogHR(hr, s_FN, 40);
    }

    //
    // if property is not there, we return 0 sites
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        *pcSites = 0;
        *prgguidSites = NULL;
        return MQ_OK;
    }

    //
    // we know we got something, it should be array of guids
    //
    ASSERT(ppropvar->vt == (VT_VECTOR|VT_CLSID));

    //
    // return values
    //
    *pcSites = ppropvar->cauuid.cElems;
    *prgguidSites = ppropvar->cauuid.pElems;
    ppropvar->vt = VT_EMPTY; // don't auto free the variant
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeBestSite()
/*++

Routine Description:
    Computes the best site to return for the machine, and saves it in the class.
    If the best site is already computed, it returns immediately.

    Algorithm:
      if there is a site computed return it;

      read sites from DS.
      if sites == 0       ASSERT real error, not likely to happen.
      else if sites == 1  find if there is sitegate in route to him & save it.
      else
      {
          get best site using dikstra algorithm (also if sitegate is on route) and save it

          if none of them is in the map, we may need to refresh, check again, then if none again,
          it means the site that the QM claims to be in was deleted between QM startup & the checking,
          because it doesn not appear in the sites container.

          if so, we need to event, error     debug-info
      }

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedBestSite)
    {
        return MQ_OK;
    }

    //
    // Get DS sites from DS
    //
    
    
    hr = GetDSSites(&m_cSites, &m_rgguidSites);
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:GetDSSites()=%lx", hr);
        return LogHR(hr, s_FN, 50);
    }

    //
    // check the returned array
    //
    if (m_cSites == 0)
    {
        //
        // there should be site(s) for the QM, it is an error otherwise
        //
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:no sites in DS");
        ASSERT(0);
        // BUGBUG: raise event
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    if (m_cSites == 1)
    {
        //
        // find if there is a sitegate to it
        //
        hr = g_pSiteRoutingTable->CheckIfSitegateOnRouteToSite(&m_rgguidSites[0], &m_fSitegateOnRouteToBestSite);
        if (FAILED(hr) && (hr != MQDS_UNKNOWN_SITE_ID))
        {
            TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:g_pSiteRoutingTable->CheckIfSitegateOnRouteToSite()=%lx", hr);
            return LogHR(hr, s_FN, 70);
        }
        else if (hr == MQDS_UNKNOWN_SITE_ID)
        {
            //
            //  The site written in the msmq-configuration is not linked
            //  to the other sites ( or at least replication about the site-link
            //  was propogated yet to this server).
            //
            //  In this case we will return the site written in the msmq-configuration
            //
            //  Since we want the requested computer's CN to be the same as the site
            //  we set m_fSitegateOnRouteToBestSite
            //
            m_fSitegateOnRouteToBestSite = TRUE;
            TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:site not found in the routing table");
            // BUGBUG: raise event
        }

        //
        // save best site for later use
        //
        m_guidBestSite = m_rgguidSites[0];
    }
    else
    {
        //
        // multiple sites for QM. Find the best site to return. It is the one
        // with the least cost routing from our site.
        //
        hr = g_pSiteRoutingTable->FindBestSiteFromHere(m_cSites, m_rgguidSites, &m_guidBestSite, &m_fSitegateOnRouteToBestSite);
        if (FAILED(hr) && (hr != MQDS_UNKNOWN_SITE_ID))
        {
            TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:g_pSiteRoutingTable->FindBestSiteFromHere()=%lx", hr);
            return LogHR(hr, s_FN, 80);
        }
        else if (hr == MQDS_UNKNOWN_SITE_ID)
        {
            //
            //  The sites written in the msmq-configuration are not linked
            //  to the other sites ( or at least replication about the site-link
            //  was propogated yet to this server).
            //
            //  In this case we will return the first site written in the
            //  msmq-configuration
            //
            m_guidBestSite = m_rgguidSites[0];
            //
            //  Since we want the requested computer's CN to be the same as the site
            //  we set m_fSitegateOnRouteToBestSite
            //
            m_fSitegateOnRouteToBestSite = TRUE;

            TrERROR(DS, "CMsmqQmXlateInfo::ComputeBestSite:no site was found in the routing table");
            // BUGBUG: raise event
        }
    }

    //
    // m_guidBestSite & m_fSitegateOnRouteToBestSite are now set to the correct values
    //
    m_fComputedBestSite = TRUE;
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeSiteGateAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for site-gate, and saves them in the class.

    Algorithm:

    1. save all IP addresses of the sitegates
    2. If there are no saved addresses, save a dummy IP address as the site-gate's IP Address

Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill = 0;

	ASSERT( m_rgguidSites != NULL);
    //
    //  Compute the IP addresses of the site-gate
    //
    if (cSites == 0)   // no ip addresses were associated with sites ( subnets resolution)
    {
        //
        // there are no IP addresses associated with sites for this computer.
        //
        //  For FRS we cannot save "unknown IP address" ( since the QM
        //  doesn't handle it).
        //
        //  Therefore, if we have IP addresses for the computer, we will return all of them
        //  with the machine's site. Otherwise (we couldn't find IP addresses at all for the
        //  computer) the best we can do is still return unknown address.
        //
        if (cIpAddrs > 0)
        {

            m_rgAddrs = new XLATQM_ADDR_SITE[m_cSites];
            for (ULONG ulTmp = 0; ulTmp < m_cSites; ulTmp++)
            {
                //
                //  Did we resolve ip address of this site?
                //
                //  Note the first ip address ( random) is returned
                //
                if (m_guidBestSite == m_rgguidSites[ulTmp])
                {
                    m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
                    m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
                    memcpy(&m_rgAddrs[ulTmp].Address, &prgIpAddrs[0], sizeof(ULONG));
                    m_rgAddrs[ulTmp].guidSite = m_guidBestSite;
                }
                else
                {
                    //
                    //  BUGBUG - to verify that every site that we
                    //  didn't resolve its address, is indeed a foreign site
                    //
                    m_rgAddrs[ulTmp].usAddressType = FOREIGN_ADDRESS_TYPE;
                    m_rgAddrs[ulTmp].AddressLength = sizeof(GUID);
                    memcpy(&m_rgAddrs[ulTmp].Address, &m_rgguidSites[ulTmp], sizeof(GUID));
                    m_rgAddrs[ulTmp].guidSite = m_rgguidSites[ulTmp];
                }
            }
            cNextAddressToFill = m_cSites;
        }
        else // ip addresses were associated with sites ( subnets resolution)
        {
            //
            // no IP addresses for the computer at all
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0 , sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
    }
    else
    {
        //
        // return all the site-gate  addresses including foreign ones
        //

        ASSERT(m_rgguidSites != NULL);
        DWORD cAddresses = m_cSites + cSites;

        m_rgAddrs = new XLATQM_ADDR_SITE[cAddresses];
        for (ULONG ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
            memcpy(&m_rgAddrs[ulTmp].Address, &prgSites[ulTmp].ulIpAddress, sizeof(ULONG));
            m_rgAddrs[ulTmp].guidSite = prgSites[ulTmp].guidSite;
        }
        cNextAddressToFill = cSites;
        //
        //  add the foreign sites
        //
        for ( ulTmp = 0; ulTmp < m_cSites; ulTmp++)
        {
			//
			// make sure not to over fill the array
			//
            if ( cNextAddressToFill ==  cAddresses)
            {
                break;
            }

            if (g_mapForeignSites.IsForeignSite(&m_rgguidSites[ ulTmp]) )
            {
                m_rgAddrs[ cNextAddressToFill].usAddressType = FOREIGN_ADDRESS_TYPE;
                m_rgAddrs[ cNextAddressToFill].AddressLength = sizeof(GUID);
                memcpy( &m_rgAddrs[ cNextAddressToFill].Address, &m_rgguidSites[ ulTmp], sizeof(GUID));
                m_rgAddrs[ cNextAddressToFill].guidSite = m_rgguidSites[ ulTmp];
                cNextAddressToFill++;
            }
        }
    }

    m_cAddrs = cNextAddressToFill;
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeRoutingServerAddresses(
                const IPSITE_SiteArrayEntry *   prgSites,
                ULONG                           cSites,
                const ULONG *                   prgIpAddrs,
                ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for routing server, and saves them in the class.

    Algorithm:

    1. save all IP addresses of the routing server
    2. If there are no saved addresses, save a dummy IP address as the routing-server's IP Address

Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill;
    //
    //  Compute the IP addresses and then
    //
    if (cSites == 0) // no ip addresses were associated with sites ( subnets resolution)
    {
        //
        // there sre no IP addresses with sites found for this computer.
        //
        // The best solution would be to
        // save IP address unknown address with machine's site.
        //  But we cannot use it, since the QM doesn't handle
        //  a IP address unknown address for FRSs.
        //
        //  Therefore, if we have IP addresses for the computer, we will return all of them
        //  with the machine's site. Otherwise (we couldn't find IP addresses at all for the
        //  computer) the best we can do is still return unknown address.
        //
        if (cIpAddrs > 0)
        {
                m_rgAddrs = new XLATQM_ADDR_SITE[cIpAddrs];
                for ( DWORD i = 0; i < cIpAddrs; i++)
                {
                    m_rgAddrs[i].usAddressType = IP_ADDRESS_TYPE;
                    m_rgAddrs[i].AddressLength = sizeof(ULONG);
                    memcpy(&m_rgAddrs[i].Address, &prgIpAddrs[i], sizeof(ULONG));
                    m_rgAddrs[i].guidSite = m_guidBestSite;
                }
                cNextAddressToFill = cIpAddrs;
        }
        else
        {
            //
            // no IP addresses for the computer at all
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;

            //
            //  inform the user, that there are RS with unknown addresses
            //
            if ( ObjectDN() != NULL)
            {
                TrWARNING(DS, "Unable to resolve IP addresses of RS : %ls", ObjectDN());
            }
            else
            {
                TrWARNING(DS, "Unable to resolve IP addresses of RS : GUID=%!guid!", ObjectGuid());
            }
            static BOOL fInformOnceAboutRsWithoutAddresses = FALSE;

            if ( !fInformOnceAboutRsWithoutAddresses)
            {
                EvReport(RS_WITHOUT_ADDRESSES);
                fInformOnceAboutRsWithoutAddresses = TRUE;
            }

        }
    }
    else // ip addresses were associated with sites ( subnets resolution)
    {
        //
        // computer has at least one IP address
        // return all IP addresses of routing server
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[cSites];
        for (DWORD ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
            memcpy(&m_rgAddrs[ulTmp].Address, &prgSites[ulTmp].ulIpAddress, sizeof(ULONG));
            m_rgAddrs[ulTmp].guidSite = prgSites[ulTmp].guidSite;
        }
        cNextAddressToFill = cSites;

    }

    m_cAddrs = cNextAddressToFill;
    return(MQ_OK);

}

HRESULT CMsmqQmXlateInfo::ComputeIDCAddresses(
                    BOOL                            fThisLocalServer,
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for an IDC, and saves them in the class.

    Algorithm:


Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill = 0;
    //
    // save addresses to return
    //
    if (cSites == 0)
    {
        //
        // there are no IP addresses with sites found for this computer.
        //
        if ((cIpAddrs > 0) &&
            ( fThisLocalServer))
        {
            //
            //  Return all the IP address of the computer as belonging
            //  to the best site.
            //
            //  One reason for doing this: is to return a correct address of
            //  this DC which is not a routing server ( required for client address
            //  recognition)
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[ cIpAddrs ];
            for ( DWORD i = 0; i < cIpAddrs; i++)
            {
                m_rgAddrs[i].usAddressType = IP_ADDRESS_TYPE;
                m_rgAddrs[i].AddressLength = sizeof(ULONG);
                memcpy(&m_rgAddrs[i].Address, &prgIpAddrs[i], sizeof(ULONG));
                m_rgAddrs[i].guidSite = m_guidBestSite;
            }
            cNextAddressToFill = cIpAddrs;
        }
        else if (cIpAddrs > 0)
        {
            //
            //  The best solution would be to
            //  save IP address unknown address with machine's site.
            //

            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
        else
        {
            ASSERT( !fThisLocalServer);
        }
    }
    else
    {
        //
        // computer has at least one address
        //
        // return addresses only for the computed site
        //
        //
        // save the indexes of the IP Addresses in the computed site
        //
        ULONG cMatchedIPAddrs = 0;
        AP<ULONG> rgulMatchedIPAddrs = new ULONG[cSites];
        for (ULONG ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            if (prgSites[ulTmp].guidSite == m_guidBestSite)
            {
                rgulMatchedIPAddrs[cMatchedIPAddrs] = ulTmp;
                cMatchedIPAddrs++;
            }
        }

        //
        // save the IP Addresses in the computed site
        //
        if (cMatchedIPAddrs == 0)
        {
            //
            // there are no IP addresses for the site that was computed for this machine.
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
        else
        {
            //
            // there is at least one IP address for the computed site.
            // save them
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[cMatchedIPAddrs];
            for (ulTmp = 0; ulTmp < cMatchedIPAddrs; ulTmp++, cNextAddressToFill++)
            {
                m_rgAddrs[cNextAddressToFill].usAddressType = IP_ADDRESS_TYPE;
                m_rgAddrs[cNextAddressToFill].AddressLength = sizeof(ULONG);
                memcpy(&m_rgAddrs[cNextAddressToFill].Address, &prgSites[rgulMatchedIPAddrs[ulTmp]].ulIpAddress, sizeof(ULONG));
                m_rgAddrs[cNextAddressToFill].guidSite = prgSites[rgulMatchedIPAddrs[ulTmp]].guidSite;
            }
        }

    }

    //
    //  Only if the machine doesn't have IP addresses, Assume an unknown IP address
    //
    if ( cNextAddressToFill == 0)
    {
        //
        //  Assume an unknown IP address
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[1];
        m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
        m_rgAddrs[0].AddressLength = sizeof(ULONG);
        memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
        m_rgAddrs[0].guidSite = m_guidBestSite;
        cNextAddressToFill = 1;
    }

    m_cAddrs = cNextAddressToFill;

    return MQ_OK;
}



HRESULT CMsmqQmXlateInfo::FetchMachineParameters(
                OUT BOOL *      pfForeignMachine,
                OUT BOOL *      pfRoutingServer,
                OUT LPWSTR *    ppwszMachineName,
                OUT LPWSTR *    ppwszMachineDnsName)
/*
*/
{
    //
    // get machine name from object
    //
    HRESULT hr;
    hr = GetMachineNameAndDnsFromQMObject(ObjectDN(),
                                          ppwszMachineName,
                                          ppwszMachineDnsName);
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::FetchMachineParameters()=%lx", hr);
        return LogHR(hr, s_FN, 100);
    }

    //
    //  Is it a foreign machine
    //
    MQPROPVARIANT varForeign;
    varForeign.vt = VT_UI1;

    hr = GetDsProp(MQ_QM_FOREIGN_ATTRIBUTE,
                   MQ_QM_FOREIGN_ADSTYPE,
                   VT_UI1,
                   FALSE /*fMultiValued*/,
                   &varForeign);
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
        varForeign.bVal = DEFAULT_QM_FOREIGN;
        hr = MQ_OK;
    }
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::FetchMachineParameters(%ls)=%lx", MQ_QM_FOREIGN_ATTRIBUTE, hr);
        return LogHR(hr, s_FN, 110);
    }
    *pfForeignMachine = varForeign.bVal;
    //
    //  Is it a routing server machine
    //
    MQPROPVARIANT varRoutingServer;
    varRoutingServer.vt = VT_UI1;

    hr = GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE,     // [adsrv] MQ_QM_SERVICE_ATTRIBUTE
                   MQ_QM_SERVICE_ROUTING_ADSTYPE,       // [adsrv] MQ_QM_SERVICE_ADSTYPE
                   VT_UI1,
                   FALSE /*fMultiValued*/,
                   &varRoutingServer);
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
        varRoutingServer.bVal = DEFAULT_N_SERVICE;
        hr = MQ_OK;
    }
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::FetchMachineParameters(%ls)=%lx", MQ_QM_SERVICE_ATTRIBUTE, hr);
        return LogHR(hr, s_FN, 90);
    }
    *pfRoutingServer = varRoutingServer.bVal;    // [adsrv] ulVal >= SERVICE_SRV;
    return(MQ_OK);
}


HRESULT CMsmqQmXlateInfo::ComputeAddresses()
/*++

Routine Description:
    Computes the Addresses to return for the machine, and saves them in the class.
    If the  Addresses are already computed, it returns immediately.

    Algorithm:
    if there are addresses computed already return them

    compute best site (if not already computed)

    Get a list of (IPaddress, site) for the machine

    if (machine is a sitegate) save all addresses
    if (machine is not a sitegate) save only addresses that are in the computed site

    if number of saved addresses == 0 save dummy IP address as the machine's IP Address

    BUGBUG: if for sitegate it is not harmful to return all ipaddresses (even if not on the returned site)
            maybe it is OK to do so for a regular machine as well.

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedAddresses)
    {
        return MQ_OK;
    }
    //
    // compute best site (if not already computed)
    //
    hr = ComputeBestSite();
    if (FAILED(hr))
    {
        TrERROR(DS, TrERROR"CMsmqQmXlateInfo::ComputeAddresses:ComputeBestSite()=%lx", hr);
        return LogHR(hr, s_FN, 1711);
    }

    //
    //  Fetch computer parameters
    //
    BOOL    fRoutingServer;
    AP<WCHAR> pwszMachineName;
    AP<WCHAR> pwszMachineDnsName;
    hr = FetchMachineParameters(
                &m_fForeignMachine,
                &fRoutingServer,
                &pwszMachineName,
                &pwszMachineDnsName
				);
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeAddresses:FetchMachineParameters()=%lx", hr);
        return LogHR(hr, s_FN, 1712);
    }

    //
    // check if machine is sitegate
    //
    m_fMachineIsSitegate = g_pMySiteInformation->CheckMachineIsSitegate(ObjectGuid());



    if ( m_fForeignMachine != MSMQ_MACHINE)
    {
        //
        //  It is a foreign machine
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[m_cSites];
        for ( ULONG i = 0; i < m_cSites; i++)
        {
            m_rgAddrs[i].usAddressType = FOREIGN_ADDRESS_TYPE;
            m_rgAddrs[i].AddressLength = FOREIGN_ADDRESS_LEN;
            *reinterpret_cast<GUID *>(&m_rgAddrs[i].Address) = m_rgguidSites[i];
            m_rgAddrs[i].guidSite = m_rgguidSites[i];
        }
        m_cAddrs = m_cSites;
        m_fComputedAddresses = TRUE;
        return MQ_OK;

    }

    //
    // get list of IP Addresses per site of this machine
    //
    AP<IPSITE_SiteArrayEntry> rgSites;
    ULONG cSites;
    AP<ULONG>  rgIpAddrs;
    ULONG cIpAddrs;
    hr = g_pcIpSite->FindSitesByComputerName(
							pwszMachineName,
							pwszMachineDnsName,
							&rgSites,
							&cSites,
							&rgIpAddrs,
							&cIpAddrs
							);
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeAddresses:g_pcIpSite->FindSitesByComputerName()=%lx", hr);
        return LogHR(hr, s_FN, 1649);
    }

    if (m_fMachineIsSitegate)
    {
        //
        //  Prepare sitegate addresses
        //
        hr = ComputeSiteGateAddresses(
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);


    }
    else if (fRoutingServer)
    {
        hr = ComputeRoutingServerAddresses(
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);

    }
    else
    {
        BOOL fThisLocalServer = FALSE;
        //
        //  Special case if the address calculated belongs to the local server
        //
        if (_wcsicmp( g_pwcsServerName, pwszMachineName) == 0)
        {
            fThisLocalServer = TRUE;
        }

        hr = ComputeIDCAddresses(
                    fThisLocalServer,
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);
    }


    //
    // m_rgAddrs, m_cAddrs & m_fMachineIsSitegate are now set to the correct values
    //
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeAddresses failed=%lx", hr);
        return LogHR(hr, s_FN, 1653);
    }
    m_fComputedAddresses = TRUE;
    return MQ_OK;

}



HRESULT CMsmqQmXlateInfo::ComputeCNs()
/*++

Routine Description:
    Computes the CN's to return for the machine, and saves them in the class.
    If the CN's are already computed, it returns immediately.

    Algorithm:
    if there are CN's computed already return immediately

    compute IP addresses to return (if not already computed) - this computes the best site as well

    if machine is a sitegate the saved CN's are the sites from the saved (ipAddress, site) list, all of them,
        w/o checking of sitegates on route to them

    if machine is not a sitegate:
       if there is a sitegate to the best site - the saved CN's are duplicates(the number of IP addresses returned) of the best site
       if there is no sitegate to the best site - the saved CN's are duplicates(the number of IP addresses returned) of the DS site

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedCNs)
    {
        return MQ_OK;
    }

    //
    // compute Addresses (if not already computed)
    //
    hr = ComputeAddresses();
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::ComputeCNs:ComputeIPAddresses()=%lx", hr);
        return LogHR(hr, s_FN, 1654);
    }

    //
    // if machine is a sitegate, CN == site for each of its IP Addresses
    // note that for a sitegate we save all of its addresses, not only those that are
    // in its computed site.
    //
    if (m_fMachineIsSitegate)
    {
        //
        // Fill the CN's array
        // It is a must that the number of the CN's we return is the number of the
        // returned IP addresses
        //
        m_rgCNs = new GUID[m_cAddrs];
        for (ULONG ulTmp = 0; ulTmp < m_cAddrs; ulTmp++)
        {
            m_rgCNs[ulTmp] = m_rgAddrs[ulTmp].guidSite;
        }
    }
    else
    { 
        GUID guidReturnedCN;
        if ( m_fForeignMachine == FOREIGN_MACHINE)
        {
            //
            //  For a foreign computer:
            // All the addresses refer anyway to the same site, so we take the first of
            // the saved list
            //
            guidReturnedCN = m_rgAddrs[0].guidSite;
        }
        else
        {
            guidReturnedCN = *(g_pMySiteInformation->GetSiteId());
        }

        //
        // Fill the CN's array
        // It is a must that the number of the CN's we return is the number of the
        // returned IP addresses
        //
        m_rgCNs = new GUID[m_cAddrs];
        for (ULONG ulTmp = 0; ulTmp < m_cAddrs; ulTmp++)
        {
            m_rgCNs[ulTmp] = guidReturnedCN;
        }
    } 

    //
    // m_rgCNs is now set to the correct values
    //
    m_fComputedCNs = TRUE;
    return MQ_OK;
}


static HRESULT FillQmidsFromQmDNs(IN const PROPVARIANT * pvarQmDNs,
                                  OUT PROPVARIANT * pvarQmids)
/*++

Routine Description:
    Given a propvar of QM DN's, fills a propvar of QM id's
    returns an error if none of the QM DN's could be converted to guids

Arguments:
    pvarQmDNs       - QM distinguished names propvar
    pvarQmids       - returned QM ids propvar

Return Value:
    None

--*/
{

    //
    // sanity check
    //
    if (pvarQmDNs->vt != (VT_LPWSTR|VT_VECTOR))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1716);
    }

    //
    // return an empty guid list if there is an empty DN list
    //
    if (pvarQmDNs->calpwstr.cElems == 0)
    {
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // DN list is not empty
    // allocate guids in an auto free propvar
    //
    CMQVariant varTmp;
    PROPVARIANT * pvarTmp = varTmp.CastToStruct();
    pvarTmp->cauuid.pElems = new GUID [pvarQmDNs->calpwstr.cElems];
    pvarTmp->cauuid.cElems = pvarQmDNs->calpwstr.cElems;
    pvarTmp->vt = VT_CLSID|VT_VECTOR;

    //
    //  Translate each of the QM DN into unique id
    //
    ASSERT(pvarQmDNs->calpwstr.pElems != NULL);
    PROPID prop = PROPID_QM_MACHINE_ID;
    PROPVARIANT varQMid;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    DWORD dwNextToFile = 0;
    for ( DWORD i = 0; i < pvarQmDNs->calpwstr.cElems; i++)
    {
        varQMid.vt = VT_CLSID; // so returned guid will not be allocated
        varQMid.puuid = &pvarTmp->cauuid.pElems[dwNextToFile];

	    WCHAR * pszDomainName = wcsstr(pvarQmDNs->calpwstr.pElems[i], x_DcPrefix);
        ASSERT(pszDomainName) ;
			
        HRESULT hr;
        //
        //  try local DC if FRS belongs to the same domain
        //
        if ((pszDomainName != NULL) && !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
        {
            hr = g_pDS->GetObjectProperties(
                                eLocalDomainController,
                                &requestDsServerInternal,     // This routine is called from
                                                        // DSADS:LookupNext or DSADS::Get..
                                                        // impersonation, if required,
                                                        // has already been performed.
                                pvarQmDNs->calpwstr.pElems[i],
                                NULL,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        else
        {
            hr = g_pDS->GetObjectProperties(
                                eGlobalCatalog,
                                &requestDsServerInternal,     // This routine is called from
                                                        // DSADS:LookupNext or DSADS::Get..
                                                        // impersonation, if required,
                                                        // has already been performed.
                                pvarQmDNs->calpwstr.pElems[i],
                                NULL,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        if (SUCCEEDED(hr))
        {
            dwNextToFile++;
        }
    }

    if (dwNextToFile == 0)
    {
        //
        //  no FRS in the list is a valid one ( they were
        //  uninstalled probably)
        //
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // return results
    //
    pvarTmp->cauuid.cElems = dwNextToFile;
    *pvarQmids = *pvarTmp;   // set returned propvar
    pvarTmp->vt = VT_EMPTY;  // detach varTmp
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           )
/*++

Routine Description:
    Retrieves IN or OUT FRS property from the DS.
    In the DS we keep the distingushed name of the FRSs. DS client excpects
    to retrieve the unique-id of the FRSs. Therefore for each FRS ( according
    to its DN) we retrieve its unique-id.


Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    ASSERT((ppropvariant->vt == VT_NULL) || (ppropvariant->vt == VT_EMPTY));
    //
    //  Retrieve the DN of the FRSs
    //  into an auto free propvar
    //
    CMQVariant varFrsDn;
    hr = RetrieveFrssFromDs(
                    pwcsAttributeName,
                    varFrsDn.CastToStruct());
    if (FAILED(hr))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::RetrieveFrss:pQMTrans->RetrieveOutFrss()=%lx ", hr);
        return LogHR(hr, s_FN, 1656);
    }

    HRESULT hr2 = FillQmidsFromQmDNs(varFrsDn.CastToStruct(), ppropvariant);
    return LogHR(hr2, s_FN, 1657);
}


HRESULT CMsmqQmXlateInfo::RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  pvar
           )
/*++

Routine Description:
    Retrieves the computer's frss.

Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get the FRSs stored in the DS for the computer
    //
    hr = GetDsProp(pwcsAttributeName,
                   ADSTYPE_DN_STRING,
                   VT_VECTOR|VT_LPWSTR,
                   TRUE /*fMultiValued*/,
                   pvar);
    if (FAILED(hr) && (hr != E_ADS_PROPERTY_NOT_FOUND))
    {
        TrERROR(DS, "CMsmqQmXlateInfo::RetrieveFrssFromDs:GetDsProp(%ls)=%lx", MQ_QM_OUTFRS_ATTRIBUTE, hr);
        return LogHR(hr, s_FN, 1661);
    }

    //
    // if property is not there, we return 0 frss
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        pvar->vt = VT_LPWSTR|VT_VECTOR;
        pvar->calpwstr.cElems = 0;
        pvar->calpwstr.pElems = NULL;
        return MQ_OK;
    }

    return( MQ_OK);

}

//----------------------------------------------------------------------
//
// Routine to get a default translation object for MSMQ DS objects
//
//----------------------------------------------------------------------
HRESULT WINAPI GetMsmqQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo)
/*++
    Abstract:
        Routine to get a translate object that will be passed to
        translation routines to all properties of the QM

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObjectGuid     - GUID of the translated object
        ppcMsmqObjXlateInfo - Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcMsmqObjXlateInfo = new CMsmqQmXlateInfo(pwcsObjectDN, pguidObjectGuid, pRequestContext);
    return MQ_OK;
}

//----------------------------------------------------------------------
//
// Translation routines
//
//----------------------------------------------------------------------

HRESULT WINAPI MQADSpRetrieveMachineSite(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the Site property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property. propvariant should be empty already
                   as this function doesn't free it before setting the value

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute best site (if not already computed)
    //
    hr = pQMTrans->ComputeBestSite();
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpRetrieveMachineSite:pQMTrans->ComputeBestSite()=%lx for site %ls", hr, pQMTrans->ObjectDN());
        return LogHR(hr, s_FN, 1663);
    }

    //
    // set the returned prop variant
    //
    //
    //  This is a special case where we do not necessarily allocate the memory for the guid
    //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
    //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
    //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
    //
    if (ppropvariant->vt != VT_CLSID)
    {
        ASSERT(((ppropvariant->vt == VT_NULL) || (ppropvariant->vt == VT_EMPTY)));
        ppropvariant->puuid = new GUID;
        ppropvariant->vt = VT_CLSID;
    }
    else if ( ppropvariant->puuid == NULL)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1717);
    }
    *(ppropvariant->puuid) = *(pQMTrans->BestSite());
    return MQ_OK;
}


HRESULT WINAPI MQADSpRetrieveMachineAddresses(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the IP Addresses property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute IP Addresses (if not already computed)
    //
    hr = pQMTrans->ComputeAddresses();
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpRetrieveMachineAddresses:pQMTrans->ComputeIPAddresses()=%lx for site %ls", hr, pQMTrans->ObjectDN());
        return LogHR(hr, s_FN, 1664);
    }

    //
    // allocate & fill the returned blob
    //
    ASSERT( FOREIGN_ADDRESS_LEN > IP_ADDRESS_LEN);
    ULONG cbAddresses = 0;
    AP<BYTE> pbAddresses = new BYTE[pQMTrans->CountAddrs() * (TA_ADDRESS_SIZE+FOREIGN_ADDRESS_LEN)];
    TA_ADDRESS * ptaaddr = (TA_ADDRESS *)((LPBYTE)pbAddresses);
    const XLATQM_ADDR_SITE * rgAddrs = pQMTrans->Addrs();
    for (ULONG ulTmp = 0; ulTmp < pQMTrans->CountAddrs(); ulTmp++)
    {
        ptaaddr->AddressType = rgAddrs[ulTmp].usAddressType;
        unsigned short len = rgAddrs[ulTmp].AddressLength;
        ptaaddr->AddressLength = len;
        memcpy(ptaaddr->Address, (LPBYTE)&rgAddrs[ulTmp].Address, len);
        ptaaddr = (TA_ADDRESS *)((LPBYTE)ptaaddr + TA_ADDRESS_SIZE + len);
        cbAddresses += TA_ADDRESS_SIZE + len;

    }

    //
    // set the returned prop variant
    //
    ppropvariant->blob.cbSize = cbAddresses;
    ppropvariant->blob.pBlobData = pbAddresses.detach();
    ppropvariant->vt = VT_BLOB;
    return MQ_OK;
}


HRESULT WINAPI MQADSpRetrieveMachineCNs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the CN property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute CN's (if not already computed)
    //
    hr = pQMTrans->ComputeCNs();
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpRetrieveMachine:pQMTrans->ComputeCNs()=%lx for site %ls", hr, pQMTrans->ObjectDN());
        return LogHR(hr, s_FN, 1666);
    }

    //
    // allocate & fill the returned blob
    //
    AP<GUID> pElems = new GUID[pQMTrans->CountAddrs()];
    memcpy(pElems, pQMTrans->CNs(), sizeof(GUID) * pQMTrans->CountAddrs());

    //
    // set the returned prop variant
    //
    ppropvariant->cauuid.cElems = pQMTrans->CountAddrs();
    ppropvariant->cauuid.pElems = pElems.detach();
    ppropvariant->vt = VT_CLSID | VT_VECTOR;
    return S_OK;
}


/*====================================================

MQADSpRetrieveMachineName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // get the machine name
    //
    AP<WCHAR> pwszMachineName;
    HRESULT hr = GetMachineNameFromQMObject(pTrans->ObjectDN(), &pwszMachineName);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpRetrieveMachineName:GetMachineNameFromQMObject()=%lx", hr);
        return LogHR(hr, s_FN, 1667);
    }

    CharLower(pwszMachineName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwszMachineName.detach();
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveMachineDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineDNSName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // read dNSHostName of the computer object
    //
    ASSERT(wcschr(pTrans->ObjectDN(), L',') != NULL);
    WCHAR * pwcsComputerName = wcschr(pTrans->ObjectDN(), L',');
    if(pwcsComputerName == NULL)
	{
        TrERROR(DS, "Bad DN in object, %ls", pTrans->ObjectDN());
		ASSERT(("Bad DN in object.", 0));
		return MQ_ERROR_INVALID_PARAMETER;
	}

	pwcsComputerName++;

    WCHAR * pwcsDnsName; 
    HRESULT hr = MQADSpGetComputerDns(
                pwcsComputerName,
                &pwcsDnsName
                );
    if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
    {
        //
        //    The dNSHostName attribute doesn't have value
        //
        ppropvariant->vt = VT_EMPTY;
        return MQ_OK;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1718);
    }

    CharLower(pwcsDnsName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwcsDnsName;
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveMachineMasterId

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineMasterId(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    //  BUGBUG - for the time being, returns the site
    //
    HRESULT hr2 = MQADSpRetrieveMachineSite(pTrans, ppropvariant);
    return LogHR(hr2, s_FN, 1719);
}

/*====================================================

MQADSpRetrieveMachineOutFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineOutFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( MQ_QM_OUTFRS_ATTRIBUTE,
                               ppropvariant);
    return LogHR(hr, s_FN, 1721);

}

/*====================================================

MQADSpRetrieveMachineInFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineInFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( MQ_QM_INFRS_ATTRIBUTE,
                               ppropvariant);
    return LogHR(hr, s_FN, 1722);
}

/*====================================================

MQADSpRetrieveQMService

Arguments:

Return Value:
                  [adsrv]
=====================================================*/
HRESULT WINAPI MQADSpRetrieveQMService(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // get the QM service type bits
    //
    MQPROPVARIANT varRoutingServer, varDsServer;  //, varDepClServer;
    varRoutingServer.vt = VT_UI1;
    varDsServer.vt      = VT_UI1;

    hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE,
                   MQ_QM_SERVICE_ROUTING_ADSTYPE,
                   VT_UI1,
                   FALSE,
                   &varRoutingServer);
    if (FAILED(hr))
    {
        if (hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //  This can happen if some of the computers were installed
            //  with Beta2 DS servers
            //
            //  In this case, we return the old-service as is.
            //
            hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_ATTRIBUTE,
                           MQ_QM_SERVICE_ADSTYPE,
                           VT_UI4,
                           FALSE,
                           ppropvariant);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1723);
            }
            else
            {
                ppropvariant->vt = VT_UI4;
                return(MQ_OK);
            }

        }


        TrERROR(DS, "MQADSpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE)=%lx", hr);
        return LogHR(hr, s_FN, 1668);
    }

    hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_DSSERVER_ATTRIBUTE,
                   MQ_QM_SERVICE_DSSERVER_ADSTYPE,
                   VT_UI1,
                   FALSE,
                   &varDsServer);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_DSSERVER_ATTRIBUTE)=%lx", hr);
        return LogHR(hr, s_FN, 1669);
    }


    //
    // set the returned prop variant
    //
    ppropvariant->vt    = VT_UI4;
    ppropvariant->ulVal = (varDsServer.bVal ? SERVICE_PSC : (varRoutingServer.bVal ? SERVICE_SRV : SERVICE_NONE));
    return(MQ_OK);
}

//----------------------------------------------------------------------
//
// Set routines
//
//----------------------------------------------------------------------

HRESULT WINAPI MQADSpCreateMachineSite(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    // if someone asks to set the old prop for site (now computed), we change it to
    // setting the new multi-valued site prop (in the DS)
    //
    ASSERT(pPropVar->vt == VT_CLSID);
    *pdwNewPropID = PROPID_QM_SITE_IDS;
    pNewPropVar->vt = VT_CLSID|VT_VECTOR;
    pNewPropVar->cauuid.cElems = 1;
    pNewPropVar->cauuid.pElems = new GUID;
    pNewPropVar->cauuid.pElems[0] = *pPropVar->puuid;
    return S_OK;
}

HRESULT WINAPI MQADSpSetMachineSite(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    // if someone asks to set the old prop for site (now computed), we change it to
    // setting the new multi-valued site prop (in the DS)
    //
    UNREFERENCED_PARAMETER( pAdsObj);
	HRESULT hr2 = MQADSpCreateMachineSite(
					pPropVar,
					pdwNewPropID,
					pNewPropVar);
    return LogHR(hr2, s_FN, 1731);
}



static HRESULT  SetMachineFrss(
                 IN const PROPID       propidFRS,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
/*++

Routine Description:
    Translate PROPID_QM_??FRS to PROPID_QM_??FRS_DN, for set or create
    operation

Arguments:
    propidFRS   - the proerty that we translate to
    pPropVar    - the user supplied property value
    pdwNewPropID - the property that we translate to
    pNewPropVar  - the translated property value

Return Value:
    HRESULT

--*/
{
    //
    //  When the user tries to set PROPID_QM_OUTFRS or
    //  PROPID_QM_INFRS, we need to translate the frss'
    //  unqiue-id to their DN.
    //
    ASSERT(pPropVar->vt == (VT_CLSID|VT_VECTOR));
    *pdwNewPropID = propidFRS;

    if ( pPropVar->cauuid.cElems == 0)
    {
        //
        //  No FRSs
        //
        pNewPropVar->calpwstr.cElems = 0;
        pNewPropVar->calpwstr.pElems = NULL;
        pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;
       return(S_OK);
    }
    HRESULT hr;
    //
    //  Translate unique id to DN
    //
    pNewPropVar->calpwstr.cElems = pPropVar->cauuid.cElems;
    pNewPropVar->calpwstr.pElems = new LPWSTR[ pPropVar->cauuid.cElems];
    memset(  pNewPropVar->calpwstr.pElems, 0, pPropVar->cauuid.cElems * sizeof(LPWSTR));
    pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;

    PROPID prop = PROPID_QM_FULL_PATH;
    PROPVARIANT var;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    for (DWORD i = 0; i < pPropVar->cauuid.cElems; i++)
    {
        var.vt = VT_NULL;

        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,	
                    &requestDsServerInternal,     // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
 	                NULL,
                    &pPropVar->cauuid.pElems[i],
                    1,
                    &prop,
                    &var);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1733);
        }
        pNewPropVar->calpwstr.pElems[i] = var.pwszVal;
    }
    return(S_OK);
}


/*====================================================

MQADSpCreateMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1734);
}
/*====================================================

MQADSpSetMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1746);
}


/*====================================================

MQADSpCreateMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1747);
}

/*====================================================

MQADSpSetMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1748);
}



/*====================================================

MQADSpSetMachineServiceInt

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceTypeInt(
                 IN  PROPID            propFlag,
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);
    
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        TrTRACE(DS, "MQADSpSetMachineService:pIADs->Get()=%lx", hr);
        return LogHR(hr, s_FN, 1751);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpSetMachineService:Variant2MqVal()=%lx", hr);
        return LogHR(hr, s_FN, 1671);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;
    // PROPID propToChangeInSetting = PROPID_SET_SERVICE; [adsrv]

    CDsQueryHandle hQuery;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpSetMachineService : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 1754);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    HRESULT hr1 = MQ_OK;
    while (SUCCEEDED(hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //
        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->SetObjectProperties (
                        eLocalDomainController,
                        &requestDsServerInternal1, // no need to impersonate again,
                                            // this routine is called from 
                                            // dsads::Set.. which already performed
                                            // impersonation if required
                        var.pwszVal,
                        NULL,
                        1,
                        &propFlag,               //[adsrv]propToChangeInSetting,
                        pPropVar,
                        NULL /*pObjInfoRequest*/
                        );
        if (FAILED(hr))
        {
            hr1 = hr;
        }

    }
    if (FAILED(hr1))
    {
        return LogHR(hr1, s_FN, 1756);
    }

    return LogHR(hr, s_FN, 1757);
}

/*====================================================

MQADSpSetMachineServiceDs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr = MQADSpSetMachineServiceTypeInt(
					 PROPID_SET_SERVICE_DSSERVER,
					 pAdsObj,
					 pPropVar,
					 pdwNewPropID,
					 pNewPropVar);
    if (FAILED(hr))
    {
    	return LogHR(hr, s_FN, 1758);
    }
	
    //
    // we have to reset PROPID_SET_NT4 flag. 
    // In general this flag was reset by migration tool for PEC/PSC.
    // The problem is BSC. After BSC upgrade we have to change
    // PROPID_SET_NT4 flag to 0 and if this BSC is not DC we have to 
    // reset PROPID_SET_SERVICE_DSSERVER flag too. 
    // So, when QM runs first time after upgrade, it completes upgrade
    // process and tries to set PROPID_SET_SERVICE_DSSERVER. 
    // Together with this flag we can change PROPID_SET_NT4 too.
    //

    //
    // BUGBUG: we need to perform set only for former BSC.
    // Here we do it everytime for every server. 
    //
    PROPVARIANT propVarSet;
    propVarSet.vt = VT_UI1;
    propVarSet.bVal = 0;

    hr = MQADSpSetMachineServiceTypeInt(
				     PROPID_SET_NT4,
				     pAdsObj,
				     &propVarSet,
				     pdwNewPropID,
				     pNewPropVar);

    return LogHR(hr, s_FN, 1759);
}


/*====================================================

MQADSpSetMachineServiceRout

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr2 = MQADSpSetMachineServiceTypeInt(
                 PROPID_SET_SERVICE_ROUTING,
                 pAdsObj,
                 pPropVar,
                 pdwNewPropID,
                 pNewPropVar);
    return LogHR(hr2, s_FN, 1761);
}

/*====================================================

MQADSpSetMachineService

Arguments:

Return Value:

=====================================================*/

// [adsrv] BUGBUG:  TBD: If there will be any setting of PROPID_QM_OLDSERVICE, we'll have to rewrite it...

HRESULT WINAPI MQADSpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);

    if ( pPropVar->ulVal < SERVICE_SRV)
    {
        return S_OK;
    }
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        TrTRACE(DS, "MQADSpSetMachineService:pIADs->Get()=%lx", hr);
        return LogHR(hr, s_FN, 1762);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        TrERROR(DS, "MQADSpSetMachineService:Variant2MqVal()=%lx", hr);
        return LogHR(hr, s_FN, 1673);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        TrWARNING(DS, "MQADSpSetMachineService : Locate begin failed %lx", hr);
        return LogHR(hr, s_FN, 1764);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    while (SUCCEEDED(hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //

        // [adsrv] TBD: here we will have to translate PROPID_QM_OLDSERVICE into set of 3 bits
        PROPID aFlagPropIds[] = {PROPID_SET_SERVICE_DSSERVER,
                                 PROPID_SET_SERVICE_ROUTING,
                                 PROPID_SET_SERVICE_DEPCLIENTS,
								 PROPID_SET_OLDSERVICE};

        MQPROPVARIANT varfFlags[4];
        for (DWORD j=0; j<3; j++)
        {
            varfFlags[j].vt   = VT_UI1;
            varfFlags[j].bVal = FALSE;
        }
        varfFlags[3].vt   = VT_UI4;
        varfFlags[3].ulVal = pPropVar->ulVal;


        switch(pPropVar->ulVal)
        {
        case SERVICE_SRV:
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_BSC:
        case SERVICE_PSC:
        case SERVICE_PEC:
            varfFlags[0].bVal = TRUE;   // DS server
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_RCS:
            return S_OK;                // nothing to set - we ignored downgrading
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1766);
        }

        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->SetObjectProperties (
                        eLocalDomainController,
                        &requestDsServerInternal1,       // no need to impersonate again,
                                            // this routine is called from 
                                            // dsads::Set.. which already performed
                                            // impersonation if required
                        var.pwszVal,
                        NULL,
                        4,
                        aFlagPropIds,
                        varfFlags,
                        NULL /*pObjInfoRequest*/
                        );

    }
    return LogHR(hr, s_FN, 1767);
}



/*====================================================

MQADSpQM1SetMachineSite

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineSite(
                 IN ULONG             /*cProps */,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];

    if ((pPropVar->vt != (VT_CLSID|VT_VECTOR)) ||
        (pPropVar->cauuid.cElems == 0) ||
        (pPropVar->cauuid.pElems == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1768);
    }

    //
    // return the first site-id from the list
    //
    pNewPropVar->puuid = new CLSID;
    pNewPropVar->vt = VT_CLSID;
    *pNewPropVar->puuid = pPropVar->cauuid.pElems[0];
    return MQ_OK;
}


/*====================================================

MQADSpQM1SetMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineOutFrss(
                 IN ULONG             /* cProps */,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];
    HRESULT hr2=FillQmidsFromQmDNs(pPropVar, pNewPropVar);
    return LogHR(hr2, s_FN, 1771);
}

/*====================================================

MQADSpQM1SetMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineInFrss(
                 IN ULONG             /*cProps*/,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];
    HRESULT hr2 = FillQmidsFromQmDNs(pPropVar, pNewPropVar);
    return LogHR(hr2, s_FN, 1773);
}

/*====================================================

MQADSpQM1SetMachineService

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpQM1SetMachineService(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             /*idxProp*/,
                 OUT PROPVARIANT      *pNewPropVar)
{
    BOOL fRouter      = FALSE,
         fDSServer    = FALSE,
		 fFoundRout   = FALSE,
		 fFoundDs     = FALSE,
		 fFoundDepCl  = FALSE;

    for ( DWORD i = 0; i< cProps ; i++)
    {
        switch (rgPropIDs[i])
        {
        // [adsrv] Even if today we don't get new server-type-specific props, we may tomorrow.
        case PROPID_QM_SERVICE_ROUTING:
            fRouter = (rgPropVars[i].bVal != 0);
			fFoundRout = TRUE;
            break;

        case PROPID_QM_SERVICE_DSSERVER:
            fDSServer  = (rgPropVars[i].bVal != 0);
			fFoundDs = TRUE;
            break;

        case PROPID_QM_SERVICE_DEPCLIENTS:
			fFoundDepCl = TRUE;
            break;

        default:
            break;

        }
    }

	// If anybody sets one of 3 proprties (rout, ds, depcl), he must do it for all 3 of them
	ASSERT( fFoundRout && fFoundDs && fFoundDepCl);

    pNewPropVar->vt    = VT_UI4;
    pNewPropVar->ulVal = (fDSServer ? SERVICE_PSC : (fRouter ? SERVICE_SRV : SERVICE_NONE));

	return MQ_OK;
}

/*====================================================

MQADSpQM1SetSecurity

    Translate security descriptor to NT4 format.

====================================================*/

HRESULT WINAPI MQADSpQM1SetSecurity(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             /*idxProp*/,
                 OUT PROPVARIANT      *pNewPropVar)
{
    DWORD dwIndex = 0 ;
    DWORD dwObjectType = 0 ;

    for ( DWORD i = 0; ((i < cProps) && (dwObjectType == 0)) ; i++ )
    {
        switch (rgPropIDs[i])
        {
            case PROPID_Q_SECURITY:
                dwIndex = i ;
                dwObjectType = MQDS_QUEUE ;
                break ;

            case PROPID_QM_SECURITY:
                dwIndex = i ;
                dwObjectType = MQDS_MACHINE ;
                break ;

            default:
                break ;
        }
    }

    if (dwObjectType == 0)
    {
        ASSERT(0) ;
        return LogHR(MQDS_WRONG_OBJ_TYPE, s_FN, 1776);
    }

    DWORD dwSD4Len = 0 ;
    P<SECURITY_DESCRIPTOR> pSD4 = NULL ;

    HRESULT hr = MQSec_ConvertSDToNT4Format( dwObjectType,
                (SECURITY_DESCRIPTOR*) rgPropVars[ dwIndex ].blob.pBlobData,
                                            &dwSD4Len,
                                            &pSD4 ) ;
    if (FAILED(hr))
    {
        ASSERT(0) ;
        return LogHR(hr, s_FN, 1777);
    }

    pNewPropVar->vt = VT_BLOB ;

    if (hr == MQSec_I_SD_CONV_NOT_NEEDED)
    {
        ASSERT(pSD4 == NULL) ;
        //
        // Copy input descriptor.
        //
        dwSD4Len = rgPropVars[ dwIndex ].blob.cbSize ;
        pNewPropVar->blob.pBlobData = (BYTE*) new BYTE[ dwSD4Len ] ;
        memcpy( pNewPropVar->blob.pBlobData,
                rgPropVars[ dwIndex ].blob.pBlobData,
                dwSD4Len ) ;
        pNewPropVar->blob.cbSize = dwSD4Len ;
    }
    else
    {
        pNewPropVar->blob.pBlobData = (BYTE*)pSD4.detach();
        pNewPropVar->blob.cbSize = dwSD4Len ;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\_dsads.h ===
#ifndef ___DSADS_H__
#define ___DSADS_H__
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	_dsads.h

Abstract:
	Internal definitions for CADSI class implementation

Author:
    AlexDad
--*/

#include "activeds.h"
#include "mqads.h"

//---------------------------------------------------------
//
// CADSSearch: Internal object encapsulating ongoing search
//
//---------------------------------------------------------

class CADSSearch
{
public:
    CADSSearch(IDirectorySearch  *  pIDirSearch, 
               const PROPID      *  pPropIDs,    
               DWORD                cPropIDs,          
               DWORD                cRequestedFromDS,
               const MQClassInfo *  pClassInfo,               
               ADS_SEARCH_HANDLE    hSearch);
    ~CADSSearch();

    BOOL               Verify();
    IDirectorySearch  *pDSSearch();
    ADS_SEARCH_HANDLE  hSearch();
    PROPID             PropID(DWORD i);
    DWORD              NumPropIDs();
    DWORD              NumRequestedFromDS();
    const MQClassInfo *      ClassInfo();
    void               SetNoMoreResult();
    BOOL               WasLastResultReturned();

private:
    DWORD              m_dwSignature;   // to verify that handle was not falsified
    IDirectorySearch  *m_pDSSearch;     //IDirectorySearch interface captured;
    ADS_SEARCH_HANDLE  m_hSearch;       // ADSI search handle 
    PROPID            *m_pPropIDs;      // array of column PropIDs
    DWORD              m_cPropIDs;      // counter of columns requested in PropIDs
    DWORD              m_cRequestedFromDS; // counter of columns passed to DS (with Dn & Guid)
    const MQClassInfo * m_pClassInfo;    // pointer to class info
    BOOL               m_fNoMoreResults;
};


inline BOOL CADSSearch::Verify()
{
    // Checking the signature
    return (m_dwSignature == 0x1234);
}

inline IDirectorySearch  *CADSSearch::pDSSearch()
{
    return m_pDSSearch;
}
    
inline ADS_SEARCH_HANDLE CADSSearch::hSearch()
{
    return  m_hSearch;
}

inline  PROPID CADSSearch::PropID(DWORD i)
{
    ASSERT(i < m_cPropIDs);
    return m_pPropIDs[i];
}

inline DWORD CADSSearch::NumPropIDs()
{
    return m_cPropIDs;
}

inline DWORD CADSSearch::NumRequestedFromDS()
{
    return m_cRequestedFromDS;
}

inline void CADSSearch::SetNoMoreResult()
{
    m_fNoMoreResults = TRUE;
}
inline BOOL CADSSearch::WasLastResultReturned()
{
    return( m_fNoMoreResults);
}


inline const MQClassInfo * CADSSearch::ClassInfo()
{
    return m_pClassInfo;
}

#endif

static HRESULT GetDNGuidFromSearchObj(IN IDirectorySearch  *pSearchObj,
                                      ADS_SEARCH_HANDLE  hSearch,
                                      OUT LPWSTR * ppwszObjectDN,
                                      OUT GUID ** ppguidObjectGuid);
static HRESULT GetDNGuidFromIADs(IN IADs * pIADs,
                                 OUT LPWSTR * ppwszObjectDN,
                                 OUT GUID ** ppguidObjectGuid);

static HRESULT VerifyObjectCategory( IN IADs * pIADs,
                                  IN const WCHAR * pwcsExpectedCategory
                                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\xlatobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatobj.cpp

Abstract:

    Implementation of routines that deal with translation of generic MSMQ objects:
    CMsmqObjXlateInfo

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include <activeds.h>
#include "mqads.h"
#include "_propvar.h"
#include "dsutils.h"
#include "utils.h"
#include <adsiutl.h> 

#include "xlatobj.tmh"


static WCHAR *s_FN=L"mqdscore/xlatobj";

//--------------------------------------------------------------------
// static functions fwd declaration
//--------------------------------------------------------------------

static HRESULT GetPropvarByIADs(IN IADs * pIADs,
                                IN LPCWSTR pwszPropName,
                                IN ADSTYPE adstype,
                                IN VARTYPE vartype,
                                IN BOOL fMultiValued,
                                OUT PROPVARIANT * ppropvarResult);
static HRESULT GetPropvarByDN(IN LPCWSTR pwszObjectDN,
                              IN LPCWSTR pwszPropName,
                              IN ADSTYPE adstype,
                              IN VARTYPE vartype,
                              IN BOOL fMultiValued,
                              OUT PROPVARIANT * ppropvarResult,
                              OUT IADs ** ppIADs);
static HRESULT GetPropvarBySearchObj(IN IDirectorySearch *pSearchObj,
                                     IN ADS_SEARCH_HANDLE hSearch,
                                     IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     OUT PROPVARIANT * ppropvarResult);

//--------------------------------------------------------------------
// CMsmqObjXlateInfo implementation
//--------------------------------------------------------------------

CMsmqObjXlateInfo::CMsmqObjXlateInfo(
                    LPCWSTR             pwszObjectDN,
                    const GUID*         pguidObjectGuid,
                    CDSRequestContext *    pRequestContext)
                    : m_pRequestContext( pRequestContext)
/*++
    Constructor for the generic xlate info for an MSMQ objects
--*/
{
    //
    // record the DN of the object if any
    //
    if (pwszObjectDN)
    {
        m_pwszObjectDN = new WCHAR[wcslen(pwszObjectDN) + 1];
        wcscpy(m_pwszObjectDN, pwszObjectDN);
    }

    //
    // record the guid of the object if any
    //
    if (pguidObjectGuid)
    {
        m_pguidObjectGuid = new GUID;
        *m_pguidObjectGuid = *pguidObjectGuid;
    }
//
//    no need for following initialization since these are auto-release and inited
//    to NULL already
//
//    m_pIADs = NULL;
//    m_pSearchObj = NULL;
//
}


CMsmqObjXlateInfo::~CMsmqObjXlateInfo()
/*++
    Destructor for the generic xlate info for an MSMQ objects.
--*/
{
    //
    // members are auto release
    //
}


void CMsmqObjXlateInfo::InitGetDsProps(IN IADs * pIADs)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given IADs object when trying to
        get props for the object.

    Parameters:
        pIADs           - IADs interface for the object

    Returns:
      None
--*/
{
    pIADs->AddRef();  // keep it alive
    m_pIADs = pIADs;  // will auto release on destruction
}


void CMsmqObjXlateInfo::InitGetDsProps(IN IDirectorySearch * pSearchObj,
                                       IN ADS_SEARCH_HANDLE hSearch)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given search object first when trying to
        get props for the object, before binding to it using IADs.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle

    Returns:
      None
--*/
{
    pSearchObj->AddRef();      // keep it alive
    m_pSearchObj = pSearchObj; // will auto release on destruction
    m_hSearch = hSearch;
}


HRESULT CMsmqObjXlateInfo::GetDsProp(IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     IN BOOL fMultiValued,
                                     OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property value of the object as a propvariant, w/o going
        to translation routine or default value

    Parameters:
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      MQ_OK - success, ppropvarResult is filled
      E_ADS_PROPERTY_NOT_FOUND - property was not found
      other HRESULT errors
--*/
{
    HRESULT hr;
    CMQVariant propvarResult;
    BOOL fGotPropFromSearchObj = FALSE;

    //
    // start with getting the property from search object
    //
    if (m_pSearchObj.get() != NULL)
    {
        hr = GetPropvarBySearchObj(m_pSearchObj.get(),
                                   m_hSearch,
                                   pwszPropName,
                                   adstype,
                                   vartype,
                                   propvarResult.CastToStruct());
        if (FAILED(hr))
        {
            TrERROR(DS, "Failed to get propery %ls from search object. %!hresult!",pwszPropName, hr);
            return hr;
        }

        //
        // hr could be S_OK (if property found) or S_FALSE (if property was not requested in search)
        //
        if (hr == S_OK) //e.g. (hr != S_FALSE)
        {
            //
            // we don't need to check further
            //
            fGotPropFromSearchObj = TRUE;
        }
    }

    //
    // if search object was not helpfull, use IADs
    //
    if (!fGotPropFromSearchObj)
    {
        //
        // property was not found, use IADs
        //
        if (m_pIADs.get() != NULL)
        {
            //
            // there is already an open IADs for the object, use it
            //
            hr = GetPropvarByIADs(m_pIADs.get(),
                                  pwszPropName,
                                  adstype,
                                  vartype,
                                  fMultiValued,
                                  propvarResult.CastToStruct());
            if (FAILED(hr))
            {
                TrERROR(DS, "Failed to get propvar by IADs for %ls. %!hresult!", pwszPropName, hr);
                return hr;
            }
        }
        else
        {
            //
            // IADs is not set, bind to the object, and save the IADs
            //
            R<IADs> pIADs;
            hr = GetPropvarByDN(ObjectDN(),
                                pwszPropName,
                                adstype,
                                vartype,
                                fMultiValued,
                                propvarResult.CastToStruct(),
                                &pIADs.ref());
            if (FAILED(hr))
            {
                TrERROR(DS, "Failed to get propvar by DN for %ls. %!hresult!", pwszPropName, hr);
                return hr;
            }

            //
            // save the IADs
            // we must not AddRef it since we created it and we need to totally release
            // it on destruction, it is not a passed parameter we need to keep alive
            //
            m_pIADs = pIADs;
        }
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return MQ_OK;
}


//--------------------------------------------------------------------
// external functions
//--------------------------------------------------------------------

HRESULT WINAPI GetDefaultMsmqObjXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo)
/*++
    Abstract:
        Routine to get a default translate object that will be passed to
        translation routines to all properties of the translated object

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObjectGuid     - GUID of the translated object
        ppcMsmqObjXlateInfo - Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcMsmqObjXlateInfo = new CMsmqObjXlateInfo(
                                        pwcsObjectDN,
                                        pguidObjectGuid,
                                        pRequestContext);
    return MQ_OK;
}


//--------------------------------------------------------------------
// static functions
//--------------------------------------------------------------------

static HRESULT GetPropvarByIADs(IN IADs * pIADs,
                                IN LPCWSTR pwszPropName,
                                IN ADSTYPE adstype,
                                IN VARTYPE vartype,
                                IN BOOL fMultiValued,
                                OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using IADs

    Parameters:
        pIADs           - IADs interface for the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;
    //
    // get prop
    //
    CAutoVariant varResult;
    BS bsProp = pwszPropName;
    if (fMultiValued)
    {
        hr = pIADs->GetEx(bsProp, &varResult);
    }
    else
    {
        hr = pIADs->Get(bsProp, &varResult);
    }    
    if (FAILED(hr))
    {
        TrERROR(DS, "Failed to get property %ls from object. %!hresult!", pwszPropName, hr);
        return hr;
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, adstype, vartype);
    if (FAILED(hr))
    {
        TrERROR(DS, "Failed to ranslates OLE Variant into MQPropVal value. %!hresult!", hr);
        return hr;
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}


static HRESULT GetPropvarByDN(IN LPCWSTR pwszObjectDN,
                              IN LPCWSTR pwszPropName,
                              IN ADSTYPE adstype,
                              IN VARTYPE vartype,
                              IN BOOL fMultiValued,
                              OUT PROPVARIANT * ppropvarResult,
                              OUT IADs ** ppIADs)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using its DN. It also returns the IADs for the object.

    Parameters:
        pwszObjectDN    - distinguished name of the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already
        ppIADs          - returned IADs interface for the object

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;

    //
    // Create ADSI path
    //
    AP<WCHAR> pwszPath = new WCHAR[1+wcslen(L"LDAP://")+wcslen(pwszObjectDN)];
    wcscpy(pwszPath, L"LDAP://");
    wcscat(pwszPath, pwszObjectDN);

    //
    // bind to the obj
    //
    R<IADs> pIADs;

	AP<WCHAR> pEscapeAdsPathNameToFree;

	hr = ADsOpenObject(
			UtlEscapeAdsPathName(pwszPath, pEscapeAdsPathNameToFree),
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADs,
			(void**)&pIADs
			);


    LogTraceQuery(pwszPath, s_FN, 59);
    if (FAILED(hr))
    {
        TrERROR(DS, "Failed to open %ls. %!hresult!", pwszPath, hr);
        return hr;
    }

    //
    // get the prop
    //
    CMQVariant propvarResult;
    hr = GetPropvarByIADs(pIADs.get(), pwszPropName, adstype, vartype, fMultiValued, propvarResult.CastToStruct());
    if (FAILED(hr))
    {
        TrERROR(DS, "Failed to get propvar %ls. %!hresult!",pwszPropName, hr);
        return hr;
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    *ppIADs = pIADs.detach();
    return S_OK;
}


static HRESULT GetPropvarBySearchObj(IN IDirectorySearch *pSearchObj,
                                     IN ADS_SEARCH_HANDLE hSearch,
                                     IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using a search object.
        Note it might not find the property if it was not requested by the
        search originator.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      S_FALSE - property not requested by search originator, ppropvarResult is not filled
      other HRESULT errors
--*/
{
    //
    // check if prop is requested
    //
    ADS_SEARCH_COLUMN columnProp;
    HRESULT hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(pwszPropName), &columnProp);
    if (FAILED(hr) && (hr != E_ADS_COLUMN_NOT_SET))
    {
        TrERROR(DS, "Failed to get column for %ls. %!hresult!", pwszPropName, hr);
        return hr;
    }
    
    if (hr == E_ADS_COLUMN_NOT_SET)
    {
        //
        // property was not requested
        //
        return S_FALSE;
    }

    //
    // property was found, make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnProp(pSearchObj, &columnProp);

    //
    // convert it to propvariant
    //
    CMQVariant propvarResult;
    hr = AdsiVal2MqVal(propvarResult.CastToStruct(),
                       vartype,
                       adstype,
                       columnProp.dwNumValues,
                       columnProp.pADsValues);
    if (FAILED(hr))
    {
        TrERROR(DS, "Failed to convert val to mqval for %ls. %!hresult!",pwszPropName, hr);
        return hr;
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\midluser.cpp ===
#include "stdh.h"
#include "..\..\common\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdscore\xlatqm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Definition of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#ifndef __XLATQM_H__
#define __XLATQM_H__

#include "mqads.h"

HRESULT WINAPI GetMsmqQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo);

HRESULT WINAPI MQADSpRetrieveMachineSite(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineAddresses(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineCNs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineDNSName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineMasterId(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveQMService(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineOutFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineInFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);


HRESULT WINAPI MQADSpSetMachineSite(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineSite(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineSite(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineOutFrss(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineInFrss(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineService(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetSecurity(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT MQADSpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                OUT WCHAR **    ppwcsDnsName
                );


#endif //__XLATQM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\dscomm_s_.c ===
#pragma warning(push, 3)
#pragma warning(disable: 4701)
#include <dscomm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\dsapi.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsapi.cpp

Abstract:

    Includes ClIENT-SERVER APIs ( local interface)

Author:

    Ronit Hartmann (ronith)

--*/

#include "stdh.h"
#include "mqds.h"
#include "qmperf.h"
#include <mqsec.h>
#include <_registr.h>
#include <mqsec.h>
#include "dsreqinf.h"
#include <adserr.h>
#include <ex.h>
#include <_mqrpc.h>

#include "dsapi.tmh"

static WCHAR *s_FN=L"mqdssrv/dsapi";

#define STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate)  \
    {                                                                   \
        fImpersonate = ((dwObjectType & IMPERSONATE_CLIENT_FLAG) != 0); \
        dwObjectType &= ~IMPERSONATE_CLIENT_FLAG;                       \
    }


// Validate that all the specified properties are allowed to be queried
// by applications via the DS API.
static HRESULT ValidateProperties(DWORD cp, PROPID aProp[])
{
    DWORD i;
    PROPID *pPropID;

    //
    // Check the PROPID pointer and return error if NULL
    // We hit this condition during .net RC2 ITG deployment in NorthAmerica domain
    //
    if (aProp == NULL)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 5);
    }


    if ((cp ==1) && (aProp[0] == PROPID_COM_SID))
    {
        //
        // Allow msmq services to query for their own machine account SID.
        //
        return MQ_OK ;
    }
    else if ((cp ==1) && (aProp[0] == PROPID_SET_FULL_PATH))
    {
        //
        // Happen when msmq service wants to update its dacl in
        // msmqConfiguration object after upgrade to win2k.
        //
        return MQ_OK ;
    }

    for (i = 0, pPropID = aProp;
         (i < cp) && !IS_PRIVATE_PROPID(*pPropID);
         i++, pPropID++)
	{
		NULL;
	}

    if (i < cp)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 10);
    }

    return(MQ_OK);
}


// Validate that all the specified restrictions are allowed to be queried
// by applications via the DS API.
static HRESULT ValidateRestrictions( DWORD cRes,
                                     MQPROPERTYRESTRICTION *paPropRes)
{
    //
    // Check the paPropRes pointer and return error if NULL
    // We hit this condition during .net RC2 ITG deployment in NorthAmerica domain
    //
    if (paPropRes == NULL)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 7);
    }


    if ((cRes == 2)                                  &&
        ((paPropRes[0]).prop == PROPID_SET_SERVICE) &&
        ((paPropRes[1]).prop == PROPID_SET_NT4))
    {
        //
        // Happen when msmq service wants to update its dacl in
        // msmqConfiguration object after upgrade to win2k.
        //
        return MQ_OK ;
    }

    DWORD i;
    MQPROPERTYRESTRICTION *pPropRes;

    for (i = 0, pPropRes = paPropRes;
         (i < cRes) && !IS_PRIVATE_PROPID(pPropRes->prop);
         i++, pPropRes++)
	{
		NULL;
	}

    if (i < cRes)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 20);
    }

    return(MQ_OK);
}

/*====================================================

DSCreateObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSCreateObjectInternal( IN  DWORD                  dwObjectType,
                        IN  LPCWSTR                pwcsPathName,
                        IN  PSECURITY_DESCRIPTOR   pSecurityDescriptorIn,
                        IN  DWORD                  cp,
                        IN  PROPID                 aProp[],
                        IN  PROPVARIANT            apVar[],
                        IN  BOOL                   fIsKerberos,
                        OUT GUID*                  pObjGuid )
{
    BOOL fImpersonate;

    STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

    if (dwObjectType == MQDS_ENTERPRISE)
    {
        //
        // On Windows, we don't expect anyone to call this function and
        // create the enterprise object.
        //
        return LogHR(MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION, s_FN, 30);
    }
    else if (dwObjectType != MQDS_QUEUE)
    {
        //
        // The only instance when msmq application can create objects with
        // explicit security descriptor is when calling MQCreateQueue().
        // All other calls to this function are from msmq admin tools or
        // setup. These calls never pass a security descriptor. The code
        // below, SetDefaultValues(), will create a default descriptor for
        // msmq admin/setup objects.
        //
        if (pSecurityDescriptorIn != NULL)
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 40);
        }

        //
        // Security property should never be supplied.
        //
        PROPID pSecId = GetObjectSecurityPropid( dwObjectType ) ;
        if (pSecId != ILLEGAL_PROPID_VALUE)
        {
            for ( DWORD i = 0; i < cp ; i++ )
            {
                if (pSecId == aProp[i])
                {
                    ASSERT(0) ;
                    return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 50);
                }
            }
        }
    }

    HRESULT hr;
    DWORD cpObject;
    AP<PROPID> pPropObject = NULL;
    AP< PROPVARIANT> pVarObject = NULL;
    P<VOID> pDefaultSecurityDescriptor;
    P<BYTE> pMachineSid = NULL ;
    P<BYTE> pUserSid = NULL ;
    PSECURITY_DESCRIPTOR   pSecurityDescriptor = pSecurityDescriptorIn ;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        if (dwObjectType == MQDS_USER)
        {
            hr = MQSec_GetThreadUserSid(TRUE, (PSID*) &pUserSid, NULL, TRUE) ;
            if (FAILED(hr))
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 60);
                return MQ_ERROR_ILLEGAL_USER;
            }
            ASSERT(IsValidSid(pUserSid)) ;

            BOOL fAnonymus = MQSec_IsAnonymusSid( pUserSid ) ;
            if (fAnonymus)
            {
                return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 70);
            }
        }

        DWORD   cpEx = 0 ;
        PROPID  propIdEx = 0 ;
        PROPID *ppropIdEx = NULL ;

        if ((dwObjectType == MQDS_QUEUE) ||
            (dwObjectType == MQDS_SITE))
        {
            //
            // Fill with default vaules any missing part of the
            // security descriptor.
            //
            if (!pSecurityDescriptor)
            {
                //
                // If caller did not supply his own security descriptor then
                // create a default descriptor without owner. This is to
                // fix bug # 5286, that happen because of mismatch between
                // anonymous and guest. On win2k, we can create objects
                // without supplying owner. The active directory server will
                // add the owner from the impersonation token.
                // (note- on msmq1.0, the mqis implemented the security, so
                // it had to have a owner for each object).
                // Implementation- here we create a complete descriptor,
                // inlcuding owner. If eventually the call go to local active
                // directory, we'll remove the owner. If call is write-
                // requested to a MQIS server, the owner is needed.
                // The propid used here is a "dummy" one, used as place
                // holder to tell mqads code to remove the owner.
                //
                cpEx = 1 ;
                propIdEx = PROPID_Q_DEFAULT_SECURITY ;
                ppropIdEx = &propIdEx ;
            }

			//
			// Get queue computer sid, in order to add read permissions to the computer_name$
			//
			AP<BYTE> pComputerSid;
			if(dwObjectType == MQDS_QUEUE)
			{
				AP<WCHAR> pwcsMachineName;
				AP<WCHAR> pwcsQueueName;
				hr = MQDSSplitAndFilterQueueName(
								  pwcsPathName,
								  &pwcsMachineName,
								  &pwcsQueueName
								  );

	            if (SUCCEEDED(hr))
				{
					PROPID propidSid = PROPID_COM_SID;
					MQPROPVARIANT   PropVarSid;
					PropVarSid.vt = VT_NULL;

					CDSRequestContext RequestContext(e_DoNotImpersonate, e_IP_PROTOCOL);
					hr = MQDSGetProps( 
							MQDS_COMPUTER,
							pwcsMachineName,
							NULL,
							1,
							&propidSid,
							&PropVarSid, 
							&RequestContext
							);

					if (FAILED(hr))
					{
						//
						// Ignore errors
						//
						TrERROR(DS, "MQDSGetProps failed to get PROPID_COM_SID, hr = %!hresult!", hr);
						LogHR(hr, s_FN, 75);
					}
					else
					{
						pComputerSid = PropVarSid.blob.pBlobData;
						TrTRACE(DS, "Computer name = %ls, Computer sid = %!sid!", pwcsMachineName, pComputerSid);
					}
				}
			}            
			
			hr = MQSec_GetDefaultSecDescriptor( 
						dwObjectType,
						&pDefaultSecurityDescriptor,
						fImpersonate,
						pSecurityDescriptor,
						0, // seInfoToRemove,
						e_UseDefaultDacl,
						pComputerSid
						);

            if (FAILED(hr))
            {
                ASSERT(SUCCEEDED(hr));
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 80);
                return MQ_ERROR_ACCESS_DENIED;
            }
            pSecurityDescriptor = pDefaultSecurityDescriptor;
        }

        //
        //  Set default values for all the object properties,
        //  that were not provided by the caller
        //
        hr = SetDefaultValues(
                    dwObjectType,
                    pSecurityDescriptor,
                    pUserSid,
                    cp,
                    aProp,
                    apVar,
                    &cpObject,
                    &pPropObject,
                    &pVarObject);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 90);
        }

        if (dwObjectType == MQDS_USER)
        {
            hr = VerifyInternalCert( cpObject,
                                     pPropObject,
                                     pVarObject,
                                    &pMachineSid );
            if (FAILED(hr))
            {
                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 100);
            }
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        if (dwObjectType == MQDS_MACHINE)
        {
            //
            // Bug 5241.
            // To support setup from nt4 machines, or win9x ones, when
            // logged on user is nt4 user. This setting (when fIsKerberos is
            // FALSE) will cause dscore to use server binding
            // (LDPA://server/path). Server binding is needed when called
            // from nt4 users.
            // For all other types of objects, the dscore code know how to
            // handle such nt4 users correctly.
            //
            requestContext.SetKerberos( fIsKerberos ) ;
        }

        hr = MQDSCreateObject( dwObjectType,
                               pwcsPathName,
                               cpObject,
                               pPropObject,
                               pVarObject,
                               cpEx,
                               ppropIdEx,
                               NULL,
                               &requestContext,
                               pObjGuid);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
            return LogHR(hr, s_FN, 110);
        }

        return LogHR(hr, s_FN, 120);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to create %ls in DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSCreateObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateObject( IN  DWORD                  dwObjectType,
                IN  LPCWSTR                pwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT GUID*                  pObjGuid )
{
    HRESULT hr = DSCreateObjectInternal( dwObjectType,
                                         pwcsPathName,
                                         pSecurityDescriptor,
                                         cp,
                                         aProp,
                                         apVar,
                                         TRUE /* fKerberos */,
                                         pObjGuid ) ;
    return LogHR(hr, s_FN, 2130);
}

/*====================================================

DSDeleteObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT DSDeleteObjectInternal( IN  DWORD    dwObjectType,
                                IN  LPCWSTR  pwcsPathName )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext( fImpersonate, e_IP_PROTOCOL);

        hr = MQDSDeleteObject( dwObjectType,
                               pwcsPathName,
                               NULL,
                               &requestContext) ;
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 140);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        TrERROR(DS, "Failed to delete %ls in DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSDeleteObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObject( IN  DWORD     dwObjectType,
                IN  LPCWSTR   pwcsPathName )
{
    HRESULT hr = DSDeleteObjectInternal( dwObjectType,
                                         pwcsPathName ) ;
    return LogHR(hr, s_FN, 170);
}

/*====================================================

DSGetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectProperties(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[])
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 180);
        }
        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetProps( dwObjectType,
                           pwcsPathName,
                           NULL,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 190);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get propeties for %ls from DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectPropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectPropertiesInternal( IN  DWORD         dwObjectType,
                               IN  LPCWSTR       pwcsPathName,
                               IN  DWORD         cp,
                               IN  PROPID        aProp[],
                               IN  PROPVARIANT   apVar[] )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        //
        //  Only for RPC calls we would like to continue and verify which props 
        //  are asked for ( and this is only to keep the same functionalty as before).
        //  For QM calls we want to enable also retrive of "private" properties and thus
        //  to eliminate the need to call GetObjectSecurity...
        //
        if (fImpersonate)
        {
            hr = ValidateProperties(cp, aProp);
            if (!SUCCEEDED(hr))
            {
                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 210);
            }
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSSetProps(  dwObjectType,
                            pwcsPathName,
                            NULL,
                            cp,
                            aProp,
                            apVar,
                            &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 220);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to set propeties for %ls in DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectProperties(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[])
{
    HRESULT hr = DSSetObjectPropertiesInternal( dwObjectType,
                                                pwcsPathName,
                                                cp,
                                                aProp,
                                                apVar ) ;
    return LogHR(hr, s_FN, 240);
}

/*====================================================

DSLookupBegin

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupBegin(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume)
{
    HRESULT hr;
    BOOL fImpersonate;
    *phEnume = NULL;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(pColumns->cCol, fImpersonate);

        if (pRestriction)
        {
            hr = ValidateRestrictions(pRestriction->cRes, pRestriction->paPropRes);
            if (!SUCCEEDED(hr)) {

                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 250);
            }
        }

       if ( pColumns->cCol == 0)
       {
            return LogHR(MQ_ERROR_ILLEGAL_MQCOLUMNS, s_FN, 260);
       }
       hr = ValidateProperties(pColumns->cCol, pColumns->aCol);


        if (!SUCCEEDED(hr)) {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 270);
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSLookupBegin( pwcsContext,
                              pRestriction,
                              pColumns,
                              pSort,
                              phEnume,
                              &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 280);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to begin lookup in DS because of insufficient resources.");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSLookupNaxt

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupNext(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[])
{
    HRESULT hr;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {

        hr = MQDSLookupNext( hEnum,
                             pcProps,
                             aPropVar);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 300);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "DSLookupNext Failed because of insufficient resources.");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}


/*====================================================

DSLookupEnd

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupEnd(
                IN  HANDLE                  hEnum)
{
    HRESULT hr;

    if ( hEnum == 0 )
    {
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 320);
    }

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        hr = MQDSLookupEnd( hEnum);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 330);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "DSLookupEnd Failed because of insufficient resources.");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSServerInit

Arguments:

  See ..\mqdscli\dsapi.cpp

Return Value:

=====================================================*/

extern HMODULE  g_hInstance ;

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSServerInit( 
	VOID
	)
{
#ifdef _DEBUG
    TCHAR tszFileName[MAX_PATH * 2 + 1] = L"";
    DWORD dwGet = GetModuleFileName( 
						g_hInstance,
						tszFileName,
						STRLEN(tszFileName) 
						);
    if (dwGet)
    {
        DWORD dwLen = lstrlen( tszFileName );
        lstrcpy(&tszFileName[ dwLen - 3 ], TEXT("ini"));

        UINT uiDbg = GetPrivateProfileInt(
						TEXT("Debug"),
						TEXT("StopBeforeInit"),
						0,
						tszFileName 
						);
        if (uiDbg)
        {
            ASSERT(0);
        }
    }
#endif

    HRESULT hr = MQ_OK;

    //
    //  Init DS provider
    //
    hr = MQDSInit();

    if ( FAILED(hr))
    {
        LogHR(hr, s_FN, 360);
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        if (hr == MQ_ERROR_NOT_TRUSTED_DELEGATION)
        {
            ; // do nothing more
        }
        else
        {
			hr = MQ_ERROR_NO_DS;
        }
        return hr;
    }
    else
    {
		//
		// Update the access count to the server (performace info only)
		//
		UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)
    }

    //
    // Init RPC interface of this site controller
    // Not needed in setup mode.
	//
    RPC_STATUS status = RpcServerInit();
    LogRPCStatus(status, s_FN, 400);

    return hr;
}


/*====================================================

DSGetObjectSecurity

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                  pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetObjectSecurity(dwObjectType,
                                   pwcsPathName,
                                   NULL,
                                   RequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthNeeded,
                                   &requestContext);

        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 410);
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return(hr);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get security for %ls from DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectSecurity

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSSetObjectSecurity(dwObjectType,
                                   pwcsPathName,
                                   NULL,
                                   SecurityInformation,
                                   pSecurityDescriptor,
                                   &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 430);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to set security for %ls in DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}
/*====================================================

DSGetObjectSecurityGuid

Arguments:

Return Value:


=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr;
    BOOL fImpersonate;
	//
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        if ((RequestedInformation & MQDS_PUBLIC_KEYS_INFO_ALL) != 0)
        {
			ASSERT((RequestedInformation & ~MQDS_PUBLIC_KEYS_INFO_ALL) == 0);
			ASSERT(RequestedInformation != MQDS_PUBLIC_KEYS_INFO_ALL);
			ASSERT(((RequestedInformation & MQDS_SIGN_PUBLIC_KEY) == 0) || 
				   ((dwObjectType == MQDS_MACHINE) || (dwObjectType == MQDS_SITE)));
			ASSERT(((RequestedInformation & MQDS_KEYX_PUBLIC_KEY) == 0) || 
				   (dwObjectType == MQDS_MACHINE));
            //
            // We bypass ADS access check and make this query with the
            // credential of local msmq service. This query fetch the
            // public key of a machine from ADS, so it's not a serious
            // security hole.
            // hey, "public key" is a public domain data, isn't it ?
            //
            // The reason we absolutely need this hole is as follow:
            // in mixed mode, if Windows ex-PEC renew its crypto keys,
            // all NT4 PSC will call this function to retrieve the new
            // public key. NT4 msmq service is impersonated as anonymous
            // user. If DACL is such that this query fail for anonymous
            // user, then all NT4 PSCs can no longer get replications from
            // Windows AD world.
            // So the possible damage is orders of magnitude more severe
            // than the possible hole opened here.
            //
            fImpersonate = FALSE ;
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetObjectSecurity(dwObjectType,
                                   NULL,
                                   pObjectGuid,
                                   RequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthNeeded,
                                   &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 450);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get security guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectSecurityGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  BOOL                    fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSSetObjectSecurity(dwObjectType,
                                   NULL,
                                   pObjectGuid,
                                   SecurityInformation,
                                   pSecurityDescriptor,
                                   &requestContext);
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 470);
            if ((dwObjectType == MQDS_QUEUE) &&
                ((SecurityInformation & OWNER_SECURITY_INFORMATION) ==
                                               OWNER_SECURITY_INFORMATION))
            {
                //
                // On Windows, queue may be created by local msmq service
                // on behalf of users on local machine. In that case, the
                // owner is the computer account, not the user. So for
                // not breaking existing applications, we won't fail
                // this call if owner was not set. rather, we'll ignore
                // the owner.
                //
                SecurityInformation &= (~OWNER_SECURITY_INFORMATION) ;
                if (SecurityInformation != 0)
                {
                    //
                    // If caller wanted to change only owner, and first
                    // try failed, then don't try again with nothing...
                    //
                    hr = MQDSSetObjectSecurity( dwObjectType,
                                                NULL,
                                                pObjectGuid,
                                                SecurityInformation,
                                                pSecurityDescriptor,
                                               &requestContext );
                    if (hr == MQ_OK)
                    {
                        hr = MQ_INFORMATION_OWNER_IGNORED ;
                    }
                    LogHR(hr, s_FN, 475) ;
                }
            }
        }

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return (hr);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to set security guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr =DSSetObjectSecurityGuidInternal(
                                        dwObjectType,
                                        pObjectGuid,
                                        SecurityInformation,
                                        pSecurityDescriptor,
                                        TRUE /* fKerberos */) ;
    return hr ;
}

/*====================================================

DSDeleteObjectGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT DSDeleteObjectGuidInternal( IN  DWORD        dwObjectType,
                                    IN  CONST GUID*  pObjectGuid,
                                    IN  BOOL         fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSDeleteObject( dwObjectType,
                               NULL,
                               pObjectGuid,
                               &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 490);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to delete object guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

}
/*====================================================

DSDeleteObjectGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObjectGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid)
{
    HRESULT hr = DSDeleteObjectGuidInternal( dwObjectType,
                                             pObjectGuid,
                                             TRUE /* fKerberos */) ;
    return LogHR(hr, s_FN, 510);
}

/*====================================================

DSGetObjectPropertiesGuid

Arguments:

Return Value:


=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 520);
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetProps( dwObjectType,
                           NULL,
                           pObjectGuid,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 530);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get object propeties by guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectPropertiesGuidIntenral

Arguments:

Return Value:


=====================================================*/

HRESULT
DSSetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 560);
        }


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSSetProps(  dwObjectType,
                            NULL,
                            pObjectGuid,
                            cp,
                            aProp,
                            apVar,
                            &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 570);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to set object propeties by guid in DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSSetObjectPropertiesGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr = DSSetObjectPropertiesGuidInternal( dwObjectType,
                                                    pObjectGuid,
                                                    cp,
                                                    aProp,
                                                    apVar,
                                                    TRUE /* fKerberos */) ;
    return hr ;
}


/*====================================================

DSGetUserParams

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetUserParams(
    DWORD dwFlags,
    DWORD dwSidLength,
    PSID pUserSid,
    DWORD *pdwSidReqLength,
    LPWSTR szAccountName,
    DWORD *pdwAccountNameLen,
    LPWSTR szDomainName,
    DWORD *pdwDomainNameLen
    )
{
    HRESULT hr = MQ_OK;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    BOOL fImpersonate;
    STORE_AND_CLEAR_IMPERSONATION_FLAG(dwSidLength, fImpersonate);

    try
    {
        if (dwFlags & GET_USER_PARAM_FLAG_SID)
        {
            //
            // Get the SID of the calling user.
            //
            AP<char> pSDOwner;
            PSID pOwner;
            BOOL bDefaulted;

            // Get the default security descriptor and extract the owner.
            hr = MQSec_GetDefaultSecDescriptor( MQDS_QUEUE,
                                   (PSECURITY_DESCRIPTOR*)(char*)&pSDOwner,
                                          fImpersonate,
                                          NULL,
                                          DACL_SECURITY_INFORMATION, // seInfoToRemove
                                          e_UseDefaultDacl ) ;
            ASSERT(SUCCEEDED(hr)) ;
            if (FAILED(hr))
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 640);
                return MQ_ERROR_ACCESS_DENIED;
            }

            BOOL bRet = GetSecurityDescriptorOwner( pSDOwner,
                                                   &pOwner,
                                                   &bDefaulted );
            ASSERT(bRet);

            BOOL fAnonymus = MQSec_IsAnonymusSid( pOwner ) ;
            if (fAnonymus)
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
                return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 650);
            }

            // Prepare the result.
            *pdwSidReqLength = GetLengthSid(pOwner);
            ASSERT(*pdwSidReqLength);
            if (dwSidLength >= *pdwSidReqLength)
            {
                bRet = CopySid(dwSidLength, pUserSid, pOwner);
                ASSERT(bRet);
                hr = MQ_OK;
            }
            else
            {
                // Buffer is too small.
                hr = MQ_ERROR_SENDERID_BUFFER_TOO_SMALL;
            }
        }

        if (SUCCEEDED(hr) && (dwFlags & GET_USER_PARAM_FLAG_ACCOUNT))
        {
            //
            // Get the account name and account domain of the calling user.
            //
            char Sid_buff[64];
            PSID pLocSid;
            AP<char> pLongSidBuff;

            //
            // Get the SID of the calling user. Either use the value that was
            // previously obtained in this call, or call this function with
            // the GET_USER_PARAM_FLAG_SID flags set.
            //
            if (dwFlags & GET_USER_PARAM_FLAG_SID)
            {
                pLocSid = pUserSid;
            }
            else
            {
                DWORD dwReqLen;

                pLocSid = (PSID)Sid_buff;
                hr = DSGetUserParams(
                        GET_USER_PARAM_FLAG_SID,
                        (DWORD)sizeof(Sid_buff) |
                            (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                        pLocSid,
                        &dwReqLen,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
                if (FAILED(hr))
                {
                    if (hr == MQ_ERROR_SENDERID_BUFFER_TOO_SMALL)
                    {
                        pLocSid = pLongSidBuff = new char[dwReqLen];
                        hr = DSGetUserParams(
                                GET_USER_PARAM_FLAG_SID,
                                dwReqLen |
                                    (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                                pLocSid,
                                &dwReqLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                SID_NAME_USE eUse;
                if (!LookupAccountSid(
                        NULL,
                        pLocSid,
                        szAccountName,
                        pdwAccountNameLen,
                        szDomainName,
                        pdwDomainNameLen,
                        &eUse))
                {
                    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        *szAccountName = '\0';
                        *szDomainName = '\0';
                        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
                    }
                    else
                    {
                        hr = MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO;
                    }
                }
            }
            else
            {
                if (hr != MQ_ERROR_ILLEGAL_USER)
                {
                    hr = MQ_ERROR_COULD_NOT_GET_USER_SID;
                }
                else
                {
                    // The error was already counted.
                    return LogHR(hr, s_FN, 660);
                }
            }
        }
    }
    catch(const bad_alloc&)
    {
        TrERROR(DS, "Failed to get user prams from DS because of insufficient resources.");
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 670);
}

/*====================================================

DSTerminate

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSTerminate()
{
    //
    //  Terminate DS provider
    //
    MQDSTerminate();
}

static
HRESULT
CallSignProc(
	DSQMChallengeResponce_ROUTINE pChallenge,
	BYTE    *pbChallenge,
	DWORD   dwChallengeSize,
	DWORD_PTR dwContext,
	BYTE    *pbSignature,
	DWORD   *pdwSignatureSize,
	DWORD   dwSignatureMaxSize
	)
{
	RpcTryExcept
	{
		return pChallenge(
				pbChallenge,
				dwChallengeSize,
				dwContext,
				pbSignature,
				pdwSignatureSize,
				dwSignatureMaxSize
				);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		DWORD gle = GetExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		return HRESULT_FROM_WIN32(gle);
	}
	RpcEndExcept
}

/*====================================================

DSQMSetMachineProperties

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMSetMachineProperties(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           aProp[],
    IN  PROPVARIANT      apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR        dwContext
    )
{
    HRESULT hr;
    BYTE abChallenge[32];
    DWORD dwChallengeSize = sizeof(abChallenge);
    memset(abChallenge, 0 , dwChallengeSize);
    BYTE abSignature[128];
    DWORD dwSignatureMaxSize = sizeof(abSignature);
	memset(abSignature, 0 , dwSignatureMaxSize);

    DWORD dwSignatureSize = 0;
    

    BOOL fImpersonate;
    STORE_AND_CLEAR_IMPERSONATION_FLAG(cp, fImpersonate);

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {

        //
        // Generate the challenge.
        //
        HCRYPTPROV  hProv = NULL ;
        hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                         &hProv ) ;
        if (!hProv || !CryptGenRandom(hProv, dwChallengeSize, abChallenge))
        {
            hr = MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
        else
        {
            //
            // Call back to sign the challenge and the properties.
            //
            hr = CallSignProc(
            		pfSignProc,
                    abChallenge,
                    dwChallengeSize,
                    dwContext,
                    abSignature,
                    &dwSignatureSize,
                    dwSignatureMaxSize
                    );

            if (SUCCEEDED(hr))
            {
                //
                // Call MQIS. It'll validate the signature. If the signature is OK,
                // it'll set the properties.
                //
                hr = MQDSQMSetMachineProperties(
                        pwcsPathName,
                        cp,
                        aProp,
                        apVar,
                        abChallenge,
                        dwChallengeSize,
                        abSignature,
                        dwSignatureSize);
            }
        }

        if (FAILED(hr))
        {
            //
            // If we failed to set the properties by signing the properties,
            // try to do this in the usual way.
            //
            hr = DSSetObjectProperties(
                    MQDS_MACHINE | (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                    pwcsPathName,
                    cp,
                    aProp,
                    apVar);
        }
    }
    catch(const bad_alloc&)
    {
        TrERROR(DS, "Failed to set machine properties for %ls because of insufficient resources.", pwcsPathName);
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 673);
}

/*======================================================================

 DSCreateServersCache

This function is called only from local QM, only on MQIS servers. It's
never called from clients through RPC. The RPC calls from clients are
processed in dsifsrv.cpp, where results are read from registry, without
querying local MQIS database.

Arguments:      None

Return Value:   None

========================================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateServersCache()
{
    HRESULT hr = MQDSCreateServersCache() ;
    return LogHR(hr, s_FN, 676);
}

/*====================================================

DSQMGetObjectSecurity

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMGetObjectSecurity(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    )
{
    HRESULT hr;
    BYTE abChallenge[32];
    DWORD dwChallengeSize = sizeof(abChallenge);
    BYTE abChallengeResponce[128];
    DWORD dwChallengeResponceMaxSize = sizeof(abChallengeResponce);
    DWORD dwChallengeResponceSize = 0;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        BOOL fTryUsualWay = TRUE ;
        //
        // Generate the challenge.
        //
        HCRYPTPROV  hProv = NULL ;
        hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                         &hProv ) ;
        if (!hProv || !CryptGenRandom(hProv, dwChallengeSize, abChallenge))
        {
            hr = MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
        else
        {
            hr = CallSignProc(
					pfChallengeResponceProc,
					abChallenge,
					dwChallengeSize,
					dwContext,
					abChallengeResponce,
					&dwChallengeResponceSize,
					dwChallengeResponceMaxSize
					);

            if (SUCCEEDED(hr))
            {
                //
                // Call MQIS. It'll validate the challenge responce. If the
                // challenge responce is OK, it'll set the properties.
                //
                hr = MQDSQMGetObjectSecurity(
                        dwObjectType,
                        pObjectGuid,
                        RequestedInformation,
                        pSecurityDescriptor,
                        nLength,
                        lpnLengthNeeded,
                        abChallenge,
                        dwChallengeSize,
                        abChallengeResponce,
                        dwChallengeResponceSize);

                if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
                {
                    //
                    // that's a "good" error, and caller should allocate
                    // a buffer. Don't try to call again the "usual" way.
                    //
                    fTryUsualWay = FALSE ;
                }
            }
        }

        if (FAILED(hr) && fTryUsualWay)
        {
            //
            // If we failed to get the security by signing the challenge,
            // try to do this in the usual way.
            //
            hr = DSGetObjectSecurityGuid(
                    dwObjectType | (dwContext ? IMPERSONATE_CLIENT_FLAG : 0),
                    pObjectGuid,
                    RequestedInformation,
                    pSecurityDescriptor,
                    nLength,
                    lpnLengthNeeded);

            if ( ((hr == MQ_ERROR_ACCESS_DENIED) ||
                  (hr == E_ADS_BAD_PATHNAME))              &&
                (RequestedInformation & SACL_SECURITY_INFORMATION))
            {
                //
                // Return this error to be compatible with msmq1.0 machines.
                // They'll try to retrieve the security descriptor without
                // the SACL.
                // Otherwise, a nt4 machine without crypto functionality
                // (for example- french machines or nt4 cluster) won't be
                // able to boot.
                //
                hr = MQ_ERROR_PRIVILEGE_NOT_HELD ;
            }
        }
    }
    catch(const bad_alloc&)
    {
        TrERROR(DS, "Failed to get object security by guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 690);
}



/*====================================================

DSGetComputerSites

Arguments:

Return Value:


=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
{
    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)
    HRESULT hr;

    try
    {
        hr = MQDSGetComputerSites(
                    pwcsComputerName,
                    pdwNumSites,
                    ppguidSites
                    );
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 730);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get computer sites for %ls from DS because of insufficient resources.", pwcsComputerName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSGetObjectPropertiesEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesEx(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[] )
                       /*IN  BOOL                     fSearchDSserver )*/
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetPropsEx(
                           dwObjectType,
                           pwcsPathName,
                           NULL,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 750);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get propeties for %ls from DS because of insufficient resources.", pwcsPathName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

/*====================================================

DSGetObjectPropertiesGuidEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:


=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuidEx(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] )
                /*IN  BOOL                     /*fSearchDSserver) */
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetPropsEx(
                           dwObjectType,
                           NULL,
                           pObjectGuid,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 770);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        TrERROR(DS, "Failed to get object propeties by guid from DS because of insufficient resources. %!guid!", pObjectGuid);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

//+---------------------------------------
//
//  DSRelaxSecurity
//
//+---------------------------------------

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSRelaxSecurity( DWORD dwRelaxFlag )
{
    HRESULT hr = MQDSRelaxSecurity( dwRelaxFlag ) ;
    return LogHR(hr, s_FN, 790);
}

//+-----------------------------------------
//
//   DSGetGCListInDomainInternal
//
//+-----------------------------------------

HRESULT
DSGetGCListInDomainInternal(
	IN  LPCWSTR     pwszComputerName,
	IN  LPCWSTR     pwszDomainName,
	OUT LPWSTR     *lplpwszGCList 
	)
{
    HRESULT hr;

    try
    {
        //
        // Update the access count to the server (performace info only)
        //
        UPDATE_COUNTER(&g_pdsCounters->nAccessServer,
                        g_pdsCounters->nAccessServer++);

        hr = MQDSGetGCListInDomain(
                 pwszComputerName,
                 pwszDomainName,
                 lplpwszGCList 
				 );
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                        g_pdsCounters->nErrorsReturnedToApp++);

        TrERROR(DS, "Failed to get GC list for %ls in domain %ls, because of insufficent resources.", pwszComputerName, pwszDomainName);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    return LogHR(hr, s_FN, 800);
}


//+---------------------------------------
//
//  DSExSetTimer
//
//+---------------------------------------

void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSExSetTimer( 
    CTimer* pTimer,
    const CTimeDuration& Timeout
	)
{
    MQDSExSetTimer(pTimer, Timeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\midlproc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    midlproc.cpp

Abstract:

Author:

    Ronit Hartmann(ronith)

--*/

#include "stdh.h"
#include "dscomm.h"
#include "ds.h"
#include "notifydl.h"

#include "midlproc.tmh"

extern "C" void  __RPC_USER PCONTEXT_HANDLE_TYPE_rundown(PCONTEXT_HANDLE_TYPE phContext)
{
	 DSLookupEnd(phContext);
}


extern "C" void __RPC_USER PCONTEXT_HANDLE_READONLY_TYPE_rundown(PCONTEXT_HANDLE_READONLY_TYPE /* phContext */)
{
    //
    // Obsolete
    //
}

extern "C" void __RPC_USER PCONTEXT_HANDLE_DELETE_TYPE_rundown(PCONTEXT_HANDLE_DELETE_TYPE phContext)
{
    CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)phContext;
    delete pDelNotification;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\dsifsrv.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    dsifrpc.cpp

Abstract:

    Implementation of MQIS CLIENT-SERVER API interface, server side.

Author:

    ronit hartmann (ronith)
    Doron Juater   (DoronJ)  25-May-1997, copied from rpcsrv.cpp

--*/

#include "stdh.h"
#include "mqds.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "servlist.h"
#include "notifydl.h"
#include "dscomm.h"
#include <mqkeyhlp.h>
#include <mqsec.h>
#include <_mqrpc.h>
#include <dscore.h>
#include <tr.h>
#include <strsafe.h>


#include "dsifsrv.tmh"

static WCHAR *s_FN=L"mqdssrv/dsifsrv";

HRESULT
DSGetGCListInDomainInternal(
	IN  LPCWSTR     pwszComputerName,
	IN  LPCWSTR     pwszDomainName,
	OUT LPWSTR     *lplpwszGCList 
	);


/*====================================================

RoutineName: SignProperties

Arguments:

Return Value:

=====================================================*/

static 
HRESULT
SignProperties( 
	DWORD cp,
	PROPID aProp[  ],
	PROPVARIANT apVar[  ],
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE pbServerSignature,
	DWORD* pdwServerSignatureSize
	)
{
    //
    // SSL server authentication should not be used when using Kerberos.
    // For Kerberos, we're using the built in mutual authentication feature.
    //
    ASSERT(g_hProvVer);

    if (pServerAuthCtx == NULL)
    {
		TrERROR(DS, "pServerAuthCtx is NULL");
		return MQ_ERROR_INVALID_PARAMETER;
    }

	DWORD dwServerSignatureSize = *pdwServerSignatureSize;

	if (pbServerSignature == NULL)
	{
		dwServerSignatureSize = 0;
	}
	
	*pdwServerSignatureSize = 0;

    //
    // Create a hash object.
    //
    CHCryptHash hHash;

    if (!CryptCreateHash(g_hProvVer, CALG_MD5, NULL, 0, &hHash))
    {
        DWORD gle = GetLastError();
		TrERROR(DS, "CryptCreateHash() failed. %!winerr!", gle);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    //
    // Hash the properties.
    //
    HRESULT hr = HashProperties(hHash, cp, aProp, apVar);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    if (dwServerSignatureSize <= pServerAuthCtx->cbHeader + pServerAuthCtx->cbTrailer)
	{
		TrERROR(DS, "pbServerSignature is too small");
		return MQ_ERROR_USER_BUFFER_TOO_SMALL;
	}

	//
	// Need to initialize the allocated server buffer.
	// This buffer will not be initialized in case of error.
	// The allocated buffer is returned to the user so it need to be initialized
	//
    memset(pbServerSignature, 0, dwServerSignatureSize);

    //
    // Get the hash value.
    //
    DWORD dwHashSize = dwServerSignatureSize - pServerAuthCtx->cbHeader - pServerAuthCtx->cbTrailer;
    PBYTE pbHashVal = pbServerSignature + pServerAuthCtx->cbHeader;

    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHashVal, &dwHashSize, 0))
    {
        DWORD dwErr = GetLastError();
        LogHR(dwErr, s_FN, 60);

        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    //
    // Seal the hash value.
	//
    *pdwServerSignatureSize = pServerAuthCtx->cbHeader + dwHashSize + pServerAuthCtx->cbTrailer;
    hr = MQSealBuffer(pServerAuthCtx->pvhContext, pbServerSignature, *pdwServerSignatureSize);

    return LogHR(hr, s_FN, 70);
}

/*====================================================

RoutineName: SignBuffer

Arguments:

Return Value:

=====================================================*/

HRESULT
SignBuffer(
    DWORD cbSize,
    PBYTE pBuffer,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
    PBYTE pbServerSignature,
    DWORD *pdwServerSignatureSize)
{
    //
    // Make the buffer in a form of a VT_BLOB PROPVARIANT and sign it.
    //
    PROPVARIANT PropVar;

    PropVar.vt = VT_BLOB;
    PropVar.blob.cbSize = cbSize;
    PropVar.blob.pBlobData = pBuffer;

    HRESULT hr2 = SignProperties(
							1,
							NULL,
							&PropVar,
							pServerAuthCtx,
							pbServerSignature,
							pdwServerSignatureSize
							);
    return LogHR(hr2, s_FN, 80);
}

//+-----------------------------------------------------------------------
//
//  BOOL CheckAuthLevel()
//
//  Check that the authentication level is at least the packet level. We
//  allow the connect level only if the user is the guest user or the
//  anonymous user.
//
//+-----------------------------------------------------------------------

BOOL CheckAuthLevel( IN handle_t hBind,
                     OUT ULONG  *pulAuthnSvc = NULL )
{
    RPC_STATUS Status;
    ULONG      ulAuthnLevel;

    ULONG  ulAuthnSvc ;
    ULONG *pSvc = pulAuthnSvc ;
    if (!pSvc)
    {
        pSvc = &ulAuthnSvc ;
    }
    *pSvc = 0 ;

    Status = RpcBindingInqAuthClient(hBind,
                                     NULL,
                                     NULL,
                                     &ulAuthnLevel,
                                     pSvc,
                                     NULL);
    if((Status == RPC_S_OK) &&
       ((*pSvc == RPC_C_AUTHN_WINNT) || (*pSvc == RPC_C_AUTHN_GSS_KERBEROS)) &&
       (ulAuthnLevel >= RPC_C_AUTHN_LEVEL_PKT))
    {
        //
        // Authentication level is high enough.
        //
        return TRUE;
    }

    LogRPCStatus(Status, s_FN, 90);

    //
    // We have low authentication level, verify that the user is the guest
    // user, or the anonymous user, i.e., an un-authenticated user.
    //

    BOOL fUnAuthenticated ;
    HRESULT hr = MQSec_IsUnAuthenticatedUser(&fUnAuthenticated) ;
    LogHR(hr, s_FN, 100);

    return(SUCCEEDED(hr) && fUnAuthenticated) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT  _CheckIfGoodServer()
//
//  see mqdscore\dsntlm.cpp for explanation regarding ntlm support.
//
//  Parameters-
//      pKerberosUser: return TRUE if rpc call can be considered as
//          Kerberos.  This mean the call is either local (local rpc protocol)
//          or come on wire and was authenticated with Kerberos. See
//          DeleteObjectGuid for its main use.
//
//+-----------------------------------------------------------------------

static
HRESULT 
_CheckIfGoodServer( 
	OUT BOOL     *pKerberosUser,
	ULONG         ulAuthnSvc,
	DWORD         dwObjectType,
	LPCWSTR       pwcsPathName,
	const GUID   *pObjectGuid,
	IN DWORD              cProps,
	IN const PROPID      *pPropIDs = NULL,
	IN enum enumNtlmOp    eNtlmOp  = e_Create
	)
{
    if (pKerberosUser)
    {
        *pKerberosUser = TRUE ;
    }

    if (ulAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
    {
        return MQ_OK ;
    }

    if (pKerberosUser)
    {
        *pKerberosUser = FALSE ;
    }

    //
    // We need the propid (in MQDSCore) to chose the right object
    // context in the DS. When calling MQSetSecurity(), or DSDelete(),
    // caller do not provide a propid, so generate it here.
    //
    PROPID PropIdSec = 0 ;
    PROPID *pPropId = const_cast<PROPID*> (pPropIDs) ;

    if (pPropId == NULL)
    {
        switch ( dwObjectType)
        {
            case MQDS_QUEUE:
                PropIdSec = PROPID_Q_SECURITY;
                break;

            case MQDS_MACHINE:
                PropIdSec = PROPID_QM_SECURITY;
                break;

            case MQDS_SITE:
                PropIdSec = PROPID_S_SECURITY;
                break;

            case MQDS_USER:
                PropIdSec = PROPID_U_ID ;
                break ;

            case MQDS_ENTERPRISE:
            default:
                //
                // Enterprise object is alwasy accessible from local server.
                //
                return(MQ_OK);
                break;
        }
        pPropId = &PropIdSec ;
        cProps = 1 ;
    }

    HRESULT hr = DSCoreCheckIfGoodNtlmServer( dwObjectType,
                                              pwcsPathName,
                                              pObjectGuid,
                                              cProps,
                                              pPropId,
                                              eNtlmOp ) ;
    if (hr == MQ_ERROR_NO_DS)
    {
        TrTRACE(DS, "MQDSSRV: Refusing to NTLM client, ObjType- %lut, eNtlmOp- %lut",dwObjectType, eNtlmOp);
    }
    return LogHR(hr, s_FN, 110);
}

//+---------------------------------------------------------------------
//
//  BOOL IsQueryImpersonationNeeded()
//
//  return TRUE if impersonation is needed on the ADS operation.
//
//+---------------------------------------------------------------------

static BOOL IsQueryImpersonationNeeded()
{
    static BOOL s_fAlreadyInit = FALSE;
    static BOOL s_fNeedQueryImpersonation = TRUE;

    if (s_fAlreadyInit)
    {
        return s_fNeedQueryImpersonation;
    }

    //
    // In the NameStyle property of the MSMQService object we keep the
    // global "relaxation" flag. If set, we do not impersonate on any
    // query. So all Get/Locate operation are enabled to everyone.
    // This is needed in order to support nt4 and local users without
    // asking admin to do any manual setting.
    // Read now the NameStyle flag.
    // if flag is FALSE, the relaxation is not enabled and we'll
    // impersonate the caller.
    //
    CDSRequestContext requestContext(e_DoNotImpersonate, e_ALL_PROTOCOLS);
    PROPID PropId = PROPID_E_NAMESTYLE;
    PROPVARIANT var;
    var.vt = VT_NULL;

    HRESULT hr = MQDSGetProps( 
						MQDS_ENTERPRISE,
						NULL,
						NULL,
						1,
						&PropId,
						&var,
						&requestContext
						);

    LogHR(hr, s_FN, 120);

    if (SUCCEEDED(hr) && (var.bVal != MQ_E_RELAXATION_DEFAULT))
    {
        s_fNeedQueryImpersonation = !(var.bVal);

        if (!s_fNeedQueryImpersonation)
        {
            TrTRACE(DS, "MQDSSRV: Relaxing security.");
        }
    }

    s_fAlreadyInit = TRUE;
    return s_fNeedQueryImpersonation;
}

/*====================================================

RoutineName: SecurityInformationValidation

Arguments:

Return Value: void

=====================================================*/
static
void 
SecurityInformationValidation(
        DWORD                   dwObjectType,
        SECURITY_INFORMATION    SecurityInformation
		)
{
	BOOL	fPublicKeysSecurityInformation	= (SecurityInformation & MQDS_PUBLIC_KEYS_INFO_ALL)  != 0;
	BOOL	fStandardSecurityInformation	= (SecurityInformation & ~MQDS_PUBLIC_KEYS_INFO_ALL) != 0;

	if (SecurityInformation == 0)
	{
		//
		// No Security Information input.
		//
		TrERROR(RPC, "No Security Information input.");
		ASSERT_BENIGN(("No Security Information input.", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if (fPublicKeysSecurityInformation && fStandardSecurityInformation)
	{
		//
		// A Public Key flag is set and a Standard flag is also set.
		//
		TrERROR(RPC, "A Public Key flag is set and a Standard flag is also set");
		ASSERT_BENIGN(("A Public Key flag is set and a Standard flag is also set", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if (SecurityInformation == MQDS_PUBLIC_KEYS_INFO_ALL)
	{
		//
		// Both Public Key flags are set.
		//
		TrERROR(RPC, "Both Public Key flags are set");
		ASSERT_BENIGN(("Both Public Key flags are set", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if (((SecurityInformation & MQDS_SIGN_PUBLIC_KEY) != 0) && 
	    (dwObjectType != MQDS_MACHINE) && (dwObjectType != MQDS_SITE))
	{
		//
		//Sign Public Key flag is set for improper object type.
		//
		TrERROR(RPC, "Sign Public Key flag is set for improper object type");
		ASSERT_BENIGN(("Sign Public Key flag is set for improper object type", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if (((SecurityInformation & MQDS_KEYX_PUBLIC_KEY) != 0) && 
	    (dwObjectType != MQDS_MACHINE)) 
	{
		//
		//Encryption Public Key flag is set for improper object type.
		//
		TrERROR(RPC, "Encryption Public Key flag is set for improper object type");
		ASSERT_BENIGN(("Encryption Public Key flag is set for improper object type", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
}

/*====================================================

RoutineName: S_DSCreateObject

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSCreateObject(
                 handle_t               hBind,
                 DWORD                  dwObjectType,
                 LPCWSTR                pwcsPathName,
                 DWORD                  /*dwSDLength*/,
                 unsigned char *        pSecurityDescriptor,
                 DWORD                  cp,
                 PROPID                 aProp[  ],
                 PROPVARIANT            apVar[  ],
                 GUID*                  pObjGuid)
{

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 160);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSCreateObjectInternal( dwObjectType,
                                 pwcsPathName,
                                 (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                 cp,
                                 aProp,
                                 apVar,
                                 fKerberos,
                                 pObjGuid );

    return LogHR(hr, s_FN, 180);
}

/*====================================================

RoutineName: S_DSDeleteObject

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSDeleteObject( handle_t   hBind,
                          DWORD      dwObjectType ,
                          LPCWSTR    pwcsPathName )
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 190);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL, // pGuid
                                     0,
                                     NULL,
                                     e_Delete ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSDeleteObject( dwObjectType, pwcsPathName);

    return LogHR(hr, s_FN, 210);
}

/*====================================================

RoutineName: S_DSGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetProps(
	handle_t     hBind,
	DWORD dwObjectType,
	LPCWSTR pwcsPathName,
	DWORD        cp,
	PROPID       aProp[  ],
	PROPVARIANT  apVar[  ],
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE pbServerSignature,
	DWORD *pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 220);
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();

    HRESULT hr;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( 
					NULL,
					ulAuthnSvc,
					dwObjectType,
					pwcsPathName,
					NULL,   // guid
					cp,
					aProp,
					e_GetProps 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 230);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectProperties(  
				dwObjectType,
				pwcsPathName,
				cp,
				aProp,
				apVar 
				);
    LogHR(hr, s_FN, 240);


    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(
					cp,
					aProp,
					apVar,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;

        LogHR(hr, s_FN, 250);
    }

    return LogHR(hr, s_FN, 270);
}

/*====================================================

RoutineName: S_DSSetProps

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSSetProps( handle_t     hBind,
                      DWORD        dwObjectType,
                      LPCWSTR      pwcsPathName,
                      DWORD        cp,
                      PROPID       aProp[  ],
                      PROPVARIANT  apVar[  ] )
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 280);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 290);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectProperties( dwObjectType,
                                pwcsPathName,
                                cp,
                                aProp,
                                apVar ) ;
    return LogHR(hr, s_FN, 300);
}

/*====================================================

RoutineName: S_DSGetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetObjectSecurity(
        handle_t                hBind,
        DWORD                   dwObjectType,
        LPCWSTR                 pwcsPathName,
        SECURITY_INFORMATION    RequestedInformation,
        unsigned char*          pSecurityDescriptor,
        DWORD                   nLength,
        LPDWORD                 lpnLengthNeeded,
        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
        PBYTE                   pbServerSignature,
        DWORD *                 pdwServerSignatureSize
		)
{
	SecurityInformationValidation( 
		dwObjectType,
		RequestedInformation
		);

	if (pdwServerSignatureSize == NULL)
	{
		TrERROR(RPC, "pdwServerSignatureSize is NULL");
		ASSERT_BENIGN(("pdwServerSignatureSize is NULL", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

	//
	// Need to initialize the allocated server buffer.
	// This buffer will not be initialized in case of error or will be partially filled.
	// The allocated buffer is returned to the user so it need to be initialized
	//
    memset(pSecurityDescriptor, 0, nLength);

    ULONG  ulAuthnSvc;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 320);
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();

    HRESULT hr = MQ_OK;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( 
					NULL,
					ulAuthnSvc,
					dwObjectType,
					pwcsPathName,
					NULL, // pGuid
					0,
					NULL,
					e_GetProps 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 330);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectSecurity( 
				dwObjectType,
				pwcsPathName,
				RequestedInformation,
				(PSECURITY_DESCRIPTOR)pSecurityDescriptor,
				nLength,
				lpnLengthNeeded
				);
    LogHR(hr, s_FN, 340);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(
				*lpnLengthNeeded,
				pSecurityDescriptor,
				pServerAuthCtx,
				pbServerSignature,
				&dwServerSignatureSize
				);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 350);
}

/*====================================================

RoutineName: S_DSSetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSSetObjectSecurity(
	handle_t                hBind,
	DWORD                   dwObjectType,
	LPCWSTR                 pwcsPathName,
	SECURITY_INFORMATION    SecurityInformation,
	unsigned char*          pSecurityDescriptor,
	DWORD                   /*nLength*/
	)
{
	SecurityInformationValidation( 
		dwObjectType,
		SecurityInformation
		);

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 370);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     0 ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 380);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectSecurity( dwObjectType,
                              pwcsPathName,
                              SecurityInformation,
                              (PSECURITY_DESCRIPTOR)pSecurityDescriptor);

    return LogHR(hr, s_FN, 390);
}

/*====================================================

RoutineName: S_DSLookupBegin

Arguments:

Return Value:

=====================================================*/

HRESULT
S_DSLookupBegin(
	handle_t               hBind,
	PPCONTEXT_HANDLE_TYPE  pHandle,
	LPWSTR                 pwcsContext,
	MQRESTRICTION          *pRestriction,
	MQCOLUMNSET            *pColumns,
	MQSORTSET              *pSort,
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE /*pServerAuthCtx*/
	)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 400);
    }
    
	BOOL fImpersonate = IsQueryImpersonationNeeded();
    
    HRESULT hr = MQ_OK ;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 ulAuthnSvc,
                                 0,
                                 NULL,
                                 NULL,
                                 pColumns->cCol,
                                 pColumns->aCol,
                                 e_Locate ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 410);
        }

        pColumns->cCol |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSLookupBegin( pwcsContext,
                        (MQRESTRICTION *)pRestriction,
                        (MQCOLUMNSET *)pColumns,
                        (MQSORTSET *)pSort,
                        (HANDLE*)pHandle ) ;
    return LogHR(hr, s_FN, 420);
}

/*====================================================

RoutineName: S_DSLookupNext

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSLookupNext(
	handle_t               hBind,
	PCONTEXT_HANDLE_TYPE   Handle,
	DWORD                  *dwSize,
	DWORD                  *dwOutSize,
	PROPVARIANT            *pbBuffer,
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE                  pbServerSignature,
	DWORD *                pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;
	*dwOutSize = 0;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 430);
    }

    P<CImpersonate> pImpersonate;

	BOOL fImpersonate = IsQueryImpersonationNeeded();
	if (fImpersonate)
	{
    	MQSec_GetImpersonationObject(
    		FALSE,	// fImpersonateAnonymousOnFailure
	    	&pImpersonate 
    		);
	   	RPC_STATUS dwStatus = pImpersonate->GetImpersonationStatus();
	    if (dwStatus != RPC_S_OK)
	    {
			TrERROR(DS, "Failed to impersonate client, RPC_STATUS = 0x%x", dwStatus);
			return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
	    }
	}

	DWORD dwInSize = *dwSize ;
    HRESULT hr = DSLookupNext( (HANDLE)Handle, &dwInSize, pbBuffer);
    *dwOutSize = dwInSize ;
    
	pImpersonate.free();

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties( 
					*dwOutSize,
					NULL,
					pbBuffer,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 440);
}

/*====================================================

RoutineName: S_DSLookupEnd

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSLookupEnd(
                        handle_t                hBind,
                        PPCONTEXT_HANDLE_TYPE   pHandle)
{
    HRESULT hr;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 450);
    }

    hr = DSLookupEnd( (HANDLE)*pHandle);
    *pHandle = NULL;

    return LogHR(hr, s_FN, 460);
}

/*====================================================

RoutineName: S_DSFlush

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSFlush(handle_t /* hBind */)
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 470);
}


/*====================================================

RoutineName: S_DSDeleteObjectGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSDeleteObjectGuid(
                            handle_t    hBind,
                            DWORD       dwObjectType,
                            CONST GUID *pGuid)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 480);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                      ulAuthnSvc,
                                      dwObjectType,
                                      NULL,   // Pathname
                                      pGuid,
                                      0,
                                      NULL,
                                      e_Delete ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    HRESULT hr2 = DSDeleteObjectGuidInternal( dwObjectType,
                                              pGuid,
                                              fKerberos ) ;
    return LogHR(hr2, s_FN, 500);
}

/*====================================================

RoutineName: S_DSGetPropsGuid

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetPropsGuid(
	handle_t     hBind,
	DWORD        dwObjectType,
	CONST GUID  *pGuid,
	DWORD        cp,
	PROPID       aProp[  ],
	PROPVARIANT  apVar[  ],
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE pbServerSignature,
	DWORD *pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

    ULONG  ulAuthnSvc;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 510);
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();

    HRESULT hr;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( 
					NULL,
					ulAuthnSvc,
					dwObjectType,
					NULL,  // PathName,
					pGuid,
					cp,
					aProp,
					e_GetProps 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 520);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectPropertiesGuid(dwObjectType, pGuid, cp, aProp, apVar);
    LogHR(hr, s_FN, 530);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties( 
					cp,
					aProp,
					apVar,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 540);
}

/*====================================================

RoutineName: S_DSSetPropsGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSSetPropsGuid(
                        handle_t     hBind,
                        DWORD dwObjectType,
                        CONST GUID *pGuid,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ])
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 550);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     NULL,
                                     pGuid,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 560);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    HRESULT hr2 = DSSetObjectPropertiesGuidInternal(
                                             dwObjectType,
                                             pGuid,
                                             cp,
                                             aProp,
                                             apVar,
                                             fKerberos ) ;
    return LogHR(hr2, s_FN, 570);
}


/*====================================================

RoutineName: S_DSSetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSSetObjectSecurityGuid(
		IN  handle_t                hBind,
		IN  DWORD                   dwObjectType,
		IN  CONST GUID*             pObjectGuid,
		IN  DWORD/*SECURITY_INFORMATION*/    SecurityInformation,
		IN  unsigned char*          pSecurityDescriptor,
		IN  DWORD                   /*nLength*/
		)
{
	SecurityInformationValidation( 
		dwObjectType,
		SecurityInformation
		);

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 580);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     NULL,
                                     pObjectGuid,
                                     0 ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectSecurityGuidInternal(
                                 dwObjectType,
                                 pObjectGuid,
                                 SecurityInformation,
                                 (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                 fKerberos );
    return LogHR(hr, s_FN, 600);
}

/*====================================================

RoutineName: S_DSGetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetObjectSecurityGuid(
                IN  handle_t                hBind,
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                OUT unsigned char*          pSecurityDescriptor,
                IN  DWORD                   nLength,
                OUT LPDWORD                 lpnLengthNeeded,
                IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                OUT LPBYTE                  pbServerSignature,
                IN OUT DWORD *              pdwServerSignatureSize)
{
	SecurityInformationValidation( 
		dwObjectType,
		RequestedInformation
		);

	if (pdwServerSignatureSize == NULL)
	{
		TrERROR(RPC, "pdwServerSignatureSize is NULL");
		ASSERT_BENIGN(("pdwServerSignatureSize is NULL", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

	//
	// Need to initialize the allocated server buffer.
	// This buffer will not be initialized in case of error or will be partially filled.
	// The allocated buffer is returned to the user so it need to be initialized
	//
	if (pSecurityDescriptor == NULL)
	{
		nLength = 0;
	}
	else
	{
		memset(pSecurityDescriptor, 0, nLength);
	}
    
	ULONG  ulAuthnSvc;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 610);
    }

    HRESULT hr = MQ_OK ;
    BOOL fImpersonate = IsQueryImpersonationNeeded();

    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( 
					NULL,
					ulAuthnSvc,
					dwObjectType,
					NULL,
					pObjectGuid,
					0,
					NULL,
					e_GetProps 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 620);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectSecurityGuid( 
				dwObjectType,
				pObjectGuid,
				RequestedInformation,
				(PSECURITY_DESCRIPTOR)pSecurityDescriptor,
				nLength,
				lpnLengthNeeded
				);
    LogHR(hr, s_FN, 630);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(
					*lpnLengthNeeded,
					pSecurityDescriptor,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 640);
}
/*====================================================

RoutineName: S_DSDemoteStopWrite

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSDemoteStopWrite(handle_t /* hBind */)
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 650);
}

/*====================================================

RoutineName: S_DSDemotePSC

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSDemotePSC(
    IN handle_t /* hBind */,
    IN LPCWSTR /* lpwcsNewPSCName */,
    OUT DWORD* /* pdwNumberOfLSN */,
    OUT _SEQNUM /* asnLSN */ []
    )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 660);
}
/*====================================================

RoutineName: S_DSDemotePSC

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSCheckDemotedPSC(
    IN handle_t /* hBind */,
    IN LPCWSTR  /* lpwcsNewPSCName */
    )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 670);
}

/*====================================================

RoutineName: S_DSGetUserParam

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSGetUserParams(
    IN handle_t        hBind,
    DWORD              dwFalgs,
    IN DWORD           dwSidLength,
    OUT unsigned char  *pUserSid,
    OUT DWORD          *pdwSidReqLength,
    LPWSTR             szAccountName,
    DWORD              *pdwAccountNameLen,
    LPWSTR             szDomainName,
    DWORD              *pdwDomainNameLen,
    IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE
                       pServerAuthCtx,
    OUT LPBYTE         pbServerSignature,
    IN OUT DWORD *     pdwServerSignatureSize
    )
{
	if ((szAccountName == NULL) || 
		(szDomainName == NULL) || 
		(pdwDomainNameLen == NULL) || 
		(pdwAccountNameLen == NULL))
	{
		TrERROR(DS, "szAccountName or szDomainName is NULL");
		return MQ_ERROR_INVALID_PARAMETER;
	}

	if (*pdwDomainNameLen > 256 || *pdwAccountNameLen > 256)
	{
		//
		// Domain names and accounts names cannot be longer than 256. 
		//
		TrERROR(DS, "Domain name length (%d) or account length (%d) are longer than 256", *pdwDomainNameLen, *pdwAccountNameLen);
		return MQ_ERROR_INVALID_PARAMETER;
	}
	
	if (pUserSid == NULL)
	{
		dwSidLength = 0;
	}
	else
	{
		memset(pUserSid, 0, dwSidLength);
	}

	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

	//
	// Need to initialize the allocated server buffer.
	// This buffer will not be initialized in case of error or will be partially filled.
	// The allocated buffer is returned to the user so it need to be initialized
	//
    memset(szAccountName, 0, ((*pdwAccountNameLen) + 1) * sizeof(WCHAR));
    memset(szDomainName, 0, ((*pdwDomainNameLen) + 1) * sizeof(WCHAR));

    dwSidLength |= IMPERSONATE_CLIENT_FLAG;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 680);
    }

    *szAccountName = '\0';
    *szDomainName = '\0';

    HRESULT hr;

    hr = DSGetUserParams(
                dwFalgs,
                dwSidLength,
                (PSID)pUserSid,
                pdwSidReqLength,
                szAccountName,
                pdwAccountNameLen,
                szDomainName,
                pdwDomainNameLen
				);

    LogHR(hr, s_FN, 690);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        DWORD cp = 0;
        PROPVARIANT PropVar[3];

        if (dwFalgs & GET_USER_PARAM_FLAG_SID)
        {
            PropVar[cp].vt = VT_VECTOR | VT_UI1;
            PropVar[cp].caub.pElems = pUserSid;
            PropVar[cp].caub.cElems = *pdwSidReqLength;
            cp++;
        }

        if (dwFalgs & GET_USER_PARAM_FLAG_ACCOUNT)
        {
            PropVar[cp].vt = VT_LPWSTR;
            PropVar[cp].pwszVal = szAccountName;
            PropVar[cp+1].vt = VT_LPWSTR;
            PropVar[cp+1].pwszVal = szDomainName;
            cp += 2;
        }

        hr = SignProperties( 
					cp,
					NULL,
					PropVar,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 700);
}

//
// A sign routine that servers as a wrapper to the RPC callback to sign
// routine on the client.
// This is done in order to convert the DWORD_PTR dwContext used by
// DSQMSetMachineProperties back to DWORD for RPC callback
//
HRESULT
DSQMSetMachinePropertiesSignProc(
    BYTE             *abChallenge,
    DWORD            dwCallengeSize,
    DWORD_PTR        dwContext,
    BYTE             *abSignature,
    DWORD            *pdwSignatureSize,
    DWORD            dwSignatureMaxSize)
{
    return S_DSQMSetMachinePropertiesSignProc(
               abChallenge,
               dwCallengeSize,
               DWORD_PTR_TO_DWORD(dwContext), //safe, we got that as a DWORD from S_DSQMSetMachineProperties
               abSignature,
               pdwSignatureSize,
               dwSignatureMaxSize);
}



/*====================================================

RoutineName: S_DSQMSetMachineProperties

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSQMSetMachineProperties(
    handle_t                hBind,
    LPCWSTR                 pwcsPathName,
    DWORD                   cp,
    PROPID                  aProp[],
    PROPVARIANT             apVar[],
    DWORD                   dwContext)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 720);
    }

    if ((cp == 1) && (aProp[0] == PROPID_QM_UPGRADE_DACL))
    {
        if (ulAuthnSvc != RPC_C_AUTHN_GSS_KERBEROS)
        {
            //
            // For upgrade of DACL, we're supporting only win2k machines,
            // that authenticate with Kerberos.
            //
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1270);
        }
    }

    hr = DSQMSetMachineProperties(
            pwcsPathName,
            cp | IMPERSONATE_CLIENT_FLAG,
            aProp,
            apVar,
            DSQMSetMachinePropertiesSignProc, //defined here as a wrapper to S_DSQMSetMachinePropertiesSignProc
            DWORD_TO_DWORD_PTR(dwContext)); //enlarge to DWORD_PTR

    if (hr == MQ_ERROR_ACCESS_DENIED)
    {
        //
        // This may happen when nt4 machine tries to change its own properties
        // and it talks with a domain controller that does not contain its
        // msmqConfiguration object. S_DSSet will check for this condition
        // (configuration object not on local domain controller) and return
        // ERROR_NO_DS. That error tells the caller to look for another DC.
        //
        // By default a domain controller does not have write permissions
        // on objects of another domain, and ntlm impersonation can not be
        // delegated to another controller. That's the reason for the
        // access-denied error.
        //
        hr = S_DSSetProps( hBind,
                           MQDS_MACHINE,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar ) ;
    }

    return LogHR(hr, s_FN, 730);
}

HRESULT 
GetServersCacheRegistryData(
	BOOL fImpersonate,
	DWORD Index,
	LPWSTR* lplpServersList
	)
{
    P<CImpersonate> pImpersonate;
	if (fImpersonate)
	{
    	MQSec_GetImpersonationObject(
    		FALSE,	// fImpersonateAnonymousOnFailure
	    	&pImpersonate 
    		);
	   	RPC_STATUS dwStatus = pImpersonate->GetImpersonationStatus();
	    if (dwStatus != RPC_S_OK)
	    {
			TrERROR(DS, "Failed to impersonate client, RPC_STATUS = 0x%x", dwStatus);
			return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
	    }
	}

	//
    // First, open the registry key.
    //
    LONG    rc;
    CAutoCloseRegHandle hKeyCache;

    WCHAR  tServersKeyName[ 256 ] = {0};
    HRESULT hr = StringCchPrintf(tServersKeyName, TABLE_SIZE(tServersKeyName), L"%s\\"MSMQ_SERVERS_CACHE_REGNAME, GetFalconSectionName());
    ASSERT(SUCCEEDED(hr));
    ASSERT(wcslen(tServersKeyName) < (TABLE_SIZE(tServersKeyName)));

    rc = RegOpenKeyEx( 
				FALCON_REG_POS,
				tServersKeyName,
				0,
				KEY_READ,
				&hKeyCache
				);

    LogNTStatus(rc, s_FN, 740);
    if (rc != ERROR_SUCCESS) 
    {
        TrERROR(DS, "Fail to Open 'ServersCache' Key. Error %d", rc);
        return HRESULT_FROM_WIN32(rc);
    }

    WCHAR wszData[WSZSERVERS_LEN];
    DWORD dwDataLen = sizeof(wszData);
    WCHAR wszValueName[512];
    DWORD dwValueLen = 512;
    DWORD dwType = REG_SZ;

    rc = RegEnumValue( 
			hKeyCache,
			Index,
			wszValueName,
			&dwValueLen,
			NULL,
			&dwType,
			(BYTE *)&wszData[0],
			&dwDataLen 
			);
    if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA) && (rc != ERROR_NO_MORE_ITEMS))
    {
		TrERROR(DS, "RegEnumValue failed. Error: %!winerr!", rc);
        return HRESULT_FROM_WIN32(rc);
    }

    if (rc == ERROR_NO_MORE_ITEMS)
    {
		//
		// No items in key
		//
		return MQDS_E_NO_MORE_DATA;
    }

    if (rc == ERROR_MORE_DATA)
    {
	    ASSERT(dwDataLen > sizeof(wszData));

	    //
	    // input buffer too small. This error is not documented in msdn,
	    // but it's similar to behavior of RegQueryValue(), so let's assume
	    // it's the same behavior.
	    //
	    AP<BYTE> pBuf = new BYTE[dwDataLen];

	    rc = RegEnumValue( 
				hKeyCache,
				Index,
				wszValueName,
				&dwValueLen,
				NULL,
				&dwType,
				pBuf,
				&dwDataLen 
				);
	    if (rc != ERROR_SUCCESS)
	    {
			TrERROR(DS, "RegEnumValue failed. Error: %!winerr!", rc);
	    	return HRESULT_FROM_WIN32(rc);
	    }

	    //
	    // Truncate the servers list, to include no more than
	    // WSZSERVERS_LEN characters. This means that clients can use
	    // no more than ~90 BSCs for load balancing MQIS operations.
	    // This is necessary for compatibility with existing clients.
	    //
	    dwDataLen = sizeof(wszData);
	    memcpy(wszData, pBuf, dwDataLen);
    }

	ASSERT(rc == ERROR_SUCCESS);

    if (dwDataLen >= sizeof(wszData))
    {
        //
        // Long buffer (all of "wszData").
        // Remove one character to compensate for the single
        // character header that is added for client. Add NULL
        // termination at end of last server name.
        //
        LONG iStrLen = TABLE_SIZE(wszData) - 1;
        wszData[ iStrLen-1 ] = 0;
        WCHAR *pCh = wcsrchr(wszData, L',');
        if (pCh != 0)
            *pCh = 0;
    }

    LONG iLen = wcslen(wszValueName) +
                1                    +  // ";"
                wcslen(NEW_SITE_IN_REG_FLAG_STR) + // header
                wcslen(wszData)                  +
                1; // null terminator.

	*lplpServersList = new WCHAR[iLen];
	LPWSTR lpServers = *lplpServersList;
	lpServers[0] = L'\0';

	hr = StringCchPrintf(lpServers, iLen, L"%s;" NEW_SITE_IN_REG_FLAG_STR L"%s", wszValueName, wszData);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);

	ASSERT((LONG)wcslen(lpServers) < iLen);

    return MQ_OK;
}
	

/*=======================================================================

RoutineName: S_DSCreateServersCache

Here MQIS server process RPC calls from clients. Data is retrieved from
registry, not by querying local MQIS database. Registry was prepared when
local QM on MQIS server call dsapi.cpp\DSCreateServersCache().

Arguments:

Return Value:

=========================================================================*/

HRESULT
S_DSCreateServersCache(
    handle_t hBind,
    DWORD* pdwIndex,
    LPWSTR* lplpServersList,
    IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
    OUT LPBYTE pbServerSignature,
    IN OUT DWORD* pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

	ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
    	TrERROR(DS, "CheckAuthLevel failed");
        return MQ_ERROR_DS_ERROR;
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();
    HRESULT hr;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( 
					NULL,
					ulAuthnSvc,
					NULL,
					NULL,
					NULL,   // guid
					0,
					NULL,
					e_GetProps 
					);
        if (FAILED(hr))
        {
            TrERROR(DS, "_CheckIfGoodServer failed");
        	return hr;
        }
    }

    ASSERT(pdwIndex);
    ASSERT(lplpServersList);

   	hr = GetServersCacheRegistryData(fImpersonate, *pdwIndex, lplpServersList);
   	if (FAILED(hr))
   	{
		TrERROR(DS, "GetServersCacheRegistryData failed");
        return hr;
   	}

	if (pServerAuthCtx->pvhContext)
	{
	   PROPVARIANT PropVar[2];

	   PropVar[0].vt = VT_UI4;
	   PropVar[0].ulVal = *pdwIndex;
	   PropVar[1].vt = VT_LPWSTR;
	   PropVar[1].pwszVal = *lplpServersList;

	   hr = SignProperties(
				2,
				NULL,
				PropVar,
				pServerAuthCtx,
				pbServerSignature,
				&dwServerSignatureSize
				);
	   if (FAILED(hr))
	   {
	   		TrERROR(DS, "SignProperties failed. Error: %!hresult!", hr);
			return hr;
	   }

	   *pdwServerSignatureSize = dwServerSignatureSize;
	}

	return MQ_OK;
}

//
// A challenge response routine that servers as a wrapper to the RPC callback to
// challenge response routine on the client.
// This is done in order to convert the DWORD_PTR dwContext used by
// DSQMGetObjectSecurity back to DWORD for RPC callback
//
HRESULT
DSQMGetObjectSecurityChallengeResponceProc(
    BYTE    *abChallenge,
    DWORD   dwCallengeSize,
    DWORD_PTR   dwContext,
    BYTE    *pbChallengeResponce,
    DWORD   *pdwChallengeResponceSize,
    DWORD   dwChallengeResponceMaxSize)
{
    return S_DSQMGetObjectSecurityChallengeResponceProc(
               abChallenge,
               dwCallengeSize,
               DWORD_PTR_TO_DWORD(dwContext), //safe, we got that as a DWORD from S_DSQMGetObjectSecurity
               pbChallengeResponce,
               pdwChallengeResponceSize,
               dwChallengeResponceMaxSize);              
}


/*====================================================

RoutineName: S_DSQMGetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSQMGetObjectSecurity(
    handle_t                hBind,
    DWORD                   dwObjectType,
    CONST GUID*             pObjectGuid,
    SECURITY_INFORMATION    RequestedInformation,
    BYTE                    *pSecurityDescriptor,
    DWORD                   nLength,
    LPDWORD                 lpnLengthNeeded,
    DWORD                   dwContext,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
    LPBYTE                  pbServerSignature,
    DWORD *                 pdwServerSignatureSize
	)
{
	SecurityInformationValidation( 
		dwObjectType,
		RequestedInformation
		);

	if (pdwServerSignatureSize == NULL)
	{
		TrERROR(RPC, "pdwServerSignatureSize is NULL");
		ASSERT_BENIGN(("pdwServerSignatureSize is NULL", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

	if (pSecurityDescriptor == NULL)
	{
		nLength = 0;
	}
	else
	{
		//
		// Need to initialize the allocated server buffer.
		// This buffer will not be initialized in case of error or will be partially filled.
		// The allocated buffer is returned to the user so it need to be initialized
		//
	    memset(pSecurityDescriptor, 0, nLength);
	}
	
	

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 780);
    }

    HRESULT hr = DSQMGetObjectSecurity(
						dwObjectType,
						pObjectGuid,
						RequestedInformation,
						(PSECURITY_DESCRIPTOR)pSecurityDescriptor,
						nLength,
						lpnLengthNeeded,
						DSQMGetObjectSecurityChallengeResponceProc, //wrapper to S_DSQMGetObjectSecurityChallengeResponceProc
						DWORD_TO_DWORD_PTR(dwContext)  //enlarge to DWORD_PTR
						); 

    LogHR(hr, s_FN, 790);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(
					*lpnLengthNeeded,
					pSecurityDescriptor,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 800);
}


/*====================================================

S_DSMQISStats

=====================================================*/
HRESULT
S_DSMQISStats(
    handle_t /* hBind */,
    MQISSTAT** /* ppStat */,
    LPDWORD pdwStatElem
    )
{
	*pdwStatElem = 0;
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 810);
}


/*====================================================

RoutineName: InitServerAuthInternal

Arguments:

Return Value:

=====================================================*/

static
HRESULT
InitServerAuthInternal(
    DWORD       dwContext,
    DWORD       dwClientBufferMaxSize,
    LPBYTE      pbClientBuffer,
    DWORD       dwClientBufferSize,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuth,
	DWORD 		MaxTokenSize
	)
{
    //
    // Create a context handle. This requires negotiation with the client.
    //

    //
    // Allocate the token buffer.
    //
    DWORD dwServerBufferSize = MaxTokenSize;
    AP<BYTE> pbServerBuffer = new BYTE[dwServerBufferSize];

    BOOL fFirst = TRUE;
    do
    {
        //
        // Process the client's buffer and get a new buffer to send to the
        // client. A new buffer is received if the return code is not
        // MQ_OK (SEC_E_OK).
        //
        HRESULT hrServer = ServerAcceptSecCtx(
								fFirst,
								&pServerAuth->pvhContext,
								pbServerBuffer,
								&dwServerBufferSize,
								pbClientBuffer,
								dwClientBufferSize
								);
        if (FAILED(hrServer))
        {
            return hrServer;
        }

        //
        // Send the server buffer to the client and receive a new buffer from
        // the client. A new buffer is received from the lient when the return
        // code in not MQ_OK (SEC_E_OK).
        //
        HRESULT hrClient = S_InitSecCtx(
								dwContext,
								pbServerBuffer,
								dwServerBufferSize,
								dwClientBufferMaxSize,
								pbClientBuffer,
								&dwClientBufferSize
								);

        if (FAILED(hrClient))
        {
            return hrClient;
        }

        //
        // When the server return MQ_OK, the client must also return MQ_OK.
        // Otherwise it means that something went wrong.
        //
        if ((hrClient == MQ_OK) || (hrServer == MQ_OK))
        {
			if(hrClient != MQ_OK)
				return hrClient;
            return hrServer;
        }

        fFirst = FALSE;

    } while (1);

}


/*====================================================

RoutineName: InitServerAuth

Arguments:

Return Value:

=====================================================*/

InitServerAuth(
    DWORD       dwContext,
    DWORD       dwClientBufferMaxSize,
    LPBYTE      pbClientBuffer,
    DWORD       dwClientBufferSize,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuth)
{
    HRESULT hr = MQ_OK ;
    static BOOL fServerCredsInitialized = FALSE;

    if (!fServerCredsInitialized)
    {
        //
        // Create the server's credentials handle.
        //
        hr =  MQsspi_InitServerAuthntication() ;
        LogHR(hr, s_FN, 820);
        if (FAILED(hr))
        {
            return   MQDS_E_CANT_INIT_SERVER_AUTH ;
        }
        fServerCredsInitialized = TRUE;
    }

    //
    // Get the maximum size for the token buffer.
    //
    DWORD MaxTokenSize;
    hr = GetSizes(&MaxTokenSize);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 830);
    }

    __try
    {
		hr = InitServerAuthInternal(
					dwContext,
					dwClientBufferMaxSize,
					pbClientBuffer,
					dwClientBufferSize,
					pServerAuth,
					MaxTokenSize
					);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = MQDS_E_CANT_INIT_SERVER_AUTH;
    }

    //
    // If we already got a context handle and failed in the remaining
    // negotiation, we should delete the context handle.
    //
    if (pServerAuth->pvhContext && (hr != MQ_OK))
    {
        FreeContextHandle(pServerAuth->pvhContext);
        pServerAuth->pvhContext = NULL;
    }

    LogHR(hr, s_FN, 840);

    if (hr == MQ_OK)
    {
        //
        // Get the header and trailer sizes for the context.
        //
        hr = GetSizes(
				NULL,
				pServerAuth->pvhContext,
				&pServerAuth->cbHeader,
				&pServerAuth->cbTrailer
				);
    }
    else
    {
        hr = MQDS_E_CANT_INIT_SERVER_AUTH;
    }

    return LogHR(hr, s_FN, 850);
}


extern "C"
HRESULT
S_DSCloseServerHandle(
    /* [out][in] */ PPCONTEXT_HANDLE_SERVER_AUTH_TYPE pphServerAuth
    )
{
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE phServerAuth = *pphServerAuth;

	if(phServerAuth == NULL)
		return MQ_ERROR_INVALID_PARAMETER;

    if (phServerAuth->pvhContext)
    {
        FreeContextHandle(phServerAuth->pvhContext);
    }

    delete phServerAuth;

    *pphServerAuth = 0;

    return MQ_OK;
}

/*====================================================

RoutineName: PCONTEXT_HANDLE_SERVER_AUTH_TYPE_rundown

Arguments:

Return Value:

=====================================================*/

extern "C"
void
__RPC_USER
PCONTEXT_HANDLE_SERVER_AUTH_TYPE_rundown(
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE phServerAuth)
{
    TrWARNING(DS, "MQDSSRV: in rundown");

    S_DSCloseServerHandle(&phServerAuth);
}


/*====================================================

RoutineName: S_DSValidateServer

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSValidateServer(IN   handle_t    hBind,
                   IN   const GUID * /*pguidEnterpriseId*/,
                   IN   BOOL        /* fSetupMode */,
                   IN   DWORD       dwContext,
                   IN   DWORD       dwClientBuffMaxSize,
                   IN   PUCHAR      pClientBuff,
                   IN   DWORD       dwClientBuffSize,
                   OUT  PPCONTEXT_HANDLE_SERVER_AUTH_TYPE
                                    pphServerAuth)
{
    HRESULT hr = MQ_OK;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 860);
    }


    //
    // If the caller is interested in server authntication, go and
    // set it on. Otherwise, set a null server context.
    //

    SERVER_AUTH_STRUCT ServerAuth = {NULL, 0, 0};

    if (dwClientBuffSize)
    {
        hr = InitServerAuth(dwContext,
                            dwClientBuffMaxSize,
                            pClientBuff,
                            dwClientBuffSize,
                            &ServerAuth);
        LogHR(hr, s_FN, 870);
        if (FAILED(hr))
        {
            hr = MQDS_E_CANT_INIT_SERVER_AUTH;
        }
    }

    *pphServerAuth = new SERVER_AUTH_STRUCT;
    **pphServerAuth = ServerAuth;

    return(hr);
}


/*====================================================

RoutineName: S_DSDisableWriteOperations

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSDisableWriteOperations(
    handle_t /* hBind */,
    PPCONTEXT_HANDLE_TYPE  pphContext
    )
{
    *pphContext = NULL;
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 880);
}

/*====================================================

RoutineName: S_DSEnableWriteOperations

Arguments:

Return Value:

=====================================================*/

HRESULT
S_DSEnableWriteOperations(
	handle_t /* hBind */,
	PPCONTEXT_HANDLE_TYPE  pphContext)
{
    *pphContext = NULL;
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 890);
}

/*====================================================

RoutineName: S_DSGetComputerSites

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetComputerSites(
        handle_t            hBind,
        LPCWSTR             pwcsPathName,
        DWORD *             pdwNumberOfSites,
        GUID **             ppguidSites,
        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
        PBYTE               pbServerSignature,
        DWORD *             pdwServerSignatureSize
		)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;
	*pdwNumberOfSites = 0;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 900);
    }

    HRESULT hr = DSGetComputerSites(
						pwcsPathName,
						pdwNumberOfSites,
						ppguidSites
						);

    LogHR(hr, s_FN, 910);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(
					(*pdwNumberOfSites)* sizeof(GUID),
					(unsigned char *)*ppguidSites,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 920);
}

/*====================================================

RoutineName: S_DSGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetPropsEx(
	handle_t     hBind,
	DWORD        dwObjectType,
	LPCWSTR      pwcsPathName,
	DWORD        cp,
	PROPID       aProp[  ],
	PROPVARIANT  apVar[  ],
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE  pbServerSignature,
	DWORD *pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 930);
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();

    if (fImpersonate)
    {
        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    HRESULT hr = DSGetObjectPropertiesEx(
                                 dwObjectType,
                                 pwcsPathName,
                                 cp,
                                 aProp,
                                 apVar 
								 );
    LogHR(hr, s_FN, 940);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(
					cp,
					aProp,
					apVar,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 950);
}

/*====================================================

RoutineName: S_DSGetPropsGuidEx

Arguments:

Return Value:

=====================================================*/
HRESULT 
S_DSGetPropsGuidEx(
	handle_t     hBind,
	DWORD        dwObjectType,
	CONST GUID  *pGuid,
	DWORD        cp,
	PROPID       aProp[  ],
	PROPVARIANT  apVar[  ],
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
	PBYTE  pbServerSignature,
	DWORD *pdwServerSignatureSize
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 960);
    }

    BOOL fImpersonate = IsQueryImpersonationNeeded();

    if (fImpersonate)
    {
        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    HRESULT hr = DSGetObjectPropertiesGuidEx(dwObjectType, pGuid, cp, aProp, apVar);
    LogHR(hr, s_FN, 970);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(
					cp,
					aProp,
					apVar,
					pServerAuthCtx,
					pbServerSignature,
					&dwServerSignatureSize
					);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 980);

}

/*====================================================

RoutineName: S_DSBeginDeleteNotification

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSBeginDeleteNotification(
	handle_t /* hBind */,
	LPCWSTR pwcsName,
	PPCONTEXT_HANDLE_DELETE_TYPE pHandle,
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE /* pServerAuthCtx */
	)
{
    *pHandle = NULL;
    P<CBasicDeletionNotification>  pDelNotification;
    //
    //  Find if it is a queue or a machine
    //
    WCHAR * pQueueDelimiter = wcschr( pwcsName, PN_DELIMITER_C);

    if ( pQueueDelimiter != NULL)
    {
        pDelNotification = new CQueueDeletionNotification();
    }
    else
    {
        pDelNotification = new CMachineDeletionNotification();
    }
    HRESULT hr;
    hr = pDelNotification->ObtainPreDeleteInformation(
                            pwcsName
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 990);
    }
    *pHandle = pDelNotification.detach();
    return(MQ_OK);

}

/*====================================================

RoutineName: S_DSNotifyDelete

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSNotifyDelete(
     handle_t /* hBind */,
	 PCONTEXT_HANDLE_DELETE_TYPE Handle
	)
{
    CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)Handle;
	
	if (pDelNotification->m_eType != CBaseContextType::eDeleteNotificationCtx)
	{
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1001);
	}

    HRESULT hr = pDelNotification->PerformPostDeleteOperations();
    return LogHR(hr, s_FN, 1000);
}

/*====================================================

RoutineName: S_DSEndDeleteNotification

Arguments:

Return Value:

=====================================================*/
void
S_DSEndDeleteNotification(
    handle_t /* hBind */,
	PPCONTEXT_HANDLE_DELETE_TYPE pHandle
	)
{
    if ( *pHandle != NULL)
    {
        CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)(*pHandle);

		if (pDelNotification->m_eType != CBaseContextType::eDeleteNotificationCtx)
		{
			return;
		}

        delete pDelNotification;
    }

    *pHandle = NULL;
}

/*====================================================

RoutineName: S_DSIsServerGC()

Arguments:

Return Value:

=====================================================*/

BOOL S_DSIsServerGC(handle_t /* hBind */)
{
    BOOL fGC = MQDSIsServerGC() ;
    return fGC ;
}

/*=========================================================================

RoutineName: S_DSUpdateMachineDacl()

Note: Unsupported anymore.

Return Value:

==========================================================================*/

HRESULT S_DSUpdateMachineDacl(handle_t /* hBind */)
{
    return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1260);
}

/*====================================================

RoutineName: S_DSGetGCListInDomain

Arguments:

Return Value:

=====================================================*/

HRESULT 
S_DSGetGCListInDomain(
	IN  handle_t                      hBind,
	IN  LPCWSTR                       pwszComputerName,
	IN  LPCWSTR                       pwszDomainName,
	OUT LPWSTR                       *lplpwszGCList,
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE  pServerAuthCtx,
	PBYTE                             pbServerSignature,
	DWORD                            *pdwServerSignatureSize 
	)
{
	DWORD dwServerSignatureSize = *pdwServerSignatureSize;
	*pdwServerSignatureSize = 0;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1300);
    }

    HRESULT hr = DSGetGCListInDomainInternal(
					pwszComputerName,
					pwszDomainName,
					lplpwszGCList 
					);

    LogHR(hr, s_FN, 1310);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        DWORD dwSize = (wcslen( *lplpwszGCList ) + 1) * sizeof(WCHAR);

        hr = SignBuffer( 
				dwSize,
				(BYTE*) (*lplpwszGCList),
				pServerAuthCtx,
				pbServerSignature,
				&dwServerSignatureSize
				);

		*pdwServerSignatureSize = dwServerSignatureSize;
    }

    return LogHR(hr, s_FN, 1320);
}


//+---------------------------------------
//
//  DSIsWeakenSecurity
//
//+---------------------------------------

BOOL
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSIsWeakenSecurity()
{
	//
	// IsQueryImpersonationNeeded() check if we are in weaken security mode.
	// If Impersonation for read operations is not needed, we are in weaken security mode.
	//
    return !IsQueryImpersonationNeeded();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\dsutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsutil.cpp

Abstract:

    DS utilities

Author:

    Ronit Hartmann (ronith)

--*/

#include "stdh.h"
#include "mqds.h"
#include "_rstrct.h"
#include "_mqini.h"
#include <mqsec.h>
#include "mqcert.h"
#include "uniansi.h"
#include "mqutil.h"
#include <cm.h>


#include "dsutil.tmh"

static WCHAR *s_FN=L"mqdssrv/dsutil";

typedef CMap < PROPID, PROPID, int, int> CMapPropidToIndex;

const PROPID x_propQueueToFilterOut[] = {PROPID_Q_INSTANCE};

HMODULE  g_hInstance = NULL ;

//+----------------------------------------------
//
//  PROPID  GetObjectSecurityPropid()
//
//+----------------------------------------------

PROPID  GetObjectSecurityPropid( DWORD dwObjectType )
{
    PROPID pId = (PROPID)ILLEGAL_PROPID_VALUE;

    switch ( dwObjectType )
    {
        case MQDS_QUEUE:
            pId = PROPID_Q_SECURITY;
            break;

        case MQDS_MACHINE:
            pId = PROPID_QM_SECURITY;
            break ;

        case MQDS_SITE:
            pId = PROPID_S_SECURITY;
            break;

        case MQDS_CN:
            pId = PROPID_CN_SECURITY;
            break ;

        case MQDS_USER:
        case MQDS_COMPUTER:
        case MQDS_SITELINK:
            //
            // These objects do not have security property (at least not as
            // far as msmq is concerned).
            //
            break ;

        default:
            //
            // We don't expect this code to be called for other types of
            // objects.
            //
            ASSERT(0);
            break;
    }

    return pId ;
}

/*====================================================

SetDefaultValues

Arguments:

Return Value:

=====================================================*/

HRESULT
SetDefaultValues(
	IN  DWORD                  dwObjectType,
	IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
	IN  PSID                   pUserSid,
	IN  DWORD                  cp,
	IN  PROPID                 aProp[],
	IN  PROPVARIANT            apVar[],
	OUT DWORD*                 pcpOut,
	OUT PROPID **              ppOutProp,
	OUT PROPVARIANT **         ppOutPropvariant
	)
{
    //
    //  The only property that we set default value is the
    //  object security.
    //
    //  For other properties:
    //  If they are mandatory, then the caller must provide them (otherwise
    //  object creation will fail).
    //  If they are not mandatory, no default values are set. Those properties
    //  will not have value in NT5 ( and will not consume object space).
    //  When retrieved through MQADS, default values will be returned ( even
    //  though the default values are not stored in NT5 DS).
    //
    PROPID propSecurity = (PROPID)ILLEGAL_PROPID_VALUE;
    DWORD iSid = (DWORD)-1;

    DWORD dwNumPropertiesToFilterOut = 0;
    const PROPID * ppropToFilterOut = NULL;

    switch ( dwObjectType)
    {
        case MQDS_QUEUE:
            ppropToFilterOut = x_propQueueToFilterOut;
            dwNumPropertiesToFilterOut = sizeof(x_propQueueToFilterOut)/sizeof(PROPID);
            propSecurity = PROPID_Q_SECURITY;
            break;

        case MQDS_SITE:
            propSecurity = PROPID_S_SECURITY;
            break;

        case MQDS_MACHINE:
        case MQDS_CN:
        case MQDS_USER:
        case MQDS_SITELINK:
        case MQDS_COMPUTER:
            //
            // These object types do not need a security descriptor.
            //
            break;

        default:
            ASSERT(0);
            break;
    }

    //
    //  Allocate a copy of provariants and propids
    //  This operation is performed even if the caller
    //  had supplied the security property
    //
    DWORD securityIndex = cp;
    DWORD dwNumOfObjectProps = cp ;

    if (propSecurity != ILLEGAL_PROPID_VALUE)
    {
        //
        // User object get SID as "extra" prop, not security descriptor.
        //
        ASSERT(dwObjectType != MQDS_USER) ;
        dwNumOfObjectProps++;
    }
    else if (dwObjectType == MQDS_USER)
    {
        //
        //  Need to add one extra space, for PROPID_U_SID
        //
        iSid = dwNumOfObjectProps;
        dwNumOfObjectProps++;
    }

    //
    // Allocate new arrays of prop IDs and propvariants.
    //
    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( dwNumOfObjectProps > 0);
    pAllPropvariants = new PROPVARIANT[dwNumOfObjectProps];
    pAllPropids = new PROPID[dwNumOfObjectProps];
    memset(pAllPropids, 0, (sizeof(PROPID) * dwNumOfObjectProps)) ;

    if ( cp > 0)
    {
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }

    //
    //  Remove properties that need to be filtered out
    //
    for (DWORD i = 0; i <  dwNumPropertiesToFilterOut; i++)
    {
        ASSERT( ppropToFilterOut != NULL);
        for (DWORD j = 0; j < cp;)
        {
            if ( pAllPropids[j] == ppropToFilterOut[i])
            {
                //
                //  remove the propid & var
                //
                if ( j < cp -1)
                {
                    memcpy (&pAllPropvariants[j],
                            &pAllPropvariants[j + 1],
                            sizeof(PROPVARIANT) * (cp - j - 1));
                    memcpy (&pAllPropids[j],
                            &pAllPropids[j + 1],
                            sizeof(PROPID) * (cp - j - 1));
                }
                pAllPropids[cp - 1] = 0;
                dwNumOfObjectProps--;
                securityIndex--;
                if ( iSid != -1) iSid--;
            }
            else
            {
                j++;
            }
        }
    }

    //
    //  Set the security property
    //
#ifdef _DEBUG
    //
    // First verify that we're sane
    //
    if (pSecurityDescriptor)
    {
        SECURITY_DESCRIPTOR_CONTROL sdc;
        DWORD dwSDRev;

        ASSERT(GetSecurityDescriptorControl( pSecurityDescriptor,
                                            &sdc,
                                            &dwSDRev )) ;
        ASSERT(dwSDRev == SECURITY_DESCRIPTOR_REVISION);
        ASSERT(sdc & SE_SELF_RELATIVE);
    }
#endif

    if (propSecurity != ILLEGAL_PROPID_VALUE)
    {
        if(pSecurityDescriptor == NULL)
	{
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 5);
	}

        pAllPropvariants[ securityIndex ].blob.cbSize =
                       GetSecurityDescriptorLength( pSecurityDescriptor ) ;
        pAllPropvariants[ securityIndex ].blob.pBlobData =
                                     (unsigned char *) pSecurityDescriptor;
        pAllPropvariants[ securityIndex ].vt = VT_BLOB;
        pAllPropids[ securityIndex ] = propSecurity;
    }

    if (dwObjectType == MQDS_USER)
    {
        //
        // Set the SID property of the user object according to the owner
        // field of the security descriptor.
        //
        ASSERT(iSid != -1);

        pAllPropvariants[iSid].vt = VT_BLOB;
        pAllPropvariants[iSid].blob.cbSize = GetLengthSid(pUserSid) ;
        pAllPropvariants[iSid].blob.pBlobData = (unsigned char *)pUserSid ;
        pAllPropids[iSid] = PROPID_U_SID;
    }

    *pcpOut =  dwNumOfObjectProps;
    *ppOutProp =  pAllPropids.detach();
    *ppOutPropvariant = pAllPropvariants.detach();
    return(MQ_OK);
}


/*====================================================

VerifyInternalCert

Arguments:

Return Value:


=====================================================*/

HRESULT VerifyInternalCert(
             IN  DWORD                  cp,
             IN  PROPID                 aProp[],
             IN  PROPVARIANT            apVar[],
             OUT BYTE                 **ppMachineSid )
{
    //
    // Verify that the self signature of internal certificates is OK.
    //
    DWORD i;
    HRESULT hr = MQ_OK;
    BOOL    fMachine = FALSE ; // TRUE for computer object.

    //
    // Find the certificate property.
    //
    for ( i = 0 ; i < cp ; i++)
    {
        if (aProp[i] == PROPID_U_SIGN_CERT)
        {
            break ;
        }
        else if (aProp[i] == PROPID_COM_SIGN_CERT)
        {
            fMachine = TRUE ;
            break ;
        }
    }
    if (i == cp)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 10);
    }

    //
    // Create a certificate object.
    //
    R<CMQSigCertificate> pCert ;

    hr = MQSigCreateCertificate( &pCert.ref(),
                                 NULL,
                                 apVar[i].blob.pBlobData,
                                 apVar[i].blob.cbSize ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    // Look for the locality and the common name.
    //
    BOOL fInternalCert = FALSE;
    P<WCHAR> pwszLoc = NULL;
    P<WCHAR> wszCN = NULL;

    hr = pCert->GetIssuer( &pwszLoc,
                           NULL,
                           NULL,
                           &wszCN ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (pwszLoc)
    {
        fInternalCert = (lstrcmpi(pwszLoc, MQ_CERT_LOCALITY) == 0) ;
    }

    if (!fInternalCert)
    {
        //
        // Not an internal certificate. Quit !
        //
        return LogHR(hr, s_FN, 40);
    }

    //
    // Verify that the self signature is OK.
    //
    hr= pCert->IsCertificateValid( pCert.get(),
                                   x_dwCertValidityFlags,
                                   NULL,
                                   TRUE ) ; // ignore NotBefore.
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 50);
        return MQ_ERROR_INVALID_CERTIFICATE;
    }

    //
    // Replace system sid in PROPID_U_SID with SID of machine account.
    //
    for ( i = 0 ; i < cp ; i++ )
    {
        if (aProp[i] == PROPID_U_SID)
        {
            if (MQSec_IsSystemSid((PSID)apVar[i].blob.pBlobData))
            {
                DWORD dwSize = 0 ;
                *ppMachineSid = (BYTE*)MQSec_GetLocalMachineSid( TRUE, &dwSize );
				if (NULL == *ppMachineSid)
				{
					LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 55);
				}

                apVar[i].blob.pBlobData = *ppMachineSid ;
                apVar[i].blob.cbSize = dwSize ;
                aProp[i] = PROPID_COM_SID ;
            }
            else if (fMachine)
            {
                //
                // SID of computer object. Replace propid that was set in
                // SetDefaultValues().
                //
                aProp[i] = PROPID_COM_SID ;
            }
            break ;
        }
    }
    if (i == cp)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 60);
    }

    //
    // Verify that the user's SID matches the DOMAIN\account in the
    // certificate's common name.
    //
    LPWSTR pComma;

    if (!wszCN || ((pComma = wcschr(wszCN, L',')) == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 70);
    }

    *pComma = L'\0';

    BYTE  abSid[128] ;
    PSID  pSid = (PSID)abSid;
    DWORD dwSidLen = sizeof(abSid);
    AP<BYTE> pbLongSid;
    WCHAR wszRefDomain[64];
    DWORD dwRefDomainLen = sizeof(wszRefDomain) / sizeof(WCHAR);
    LPWSTR pwszRefDomain = wszRefDomain;
    AP<WCHAR> wszLongRefDomain;
    SID_NAME_USE eUse;

    //
    // Get the user's SID according to the DOMAIN\account found in
    // the certificate's common name.
    //
    if (!LookupAccountName(
            NULL,
            wszCN,
            pSid,
            &dwSidLen,
            pwszRefDomain,
            &dwRefDomainLen,
            &eUse))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            if (dwSidLen > sizeof(abSid))
            {
                //
                // Allocate a larger buffer for the SID.
                //
                pbLongSid = new BYTE[dwSidLen];
                pSid = (PSID)pbLongSid;
            }

            if (dwRefDomainLen > sizeof(wszRefDomain) / sizeof(WCHAR))
            {
                //
                // Allocate a larger buffer for the reference
                // domain name.
                //
                wszLongRefDomain = new WCHAR[dwRefDomainLen];
                pwszRefDomain = wszLongRefDomain;
            }

            if (!LookupAccountName(
                    NULL,
                    wszCN,
                    pSid,
                    &dwSidLen,
                    pwszRefDomain,
                    &dwRefDomainLen,
                    &eUse))
            {
                ASSERT(0);
                hr = MQ_ERROR_INVALID_CERTIFICATE;
            }
        }
        else
        {
            hr = MQ_ERROR_INVALID_CERTIFICATE;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!EqualSid(pSid, (PSID)apVar[i].blob.pBlobData))
        {
            return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 80);
        }
    }

    return LogHR(hr, s_FN, 90);
}


//-------------------------------------
//
//  DllMain
//
//-------------------------------------

static void SetAssertBenign(void)
{
#ifdef _DEBUG
    DWORD AssertBenignValue = 0;
    const RegEntry reg(L"Debug", L"AssertBenign");
    CmQueryValue(reg, &AssertBenignValue);
    g_fAssertBenign = (AssertBenignValue != 0);
#endif
}

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID /* lpvReserved */)
{
    BOOL result = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            g_hInstance = hMod ;
            MQUInitGlobalScurityVars() ;
			CmInitialize(HKEY_LOCAL_MACHINE, GetFalconSectionName(), KEY_READ);
			SetAssertBenign();
            break;
        }

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;

    }
    return(result);
}

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), RPC STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), BOOL: 0x%x", wszFileName, usPoint, b);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\rpcsrv.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpcsrv.cpp

Abstract:

    Implementation of DS CLIENT-SERVER API, server side.

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (IlanH)   9-July-2000 

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "_mqrpc.h"
#include "dscomm.h"
#include <uniansi.h>
#include <mqsocket.h>
#include <strsafe.h>

#include "rpcsrv.tmh"

#define  RPCSRV_START_MQIS_IP_EP   2101

static RPC_BINDING_VECTOR *g_pBindings ;  // used for rpc dynamic endpoints.

static WCHAR *s_FN=L"mqdssrv/rpcsrv";


static
RPC_STATUS 
DSSpStartRpcServer(
	void
	)
/*++

Routine Description:
	Rpc Server Start listening.

Arguments:
	None.

Returned Value:
	RPC_S_OK if success, else failure code. 

--*/
{
	//
	// Issuing RPC Listen ourselves.
	//
	// Note for WinNT: all our interfaces are registed as "AUTOLISTEN".
	// The only reason we need this call here is to enable Win95 (and w2k)
	// clients to call us. Otherwise, when Win95 call RpcBindingSetAuthInfo()
	// it will get a Busy (0x6bb) error.
	//  BUGBUG, DoronJ, 15-Jan-97. This may be fixed if SetAuthInfo() specify
	//  a principal name.
	//
	// Note for Win95: On Win95 we must issue the listen.
	// RpcServerRegisterIfEx() was not implemented in the first release of
	// Win95. It was added only in the DCOM95 service pack.
	//
	// This initialization is needed also for w2k.
	// Otherwise RpcMgmt*() will get a Busy (0x6bb) error.
	// This is by design of the RPC but might be changed
	// ilanh 9-July-2000
	//
	
	//
	// fDontWait = TRUE, Functions return immediatly after completing 
	//
	RPC_STATUS status = RpcServerListen( 
							1,
							RPC_C_LISTEN_MAX_CALLS_DEFAULT,
							TRUE  // fDontWait
							);

    TrTRACE(RPC, "MQDSSRV: RpcServerListen() returned 0x%x", status);

	//
	// On WinNT, a listen may be issued by DTC, until they fix their
	// code to use RegisterIfEx() instead of RegisterIf().
	//
	if((status == RPC_S_OK) || (status == RPC_S_ALREADY_LISTENING))
		return (RPC_S_OK);

	ASSERT(("RpcServerListen returned status != RPC_S_OK", 0));

    return LogRPCStatus(status, s_FN, 5);
}


static
RPC_STATUS
DSSpRpcServerUseProtseqEp(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    unsigned short __RPC_FAR * Endpoint
    )
/*++

Routine Description:
	Register Dynamic EndPoint and fix EndPoint for the protocol 

Arguments:
	Protseq	- string identifier of the protocol sequence 
	MaxCalls - max rpc calls
	Endpoint - endpoint	(could be null for dynamic endpoint)

Returned Value:
	RPC_S_OK if success, else failure code. 

--*/
{
    //
    // Listen only on IP addresses we get from winsock.
    // This enables multiple QMs to listen each to its
    // own addresses, in a cluster environment. (ShaiK)
    //

    PHOSTENT pHostEntry = gethostbyname(NULL);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 20);
    }

    for ( DWORD ix = 0; pHostEntry->h_addr_list[ix] != NULL; ++ix)
    {
        WCHAR wzAddress[50];
        int retval = ConvertToWideCharString(
		            inet_ntoa(*(struct in_addr *)(pHostEntry->h_addr_list[ix])),
		            wzAddress,
		            TABLE_SIZE(wzAddress)
		            );
        ASSERT(retval != 0);
        DBG_USED(retval);

        RPC_POLICY policy;
        policy.Length = sizeof(policy);
        policy.EndpointFlags = 0;
        policy.NICFlags = 0;

        RPC_STATUS status = RPC_S_OK;
        if (NULL != Endpoint)
        {
            status = I_RpcServerUseProtseqEp2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         Endpoint,
                         NULL,
                         &policy
                         );

            TrTRACE(RPC, "MQDSSRV: I_RpcServerUseProtseqEp2 (%ls, %ls, %ls) returned 0x%x", wzAddress, Protseq, Endpoint, status);
        }
        else
        {
            status = I_RpcServerUseProtseq2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         NULL,
                         &policy
                         );

            TrTRACE(RPC, "MQDSSRV: I_RpcServerUseProtseq2 (%ls, %ls) returned 0x%x",wzAddress, Protseq, status);
        }

        if (RPC_S_OK != status)
        {
            return LogRPCStatus(status, s_FN, 30);
        }
    }

    return RPC_S_OK;

}


DWORD  DSSpRegisterDynamicEnpoint(
    IN unsigned int  cMaxCalls,
    IN DWORD         dwFirstEP
    )
/*++

Routine Description:
	Register Dynamic EndPoint and fix EndPoint for the protocol 

Arguments:
	cMaxCalls - max rpc calls
	dwFirstEP - first static EndPoint to try

Returned Value:
	The fix endpoint which will be used for the real interface communnication. 

--*/
{
    LPWSTR lpProtocol = RPC_TCPIP_NAME;

    //
    // Register this protocol for dynamic endpoint
    //
	RPC_STATUS status = DSSpRpcServerUseProtseqEp(
							lpProtocol,
							cMaxCalls,
							NULL 	/* Endpoint */
							);
    
	if (status == RPC_S_OK)
	{
		//
		// Now register a fix endpoint which will be used for the real
		// interface communnication.
		//
		WCHAR wszEndpoint[24];
		for (DWORD j = dwFirstEP; j < dwFirstEP + 1000; j = j + 11)
		{
			HRESULT hr = StringCchPrintf(wszEndpoint, TABLE_SIZE(wszEndpoint), L"%lu", j);
			ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);

			status = DSSpRpcServerUseProtseqEp(
						lpProtocol,
						cMaxCalls,
						wszEndpoint
						);

			if (status == RPC_S_OK)
			{
			   return j;
			}

			LogRPCStatus(status, s_FN, 50);
		}
	}

	TrWARNING(RPC, "MQDSSRV: DSSpRV_RegisterDynamicEnpoint: failed to register %ls",lpProtocol);

	return 0;
}

RPC_STATUS RPC_ENTRY dscommSecurityCallback(
	RPC_IF_HANDLE, 
	void* hBind
	)
{	
	TrTRACE(RPC, "dscommSecurityCallback starting");
	
	if (!mqrpcIsTcpipTransport(hBind))
    {
        TrERROR(RPC, "Failed to verify Remote RPC");
		ASSERT_BENIGN(("Failed to verify Remote RPC", 0));
		return ERROR_ACCESS_DENIED;
    }

	TrTRACE(RPC, "dscommSecurityCallback passed successfully");
	return RPC_S_OK;
}




//
// These are the fix ports used for real MQIS interface communication.
//
static DWORD s_dwIPPort  = 0 ;

/*====================================================

Function: RpcServerInit

Arguments:

Return Value:

=====================================================*/

RPC_STATUS RpcServerInit(void)
{
    TrTRACE(DS, "MQDSSRV: RpcServerInit");

    RPC_STATUS  status;
    unsigned int cMaxCalls = RPC_C_LISTEN_MAX_CALLS_DEFAULT;

    //
    // See if we use dynamic or predefined endpoints. By default we use
    // dynamic endpoints.
    //
    BOOL  fUsePredefinedEP =  RPC_DEFAULT_PREDEFINE_DS_EP;
    DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_DS_EP;

    READ_REG_DWORD( 
		fUsePredefinedEP,
		RPC_PREDEFINE_DS_EP_REGNAME,
		&ulDefault 
		);

    BOOL fIPRergistered = FALSE;
    if (fUsePredefinedEP)
    {
		//
		// Read the IP port for RPC.
		//
		WCHAR  wzDsIPEp[MAX_REG_DEFAULT_LEN];
		DWORD  dwSize = sizeof(wzDsIPEp);

		HRESULT hr = GetThisServerIpPort(wzDsIPEp, dwSize);
		if (FAILED(hr))
		{
		   return LogHR(hr, s_FN, 55);
		}

		RPC_STATUS  statusIP =  RpcServerUseProtseqEp( 
									RPC_TCPIP_NAME,
									cMaxCalls,
									wzDsIPEp,
									NULL
									);

		TrTRACE(RPC, "MQDSSRV: RpcServerUseProtseqEp (tcp/ip) returned 0x%x", statusIP);

		fIPRergistered = (statusIP == RPC_S_OK);
    }
    else
    {
		s_dwIPPort = DSSpRegisterDynamicEnpoint( 
						cMaxCalls,
						RPCSRV_START_MQIS_IP_EP 
						);

		fIPRergistered =  (s_dwIPPort != 0);
    }

    if (!fUsePredefinedEP)
    {
		status = RpcServerInqBindings(&g_pBindings);
		if (status == RPC_S_OK)
		{
			status = RpcEpRegister( 
						dscomm_v1_0_s_ifspec,
						g_pBindings,
						NULL,
						L"Message Queuing Downlevel Client Support - V1" 
						);
		}

		TrERROR(DS, "MQDSSRV: Registering Endpoints, status- %lxh", status);

		if (status != RPC_S_OK)
		{
			//
			// can't register endpoints, can't be rpc server
			//
			return(RPC_S_PROTSEQ_NOT_SUPPORTED) ;
		}
		status = RpcEpRegister( 
					dscomm2_v1_0_s_ifspec,
					g_pBindings,
					NULL,
					L"Message Queuing Downlevel Client Support - V2" 
					);

		LogRPCStatus(status, s_FN, 60);

		TrERROR(DS, "MQDSSRV: Registering dscomm2 Endpoints, status- %lxh", status);

		if (status != RPC_S_OK)
		{
		  //
		  // can't register endpoints, can't be rpc server
		  //
		  return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 70);
		}
	}

    if (!fIPRergistered)
    {
		//
		// can't register IP. Quit. We're quite useless.
		//
		TrERROR(DS, "MQDSSRV: RpcServerInit can't use IP");


		//
		// If use some local RPC need to check it here 
		//

		//
		// Can't use any RPC protocol. We're completely useless!
		//
		return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 80);
    }

    //
    // We register this interface as AUTO_LISTEN, so we start listengin now,
    // and do not depend on a call to RpcListen elsewhere.
	// This is TRUE but RpcMgmt* will return error till we explicitly
	// call RpcServerListen()   ilanh 10-July-2000
    //
    status = RpcServerRegisterIfEx( 
				dscomm_v1_0_s_ifspec,
				NULL,
				NULL,
				RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
				cMaxCalls,
				dscommSecurityCallback 
				);

    TrTRACE(RPC, "MQDSSRV: RpcServerRegisterIf returned 0x%x",status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 90);
    }

    status = RpcServerRegisterIfEx( 
				dscomm2_v1_0_s_ifspec,
				NULL,
				NULL,
				RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
				cMaxCalls,
				dscommSecurityCallback
				);

    TrTRACE(RPC, "MQDSSRV: RpcServerRegisterIf of dscomm2 returned 0x%x", status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 100);
    }

    status = RpcServerRegisterAuthInfo(
				NULL, 
				RPC_C_AUTHN_WINNT, 
				NULL, 
				NULL
				);

    TrTRACE(DS, "MQDSSRV: RpcServerRegisterAuthInfo(ntlm) returned 0x%x",status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 110);
    }

    //
    // #3117, for NT5 Beta2
    // Jul/16/1998 RaananH, added kerberos support
    //
    // register kerberos authenticaton
    //
    // kerberos needs principal name
    //
    LPWSTR pwszPrincipalName = NULL;
    status = RpcServerInqDefaultPrincName(
				RPC_C_AUTHN_GSS_KERBEROS,
				&pwszPrincipalName
				);

    TrTRACE(DS, "MQDSSRV: RpcServerInqDefaultPrincName(kerberos) returned 0x%x", status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 120);
    }
    status = RpcServerRegisterAuthInfo( 
				pwszPrincipalName,
				RPC_C_AUTHN_GSS_KERBEROS,
				NULL,
				NULL 
				);

    RpcStringFree(&pwszPrincipalName);
    TrTRACE(DS, "MQDSSRV: RpcServerRegisterAuthInfo(kerberos) returned 0x%x",status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 130);
    }

	//
	// Call for RpcServerListen() ourself
	// Without this call although our interfaces are register as AUTO_LISTEN
	// RpcMgmt*() functions will return error
	//
	status = DSSpStartRpcServer();

    return (status);
}

/*====================================================

RoutineName: S_DSGetServerPort()

Arguments: None

Return Value:

=====================================================*/

DWORD
S_DSGetServerPort( 
	/*[in]*/  handle_t /* hBind */,
	/*[in]*/  DWORD fIP
	)
{

	//
	// Error return null port
	//
	if(fIP == (DWORD) -1)
		return 0;

	//
	// Support only IP port
	//
	if(fIP)
	  return s_dwIPPort;

	//
	// Error return null port - dont support IPX
	//
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\acapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acapi.h

Abstract:
    Falcon interface to the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96

--*/

#ifndef _ACAPI_H
#define _ACAPI_H

#include <portapi.h>


extern TCHAR g_wzDeviceName[];
#define MQAC_NAME g_wzDeviceName

//---------------------------------------------------------
//
// IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
// Falcon RT DLL interface to AC driver
//
//---------------------------------------------------------

inline
HRESULT
ACCreateHandle(
    PHANDLE phDevice
    )
{
    return MQpCreateFileW(
            MQAC_NAME,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phDevice
            );
}

inline
HRESULT
ACCloseHandle(
    HANDLE hQueue
    )
{
    return MQpCloseHandle(hQueue);
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    BOOL fCheckMachineQuota,
    CACSendParameters& SendParams
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                fCheckMachineQuota,
                &SendParams,
                sizeof(SendParams)
                );
}

inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    CACSendParameters& SendParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                TRUE,
                &SendParams,
                sizeof(SendParams),
                lpOverlapped
                );
}

inline
HRESULT
ACReceiveMessage(
    HANDLE hQueue,
    CACReceiveParameters& ReceiveParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_RECEIVE_MESSAGE,
                &ReceiveParams,
                sizeof(ReceiveParams),
                0,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACReceiveMessageByLookupId(
    HANDLE hQueue,
    CACReceiveParameters& ReceiveParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID,
                &ReceiveParams,
                sizeof(ReceiveParams),
                0,
                0,
                lpOverlapped
                );
}


inline
HRESULT
ACCreateCursor(
    HANDLE hQueue,
    HACCursor32* phCursor
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CREATE_CURSOR,
                0,
                0,
                phCursor,
                sizeof(*phCursor)
                );
}


inline
HRESULT
ACCreateCursor(
    HANDLE hQueue,
    HACCursor32* phCursor,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CREATE_CURSOR,
                0,
                0,
                phCursor,
                sizeof(*phCursor),
                lpOverlapped
                );
}


inline
HRESULT
ACCloseCursor(
    HANDLE hQueue,
    HACCursor32 hCursor
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CLOSE_CURSOR,
                0,
                0,
                LongToPtr(hCursor),
                0
                );
}


inline
HRESULT
ACHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_HANDLE_TO_FORMAT_NAME,
                lpdwFormatNameLength,
                sizeof(DWORD),
                lpwcsFormatName,
                *lpdwFormatNameLength
                );
}

inline
HRESULT
ACPurgeQueue(
    HANDLE hQueue
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_PURGE_QUEUE,
                0,
                0,
                0,
                0
                );
}


//---------------------------------------------------------
//
// QM control APIs
//
//---------------------------------------------------------

inline
HRESULT
ACPurgeQueue(
    HANDLE hQueue,
    BOOL   fDelete,
    USHORT usClass
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_INTERNAL_PURGE_QUEUE,
                0,
                fDelete,
                0,
                usClass
                );
}


inline
HRESULT
ACSetQueueProperties(
    HANDLE hQueue,
    BOOL fJournalQueue,
    BOOL fAuthenticate,
    ULONG ulPrivLevel,
    ULONG ulQuota,
    ULONG ulJournalQuota,
    LONG lBasePriority,
    BOOL fTransactionalQueue,
    const GUID* pgConnectorQM,
    BOOL fUnknownQueueType
    )
{
    CACSetQueueProperties qp = {
        fJournalQueue,
        fAuthenticate,
        ulPrivLevel,
        ulQuota,
        ulJournalQuota,
        lBasePriority,
        fTransactionalQueue,
        fUnknownQueueType,
        pgConnectorQM
    };

    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_SET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACGetQueueProperties(
    HANDLE hQueue,
    CACGetQueueProperties& qp
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACGetQueueHandleProperties(
    HANDLE hQueue,
    CACGetQueueHandleProperties& qhp
    )
{
    return MQpDeviceIoControl(
               hQueue,
               IOCTL_AC_GET_QUEUE_HANDLE_PROPS,
               0,
               0,
               &qhp,
               sizeof(qhp)
               );
}


inline
HRESULT
ACCreateDistribution(
    DWORD              nQueues,
    const HANDLE       hQueues[],
    const bool         HttpSend[],
    DWORD              nTopLevelQueueFormats,
    const QUEUE_FORMAT TopLevelQueueFormats[],
    PHANDLE            phDistribution
    )
{
    
	HANDLE hDistribution;
    HRESULT rc = ACCreateHandle(&hDistribution);
    if (FAILED(rc))
    {
        return rc;
    }

    CACCreateDistributionParameters cdp = {
        TopLevelQueueFormats,
        nTopLevelQueueFormats,
        hQueues,
        HttpSend,
        nQueues
    };

    rc = MQpDeviceIoControl(
             hDistribution,
             IOCTL_AC_CREATE_DISTRIBUTION,
             0,
             0,
             &cdp,
             sizeof(cdp)
             );

    if (FAILED(rc))
    {
        ACCloseHandle(hDistribution);
		return rc;
    }
	
	*phDistribution = hDistribution;
	return rc;

} // ACCreateDistribution


inline
HRESULT
ACCreateQueue(
    BOOL fTargetQueue,
    const GUID* pDestGUID,
    const QUEUE_FORMAT* pQueueID,
    QueueCounters* pQueueCounters,
    LONGLONG liSeqID,
    ULONG ulSeqNo,
	const CSenderStream* SenderStream,
    PHANDLE phQueue
    )
{
    HANDLE hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateQueueParameters cqp = {
        fTargetQueue,
        pDestGUID,
        pQueueID,
        pQueueCounters,
        liSeqID,
        ulSeqNo,
		SenderStream
    };


    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_QUEUE,
            0,
            0,
            &cqp,
            sizeof(cqp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}

inline
HRESULT
ACCreateRemoteProxy(
    const QUEUE_FORMAT* pQueueID,
    const VOID* cli_pQMQueue, // CBaseRRQueue*
    PHANDLE phQueue
    )
{
	HANDLE 	hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateRemoteProxyParameters cpp = {
        pQueueID,
        cli_pQMQueue
    	};

    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_REMOTE_PROXY,
            0,
            0,
            &cpp,
            sizeof(cpp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}


inline
HRESULT
ACCreateRemoteCursor(
    HANDLE hProxyQueue,
    ULONG hRemoteCursor,
    ULONG ulTag
	)
{
    CACCreateRemoteCursorParameters crcp = {
        ulTag,
        hRemoteCursor
    	};

    return MQpDeviceIoControl(
	            hProxyQueue,
	            IOCTL_AC_CREATE_REMOTE_CURSOR,
	            &crcp,
	            sizeof(crcp),
	            0,
	            0
	            );
}


inline
HRESULT
ACCreateTransaction(
    const XACTUOW* pXactUow,
    PHANDLE phQueue
    )
{
	HANDLE hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_TRANSACTION,
            0,
            0,
            const_cast<XACTUOW*>(pXactUow),
            sizeof(*pXactUow)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}

inline
HRESULT
ACGetServiceRequest(
    HANDLE hDevice,
    CACRequest* pRequest,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_GET_SERVICE_REQUEST,
            0,
            0,
            pRequest,
            sizeof(*pRequest),
            lpOverlapped
            );
}


inline
HRESULT
ACCreatePacketCompleted(
    HANDLE    hDevice,
    CPacket * pOriginalDriverPacket,
    CPacket * pNewDriverPacket,
    HRESULT   result,
    USHORT    ack
    )
{   
    return MQpDeviceIoControl(
               hDevice,
               IOCTL_AC_CREATE_PACKET_COMPLETED,
               pOriginalDriverPacket,
               result,
               pNewDriverPacket,
               ack
               );
}


inline
HRESULT
ACStorageCompleted(
    HANDLE hDevice,
    ULONG count,
    VOID* const* pCookieList,
    HRESULT result
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_STORE_COMPLETED,
            const_cast<VOID**>(pCookieList),
            count * sizeof(VOID*),
            (VOID*)(LONG_PTR)result,
            0
            );
}

inline
HRESULT
ACAckingCompleted(
    HANDLE hDevice,
    const VOID* pCookie
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ACKING_COMPLETED,
            0,
            0,
            const_cast<VOID*>(pCookie),
            0
            );
}

inline
HRESULT
ACXactGetInformation(
    HANDLE hXact,
    CACXactInformation *pInfo
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_GET_INFORMATION,
            0,
            0,
            pInfo,
            sizeof(*pInfo)
            );
}

inline
HRESULT
ACConnect(
    HANDLE hDevice,
    const GUID* pguidSourceQM,
    PWCHAR pStoragePath[AC_PATH_COUNT],
    ULONGLONG MessageID,
    ULONG ulPoolSize,
    LONGLONG liSeqIDAtRestore,
    BOOL  fXactCompatibilityMode
    )
{
    
    CACConnectParameters cp;
    cp.pgSourceQM = pguidSourceQM;
    cp.MessageID = MessageID;
    cp.ulPoolSize = ulPoolSize;
    cp.liSeqIDAtRestore = liSeqIDAtRestore;
    cp.fXactCompatibilityMode = fXactCompatibilityMode;

    for(int i = 0; i < AC_PATH_COUNT; ++i)
    {
        cp.pStoragePath[i] = pStoragePath[i];
    }

    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_CONNECT,
            0,
            0,
            &cp,
            sizeof(cp)
            );
}

inline
HRESULT
ACSetMachineProperties(
    HANDLE hDevice,
    ULONG ulQuota
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_SET_MACHINE_PROPS,
            0,
            0,
            0,
            ulQuota
            );
}

inline
HRESULT
ACAssociateQueue(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    bool  fProtocolSrmp
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_QUEUE,
            reinterpret_cast<PVOID>(fProtocolSrmp),
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateJournal(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_JOURNAL,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateDeadxact(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_DEADXACT,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACPutRestoredPacket(
    HANDLE hQueue,
    CPacket * pPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_RESTORED_PACKET,
            0,
            0,
            pPacket,
            0
            );
}

inline
HRESULT
ACGetRestoredPacket(
    HANDLE hDriver,
    CACRestorePacketCookie * pPacketCookie
    )
{

    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_GET_RESTORED_PACKET,
            0,
            0,
            pPacketCookie,
            sizeof(CACRestorePacketCookie)
            );
}

inline
HRESULT
ACGetPacketByCookie(
    HANDLE hDriver,
    CACPacketPtrs * pPacketPtrs
    )
{
    return MQpDeviceIoControl(
               hDriver,
               IOCTL_AC_GET_PACKET_BY_COOKIE,
               0,
               0,
               pPacketPtrs,
               sizeof(CACPacketPtrs)
               );
}

inline
HRESULT
ACRestorePackets(
    HANDLE hDriver,
    PWSTR pLogPath,
    PWSTR pFilePath,
    ULONG ulFileID,
    ACPoolType pt
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_RESTORE_PACKETS,
            pLogPath,
            pt,
            pFilePath,
            ulFileID
            );
}

inline
HRESULT
ACSetMappedLimit(
   HANDLE hDriver,	
   ULONG ulMaxMappedFiles
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_MAPPED_LIMIT,
            0,
            0,
            0,
            ulMaxMappedFiles
            );
}

inline
HRESULT
ACSetPerformanceBuffer(
    HANDLE hDriver,
    HANDLE hPerformanceSection,
    PVOID  pvPerformanceBuffer,
    QueueCounters *pMachineQueueCounters,
    QmCounters *pQmCounters
    )
{
#ifdef _WIN64
    CACSetPerformanceBuffer cPerf = {
        hPerformanceSection,
        pvPerformanceBuffer,
        pMachineQueueCounters,
        pQmCounters
    };
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_PERFORMANCE_BUFF,
            0,
            0,
            &cPerf,
            sizeof(cPerf)
            );
#else //!_WIN64
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_PERFORMANCE_BUFF,
            hPerformanceSection,
            reinterpret_cast<DWORD>(pQmCounters),
            pvPerformanceBuffer,
            reinterpret_cast<DWORD>(pMachineQueueCounters)
            );
#endif //_WIN64
}

inline
HRESULT
ACReleaseResources(
    HANDLE hDevice
    )
{
    return MQpDeviceIoControl(
                hDevice,
                IOCTL_AC_RELEASE_RESOURCES,
                0,
                0,
                0,
                0
                );
}


inline
HRESULT
ACConvertPacket(
	HANDLE       hDriver,
	CPacket *    pDriverPacket,
    BOOL         fStore,
	LPOVERLAPPED lpOverlapped
	)
{
   return MQpDeviceIoControl(
				hDriver,
                IOCTL_AC_CONVERT_PACKET,
                0,
                fStore,
                pDriverPacket,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACIsSequenceOnHold(
    HANDLE hQueue,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_IS_SEQUENCE_ON_HOLD,
            0,
            0,
            pDriverPacket,
            0
            );
}


inline
HRESULT
ACSetSequenceAck(
    HANDLE hQueue,
    LONGLONG liAckSeqID,
    ULONG    ulAckSeqN
    )
{
    CACSetSequenceAck ssa;
    ssa.liAckSeqID = liAckSeqID;
    ssa.ulAckSeqN  = ulAckSeqN;

    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SET_SEQUENCE_ACK,
                0,
                0,
                &ssa,
                sizeof(ssa)
                );
}

inline
HRESULT
ACGetUsedQuota(
	HANDLE hDriver,
	ULONGLONG* pullUsedQuota
	)
{
	    return MQpDeviceIoControl(
                hDriver,
                IOCTAL_AC_GET_USED_QUOTA,
                0,
                0,
                pullUsedQuota,
                sizeof(ULONGLONG)
                );
}


//---------------------------------------------------------
//
// QM network interface APIs
//
//---------------------------------------------------------

inline
HRESULT
ACAllocatePacket(
    HANDLE hDevice,
    ACPoolType pt,
    DWORD dwSize,
    CACPacketPtrs& PacketPtrs,
    BOOL fCheckMachineQuota = TRUE
    )
{

    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ALLOCATE_PACKET,
            reinterpret_cast<PVOID>((ULONG_PTR)fCheckMachineQuota),
            pt,
            &PacketPtrs,
            dwSize
            );
}

inline
HRESULT
ACFreePacket(
    HANDLE hDevice,
    CPacket * pDriverPacket,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET,
            0,
            0,
            pDriverPacket,
            usClass
            );
}

inline
HRESULT
ACFreePacket2(
    HANDLE hDevice,
    const VOID* pCookie,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET2,
            0,
            0,
            const_cast<VOID*>(pCookie),
            usClass
            );
}

inline
HRESULT
ACFreePacket1(
    HANDLE hDevice,
    const VOID* pCookie,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET1,
            0,
            0,
            const_cast<VOID*>(pCookie),
            usClass
            );
}

inline
HRESULT
ACArmPacketTimer(
    HANDLE hDevice,
    const VOID* pCookie,
    BOOL fTimeToBeReceived,
    ULONG ulDelay
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ARM_PACKET_TIMER,
            0,
            ulDelay,
            const_cast<VOID*>(pCookie),
            fTimeToBeReceived
            );
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            pDriverPacket,
            0
            );
}

//
//  Asynchronous, using an overlapped
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    CPacket * pDriverPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            pDriverPacket,
            0,
            lpOverlapped
            );
}

//
//  Asynchronous, using an overlapped;  with Receive setting
//
inline
HRESULT
ACPutPacket1(
    HANDLE hQueue,
    CPacket * pDriverPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET1,
            0,
            0,
            pDriverPacket,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACGetPacket(
    HANDLE hQueue,
    CACPacketPtrs& PacketPtrs,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_PACKET,
            0,
            0,
            &PacketPtrs,
            sizeof(PacketPtrs),
            lpOverlapped
            );
}

inline
HRESULT
ACCreateGroup(
    PHANDLE phGroup,
    BOOL    fPeekByPriority
    )
{
    HRESULT rc;
    rc = MQpCreateFileW(
            MQAC_NAME,
            GENERIC_READ,
            FILE_SHARE_READ,
            0,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phGroup
            );

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            *phGroup,
            IOCTL_AC_CREATE_GROUP,
            0,
            fPeekByPriority,
            0,
            0
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phGroup);
    }

    return rc;
}

inline
HRESULT
ACCanCloseQueue(
    HANDLE hQueue
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CAN_CLOSE_QUEUE,
            0,
            0,
            0,
            0
            );
}

inline
HRESULT
ACMoveQueueToGroup(
    HANDLE hQueue,
    HANDLE hGroup
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_MOVE_QUEUE_TO_GROUP,
            0,
            0,
            hGroup,
            0
            );
}


//----------------------------------------------------
//
//   APIs for remote reading.
//
//----------------------------------------------------

inline
HRESULT
ACBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_BEGIN_GET_PACKET_2REMOTE,
            &g2r,
            sizeof(g2r),
            &packetPtrs,
            sizeof(packetPtrs),
            lpOverlapped
            );
}

inline
HRESULT
ACEndGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_END_GET_PACKET_2REMOTE,
            0,
            0,
            &g2r,
            sizeof(g2r)
            );
}

inline
HRESULT
ACCancelRequest(
    HANDLE hQueue,
    NTSTATUS status,
    ULONG ulTag
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CANCEL_REQUEST,
            0,
            status,
            0,
            ulTag
            );
}

inline
HRESULT
ACPutRemotePacket(
    HANDLE hQueue,
    ULONG ulTag,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_REMOTE_PACKET,
            0,
            0,
            pDriverPacket,
            ulTag
            );
}

//----------------------------------------------------
//
//   APIs for transaction processing
//
//----------------------------------------------------


inline
HRESULT
ACXactCommit1(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT1,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit2(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT2,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit3(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT3,
            0,
            0,
            0,
			0
            );
}

inline
HRESULT
ACXactAbort1(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT1,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactAbort2(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT2,
            0,
            0,
            0,
			0
            );
}


inline
HRESULT
ACXactPrepare(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactPrepareDefaultCommit(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}


#endif // _ACAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\notifydl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    notifydel.h

Abstract:


Author:

    Ronit Hartmann (ronith)

--*/
#ifndef _NOTIFYDEL_H_
#define _NOTIFYDEL_H_

#include "stdh.h"
#include "mqds.h"
#include "rpcsrv.h"

class CBasicDeletionNotification : public CBaseContextType
{
public:
    CBasicDeletionNotification() : 
	  CBaseContextType(CBaseContextType::eDeleteNotificationCtx) {};

    virtual ~CBasicDeletionNotification() {};

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        ) = 0;
    virtual HRESULT PerformPostDeleteOperations() = 0;

private:

};


class CQueueDeletionNotification : public CBasicDeletionNotification
{
public:
    CQueueDeletionNotification();
    ~CQueueDeletionNotification();

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        );
    virtual HRESULT PerformPostDeleteOperations();

private:
    AP<WCHAR>         m_pwcsQueueName;
    GUID              m_guidQmId;
    BOOL              m_fForeignQm;

};

inline CQueueDeletionNotification::CQueueDeletionNotification()
                :   m_pwcsQueueName(NULL)
{
}

inline CQueueDeletionNotification::~CQueueDeletionNotification()
{
}

inline HRESULT CQueueDeletionNotification::PerformPostDeleteOperations()
{
    return( MQDSPostDeleteQueueActions(
		        m_pwcsQueueName,
		        &m_guidQmId,
		        &m_fForeignQm
		        ));

}

inline HRESULT CQueueDeletionNotification::ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        )
{
    HRESULT hr;
    hr = MQDSPreDeleteQueueGatherInfo(
                pwcsQueueName,
                &m_guidQmId,
                &m_fForeignQm
                );
    if (FAILED(hr))
    {
        return(hr);
    }
    //
    //  keep a copy of the queue name 
    //
    m_pwcsQueueName = new WCHAR[ 1 + wcslen(pwcsQueueName)];
    wcscpy( m_pwcsQueueName, pwcsQueueName);
    return MQ_OK ;
}



class CMachineDeletionNotification : public CBasicDeletionNotification
{
public:
    CMachineDeletionNotification();
    ~CMachineDeletionNotification();

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsMachineName
        );
    virtual HRESULT PerformPostDeleteOperations();
};

inline CMachineDeletionNotification::CMachineDeletionNotification()
{
}

inline CMachineDeletionNotification::~CMachineDeletionNotification()
{
}

inline HRESULT CMachineDeletionNotification::PerformPostDeleteOperations()
{
    return MQ_OK;
}

inline HRESULT CMachineDeletionNotification::ObtainPreDeleteInformation(
        IN   LPCWSTR		/* pwcsMachineName */
        )
{
    return MQ_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ds\mqdssrv\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    precompiled header file for DS Server

Author:

    RaphiR
    Erez Haba (erezh) 25-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>


#include <mqtypes.h>
#include "ds.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include "mqlog.h"

#ifdef MQUTIL_EXPORT
#undef MQUTIL_EXPORT
#endif
#define MQUTIL_EXPORT DLL_IMPORT
#include <_secutil.h>


// This flag or orred with the object type parameter to indicated that the
// function is called via RPC and so the client should be impersonated.
#define IMPERSONATE_CLIENT_FLAG 0x80000000

#define  ILLEGAL_PROPID_VALUE  (-1)

RPC_STATUS RpcServerInit(void);

HRESULT SetDefaultValues(
         IN  DWORD                  dwObjectType,
         IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
         IN  PSID                   pUserSid,
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT DWORD*                 pcpOut,
         OUT PROPID **              ppOutProp,
         OUT PROPVARIANT **         ppOutPropvariant);

HRESULT AddModificationTime(
         IN  DWORD                  dwObjectType,
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT DWORD*                 pcpOut,
         OUT PROPID **              ppOutProp,
         OUT PROPVARIANT **         ppOutPropvariant);

HRESULT InitDefaultValues();

PROPID  GetObjectSecurityPropid( DWORD dwObjectType ) ;

HRESULT VerifyInternalCert(
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT BYTE                 **ppMachineSid ) ;

HRESULT DSDeleteObjectGuidInternal( IN  DWORD        dwObjectType,
                                    IN  CONST GUID*  pObjectGuid,
                                    IN  BOOL         fIsKerberos ) ;

HRESULT DSSetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fIsKerberos ) ;

HRESULT DSSetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  BOOL                    fIsKerberos ) ;

HRESULT
DSCreateObjectInternal( IN  DWORD                  dwObjectType,
                        IN  LPCWSTR                pwcsPathName,
                        IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                        IN  DWORD                  cp,
                        IN  PROPID                 aProp[],
                        IN  PROPVARIANT            apVar[],
                        IN  BOOL                   fKerberos,
                        OUT GUID*                  pObjGuid ) ;

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\ac.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    ac.h

Abstract:
    Falcon AC Driver master include file

Author:
    Erez Haba (erezh) 25-Feb-96

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef __AC_H
#define __AC_H

#include <acioctl.h>
#include <acdef.h>
#include <acapi.h>

#endif // __AC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\acdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acdef.h

Abstract:
    Falcon interface stractures used by the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96
    Shai Kariv (shaik) 11-May-2000

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef _ACDEF_H
#define _ACDEF_H

#include <mqperf.h>
#include <xactdefs.h>
#include <qformat.h>

class CPacket;
struct CBaseHeader;

//
//  Number of pools used for storage
//  Reliable, Persistant, Journal, Deadletter
//
enum ACPoolType {
    ptReliable,
    ptPersistent,
    ptJournal,
    ptLastPool
};

//
//  Path count is pool count plus one for the log path
//
#define AC_PATH_COUNT (ptLastPool + 1)


//---------------------------------------------------------
//
//  class CACRequest
//  AC Request packet passed from AC to QM
//
//---------------------------------------------------------

class CACRequest {
public:

    enum RequestFunction {
        rfAck,
        rfStorage,
        rfCreatePacket,
        rfMessageID,
        rfRemoteRead,
        rfRemoteCancelRead,
        rfRemoteCloseQueue,
        rfRemoteCreateCursor,
        rfRemoteCloseCursor,
        rfRemotePurgeQueue,
        rfTimeout,
        rfEventLog,
    };

    CACRequest(RequestFunction _rf);

public:
    LIST_ENTRY m_link;

    RequestFunction rf;

    union {

        //
        //
        //
        struct {
            ACPoolType pt;
            BOOL fSuccess;
            ULONG ulFileCount;
        } EventLog;

        //
        //  Save message ID request
        //
        struct {
            ULONGLONG Value;
        } MessageID;

        //
        //  Storage request
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            PVOID pAllocator;
			ULONG ulSize;
        } Storage;

        //
        // CreatePacket request
        //
        struct {
            CBaseHeader *  pPacket;
            CPacket *      pDriverPacket;
            bool           fProtocolSrmp;
        } CreatePacket;

        //
        //  Timeout request (xact)
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            BOOL fTimeToBeReceived;
        } Timeout;

        //
        //  ACK/NACK request
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            ULONG ulClass;
            BOOL fUser;
            BOOL fOrder;
            ULONG32 ulAllocatorBlockOffset;             
        } Ack;

        //
        //  Remote requests
        //
        struct {

            //
            //  cli_pQMQueue needed for all requests
            //
            const VOID* cli_pQMQueue; 	// CBaseRRQueue*

            union {
                //
                //  Receive/Peek request
                //
                struct {
                    ULONG ulTag;            // request identifier
                    ULONG hRemoteCursor;
                    ULONG ulAction;
                    ULONG ulTimeout;
            		ULONG MaxBodySize;
            		ULONG MaxCompoundMessageSize;
                    bool  fReceiveByLookupId;
                    ULONGLONG LookupId;
                } Read;

                //
                //  Cancel remote read request
                //
                struct {
                    ULONG ulTag;        // request identifier
                } CancelRead;

                //
                //  Close remote queue request
                //
                struct {
                } CloseQueue;

                //
                //  Create remote cursor request
                //
                struct {
                    ULONG ulTag;            // request identifier
                 } CreateCursor;

                //
                //  Close remote cursor request
                //
                struct {
                    ULONG hRemoteCursor;
                } CloseCursor;

                //
                //  Purge remote queue request
                //
                struct {
                } PurgeQueue;
            };
        } Remote;
    };
};

inline CACRequest::CACRequest(RequestFunction _rf)
{
    rf = _rf;
}


//---------------------------------------------------------
//
//  class CSenderStream - holds sender side stream data
//
//---------------------------------------------------------
class CSenderStream
{
public:
	CSenderStream(
		void
		):
		m_fValid(false),
		m_size(0)
		{
		}
		
	static const int x_MaxDataSize = 48;
		
	CSenderStream(
		const UCHAR* data, 
		ULONG size
		):
		m_fValid(true),
		m_size(min(x_MaxDataSize, size))
		{
			memcpy(m_data, data, m_size);
		}

public:
	bool IsValid()const
	{
		return m_fValid;
	}

	
	const UCHAR* data()const 
	{
		ASSERT(m_fValid);
		return m_data;
	}

	ULONG size()const
	{
		ASSERT(m_fValid);
		return m_size;
	}


private:
	bool m_fValid;
	ULONG m_size;
	UCHAR m_data[x_MaxDataSize];
};



inline bool operator==(const CSenderStream& x1,const CSenderStream& x2)
{
	if(x1.size() != x2.size())
		return false;

	return (memcmp(x1.data(), x2.data(), x1.size()) == 0); 
}

//---------------------------------------------------------
//
//  class CACCreateQueueParameters
//
//---------------------------------------------------------

class CACCreateQueueParameters {
public:
    BOOL fTargetQueue;
    const GUID* pDestGUID;
    const QUEUE_FORMAT* pQueueID;
    QueueCounters* pQueueCounters;
    LONGLONG liSeqID;               // Note: align on 8
    ULONG ulSeqN;
	const CSenderStream* SenderStream;
};

//---------------------------------------------------------
//
//  struct CACSetQueueProperties
//
//---------------------------------------------------------

struct CACSetQueueProperties {
    BOOL fJournalQueue;
    BOOL fAuthenticate;
    ULONG ulPrivLevel;
    ULONG ulQuota;
    ULONG ulJournalQuota;
    LONG lBasePriority;
    BOOL fTransactional;
    BOOL fUnknownType;
    const GUID* pgConnectorQM;
};


//---------------------------------------------------------
//
//  struct CACGetQueueProperties
//
//---------------------------------------------------------

struct CACGetQueueProperties {
    ULONG ulCount;
    ULONG ulQuotaUsed;
    ULONG ulJournalCount;
    ULONG ulJournalQuotaUsed;
    ULONG ulPrevNo;
    ULONG ulSeqNo;
    LONGLONG liSeqID;
};

//---------------------------------------------------------
//
//  struct CACGetQueueHandleProperties
//
//---------------------------------------------------------

struct CACGetQueueHandleProperties {
    //
    // SRMP protocol is used for http queue (direct=http or multicast) and for members
    // in distribution that are http queues.
    //
    bool  fProtocolSrmp;

    //
    // MSMQ proprietary protocol is used for non-http queue and for members in 
    // distribution that are non-http queues.
    //
    bool  fProtocolMsmq;
};

//---------------------------------------------------------
//
//  class CACRemoteProxyProp
//
//---------------------------------------------------------

class CACCreateRemoteProxyParameters {
public:
    const QUEUE_FORMAT* pQueueID;
	const VOID* cli_pQMQueue;
};

//---------------------------------------------------------
//
//  class CACCreateRemoteCursorParameters
//
//---------------------------------------------------------

class CACCreateRemoteCursorParameters {
public:
    ULONG ulTag;
    ULONG hRemoteCursor;
};

//---------------------------------------------------------
//
//  class CACGet2Remote
//
//---------------------------------------------------------

class CACGet2Remote {
public:
   ULONG  RequestTimeout;
   ULONG  Action;
   HACCursor32 Cursor;
   CBaseHeader *  lpPacket;
   CPacket *  lpDriverPacket;
   ULONG* pTag;
   bool      fReceiveByLookupId;
   ULONGLONG LookupId;
};

//---------------------------------------------------------
//
//  class CACConnectParameters
//
//---------------------------------------------------------

class CACConnectParameters {
public:
   ULONGLONG MessageID;
   LONGLONG liSeqIDAtRestore;
   const GUID* pgSourceQM;
   ULONG ulPoolSize;
   PWCHAR pStoragePath[AC_PATH_COUNT];
   BOOL   fXactCompatibilityMode;
};

//---------------------------------------------------------
//
//  class CACXactInformation
//
//---------------------------------------------------------

class CACXactInformation {
public:
   	ULONG nReceives;
	ULONG nSends;
};

//---------------------------------------------------------
//
//  class CACSetSequenceAck
//
//---------------------------------------------------------

class CACSetSequenceAck {
public:
    LONGLONG liAckSeqID;
    ULONG    ulAckSeqN;
};

#ifdef _WIN64
//---------------------------------------------------------
//
//  class CACSetPerformanceBuffer
//
//---------------------------------------------------------

class CACSetPerformanceBuffer {
public:
   HANDLE hPerformanceSection;
   PVOID  pvPerformanceBuffer;
   QueueCounters *pMachineQueueCounters;
   QmCounters *pQmCounters;
};
#endif //_WIN64

//---------------------------------------------------------
//
//  class CACPacketPtrs
//
//---------------------------------------------------------

class CACPacketPtrs {
public:
   CBaseHeader * pPacket;
   CPacket *  pDriverPacket;
};

//---------------------------------------------------------
//
//  class CACRestorePacketCookie
//
//---------------------------------------------------------

class CACRestorePacketCookie {
public:
   ULONGLONG  SeqId;
   CPacket *  pDriverPacket;
};

//--------------------------------------------------------------
//
//  class CACCreateDistributionParameters
//
//--------------------------------------------------------------

class CACCreateDistributionParameters {
public:
	const QUEUE_FORMAT * TopLevelQueueFormats;
    ULONG                nTopLevelQueueFormats;
    const HANDLE *       hQueues;
    const bool *         HttpSend;
    ULONG                nQueues;
};

//------------------------------------------------------------------
//
// MESSAGE_PROPERTIES macro.
//
//------------------------------------------------------------------
#define MESSAGE_PROPERTIES(AC_POINTER)                         \
    USHORT   AC_POINTER            pClass;                     \
    OBJECTID AC_POINTER AC_POINTER ppMessageID;                \
    UCHAR    AC_POINTER AC_POINTER ppCorrelationID;            \
                                                               \
    ULONG    AC_POINTER            pSentTime;                  \
    ULONG    AC_POINTER            pArrivedTime;               \
                                                               \
    UCHAR    AC_POINTER            pPriority;                  \
    UCHAR    AC_POINTER            pDelivery;                  \
    UCHAR    AC_POINTER            pAcknowledge;               \
                                                               \
    UCHAR    AC_POINTER            pAuditing;                  \
    ULONG    AC_POINTER            pApplicationTag;            \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppBody;                     \
    ULONG                          ulBodyBufferSizeInBytes;    \
    ULONG                          ulAllocBodyBufferInBytes;   \
    ULONG    AC_POINTER            pBodySize;                  \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppTitle;                    \
    ULONG                          ulTitleBufferSizeInWCHARs;  \
    ULONG    AC_POINTER            pulTitleBufferSizeInWCHARs; \
                                                               \
    ULONG                          ulAbsoluteTimeToQueue;      \
    ULONG    AC_POINTER            pulRelativeTimeToQueue;     \
    ULONG                          ulRelativeTimeToLive;       \
    ULONG    AC_POINTER            pulRelativeTimeToLive;      \
                                                               \
    UCHAR    AC_POINTER            pTrace;                     \
    ULONG    AC_POINTER            pulSenderIDType;            \
    UCHAR    AC_POINTER AC_POINTER ppSenderID;                 \
    ULONG    AC_POINTER            pulSenderIDLenProp;         \
                                                               \
    ULONG    AC_POINTER            pulPrivLevel;               \
    ULONG                          ulAuthLevel;                \
    UCHAR    AC_POINTER            pAuthenticated;             \
                                                               \
    ULONG    AC_POINTER            pulHashAlg;                 \
    ULONG    AC_POINTER            pulEncryptAlg;              \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppSenderCert;               \
    ULONG                          ulSenderCertLen;            \
    ULONG    AC_POINTER            pulSenderCertLenProp;       \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppwcsProvName;              \
    ULONG                          ulProvNameLen;              \
    ULONG    AC_POINTER            pulAuthProvNameLenProp;     \
                                                               \
    ULONG    AC_POINTER            pulProvType;                \
    BOOL                           fDefaultProvider;           \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppSymmKeys;                 \
    ULONG                          ulSymmKeysSize;             \
    ULONG    AC_POINTER            pulSymmKeysSizeProp;        \
                                                               \
    UCHAR                          bEncrypted;                 \
    UCHAR                          bAuthenticated;             \
                                                               \
    USHORT                         uSenderIDLen;               \
    UCHAR    AC_POINTER AC_POINTER ppSignature;                \
    ULONG                          ulSignatureSize;            \
    ULONG    AC_POINTER            pulSignatureSizeProp;       \
                                                               \
    GUID     AC_POINTER AC_POINTER ppSrcQMID;                  \
    XACTUOW  AC_POINTER            pUow;                       \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppMsgExtension;             \
    ULONG                          ulMsgExtensionBufferInBytes;\
    ULONG    AC_POINTER            pMsgExtensionSize;          \
                                                               \
    GUID     AC_POINTER AC_POINTER ppConnectorType;            \
    ULONG    AC_POINTER            pulBodyType;                \
                                                               \
    ULONG    AC_POINTER            pulVersion;                 \
    UCHAR    AC_POINTER            pbFirstInXact;              \
    UCHAR    AC_POINTER            pbLastInXact;               \
    OBJECTID AC_POINTER AC_POINTER ppXactID;                   \
                                                               \
    ULONGLONG AC_POINTER           pLookupId;                  \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppSrmpEnvelope;             \
    ULONG    AC_POINTER            pSrmpEnvelopeBufferSizeInWCHARs; \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppCompoundMessage;          \
    ULONG                          CompoundMessageSizeInBytes; \
    ULONG    AC_POINTER            pCompoundMessageSizeInBytes;\
                                                               \
    ULONG                          EodStreamIdSizeInBytes;     \
    ULONG    AC_POINTER            pEodStreamIdSizeInBytes;    \
    UCHAR    AC_POINTER AC_POINTER ppEodStreamId;              \
    ULONG                          EodOrderQueueSizeInBytes;   \
    ULONG    AC_POINTER            pEodOrderQueueSizeInBytes;  \
    UCHAR    AC_POINTER AC_POINTER ppEodOrderQueue;            \
                                                               \
    LONGLONG AC_POINTER            pEodAckSeqId;               \
    LONGLONG AC_POINTER            pEodAckSeqNum;              \
    ULONG                          EodAckStreamIdSizeInBytes;  \
    ULONG    AC_POINTER            pEodAckStreamIdSizeInBytes; \
    UCHAR    AC_POINTER AC_POINTER ppEodAckStreamId;


//------------------------------------------------------------------
//
// SEND_PARAMETERS macro.
//
//------------------------------------------------------------------
#define SEND_PARAMETERS(AC_POINTER, AC_QUEUE_FORMAT)           \
    AC_QUEUE_FORMAT AC_POINTER     AdminMqf;                   \
    ULONG                          nAdminMqf;                  \
    AC_QUEUE_FORMAT AC_POINTER     ResponseMqf;                \
    ULONG                          nResponseMqf;               \
    UCHAR    AC_POINTER AC_POINTER ppSignatureMqf;             \
    ULONG                          SignatureMqfSize;		   \
    UCHAR    AC_POINTER AC_POINTER ppXmldsig;                  \
    ULONG                          ulXmldsigSize;              \
    WCHAR    AC_POINTER AC_POINTER ppSoapHeader;               \
    WCHAR    AC_POINTER AC_POINTER ppSoapBody;                 \
                                                               

//------------------------------------------------------------------
//
// RECEIVE_PARAMETERS macro.
//
//------------------------------------------------------------------
#define RECEIVE_PARAMETERS(AC_POINTER)                           \
    HACCursor32                    Cursor;                       \
    ULONG                          RequestTimeout;               \
    ULONG                          Action;                       \
    ULONG                          Asynchronous;                 \
    ULONGLONG                      LookupId;                     \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppDestFormatName;             \
    ULONG AC_POINTER               pulDestFormatNameLenProp;     \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppAdminFormatName;            \
    ULONG AC_POINTER               pulAdminFormatNameLenProp;    \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppResponseFormatName;         \
    ULONG AC_POINTER               pulResponseFormatNameLenProp; \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppOrderingFormatName;         \
    ULONG AC_POINTER               pulOrderingFormatNameLenProp; \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppDestMqf;                    \
    ULONG AC_POINTER               pulDestMqfLenProp;            \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppAdminMqf;                   \
    ULONG AC_POINTER               pulAdminMqfLenProp;           \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppResponseMqf;                \
    ULONG AC_POINTER               pulResponseMqfLenProp;        \
                                                                 \
    UCHAR AC_POINTER AC_POINTER    ppSignatureMqf;               \
    ULONG                          SignatureMqfSize;             \
    ULONG AC_POINTER               pSignatureMqfSize;


//------------------------------------------------------------------
//
// CACMessageProperties, CACSendParameters, CACReceiveParameters
//
// Note: changes here should also be reflected in:
//       * 64 bit Helper structures (ac\acctl32.*)
//       * Dependent client handling (qm\depclient.cpp)
//       * Corresponding XXX_32 structs (in this module)
//
//------------------------------------------------------------------

#ifndef _WIN64
#pragma pack(push, 4)
#endif

class CACMessageProperties {
    //
    // Private constructor prevents creating this object explicitly. Friend declaration allows aggregation.
    // 
    friend class CACSendParameters;
    friend class CACReceiveParameters;
private:
    CACMessageProperties() {}

public:
    MESSAGE_PROPERTIES(*);
};


class CACSendParameters {
public:
    CACSendParameters() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties MsgProps;
    SEND_PARAMETERS(*, QUEUE_FORMAT);
};


class CACReceiveParameters {
public:
    CACReceiveParameters() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties MsgProps;
    RECEIVE_PARAMETERS(*);
};

#ifndef _WIN64
#pragma pack(pop)
#endif

//------------------------------------------------------------------
//
// CACMessageProperties_32, CACSendParameters_32, CACReceiveParameters_32
//
//------------------------------------------------------------------

#ifdef _WIN64

#pragma pack(push, 4)

class CACMessageProperties_32 {
    //
    // Private constructor prevents creating this object explicitly. Friend declaration allows aggregation.
    // 
    friend class CACSendParameters_32;
    friend class CACReceiveParameters_32;
private:
    CACMessageProperties_32() {}

public:
    MESSAGE_PROPERTIES(*POINTER_32);
};


class CACSendParameters_32 {
public:
    CACSendParameters_32() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties_32 MsgProps;
    SEND_PARAMETERS(*POINTER_32, QUEUE_FORMAT_32);
};


class CACReceiveParameters_32 {
public:
    CACReceiveParameters_32() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties_32 MsgProps;
    RECEIVE_PARAMETERS(*POINTER_32);
};

#pragma pack(pop)

#endif // _WIN64


//
// The following compile time asserts verify that the 32 bit structs on x86 system
// and their representations on ia64 system (XXX_32) are the same.
//
const size_t xSizeOfMessageProperties32 = 292;
const size_t xSizeOfSendParameters32 = 332;
const size_t xSizeOfReceiveParameters32 = 384;
#ifdef _WIN64
C_ASSERT(sizeof(CACMessageProperties_32) == xSizeOfMessageProperties32);
C_ASSERT(sizeof(CACSendParameters_32) == xSizeOfSendParameters32);
C_ASSERT(sizeof(CACReceiveParameters_32) == xSizeOfReceiveParameters32);
#else
C_ASSERT(sizeof(CACMessageProperties) == xSizeOfMessageProperties32);
C_ASSERT(sizeof(CACSendParameters) == xSizeOfSendParameters32);
C_ASSERT(sizeof(CACReceiveParameters) == xSizeOfReceiveParameters32);
#endif

//+----------------------------------------------------------------------
//
// Helper code to compute size (in bytes) of provider name in packet.
//
//+----------------------------------------------------------------------
inline ULONG AuthProvNameSize(const CACMessageProperties * pMsgProps)
{
    return static_cast<ULONG>(sizeof(ULONG) + 
		    ((wcslen(*(pMsgProps->ppwcsProvName)) + 1) * sizeof(WCHAR)));
}

//+----------------------------------------------------------------------
//
// Helper code to compute size (in bytes) of provider name in packet 
// for MSMQ protocol.
//
//+----------------------------------------------------------------------
inline ULONG ComputeAuthProvNameSize(const CACMessageProperties * pMsgProps)
{
    ULONG ulSize = 0 ;

    if ( (pMsgProps->ulSignatureSize != 0) && (!(pMsgProps->fDefaultProvider)) )
    {
        ulSize = AuthProvNameSize(pMsgProps);
    }

    return ulSize ;
}

#endif // _ACDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\acioctl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acioctl.h

Abstract:

    Type definitions and data for Falcon AC driver

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/

#ifndef __ACIOCTL_H
#define __ACIOCTL_H

extern "C"
{
#include <devioctl.h>
}

//-- constants --------------------------------------------
//
//  Falcon Access Control unique identifier
//
//
#define FILE_DEVICE_MQAC 0x1965    //BUGBUG: find a number

//
//  Falcon IO control codes
//


//---------------------------------------------------------
//
//  RT INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  Message apis
//
#define IOCTL_AC_SEND_MESSAGE_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_WRITE_ACCESS)

#define IOCTL_AC_RECEIVE_MESSAGE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_BUFFERED, \
                                                             FILE_READ_ACCESS)

#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_BUFFERED, \
                                                             FILE_READ_ACCESS)

//
//  Queue apis
//
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_ANY_ACCESS)

#define IOCTL_AC_PURGE_QUEUE_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_READ_ACCESS)

//
//  QueueHandle apis
//
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                              ctl_num, \
                                                              METHOD_NEITHER, \
                                                              FILE_ANY_ACCESS)

//
//  Cursor apis
//
#define IOCTL_AC_CREATE_CURSOR_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_BUFFERED, \
                                                             FILE_READ_ACCESS)

#define IOCTL_AC_CLOSE_CURSOR_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_ANY_ACCESS)

//
//  RT ioctls
//  32 bit - range is 0x11-0x25
//  64 bit - range is 0x41-0x55 (offset of 0x30), and we need also the 32 bit ioctls
//           for compatibility with 32 bit MSMQ apps
//
#ifdef _WIN64
//
// WIN64
//
// 32 bit ioctls with _32 suffix
//
#define IOCTL_AC_SEND_MESSAGE_32           IOCTL_AC_SEND_MESSAGE_DEF(0x011)
#define IOCTL_AC_RECEIVE_MESSAGE_32        IOCTL_AC_RECEIVE_MESSAGE_DEF(0x012)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME_32  IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x013)
#define IOCTL_AC_PURGE_QUEUE_32            IOCTL_AC_PURGE_QUEUE_DEF(0x014)
#define IOCTL_AC_CREATE_CURSOR_32          IOCTL_AC_CREATE_CURSOR_DEF(0x021)
#define IOCTL_AC_CLOSE_CURSOR_32           IOCTL_AC_CLOSE_CURSOR_DEF(0x022)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32   IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x024)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS_32 IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x25)
//
// 64 bit ioctls (no suffix), offset of 0x30 from 32 bit ioctls
//
#define IOCTL_AC_SEND_MESSAGE                 IOCTL_AC_SEND_MESSAGE_DEF(0x041)
#define IOCTL_AC_RECEIVE_MESSAGE              IOCTL_AC_RECEIVE_MESSAGE_DEF(0x042)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME        IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x043)
#define IOCTL_AC_PURGE_QUEUE                  IOCTL_AC_PURGE_QUEUE_DEF(0x044)
#define IOCTL_AC_CREATE_CURSOR                IOCTL_AC_CREATE_CURSOR_DEF(0x051)
#define IOCTL_AC_CLOSE_CURSOR                 IOCTL_AC_CLOSE_CURSOR_DEF(0x052)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x054)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS       IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x55)
#else //!_WIN64
//
// WIN32
//
// 32 bit ioctls (no suffix)
//
#define IOCTL_AC_SEND_MESSAGE              IOCTL_AC_SEND_MESSAGE_DEF(0x011)
#define IOCTL_AC_RECEIVE_MESSAGE           IOCTL_AC_RECEIVE_MESSAGE_DEF(0x012)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME     IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x013)
#define IOCTL_AC_PURGE_QUEUE               IOCTL_AC_PURGE_QUEUE_DEF(0x014)
#define IOCTL_AC_CREATE_CURSOR             IOCTL_AC_CREATE_CURSOR_DEF(0x021)
#define IOCTL_AC_CLOSE_CURSOR              IOCTL_AC_CLOSE_CURSOR_DEF(0x022)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID  IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x024)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS    IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x25)
#endif //_WIN64

//---------------------------------------------------------
//
//  QM INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  QM Control apis
//

//---------------------------------------------------------
//
//  NOTE: CONNECT must be first QM ioctl
//
#define IOCTL_AC_CONNECT_DEF(ctl_num)                    CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)
//
//---------------------------------------------------------

#define IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_MACHINE_PROPS_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_GET_SERVICE_REQUEST_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_STORE_COMPLETED_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(ctl_num)    CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ACKING_COMPLETED_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CAN_CLOSE_QUEUE_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_QUEUE_PROPS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_QUEUE_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_JOURNAL_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_DEADXACT_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_RESTORED_PACKET_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_RESTORED_PACKET_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_RESTORE_PACKETS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_MAPPED_LIMIT_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_QUEUE_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_GROUP_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_RELEASE_RESOURCES_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_GET_QUEUE_PROPS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CONVERT_PACKET_DEF(ctl_num)				CTL_CODE(FILE_DEVICE_MQAC, \
										                  		ctl_num, \
					                  							METHOD_NEITHER, \
                  												FILE_ANY_ACCESS)

#define IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_SEQUENCE_ACK_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_DISTRIBUTION_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)


#define IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTAL_AC_GET_USED_QUOTA_DEF(ct1_num)				 CTL_CODE(FILE_DEVICE_MQAC,\
																  ct1_num, \
																  METHOD_NEITHER, \
																  FILE_ANY_ACCESS)
																	
																	

//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_PACKET_DEF(ctl_num)                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_PACKET_DEF(ctl_num)                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_REMOTE_CURSOR_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(ctl_num)   CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(ctl_num)     CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CANCEL_REQUEST_DEF(ctl_num)             CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_REMOTE_PACKET_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)


//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT1_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT2_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT1_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(ctl_num)   CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)


#define IOCTL_AC_PUT_PACKET1_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_XACT_SET_CLASS_DEF(ctl_num)             CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_GET_INFORMATION_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET2_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET1_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ARM_PACKET_TIMER_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT3_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT2_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM ioctls to AC
//  32 bit - range is 0x101-0x250
//  64 bit - range is 0x401-0x550 (offset of 0x300). We don't need the 32 bit ioctls
//           since both QM, CPL and AC are 64 bit
//
#ifdef _WIN64
//
//  64 bit ioctls
//  NOTE: CONNECT must be first QM ioctl
//
//  QM Control apis
//
#define IOCTL_AC_CONNECT                    IOCTL_AC_CONNECT_DEF(0x401)
#define IOCTL_AC_SET_PERFORMANCE_BUFF       IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(0x402)
#define IOCTL_AC_SET_MACHINE_PROPS          IOCTL_AC_SET_MACHINE_PROPS_DEF(0x403)
#define IOCTL_AC_GET_SERVICE_REQUEST        IOCTL_AC_GET_SERVICE_REQUEST_DEF(0x404)
#define IOCTL_AC_CREATE_PACKET_COMPLETED    IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(0x405)
#define IOCTL_AC_STORE_COMPLETED            IOCTL_AC_STORE_COMPLETED_DEF(0x406)
#define IOCTL_AC_ACKING_COMPLETED           IOCTL_AC_ACKING_COMPLETED_DEF(0x407)
#define IOCTL_AC_CAN_CLOSE_QUEUE            IOCTL_AC_CAN_CLOSE_QUEUE_DEF(0x411)
#define IOCTL_AC_SET_QUEUE_PROPS            IOCTL_AC_SET_QUEUE_PROPS_DEF(0x412)
#define IOCTL_AC_ASSOCIATE_QUEUE            IOCTL_AC_ASSOCIATE_QUEUE_DEF(0x413)
#define IOCTL_AC_ASSOCIATE_JOURNAL          IOCTL_AC_ASSOCIATE_JOURNAL_DEF(0x414)
#define IOCTL_AC_ASSOCIATE_DEADXACT         IOCTL_AC_ASSOCIATE_DEADXACT_DEF(0x415)
#define IOCTL_AC_PUT_RESTORED_PACKET        IOCTL_AC_PUT_RESTORED_PACKET_DEF(0x416)
#define IOCTL_AC_GET_RESTORED_PACKET        IOCTL_AC_GET_RESTORED_PACKET_DEF(0x417)
#define IOCTL_AC_RESTORE_PACKETS            IOCTL_AC_RESTORE_PACKETS_DEF(0x418)
#define IOCTL_AC_SET_MAPPED_LIMIT           IOCTL_AC_SET_MAPPED_LIMIT_DEF(0x419)
#define IOCTL_AC_CREATE_QUEUE               IOCTL_AC_CREATE_QUEUE_DEF(0x420)
#define IOCTL_AC_CREATE_GROUP               IOCTL_AC_CREATE_GROUP_DEF(0x421)
#define IOCTL_AC_RELEASE_RESOURCES          IOCTL_AC_RELEASE_RESOURCES_DEF(0x423)
#define IOCTL_AC_GET_QUEUE_PROPS            IOCTL_AC_GET_QUEUE_PROPS_DEF(0x424)
#define IOCTL_AC_CONVERT_PACKET             IOCTL_AC_CONVERT_PACKET_DEF(0x425)
#define IOCTL_AC_IS_SEQUENCE_ON_HOLD        IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(0x426)
#define IOCTL_AC_SET_SEQUENCE_ACK           IOCTL_AC_SET_SEQUENCE_ACK_DEF(0x427)
#define IOCTL_AC_GET_PACKET_BY_COOKIE       IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(0x428)
#define IOCTL_AC_CREATE_DISTRIBUTION        IOCTL_AC_CREATE_DISTRIBUTION_DEF(0x429)
#define IOCTL_AC_INTERNAL_PURGE_QUEUE       IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(0x431)
#define IOCTAL_AC_GET_USED_QUOTA			IOCTAL_AC_GET_USED_QUOTA_DEF(0x432)
//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET            IOCTL_AC_ALLOCATE_PACKET_DEF(0x501)
#define IOCTL_AC_FREE_PACKET                IOCTL_AC_FREE_PACKET_DEF(0x502)
#define IOCTL_AC_PUT_PACKET                 IOCTL_AC_PUT_PACKET_DEF(0x503)
#define IOCTL_AC_GET_PACKET                 IOCTL_AC_GET_PACKET_DEF(0x504)
#define IOCTL_AC_MOVE_QUEUE_TO_GROUP        IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(0x513)
//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY        IOCTL_AC_CREATE_REMOTE_PROXY_DEF(0x521)
#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE   IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(0x522)
#define IOCTL_AC_END_GET_PACKET_2REMOTE     IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(0x523)
#define IOCTL_AC_CANCEL_REQUEST             IOCTL_AC_CANCEL_REQUEST_DEF(0x524)
#define IOCTL_AC_PUT_REMOTE_PACKET          IOCTL_AC_PUT_REMOTE_PACKET_DEF(0x525)
#define IOCTL_AC_CREATE_REMOTE_CURSOR       IOCTL_AC_CREATE_REMOTE_CURSOR_DEF(0x526)
//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION         IOCTL_AC_CREATE_TRANSACTION_DEF(0x531)
#define IOCTL_AC_XACT_COMMIT1               IOCTL_AC_XACT_COMMIT1_DEF(0x532)
#define IOCTL_AC_XACT_COMMIT2               IOCTL_AC_XACT_COMMIT2_DEF(0x533)
#define IOCTL_AC_XACT_ABORT1                IOCTL_AC_XACT_ABORT1_DEF(0x534)
#define IOCTL_AC_XACT_PREPARE               IOCTL_AC_XACT_PREPARE_DEF(0x535)
#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT    IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(0x536)
#define IOCTL_AC_PUT_PACKET1                IOCTL_AC_PUT_PACKET1_DEF(0x537)
#define IOCTL_AC_XACT_SET_CLASS             IOCTL_AC_XACT_SET_CLASS_DEF(0x538)
#define IOCTL_AC_XACT_GET_INFORMATION       IOCTL_AC_XACT_GET_INFORMATION_DEF(0x539)
#define IOCTL_AC_FREE_PACKET1               IOCTL_AC_FREE_PACKET1_DEF(0x53a)
#define IOCTL_AC_ARM_PACKET_TIMER           IOCTL_AC_ARM_PACKET_TIMER_DEF(0x53b)
#define IOCTL_AC_XACT_COMMIT3               IOCTL_AC_XACT_COMMIT3_DEF(0x53c)
#define IOCTL_AC_XACT_ABORT2                IOCTL_AC_XACT_ABORT2_DEF(0x53d)
#define IOCTL_AC_FREE_PACKET2               IOCTL_AC_FREE_PACKET2_DEF(0x53e)

#else //!_WIN64
//
//  32 bit ioctls
//  NOTE: CONNECT must be first QM ioctl
//
//  QM Control apis
//
#define IOCTL_AC_CONNECT                 IOCTL_AC_CONNECT_DEF(0x101)
#define IOCTL_AC_SET_PERFORMANCE_BUFF    IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(0x102)
#define IOCTL_AC_SET_MACHINE_PROPS       IOCTL_AC_SET_MACHINE_PROPS_DEF(0x103)
#define IOCTL_AC_GET_SERVICE_REQUEST     IOCTL_AC_GET_SERVICE_REQUEST_DEF(0x104)
#define IOCTL_AC_CREATE_PACKET_COMPLETED IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(0x105)
#define IOCTL_AC_STORE_COMPLETED         IOCTL_AC_STORE_COMPLETED_DEF(0x106)
#define IOCTL_AC_ACKING_COMPLETED        IOCTL_AC_ACKING_COMPLETED_DEF(0x107)
#define IOCTL_AC_CAN_CLOSE_QUEUE         IOCTL_AC_CAN_CLOSE_QUEUE_DEF(0x111)
#define IOCTL_AC_SET_QUEUE_PROPS         IOCTL_AC_SET_QUEUE_PROPS_DEF(0x112)
#define IOCTL_AC_ASSOCIATE_QUEUE         IOCTL_AC_ASSOCIATE_QUEUE_DEF(0x113)
#define IOCTL_AC_ASSOCIATE_JOURNAL       IOCTL_AC_ASSOCIATE_JOURNAL_DEF(0x114)
#define IOCTL_AC_ASSOCIATE_DEADXACT      IOCTL_AC_ASSOCIATE_DEADXACT_DEF(0x115)
#define IOCTL_AC_PUT_RESTORED_PACKET     IOCTL_AC_PUT_RESTORED_PACKET_DEF(0x116)
#define IOCTL_AC_GET_RESTORED_PACKET     IOCTL_AC_GET_RESTORED_PACKET_DEF(0x117)
#define IOCTL_AC_RESTORE_PACKETS         IOCTL_AC_RESTORE_PACKETS_DEF(0x118)
#define IOCTL_AC_SET_MAPPED_LIMIT        IOCTL_AC_SET_MAPPED_LIMIT_DEF(0x119)
#define IOCTL_AC_CREATE_QUEUE            IOCTL_AC_CREATE_QUEUE_DEF(0x120)
#define IOCTL_AC_CREATE_GROUP            IOCTL_AC_CREATE_GROUP_DEF(0x121)
#define IOCTL_AC_RELEASE_RESOURCES       IOCTL_AC_RELEASE_RESOURCES_DEF(0x123)
#define IOCTL_AC_GET_QUEUE_PROPS         IOCTL_AC_GET_QUEUE_PROPS_DEF(0x124)
#define IOCTL_AC_CONVERT_PACKET          IOCTL_AC_CONVERT_PACKET_DEF(0x125)
#define IOCTL_AC_IS_SEQUENCE_ON_HOLD     IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(0x126)
#define IOCTL_AC_SET_SEQUENCE_ACK        IOCTL_AC_SET_SEQUENCE_ACK_DEF(0x127)
#define IOCTL_AC_GET_PACKET_BY_COOKIE    IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(0x128)
#define IOCTL_AC_CREATE_DISTRIBUTION     IOCTL_AC_CREATE_DISTRIBUTION_DEF(0x129)
#define IOCTL_AC_INTERNAL_PURGE_QUEUE    IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(131)
#define IOCTAL_AC_GET_USED_QUOTA		IOCTAL_AC_GET_USED_QUOTA_DEF(0x132)

//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET         IOCTL_AC_ALLOCATE_PACKET_DEF(0x201)
#define IOCTL_AC_FREE_PACKET             IOCTL_AC_FREE_PACKET_DEF(0x202)
#define IOCTL_AC_PUT_PACKET              IOCTL_AC_PUT_PACKET_DEF(0x203)
#define IOCTL_AC_GET_PACKET              IOCTL_AC_GET_PACKET_DEF(0x204)
#define IOCTL_AC_MOVE_QUEUE_TO_GROUP     IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(0x213)
//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY     IOCTL_AC_CREATE_REMOTE_PROXY_DEF(0x221)
#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(0x222)
#define IOCTL_AC_END_GET_PACKET_2REMOTE  IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(0x223)
#define IOCTL_AC_CANCEL_REQUEST          IOCTL_AC_CANCEL_REQUEST_DEF(0x224)
#define IOCTL_AC_PUT_REMOTE_PACKET       IOCTL_AC_PUT_REMOTE_PACKET_DEF(0x225)
#define IOCTL_AC_CREATE_REMOTE_CURSOR    IOCTL_AC_CREATE_REMOTE_CURSOR_DEF(0x226)
//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION      IOCTL_AC_CREATE_TRANSACTION_DEF(0x231)
#define IOCTL_AC_XACT_COMMIT1            IOCTL_AC_XACT_COMMIT1_DEF(0x232)
#define IOCTL_AC_XACT_COMMIT2            IOCTL_AC_XACT_COMMIT2_DEF(0x233)
#define IOCTL_AC_XACT_ABORT1             IOCTL_AC_XACT_ABORT1_DEF(0x234)
#define IOCTL_AC_XACT_PREPARE            IOCTL_AC_XACT_PREPARE_DEF(0x235)
#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(0x236)
#define IOCTL_AC_PUT_PACKET1             IOCTL_AC_PUT_PACKET1_DEF(0x237)
#define IOCTL_AC_XACT_SET_CLASS          IOCTL_AC_XACT_SET_CLASS_DEF(0x238)
#define IOCTL_AC_XACT_GET_INFORMATION    IOCTL_AC_XACT_GET_INFORMATION_DEF(0x239)
#define IOCTL_AC_FREE_PACKET1            IOCTL_AC_FREE_PACKET1_DEF(0x23a)
#define IOCTL_AC_ARM_PACKET_TIMER        IOCTL_AC_ARM_PACKET_TIMER_DEF(0x23b)
#define IOCTL_AC_XACT_COMMIT3            IOCTL_AC_XACT_COMMIT3_DEF(0x23c)
#define IOCTL_AC_XACT_ABORT2             IOCTL_AC_XACT_ABORT2_DEF(0x23d)
#define IOCTL_AC_FREE_PACKET2            IOCTL_AC_FREE_PACKET2_DEF(0x23e)

#endif //_WIN64


#endif // __ACIOCTL_H 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\admcomnd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admcomnd.h


Abstract:

    Definitions of explorer commands passed to the QM
  
Author:

	David Reznick (t-davrez)


--*/
#ifndef __ADMCOMND_H
#define __ADMCOMND_H

#define ADMIN_COMMANDS_TITLE       (L"QM-Admin Commands")
#define ADMIN_RESPONSE_TITLE       (L"QM Response Message")
#define ADMIN_REPORTMSG_TITLE      (L"Report Message")
#define ADMIN_REPORTCONFLICT_TITLE (L"Report Message Conflict")    
#define ADMIN_PING_RESPONSE_TITLE  (L"Ping Response")    
#define ADMIN_DEPCLI_RESPONSE_TITLE  (L"Dependent Clients Response")    

#define ADMIN_SET_REPORTQUEUE    (L"Set Report Queue")
#define ADMIN_GET_REPORTQUEUE    (L"Get Report Queue")
#define ADMIN_SET_PROPAGATEFLAG  (L"Set Propagate Flag")
#define ADMIN_GET_PROPAGATEFLAG  (L"Get Propagate Flag")
#define ADMIN_SEND_TESTMSG       (L"Send Test Message")
#define ADMIN_GET_PRIVATE_QUEUES (L"Get Private Queues")
#define ADMIN_PING               (L"Ping")
#define ADMIN_GET_DEPENDENTCLIENTS (L"Get Dependent Clients")


#define PROPAGATE_STRING_FALSE (L"FALSE")
#define PROPAGATE_FLAG_FALSE ((unsigned char)0)

#define PROPAGATE_STRING_TRUE  (L"TRUE")
#define PROPAGATE_FLAG_TRUE  ((unsigned char)1)

#define ADMIN_STAT_OK            ((unsigned char)0)
#define ADMIN_STAT_ERROR         ((unsigned char)1)
#define ADMIN_STAT_NOVALUE       ((unsigned char)2)

#define ADMIN_COMMANDS_TIMEOUT 0xffffffff
#define REPORT_MSGS_TIMEOUT    600                  // report message time to reach queue is 10 minutes

#define STRING_UUID_SIZE 38  // Wide-Characters (includiing - "{}")

#define MAX_ADMIN_RESPONSE_SIZE 1024

//
// QM response structure (The first byte of the response message holds the
//                        status)                           
//
struct QMResponse
{
    DWORD  dwResponseSize;

    UCHAR  uStatus;   
    UCHAR  uResponseBody[MAX_ADMIN_RESPONSE_SIZE];
};
//
// response structure For Get private Queue request                           
//
#ifdef _WIN64
#define QMGetPrivateQResponse_POS32 DWORD //should be 32 bit value also on win64
#else //!_WIN64
#define QMGetPrivateQResponse_POS32 LPVOID
#endif //_WIN64

#define MAX_GET_PRIVATE_RESPONSE_SIZE 4096
struct QMGetPrivateQResponse
{
    HRESULT hr;
    DWORD   dwNoOfQueues;
    DWORD   dwResponseSize;
    QMGetPrivateQResponse_POS32 pos;
    UCHAR   uResponseBody[MAX_GET_PRIVATE_RESPONSE_SIZE];
};


// 
// Client names structure - for passing the list of dependent clients
//
typedef struct _ClientNames {
    ULONG   cbClients;          // Number of client names
    ULONG   cbBufLen;           // Buffer length
    WCHAR   rwName[1];          // buffer with zero-trailed names
} ClientNames;

#endif __ADMCOMND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autoclean.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autoclean.h

Abstract:

    auto clean classes.

Author:

    Ilan herbst (ilanh)  6-Sep-2001

Revision History:

--*/

#ifndef _MSMQ_AUTOCLEAN_H_
#define _MSMQ_AUTOCLEAN_H_

#include "winsock.h"

//----------------------------------------
//
//  Auto cleanup for previous WSAStartup()
//
//----------------------------------------
class CAutoWSACleanup
{
public:
    CAutoWSACleanup() {}

    ~CAutoWSACleanup()
    {
        WSACleanup();
    }
};

#endif //_MSMQ_AUTOCLEAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\ad.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ad.h

Abstract:

    Message Queuing's Active Dirctory Header File

--*/

#ifndef __AD_H__
#define __AD_H__


#include "mqaddef.h"
#include "dsproto.h"



//********************************************************************
//                           A P I
//********************************************************************

//
//  Creating objects
//
HRESULT
ADCreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );
//
//  Deleting objects
//
HRESULT
ADDeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

HRESULT
ADDeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );

HRESULT
ADDeleteObjectGuidSid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const SID*              pSid
                );
//
//  Retreive object properties
//
HRESULT
ADGetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

HRESULT
ADGetGenObjectProperties(
                IN  eDSNamespace            eNamespace,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  LPCWSTR                 aPropNames[],
                IN OUT VARIANT              apVar[]
                );

HRESULT
ADGetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                );


HRESULT
ADQMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE pfChallengeResponceProc
                );


HRESULT
ADGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

HRESULT
ADGetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );


//
// Setting object properties
//
HRESULT
ADSetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

HRESULT
ADSetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );




HRESULT
ADQMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                );

HRESULT
ADSetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );


HRESULT
ADSetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

//
//  Initailzation
//
HRESULT
ADInit(
                IN QMLookForOnlineDS_ROUTINE pLookDS,
                IN MQGetMQISServer_ROUTINE pGetServers ,
                IN bool  fSetupMode,
                IN bool  fQMDll,
		        IN bool  fIgnoreWorkGroup,
                IN bool  fDisableDownlevelNotifications
                );



//
//  This routine is kept only for MSMQ 1.0 purposes.
//
HRESULT
ADCreateServersCache();




HRESULT
ADGetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                );


HRESULT
ADBeginDeleteNotification(
                IN AD_OBJECT                eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                );
HRESULT
ADNotifyDelete(
                IN  HANDLE                  hEnum
                );

HRESULT
ADEndDeleteNotification(
                IN  HANDLE                  hEnum
                );




//
// Locating objects
//


HRESULT
ADQueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );



HRESULT
ADQuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );


HRESULT
ADQueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

HRESULT
ADEndQuery(
                IN  HANDLE                  hEnum
                );

eDsEnvironment
ADGetEnterprise( void);

eDsProvider
ADProviderType( void);

DWORD
ADRawDetection(void);

HRESULT
ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );


//-------------------------------------------------------
//
// auto release for ADQuery handles
//
class CADQueryHandle
{
public:
    CADQueryHandle()
    {
        m_h = NULL;
    }

    CADQueryHandle(HANDLE h)
    {
        m_h = h;
    }

    ~CADQueryHandle()
    {
        if (m_h)
        {
            ADEndQuery(m_h);
        }
    }

    HANDLE detach()
    {
        HANDLE hTmp = m_h;
        m_h = NULL;
        return hTmp;
    }

    operator HANDLE() const
    {
        return m_h;
    }

    HANDLE* operator &()
    {
        return &m_h;
    }

    CADQueryHandle& operator=(HANDLE h)
    {
        if (m_h)
        {
            ADEndQuery(m_h);
        }
        m_h = h;
        return *this;
    }

private:
    HANDLE m_h;
};




#endif // __AD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\adsiutil.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
	adsiutil.h

Abstract:
	General declarations and utilities for using ADSI.

Author:
    Doron Juster (DoronJ)   23-June-1999

--*/

#ifndef __ADSIUTIL_H__
#define __ADSIUTIL_H__

#include <iads.h>
#include <adshlp.h>

//+--------------------------------------------------
//
// helper class - Auto release for CoInitialize
//
//+--------------------------------------------------

class CCoInit
{
public:
    CCoInit()
    {
        m_fInited = FALSE;
    }

    ~CCoInit()
    {
        if (m_fInited)
            CoUninitialize();
    }

    HRESULT CoInitialize()
    {
        HRESULT hr;

        hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED );
        m_fInited = SUCCEEDED(hr);
        return(hr);
    }

private:
    BOOL m_fInited;
};


#endif //  __ADSIUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autorel.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    autorel.h

Abstract:

    Some classes for automatically releasing resources.

Author:

    Boaz Feldbaum (BoazF) 26-Jun-1997

Revision History:

--*/

#ifndef __AUTOREL_H
#define __AUTOREL_H

class CAutoCloseFileHandle
{
public:
    CAutoCloseFileHandle(HANDLE h =INVALID_HANDLE_VALUE) { m_h = h; };
    ~CAutoCloseFileHandle() { if (m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); };

public:
    CAutoCloseFileHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseHandle
{
public:
    CAutoCloseHandle(HANDLE h =NULL) { m_h = h; };
    ~CAutoCloseHandle() { if (m_h) CloseHandle(m_h); };

public:
    CAutoCloseHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseRegHandle
{
public:
    CAutoCloseRegHandle(HKEY h =NULL) { m_h = h; };
    ~CAutoCloseRegHandle() { if (m_h) RegCloseKey(m_h); };

public:
    CAutoCloseRegHandle & operator =(HKEY h) { m_h = h; return(*this); };
    HKEY * operator &() { return &m_h; };
    operator HKEY() { return m_h; };

private:
    HKEY m_h;
};

class CAutoFreeLibrary
{
public:
    CAutoFreeLibrary(HINSTANCE hLib =NULL) { m_hLib = hLib; };
    ~CAutoFreeLibrary() { if (m_hLib) FreeLibrary(m_hLib); };

public:
    CAutoFreeLibrary & operator =(HINSTANCE hLib) { m_hLib = hLib; return(*this); };
    HINSTANCE * operator &() { return &m_hLib; };
    operator HINSTANCE() { return m_hLib; };
    HINSTANCE detach() { HINSTANCE hLib = m_hLib; m_hLib = NULL; return hLib; };

private:
    HINSTANCE m_hLib;
};

#endif // __AUTOREL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autoauthz.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autoauthz.h

Abstract:
    Auto handle classes, free the handle resoruce when destructed.

Author:
    Ilan Herbst (ilanh) 18-Mar-2001

--*/

#pragma once

#ifndef _MSMQ_AUTOAUTHZ_H_
#define _MSMQ_AUTOAUTHZ_H_

#include "authz.h"

//---------------------------------------------------------
//
//  class CAUTHZ_RESOURCE_MANAGER_HANDLE
//
//---------------------------------------------------------
class CAUTHZ_RESOURCE_MANAGER_HANDLE {
public:
    CAUTHZ_RESOURCE_MANAGER_HANDLE(AUTHZ_RESOURCE_MANAGER_HANDLE h = 0) : m_h(h)  {}
   ~CAUTHZ_RESOURCE_MANAGER_HANDLE()                       { if (m_h != 0) AuthzFreeResourceManager(m_h); }

    AUTHZ_RESOURCE_MANAGER_HANDLE* operator &()            { return &m_h; }
    operator AUTHZ_RESOURCE_MANAGER_HANDLE() const         { return m_h; }
    AUTHZ_RESOURCE_MANAGER_HANDLE detach()                 { AUTHZ_RESOURCE_MANAGER_HANDLE h = m_h; m_h = 0; return h; }

private:
    CAUTHZ_RESOURCE_MANAGER_HANDLE(const CAUTHZ_RESOURCE_MANAGER_HANDLE&);
    CAUTHZ_RESOURCE_MANAGER_HANDLE& operator=(const CAUTHZ_RESOURCE_MANAGER_HANDLE&);

private:
    AUTHZ_RESOURCE_MANAGER_HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CAUTHZ_CLIENT_CONTEXT_HANDLE
//
//---------------------------------------------------------
class CAUTHZ_CLIENT_CONTEXT_HANDLE {
public:
    CAUTHZ_CLIENT_CONTEXT_HANDLE(AUTHZ_CLIENT_CONTEXT_HANDLE h = 0) : m_h(h)  {}
   ~CAUTHZ_CLIENT_CONTEXT_HANDLE()                       { if (m_h != 0) AuthzFreeContext(m_h); }

    AUTHZ_CLIENT_CONTEXT_HANDLE* operator &()            { return &m_h; }
    operator AUTHZ_CLIENT_CONTEXT_HANDLE() const         { return m_h; }
    AUTHZ_CLIENT_CONTEXT_HANDLE detach()                 { AUTHZ_CLIENT_CONTEXT_HANDLE h = m_h; m_h = 0; return h; }

private:
    CAUTHZ_CLIENT_CONTEXT_HANDLE(const CAUTHZ_CLIENT_CONTEXT_HANDLE&);
    CAUTHZ_CLIENT_CONTEXT_HANDLE& operator=(const CAUTHZ_CLIENT_CONTEXT_HANDLE&);

private:
    AUTHZ_CLIENT_CONTEXT_HANDLE m_h;
};

#endif // _MSMQ_AUTOAUTHZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\crtwin.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crtwin.h

Abstract:

    Convert many system calls to crt calls, easy porting to Win95. Include it
    After you include windows headers.

Author:

    Erez Haba (erez) 20-Oct-96

--*/
#ifndef __CRTWIN_H
#define __CRTWIN_H

#undef lstrlen
#define lstrlen _tcslen

#undef lstrcmp
#define lstrcmp _tcscmp

#undef lstrcmpi
#define lstrcmpi _tcsicmp

#undef lstrcat
#define lstrcat _tcscat

#undef lstrcpy
#define lstrcpy _tcscpy

#undef wsprintf
#define wsprintf swprintf

#endif // __CRTWIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\cancel.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cancel.h

Abstract:
    Keep track of outgoing RPC calls and cancel delayed pending requests

Author:
    Ronit Hartmann (ronith)

--*/

#ifndef __CANCEL_H
#define __CANCEL_H

#include "autorel.h"
#include "cs.h"

class MQUTIL_EXPORT CCancelRpc
{
public:
    CCancelRpc();
    ~CCancelRpc();
	void Add(	IN	HANDLE	hThread,
				IN	time_t	timeCallIssued);
	void Remove(  IN HANDLE hThread);


	void CancelRequests( IN	time_t timeIssuedBefore);

    //
    // We cannot initialize everything in constructor because we use
    // global object and it'll fail to construct when setup loads this dll
    // (during setup we don't have yet the timeout in registry for example)
    //
    void Init(void);

	DWORD RpcCancelTimeout(void);
		
	void ShutDownCancelThread();

private:
    static DWORD WINAPI CancelThread(LPVOID);
    inline void ProcessEvents(void);

    CCriticalSection			m_cs;
	CMap< HANDLE, HANDLE, time_t, time_t> m_mapOutgoingRpcRequestThreads;

    CAutoCloseHandle m_hRpcPendingEvent;
    CAutoCloseHandle m_hTerminateThreadEvent;
    CAutoCloseHandle m_hCancelThread;

	CAutoCloseHandle m_hThreadIntializationComplete;
	HRESULT m_ThreadIntializationStatus;
	
	LONG m_RefCount;
    DWORD m_dwRpcCancelTimeout;

	HMODULE m_hModule;
}; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autorel3.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autorel3.h

Abstract:

    Cluster related auto release classes

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MSMQ_AUTOREL3_H_
#define _MSMQ_AUTOREL3_H_


//
// Cluster related classes
//

class CAutoCluster
{
public:
	explicit CAutoCluster(HCLUSTER h = NULL) { m_h = h; };
	~CAutoCluster() { if (m_h) CloseCluster(m_h); };

	operator HCLUSTER() const { return m_h; };
    CAutoCluster& operator=(HCLUSTER h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CAutoCluster(const CAutoCluster & );
    CAutoCluster& operator=(const CAutoCluster &);

private:
	HCLUSTER m_h;

}; //CAutoCluster


class CClusterEnum
{
public:
    explicit CClusterEnum(HCLUSENUM h = NULL) { m_h = h; };
    ~CClusterEnum() { if (m_h) ClusterCloseEnum(m_h); };

    operator HCLUSENUM() const { return m_h; };
    CClusterEnum& operator=(HCLUSENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CClusterEnum(const CClusterEnum & );
    CClusterEnum& operator=(const CClusterEnum &);

private:
    HCLUSENUM m_h;

}; //CClusterEnum


class CGroupEnum
{
public:
    explicit CGroupEnum(HGROUPENUM h = NULL) { m_h = h; };
    ~CGroupEnum() { if (m_h) ClusterGroupCloseEnum(m_h); };

    operator HGROUPENUM() const { return m_h; };
    CGroupEnum& operator=(HGROUPENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CGroupEnum(const CGroupEnum & );
    CGroupEnum& operator=(const CGroupEnum &);

private:
    HGROUPENUM m_h;

}; //CGroupEnum


class CResourceEnum
{
public:
    explicit CResourceEnum(HRESENUM h = NULL) { m_h = h; };
    ~CResourceEnum() { if (m_h) ClusterResourceCloseEnum(m_h); };

    operator HRESENUM() const { return m_h; };
    CResourceEnum& operator=(HRESENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CResourceEnum(const CResourceEnum & );
    CResourceEnum& operator=(const CResourceEnum &);

private:
    HRESENUM m_h;

}; //CResourceEnum


class CClusterResource
{
public:
    explicit CClusterResource(HRESOURCE h = NULL) { m_h = h; };
    ~CClusterResource() { if (m_h) CloseClusterResource(m_h); };

    operator HRESOURCE() const { return m_h; };
    HRESOURCE * operator &() { return &m_h; };
    CClusterResource& operator=(HRESOURCE h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HRESOURCE detach() { HRESOURCE h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterResource(const CClusterResource & );
    CClusterResource& operator=(const CClusterResource &);

private:
    HRESOURCE m_h;

}; //CClusterResource


class CClusterGroup
{
public:
    explicit CClusterGroup(HGROUP h = NULL) { m_h = h; };
    ~CClusterGroup() { if (m_h) CloseClusterGroup(m_h); };

    operator HGROUP() const { return m_h; };
    HGROUP * operator &() { return &m_h; };
    CClusterGroup& operator=(HGROUP h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HGROUP detach() { HGROUP h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterGroup(const CClusterGroup & );
    CClusterGroup& operator=(const CClusterGroup &);

private:
    HGROUP m_h;

}; //CClusterGroup


class CClusterNode
{
public:
    explicit CClusterNode(HNODE h = NULL) { m_h = h; };
    ~CClusterNode() { if (m_h) CloseClusterNode(m_h); };

    operator HNODE() const { return m_h; };
    HNODE * operator &() { return &m_h; };
    CClusterNode& operator=(HNODE h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HNODE detach() { HNODE h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterNode(const CClusterNode & );
    CClusterNode& operator=(const CClusterNode &);

private:
    HNODE m_h;

}; //CClusterNode


class CEnvironment
{
public:
    explicit CEnvironment(LPVOID p = NULL) { m_p = p; };
    ~CEnvironment() { if (m_p) ResUtilFreeEnvironment(m_p); };

    operator PWCHAR() { return static_cast<PWCHAR>(m_p); };
    operator PBYTE()  { return static_cast<PBYTE>(m_p); };
    //CEnvironment& operator=(LPVOID p)   { m_p = p; return *this; }

private:
    //
    // Prevent copy
    //
    CEnvironment(const CEnvironment & );
    CEnvironment& operator=(const CEnvironment &);

private:
    LPVOID m_p;

}; //CEnvironment


#endif //_MSMQ_AUTOREL3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autoreln.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autoreln.h

Abstract:

    auto release classes for netapi. And for LocalFree buffer, used
    extensively in security apis.

Author:

    Doron Juster (DoronJ)  25-May-1999

Revision History:

--*/

#ifndef _MSMQ_AUTORELN_H_
#define _MSMQ_AUTORELN_H_

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//----------------------------------------
//
//  Auto delete pointer for net api
//
//----------------------------------------
template<class T>
class PNETBUF {
private:
    T* m_p;

public:
    PNETBUF(T* p = 0) : m_p(p)    {}
   ~PNETBUF()                     { if (m_p != 0) NetApiBufferFree(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { if (m_p != 0) NetApiBufferFree(detach()); }

    T** operator&()
    {
        ASSERT(("Auto NETBUF pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    PNETBUF& operator=(T* p)
    {
        ASSERT(("Auto NETBUF pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    PNETBUF(const PNETBUF&);
	PNETBUF<T>& operator=(const PNETBUF<T>&);
};

//+----------------------------------
//
// class CAutoLocalFreePtr
//
//+----------------------------------

class CAutoLocalFreePtr
{
private:
    BYTE *m_p;

public:
    CAutoLocalFreePtr(BYTE *p = 0) : m_p(p) {};
    ~CAutoLocalFreePtr() { if (m_p != 0) LocalFree(m_p); };

    operator BYTE*() const     { return m_p; }
    BYTE* operator->() const   { return m_p; }
    BYTE* get() const          { return m_p; }
    BYTE* detach()             { BYTE* p = m_p; m_p = 0; return p; }
    void free()				   { if (m_p != 0) LocalFree(detach()); }

    BYTE** operator&()
    {
        ASSERT(("Auto LocalFree pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


	CAutoLocalFreePtr& operator =(BYTE *p)
    {
        ASSERT(("Auto LocalFree pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CAutoLocalFreePtr(const CAutoLocalFreePtr&);
	CAutoLocalFreePtr& operator=(const CAutoLocalFreePtr&);

};

#endif //_MSMQ_AUTORELN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\autorel2.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autorel2.h

Abstract:

    Auto release classes 

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MSMQ_AUTOREL2_H_
#define _MSMQ_AUTOREL2_H_

#include <propidl.h>

class CServiceHandle
{
public:
    explicit CServiceHandle(SC_HANDLE h = NULL) { m_h = h; };
    ~CServiceHandle() { if (m_h) CloseServiceHandle(m_h); };

    operator SC_HANDLE() const { return m_h; };
    //CServiceHandle& operator=(SC_HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CServiceHandle(const CServiceHandle & );
    CServiceHandle& operator=(const CServiceHandle &);

private:
    SC_HANDLE m_h;

}; //CServiceHandle


class CFindHandle
{
public:
    explicit CFindHandle(HANDLE h = INVALID_HANDLE_VALUE) { m_h = h; };
    ~CFindHandle() { if (m_h != INVALID_HANDLE_VALUE) FindClose(m_h); };

    operator HANDLE() const { return m_h; };
    //CFindHandle& operator=(HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CFindHandle(const CFindHandle & );
    CFindHandle& operator=(const CFindHandle &);

private:
    HANDLE m_h;

}; //CFindHandle


class CBlob
{
public:
    explicit CBlob() { BLOB b; b.pBlobData = NULL; b.cbSize = 0; m_blob = b; };
    CBlob(const BLOB & b) {m_blob = b; };
    ~CBlob() { delete m_blob.pBlobData; };

    CBlob& operator =(BLOB b) { m_blob = b; return(*this); };
    operator BLOB() const { return m_blob; };

private:
    //
    // Prevent copy
    //
    CBlob(const CBlob & );
    CBlob& operator=(const CBlob &);

private:
    BLOB m_blob;

}; //CBlob


class CCaclsid
{
public:
    explicit CCaclsid() { CACLSID c; c.pElems = NULL; c.cElems = 0; m_caclsid = c; };
    CCaclsid(const CACLSID & c) { m_caclsid = c; };
    ~CCaclsid() { delete m_caclsid.pElems; };

    CCaclsid& operator =(CACLSID c) { m_caclsid = c; return(*this); };
    operator CACLSID() const { return m_caclsid; };

private:
    //
    // Prevent copy
    //
    CCaclsid(const CCaclsid & );
    CCaclsid& operator=(const CCaclsid &);

private:
    CACLSID m_caclsid;

}; //CCaclsid


class CSecDescPointer
{
public:
    explicit CSecDescPointer(PSECURITY_DESCRIPTOR p = NULL) { m_p = p; };
    ~CSecDescPointer() { if (m_p) delete [] reinterpret_cast<char*>(m_p); };

    CSecDescPointer& operator =(PSECURITY_DESCRIPTOR p) { m_p = p; return(*this); };
    operator char*() { return reinterpret_cast<char*>(m_p); };

private:
    //
    // Prevent copy
    //
    CSecDescPointer(const CSecDescPointer & );
    CSecDescPointer& operator=(const CSecDescPointer &);

private:
    PSECURITY_DESCRIPTOR m_p;

}; //CSecDescPointer


class CEventSource
{
public:
    explicit CEventSource(HANDLE h = NULL) { m_h = h; };
    ~CEventSource() { if (m_h) DeregisterEventSource(m_h); };

    operator HANDLE() const { return m_h; };
    CEventSource& operator=(HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CEventSource(const CEventSource & );
    CEventSource& operator=(const CEventSource &);

private:
    HANDLE m_h;

}; //CEventSource


#endif //_MSMQ_AUTOREL2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\bupdate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	bupdate.h

Abstract:
	DS update class

	This class includes all the information of the update performed on the DS

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __BUPDATE_H__
#define __BUPDATE_H__

#include "factory.h"
#include "seqnum.h"
//
// type of operation
//
#define DS_UPDATE_CREATE        ((unsigned char) 0x00)
#define DS_UPDATE_SET           ((unsigned char) 0x01)
#define DS_UPDATE_DELETE        ((unsigned char) 0x02)
#define DS_UPDATE_SYNC          ((unsigned char) 0x03)

#define UPDATE_OK				0x00000000	// everything is fine
#define UPDATE_DUPLICATE		0x00000001	// receiving an old update
#define UPDATE_OUT_OF_SYNC		0x00000002	// we need a sync, probably we missed information
#define UPDATE_UNKNOWN_SOURCE	0x00000003	// we need a sync, probably we missed information

//
//  dwNeedCopy values
//
#define UPDATE_COPY             0x00000000
#define UPDATE_DELETE_NO_COPY   0x00000001
#define UPDATE_NO_COPY_NO_DELETE    0x00000002

#ifndef MQUTIL_EXPORT
#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif
#endif

class MQUTIL_EXPORT CDSBaseUpdate
{
public:
    CDSBaseUpdate();
	~CDSBaseUpdate();

	HRESULT Init(
			IN	const GUID	*	pguidMasterId,
			IN	const CSeqNum &	sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
			IN  BOOL            fOriginatedByThisMaster,
            IN	unsigned char	bCommand,
			IN	DWORD			dwNeedCopy,
			IN	LPWSTR			pwcsPathName,
			IN	DWORD			cp,
			IN	PROPID*         aProp,
			IN	PROPVARIANT*    aVar);


	HRESULT Init(
			IN	const GUID *	pguidMasterId,
			IN	const CSeqNum &	sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
			IN  BOOL            fOriginatedByThisMaster,
			IN	unsigned char	bCommand,
			IN	DWORD			dwNeedCopy,
			IN	CONST GUID *	pguidIdentifier,
			IN	DWORD			cp,
			IN	PROPID*         aProp,
			IN	PROPVARIANT*    aVar);

	HRESULT Init(
			IN	const unsigned char *	pBuffer,
			OUT	DWORD *					pUpdateSize,
            IN  BOOL                    fReplicationService = FALSE);
	
	HRESULT	GetSerializeSize(
			OUT DWORD *			pdwSize);

    HRESULT	Serialize(
			OUT	unsigned char *	pBuffer,
			OUT DWORD * pdwSize,
			IN  BOOL    fInterSite);


	const CSeqNum & GetSeqNum() const;
	
	const CSeqNum & GetPrevSeqNum() const;
	
	const CSeqNum & GetPurgeSeqNum() const;
	
	void	SetPrevSeqNum(IN CSeqNum & snPrevSeqNum);
	
	const GUID *	GetMasterId();
	unsigned char   GetCommand();
	DWORD           GetObjectType();
	LPWSTR          GetPathName();
	unsigned char   getNumOfProps();
	PROPID *        GetProps();
	PROPVARIANT *   GetVars();
	GUID *          GetGuidIdentifier();

#ifdef _DEBUG
    inline BOOL  WasInc() { return m_cpInc ; }
#endif

private:

	HRESULT	SerializeProperty(
			IN	PROPVARIANT&	Var,
			OUT	unsigned char *	pBuffer,
			OUT DWORD *			pdwSize);

	HRESULT	InitProperty(
			IN	const unsigned char *	pBuffer,
			OUT DWORD *					pdwSize,
			IN	PROPID					PropId,
			OUT	PROPVARIANT&			rVar);

	HRESULT	CopyProperty(
			IN	PROPVARIANT&	SrcVar,
			IN	PROPVARIANT*	pDstVar);

	void	DeleteProperty(
			IN	PROPVARIANT&	Var);


	unsigned char	m_bCommand;
	GUID			m_guidMasterId;
	CSeqNum			m_snPrev;
    BOOL            m_fOriginatedByThisMaster;     // TRUE - update was originate by this server

	CSeqNum			m_sn;
	CSeqNum			m_snPurge;
	LPWSTR			m_pwcsPathName;
	unsigned char	m_cp;
	PROPID*         m_aProp;
    PROPVARIANT*    m_aVar;

	GUID *			m_pGuid;
	BOOL			m_fUseGuid; // If true object will preform DB operations by guid and
								// not by path name
    BOOL            m_fNeedRelease; // TRUE if the destructor has to delete class variables

#ifdef _DEBUG
    BOOL            m_cpInc ;
#endif
};


inline CDSBaseUpdate::CDSBaseUpdate():
#ifdef _DEBUG
                                m_cpInc(FALSE),
#endif
                                m_bCommand(0),
								m_fOriginatedByThisMaster(FALSE),
                                m_guidMasterId(GUID_NULL),
                                m_pwcsPathName(NULL),
                                m_cp(0),
                                m_aProp(0),
                                m_aVar(NULL),
                                m_pGuid(NULL)
{
    // default constructor init m_snPrev , m_snPurge & m_sn to smallest value
}

inline 	const GUID * CDSBaseUpdate::GetMasterId()
{
	return(&m_guidMasterId);
}

inline const CSeqNum & CDSBaseUpdate::GetSeqNum() const	
{
	return(m_sn);
}

inline const CSeqNum & CDSBaseUpdate::GetPrevSeqNum() const	
{
	return(m_snPrev);
}

inline void	CDSBaseUpdate::SetPrevSeqNum(IN CSeqNum & snPrevSeqNum)
{
	m_snPrev = snPrevSeqNum;
}

inline const CSeqNum & CDSBaseUpdate::GetPurgeSeqNum() const	
{
	return(m_snPurge);
}

inline unsigned char CDSBaseUpdate::GetCommand()
{
	return(m_bCommand);

}
inline  DWORD CDSBaseUpdate::GetObjectType()
{
    if ( m_bCommand != DS_UPDATE_DELETE)
    {
	    return( PROPID_TO_OBJTYPE( *m_aProp));
    }
    else
    {
        //
        //  For deleted object - the second variant holds the Object type
        //
        ASSERT(m_aProp[1] == PROPID_D_OBJTYPE);
        ASSERT(m_cp == 2);
        return(m_aVar[1].bVal);
    }
}
inline LPWSTR CDSBaseUpdate::GetPathName()
{
	return(m_pwcsPathName);
}
inline unsigned char CDSBaseUpdate::getNumOfProps()
{
	return(m_cp);
}
inline PROPID * CDSBaseUpdate::GetProps()
{
	return(m_aProp);
}
inline PROPVARIANT * CDSBaseUpdate::GetVars()
{
	return(m_aVar);
}

inline GUID * CDSBaseUpdate::GetGuidIdentifier()
{
	return( m_pGuid);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\dsproto.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   dsproto.h

Abstract:

    Definition of DS functions prototypes.

Author:

    Doron Juster (DoronJ)


--*/

#ifndef __DSPROTO_H__
#define __DSPROTO_H__


typedef HRESULT
(APIENTRY *DSCreateObject_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                OUT GUID*                   pObjGuid);

#define MQDS_SIGN_PUBLIC_KEY ((SECURITY_INFORMATION)0x80000000)
#define MQDS_KEYX_PUBLIC_KEY ((SECURITY_INFORMATION)0x40000000)
#define	MQDS_PUBLIC_KEYS_INFO_ALL ( MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY )


typedef struct MQDS_PublicKey_tag
{
    DWORD dwPublikKeyBlobSize;
    BYTE abPublicKeyBlob[1];
} MQDS_PublicKey, *PMQDS_PublicKey;

typedef HRESULT
(APIENTRY *DSSetObjectSecurity_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

typedef HRESULT
(APIENTRY *DSGetObjectSecurity_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

typedef HRESULT
(APIENTRY *DSDeleteObject_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName);

typedef HRESULT
(APIENTRY *DSGetObjectProperties_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesEx_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSSetObjectProperties_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSLookupBegin_ROUTINE)(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT HANDLE*                 pHandle);

typedef HRESULT
(APIENTRY *DSLookupNext_ROUTINE)(
                IN  HANDLE                  hEnum,
                OUT DWORD*                  pcPropsRead,
                OUT PROPVARIANT             aPropVar[]);

typedef HRESULT
(APIENTRY *DSLookupEnd_ROUTINE)(
                IN  HANDLE                  hEnum);

typedef void (APIENTRY *QMLookForOnlineDS_ROUTINE)(VOID);

typedef HRESULT
(APIENTRY *MQGetMQISServer_ROUTINE)(
                IN BOOL *pfRemote ) ;

typedef HRESULT
(APIENTRY *DSClientInit_ROUTINE)(
							QMLookForOnlineDS_ROUTINE pLookDS,
                            MQGetMQISServer_ROUTINE pGetServers,
                            BOOL fSetupMode,
                            BOOL fQMDll
                            );

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesGuidEx_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY * DSSetObjectPropertiesGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY * DSDeleteObjectGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid);

typedef HRESULT
(APIENTRY * DSSetObjectSecurityGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID *            pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

typedef HRESULT
(APIENTRY * DSGetObjectSecurityGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID *            pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

typedef void
(APIENTRY * DSTerminate_ROUTINE) () ;

typedef HRESULT
(APIENTRY *DSQMChallengeResponce_ROUTINE)(
     IN     BYTE    *pbChallenge,
     IN     DWORD   dwChallengeSize,
     IN     DWORD_PTR dwContext,
     OUT    BYTE    *pbSignature,
     OUT    DWORD   *pdwSignatureSize,
     IN     DWORD   dwSignatureMaxSize);

struct DSQMSetMachinePropertiesStruct
{
    DWORD cp;
    PROPID *aProp;
    PROPVARIANT *apVar;
    DSQMChallengeResponce_ROUTINE pfSignProc;
};

typedef HRESULT
(APIENTRY * DSCreateServersCache_ROUTINE)() ;

typedef HRESULT
(APIENTRY * DSQMGetObjectSecurity_ROUTINE)(
                IN    DWORD                 dwObjectType,
                IN    CONST GUID*           pObjectGuid,
                IN    SECURITY_INFORMATION  RequestedInformation,
                IN    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                IN    DWORD                 nLength,
                IN    LPDWORD               lpnLengthNeeded,
                IN    DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN    DWORD_PTR             dwContext);

typedef HRESULT
(APIENTRY * DSGetUserParams_ROUTINE)(
            IN     DWORD      dwFalgs,
            IN     DWORD      dwSidLength,
            OUT    PSID       pUserSid,
            OUT    DWORD      *pdwSidReqLength,
            OUT    LPWSTR     szAccountName,
            IN OUT DWORD      *pdwAccountNameLen,
            OUT    LPWSTR     szDomainName,
            IN OUT DWORD      *pdwDomainNameLen);

typedef HRESULT
(APIENTRY * DSGetComputerSites_ROUTINE) (
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

typedef HRESULT
(APIENTRY * DSRelaxSecurity_ROUTINE) (DWORD dwRelaxFlag) ;

typedef HRESULT
(APIENTRY *DSBeginDeleteNotification_ROUTINE) (
                 IN LPCWSTR						pwcsQueueName,
                 IN OUT HANDLE   *              phEnum
	             );

typedef HRESULT
(APIENTRY *DSNotifyDelete_ROUTINE) (
				IN  HANDLE                  hEnum
				);

typedef HRESULT
(APIENTRY *DSEndDeleteNotification_ROUTINE) (
				IN  HANDLE                  hEnum
				);

typedef void
(APIENTRY *DSFreeMemory_ROUTINE) (
				IN  PVOID					pMemory
				);

#endif // __DSPROTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\ds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ds.h

Abstract:

    Message Queuing's Directory Service Header File

--*/

#ifndef __DS_H__
#define __DS_H__

#ifdef _DS_
#define DS_EXPORT  DLL_EXPORT
#else
#define DS_EXPORT  DLL_IMPORT
#endif

//
// DS_EXPORT_IN_DEF_FILE
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#ifdef _DS_
#define DS_EXPORT_IN_DEF_FILE
#else
#define DS_EXPORT_IN_DEF_FILE  DLL_IMPORT
#endif

#include <dsproto.h>
#include "mqdsdef.h"
#include "ex.h"

#ifdef __cplusplus
extern "C"
{
#endif


//********************************************************************
//                           A P I
//********************************************************************


HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                OUT GUID*                   pObjGuid);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectProperties(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectProperties(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupBegin(
                IN  LPWSTR                  lpwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupNext(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupEnd(
                IN  HANDLE                  hEnum);


HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObjectGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSClientInit(
	QMLookForOnlineDS_ROUTINE,
	MQGetMQISServer_ROUTINE,
	BOOL fSetupMode,
	BOOL fQMDll
	);


HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSServerInit(
	VOID
	);

void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSTerminate(
    VOID
    );

//
// Flags for DSGetUserParams
//
#define GET_USER_PARAM_FLAG_SID              1
#define GET_USER_PARAM_FLAG_ACCOUNT          2

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetUserParams(
            IN     DWORD      dwFalgs,
            IN     DWORD      dwSidLength,
            OUT    PSID       pUserSid,
            OUT    DWORD      *pdwSidReqLength,
            OUT    LPWSTR     szAccountName,
            IN OUT DWORD      *pdwAccountNameLen,
            OUT    LPWSTR     szDomainName,
            IN OUT DWORD      *pdwDomainNameLen);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMSetMachineProperties(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           aProp[],
    IN  PROPVARIANT      apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR        dwContext
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateServersCache(
    VOID
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMGetObjectSecurity(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

//
// In the two GetObj..Ex api below, "fSearchDSserver" tell the mqdslci code
// whether or not to search an online DS server. By default, it's TRUE.
// The code that query public key of target machines set it to FALSE.
// See mqsec\encrypt\pbkeys.cpp for details.
//

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesEx(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] ) ;
/*                IN  BOOL                    fSearchDSserver = TRUE );*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuidEx(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] ) ;
/*                IN  BOOL                    fSearchDSserver = TRUE );*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSBeginDeleteNotification(
                 IN LPCWSTR						pwcsQueueName,
                 IN OUT HANDLE   *              phEnum
	             );
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSNotifyDelete(
        IN  HANDLE                  hEnum
	    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSEndDeleteNotification(
        IN  HANDLE                  hEnum
        );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSRelaxSecurity(DWORD dwRelaxFlag) ;

void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSExSetTimer( 
    CTimer* pTimer,
    const CTimeDuration& Timeout
	);

void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSFreeMemory(
        IN PVOID pMemory
        );

BOOL
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSIsWeakenSecurity(
    VOID
    );


#ifdef __cplusplus
}
#endif

#endif // __DS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mgmtrpc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mgmtrpc.h

Abstract: rpc related code.


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#define  QMMGMT_PROTOCOL   (TEXT("ncalrpc"))
#define  QMMGMT_ENDPOINT   (TEXT("QMMgmtFacility"))
#define  QMMGMT_OPTIONS    (TEXT("Security=Impersonation Dynamic True"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqaddef.h ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

	mqaddef.h

Abstract:

	Message Queuing's Active Service defines


--*/
#ifndef __MQADDEF_H__
#define __MQADDEF_H__


//********************************************************************
//				AD object types
//********************************************************************

enum AD_OBJECT {
    eQUEUE,
    eMACHINE,
    eSITE,
    eENTERPRISE,
    eUSER,
    eROUTINGLINK,
    eSERVER,
    eSETTING,
    eCOMPUTER,
    eMQUSER,
	eFOREIGNSITE,
    eNumberOfObjectTypes
};

//********************************************************************
//				AD server types
//********************************************************************
enum AD_SERVER_TYPE{
    eRouter,
    eDS
};

//********************************************************************
//				Routing link neighnbor
//********************************************************************
enum eLinkNeighbor
{
    eLinkNeighbor1,
    eLinkNeighbor2
};

//********************************************************************
//				Environment
//********************************************************************
enum eDsEnvironment
{
    eUnknown,
    eMqis,
    eAD
};

//********************************************************************
//				Providers
//********************************************************************
enum eDsProvider
{
	eUnknownProvider,
	eWorkgroup,
    eMqdscli,
    eMqad
};

//********************************************************************
//				Object classes
//********************************************************************
enum eAdsClass
{
	eGroup,
	eAliasQueue,
    eQueue
};

//********************************************************************
//				Ds namespaces
//********************************************************************
enum eDSNamespace
{
    eConfiguration,
    eSchema,
    eDomain,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mixmode.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mixmode.h

Abstract:

    Definition for mixed mode environment (NT5/MSMQ2 + NT4/MSMQ1 servers
    in same enterprise.

Author:

    Doron Juster  (DoronJ)   07-Apr-97  Created

--*/

//
// names of default containers, which are created by the migration tool.
//
#define  MIG_DEFAULT_COMPUTERS_CONTAINER  (TEXT("msmqComputers"))
#define  MIG_DEFAULT_USERS_CONTAINER      (TEXT("msmqUsers"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\factory.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	factory.h

Abstract:
	Factory Template for Shared Objects

Author:
	RaphiR

--*/
/*
 * CFactory is a template class used for create and delete objects
 * of shared class. In the shared class, an object will be created
 * only once for a specific key. If it exists already, its reference
 * count will be incremented.
 *
 * A shared class has to be derived from CSharedObject class.
 */
#ifndef __FACTORY_H__
#define __FACTORY_H__


//---------------------------------------
//    CInterlocakedSharedObject definition
// Base class for shared objects classes 
// used in different threads
//---------------------------------------
class CInterlockedSharedObject
{
	public:
		
		CInterlockedSharedObject()		{ref = 0; }
		void AddRef()		{InterlockedIncrement(&ref);}
		long Release()		{InterlockedDecrement(&ref); ASSERT(ref>=0); return ref;}
        long GetRef()       {return ref;}
		virtual ~CInterlockedSharedObject()	{ ASSERT(ref == 0); }

	private:
		// Should be aligned on 32 bit boundary
		long ref;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqcacert.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcacert.h

Description:

    Header file for the various CA certificates management routines.

Author:

    Boaz Feldbaum (BoazF) 19-May-1997.

--*/

#ifndef _MQCQCERT_H_

#define _MQCQCERT_H_

#include <autoptr.h>

class MQ_CA_CONFIG {
public:
    MQ_CA_CONFIG() {}

    AP<WCHAR> szCaRegName;
    AP<WCHAR> szCaSubjectName;
    P<BYTE> pbSha1Hash;
    DWORD dwSha1HashSize;
    BOOL fEnabled;
    BOOL fDeleted;

private:
    MQ_CA_CONFIG(const MQ_CA_CONFIG&);
    MQ_CA_CONFIG& operator=(const MQ_CA_CONFIG&);
};

#define MQ_CA_CERT_ENABLED_PROP_ID CERT_FIRST_USER_PROP_ID
#define MQ_CA_CERT_SUBJECT_PROP_ID (CERT_FIRST_USER_PROP_ID + 1)

#ifndef MQUTIL_EXPORT
#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif
#endif

#ifndef DLL_EXPORT
#define DLL_EXPORT  __declspec(dllexport)
#endif

#ifndef DLL_IMPORT
#define DLL_IMPORT  __declspec(dllimport)
#endif

MQUTIL_EXPORT
HRESULT
MQSetCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *MqCaConfig
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqcertui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcertui.h

Abstract:

    Dialogs for certificate related user interface.

Author:

    Boaz Feldbaum (BoazF)  15-Oct-1996
    Doron Juster  (DoronJ) 15-dec-1997, remove digsig, use crypto2.0

--*/

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

BOOL
ShowPersonalCertificates(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts );

BOOL
SelectPersonalCertificateForRemoval(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts,
        CMQSigCertificate **ppCert ) ;

BOOL
SelectPersonalCertificateForRegister(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts,
        CMQSigCertificate **ppCert ) ;


#define CERT_TYPE_INTERNAL 1
#define CERT_TYPE_PERSONAL 2
#define CERT_TYPE_CA 3
#define CERT_TYPE_MASK 0xff

void
ShowCertificate(
        HWND                hParentWnd,
        CMQSigCertificate  *pCert,
        DWORD               dwFlags );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqcrypt.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    mqcrypt.h

Abstract:
    Falcon cryptographic stuff

Author:
    Boaz Feldbaum (BoazF) 16-Oct-1996

Revision History:

--*/

#ifndef _MQCRYPT_H_
#define _MQCRYPT_H_

#include <winreg.h>
#include <wincrypt.h>

//+------------------------------------------------------------
//
// A helper class for automatically releasing the CSP context.
//
//+------------------------------------------------------------

class CHCryptProv
{
public:
    CHCryptProv() : m_hProv(NULL) {}
    CHCryptProv(HCRYPTPROV hProv) : m_hProv(hProv) {}
    ~CHCryptProv() ;
    HCRYPTPROV * operator &() { return &m_hProv; }
    operator HCRYPTPROV() { return m_hProv; }
    CHCryptProv &operator =(HCRYPTPROV hProv) { m_hProv = hProv; return *this; }
    void free();
private:
    HCRYPTPROV m_hProv;
};

inline void CHCryptProv::free()
{
    if (m_hProv)
    {
       CryptReleaseContext(m_hProv, 0);
    }
    m_hProv = NULL;
}


inline CHCryptProv::~CHCryptProv()
{
	free();
}

//+---------------------------------------------------------
//
// A helper class for automatically destroying a key.
//
//+---------------------------------------------------------

class CHCryptKey
{
public:
    CHCryptKey() : m_hKey(NULL) {}
    CHCryptKey(HCRYPTKEY hKey) : m_hKey(hKey) {}
    ~CHCryptKey() { if (m_hKey) CryptDestroyKey(m_hKey); }
    HCRYPTKEY * operator &() { return &m_hKey; }
    operator HCRYPTKEY() { return m_hKey; }
    CHCryptKey &operator =(HCRYPTKEY hKey) { m_hKey = hKey; return *this; }
private:
    HCRYPTKEY m_hKey;
};

//+--------------------------------------------------------
//
// A helper class for automatically destroying a hash.
//
//+--------------------------------------------------------

class CHCryptHash
{
public:
    CHCryptHash() : m_hHash(NULL) {}
    CHCryptHash(HCRYPTHASH hHash) : m_hHash(hHash) {}
    ~CHCryptHash() { if (m_hHash) CryptDestroyHash(m_hHash); }
    HCRYPTHASH * operator &() { return &m_hHash; }
    operator HCRYPTHASH() { return m_hHash; }
    CHCryptHash &operator =(HCRYPTHASH hHash) { m_hHash = hHash; return *this; }
private:
    HCRYPTHASH m_hHash;
};

//
// A helper class for automatically closing a certificate store.
//
class CHCertStore
{
public:
    CHCertStore() : m_hStore(NULL) {}
    CHCertStore(HCERTSTORE hStore) : m_hStore(hStore) {}
    ~CHCertStore()
        { if (m_hStore) CertCloseStore(m_hStore, CERT_CLOSE_STORE_FORCE_FLAG); }
    HCERTSTORE * operator &() { return &m_hStore; }
    operator HCERTSTORE() { return m_hStore; }
    CHCertStore &operator =(HCERTSTORE hStore) { m_hStore = hStore; return *this; }
private:
    HCERTSTORE m_hStore;
};

//+------------------------------------------------------------------
//
// A helper class for automatically freeing a certificate context.
//
//+------------------------------------------------------------------

class CPCCertContext
{
public:
    CPCCertContext() : m_pCert(NULL) {}
    CPCCertContext(PCCERT_CONTEXT pCert) : m_pCert(pCert) {}
    ~CPCCertContext() { if (m_pCert) CertFreeCertificateContext(m_pCert); }
    PCCERT_CONTEXT * operator &() { return &m_pCert; }
    operator PCCERT_CONTEXT() { return m_pCert; }
    CPCCertContext &operator =(PCCERT_CONTEXT pCert) { m_pCert = pCert; return *this; }
private:
    PCCERT_CONTEXT m_pCert;
};

//+-----------------------------------------------------------------
//
// A helper class for cleanup of a CERT_INFO structure.
//
//+-----------------------------------------------------------------

class CpCertInfo
{
private:
    CERT_INFO *m_p ;

public:
    CpCertInfo() : m_p(NULL)         {}
   ~CpCertInfo() ;

    operator CERT_INFO*() const           { return m_p; }
    CERT_INFO*  operator->() const        { return m_p; }
    CERT_INFO*  operator=(CERT_INFO* p)   { m_p = p; return m_p ; }
};

inline CpCertInfo::~CpCertInfo()
{
    if (m_p)
    {
        if (m_p->Issuer.pbData)
        {
            ASSERT(m_p->Issuer.cbData > 0) ;
            delete m_p->Issuer.pbData ;
        }
        if (m_p->Subject.pbData)
        {
            ASSERT(m_p->Subject.cbData > 0) ;
            delete m_p->Subject.pbData ;
        }
        delete m_p ;
    }
}

//+----------------------------------
//
// Some constant definitions
//
//+----------------------------------

//
// Registry where internal certificate is kept. This is a registry based
// certificates store.
//
#define MQ_INTERNAL_CERT_STORE_REG  "Software\\Microsoft\\MSMQ\\CertStore"
#define MQ_INTERNAL_CERT_STORE_LOC  TEXT(MQ_INTERNAL_CERT_STORE_REG)

//
// Validity of internal certificate.
// 8 years take leap year into account.
//
#define INTERNAL_CERT_DURATION_YEARS   8

//
// "locality" value for internal certificate.
//
#define MQ_CERT_LOCALITY            TEXT("MSMQ")

//
// Name of container for public/private key of internal certificate.
// Different name if internal certificate created from a LocalSystem service.
//
#define MSMQ_INTCRT_KEY_CONTAINER_W            L"MSMQ"
#define MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W    L"MSMQ_SERVICE"

#define MAX_MESSAGE_SIGNATURE_SIZE     128 // bytes

//
// MAX_MESSAGE_SIGNATURE_SIZE_EX contain 2 hashs and constant of 12 bytes
// for hash of size 512 which is huge we need 512*2+12 = 1036
//
#define MAX_MESSAGE_SIGNATURE_SIZE_EX  1040 // bytes

//
// Default algorithems.
//
#define PROPID_M_DEFUALT_HASH_ALG       CALG_SHA1
#define PROPID_M_DEFUALT_ENCRYPT_ALG    CALG_RC2

#endif //_MQCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqcert.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    mqcert.h

Abstract:
    This dll replaces digsig.dll which is obsolete now and will not be
    available on NT5. The main functionality in mqcert.dll is to create
    a certificate or read the parameters from an existing  certificate.

    The dll exports four functions:
    - MQSigCreateCertificate
    - MQSigOpenUserCertStore
    - MQSigCloneCertFromReg
    - MQSigCloneCertFromSysStore

    and expose two classes:
    - CMQSigCertificate
    - CMQSigCertStore

    When calling the funtions, an object (CMQSigCertificate or
    CMQSigCertSotre) is always created and returned to caller. The caller
    then uses the objects for the actual work. Caller must use the Release()
    method to delete the objects and free resources held by them.

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#ifndef _MQCERT_H_
#define _MQCERT_H_

#include "mqsymbls.h"
#include "mqcrypt.h"
#include <autoptr.h>

//*****************************************
//
//  D E F I N T I O N s
//
//*****************************************

//
// default protocol for personnal certificates store
//
const WCHAR  x_wszPersonalSysProtocol[] = {L"My"};

//
// Define the default validity check done on a certificate.
//
const DWORD  x_dwCertValidityFlags  (CERT_STORE_REVOCATION_FLAG |
                                     CERT_STORE_SIGNATURE_FLAG  |
                                     CERT_STORE_TIME_VALIDITY_FLAG) ;

//********************************
//
//  Exported APIs
//
//********************************

class  CMQSigCertStore ;
class  CMQSigCertificate ;

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT APIENTRY
MQSigCreateCertificate( OUT CMQSigCertificate **ppCert,
                        IN  PCCERT_CONTEXT      pCertContext = NULL,
                        IN  PBYTE               pCertBlob = NULL,
                        IN  DWORD               dwCertSize = 0 ) ;

struct MQSigOpenCertParams
{
    HKEY  hCurrentUser ;
    bool  bWriteAccess ;
    bool  bCreate ;
    bool  bMachineStore ;
};

HRESULT APIENTRY
MQSigOpenUserCertStore( OUT CMQSigCertStore **ppStore,
                        IN  LPSTR      lpszRegRoot,
                        IN  struct MQSigOpenCertParams *pParams ) ;

HRESULT APIENTRY
MQSigCloneCertFromReg( OUT CMQSigCertificate **ppCert,
                 const IN  LPSTR               lpszRegRoot,
                 const IN  LONG                iCertIndex ) ;

HRESULT APIENTRY
MQSigCloneCertFromSysStore( OUT CMQSigCertificate **ppCert,
                      		IN  LPCWSTR             lpwzProtocol,
                      const IN  LONG                iCertIndex ) ;

//+-------------------------------------
//
//  typedef for use in GetProcAddress
//
//+-------------------------------------

typedef HRESULT
(APIENTRY *MQSigCreateCertificate_ROUTINE) (
                        OUT CMQSigCertificate **ppCert,
                        IN  PCCERT_CONTEXT      pCertContext /*= NULL*/,
                        IN  PBYTE               pCertBlob /*= NULL*/,
                        IN  DWORD               dwCertSize /*= 0*/ ) ;

typedef HRESULT
(APIENTRY *MQSigOpenUserCertStore_ROUTINE) (
                        OUT CMQSigCertStore **ppStore,
                        IN  LPSTR      lpszRegRoot,
                        IN  BOOL       fWriteAccess /*= FALSE*/,
                        IN  BOOL       fCreate /*= FALSE*/ ) ;

typedef HRESULT
(APIENTRY *MQSigCloneCertFromStore_ROUTINE) (
                        OUT CMQSigCertificate **ppCert,
                  const IN  LPSTR               lpszRegRoot,
                  const IN  LONG                iCertIndex ) ;

typedef HRESULT
(APIENTRY *MQSigCloneCertFromSysStore_ROUTINE) (
                            OUT CMQSigCertificate **ppCert,
                      		IN  LPCWSTR             lpwzProtocol,
                      const IN  LONG                iCertIndex ) ;

#ifdef __cplusplus
}
#endif

//******************************
//
//  class  CMQSigCertificate
//
//******************************

class  CMQSigCertificate
{
    friend
           HRESULT APIENTRY
           MQSigCreateCertificate(
                             OUT CMQSigCertificate **ppCert,
                             IN  PCCERT_CONTEXT      pCertContext,
                             IN  PBYTE               pCertBlob,
                             IN  DWORD               dwCertSize ) ;

    public:
        CMQSigCertificate() ;
        ~CMQSigCertificate() ;

        virtual HRESULT   EncodeCert( IN BOOL     fMachine,
                                      OUT BYTE  **ppCertBuf,
                                      OUT DWORD  *pdwSize ) ;
         //
         // "EncodeCert" is the last method to call when creating a
         // certificate. It follows all the "PutXX" methods which set the
         // various fields of the certifiacte. The returned buffer (pCertBuf)
         // is the encoded and signed certificate.
         //

        virtual HRESULT   GetCertDigest(OUT GUID  *pguidDigest) ;

        virtual HRESULT   GetCertBlob(OUT BYTE  **ppCertBuf,
                                      OUT DWORD *pdwSize) const ;
          //
          // ppCertBuf only points to the internal buffer in the object.
          // Caller must not free it or change it in any way.
          //

        virtual HRESULT   AddToStore( IN HCERTSTORE hStore ) const ;
         //
         // Add the certificate to a certificates store.
         //

        virtual HRESULT   DeleteFromStore() ;
         //
         // Delete the certificate from store.
         //

        virtual HRESULT   Release( BOOL fKeepContext = FALSE ) ;

        //-------------------------------------------------
        //  PUT methods. Set up the certificate fields.
        //-------------------------------------------------

        virtual HRESULT   PutIssuer( LPWSTR lpwszLocality,
                                      LPWSTR lpwszOrg,
                                      LPWSTR lpwszOrgUnit,
                                      LPWSTR lpwszDomain,
                                      LPWSTR lpwszUser,
                                      LPWSTR lpwszMachine ) ;


        virtual HRESULT   PutSubject( LPWSTR lpwszLocality,
                                       LPWSTR lpwszOrg,
                                       LPWSTR lpwszOrgUnit,
                                       LPWSTR lpwszDomain,
                                       LPWSTR lpwszUser,
                                       LPWSTR lpwszMachine ) ;


        virtual HRESULT   PutValidity( WORD wYears ) ;
         //
         // The granularity of this setting is a year.
         // The cert is valid for "dwYears", starting with the issue date.
         //

        virtual HRESULT   PutPublicKey( IN  BOOL  fRenew,
                                        IN  BOOL  fMachine,
                                        OUT BOOL *pfCreated = NULL ) ;
         //
         // if fRenew is TRUE, then previous private/public keys pair are
         // deleted (if they exsited) and recreated.
         // Otherwise, old keys are used if available. If not available,
         // they are created.
         // On return, pfCreate is TRUE if a new key was created.
         //

        //-------------------------------------------------
        //  GET methods. Retrieve the certificate fields.
        //-------------------------------------------------

        virtual HRESULT   GetIssuer( OUT LPWSTR *ppszLocality,
                                     OUT LPWSTR *ppszOrg,
                                     OUT LPWSTR *ppszOrgUnit,
                                     OUT LPWSTR *ppszCommon ) const ;

        virtual HRESULT   GetIssuerInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const ;
         //
         // ppNameInfo can be used when calling "GetNames", to retrieve
         // the name components of the certificate. The caller must
         // free (delete) the memory allocated for ppNameInfo.
         //

        virtual HRESULT   GetSubject( OUT LPWSTR *ppszLocality,
                                      OUT LPWSTR *ppszOrg,
                                      OUT LPWSTR *ppszOrgUnit,
                                      OUT LPWSTR *ppszCommon ) const ;

        virtual HRESULT   GetSubjectInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const ;
         //
         // ppNameInfo can be used when calling "GetNames", to retrieve
         // the name components of the certificate. The caller must
         // free (delete) the memory allocated for ppNameInfo.
         //

        virtual HRESULT   GetNames( IN CERT_NAME_INFO *pNameInfo,
                                    OUT LPWSTR         *ppszLocality,
                                    OUT LPWSTR         *ppszOrg,
                                    OUT LPWSTR         *ppszOrgUnit,
                                    OUT LPWSTR         *ppszCommon,
                               OUT LPWSTR  *ppEmailAddress = NULL ) const ;

        virtual HRESULT   GetValidity( OUT FILETIME *pftNotBefore,
                                       OUT FILETIME *pftNotAfter ) const ;

        virtual HRESULT   GetPublicKey( IN  HCRYPTPROV hProv,
                                        OUT HCRYPTKEY  *phKey ) const ;

        //-------------------------------------------------
        //  Validation methods, to validate a certificate
        //-------------------------------------------------

        virtual HRESULT   IsTimeValid(IN FILETIME *pTime = NULL) const ;

        virtual HRESULT   IsCertificateValid(
                IN CMQSigCertificate *pIssuerCert,
                IN DWORD              dwFlags =  x_dwCertValidityFlags,
                IN FILETIME          *pTime   = NULL,
                IN BOOL               fIgnoreNotBefore = FALSE)  const ;

        virtual PCCERT_CONTEXT GetContext() const ;

    private:
        CHCryptProv m_hProvCreate ;
         //
         // auto-release handle for crypto provider. Used for creating
         // a certificate. May be used to create public/private key pair.
         //

        HCRYPTPROV  m_hProvRead ;
         //
         // "Read-Only" handle of crypto provider. This is a replica of a
         // dll global handle, used by all objects and all threads. It is
         // released when dll is unloaded. It must not be released by any
         // object.
         //

        BOOL        m_fCreatedInternally ;
        CpCertInfo  m_pCertInfo ; // auto released pointer.
          // this CERT_INFO structure is built only when a certificate
          // is created from scratch.

        CERT_INFO   *m_pCertInfoRO ;
          //
          // Read-Only pointer to CERT_INFO. It points either to m_pCertInfo,
          // if we create a certificate, or to m_pCertContext->pCertInfo,
          // if a certificate is imported. NEVER release this pointer.
          //

        //
        // The following variables are used to create internal certificates.
        //
        DWORD              m_dwSerNum ;
        CRYPT_OBJID_BLOB   m_SignAlgID ;

        P<CERT_PUBLIC_KEY_INFO> m_pPublicKeyInfo ;
         //
         // Buffer for encoded and exported public key.
         //

        BYTE      *m_pEncodedCertBuf ;
         //
         // this buffer holds the encoded certificate.
         //
        DWORD      m_dwCertBufSize ;

        PCCERT_CONTEXT      m_pCertContext ;
         //
         //  Certificate context. Exist only when create an object from
         //  existing certificate.
         //

        BOOL   m_fKeepContext ;
         //
         // This flag indicates that the context must not be freed when
         // deleting this certificate object. You set it to TRUE only by
         // calling Release( TRUE ).
         //

        BOOL   m_fDeleted ;
         //
         // TRUE if the certificate was deleted from store.  (or at least
         // DeleteFromStore() was called). In that case, the certificate
         // context (m_pCertContext) is not valid any more. It as freed
         // by the delete operation, even if the operation failed.
         //

	    CMQSigCertificate(const CMQSigCertificate&);
		CMQSigCertificate& operator=(const CMQSigCertificate&);

        HRESULT   _InitCryptProviderRead() ;
        HRESULT   _InitCryptProviderCreate( IN BOOL fCreate,
                                            IN BOOL fMachine ) ;
         //
         // Initialize the crypto provider.
         // if fCreate is TRUE then a new pair of public/private keys is
         // always created. Old keys are deleted if available.
         //

        HRESULT   _Create(IN PCCERT_CONTEXT  pCertContext) ;
         //
         // Create an empty certificate (if pEncodedCert is NULL) or
         // initialize a certificate from that encoded buffer.
         //

        //
        // Methds to encode names.
        //
        HRESULT   _EncodeName( LPWSTR  lpszLocality,
                               LPWSTR  lpszOrg,
                               LPWSTR  lpszOrgUnit,
                               LPWSTR  lpszDomain,
                               LPWSTR  lpszUser,
                               LPWSTR  lpszMachine,
                               BYTE   **ppBuf,
                               DWORD  *pdwBufSize ) ;

        HRESULT   _EncodeNameRDN( CERT_RDN_ATTR *rgNameAttr,
                                  DWORD  cbRDNs,
                                  BYTE   **ppBuf,
                                  DWORD  *pdwBufSize ) ;

        HRESULT   _DecodeName( IN  BYTE  *pEncodedName,
                               IN  DWORD dwEncodedSize,
                               OUT BYTE  **pBuf,
                               OUT DWORD *pdwBufSize ) const ;

        HRESULT   _GetAName( IN  CERT_RDN  *pRDN,
                             OUT LPWSTR     *ppszName ) const ;

} ;

//******************************
//
//  class  CMQSigCertStore
//
//******************************

class  CMQSigCertStore
{
    friend
         HRESULT APIENTRY
         MQSigOpenUserCertStore( OUT CMQSigCertStore **pStore,
                                 IN  LPSTR      lpszRegRoot,
                                 IN  struct MQSigOpenCertParams *pParams ) ;

    public:
        CMQSigCertStore() ;
        ~CMQSigCertStore() ;

        virtual HRESULT     Release() ;
        virtual HCERTSTORE  GetHandle() ;

    private:
        HCERTSTORE  m_hStore ;
         //
         //  Handle of opened store.
         //

        HCRYPTPROV m_hProv ;
         //
         // This is a global handle in mqcert.dll.
         // Must not be released by this object.
         //

        HKEY        m_hKeyStoreReg ;
         //
         // Registry location of store.
         //

         //
         // Initialize the crypto provider.
         //
        HRESULT   _InitCryptProvider() ;

         //
         // Open the store.
         //
        HRESULT   _Open( IN  LPSTR      lpszRegRoot,
                         IN  struct MQSigOpenCertParams *pParams ) ;
} ;

//***************************
//
//  Inline Methods
//
//***************************

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetCertBlob()
//
//+-----------------------------------------------------------------------

inline HRESULT CMQSigCertificate::GetCertBlob(OUT BYTE  **ppCertBuf,
                                              OUT DWORD *pdwSize) const
{
    if (!m_pEncodedCertBuf)
    {
        return MQSec_E_INVALID_CALL ;
    }

    *ppCertBuf = m_pEncodedCertBuf ;
    *pdwSize = m_dwCertBufSize ;

    return MQSec_OK ;
}

//+-----------------------------------------------
//
//   CMQSigCertificate::GetContext() const
//
//+-----------------------------------------------

inline PCCERT_CONTEXT CMQSigCertificate::GetContext() const
{
    ASSERT(m_pCertContext) ;
    return m_pCertContext ;
}

//+-----------------------------------------------------------------------
//
//  inline HCERTSTORE CMQSigCertStore::GetHandle()
//
//+-----------------------------------------------------------------------

inline HCERTSTORE CMQSigCertStore::GetHandle()
{
    return m_hStore ;
}

#endif  //  _MQCERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqdsdef.h ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

	mqdsdef.h

Abstract:

	Message Queuing's Directory Service defines

    Note: when this file was first created in msmq1.0, it indeed defined
          only type of objects stored in MQIS. As time passed, and as
          we moved to msmq2.0 on Win2000, this file also define type
          of internal objects, those that are never stored in active
          directory, but are used internally in msmq code.

--*/
#ifndef __MQDSDEF_H__
#define __MQDSDEF_H__


//********************************************************************
//				DS object types
//********************************************************************

// dwObjectType values
#define	MQDS_QUEUE		    1
#define MQDS_MACHINE	    2
#define	MQDS_SITE		    3
#define MQDS_DELETEDOBJECT	4
#define MQDS_CN			    5
#define MQDS_ENTERPRISE	    6
#define MQDS_USER           7
#define MQDS_SITELINK       8

//
// The following are not applicable to msmq2.0 and beyond.
//
// DO NOT RECYCLE THE NUMBERS !!!
//
#define MQDS_PURGE		    9
#define MQDS_BSCACK		    10

//  for internal use only
#define MQDS_MACHINE_CN     11

//
// MAX_MQIS_TYPES is used in NT5 replication service, as array size for
// several arrays which map from object type to propid.
//
#define MAX_MQIS_TYPES      11

//
//  ADS objects
//
#define MQDS_SERVER     50
#define MQDS_SETTING    51
#define MQDS_COMPUTER   52

//
//  This is a temporary object : until msmq is in NT5 schema.
//  It is required for displaying MSMQ queues on left pane of MMC
//
#define MQDS_LEFTPANEQUEUE 53

//
// special object: MSMQ users that do not belong to NT5 domain
//
#define MQDS_MQUSER    54

//
// This type is used when running setup of a msmq1.0 client. It's used
// for creation of the default security descriptor of the msmqConfiguration
// object.
//
#define MQDS_MSMQ10_MACHINE  55

//
// This type is used when run time call local msmq service to create a local
// publib queue. that's new feature of win2000, whereas by default users do
// not have permissions to create queues, only LocalSystem msmq service has
// this permission.
//
#define MQDS_LOCAL_PUBLIC_QUEUE  56

//
// This type is used by the "mqforgn" tool to handle msmqConfiguration
// objects of foreign computers.
//
#define  MQDS_FOREIGN_MACHINE  57

//
//	MQDS_PRIVATE_COMPUTER type represents computer properties that
//	are calculated by the computer and not retrieved from the DS
//
#define MQDS_PRIVATE_COMPUTER	  58

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqencryp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqencryp.h

Abstract:

    Definitions used for encryption.

Author:

    Doron Juster  (DoronJ)   19-Nov-98  Created

--*/

#include <wincrypt.h>
//
// Define constants for the SDK mq.h file.
//
#define MQMSG_PRIV_BASE_PROVIDER     \
                        L"Microsoft Base Cryptographic Provider v1.0" ;
#define MQMSG_PRIV_ENHANCED_PROVIDER \
                        L"Microsoft Enhanced Cryptographic Provider v1.0" ;

//
// The following structures are used to store machine public keys in the DS.
// Each machine may store multiple keys, for multiple providers.
// The structure are only headers and skeleton, as all data is of variable
// length and it's serialized.
//

typedef struct _mqdsPublicKey
{
    ULONG    ulKeyLen ;
    ULONG    ulProviderLen ;  // provider name, including terminator, in bytes
    ULONG    ulProviderType ; // provider type.
    DWORD    aBuf[1] ;        // buffer for key and provider.
                              // first provider, then key.
                              // DWORD, for alignment.
} MQDSPUBLICKEY ;

#define SIZEOF_MQDSPUBLICKEY (sizeof(MQDSPUBLICKEY) - sizeof(DWORD))

typedef struct _mqdsPublicKeys
{
    ULONG          ulLen ;   // len of the whole structure.
    ULONG          cNumofKeys ;
    MQDSPUBLICKEY  aPublicKeys[1] ;
} MQDSPUBLICKEYS ;

#define SIZEOF_MQDSPUBLICKEYS \
                 (sizeof(MQDSPUBLICKEYS) - sizeof(MQDSPUBLICKEY))

//
// Define the MSMQ default encryption providers
//
// Base provider, 40 bits
//
const WCHAR x_MQ_Encryption_Provider_40[] = MQMSG_PRIV_BASE_PROVIDER ;
const DWORD x_MQ_Encryption_Provider_40_len =
                 sizeof( x_MQ_Encryption_Provider_40 ) / sizeof(WCHAR) ;

const DWORD x_MQ_Encryption_Provider_Type_40 = PROV_RSA_FULL ;
const DWORD x_MQ_Block_Size_40  = 8 ;
const DWORD x_MQ_SymmKeySize_40 = 0x4C ;

//
// Enhanced provider, 128 bits
//
const WCHAR x_MQ_Encryption_Provider_128[] = MQMSG_PRIV_ENHANCED_PROVIDER ;
const DWORD x_MQ_Encryption_Provider_128_len =
                 sizeof( x_MQ_Encryption_Provider_128 ) / sizeof(WCHAR) ;

const DWORD x_MQ_Encryption_Provider_Type_128 = PROV_RSA_FULL ;
const DWORD x_MQ_Block_Size_128  =  8 ;
const DWORD x_MQ_SymmKeySize_128 =  0x8C ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqf2format.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqf2format.h

Abstract:
    Convert a QUEUE_FORMATs to FORMAT_NAME string

Author:
    Ilan Herbst (ilanh) 03-Nov-2000


--*/

#ifndef __MQF2FORMAT_H
#define __MQF2FORMAT_H

#include <wchar.h>
#include <mqformat.h>
#include <fntoken.h>

inline
bool
MQpGetMqfProperty(
    const QUEUE_FORMAT*	pqf,
	ULONG				nMqf,
    ULONG*				pLength,
    WCHAR*				pUserBuffer
    )
/*++
Routine Description:
	Get FormatName string representation of mqf.
	If pUserBuffer is NULL, the function will return the needed length
	and MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL.
	This will be also the case if pUserBuffer is not NULL but to small.
	in that case this function will raise ASSERT

Arguments:
	pqf - pointer to QUEUE_FORMAT array
	nMqf - pqf size
    pLength - in/out, *ppUserBuffer string length in WCHARs on input, actual length on output.
	pUserBuffer - FormatName string buffer. can be NULL for getting needed length.

Returned Value:
	HRESULT

--*/
{
	ASSERT(pqf != NULL);
	ASSERT(nMqf > 0);
	ASSERT(pLength != NULL);

    ULONG BufferLength = 0;
    if(pUserBuffer != NULL)
    {
		BufferLength = *pLength;
	}
	*pLength = 0;

	HRESULT hr = MQ_OK;
    for ( ; nMqf-- != 0; ++pqf)
    {
	    ASSERT(pqf->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

		bool fLastElement = (nMqf == 0);

        //
        // Add next queue format to string
        //
        ULONG Length = 0;
		hr = MQpQueueFormatToFormatName(
					pqf,
					pUserBuffer,
					BufferLength,
					&Length,
					!fLastElement
					);

		ASSERT(SUCCEEDED(hr) || 
			   ((pUserBuffer == NULL) && (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)));

        //
        // Dont count the null terminator right after it
        //
        if (!fLastElement)
        {
            --Length;
        }

        //
        // Update required length, remaining length, and pointer in buffer
        //
        *pLength += Length;
        if(pUserBuffer != NULL)
        {
			if(BufferLength < Length)
			{
				ASSERT(("Buffer Length is to small", BufferLength >= Length));
				BufferLength = 0;
			}
			else
			{
				BufferLength -= Length;
				pUserBuffer += Length;
			}
        }
    }

    return (hr == MQ_OK);

} // MQpGetMqfProperty


inline
LPWSTR
MQpMqfToFormatName(
    const QUEUE_FORMAT *	pqf,
	ULONG					nMqf,
    ULONG *					pLength
    )
/*++
Routine Description:
	Get FormatName string representation of mqf.
	This function allocate the FormatName string buffer
	that need to be free by the caller.

Arguments:
	pqf - pointer to QUEUE_FORMAT array
	nMqf - pqf size
    pLength - in\out, *ppUserBuffer string length in WCHARs on input, actual length on output.
	ppUserBuffer - output, pointer to the allocated FormatName string buffer.

Returned Value:
	HRESULT

--*/
{
	ASSERT(pqf != NULL);
	ASSERT(nMqf > 0);
	ASSERT(pLength != NULL);

	//
	// Get Buffer Length
	//

	bool fSuccess = MQpGetMqfProperty(
						pqf, 
						nMqf, 
						pLength, 
						NULL
						);

	ASSERT(!fSuccess);
	ASSERT(*pLength > 0);

	//
	// Get FormatName string
	//
	AP<WCHAR> pFormatName = new WCHAR[*pLength];
	fSuccess = MQpGetMqfProperty(
					pqf, 
					nMqf, 
					pLength, 
					pFormatName.get()
					);

	ASSERT(fSuccess);

	return pFormatName.detach();
}  // MQpMqfToFormatName


#endif //  __MQF2FORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqfutils.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    mqfutils.h

Abstract:
    Mqf utils functions

Author:
    Ilan Herbst (ilanh) 05-Nov-2000


--*/

#ifndef __MQFUTILS_H
#define __MQFUTILS_H

#include <qformat.h>
#include <acdef.h>


inline
void
MQpMqf2SingleQ(
    ULONG nMqf,
    const QUEUE_FORMAT mqf[],
    QUEUE_FORMAT * * ppQueueFormat
    )
/*++

Routine Description:

    Map multi queue format to old style single queue format.

    Mapping algorithm:

      * If no elements in the MQF, no mapping.
      * If first element in the MQF can be mapped (e.g. not of type DL=), it is
        copied onto the specified buffer.
      * Otherwise, no mapping.


Arguments:

    nMqf          - Number of queue format elements in the MQF. May be 0.

    mqf           - Array of queue formats.

    ppQueueFormat - Pointer to pointer to old style single queue format.
                    On input, points to pointer to queue format buffer.
                    On output, if mapping succeeds, buffer contains  old style
                    queue format; if mapping fails, pointer to NULL
                    pointer.

Return Value:

    None.

--*/
{
    ASSERT(("Must have a valid pointer to pointer", ppQueueFormat  != NULL));
    ASSERT(("Must have a valid pointer", *ppQueueFormat != NULL));

    //
    // No elements in MQF, no mapping.
    //
    if (nMqf == 0)
    {
        *ppQueueFormat = NULL;
        return;
    }

    //
    // Map the first element in the MQF, if it's a single queue.
    //
    if (mqf[0].GetType() != QUEUE_FORMAT_TYPE_DL &&
        mqf[0].GetType() != QUEUE_FORMAT_TYPE_MULTICAST)
    {
        **ppQueueFormat = mqf[0];
        return;
    }

    //
    // No mapping
    //
    *ppQueueFormat = NULL;

} // MQpMqf2SingleQ


inline
bool
MQpNeedDestinationMqfHeader(
    const QUEUE_FORMAT        DestinationMqf[],
    ULONG                     nDestinationMqf
    )
/*++

Routine Description:

    Check if this packet needs to include MQF headers.

Arguments:

    DestinationMqf  - Array of destination queue formats.

    nDestinationMqf - Number of entries in array. Minimum is 1.

Return Value:

    true - need Destination MQF header.
    false - don't need Destination MQF header.

--*/
{
    ASSERT(nDestinationMqf >= 1);
    if (nDestinationMqf > 1)
    {
        //
        // Multiple destinations
        //
        return true;
    }

    if (DestinationMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Destination is a DL
        //
        return true;
    }

    return false;

} // MQpNeedDestinationMqfHeader


inline
bool
MQpNeedMqfHeaders(
    const QUEUE_FORMAT        DestinationMqf[],
    ULONG                     nDestinationMqf,
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    Check if this packet needs to include MQF headers.

Arguments:

    DestinationMqf  - Array of destination queue formats.

    nDestinationMqf - Number of entries in array. Minimum is 1.

    pSendParameters - Pointer to send parameters structure.

Return Value:

    true - MQF headers need to be included on this packet.
    false - MQF headers do not need to be included on this packet.

--*/
{
	if(MQpNeedDestinationMqfHeader(DestinationMqf, nDestinationMqf))
	{
		return true;
	}

    if (pSendParams->nAdminMqf > 1)
    {
        //
        // Multiple admin queues
        //
        return true;
    }

    if (pSendParams->nAdminMqf == 1 &&
        pSendParams->AdminMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Admin is a DL
        //
        return true;
    }

    if (pSendParams->nResponseMqf > 1)
    {
        //
        // Multiple Response queues
        //
        return true;
    }

    if (pSendParams->nResponseMqf == 1 &&
        pSendParams->ResponseMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Response is a DL
        //
        return true;
    }

    return false;

} // MQpNeedMqfHeaders


#endif //  __MQFUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqdbmgr.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
      mqdbmgr.h

Abstract:
   Define constants and API exported by mqdbmgr.dll.
   mqdbmgr.dll provides other QM modules with a simple interface to a
   relational database.

   For more information, see MQDBMGR.DOC in the Falcon documentation.

Author:
   Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#ifndef __MQDBMGR_H__
#define __MQDBMGR_H__

#include "mqsymbls.h"


//********************************************************************
//                       E R R O R / S T A T U S   C O D E S
//********************************************************************

#define  MQDB_OK  0

#define MQDB_E_BASE  (MQ_E_BASE + 0x0700)
#define MQDB_I_BASE  (MQ_I_BASE + 0x0700)

#define MQDB_E_UNKNOWN             (MQDB_E_BASE + 0x0000)    // Unidentified problem
#define MQDB_E_INVALID_CALL        (MQDB_E_BASE + 0x0001)    // Illegal call
#define MQDB_E_DB_NOT_FOUND        (MQDB_E_BASE + 0x0002)    // Can't find the database.
#define MQDB_E_BAD_CCOLUMNS        (MQDB_E_BASE + 0x0003)    // Invalid number of columns
#define MQDB_E_BAD_HDATABASE       (MQDB_E_BASE + 0x0004)    // Invalid database handle
#define MQDB_E_CANT_CREATE_TABLE   (MQDB_E_BASE + 0x0005)
#define MQDB_E_CANT_DELETE_TABLE   (MQDB_E_BASE + 0x0006)
#define MQDB_E_INVALID_TYPE        (MQDB_E_BASE + 0x0007)    // Invalid column type
#define MQDB_E_TABLE_NOT_FOUND     (MQDB_E_BASE + 0x0008)    // Can't find the table
#define MQDB_E_BAD_HTABLE          (MQDB_E_BASE + 0x0009)    // Invalid table handle
#define MQDB_E_CANT_CREATE_INDEX   (MQDB_E_BASE + 0x000A)
#define MQDB_E_INDEX_ALREADY_EXIST (MQDB_E_BASE + 0x000B)
#define MQDB_E_DATABASE            (MQDB_E_BASE + 0x000C)    // Database problems
#define MQDB_E_INVALID_DATA        (MQDB_E_BASE + 0x000D)    // Invalid data
#define MQDB_E_OUTOFMEMORY         (MQDB_E_BASE + 0x000E)    // Not enough memory
#define MQDB_E_TABLE_ALREADY_EXIST (MQDB_E_BASE + 0x000F)
#define MQDB_E_CANT_DELETE_INDEX   (MQDB_E_BASE + 0x0010)
#define MQDB_E_BAD_HQUERY          (MQDB_E_BASE + 0x0011)    // Invalid query handle
#define MQDB_E_NO_MORE_DATA        (MQDB_E_BASE + 0x0012)
#define MQDB_E_DLL_NOT_INIT        (MQDB_E_BASE + 0x0013)    // Dll not initialized yet
#define MQDB_E_CANT_INIT_JET       (MQDB_E_BASE + 0x0014)    // can't init Jet engine
#define MQDB_E_TABLE_FULL          (MQDB_E_BASE + 0x0015)    // Table full. Can't insert record.
#define MQDB_E_NON_UNIQUE_SORT     (MQDB_E_BASE + 0x0016)    // Happen on SQL server when ORDER BY clause get same column name more than once.
#define MQDB_E_NO_ROW_UPDATED      (MQDB_E_BASE + 0x0017)    // An update command didn't update any row.
#define MQDB_E_DBMS_NOT_AVAILABLE  (MQDB_E_BASE + 0x0018)    //
#define MQDB_E_UNSUPPORTED_DBMS    (MQDB_E_BASE + 0x0019)    // The database system is not supported (e.g., SQL6.5 SP2)
#define MQDB_E_DB_READ_ONLY        (MQDB_E_BASE + 0x001a)    // Database in read-only mode.
#define MQDB_E_BAD_SIZE_VALUE      (MQDB_E_BASE + 0x001b)    // Database size is wrong
#define MQDB_E_DEADLOCK            (MQDB_E_BASE + 0x001c)    // operation failed because of deadlock.

//********************************************************************
//          D A T A   T Y P E S
//********************************************************************

#define MQDB_VERSION_STRING_LEN  64

typedef struct _MQDBVERSION {
   DWORD dwMinor ;
   DWORD dwMajor ;
   DWORD dwProvider ;
   char  szDBMSName[ MQDB_VERSION_STRING_LEN ] ;
   char  szDBMSVer[ MQDB_VERSION_STRING_LEN ] ;
} MQDBVERSION, *LPMQDBVERSION ;

#define  MQDB_ODBC  1
#define  MQDB_DAO3  2

typedef LONG      MQDBSTATUS ;
typedef HANDLE    MQDBHANDLE ;
typedef HANDLE *  LPMQDBHANDLE ;

typedef struct _MQDBOPENDATABASE {
   IN LPSTR    lpszDatabaseName ;
   IN LPSTR    lpszDatabasePath ;
   IN LPSTR    lpszUserName ;
   IN LPSTR    lpszPassword ;
   IN BOOL     fCreate ;
   OUT MQDBHANDLE    hDatabase ;
} MQDBOPENDATABASE, *LPMQDBOPENDATABASE ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!
// Don't forget to update the relevant, database specific types, when
// updating COLUMNTYPE.
// for ODBC, update mqdbodbc.h, "dbODBCSQLTypes"

#define MQDB_NUMOF_TYPES   8

typedef enum _MQDBCOLUMNTYPE {
   MQDB_SHORT = 0,     // 16bit short integer
   MQDB_LONG,          // 32bit long integer
   MQDB_STRING,        // NULL terminated Ascii string
   MQDB_USTRING,       // NULL terminated Unicode string.
   MQDB_USTRING_UPPER, // NULL terminated Unicode string (see below)
   MQDB_FIXBINARY,     // Fixed length long binary field
   MQDB_VARBINARY,     // Variable length long binary field.
   MQDB_IDENTITY       // Long Identity column.
} MQDBCOLUMNTYPE ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!  See above

typedef struct _MQDBCOLUMNDEF{
   LPSTR             lpszColumnName ;
   MQDBCOLUMNTYPE    mqdbColumnType ;
   LONG              nColumnLength ;
   BOOL              fPrimaryKey ;
   BOOL              fUnique ;
} MQDBCOLUMNDEF ;

typedef struct _MQDBCOLUMNDEFEX{
   WORD              cbSize ;
   LPSTR             lpszColumnName ;
   MQDBCOLUMNTYPE    mqdbColumnType ;
   LONG              nColumnLength ;
   BOOL              fPrimaryKey ;
   BOOL              fUnique ;
   BOOL              fNull ;
} MQDBCOLUMNDEFEX ;

typedef struct _MQDBCOLUMNVAL {
   WORD            cbSize ;
   LPSTR           lpszColumnName ;
   LONG            nColumnValue ;
   LONG            nColumnLength ;
   MQDBCOLUMNTYPE  mqdbColumnType ;
   DWORD           dwReserve_A ;
} MQDBCOLUMNVAL, *LPMQDBCOLUMNVAL ;


// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!
// Don't forget to update the relevant, database specific op-string, when
// updating MQDBOP.
// for ODBC, update mqdbodbc.h, "dbODBCOpStrings"

#define MQDB_NUMOF_OPS  8

typedef enum _MQDBOP {
   EQ = 0, // Equal
   NE,     // Not Equal
   GE,     // Great than or Equal
   GT,     // Great than
   LE,     // Less than or Equal
   LT,     // Less than
   OR,     // Logical OR.
   AND     // Logical AND
} MQDBOP ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!  See above

// The MQDBCOLUMNSEARCH structure is used whenever a search is done in the
// database before an operation is performed. For example, in
// MQDBDeleteRecord, you first search for the proper record(s) and then
// delete it (them).  The search condition is met when:
//
//          mqdbColumnVal.lpszColumnName  mqdbOp mqdbColumnVal.nColumnValue
// Example:         "MsgID"                 EQ          6

typedef struct _MQDBCOLUMNSEARCH {
   MQDBCOLUMNVAL  mqdbColumnVal ;
   MQDBOP         mqdbOp ;
   BOOL           fPrepare ; // True if search value is to be prepared.
} MQDBCOLUMNSEARCH, *LPMQDBCOLUMNSEARCH ;

// The MQDBJOINOP defines the way a Join is performed.

typedef  struct _MQDBJOINOP {
   LPSTR    lpszLeftColumnName ;
   LPSTR    lpszRightColumnName ;
   MQDBOP   opJoin ;
   BOOL     fOuterJoin ;
} MQDBJOINOP, *LPMQDBJOINOP ;

// The MQDBSEARCHORDER structure is used to define order of records which
// are retrieved in a query.

#define MQDB_NUMOF_ORDER_OP  2

typedef enum _MQDBORDER {
   ASC = 0,
   DESC
} MQDBORDER ;

typedef struct _MQDBSEARCHORDER {
   LPSTR       lpszColumnName ;
   MQDBORDER   nOrder ;
} MQDBSEARCHORDER, *LPMQDBSEARCHORDER ;

typedef enum _MQDBTRANSACOP {
   AUTO,       // Make every call an isolated transaction.
   BEGIN,      // Begin a transaction.
   COMMIT,     // Commit a transaction.
   ROLLBACK,   // Roll back a transaction.
} MQDBTRANSACOP ;

//
//  enum which list all "set-able" options.
//
typedef enum _MQDBOPTION {
   MQDBOPT_MULTIPLE_QUERIES,
   MQDBOPT_INSERT_IDENTITY,
   MQDBOPT_NOLOCK_QUERIES,
   MQDBOPT_QUERY_TIMEOUT
} MQDBOPTION ;

//
// enum which list operation to be performed by calling MQDBExecute
//
typedef enum _MQDBEXEC {
   MQDBEXEC_UPDATE_STATISTICS,
   MQDBEXEC_SPACE_USED
} MQDBEXEC ;

//
// enum to list argregate function
//
typedef enum _MQDBAGGR {
    MQDBAGGR_MAX = 0,
    MQDBAGGR_MIN,
    MQDBAGGR_AVRG
} MQDBAGGR ;

//********************************************************************
//
//          A P I   P R O T O T Y P E S
//
//********************************************************************

MQDBSTATUS APIENTRY  MQDBGetVersion( IN MQDBHANDLE         hDatabase,
                                     IN OUT LPMQDBVERSION  pVersoin ) ;

MQDBSTATUS APIENTRY  MQDBInitialize() ;

MQDBSTATUS APIENTRY  MQDBTerminate() ;

MQDBSTATUS APIENTRY  MQDBOpenDatabase(
                     IN OUT  LPMQDBOPENDATABASE pDatabase) ;

MQDBSTATUS APIENTRY  MQDBCloseDatabase(
                     IN MQDBHANDLE  hDatabase) ;

MQDBSTATUS APIENTRY  MQDBCreateTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     IN MQDBCOLUMNDEF  aColumnDef[],
                     IN LONG           cColumns) ;

MQDBSTATUS APIENTRY  MQDBCreateTableEx(
                     IN MQDBHANDLE       hDatabase,
                     IN LPSTR            lpszTableName,
                     IN MQDBCOLUMNDEFEX  aColumnDefEx[],
                     IN LONG             cColumns) ;

MQDBSTATUS APIENTRY  MQDBDeleteTable(
                     IN MQDBHANDLE    hDatabase,
                     IN LPSTR         lpszTableName) ;

MQDBSTATUS APIENTRY  MQDBOpenTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     OUT LPMQDBHANDLE  phTable) ;

MQDBSTATUS APIENTRY  MQDBCloseTable(
                     IN MQDBHANDLE     hTable) ;

MQDBSTATUS APIENTRY  MQDBCreateIndex(
                     IN MQDBHANDLE  hTable,
                     IN LPSTR lpszIndexName,
                     IN LPSTR lpszColumnName[],
                     IN LONG  cColumns,
                     IN BOOL  fUnique,
                     IN BOOL  fClustered) ;

MQDBSTATUS APIENTRY  MQDBDeleteIndex(
                     IN MQDBHANDLE  hTable,
                     IN LPSTR       lpszIndexName,
                     IN BOOL        fUnique,
                     IN BOOL        fClustered) ;

MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBUpdateRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aUpdateColumnVal[],
                     IN LONG              cUpdateColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBUpdateRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aUpdateColumnVal[],
                     IN LONG              cUpdateColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBTruncateTable(
                     IN MQDBHANDLE        hTable ) ;

MQDBSTATUS APIENTRY  MQDBDeleteRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition) ;

MQDBSTATUS APIENTRY  MQDBDeleteRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere) ;

MQDBSTATUS APIENTRY  MQDBOpenQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBOpenQueryEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBOpenAggrQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBGetData(
                     IN MQDBHANDLE     hQuery,
                     IN MQDBCOLUMNVAL  aColumnVal[]) ;

MQDBSTATUS APIENTRY  MQDBCloseQuery(
                     IN MQDBHANDLE     hQuery) ;

MQDBSTATUS APIENTRY  MQDBOpenJoinQuery(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBTransaction(
                     IN  MQDBHANDLE     hDatabase,
                     IN  MQDBTRANSACOP  mqdbTransac) ;

MQDBSTATUS APIENTRY  MQDBFreeBuf( IN LPVOID  lpMem ) ;

MQDBSTATUS APIENTRY  MQDBSetOption(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBOPTION     mqdbOption,
                     IN DWORD          dwValue,
                     IN LPSTR          lpszValue,
                     IN MQDBHANDLE     hQuery = NULL ) ;

MQDBSTATUS APIENTRY  MQDBEscape(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszCommand ) ;

MQDBSTATUS APIENTRY  MQDBExecute(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBHANDLE     hTable,
                     IN MQDBEXEC       ExecOp,
                     IN OUT DWORD      *pdwValue,
                     IN LPSTR          lpszValue ) ;

///////////////////////////////////
//
//  Usefull Macros
//
///////////////////////////////////

#define INIT_COLUMNDEF(Col)            \
   Col.lpszColumnName = NULL ;         \
   Col.mqdbColumnType = MQDB_LONG ;    \
   Col.nColumnLength  = 0 ;            \
   Col.fPrimaryKey    = FALSE ;        \
   Col.fUnique        = FALSE ;

#define INIT_COLUMNDEFEX(Col)                         \
   Col.cbSize         = sizeof(MQDBCOLUMNDEFEX) ;     \
   Col.lpszColumnName = NULL ;                        \
   Col.mqdbColumnType = MQDB_LONG ;                   \
   Col.nColumnLength  = 0 ;                           \
   Col.fPrimaryKey    = FALSE ;                       \
   Col.fUnique        = FALSE ;                       \
   Col.fNull          = TRUE ;

#define INIT_COLUMNVAL(Col)                        \
   Col.cbSize         = sizeof(MQDBCOLUMNVAL) ;    \
   Col.lpszColumnName = NULL ;                     \
   Col.nColumnValue   = 0 ;                        \
   Col.nColumnLength  = 0 ;                        \
   Col.mqdbColumnType = MQDB_LONG ;                \
   Col.dwReserve_A    = 0

#define INIT_COLUMNSEARCH(Col)            \
   INIT_COLUMNVAL(Col.mqdbColumnVal) ;    \
   Col.mqdbOp = EQ ;                      \
   Col.fPrepare = FALSE ;

#define SET_COLUMN_NAME(Col, name)     \
   Col.lpszColumnName = name ;

#define SET_COLUMN_VALUE(Col, Val)     \
   Col.nColumnValue = (LONG) (Val) ;

#endif // __MQDBMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqkeyhlp.h ===
/*++

Copyright (c) 1996-98 Microsoft Corporation

Module Name:
    mqkeyhlp.h

Abstract:
    Helper functions that exist in MQKEYHLP.DLL.
    These functions are being called directrly by Falcon and are used
    for server authentication.

Author:
    Boaz Feldbaum (BoazF)   16-Oct-1996
    Doron Juster  (DoronJ)  20-May-1998, adapt to MSMQ2.0

Revision History:

--*/

#ifndef _MQKEYHLP_H_
#define _MQKEYHLP_H_

//+--------------------------------
//
// Server side functions.
//
//+--------------------------------

//
// This function retrieve the MSQM server certificate from the service
// "My" store and initialize the server credentials handle. This is the
// first step for initializing server authentication over schannel.
//
HRESULT  MQsspi_InitServerAuthntication() ;

HRESULT
ServerAcceptSecCtx( BOOL    fFisrt,
                    LPVOID *pvhServerContext,
                    LPBYTE  pbServerBuffer,
                    DWORD  *pdwServerBufferSize,
                    LPBYTE  pbClientBuffer,
                    DWORD   dwClientBufferSize );

//+--------------------------------
//
// Client side functions.
//
//+--------------------------------


HRESULT
GetSizes(
    DWORD *pcbMaxToken,
    LPVOID pvhContext =NULL,
    DWORD *pcbHeader =NULL,
    DWORD *pcbTrailer =NULL,
    DWORD *pcbMaximumMessage =NULL,
    DWORD *pcBuffers =NULL,
    DWORD *pcbBlockSize =NULL
    );

void
FreeContextHandle(
    LPVOID pvhContextHandle
    );

HRESULT
MQSealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize);

#endif // _MQKEYHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqformat.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqformat.h

Abstract:
    Convert a QUEUE_FORMAT struc to FORMAT_NAME string

Author:
    Boaz Feldbaum (BoazF) 5-Mar-1996

Revision History:
    Erez Haba (erezh) 12-Mar-1996
    Erez Haba (erezh) 17-Jan-1997

--*/

#ifndef __MQFORMAT_H
#define __MQFORMAT_H

#include <wchar.h>
#include <qformat.h>
#include <fntoken.h>

#if !defined(NTSTATUS) && !defined(_NTDEF_)
#define NTSTATUS HRESULT
#endif


inline
ULONG
MQpPublicToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_PUBLIC);

    const GUID* pg = &pqf->PublicID();

    _snwprintf(
        pfn,
        buff_size,
        FN_PUBLIC_TOKEN // "PUBLIC"
        FN_EQUAL_SIGN   // "="
        GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );
    
    //
    //  return format name buffer length *not* including suffix length
    //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_PUBLIC_TOKEN_LEN + 1 +
        GUID_STR_LENGTH +  1
        );
} // MQpPublicToFormatName


inline
ULONG
MQpDlToFormatName(
    const QUEUE_FORMAT* pqf,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DL);

    const DL_ID id = pqf->DlID();
    const GUID * pguid = &id.m_DlGuid;

    if (id.m_pwzDomain != NULL)
    {
        _snwprintf(
            pfn,
            buff_size,
            FN_DL_TOKEN         // "DL"
            FN_EQUAL_SIGN       // "="
            GUID_FORMAT         // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_AT_SIGN          // "@"
            FN_DOMAIN_FORMAT,   // "%s"
            GUID_ELEMENTS(pguid),
            id.m_pwzDomain
            );

        //
        //  return format name buffer length
        //  "DL=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@DomainName\0"
        //
        return static_cast<ULONG>(
            FN_DL_TOKEN_LEN + 1 +
            GUID_STR_LENGTH + 1 +
            wcslen(id.m_pwzDomain) + 1
            );
    }

    _snwprintf(
        pfn,
        buff_size,
        FN_DL_TOKEN         // "DL"
        FN_EQUAL_SIGN       // "="
        GUID_FORMAT,        // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(pguid)
        );
    
    //
    //  return format name buffer length
    //  "DL=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_DL_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpDlToFormatName


inline
ULONG
MQpPrivateToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);

    const GUID* pg = &pqf->PrivateID().Lineage;

    _snwprintf(
        pfn,
        buff_size,
        FN_PRIVATE_TOKEN        // "PRIVATE"
        FN_EQUAL_SIGN           // "="
        GUID_FORMAT             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_PRIVATE_SEPERATOR    // "\\"
        FN_PRIVATE_ID_FORMAT       // "xxxxxxxx"
        FN_SUFFIX_FORMAT,          // "%s"
        GUID_ELEMENTS(pg),
        pqf->PrivateID().Uniquifier,
        pSuffix
        );
    
    //
    //  return format name buffer length *not* including suffix length
    //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
    //
    return (
        FN_PRIVATE_TOKEN_LEN + 1 + 
        GUID_STR_LENGTH + 1 + 8 + 1
        );
} // MQpPrivateToFormatName


inline
ULONG
MQpDirectToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    _snwprintf(
        pfn,
        buff_size,
        FN_DIRECT_TOKEN     // "DIRECT"
            FN_EQUAL_SIGN   // "="
            L"%s"           // "OS:bla-bla"
            FN_SUFFIX_FORMAT,  // "%s"
        pqf->DirectID(),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "DIRECT=OS:bla-bla\0"
    //
    return static_cast<ULONG>(
        FN_DIRECT_TOKEN_LEN + 1 +
        wcslen(pqf->DirectID()) + 1
        );
} // MQpDirectToFormatName


inline
ULONG
MQpMachineToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_MACHINE);

    const GUID* pg = &pqf->MachineID();
    _snwprintf(
        pfn,
        buff_size,
        FN_MACHINE_TOKEN    // "MACHINE"
            FN_EQUAL_SIGN   // "="
            GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_MACHINE_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpMachineToFormatName


inline
ULONG
MQpConnectorToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);

    const GUID* pg = &pqf->ConnectorID();
    _snwprintf(
        pfn,
        buff_size,
        FN_CONNECTOR_TOKEN  // "CONNECTOR"
            FN_EQUAL_SIGN   // "="
            GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_CONNECTOR_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpConnectorToFormatName


inline
VOID
MQpMulticastIdToString(
    const MULTICAST_ID& id,
    LPWSTR pBuffer,
	DWORD BufferSize
    )
/*++

Routine Description:

    Serialize MULTICAST_ID struct into a string.
    We cannot call inet_addr in this module since it compiles in kernel mode.

Arguments:

    id - Reference to MULTICAST_ID struct.

    pBuffer - Points to buffer to hold string. Buffer size must be at least MAX_PATH wchars.

Returned Value:

    None.

--*/
{
    DWORD nChars = _snwprintf(
									pBuffer, 
									BufferSize - 1,
									L"%d.%d.%d.%d:%d", 
									(id.m_address & 0x000000FF),
									(id.m_address & 0x0000FF00) >> 8, 
									(id.m_address & 0x00FF0000) >> 16,
									(id.m_address & 0xFF000000) >> 24,
									id.m_port
									);

	pBuffer[BufferSize - 1] = L'\0';

	ASSERT(nChars > 0);
	DBG_USED(nChars);
} // MQpMulticastIdToString


inline 
VOID
MQpStringToMulticastId(
	LPCWSTR str,
	DWORD dwStrLen,
	MULTICAST_ID& id
	)
{
	DWORD d1, d2, d3, d4;
	DWORD port;

	int n = _snwscanf(str,dwStrLen, L"%d.%d.%d.%d:%d", &d1, &d2, &d3, &d4, &port);
	ASSERT(("Illegal multicast address", n == 5));
	ASSERT(("Illegal multicast address", (d1 < 256) && (d2 < 256) && (d3 < 256) && (d4 < 256)));
	UNREFERENCED_PARAMETER(n);

	id.m_port = port;
	id.m_address = d1 | (d2 << 8) | (d3 << 16) | (d4 << 24);
}


inline
ULONG
MQpMulticastToFormatName(
    const QUEUE_FORMAT* pqf,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_MULTICAST);

    WCHAR buffer[260];
    MQpMulticastIdToString(pqf->MulticastID(), buffer, TABLE_SIZE(buffer));

    _snwprintf(
        pfn,
        buff_size,
        FN_MULTICAST_TOKEN  // "MULTICAST"
        FN_EQUAL_SIGN       // "="
        L"%s",              // "%s"
        buffer
        );
    
    //
    //  return format name buffer length
    //  "MULTICAST=a.b.c.d:p\0"
    //
    return static_cast<ULONG>(
        FN_MULTICAST_TOKEN_LEN + 1 +
        wcslen(buffer) + 1
        );
} // MQpMulticastToFormatName


//
// Convert a QUEUE_FORMAT union to a format name string.
//
inline
NTSTATUS
MQpQueueFormatToFormatName(
    const QUEUE_FORMAT* pqf,    // queue format to translate
    LPWSTR pfn,                 // lpwcsFormatName format name buffer
    ULONG buff_size,            // format name buffer size
    PULONG pulFormatNameLength, // required buffer lenght of format name
    bool fSerializeMqfSeperator // serialize an MQF seperator on the buffer
    )
{
	if(static_cast<long>(buff_size * 2) < 0)
		return MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;

    //
    //  Sanity check
    //
    ASSERT(pqf->IsValid());

    const LPCWSTR suffixes[] = {
        FN_NONE_SUFFIX,
        FN_JOURNAL_SUFFIX,
        FN_DEADLETTER_SUFFIX,
        FN_DEADXACT_SUFFIX,
        FN_XACTONLY_SUFFIX,
    };

    const ULONG suffixes_len[] = {
        FN_NONE_SUFFIX_LEN,
        FN_JOURNAL_SUFFIX_LEN,
        FN_DEADLETTER_SUFFIX_LEN,
        FN_DEADXACT_SUFFIX_LEN,
        FN_XACTONLY_SUFFIX_LEN,
    };


    ULONG fn_size = suffixes_len[pqf->Suffix()];
    LPCWSTR pSuffix = suffixes[pqf->Suffix()];
    if (fSerializeMqfSeperator)
    {
        //
        // MQF element should not have suffix.
        //
        ASSERT(pqf->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        //
        // Set the MQF separator as suffix
        //
        fn_size = STRLEN(FN_MQF_SEPARATOR);
        pSuffix = FN_MQF_SEPARATOR;
    }


    switch(pqf->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            fn_size += MQpPublicToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_DL:
            fn_size += MQpDlToFormatName(pqf, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            fn_size += MQpPrivateToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            fn_size += MQpDirectToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            ASSERT(("This type cannot be an MQF element", !fSerializeMqfSeperator));
            fn_size += MQpMachineToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            ASSERT(("This type cannot be an MQF element", !fSerializeMqfSeperator));
            fn_size += MQpConnectorToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            ASSERT(pqf->Suffix() == QUEUE_SUFFIX_TYPE_NONE);
            fn_size += MQpMulticastToFormatName(pqf, buff_size, pfn);
            break;

        default:
            //
            //  ASSERT(0) with no level 4 warning
            //
            ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    }

    *pulFormatNameLength = fn_size;
    if(buff_size < fn_size)
    {
        //
        //  put a null terminator, and indicate buffer too small
        //
        if(buff_size > 0)
        {
            pfn[buff_size - 1] = 0;
        }
        return MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;
    }

    return MQ_OK;
}

#endif //  __MQFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqlog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mqlog.h

Abstract:

    Functions definitions for error logging in all bits (release, checked, debug).

Author:

    AlexDad   18-July-99  Created

--*/

#ifndef __MQLOG_H
#define __MQLOG_H

#define NTSTATUS HRESULT
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

//
// Error logging functions
//
extern void LogMsgHR(        HRESULT hr,        LPWSTR wszFileName, USHORT point);
extern void LogMsgNTStatus(  NTSTATUS status,   LPWSTR wszFileName, USHORT point);
extern void LogMsgRPCStatus( RPC_STATUS status, LPWSTR wszFileName, USHORT point);
extern void LogMsgBOOL(      BOOL b,            LPWSTR wszFileName, USHORT point);
extern void LogIllegalPoint(                       LPWSTR wszFileName, USHORT point);

// Following inline functions are optimized to take minimum space - there is a lot of calls 
inline HRESULT LogHR(HRESULT hr, PWCHAR pwszFileName, USHORT usPoint)
{
    if (FAILED(hr))
    {
        LogMsgHR(hr, pwszFileName, usPoint);
    }
    return hr;
}

inline NTSTATUS LogNTStatus(NTSTATUS status, PWCHAR pwszFileName, USHORT usPoint)
{
    if (status != STATUS_SUCCESS)
    {
        LogMsgNTStatus(status, pwszFileName, usPoint);
    }
    return status;
}

inline RPC_STATUS LogRPCStatus(RPC_STATUS status, PWCHAR pwszFileName, USHORT usPoint)
{
    if (status != RPC_S_OK)
    {
        LogMsgRPCStatus(status, pwszFileName, usPoint);
    }
    return status;
}

inline BOOL LogBOOL(BOOL b, PWCHAR pwszFileName, USHORT usPoint)
{
    if (!b)
    {
        LogMsgBOOL(b, pwszFileName, usPoint);
    }
    return b;
}

#endif  // __MQLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqnames.h ===
//
//  All components should refer to other only by the names below
//
#ifdef _TOOL
#define MQ1REPL_DLL_NAME  	TEXT("mq1repl.dll")
#define MQADS_DLL_NAME    	TEXT("tmqads.dll")
#define MQAD_DLL_NAME    	TEXT("tmqad.dll")
#define MQCERTUI_DLL_NAME 	TEXT("mqcertui.dll")
#define MQCLUS_DLL_NAME   	TEXT("mqclus.dll")
#define MQDBODBC_DLL_NAME 	TEXT("mqdbodbc.dll")
#define MQDSCLI_DLL_NAME  	TEXT("tmqdscli.dll")
#define MQDSSRV_DLL_NAME  	TEXT("tmqdssrv.dll")
#define MQMIGRAT_DLL_NAME 	TEXT("mqmigrat.dll")
#define MQOA_DLL_NAME     	TEXT("mqoa.dll")
#define MQPERF_DLL_NAME   	TEXT("mqperf.dll")
#define MQQM_DLL_NAME     	TEXT("tmqqm.dll")
#define MQRPERF_DLL_NAME   	TEXT("mqrperf.dll")
#define MQRT_DLL_NAME   	TEXT("mqrt.dll")
#define MQSEC_DLL_NAME  	TEXT("tmqsec.dll")
#define MQSNAP_DLL_NAME   	TEXT("mqsnap.dll")
#define MQUPGRD_DLL_NAME   	TEXT("mqupgrd.dll")
#define MQUTIL_DLL_NAME   	TEXT("tmqutil.dll")

#else

#define MQ1REPL_DLL_NAME  	TEXT("mq1repl.dll")
#define MQAD_DLL_NAME    	TEXT("mqad.dll")
#define MQADS_DLL_NAME    	TEXT("mqads.dll")
#define MQCERTUI_DLL_NAME 	TEXT("mqcertui.dll")
#define MQCLUS_DLL_NAME   	TEXT("mqclus.dll")
#define MQDBODBC_DLL_NAME 	TEXT("mqdbodbc.dll")
#define MQDSCLI_DLL_NAME  	TEXT("mqdscli.dll")
#define MQDSSRV_DLL_NAME  	TEXT("mqdssrv.dll")
#define MQMIGRAT_DLL_NAME 	TEXT("mqmigrat.dll")
#define MQOA_DLL_NAME     	TEXT("mqoa.dll")
#define MQPERF_DLL_NAME   	TEXT("mqperf.dll")
#define MQQM_DLL_NAME     	TEXT("mqqm.dll")
#define MQRPERF_DLL_NAME   	TEXT("mqrperf.dll")
#define MQRT_DLL_NAME   	TEXT("mqrt.dll")
#define MQSEC_DLL_NAME   	TEXT("mqsec.dll")
#define MQSNAP_DLL_NAME   	TEXT("mqsnap.dll")
#define MQUPGRD_DLL_NAME   	TEXT("mqupgrd.dll")
#define MQUTIL_DLL_NAME   	TEXT("mqutil.dll")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqsocket.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mqsocket.h

Abstract:

    Falcon specific definition for use with winsock.

Author:

    Doron Juster  (DoronJ)  20-Mar-1997

--*/

#ifndef __MQSOCKET_H
#define __MQSOCKET_H

#define MQSOCK_MAX_COMPUTERNAME_LENGTH   256

#endif // __MQSOCKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqprfsym.h ===
//
//  mqctrnm.h
//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 i.e.
//  even numbers. In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values for the device they belong to,
//  in order to determine the absolute location of the counter and
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the
//  counter name and Explain text definition file .INI file that is used
//  by LODCTR to load the names into the registry.
//

#define QMOBJ                   0
#define NUMSESSIONS             2
#define NUMIPSESSIONS           4
//#define NUMIPXSESSIONS          6      Entry was removed for msmq 3.0
#define NUM_OUTGOING_HTTP_SESSIONS	6
#define NUM_INCOMING_PGM_SESSIONS	8
#define NUM_OUTGOING_PGM_SESSIONS	10

#define NUMINQMPACKETS          12
#define TOTALINQMPACKETS       14
#define NUMOUTQMPACKETS        16
#define TOTALOUTQMPACKETS      18
#define TOTALPACKETSINQUEUES   20
#define TOTALBYTESINQUEUES     22


#define SESSIONOBJ             24
#define NUMSESSINPACKETS       26
#define NUMSESSOUTPACKETS      28
#define NUMSESSINBYTES         30
#define NUMSESSOUTBYTES        32
#define TOTALSESSINPACKETS     34
#define TOTALSESSINBYTES       36
#define TOTALSESSOUTPACKETS    38
#define TOTALSESSOUTBYTES      40

#define QUEUEOBJ               42
#define TOTALQUEUEINPACKETS    44
#define TOTALQUEUEINBYTES      46
#define TOTALJOURNALINPACKETS  48
#define TOTALJOURNALINBYTES    50

#define DSOBJ                       52
#define NUMOFSYNCREQUESTS           54
#define NUMOFSYNCREPLIES            56
#define NUMOFREPLREQRECV            58
#define NUMOFREPLREQSENT            60
#define NUMOFACCESSTOSRVR           62
#define NUMOFWRITEREQSENT           64
#define NUMOFERRRETURNEDTOAPP       66

#define IN_HTTP_OBJ					68
#define IN_HTTP_NUMSESSINPACKETS    70
#define IN_HTTP_NUMSESSINBYTES      72
#define IN_HTTP_TOTALSESSINPACKETS  74
#define IN_HTTP_TOTALSESSINBYTES    76

#define OUT_HTTP_SESSION_OBJ		78
#define OUT_HTTP_NUMSESSOUTPACKETS	80
#define OUT_HTTP_NUMSESSOUTBYTES	82
#define OUT_HTTP_TOTALSESSOUTPACKETS 84
#define OUT_HTTP_TOTALSESSOUTBYTES   86

#define OUT_PGM_SESSION_OBJ			88
#define OUT_PGM_NUMSESSOUTPACKETS	90
#define OUT_PGM_NUMSESSOUTBYTES		92
#define OUT_PGM_TOTALSESSOUTPACKETS 94
#define OUT_PGM_TOTALSESSOUTBYTES   96

#define IN_PGM_SESSION_OBJ			98
#define IN_PGM_NUMSESSINPACKETS     100
#define IN_PGM_NUMSESSINBYTES       102
#define IN_PGM_TOTALSESSINPACKETS   104
#define IN_PGM_TOTALSESSINBYTES     106
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqperf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqperf.h

Abstract:

    Some common definitions used by the performance monitoring code. The
    definitions here are used both by the code that generates the performance
    data (e.g., QM), and the code that shows the data (e.g., Explorer).

Author:

    Boaz Feldbaum (BoazF)  June 30, 1996

--*/

#ifndef _MQPERF_H_
#define _MQPERF_H_

#define PERF_QUEUE_OBJECT   TEXT("MSMQ Queue")
#define PERF_SESSION_OBJECT TEXT("MSMQ Session")
#define PERF_QM_OBJECT      TEXT("MSMQ Service")
#define PERF_DS_OBJECT      TEXT("MSMQ IS")

#define PERF_OUT_HTTP_SESSION_OBJECT	L"MSMQ Outgoing HTTP Session"
#define PERF_IN_HTTP_OBJECT				L"MSMQ Incoming HTTP Messages"
#define PERF_OUT_PGM_SESSION_OBJECT		L"MSMQ Outgoing Multicast Session"
#define PERF_IN_PGM_SESSION_OBJECT		L"MSMQ Incoming Multicast Session"
// the following structures will be used to map the counter arrays returned by AddInstance

//
// QM General Counters
//
typedef struct _QmCounters
{
    ULONG   nSessions;
    ULONG   nIPSessions;
	ULONG   nOutHttpSessions;
	ULONG   nInPgmSessions;
	ULONG   nOutPgmSessions;


    ULONG   nInPackets;     // Total Incoming packets
    ULONG   tInPackets;

    ULONG   nOutPackets;    // Total Outgoing packets
    ULONG   tOutPackets;

    ULONG   nTotalPacketsInQueues;
    ULONG   nTotalBytesInQueues;
} QmCounters ;

//
// Counters per active sessions
//
typedef struct
{
    ULONG   nInPackets;
    ULONG   nOutPackets;
    ULONG   nInBytes;
    ULONG   nOutBytes;

    ULONG   tInPackets;
    ULONG   tOutPackets;
    ULONG   tInBytes;
    ULONG   tOutBytes;

} SessionCounters;


//
// Counters per active sessions
//
class COutSessionCounters
{
public:
    ULONG   nOutPackets;
    ULONG   nOutBytes;

    ULONG   tOutPackets;
    ULONG   tOutBytes;
};

//
// Counters per active sessions
//
class CInSessionCounters
{
public:
    ULONG   nInPackets;
    ULONG   nInBytes;

    ULONG   tInPackets;
    ULONG   tInBytes;
};
//
// Counters per queue
//
typedef struct
{
    ULONG   nInPackets;
    ULONG   nInBytes;
} QueueCounters;



//
// Counters for MQIS
//

typedef struct
{
    ULONG nSyncRequests;
    ULONG nSyncReplies;
    ULONG nReplReqReceived;
    ULONG nReplReqSent;
    ULONG nAccessServer;
    ULONG nWriteReqSent;
    ULONG nErrorsReturnedToApp;
} DSCounters;

#ifdef _MQIS_BLD
    extern __declspec(dllexport) DSCounters *g_pdsCounters;
#else
    extern __declspec(dllimport) DSCounters *g_pdsCounters;
#endif

#endif // _MQPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqreport.h ===
/////////////////////////////////////////////////////////////////
//
//
//              File : report.h
//
//
/////////////////////////////////////////////////////////////////

#ifndef _REPORT_H_
#define _REPORT_H_

#include <cs.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)


//
// constants
//

#define EVENTLOGID          DWORD

//
//  Constants for categories in event log
//

#define  EVENTLOG_MAX_CATEGORIES   2


#ifdef _MQUTIL
#define DLL_IMPORT_EXPORT DLL_EXPORT
#else
#define DLL_IMPORT_EXPORT DLL_IMPORT
#endif

//
// Structure for compact keeping of error history
//
struct ErrorHistoryCell
{
    DWORD m_tid;			// thread ID
    LONG m_status;			// may be HR, RPCStatus, NTStatus, BOOL
    DWORD m_usPoint;		// Unique-per-file log point number 
    LPCWSTR m_pFileName;	// program file name
};

#define ERROR_HISTORY_SIZE 64


///////////////////////////////////////////////////////////////////////////
//
// class COutputReport
//
// Description : a class for outputing debug messages and event-log messages
//
///////////////////////////////////////////////////////////////////////////

class DLL_IMPORT_EXPORT COutputReport
{
    public:

        // constructor / destructor
        COutputReport (void);

        void KeepErrorHistory(
                           LPCWSTR wszFileName, 
                           USHORT usPoint, 
                           LONG status) ;

        
    private:

        //
        // Variables for logging
        //
        CCriticalSection m_LogCS ;
            
        DWORD        m_dwCurErrorHistoryIndex;      // index of the next error history cell to used
        char         m_HistorySignature[8];           // holds "MSMQERR" for lookup in dump
        
        //
        // Log history - for debugging & post-mortem
        //
        ErrorHistoryCell  m_ErrorHistory[ERROR_HISTORY_SIZE]; // array to be sought in debugging      
};

extern DLL_IMPORT_EXPORT COutputReport Report;

/**************************************************************************/
//
// Macro definitions
//
//   The following macros describe the interface of the programmer with the
//   COutputReport class.
//
/**************************************************************************/

#define KEEP_ERROR_HISTORY(data)   Report.KeepErrorHistory data

//
// REPORT macros - Used for reporting to the event-log
//

#endif  // of _REPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqprops.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqprops.h

Abstract:

    Falcon Properties

--*/

#ifndef __MQPROPS_H
#define __MQPROPS_H

#include <mqdsdef.h>

// begin_mq_h


//********************************************************************
//  API FLAGS
//********************************************************************

//
//  MQOpenQueue - Access values
//
#define MQ_RECEIVE_ACCESS       0x00000001
#define MQ_SEND_ACCESS          0x00000002
#define MQ_PEEK_ACCESS          0x00000020
#define MQ_ADMIN_ACCESS         0x00000080

//
//  MQOpenQueue - Share values
//
#define MQ_DENY_NONE            0x00000000
#define MQ_DENY_RECEIVE_SHARE   0x00000001

//
//  MQReceiveMessage - Action values
//
#define MQ_ACTION_RECEIVE       0x00000000
// end_mq_h
#define MQ_ACTION_PEEK_MASK     0x80000000  // indicate a peek operation
// begin_mq_h
#define MQ_ACTION_PEEK_CURRENT  0x80000000
#define MQ_ACTION_PEEK_NEXT     0x80000001

//
//  MQReceiveMessageByLookupId - Action values
//
#if(_WIN32_WINNT >= 0x0501)
// end_mq_h
#define MQ_LOOKUP_MASK            0x40000000
#define MQ_LOOKUP_PEEK_MASK       0x40000010
#define MQ_LOOKUP_RECEIVE_MASK    0x40000020
// begin_mq_h
#define MQ_LOOKUP_PEEK_CURRENT    0x40000010
#define MQ_LOOKUP_PEEK_NEXT       0x40000011
#define MQ_LOOKUP_PEEK_PREV       0x40000012
#define MQ_LOOKUP_PEEK_FIRST      0x40000014
#define MQ_LOOKUP_PEEK_LAST       0x40000018

#define MQ_LOOKUP_RECEIVE_CURRENT 0x40000020
#define MQ_LOOKUP_RECEIVE_NEXT    0x40000021
#define MQ_LOOKUP_RECEIVE_PREV    0x40000022
#define MQ_LOOKUP_RECEIVE_FIRST   0x40000024
#define MQ_LOOKUP_RECEIVE_LAST    0x40000028
#endif
// end_mq_h



#define PRIVATE_QUEUE_PATH_INDICATIOR L"PRIVATE$\\"
#define PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(PRIVATE_QUEUE_PATH_INDICATIOR)

#define SYSTEM_QUEUE_PATH_INDICATIOR L"SYSTEM$"
#define SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(SYSTEM_QUEUE_PATH_INDICATIOR)

#define PN_DELIMITER_C      L'\\'
#define PN_LOCAL_MACHINE_C  L'.'

#define ORDER_QUEUE_PRIVATE_INDEX      4
// begin_mq_h

//
// MQSendMessage,  MQReceiveMessage:  special cases for the transaction parameter
//
#define MQ_NO_TRANSACTION             NULL
#define MQ_MTS_TRANSACTION            (ITransaction *)1
#define MQ_XA_TRANSACTION             (ITransaction *)2
#define MQ_SINGLE_MESSAGE             (ITransaction *)3


//********************************************************************
//  PRIORITY LIMITS
//********************************************************************

//
//  Message priorities
//
#define MQ_MIN_PRIORITY          0    // Minimal message priority
#define MQ_MAX_PRIORITY          7    // Maximal message priority


//********************************************************************
//  MESSAGE PROPERTIES
//********************************************************************
#define PROPID_M_BASE					 0
#define PROPID_M_CLASS                   (PROPID_M_BASE + 1)     /* VT_UI2           */
#define PROPID_M_MSGID                   (PROPID_M_BASE + 2)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_CORRELATIONID           (PROPID_M_BASE + 3)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_PRIORITY                (PROPID_M_BASE + 4)     /* VT_UI1           */
#define PROPID_M_DELIVERY                (PROPID_M_BASE + 5)     /* VT_UI1           */
#define PROPID_M_ACKNOWLEDGE             (PROPID_M_BASE + 6)     /* VT_UI1           */
#define PROPID_M_JOURNAL                 (PROPID_M_BASE + 7)     /* VT_UI1           */
#define PROPID_M_APPSPECIFIC             (PROPID_M_BASE + 8)     /* VT_UI4           */
#define PROPID_M_BODY                    (PROPID_M_BASE + 9)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_BODY_SIZE               (PROPID_M_BASE + 10)    /* VT_UI4           */
#define PROPID_M_LABEL                   (PROPID_M_BASE + 11)    /* VT_LPWSTR        */
#define PROPID_M_LABEL_LEN               (PROPID_M_BASE + 12)    /* VT_UI4           */
#define PROPID_M_TIME_TO_REACH_QUEUE     (PROPID_M_BASE + 13)    /* VT_UI4           */
#define PROPID_M_TIME_TO_BE_RECEIVED     (PROPID_M_BASE + 14)    /* VT_UI4           */
#define PROPID_M_RESP_QUEUE              (PROPID_M_BASE + 15)    /* VT_LPWSTR        */
#define PROPID_M_RESP_QUEUE_LEN          (PROPID_M_BASE + 16)    /* VT_UI4           */
#define PROPID_M_ADMIN_QUEUE             (PROPID_M_BASE + 17)    /* VT_LPWSTR        */
#define PROPID_M_ADMIN_QUEUE_LEN         (PROPID_M_BASE + 18)    /* VT_UI4           */
#define PROPID_M_VERSION                 (PROPID_M_BASE + 19)    /* VT_UI4           */
#define PROPID_M_SENDERID                (PROPID_M_BASE + 20)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDERID_LEN            (PROPID_M_BASE + 21)    /* VT_UI4           */
#define PROPID_M_SENDERID_TYPE           (PROPID_M_BASE + 22)    /* VT_UI4           */
#define PROPID_M_PRIV_LEVEL              (PROPID_M_BASE + 23)    /* VT_UI4           */
#define PROPID_M_AUTH_LEVEL              (PROPID_M_BASE + 24)    /* VT_UI4           */
#define PROPID_M_AUTHENTICATED           (PROPID_M_BASE + 25)    /* VT_UI1           */
#define PROPID_M_HASH_ALG                (PROPID_M_BASE + 26)    /* VT_UI4           */
#define PROPID_M_ENCRYPTION_ALG          (PROPID_M_BASE + 27)    /* VT_UI4           */
#define PROPID_M_SENDER_CERT             (PROPID_M_BASE + 28)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDER_CERT_LEN         (PROPID_M_BASE + 29)    /* VT_UI4           */
#define PROPID_M_SRC_MACHINE_ID          (PROPID_M_BASE + 30)    /* VT_CLSID         */
#define PROPID_M_SENTTIME                (PROPID_M_BASE + 31)    /* VT_UI4           */
#define PROPID_M_ARRIVEDTIME             (PROPID_M_BASE + 32)    /* VT_UI4           */
#define PROPID_M_DEST_QUEUE              (PROPID_M_BASE + 33)    /* VT_LPWSTR        */
#define PROPID_M_DEST_QUEUE_LEN          (PROPID_M_BASE + 34)    /* VT_UI4           */
#define PROPID_M_EXTENSION               (PROPID_M_BASE + 35)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_EXTENSION_LEN           (PROPID_M_BASE + 36)    /* VT_UI4           */
#define PROPID_M_SECURITY_CONTEXT        (PROPID_M_BASE + 37)    /* VT_UI4           */
#define PROPID_M_CONNECTOR_TYPE          (PROPID_M_BASE + 38)    /* VT_CLSID         */
#define PROPID_M_XACT_STATUS_QUEUE       (PROPID_M_BASE + 39)    /* VT_LPWSTR        */
#define PROPID_M_XACT_STATUS_QUEUE_LEN   (PROPID_M_BASE + 40)    /* VT_UI4           */
#define PROPID_M_TRACE                   (PROPID_M_BASE + 41)    /* VT_UI1           */
#define PROPID_M_BODY_TYPE               (PROPID_M_BASE + 42)    /* VT_UI4           */
#define PROPID_M_DEST_SYMM_KEY           (PROPID_M_BASE + 43)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_DEST_SYMM_KEY_LEN       (PROPID_M_BASE + 44)    /* VT_UI4           */
#define PROPID_M_SIGNATURE               (PROPID_M_BASE + 45)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SIGNATURE_LEN           (PROPID_M_BASE + 46)    /* VT_UI4           */
#define PROPID_M_PROV_TYPE               (PROPID_M_BASE + 47)    /* VT_UI4           */
#define PROPID_M_PROV_NAME               (PROPID_M_BASE + 48)    /* VT_LPWSTR        */
#define PROPID_M_PROV_NAME_LEN           (PROPID_M_BASE + 49)    /* VT_UI4           */
#define PROPID_M_FIRST_IN_XACT           (PROPID_M_BASE + 50)    /* VT_UI1           */
#define PROPID_M_LAST_IN_XACT            (PROPID_M_BASE + 51)    /* VT_UI1           */
#define PROPID_M_XACTID                  (PROPID_M_BASE + 52)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_AUTHENTICATED_EX        (PROPID_M_BASE + 53)    /* VT_UI1           */
#if(_WIN32_WINNT >= 0x0501)
#define PROPID_M_RESP_FORMAT_NAME        (PROPID_M_BASE + 54)    /* VT_LPWSTR        */
#define PROPID_M_RESP_FORMAT_NAME_LEN    (PROPID_M_BASE + 55)    /* VT_UI4           */
// end_mq_h

//
//Place holder for future properties. (PROPID_M_BASE + 56) and (PROPID_M_BASE + 57)
//

// begin_mq_h
#define PROPID_M_DEST_FORMAT_NAME        (PROPID_M_BASE + 58)    /* VT_LPWSTR        */
#define PROPID_M_DEST_FORMAT_NAME_LEN    (PROPID_M_BASE + 59)    /* VT_UI4           */
#define PROPID_M_LOOKUPID                (PROPID_M_BASE + 60)    /* VT_UI8           */
#define PROPID_M_SOAP_ENVELOPE			 (PROPID_M_BASE + 61)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_ENVELOPE_LEN		 (PROPID_M_BASE + 62)    /* VT_UI4           */
#define PROPID_M_COMPOUND_MESSAGE		 (PROPID_M_BASE + 63)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_COMPOUND_MESSAGE_SIZE	 (PROPID_M_BASE + 64)    /* VT_UI4           */
#define PROPID_M_SOAP_HEADER             (PROPID_M_BASE + 65)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_BODY               (PROPID_M_BASE + 66)    /* VT_LPWSTR        */
#endif
// end_mq_h


#if PROPID_M_BASE != 0
#error PROPID_M_BASE != 0
#endif

#define LAST_M_PROPID      PROPID_M_SOAP_BODY
// begin_mq_h

//
// Message Property Size
//
#define PROPID_M_MSGID_SIZE         20
#define PROPID_M_CORRELATIONID_SIZE 20
#define PROPID_M_XACTID_SIZE        20


//********************************************************************
//  MESSAGE CLASS VALUES
//********************************************************************
//
//  Message class values are 16 bits laid out as follows:
//
//   1 1 1 1 1 1
//   5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-------+-----------------+
//  |S|R|H|Reserve|   Class code    |
//  +-+-+-+-------+-----------------+
//
//  where
//
//      S - is the severity flag
//          0 - Normal Message/Positive Acknowledgment (ACK)
//          1 - Negative Acknowledgment (NACK)
//
//      R - is the receive flag
//          0 - Arrival ACK/NACK
//          1 - Receive ACK/NACK
//
//      H - is http flag
//          0 - no http
//          1 - http 

#define MQCLASS_CODE(s, r, code) ((USHORT)(((s) << 15) | ((r) << 14) | (code)))
#define MQCLASS_NACK(c)     ((c) & 0x8000)
#define MQCLASS_RECEIVE(c)  ((c) & 0x4000)

#define MQCLASS_NACK_HTTP(c) (((c) & 0xA000) == 0xA000)


// end_mq_h
#define MQCLASS_POS_ARRIVAL(c)  (((c) & 0xC000) == 0x0000)
#define MQCLASS_POS_RECEIVE(c)  (((c) & 0xC000) == 0x4000)
#define MQCLASS_NEG_ARRIVAL(c)  (((c) & 0xC000) == 0x8000)
#define MQCLASS_NEG_RECEIVE(c)  (((c) & 0xC000) == 0xC000)

#define CREATE_MQHTTP_CODE(HttpStatusCode) (0xA000 | (HttpStatusCode))


#define MQCLASS_IS_VALID(c) (!(((UINT_PTR)(c)) & ~((UINT_PTR)0xE1FF)))
// begin_mq_h

//
//  Normal message
//
#define MQMSG_CLASS_NORMAL                      MQCLASS_CODE(0, 0, 0x00)

//
//  Report message
//
#define MQMSG_CLASS_REPORT                      MQCLASS_CODE(0, 0, 0x01)

//
//  Arrival acknowledgment. The message has reached its destination queue
//
#define MQMSG_CLASS_ACK_REACH_QUEUE             MQCLASS_CODE(0, 0, 0x02)
// end_mq_h

//
//  Order acknoledgment used internally by falcon
//  BUGBUG: we can remove it and use MQMSG_CLASS_ACK_REACH_QUEUE instade (erezh)
//
#define MQMSG_CLASS_ORDER_ACK                   MQCLASS_CODE(0, 0, 0xff)
// begin_mq_h

//
//  Receive acknowledgment. The message has been received by an application
//
#define MQMSG_CLASS_ACK_RECEIVE                 MQCLASS_CODE(0, 1, 0x00)


//-----------------------------------------------
//
//  Negative arrival acknowledgments
//

//
//  Destination queue cannot be reached, the queue may have been deleted
//
#define MQMSG_CLASS_NACK_BAD_DST_Q              MQCLASS_CODE(1, 0, 0x00)

//
//  The message was purged before reaching its destination queue
//
#define MQMSG_CLASS_NACK_PURGED                 MQCLASS_CODE(1, 0, 0x01)

//
//  Time to reach queue has expired
//
#define MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT    MQCLASS_CODE(1, 0, 0x02)

//
//  The message has exceeded the queue quota
//
#define MQMSG_CLASS_NACK_Q_EXCEED_QUOTA         MQCLASS_CODE(1, 0, 0x03)

//
//  The sender does not have send access rights to the queue.
//
#define MQMSG_CLASS_NACK_ACCESS_DENIED          MQCLASS_CODE(1, 0, 0x04)

//
//  The message hop count was exceeded
//
#define MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED     MQCLASS_CODE(1, 0, 0x05)

//
//  The message signature is bad. The message could not be authenticated.
//
#define MQMSG_CLASS_NACK_BAD_SIGNATURE          MQCLASS_CODE(1, 0, 0x06)

//
//  The message could not be decrypted.
//
#define MQMSG_CLASS_NACK_BAD_ENCRYPTION         MQCLASS_CODE(1, 0, 0x07)

//
//  The message could not be encrypted for the destination.
//
#define MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT      MQCLASS_CODE(1, 0, 0x08)

//
//  The message was sent to a non-transactional queue within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q    MQCLASS_CODE(1, 0, 0x09)

//
//  The message was sent to a transactional queue not within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG  MQCLASS_CODE(1, 0, 0x0A)

//
//  The requested crypto provider for encryption is not supported by the destination.
//
#define MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER  MQCLASS_CODE(1, 0, 0x0B)

//
// The QM GUID has changed and therefore the messages was thrown away.
//
#define MQMSG_CLASS_NACK_SOURCE_COMPUTER_GUID_CHANGED MQCLASS_CODE(1, 0, 0x0C)


//-----------------------------------------------
//
//  Negative receive acknowledgments
//

//
//  The queue was deleted, after the message arrived
//
#define MQMSG_CLASS_NACK_Q_DELETED              MQCLASS_CODE(1, 1, 0x00)

//
//  The message was purged at the destination queue
//
#define MQMSG_CLASS_NACK_Q_PURGED               MQCLASS_CODE(1, 1, 0x01)

//
//  Time to receive has expired while the message was still in its destination queue
//  (generated by destination)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT        MQCLASS_CODE(1, 1, 0x02)

//
//  Time to receive has expired while the message was still in its local outgoing queue
//  (generated locally by sender)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER  MQCLASS_CODE(1, 1, 0x03)


//------ PROPID_M_ACKNOWLEDGE ---------------
#define MQMSG_ACKNOWLEDGMENT_NONE           0x00

#define MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL    0x01
#define MQMSG_ACKNOWLEDGMENT_POS_RECEIVE    0x02
#define MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL    0x04
#define MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE    0x08
// end_mq_h
#define MQMSG_ACKNOWLEDGMENT_IS_VALID(a)   (!(((UINT_PTR)(a)) & ~((UINT_PTR)0x0F)))
// begin_mq_h

#define MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE ))

#define MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE |  \
            MQMSG_ACKNOWLEDGMENT_POS_RECEIVE ))
// end_mq_h
#define MQCLASS_MATCH_ACKNOWLEDGMENT(c, a) ( \
            (((a) & MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL) && MQCLASS_POS_ARRIVAL(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_POS_RECEIVE) && MQCLASS_POS_RECEIVE(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL) && MQCLASS_NEG_ARRIVAL(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE) && MQCLASS_NEG_RECEIVE(c)) )
// begin_mq_h

//------ PROPID_M_DELIVERY ------------------
#define MQMSG_DELIVERY_EXPRESS              0
#define MQMSG_DELIVERY_RECOVERABLE          1

//----- PROPID_M_JOURNAL --------------------
#define MQMSG_JOURNAL_NONE                  0
#define MQMSG_DEADLETTER                    1
#define MQMSG_JOURNAL                       2

//----- PROPID_M_TRACE ----------------------
#define MQMSG_TRACE_NONE                    0
#define MQMSG_SEND_ROUTE_TO_REPORT_QUEUE    1

//----- PROPID_M_SENDERID_TYPE --------------
#define MQMSG_SENDERID_TYPE_NONE            0
#define MQMSG_SENDERID_TYPE_SID             1
// end_mq_h
#define MQMSG_SENDERID_TYPE_QM              2
// begin_mq_h

//----- PROPID_M_PRIV_LEVEL -----------------
#define MQMSG_PRIV_LEVEL_NONE               0
#define MQMSG_PRIV_LEVEL_BODY_BASE          0x01
#define MQMSG_PRIV_LEVEL_BODY_ENHANCED      0x03

//----- PROPID_M_AUTH_LEVEL -----------------
#define MQMSG_AUTH_LEVEL_NONE				0
#define MQMSG_AUTH_LEVEL_ALWAYS				1

//
// MQMSG_AUTH_LEVEL_MSMQxx are obsolete 
// you should use MQMSG_AUTH_LEVEL_SIGxx
//
#define MQMSG_AUTH_LEVEL_MSMQ10				2
#define MQMSG_AUTH_LEVEL_MSMQ20				4

#define MQMSG_AUTH_LEVEL_SIG10 				2
#define MQMSG_AUTH_LEVEL_SIG20 				4
#define MQMSG_AUTH_LEVEL_SIG30 				8

// end_mq_h

//
// bits 0-3 in use for MSMQ signatures
//
#define AUTH_LEVEL_MASK						((ULONG)0x0000000f)
#define IS_VALID_AUTH_LEVEL(level)			(((level) & ~AUTH_LEVEL_MASK) == 0)

//
// bits 16-31 for new signatures (http signatures)
// 
#define MQMSG_AUTH_LEVEL_XMLDSIG_V1			0x10000

// begin_mq_h

//----- PROPID_M_AUTHENTICATED -----------------
//----- PROPID_M_AUTHENTICATED_EX --------------
#define MQMSG_AUTHENTICATION_NOT_REQUESTED  0
#define MQMSG_AUTHENTICATION_REQUESTED      1

//
// MQMSG_AUTHENTICATION_REQUESTED_EX is obsolete 
// use the values MQMSG_AUTHENTICATED_SIGxx
// for PROPID_M_AUTHENTICATED_EX
//
#define MQMSG_AUTHENTICATION_REQUESTED_EX   3

#define MQMSG_AUTHENTICATED_SIG10			1
#define MQMSG_AUTHENTICATED_SIG20			3
#define MQMSG_AUTHENTICATED_SIG30			5
#define MQMSG_AUTHENTICATED_SIGXML			9


//----- PROPID_M_FIRST_IN_XACT --------------
#define MQMSG_NOT_FIRST_IN_XACT             0
#define MQMSG_FIRST_IN_XACT                 1

//----- PROPID_M_LAST_IN_XACT  --------------
#define MQMSG_NOT_LAST_IN_XACT              0
#define MQMSG_LAST_IN_XACT                  1

// end_mq_h

//------------- Default Values --------------
#define DEFAULT_M_PRIORITY                  ((MQ_MAX_PRIORITY + MQ_MIN_PRIORITY) >> 1)
#define DEFAULT_M_DELIVERY                  MQMSG_DELIVERY_EXPRESS
#define DEFAULT_M_ACKNOWLEDGE               MQMSG_ACKNOWLEDGMENT_NONE
#define DEFAULT_M_JOURNAL                   MQMSG_JOURNAL_NONE
#define DEFAULT_M_APPSPECIFIC               0
#define DEFAULT_M_PRIV_LEVEL                MQMSG_PRIV_LEVEL_NONE
#define DEFAULT_M_AUTH_LEVEL                MQMSG_AUTH_LEVEL_NONE
#define DEFAULT_M_SENDERID_TYPE             MQMSG_SENDERID_TYPE_SID

#define PPROPID_Q_BASE (PRIVATE_PROPID_BASE + PROPID_Q_BASE)

// begin_mq_h


//********************************************************************
//  QUEUE PROPERTIES
//********************************************************************
#define PROPID_Q_BASE           100
#define PROPID_Q_INSTANCE       (PROPID_Q_BASE +  1)  /* VT_CLSID     */
#define PROPID_Q_TYPE           (PROPID_Q_BASE +  2)  /* VT_CLSID     */
#define PROPID_Q_PATHNAME       (PROPID_Q_BASE +  3)  /* VT_LPWSTR    */
#define PROPID_Q_JOURNAL        (PROPID_Q_BASE +  4)  /* VT_UI1       */
#define PROPID_Q_QUOTA          (PROPID_Q_BASE +  5)  /* VT_UI4       */
#define PROPID_Q_BASEPRIORITY   (PROPID_Q_BASE +  6)  /* VT_I2        */
#define PROPID_Q_JOURNAL_QUOTA  (PROPID_Q_BASE +  7)  /* VT_UI4       */
#define PROPID_Q_LABEL          (PROPID_Q_BASE +  8)  /* VT_LPWSTR    */
#define PROPID_Q_CREATE_TIME    (PROPID_Q_BASE +  9)  /* VT_I4        */
#define PROPID_Q_MODIFY_TIME    (PROPID_Q_BASE + 10)  /* VT_I4        */
#define PROPID_Q_AUTHENTICATE   (PROPID_Q_BASE + 11)  /* VT_UI1       */
#define PROPID_Q_PRIV_LEVEL     (PROPID_Q_BASE + 12)  /* VT_UI4       */
#define PROPID_Q_TRANSACTION    (PROPID_Q_BASE + 13)  /* VT_UI1       */
// end_mq_h
#define PROPID_Q_SCOPE         (PROPID_Q_BASE + 14)   /* VT_UI1       */
#define PROPID_Q_QMID          (PROPID_Q_BASE + 15)   /* VT_CLSID     */
#define PROPID_Q_MASTERID      (PROPID_Q_BASE + 16)   /* VT_CLSID     */
#define PROPID_Q_SEQNUM        (PROPID_Q_BASE + 17)   /* VT_BLOB      */
#define PROPID_Q_HASHKEY       (PROPID_Q_BASE + 18)   /* VT_UI4       */
#define PROPID_Q_LABEL_HASHKEY (PROPID_Q_BASE + 19)   /* VT_UI4       */
#define PROPID_Q_NT4ID         (PROPID_Q_BASE + 20)   /* VT_CLSID     */
//
// Q_NT4ID is the guid of the queue on NT4 (MSMQ1.0). This is used
// for migration, to create a queue with predefined objectGUID.
//
#define PROPID_Q_FULL_PATH     (PROPID_Q_BASE + 21)   /* VT_LPWSTR    */
#define PROPID_Q_DONOTHING     (PROPID_Q_BASE + 22)   /* VT_UI1       */
//
// Q_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// creation time or SeqNum. The PropId of these ones are changed to
// Q_DONOTHING before calling DSCreateObject or DSSetProps.
//
#define PROPID_Q_NAME_SUFFIX   (PROPID_Q_BASE + 23)   /* VT_LPWSTR    */
//
//  used only if queue name > cn
//

// begin_mq_h
#define PROPID_Q_PATHNAME_DNS  (PROPID_Q_BASE + 24)  /* VT_LPWSTR    */
#define PROPID_Q_MULTICAST_ADDRESS (PROPID_Q_BASE + 25)  /* VT_LPWSTR */
#define PROPID_Q_ADS_PATH      (PROPID_Q_BASE + 26)  /* VT_LPWSTR    */
// end_mq_h
#define PROPID_Q_SECURITY      (PPROPID_Q_BASE + 1)   /* VT_BLOB      */
//
//  PROPID_Q_SECURITY returns the security in NT4 format. In set or create
//  operation it can be in NT4 or NT5 format.
//
#define PROPID_Q_OBJ_SECURITY  (PPROPID_Q_BASE + 2)   /* VT_BLOB      */
//
//  PROPID_Q_OBJ_SECURTIY can be use to retrieve the security in
//  NT5 format.
//
#define PROPID_Q_SECURITY_INFORMATION  (PPROPID_Q_BASE + 3)   /* VT_UI4  */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//
#define PROPID_Q_DEFAULT_SECURITY      (PPROPID_Q_BASE + 4)   /* VT_UI4  */
//
//  see mqdssrv\dsapi.cpp, DSCreateObjectInternal for explanations about
//  PROPID_Q_DEFAULT_SECURITY.
//

#define LAST_Q_PROPID      PROPID_Q_ADS_PATH
// begin_mq_h


//----- PROPID_Q_JOURNAL ------------------
#define MQ_JOURNAL_NONE     (unsigned char)0
#define MQ_JOURNAL          (unsigned char)1

//----- PROPID_Q_TYPE ------------------
//  {55EE8F32-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_REPORT {0x55ee8f32, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//  {55EE8F33-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_TEST   {0x55ee8f33, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//----- PROPID_Q_TRANSACTION ------------------
#define MQ_TRANSACTIONAL_NONE     (unsigned char)0
#define MQ_TRANSACTIONAL          (unsigned char)1

//----- PROPID_Q_AUTHENTICATE ------------------
#define MQ_AUTHENTICATE_NONE      (unsigned char)0
#define MQ_AUTHENTICATE           (unsigned char)1

//----- PROPID_Q_PRIV_LEVEL ------------------
#define MQ_PRIV_LEVEL_NONE        (unsigned long)0
#define MQ_PRIV_LEVEL_OPTIONAL    (unsigned long)1
#define MQ_PRIV_LEVEL_BODY        (unsigned long)2
// end_mq_h


//----- PROPID_Q_SCOPE ------------------
#define SITE_SCOPE          (unsigned char)0
#define ENTERPRISE_SCOPE    (unsigned char)1


//------------- Default Values ----------
#define DEFAULT_Q_JOURNAL       MQ_JOURNAL_NONE
#define DEFAULT_Q_BASEPRIORITY  0

//
// Default for system private queues (order, mqis, admin)
//
#define DEFAULT_SYS_Q_BASEPRIORITY  0x7fff

#define DEFAULT_Q_QUOTA         0xFFFFFFFF
#define DEFAULT_Q_JOURNAL_QUOTA 0xFFFFFFFF
#define DEFAULT_Q_SCOPE         ENTERPRISE_SCOPE
#define DEFAULT_Q_TRANSACTION   MQ_TRANSACTIONAL_NONE
#define DEFAULT_Q_AUTHENTICATE  MQ_AUTHENTICATE_NONE
#define DEFAULT_Q_PRIV_LEVEL    MQ_PRIV_LEVEL_OPTIONAL

//
// Properties of objects can be public properties or private properties.
// Public properties of objects can be set and modified using the DS API
// Private properties of objects can be only set internally by the SD.
// In order to distinguish between private and public properties we set the
// value of the ID number of public properties to be less than 1000. Private
// properties has values higher than 1000. The hunderts number of each
// property should be equal to the value of the property identifier. This way
// we can easily associate a property ID with the object.
//
#define PRIVATE_PROPID_BASE 1000
#define PROPID_OBJ_GRANULARITY 100
#define PROPID_TO_OBJTYPE(pid) ((((pid) > PRIVATE_PROPID_BASE) ? ((pid) - PRIVATE_PROPID_BASE) : (pid)) / PROPID_OBJ_GRANULARITY)
#define IS_PRIVATE_PROPID(pid) ((pid) > PRIVATE_PROPID_BASE)

#if (PROPID_Q_BASE != (MQDS_QUEUE * PROPID_OBJ_GRANULARITY))
#error "PROPID_Q_BASE != (MQDS_QUEUE * PROPID_OBJ_GRANULARITY)"
#endif


// begin_mq_h


//********************************************************************
//  MACHINE PROPERTIES
//********************************************************************
#define PROPID_QM_BASE 200

// end_mq_h
#define PPROPID_QM_BASE (PRIVATE_PROPID_BASE + PROPID_QM_BASE)

#if (PROPID_QM_BASE != (MQDS_MACHINE * PROPID_OBJ_GRANULARITY))
#error "PROPID_QM_BASE != (MQDS_MACHINE * PROPID_OBJ_GRANULARITY)"
#endif
//
//  PROPID_QM_SITE_ID is a obsolete property ( replaced by PROPID_QM_SITE_IDS)
//  NOTE: when used in create machine, will also create computer object if there isn't one
//  =====
//
// begin_mq_h
#define PROPID_QM_SITE_ID                   (PROPID_QM_BASE +  1) /* VT_CLSID            */
#define PROPID_QM_MACHINE_ID                (PROPID_QM_BASE +  2) /* VT_CLSID            */
#define PROPID_QM_PATHNAME                  (PROPID_QM_BASE +  3) /* VT_LPWSTR           */
#define PROPID_QM_CONNECTION                (PROPID_QM_BASE +  4) /* VT_LPWSTR|VT_VECTOR */
#define PROPID_QM_ENCRYPTION_PK             (PROPID_QM_BASE +  5) /* VT_UI1|VT_VECTOR	 */
// end_mq_h
#define PROPID_QM_ADDRESS                   (PROPID_QM_BASE +  6) /* VT_BLOB             */
#define PROPID_QM_CNS                       (PROPID_QM_BASE +  7) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_OUTFRS                    (PROPID_QM_BASE +  8) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_INFRS                     (PROPID_QM_BASE +  9) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_SERVICE                   (PROPID_QM_BASE + 10) /* VT_UI4              */
#define PROPID_QM_MASTERID                  (PROPID_QM_BASE + 11) /* VT_CLSID            */
#define PROPID_QM_HASHKEY                   (PROPID_QM_BASE + 12) /* VT_UI4              */
#define PROPID_QM_SEQNUM                    (PROPID_QM_BASE + 13) /* VT_BLOB             */
#define PROPID_QM_QUOTA                     (PROPID_QM_BASE + 14) /* VT_UI4              */
#define PROPID_QM_JOURNAL_QUOTA             (PROPID_QM_BASE + 15) /* VT_UI4              */
#define PROPID_QM_MACHINE_TYPE              (PROPID_QM_BASE + 16) /* VT_LPWSTR           */
#define PROPID_QM_CREATE_TIME               (PROPID_QM_BASE + 17) /* VT_I4               */
#define PROPID_QM_MODIFY_TIME               (PROPID_QM_BASE + 18) /* VT_I4               */
#define PROPID_QM_FOREIGN                   (PROPID_QM_BASE + 19) /* VT_UI1              */
#define PROPID_QM_OS                        (PROPID_QM_BASE + 20) /* VT_UI4              */
#define PROPID_QM_FULL_PATH                 (PROPID_QM_BASE + 21) /* VT_LPWSTR           */
#define PROPID_QM_SITE_IDS                  (PROPID_QM_BASE + 22) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_OUTFRS_DN                 (PROPID_QM_BASE + 23) /* VT_LPWSTR|VT_VECTOR */
#define PROPID_QM_INFRS_DN                  (PROPID_QM_BASE + 24) /* VT_LPWSTR|VT_VECTOR */

#define PROPID_QM_NT4ID                     (PROPID_QM_BASE + 25) /* VT_CLSID            */
//
// QM_NT4ID is the guid of the QM on NT4 (MSMQ1.0). This is used
// for migration, to create a QM with predefined objectGUID.
//
#define PROPID_QM_DONOTHING                 (PROPID_QM_BASE + 26) /* VT_UI1              */
//
// QM_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// creation time or SeqNum. The PropId of these ones are changed to
// QM_DONOTHING before calling DSCreateObject or DSSetProps.
//

#define PROPID_QM_SERVICE_ROUTING           (PROPID_QM_BASE + 27) /* VT_UI1             */
#define PROPID_QM_SERVICE_DSSERVER          (PROPID_QM_BASE + 28) /* VT_UI1             */
#define PROPID_QM_SERVICE_DEPCLIENTS        (PROPID_QM_BASE + 29) /* VT_UI1             */
#define PROPID_QM_OLDSERVICE                (PROPID_QM_BASE + 30) /* VT_UI4             */
// begin_mq_h
#define PROPID_QM_ENCRYPTION_PK_BASE        (PROPID_QM_BASE + 31)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_ENCRYPTION_PK_ENHANCED    (PROPID_QM_BASE + 32)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_PATHNAME_DNS              (PROPID_QM_BASE + 33)  /* VT_LPWSTR         */
// end_mq_h

#define PROPID_QM_OBJ_SECURITY        (PROPID_QM_BASE + 34) /* VT_BLOB           */
//
//  PROPID_QM_SECURITY returns the security in NT4 format. In set or create
//  operation it can be in NT4 or NT5 format.
//
//  PROPID_QM_OBJ_SECURTIY can be use to retrieve the security in
//  NT5 format.
//
#define PROPID_QM_MIG_GC_NAME         (PROPID_QM_BASE + 35) /* VT_LPWSTR         */
//
//  PROPID_QM_MIG_GC_NAME is the name of a GC controller in another domain.
//  This GC will create migrated objects with predefined GUIDs.
//
#define PROPID_QM_MIG_PROVIDER        (PROPID_QM_BASE + 36) /* VT_UL4            */
//
//  PROPID_QM_MIG_PROVIDER is used to save ldap queries when running
//  migration tool and replication service. See ds\mqdscore\dsmigrat.cpp
//
#define PROPID_QM_SECURITY_INFORMATION (PROPID_QM_BASE +37)  /* VT_UI4         */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//
#define PROPID_QM_ENCRYPT_PKS         (PROPID_QM_BASE + 38) /* VT_BLOB           */
#define PROPID_QM_SIGN_PKS            (PROPID_QM_BASE + 39) /* VT_BLOB           */
//
//  PROPID_QM_ENCRYPT_PKS is used to handle the new msmq2.0 format of
//  public keys: structure that pack multiple keys for multiple providers.
//  Use same DS attribute as  PROPID_QM_ENCRYPT_PK.
//  Similar for PROPID_QM_SIGN_PKS
//
#define PROPID_QM_WORKGROUP_ID        (PROPID_QM_BASE + 40) /* VT_BLOB           */
//
//  PROPID_QM_WORKGROUP_ID is the GUID of QM in workgroup mode. It's used
//  when the machine join domain and we create the msmqConfiguration object
//  with same guid.
//
#define PROPID_QM_OWNER_SID           (PROPID_QM_BASE + 41) /* VT_BLOB           */
//
//  PROPID_QM_OWNER_SID is the sid of the user that run setup. It is passed
//  from the msmq service that create the msmqConfiguration object so the
//  server add it with full control to DACL of the newly created object.
//
#define PROPID_QM_GROUP_IN_CLUSTER    (PROPID_QM_BASE + 42) /* VT_UI1            */
//
// PROPID_QM_GROUP_IN_CLUSTER tells the server that this is a msmq on group,
// in a cluster, so default security of msmqConfiguration object must allow
// everyone to create queues.
//
#define PROPID_QM_DESCRIPTION         (PROPID_QM_BASE + 43) /* VT_LPWSTR           */
//
// PROPID_QM_DESCRIPTION is used only for address replication: we change it and
// the change will be replicated to GC. Then replication service sends
// replication message with the new properties, including new machine address
//

#define PROPID_QM_SECURITY      (PPROPID_QM_BASE + 1) /* VT_BLOB             */
#define PROPID_QM_SIGN_PK       (PPROPID_QM_BASE + 2) /* VT_BLOB             */
#define PROPID_QM_ENCRYPT_PK    (PPROPID_QM_BASE + 3) /* VT_BLOB             */

#define PROPID_QM_UPGRADE_DACL  (PPROPID_QM_BASE + 4) /* VT_UI1              */
//
// PROPID_QM_UPGRADE_DACL is a dummy propid, to ask PEC to upgrade Dacl of
// calling machine.
//

#define LAST_QM_PROPID    PROPID_QM_PATHNAME_DNS

/*
 *
    Flags definition of PROPID_QM_FOREIGN
 *
 */
#define FOREIGN_MACHINE         1
#define MSMQ_MACHINE            0

//------------- Default Values ----------

#define DEFAULT_QM_QUOTA         0x00800000
#define DEFAULT_QM_JOURNAL_QUOTA 0xFFFFFFFF
#define DEFAULT_QM_FOREIGN       MSMQ_MACHINE

/*
 *
[T] - Basic VARTYPE value of this property.
[R] - Property value may be referenced (VT_BYREF).
[N] - Property value can be retrieved without specifying basic VARTYPE
      (assigning VT_NULL instead), Falcon will assign the property
      type and will allocated memory if required.
 *
 */

/*
 *
    Old flags definition of PROPID_QM_SERVICE - we keep them for migration [adsrv]
 *
 */

#define SERVICE_NONE     ((ULONG) 0x00000000)
#define SERVICE_SRV      ((ULONG) 0x00000001)
#define SERVICE_BSC      ((ULONG) 0x00000002)
#define SERVICE_PSC      ((ULONG) 0x00000004)
#define SERVICE_PEC      ((ULONG) 0x00000008)
#define SERVICE_RCS      ((ULONG) 0x00000010)

//------------- Default Values ----------
#define DEFAULT_N_SERVICE   FALSE   // [adsrv] SERVICE_NONE

#define MSMQ_GROUP_NOT_IN_CLUSTER   0
#define MSMQ_GROUP_IN_CLUSTER       1

/*
 *
    Flags definition of PROPID_QM_OS
 *
 */
#define MSMQ_OS_NONE     ((ULONG) 0x00000000)
#define MSMQ_OS_FOREIGN  ((ULONG) 0x00000100)
#define MSMQ_OS_95       ((ULONG) 0x00000200)
#define MSMQ_OS_NTW      ((ULONG) 0x00000300)
#define MSMQ_OS_NTS      ((ULONG) 0x00000400)
#define MSMQ_OS_NTE      ((ULONG) 0x00000500)

//------------- Default Values ----------
#define DEFAULT_QM_OS   MSMQ_OS_NONE

//********************************************************************
//  SITE PROPERTIES
//********************************************************************
#define PROPID_S_BASE MQDS_SITE * PROPID_OBJ_GRANULARITY
#define PPROPID_S_BASE (PRIVATE_PROPID_BASE + PROPID_S_BASE)
/*                                                    [T]                [R] [N]*/
/*                                                  ----------------------------*/
#define PROPID_S_PATHNAME     (PROPID_S_BASE + 1)  /* VT_LPWSTR           -   + */
#define PROPID_S_SITEID       (PROPID_S_BASE + 2)  /* VT_CLSID            -   + */
#define PROPID_S_GATES        (PROPID_S_BASE + 3)  /* VT_CLSID|VT_VECTOR  -   + */
#define PROPID_S_PSC          (PROPID_S_BASE + 4)  /* VT_LPWSTR           -   + */
#define PROPID_S_INTERVAL1    (PROPID_S_BASE + 5)  /* VT_UI2              -   + */
#define PROPID_S_INTERVAL2    (PROPID_S_BASE + 6)  /* VT_UI2              -   + */
#define PROPID_S_MASTERID     (PROPID_S_BASE + 7)  /* VT_CLSID            -   + */
#define PROPID_S_SEQNUM       (PROPID_S_BASE + 8)  /* VT_BLOB             -   + */
#define PROPID_S_FULL_NAME    (PROPID_S_BASE + 9)  /* VT_LPWSTR                 */
#define PROPID_S_NT4_STUB     (PROPID_S_BASE + 10) /* VT_UI2                    */
#define PROPID_S_FOREIGN      (PROPID_S_BASE + 11) /* VT_UI1                    */

#define PROPID_S_DONOTHING    (PROPID_S_BASE + 12) /* VT_UI1                    */
//
// S_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// site gate or SeqNum. The PropId of these ones are changed to
// S_DONOTHING before calling DSCreateObject or DSSetProps.
//

#define PROPID_S_SECURITY     (PPROPID_S_BASE + 1) /* VT_BLOB                   */
#define PROPID_S_PSC_SIGNPK   (PPROPID_S_BASE + 2) /* VT_BLOB                   */
#define PROPID_S_SECURITY_INFORMATION  (PPROPID_S_BASE + 3)   /* VT_UI4         */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//

//
// PROPID_S_NT4_STUB is set to 1 by the migration tool to indicate that
// this site was created by the migration tool and it has the objectGuid
// of the original site in MSMQ1.0 MQIS database.
//


//------------- Default Values ----------
#define DEFAULT_S_INTERVAL1     2  /* sec */
#define DEFAULT_S_INTERVAL2     10 /* sec */

//********************************************************************
//  DELETED OBJECT PROPERTIES
//********************************************************************
#define PROPID_D_BASE MQDS_DELETEDOBJECT * PROPID_OBJ_GRANULARITY
#define PPROPID_D_BASE (PRIVATE_PROPID_BASE + PROPID_D_BASE)
/*                                                   [T]          [R] [N]    */
/*                                                   ----------------------  */
#define PROPID_D_SEQNUM       (PPROPID_D_BASE + 1) /* VT_BLOB                */
#define PROPID_D_MASTERID     (PPROPID_D_BASE + 2) /* VT_CLSID               */
#define PROPID_D_SCOPE        (PPROPID_D_BASE + 3) /* VT_UI1       -   +     */
#define PROPID_D_OBJTYPE      (PPROPID_D_BASE + 4) /* VT_UI1       _   +     */
#define PROPID_D_IDENTIFIER   (PPROPID_D_BASE + 5) /* VT_CLSID     -   +     */
#define PROPID_D_TIME         (PPROPID_D_BASE + 6) /* VT_I4        -   +     */


//********************************************************************
//  CNS PROPERTIES
//********************************************************************
#define PROPID_CN_BASE MQDS_CN * PROPID_OBJ_GRANULARITY
#define PPROPID_CN_BASE (PRIVATE_PROPID_BASE + PROPID_CN_BASE)
/*                                                     [T]        [R] [N]    */
/*                                                     --------------------  */
#define PROPID_CN_PROTOCOLID  (PROPID_CN_BASE + 1)  /* VT_UI1      -   +     */
#define PROPID_CN_NAME        (PROPID_CN_BASE + 2)  /* VT_LPWSTR             */
#define PROPID_CN_GUID        (PROPID_CN_BASE + 3)  /* VT_CLSID              */
#define PROPID_CN_MASTERID    (PROPID_CN_BASE + 4)  /* VT_CLSID    -   +     */
#define PROPID_CN_SEQNUM      (PROPID_CN_BASE + 5)  /* VT_BLOB               */
#define PROPID_CN_SECURITY    (PPROPID_CN_BASE + 1) /* VT_BLOB               */

//********************************************************************
//  ENTERPRISE PROPERTIES
//********************************************************************
#define PROPID_E_BASE MQDS_ENTERPRISE * PROPID_OBJ_GRANULARITY
#define PPROPID_E_BASE (PRIVATE_PROPID_BASE + PROPID_E_BASE)
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_E_NAME            (PROPID_E_BASE + 1)        /* VT_LPWSTR    */
#define PROPID_E_NAMESTYLE       (PROPID_E_BASE + 2)        /* VT_UI1       */
#define PROPID_E_CSP_NAME        (PROPID_E_BASE + 3)        /* VT_LPWSTR    */
#define PROPID_E_PECNAME         (PROPID_E_BASE + 4)        /* VT_LPWSTR    */
#define PROPID_E_S_INTERVAL1     (PROPID_E_BASE + 5)        /* VT_UI2       */
#define PROPID_E_S_INTERVAL2     (PROPID_E_BASE + 6)        /* VT_UI2       */
#define PROPID_E_MASTERID        (PROPID_E_BASE + 7)        /* VT_CLSID     */
#define PROPID_E_SEQNUM          (PROPID_E_BASE + 8)        /* VT_BLOB      */
#define PROPID_E_ID              (PROPID_E_BASE + 9)        /* VT_CLSID     */
#define PROPID_E_CRL             (PROPID_E_BASE + 10)       /* VT_BLOB      */
#define PROPID_E_CSP_TYPE        (PROPID_E_BASE + 11)       /* VT_UI4       */
#define PROPID_E_ENCRYPT_ALG     (PROPID_E_BASE + 12)       /* VT_UI4       */
#define PROPID_E_SIGN_ALG        (PROPID_E_BASE + 13)       /* VT_UI4       */
#define PROPID_E_HASH_ALG        (PROPID_E_BASE + 14)       /* VT_UI4       */
#define PROPID_E_CIPHER_MODE     (PROPID_E_BASE + 15)       /* VT_UI4       */
#define PROPID_E_LONG_LIVE       (PROPID_E_BASE + 16)       /* VT_UI4       */
#define PROPID_E_VERSION         (PROPID_E_BASE + 17)       /* VT_UI2       */
#define PROPID_E_NT4ID           (PROPID_E_BASE + 18)       /* VT_CLSID     */
//
// E_NT4ID is the guid of the enterprise on NT4 (MSMQ1.0). This is used
// for migration, to create an enterprise with predefined objectGUID.
//
#define PROPID_E_SECURITY        (PPROPID_E_BASE + 1)       /* VT_BLOB      */

//-------PROPID_E_NAMESTYLE---------------
// now used for security relaxation.
//
#define MQ_E_RELAXATION_DEFAULT  2
#define MQ_E_RELAXATION_ON       1
#define MQ_E_RELAXATION_OFF      0


//-------PROPID_E_CSP_NAME---------------
// now used for downlevel notification support.
//
#define MQ_E_DOWNLEVEL_ON        L"Y"
#define MQ_E_DOWNLEVEL_OFF       L"N"

//-------Default Values-------------------
#define DEFAULT_E_NAMESTYLE     MQ_E_RELAXATION_DEFAULT
#define DEFAULT_E_DEFAULTCSP    MQ_E_DOWNLEVEL_ON
#define DEFAULT_E_DEFAULTCSP_LEN    STRLEN(DEFAULT_E_DEFAULTCSP)
#define DEFAULT_E_PROV_TYPE     1       // PROV_RSA_FULL
#define DEFAULT_E_VERSION       200



//********************************************************************
//  USER PROPERTIES
//********************************************************************
#define PROPID_U_BASE MQDS_USER * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_U_SID             (PROPID_U_BASE + 1)        /* VT_BLOB      */
#define PROPID_U_SIGN_CERT       (PROPID_U_BASE + 2)        /* VT_BLOB      */
#define PROPID_U_MASTERID        (PROPID_U_BASE + 3)        /* VT_CLSID     */
#define PROPID_U_SEQNUM          (PROPID_U_BASE + 4)        /* VT_BLOB      */
#define PROPID_U_DIGEST          (PROPID_U_BASE + 5)        /* VT_UUID      */
#define PROPID_U_ID              (PROPID_U_BASE + 6)        /* VT_UUID      */

//********************************************************************
//  MQUSER PROPERTIES
//********************************************************************
#define PROPID_MQU_BASE MQDS_MQUSER * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_MQU_SID             (PROPID_MQU_BASE + 1)        /* VT_BLOB      */
#define PROPID_MQU_SIGN_CERT       (PROPID_MQU_BASE + 2)        /* VT_BLOB      */
#define PROPID_MQU_MASTERID        (PROPID_MQU_BASE + 3)        /* VT_CLSID     */
#define PROPID_MQU_SEQNUM          (PROPID_MQU_BASE + 4)        /* VT_BLOB      */
#define PROPID_MQU_DIGEST          (PROPID_MQU_BASE + 5)        /* VT_UUID      */
#define PROPID_MQU_ID              (PROPID_MQU_BASE + 6)        /* VT_UUID      */
#define PROPID_MQU_SECURITY        (PROPID_MQU_BASE + 7)        /* VT_BLOB      */

//********************************************************************
//  SITELINKS PROPERTIES
//********************************************************************
#define PROPID_L_BASE MQDS_SITELINK * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_L_NEIGHBOR1       (PROPID_L_BASE + 1)        /* VT_CLSID     */
#define PROPID_L_NEIGHBOR2       (PROPID_L_BASE + 2)        /* VT_CLSID     */
#define PROPID_L_COST            (PROPID_L_BASE + 3)        /* VT_UI4       */
#define PROPID_L_MASTERID        (PROPID_L_BASE + 4)        /* VT_CLSID     */
#define PROPID_L_SEQNUM          (PROPID_L_BASE + 5)        /* VT_BLOB      */
#define PROPID_L_ID              (PROPID_L_BASE + 6)        /* VT_CLSID     */
#define PROPID_L_GATES_DN        (PROPID_L_BASE + 7)        /* VT_LPWSTR | VT_VECTOR */
#define PROPID_L_NEIGHBOR1_DN    (PROPID_L_BASE + 8)        /* VT_LPWSTR    */
#define PROPID_L_NEIGHBOR2_DN    (PROPID_L_BASE + 9)        /* VT_LPWSTR    */
#define PROPID_L_DESCRIPTION     (PROPID_L_BASE + 10)       /* VT_LPWSTR    */
#define PROPID_L_FULL_PATH       (PROPID_L_BASE + 11)       /* VT_LPWSTR    */
//
//   PROPID_L_ACTUAL_COST contain the link cost as is.
//   PROPID_L_COST performs translation of the cost ( cost to
//   foreign sites is incremented)
//
#define PROPID_L_ACTUAL_COST     (PROPID_L_BASE + 12)       /* VT_UI4       */
#define PROPID_L_GATES           (PROPID_L_BASE + 13)       /* VT_CLSID | VT_VECTOR */

//-------PROPID_L_COST---------------
#define MQ_MAX_LINK_COST    999999


//********************************************************************
//  PURGE PROPERTIES
//********************************************************************
#define PROPID_P_BASE MQDS_PURGE * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_P_MASTERID        (PROPID_P_BASE + 1)        /* VT_CLSID     */
#define PROPID_P_PURGED_SN       (PROPID_P_BASE + 2)        /* VT_BLOB      */
#define PROPID_P_ALLOWED_SN      (PROPID_P_BASE + 3)        /* VT_BLOB      */
#define PROPID_P_ACKED_SN        (PROPID_P_BASE + 4)        /* VT_BLOB      */
#define PROPID_P_ACKED_SN_PEC    (PROPID_P_BASE + 5)        /* VT_BLOB      */
#define PROPID_P_STATE			 (PROPID_P_BASE + 6)		/* VT_UI1		*/

//********************************************************************
//  BSCACK PROPERTIES
//********************************************************************
#define PROPID_B_BASE MQDS_BSCACK * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_B_BSC_MACHINE_ID  (PROPID_B_BASE + 1)        /* VT_CLSID     */
#define PROPID_B_ACK_TIME        (PROPID_B_BASE + 2)        /* VT_I4        */

//********************************************************************
//  Site Server PROPERTIES
//********************************************************************
#define PROPID_SRV_BASE MQDS_SERVER * PROPID_OBJ_GRANULARITY

#define PROPID_SRV_NAME         (PROPID_SRV_BASE + 1)      /* VT_LPWSTR */
#define PROPID_SRV_ID           (PROPID_SRV_BASE + 2)      /* VT_CLSID  */
#define PROPID_SRV_FULL_PATH    (PROPID_SRV_BASE + 3)      /* VT_LPWSTR */

//********************************************************************
//  MSMQ SETTING PROPERTIES
//********************************************************************
#define PROPID_SET_BASE MQDS_SETTING * PROPID_OBJ_GRANULARITY

#define PROPID_SET_NAME         (PROPID_SET_BASE + 1)      /* VT_LPWSTR */
#define PROPID_SET_SERVICE      (PROPID_SET_BASE + 2)      /* VT_UI4    */
#define PROPID_SET_QM_ID        (PROPID_SET_BASE + 3)      /* VT_CLSID  */
#define PROPID_SET_APPLICATION  (PROPID_SET_BASE + 4)      /* VT_LPWSTR */
#define PROPID_SET_FULL_PATH    (PROPID_SET_BASE + 5)      /* VT_LPWSTR */
#define PROPID_SET_NT4          (PROPID_SET_BASE + 6)      /* VT_UI1    */
//
// SET_NT4 is TRUE if the server is NT4/MSMQ1.0. FALSE otherwise.
//
#define PROPID_SET_MASTERID     (PROPID_SET_BASE + 7)      /* VT_CLSID  */
#define PROPID_SET_SITENAME     (PROPID_SET_BASE + 8)      /* VT_LPWSTR */
//
// PROPID_SET_MASTERID is the NT4 style site guid. It's written on the
// MSMQSetting object which belong to a MSMQ PSC server object. This is the
// best place to keep it, as a server, in NT5 DS, can be in a different site,
// as compared to NT4 MSMQ1 DS. So if it's a server (PROPID_SET_SERVICE is
// SERVICE_PSC or SERVICE_PEC) then MASTERID is the NT4 style site guid which
// is also the masterID for the site's objects. This is used for replication.
//
// PROPID_SET_SITENAME is the site name as written in NT4 MSMQ1 DS.
//

// [adsrv]
#define PROPID_SET_SERVICE_ROUTING     (PROPID_SET_BASE + 9)      /* VT_UI1 */
#define PROPID_SET_SERVICE_DSSERVER    (PROPID_SET_BASE + 10)     /* VT_UI1 */
#define PROPID_SET_SERVICE_DEPCLIENTS  (PROPID_SET_BASE + 11)     /* VT_UI1 */
#define PROPID_SET_OLDSERVICE          (PROPID_SET_BASE + 12)     /* VT_UI4 */

//********************************************************************
//  COMPUTER PROPERTIES
//********************************************************************

#define PROPID_COM_BASE MQDS_COMPUTER * PROPID_OBJ_GRANULARITY

#define PROPID_COM_FULL_PATH         (PROPID_COM_BASE + 1)      /* VT_LPWSTR */
#define PROPID_COM_SAM_ACCOUNT       (PROPID_COM_BASE + 2)      /* VT_LPWSTR */

//
//  COM_CONTAINER Can be used only as extended property when creating
//  the computer object.
//
#define PROPID_COM_CONTAINER         (PROPID_COM_BASE + 3)      /* VT_LPWSTR */

//
// ACCOUNT_CONTROL property is translated to DS attribute userAccountControl
// and it must be set to 4128 (Decimal) when creating a computer object.
// Otherwise, you can't loggin from that computer. Bug 3153.
//
#define PROPID_COM_ACCOUNT_CONTROL   (PROPID_COM_BASE + 4)      /* VT_UI4    */
#define PROPID_COM_DNS_HOSTNAME      (PROPID_COM_BASE + 5)      /* VT_LPWSTR */
//
// PROPID_COM_SID is the SID of the computer object. This property is read
// from the active directory when create a msmqConfiguration object, in
// order to add it to the msmqConfiguration dacl.
//
#define PROPID_COM_SID               (PROPID_COM_BASE + 6)      /* VT_BLOB */

//
// the following properties are used to store/retrieve certificate of
// services. These ones are kept in the computer object.
//
#define PROPID_COM_SIGN_CERT         (PROPID_COM_BASE + 7)      /* VT_BLOB     */
#define PROPID_COM_DIGEST            (PROPID_COM_BASE + 8)      /* VT_CLSID    */
#define PROPID_COM_ID                (PROPID_COM_BASE + 9)      /* VT_CLSID    */
//
//  PROPID_COM_VERSION, PROPID_COM_SERVICE_PRINCIPAL_NAME are supported only in MQAD
//
#define PROPID_COM_VERSION           (PROPID_COM_BASE + 10)				/* VT_LPWSTR   */
#define PROPID_COM_SERVICE_PRINCIPAL_NAME       (PROPID_COM_BASE + 11)  /* VT_LPWSTR | VT_VECTOR */

//------------- Default Values ----------
#define DEFAULT_COM_ACCOUNT_CONTROL   (UF_PASSWD_NOTREQD | UF_WORKSTATION_TRUST_ACCOUNT)

//
// PROPID_COM_SAM_ACCOUNT (or sAMAccountName property in the Active Directory)
// should be shorter than 20 characters.
// 6295 - ilanh - 03-Jan-2001
//
#define MAX_COM_SAM_ACCOUNT_LENGTH 19

// begin_mq_h

//********************************************************************
//  PRIVATE COMPUTER PROPERTIES
//********************************************************************
#define PROPID_PC_BASE 5800

// end_mq_h

#if (PROPID_PC_BASE != (MQDS_PRIVATE_COMPUTER * PROPID_OBJ_GRANULARITY))
#error "PROPID_PC_BASE != (MQDS_PRIVATE_COMPUTER * PROPID_OBJ_GRANULARITY)"
#endif

// begin_mq_h
#define PROPID_PC_VERSION             (PROPID_PC_BASE + 1) /* VT_UI4            */
#define PROPID_PC_DS_ENABLED          (PROPID_PC_BASE + 2) /* VT_BOOL           */
// end_mq_h

#define FIRST_PRIVATE_COMPUTER_PROPID  PROPID_PC_BASE
#define LAST_PRIVATE_COMPUTER_PROPID   PROPID_PC_DS_ENABLED


// begin_mq_h

//********************************************************************
//  LOCAL ADMIN MSMQ MACHINE PROPERTIES
//********************************************************************
#define PROPID_MGMT_MSMQ_BASE           0
#define PROPID_MGMT_MSMQ_ACTIVEQUEUES   (PROPID_MGMT_MSMQ_BASE + 1) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_PRIVATEQ       (PROPID_MGMT_MSMQ_BASE + 2) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_DSSERVER       (PROPID_MGMT_MSMQ_BASE + 3) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_CONNECTED      (PROPID_MGMT_MSMQ_BASE + 4) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_TYPE           (PROPID_MGMT_MSMQ_BASE + 5) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_BYTES_IN_ALL_QUEUES (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_UI8    */


//
// Returned Value for PROPID_MGMT_MSMQ_CONNECTED property
//
#define MSMQ_CONNECTED      L"CONNECTED"
#define MSMQ_DISCONNECTED   L"DISCONNECTED"


//********************************************************************
//  LOCAL ADMIN MSMQ QUEUE PROPERTIES
//********************************************************************
#define PROPID_MGMT_QUEUE_BASE                  0
#define PROPID_MGMT_QUEUE_PATHNAME              (PROPID_MGMT_QUEUE_BASE + 1)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FORMATNAME            (PROPID_MGMT_QUEUE_BASE + 2)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_TYPE                  (PROPID_MGMT_QUEUE_BASE + 3)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_LOCATION              (PROPID_MGMT_QUEUE_BASE + 4)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_XACT                  (PROPID_MGMT_QUEUE_BASE + 5)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FOREIGN               (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_MESSAGE_COUNT         (PROPID_MGMT_QUEUE_BASE + 7)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_QUEUE        (PROPID_MGMT_QUEUE_BASE + 8)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT (PROPID_MGMT_QUEUE_BASE + 9)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL      (PROPID_MGMT_QUEUE_BASE + 10)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_STATE                 (PROPID_MGMT_QUEUE_BASE + 11)   /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_NEXTHOPS              (PROPID_MGMT_QUEUE_BASE + 12)   /* VT_LPWSTR|VT_VECTOR  */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK          (PROPID_MGMT_QUEUE_BASE + 13)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME     (PROPID_MGMT_QUEUE_BASE + 14)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT    (PROPID_MGMT_QUEUE_BASE + 15)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK     (PROPID_MGMT_QUEUE_BASE + 16)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK      (PROPID_MGMT_QUEUE_BASE + 17)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NEXT_SEQ          (PROPID_MGMT_QUEUE_BASE + 18)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT     (PROPID_MGMT_QUEUE_BASE + 19)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT      (PROPID_MGMT_QUEUE_BASE + 20)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_TIME       (PROPID_MGMT_QUEUE_BASE + 21)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL   (PROPID_MGMT_QUEUE_BASE + 22)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_COUNT      (PROPID_MGMT_QUEUE_BASE + 23)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_SOURCE_INFO       (PROPID_MGMT_QUEUE_BASE + 24)   /* VT_VARIANT|VT_VECTOR */


//
// Alternative names for "Bytes in ..."
//
#define PROPID_MGMT_QUEUE_USED_QUOTA            PROPID_MGMT_QUEUE_BYTES_IN_QUEUE          
#define PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA    PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL        

//
// Returned value for PROPID_MGMT_QUEUE_TYPE
//
#define MGMT_QUEUE_TYPE_PUBLIC      L"PUBLIC"
#define MGMT_QUEUE_TYPE_PRIVATE     L"PRIVATE"
#define MGMT_QUEUE_TYPE_MACHINE     L"MACHINE"
#define MGMT_QUEUE_TYPE_CONNECTOR   L"CONNECTOR"
#define MGMT_QUEUE_TYPE_MULTICAST   L"MULTICAST"

//
// Returned value for PROPID_MGMT_QUEUE_STATE
//
#define MGMT_QUEUE_STATE_LOCAL          L"LOCAL CONNECTION"
#define MGMT_QUEUE_STATE_NONACTIVE      L"INACTIVE"
#define MGMT_QUEUE_STATE_WAITING        L"WAITING"
#define MGMT_QUEUE_STATE_NEED_VALIDATE  L"NEED VALIDATION"
#define MGMT_QUEUE_STATE_ONHOLD         L"ONHOLD"
#define MGMT_QUEUE_STATE_CONNECTED      L"CONNECTED"
#define MGMT_QUEUE_STATE_DISCONNECTING  L"DISCONNECTING"
#define MGMT_QUEUE_STATE_DISCONNECTED   L"DISCONNECTED"
#define MGMT_QUEUE_STATE_LOCKED   L"LOCKED"

//
// Returned value for PROPID_MGMT_QUEUE_LOCATION
//
#define MGMT_QUEUE_LOCAL_LOCATION   L"LOCAL"
#define MGMT_QUEUE_REMOTE_LOCATION  L"REMOTE"

// 
// Returned Value for PROPID_MGMT_QUEUE_XACT and PROPID_MGMT_QUEUE_FOREIGN
//

#define MGMT_QUEUE_UNKNOWN_TYPE     L"UNKNOWN"

//
// Obselete names left for backword compatibility.
//

#define MGMT_QUEUE_CORRECT_TYPE     L"YES"
#define MGMT_QUEUE_INCORRECT_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_XACT 
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_TRANSACTIONAL_TYPE  	L"YES"
#define MGMT_QUEUE_NOT_TRANSACTIONAL_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_FOREIGN
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_FOREIGN_TYPE         L"YES"
#define MGMT_QUEUE_NOT_FOREIGN_TYPE     L"NO"

//
// Object parameter values for MQMgmtAction API
//
#define MO_MACHINE_TOKEN    L"MACHINE"
#define MO_QUEUE_TOKEN      L"QUEUE"

//
// Action parameter values for MQMgmtAction API
//
#define MACHINE_ACTION_CONNECT      L"CONNECT"
#define MACHINE_ACTION_DISCONNECT   L"DISCONNECT"
#define MACHINE_ACTION_TIDY         L"TIDY"

#define QUEUE_ACTION_PAUSE      L"PAUSE"
#define QUEUE_ACTION_RESUME     L"RESUME"
#define QUEUE_ACTION_EOD_RESEND L"EOD_RESEND"

// end_mq_h


// begin_mq_h
//
// LONG_LIVED is the default for PROPID_M_TIME_TO_REACH_QUEUE. If calls
// to MQSendMessage() specify this value, or not specify this property at
// all, then the actual timeout is obtained from Active Directory.
//
#define LONG_LIVED    0xfffffffe

#define MQ_MAX_Q_NAME_LEN      124   // Maximal WCHAR length of a queue name.
#define MQ_MAX_Q_LABEL_LEN     124
#define MQ_MAX_MSG_LABEL_LEN   250

// end_mq_h

#endif // __MQPROPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqsec.h ===
//++
//
// Copyright (c) 1996-1998 Microsoft Coroporation
//
// Module Name  : mqsec.h
//
// Abstract     : Security related definitions
//
// Module Author: Boaz Feldbaum and Yoel Arnon
//
// History:  Doron Juster (DoronJ), add definition for mqsec.dll
//
//--

#ifndef __MQSEC_H_
#define __MQSEC_H_

#include "mqencryp.h"

//+-------------------------------
//
//  CImpersonate
//
//+-------------------------------

//
// This object class is not need on Win95.
//
// CImpersonate is an object that impersonates the calling user. If the
// client is an RPC client, impersonation is done using RPC functions, else
// impersonation is done by calling ImpersonateSelf.

class CImpersonate
{
public:
    CImpersonate(
    	BOOL fClient,
    	BOOL fImpersonateAnonymousOnFailure
    	);

    virtual ~CImpersonate();

    virtual DWORD  GetImpersonationStatus();

    virtual BOOL   GetThreadSid(OUT BYTE **ppSid);

    virtual BOOL   IsImpersonatedAsSystemService(PSID* ppSystemServiceSid);

private:

    virtual BOOL Impersonate(BOOL fImpersonateAnonymousOnFailure);

private:
    BOOL   m_fClient;
    HANDLE m_hAccessTokenHandle;
    DWORD  m_dwStatus;

    bool m_fImpersonateAnonymous;	// a flag to indicate impersonate anonymous
};


//
// Structure for Absolute security descriptor
//
struct CAbsSecurityDsecripror
{
public:
	CAbsSecurityDsecripror() {}

public:
    AP<char> m_pOwner;
    AP<char> m_pPrimaryGroup;
    AP<char> m_pDacl;
    AP<char> m_pSacl;
    AP<char> m_pObjAbsSecDescriptor;

private:
    CAbsSecurityDsecripror(const CAbsSecurityDsecripror&);
	CAbsSecurityDsecripror& operator=(const CAbsSecurityDsecripror&);

};


//+--------------------------------------
//
//  enums and other useful macros
//
//+--------------------------------------

#define  MQSEC_SD_ALL_INFO  ( OWNER_SECURITY_INFORMATION |      \
                              GROUP_SECURITY_INFORMATION |      \
                              DACL_SECURITY_INFORMATION  |      \
                              SACL_SECURITY_INFORMATION )

//+-----------------------------------------------------------------------
//
//  enum enumProvider
//
//  This enumerates the crypto providers supported by msmq for encryption.
//  The "Foreign" entries are used by the "mqforgn" tool to insert public
//  keys into the msmqConfiguration objects of foreign machines.
//
//+-----------------------------------------------------------------------

enum enumProvider
{
    eBaseProvider,
    eEnhancedProvider,
    eForeignBaseProvider,
    eForeignEnhProvider
} ;

enum enumCryptoProp
{
    eProvName,
    eProvType,
    eSessionKeySize,
    eContainerName,
    eBlockSize
} ;

//+----------------------------------------------------------------------
//
// The functions exported by mqsec.dll are internals and should not
// be included in mq.h in the sdk.
//
//+----------------------------------------------------------------------

//
// Function to manipulate security descriptors.
//

enum  enumDaclType {
    e_UseDefaultDacl = 0,
    e_GrantFullControlToEveryone,
    e_UseDefDaclAndCopyControl
} ;

HRESULT
APIENTRY
MQSec_GetDefaultSecDescriptor(
	IN  DWORD                 dwObjectType,
	OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
	IN  BOOL                  fImpersonate,
	IN  PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
	IN  SECURITY_INFORMATION  seInfoToRemove,
	IN  enum  enumDaclType    eDaclType,
	IN  PSID  pMachineSid = NULL
	);

typedef HRESULT (APIENTRY *MQSec_GetDefaultSecDescriptor_ROUTINE) (
                        DWORD                 dwObjectType,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL                  fImpersonate,
                        PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
                        SECURITY_INFORMATION  seInfoToRemove,
						IN  enum  enumDaclType    eDaclType,
						IN  PSID  pMachineSid /*= NULL*/
						);

HRESULT  APIENTRY MQSec_MergeSecurityDescriptors(
                        IN  DWORD                  dwObjectType,
                        IN  SECURITY_INFORMATION   SecurityInformation,
                        IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
                        IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
                        OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor
                        );


HRESULT APIENTRY  MQSec_MakeSelfRelative(
                                IN  PSECURITY_DESCRIPTOR   pIn,
                                OUT PSECURITY_DESCRIPTOR  *ppOut,
                                OUT DWORD                 *pdwSize ) ;

//
// Function to manipulate crypto provider and crypto keys.
//

HRESULT APIENTRY  MQSec_PackPublicKey(
                             IN      BYTE            *pKeyBlob,
                             IN      ULONG            ulKeySize,
                             IN      LPCWSTR          wszProviderName,
                             IN      ULONG            ulProviderType,
                             IN OUT  MQDSPUBLICKEYS **ppPublicKeysPack ) ;

HRESULT APIENTRY  MQSec_UnpackPublicKey(
                               IN  MQDSPUBLICKEYS  *pPublicKeysPack,
                               IN  LPCWSTR          wszProviderName,
                               IN  ULONG            ulProviderType,
                               OUT BYTE           **ppKeyBlob,
                               OUT ULONG           *pulKeySize ) ;

HRESULT APIENTRY  MQSec_GetCryptoProvProperty(
                                     IN  enum enumProvider     eProvider,
                                     IN  enum enumCryptoProp   eProp,
                                     OUT LPWSTR         *ppwszStringProp,
                                     OUT DWORD          *pdwProp ) ;

HRESULT APIENTRY  MQSec_AcquireCryptoProvider(
                                     IN  enum enumProvider  eProvider,
                                     OUT HCRYPTPROV        *phProv ) ;

typedef HRESULT
(APIENTRY *MQSec_StorePubKeys_ROUTINE) ( IN BOOL fRegenerate,
                                         IN enum enumProvider eBaseCrypProv,
                                         IN enum enumProvider eEnhCrypProv,
                                         OUT BLOB * pblobEncrypt,
                                         OUT BLOB * pblobSign ) ;

HRESULT APIENTRY MQSec_StorePubKeys( IN BOOL fRegenerate,
                                     IN enum enumProvider eBaseCrypProv,
                                     IN enum enumProvider eEnhCrypProv,
                                     OUT BLOB * pblobEncrypt,
                                     OUT BLOB * pblobSign ) ;

typedef HRESULT
(APIENTRY *MQSec_StorePubKeysInDS_ROUTINE) ( IN BOOL       fRegenerate,
                                    IN LPCWSTR    wszObjectName,
                                    IN DWORD      dwObjectType,
									IN BOOL		  fFromSetup /*= false*/);

HRESULT  APIENTRY MQSec_StorePubKeysInDS( IN BOOL         fRegenerate,
                                 IN LPCWSTR      wszObjectName,
                                 IN DWORD        dwObjectType,
  								 IN BOOL		 fFromSetup = false);

HRESULT  APIENTRY MQSec_GetPubKeysFromDS(
                                 IN  const GUID  *pMachineGuid,
                                 IN  LPCWSTR      lpwszMachineName,
                                 IN  enum enumProvider     eProvider,
                                 IN  DWORD        propIdKeys,
                                 OUT BYTE       **pPubKeyBlob,
                                 OUT DWORD       *pdwKeyLength ) ;

void APIENTRY MQSec_TraceThreadTokenInfo();

HRESULT  
APIENTRY  
MQSec_GetUserType( 
	IN  PSID pSid,
	OUT BOOL *pfLocalUser,
	OUT BOOL *pfLocalSystem,
	OUT BOOL *pfNetworkService = NULL
	);

typedef HRESULT  
(APIENTRY  *MQSec_GetUserType_ROUTINE) (
	IN  PSID pSid,
	OUT BOOL *pfLocalUser,
	OUT BOOL *pfLocalSystem,
	OUT BOOL *pfNetworkService /* = NULL */
	);

bool    APIENTRY MQSec_IsDC();

BOOL    APIENTRY  MQSec_IsSystemSid(IN  PSID  pSid);

BOOL    APIENTRY  MQSec_IsNetworkServiceSid(IN  PSID  pSid);

BOOL    APIENTRY  MQSec_IsGuestSid(IN  PSID  pSid);

BOOL    APIENTRY  MQSec_IsAnonymusSid(IN  PSID  pSid);

HRESULT APIENTRY  MQSec_IsUnAuthenticatedUser(
                                         BOOL *pfUnAuthenticatedUser ) ;

void APIENTRY  MQSec_GetImpersonationObject(
						IN  BOOL fImpersonateAnonymousOnFailure,	
						OUT CImpersonate **ppImpersonate
						);

HRESULT APIENTRY  MQSec_GetThreadUserSid(
                                       IN  BOOL           fImpersonate,
                                       OUT PSID  *        ppSid,
                                       OUT DWORD *        pdwSidLen,
                                       IN  BOOL           fThreadTokenOnly
                                       ) ;


HRESULT APIENTRY  MQSec_GetProcessUserSid( OUT PSID  *ppSid,
                                           OUT DWORD *pdwSidLen ) ;

typedef HRESULT (APIENTRY * MQSec_GetProcessUserSid_ROUTINE) (
                                           OUT PSID  *ppSid,
                                           OUT DWORD *pdwSidLen ) ;

void APIENTRY MQSec_UpdateLocalMachineSid(PSID pLocalMachineSid);

PSID    APIENTRY  MQSec_GetLocalMachineSid( IN  BOOL    fAllocate,
                                            OUT DWORD  *pdwSize ) ;

PSID    APIENTRY  MQSec_GetWorldSid();

PSID	APIENTRY  MQSec_GetAnonymousSid();

PSID	APIENTRY  MQSec_GetAdminSid();

PSID	APIENTRY  MQSec_GetLocalSystemSid();

PSID    APIENTRY  MQSec_GetProcessSid();

PSID    APIENTRY  MQSec_GetNetworkServiceSid();

enum  enumCopyControl {
    e_DoNotCopyControlBits = 0,
    e_DoCopyControlBits
} ;

BOOL    APIENTRY MQSec_CopySecurityDescriptor(
                    IN PSECURITY_DESCRIPTOR  pDstSecurityDescriptor,
                    IN PSECURITY_DESCRIPTOR  pSrcSecurityDescriptor,
                    IN SECURITY_INFORMATION  RequestedInformation,
                    IN enum  enumCopyControl eCopyControlBits ) ;

bool
APIENTRY
MQSec_MakeAbsoluteSD(
    PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
	CAbsSecurityDsecripror* pAbsSecDescriptor
	);

bool
APIENTRY
MQSec_SetSecurityDescriptorDacl(
    IN  PACL pNewDacl,
    IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
    OUT AP<BYTE>&  pSecurityDescriptor
	);


HRESULT APIENTRY  MQSec_ConvertSDToNT4Format(
                     IN  DWORD                 dwObjectType,
                     IN  SECURITY_DESCRIPTOR  *pSD5,
                     OUT DWORD                *pdwSD4Len,
                     OUT SECURITY_DESCRIPTOR **ppSD4,
                     IN  SECURITY_INFORMATION  sInfo = MQSEC_SD_ALL_INFO ) ;

enum  enumDaclDefault {
    e_DoNotChangeDaclDefault = 0,
    e_MakeDaclNonDefaulted
} ;

HRESULT APIENTRY  MQSec_ConvertSDToNT5Format(
                     IN  DWORD                 dwObjectType,
                     IN  SECURITY_DESCRIPTOR  *pSD4,
                     OUT DWORD                *pdwSD5Len,
                     OUT SECURITY_DESCRIPTOR **ppSD5,
                     IN  enum  enumDaclDefault eUnDefaultDacl,
                     IN  PSID                  pComputerSid  = NULL ) ;

HRESULT APIENTRY  MQSec_SetPrivilegeInThread( LPCTSTR lpwcsPrivType,
                                              BOOL    bEnabled ) ;

typedef HRESULT  (APIENTRY *MQSec_SetPrivilegeInThread_FN)
                             ( LPCTSTR lpwcsPrivType, BOOL bEnabled ) ;

HRESULT APIENTRY  MQSec_AccessCheck(
                            IN  SECURITY_DESCRIPTOR *pSD,
                            IN  DWORD                dwObjectType,
                            IN  LPCWSTR              pwszObjectName,
                            IN  DWORD                dwDesiredAccess,
                            IN  LPVOID               pId,
                            IN  BOOL                 fImpAsClient = FALSE,
                            IN  BOOL                 fImpersonate = FALSE ) ;

HRESULT
APIENTRY
MQSec_AccessCheckForSelf(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  PSID                 pSelfSid,
	IN  DWORD                dwDesiredAccess,
	IN  BOOL                 fImpersonate
	);

BOOL    APIENTRY  MQSec_CanGenerateAudit();

ULONG APIENTRY MQSec_RpcAuthnLevel();

RPC_STATUS APIENTRY  MQSec_SetLocalRpcMutualAuth( handle_t *phBind ) ;

//+----------------------------------------------
//
//  Message Authentication functions.
//
//+----------------------------------------------

//
// This structure is used to gather the message flags that are supplied by
// caller to MQSendMessage() and hash them.
//
struct _MsgFlags
{
    UCHAR  bDelivery ;
    UCHAR  bPriority ;
    UCHAR  bAuditing ;
    UCHAR  bAck      ;
    USHORT usClass   ;
    ULONG  ulBodyType ;
} ;

struct _MsgPropEntry
{
    ULONG       dwSize ;
    const BYTE *pData ;
} ;

struct _MsgHashData
{
    ULONG                cEntries ;
    struct _MsgPropEntry aEntries[1] ;
} ;

HRESULT APIENTRY  MQSigHashMessageProperties(
                                 IN HCRYPTHASH           hHash,
                                 IN struct _MsgHashData *pHashData ) ;

// begin_mq_h

//+-----------------------------------------
//
// Flags for MQRegisterCertificate()
//
//+-----------------------------------------

#define MQCERT_REGISTER_ALWAYS        0x01
#define MQCERT_REGISTER_IF_NOT_EXIST  0x02

// end_mq_h

//
// flags in HKCU, CERTIFICATE_REGISTERD_REGNAME, that indicate result
// of autoregistration of internal certificate.
//
#define INTERNAL_CERT_REGISTERED   1

// begin_mq_h

//********************************************************************
//  SECURITY Flags (Queue access control)
//********************************************************************

#define MQSEC_DELETE_MESSAGE                0x1
#define MQSEC_PEEK_MESSAGE                  0x2
#define MQSEC_WRITE_MESSAGE                 0x4
#define MQSEC_DELETE_JOURNAL_MESSAGE        0x8
#define MQSEC_SET_QUEUE_PROPERTIES          0x10
#define MQSEC_GET_QUEUE_PROPERTIES          0x20
#define MQSEC_DELETE_QUEUE                  DELETE
#define MQSEC_GET_QUEUE_PERMISSIONS         READ_CONTROL
#define MQSEC_CHANGE_QUEUE_PERMISSIONS      WRITE_DAC
#define MQSEC_TAKE_QUEUE_OWNERSHIP          WRITE_OWNER

#define MQSEC_RECEIVE_MESSAGE               (MQSEC_DELETE_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_RECEIVE_JOURNAL_MESSAGE       (MQSEC_DELETE_JOURNAL_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_QUEUE_GENERIC_READ            (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE)

#define MQSEC_QUEUE_GENERIC_WRITE           (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_WRITE_MESSAGE)

#define MQSEC_QUEUE_GENERIC_EXECUTE         0

#define MQSEC_QUEUE_GENERIC_ALL             (MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE | \
                                             MQSEC_WRITE_MESSAGE | \
                                             MQSEC_SET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_DELETE_QUEUE | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_CHANGE_QUEUE_PERMISSIONS | \
                                             MQSEC_TAKE_QUEUE_OWNERSHIP)
// end_mq_h

//
// Machine security flags
//
#define MQSEC_DELETE_DEADLETTER_MESSAGE     0x1
#define MQSEC_PEEK_DEADLETTER_MESSAGE       0x2
#define MQSEC_CREATE_QUEUE                  0x4
#define MQSEC_SET_MACHINE_PROPERTIES        0x10
#define MQSEC_GET_MACHINE_PROPERTIES        0x20
#define MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE  0x40
#define MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE    0x80
#define MQSEC_DELETE_MACHINE                DELETE
#define MQSEC_GET_MACHINE_PERMISSIONS       READ_CONTROL
#define MQSEC_CHANGE_MACHINE_PERMISSIONS    WRITE_DAC
#define MQSEC_TAKE_MACHINE_OWNERSHIP        WRITE_OWNER

#define MQSEC_RECEIVE_DEADLETTER_MESSAGE    (MQSEC_DELETE_DEADLETTER_MESSAGE | \
                                             MQSEC_PEEK_DEADLETTER_MESSAGE)

#define MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE (MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE | \
                                             MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE)

#define MQSEC_MACHINE_GENERIC_READ          (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_RECEIVE_DEADLETTER_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE)

#define MQSEC_MACHINE_GENERIC_WRITE         (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_CREATE_QUEUE)

#define MQSEC_MACHINE_GENERIC_EXECUTE       0

#define MQSEC_MACHINE_GENERIC_ALL           (MQSEC_RECEIVE_DEADLETTER_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE | \
                                             MQSEC_CREATE_QUEUE | \
                                             MQSEC_SET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_DELETE_MACHINE | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_CHANGE_MACHINE_PERMISSIONS | \
                                             MQSEC_TAKE_MACHINE_OWNERSHIP)

#define MQSEC_MACHINE_WORLD_RIGHTS          (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS)

#define MQSEC_MACHINE_SELF_RIGHTS       (MQSEC_GET_MACHINE_PROPERTIES     | \
                                         MQSEC_GET_MACHINE_PERMISSIONS    | \
                                         MQSEC_SET_MACHINE_PROPERTIES     | \
                                         MQSEC_CHANGE_MACHINE_PERMISSIONS | \
                                         MQSEC_CREATE_QUEUE)
//
// Site security flags
//
#define MQSEC_CREATE_FRS                    0x1
#define MQSEC_CREATE_BSC                    0x2
#define MQSEC_CREATE_MACHINE                0x4
#define MQSEC_SET_SITE_PROPERTIES           0x10
#define MQSEC_GET_SITE_PROPERTIES           0x20
#define MQSEC_DELETE_SITE                   DELETE
#define MQSEC_GET_SITE_PERMISSIONS          READ_CONTROL
#define MQSEC_CHANGE_SITE_PERMISSIONS       WRITE_DAC
#define MQSEC_TAKE_SITE_OWNERSHIP           WRITE_OWNER

#define MQSEC_SITE_GENERIC_READ             (MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PERMISSIONS)

#define MQSEC_SITE_GENERIC_WRITE            (MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PERMISSIONS | \
                                             MQSEC_CREATE_MACHINE)

#define MQSEC_SITE_GENERIC_EXECUTE          0

#define MQSEC_SITE_GENERIC_ALL              (MQSEC_CREATE_FRS | \
                                             MQSEC_CREATE_BSC | \
                                             MQSEC_CREATE_MACHINE | \
                                             MQSEC_SET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_DELETE_SITE | \
                                             MQSEC_GET_SITE_PERMISSIONS | \
                                             MQSEC_CHANGE_SITE_PERMISSIONS | \
                                             MQSEC_TAKE_SITE_OWNERSHIP)

//
// CN security flags
//
#define MQSEC_CN_OPEN_CONNECTOR             0x1
#define MQSEC_SET_CN_PROPERTIES             0x10
#define MQSEC_GET_CN_PROPERTIES             0x20
#define MQSEC_DELETE_CN                     DELETE
#define MQSEC_GET_CN_PERMISSIONS            READ_CONTROL
#define MQSEC_CHANGE_CN_PERMISSIONS         WRITE_DAC
#define MQSEC_TAKE_CN_OWNERSHIP             WRITE_OWNER

#define MQSEC_CN_GENERIC_READ               (MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PERMISSIONS)

#define MQSEC_CN_GENERIC_WRITE              (MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PERMISSIONS)

#define MQSEC_CN_GENERIC_EXECUTE            0

#define MQSEC_CN_GENERIC_ALL                (MQSEC_CN_OPEN_CONNECTOR | \
                                             MQSEC_SET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_DELETE_CN | \
                                             MQSEC_GET_CN_PERMISSIONS | \
                                             MQSEC_CHANGE_CN_PERMISSIONS | \
                                             MQSEC_TAKE_CN_OWNERSHIP)
//
// Enterprise security flags
//
#define MQSEC_CREATE_USER                   0x1
#define MQSEC_CREATE_SITE                   0x2
#define MQSEC_CREATE_CN                     0x4
#define MQSEC_SET_ENTERPRISE_PROPERTIES     0x10
#define MQSEC_GET_ENTERPRISE_PROPERTIES     0x20
#define MQSEC_DELETE_ENTERPRISE             DELETE
#define MQSEC_GET_ENTERPRISE_PERMISSIONS    READ_CONTROL
#define MQSEC_CHANGE_ENTERPRISE_PERMISSIONS WRITE_DAC
#define MQSEC_TAKE_ENTERPRISE_OWNERSHIP     WRITE_OWNER

#define MQSEC_ENTERPRISE_GENERIC_READ       (MQSEC_CREATE_USER | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS)

#define MQSEC_ENTERPRISE_GENERIC_WRITE      (MQSEC_CREATE_USER | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_CREATE_SITE | \
                                             MQSEC_CREATE_CN | \
                                             MQSEC_CREATE_USER)

#define MQSEC_ENTERPRISE_GENERIC_EXECUTE    0

#define MQSEC_ENTERPRISE_GENERIC_ALL        (MQSEC_CREATE_USER | \
                                             MQSEC_CREATE_CN | \
                                             MQSEC_CREATE_SITE | \
                                             MQSEC_SET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_DELETE_ENTERPRISE | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_CHANGE_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_TAKE_ENTERPRISE_OWNERSHIP)

#endif // __MQSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqmaps.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    mqmaps.h

Abstract:
    map file sample.

Author:
    Tatiana Shubin	(tatianas)	5-Dec-2000
    Ilan Herbst		(ilanh)		21-Nov-2001

--*/

#pragma once

#ifndef _MSMQ_MQMAPS_H_
#define _MSMQ_MQMAPS_H_


//
// please pay attention: each line starts by " (quote sign)
// and ends by \r\n" (backslash, letter 'r', backslash, letter 'n' and quote sign)
// if you need quote sign or backslash in the line please use backslash before the sign:
// Example:
// if you need to put the line ' .... host="localhost"...' you have to write
// L".... host=\"localhost\" ...."
// or for '...msmq\internal...' you have to write
// L"...msmq\\internal..."
// As a result setup will generate the file sample_map.xml in msmq\mapping directory.
// The file will look like:
/*---------------
<!-- This is a sample XML file that demonstrates queue redirection. Use it as a template to
    create your own queue redirection files. -->


<redirections xmlns="msmq-queue-mapping.xml">

    <!-- Element that maps an internal application public queue name to an external one.
	<redirection>
   		<from>http://internal_host\msmq\internal_queue</from>
   		<to>http://external_host\msmq\external_queue</to>
   	</redirection>
	-->

    <!-- Element that maps an internal application private queue name to an external one.
	<redirection>
   		<from>http://internal_host\msmq\private$\order_queue$</from>
   		<to>http://external_host\msmq\private$\order_queue$</to>
   	</redirection>
	-->
	

</redirections>
-----------------*/

const char xMappingSample[] = ""
"<!-- \r\n"
"   This is a sample XML file that demonstrates queue redirection. Use it as a\r\n"
"   template to create your own queue redirection files.\r\n"
"   -->\r\n"
"\r\n"
"\r\n"
"<redirections xmlns=\"msmq-queue-redirections.xml\">\r\n"
"\r\n"
"  <!--\r\n"
"     Each <Redirections> element contains 0 or more <redirection> elements, each \r\n"
"     of which contains exactly one <from> subelement and exactly one <to> \r\n"
"     subelement. Each <redirection> element describes a redirection (or mapping)\r\n"
"     of the logical address given in the <from> subelement to the physical address \r\n"
"     given in the <to> element.\r\n"
"\r\n"
"  <redirection>\r\n"
"      <from>http://external_host/msmq/external_queue</from>\r\n"
"      <to>http://internal_host/msmq/internal_queue</to> \r\n"
"  </redirection>\r\n"
"\r\n"
"  --> \r\n"
"\r\n"
"  <!--\r\n"
"     Limited use of regular expressions in a <from> element is supported. \r\n"
"     Asterisk-terminated URLs can define a redirection from multiple logical \r\n"
"     addresses to a single physical address.\r\n"
"\r\n"
"     In the following example, any message with a logical address that starts \r\n"
"     with the string https://external_host/* will be redirected to the physical \r\n"
"     address in the <to> element.\r\n"
"\r\n"
"  <redirection>\r\n"
"      <from>https://external_host/*</from>\r\n"
"      <to>http://internal_host/msmq/internal_queue</to> \r\n"
"  </redirection>\r\n"
"	--> \r\n"
"\r\n"	
"\r\n"
"</redirections>"
"\r\n";


const char xOutboundMappingSample[] = ""
"<!-- \r\n"
"   This is a sample XML mapping file that demonstrates outbound message redirection. Use it as a\r\n"
"   template to create your own outbound message redirection files.\r\n"
"   -->\r\n"
"\r\n"
"\r\n"
"<outbound_redirections xmlns=\"msmq_outbound_mapping.xml\">\r\n"
"\r\n"
"  <!--\r\n"
"     The <outbound_redirections> element contains 0 or more <redirection> subelements, each \r\n"
"     of which in turn contains exactly one <destination> subelement and exactly one <through> \r\n"
"     subelement. Each <redirection> element describes a redirection (or mapping)\r\n"
"     of the physical address of the destination queue given in the <destination> subelement \r\n"
"     to the virtual directory on the intermediate host given in the <through> subelement.\r\n"
"\r\n"
"  <redirection>\r\n"
"      <destination>http://target_host/msmq/private$/destination_queue</destination>\r\n"
"      <through>http://intermediate_host/msmq</through> \r\n"
"  </redirection>\r\n"
"\r\n"
"  --> \r\n"
"\r\n"
"  <!--\r\n"
"     Limited use of regular expressions in a <destination> element is supported. \r\n"
"     Asterisk-terminated URLs can define a redirection of multiple physical addresses \r\n"
"     of destination queues to a single address of a virtual directory on a intermediate host.\r\n"
"\r\n"
"     In the following example, all messages sent using the HTTP protocol \r\n"
"     will be redirected through the intermediate host. \r\n"
"\r\n"
"  <redirection>\r\n"
"      <destination>http://*</destination>\r\n"
"      <through>http://intermediate_host/msmq</through> \r\n"
"  </redirection>\r\n"
"	--> \r\n"
"\r\n"
"  <!--\r\n"
"     Each <outbound_redirections> element may contain 0 or more <exception> subelements.\r\n"
"     You can use <exception> elements to exclude messages sent to specific queues from\r\n"
"     being redirected by <redirection> rules.  \r\n"
"     Limited use of regular expressions in an <exception> element is supported with the same \r\n"
"     restrictions as for the <destination> element above. \r\n"
"\r\n"
"     In the following example, all messages sent to private queues on special_host \r\n"
"     will not be redirected through the intermediate host. \r\n"
"\r\n"
"  <exception>http://special_host/msmq/private$/*</exception>\r\n"
"\r\n"
"     You can use the keyword 'local_names' to exclude messages sent to any internal (intranet) host \r\n"
"     from being redirected by <redirection> rules. \r\n"
"\r\n"
"     In the following example, no messages sent to internal hosts \r\n"
"     will be redirected through the intermediate host. \r\n"
"\r\n"
"  <exception>local_names</exception>\r\n"
"	--> \r\n"
"\r\n"	
"\r\n"
"</outbound_redirections>"
"\r\n";


const char xStreamReceiptSample[] = ""
"<!-- \r\n"
"     This is a sample XML file that demonstrates stream receipt redirection. \r\n"
"     Use it as a template to create your own stream receipt redirection files.\r\n"
"  -->\r\n"
"\r\n"
"\r\n"
"<StreamReceiptSetup xmlns=\"msmq-streamreceipt-mapping.xml\">\r\n"
"\r\n"
"<!-- \r\n"
"     Each <StreamReceiptSetup> element contains 0 or more <setup> subelements, \r\n"
"     each of which in turn contains exactly one <LogicalAddress> subelement and exactly \r\n"
"     one <StreamReceiptURL> subelement. Each <setup> elememt describes the URL \r\n"
"     to which a stream receipt is sent (<StreamReceiptURL>) when an SRMP \r\n"
"     message is sent to the logical URL specified in <LogicalAddress>. \r\n"
"\r\n"
"	  Each <setup> element also defines an implicit mapping that redirects every \r\n"
"     SRMP message arriving at the queue specified in <StreamReceiptURL> to the \r\n"
"     physical address of the local order queue.\r\n"
"\r\n"
"  <setup>\r\n"
"    <LogicalAddress>https://external_host/msmq/external_queue</LogicalAddress> \r\n"
"    <StreamReceiptURL>https://internal_host/msmq/virtual_order_queue</StreamReceiptURL>\r\n"
"  </setup>\r\n"
"  -->\r\n"
"\r\n"
"<!-- Limited use of regular expressions in <LogicalAddress> elements is supported. \r\n"
"     Asterisk-terminated URLs can define the use of a single stream receipt URL \r\n"
"     for multiple logical addresses.\r\n"
"\r\n"
"      In following example any message with a logical address that starts with \r\n"
"      the string http://external_host/* will use the stream receipt URL that \r\n"
"      is defined in the <StreamReceiptURL> element. \r\n"
"\r\n"
"  <setup>\r\n"
"    <LogicalAddress>http://external_host/*</LogicalAddress> \r\n"
"    <StreamReceiptURL>http://internal_host/msmq/virtual_order_queue</StreamReceiptURL>\r\n"
"  </setup>\r\n"
"  -->\r\n"
"\r\n"
"<!--\r\n"
"     Each <StreamReceiptSetup> element may contain one <default> element, which \r\n"
"     defines the default stream receipt URL that is used by the local \r\n"
"     MSMQ service in every outgoing streamed (transactional) SRMP message, \r\n"
"     unless the logical address of the message matches the <LogicalAdress> \r\n"
"     element in one of the <setup> elements. \r\n"
"\r\n"
"  <default>http://internal_host/msmq/virtual_order_queue</default>\r\n"
"  -->\r\n"
"</StreamReceiptSetup>"
"\r\n";
#endif // _MSMQ_MQMAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqversion.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mqversion.h

Abstract:

    MSMQ product version as returned by MSMQ API

Author:

    Shai Kariv (shaik) 24-Apr-2001

--*/

#ifndef _MQ_VERSION_H_
#define _MQ_VERSION_H_

//
// MSMQ major version as returned by MSMQ API
//
#define MSMQ_RMJ 3

//
// MSMQ minor version as returned by MSMQ API
//
#define MSMQ_RMM 0

#endif // _MQ_VERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqupgrd.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mqupgrd.h

Abstract:

    header for functions exported from  mqupgrd.dll

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#ifndef _MQUPGRD_H
#define _MQUPGRD_H

typedef HRESULT
    (APIENTRY *pfCreateMsmqObj_ROUTINE) (VOID);

typedef VOID (APIENTRY *RemoveStartMenuShortcuts_ROUTINE) (VOID);

typedef VOID (APIENTRY *CleanupOnCluster_ROUTINE) (LPCWSTR);

#endif //_MQUPGRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqtime.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqtime.h

Abstract:

    This header file contains definitions for message queue time handeling.

Author:

    Boaz Feldbaum (BoazF) 17 Jul, 1996

--*/

#ifndef _MQTIME_H_
#define _MQTIME_H_

/**************************************************************

  Function:
        MqSysTime

  Parameters:
        None.

  Description:
        The function returns the number of seconds passed from 
        January 1, 1970. 
        
        This function replaces the CRT function time(). time() 
        returns a different result during day light saving 
        time, depending on whether or not the system is set to 
        automatically adjust the time acording to the day light
        saving time period. 

**************************************************************/
inline ULONG MqSysTime()
{
    LARGE_INTEGER liSysTime;

    // Get the current system time in FILETIME format.
    GetSystemTimeAsFileTime((FILETIME*)&liSysTime);

    // GetSystemTimeAsFileTime() returns the system time in number 
    // of 100-nanosecond intervals since January 1, 1601. We
    // should return the number of seconds since January 1, 1970.
    // So we should subtract the number of 100-nanosecond intervals
    // since January 1, 1601 up until January 1, 1970, then divide
    // the result by 10**7.
    liSysTime.QuadPart -= 0x019db1ded53e8000;
    liSysTime.QuadPart /= 10000000;

    return(liSysTime.LowPart);
}

#endif // _MQTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mqutils.h

Abstract:

    Falcon helper functions and utilities

Author:

    Erez Haba (erezh) 16-Jan-96

Revision History:
--*/

#ifndef __MQUTILS_H
#define __MQUTILS_H

#include <mqsymbls.h>
#include <mqtypes.h>
#include <_guid.h>
#include <_propvar.h>
#include <_rstrct.h>
#include <_registr.h>
#include <_secutil.h>
#include <unknwn.h>
#include <cs.h>
#include <autorel.h>

MQUTIL_EXPORT
HRESULT
XactGetWhereabouts(
    ULONG     *pcbTmWhereabouts,
    BYTE      *ppbTmWhereabouts
    );


MQUTIL_EXPORT
HRESULT
XactGetDTC(
	IUnknown **ppunkDtc
    );

HRESULT 
MQUTIL_EXPORT 
APIENTRY 
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    );

HRESULT 
MQUTIL_EXPORT 
APIENTRY 
GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize
    );

bool
MQUTIL_EXPORT
APIENTRY
IsLocalSystemCluster(
    VOID
    );

HRESULT MQUTIL_EXPORT GetThisServerIpPort( WCHAR * pwcsIpEp, DWORD dwSize);

//
// Close debug window and debug threads
//
VOID APIENTRY ShutDownDebugWindow(VOID);


//
// MQUTIL_EXPORT_IN_DEF_FILE
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#ifdef _MQUTIL
#define MQUTIL_EXPORT_IN_DEF_FILE
#else
#define MQUTIL_EXPORT_IN_DEF_FILE  DLL_IMPORT
#endif

extern "C" DWORD  MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetOperatingSystem();
typedef DWORD   (APIENTRY *MSMQGetOperatingSystem_ROUTINE)        (VOID);

#endif // __MQUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqtg.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mqtrig.h

Abstract:
    MSMQ trigger, constant value

Author:
    Uri Habusha (urih) 26-Jun-2000

--*/

#pragma once

#ifndef __MQTRIG_H__
#define __MQTRIG_H__


const TCHAR xDefaultTriggersServiceName[] = L"MSMQTriggers";
const TCHAR xTriggersResourceType[] = L"MSMQTriggers";

const WCHAR xTriggersComplusApplicationName[] = L"MQTriggersApp";

const TCHAR xDefaultTriggersDisplayName[] = L"Message Queueing Triggers";

// Registry keys
#define REGKEY_TRIGGER_POS                 HKEY_LOCAL_MACHINE
const TCHAR REGKEY_TRIGGER_PARAMETERS[] = _T("Software\\Microsoft\\MSMQ\\Triggers");
const TCHAR REG_SUBKEY_CLUSTERED[] = _T("\\Clustered\\");
const TCHAR REG_SUBKEY_RULES[] = _T("Data\\Rules\\");
const TCHAR REG_SUBKEY_TRIGGERS[] = _T("Data\\Triggers\\");
const TCHAR REGISTRY_TRIGGER_MSG_PROCESSING_TYPE[] = _T("MsgProcessingType");


// Define the maximum size of a registry key (255 Unicode chars + null)
#define MAX_REGKEY_NAME_SIZE 512


// Configuration parameters
const TCHAR CONFIG_PARM_NAME_INITIAL_THREADS[] = _T("InitialThreads");
const TCHAR CONFIG_PARM_NAME_MAX_THREADS[] = _T("MaxThreads");
const TCHAR CONFIG_PARM_NAME_INIT_TIMEOUT[]	= _T("InitTimeout");
const TCHAR CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE[] = _T("DefaultMsgBodySize");
const TCHAR CONFIG_PARM_NAME_COMPLUS_INSTALLED[] = _T("ComplusCompInstalled");
const TCHAR CONFIG_PARM_NAME_CHANGE_TO_NETWORK_SERVICE[] = _T("ChangeToNetworkService");


// Define default values for some of the configuration parameters.
const DWORD CONFIG_PARM_DFLT_INITIAL_THREADS  = 5;
const DWORD CONFIG_PARM_DFLT_MAX_THREADS = 20;
const DWORD CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE = 2048;
const DWORD CONFIG_PARM_DFLT_INIT_TIMEOUT = 5*60000;
const DWORD CONFIG_PARM_DFLT_WRITE_TO_LOGQ =  0;

const DWORD CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED = 0;
const DWORD CONFIG_PARM_COMPLUS_INSTALLED = 1;

const DWORD CONFIG_PARM_DFLT_NETWORK_SERVICE = 0;
const DWORD CONFIG_PARM_CHANGE_TO_NETWORK_SERVICE = 1;


#ifdef _DEBUG
	const DWORD CONFIG_PARM_DFLT_PRODUCE_TRACE_INFO = 1;
#else
	const DWORD CONFIG_PARM_DFLT_PRODUCE_TRACE_INFO = 0;
#endif 

const DWORD xDefaultMsbBodySizeMaxValue = 4193000;  // (~ 4MB - 1000) 
const DWORD xMaxThreadNumber = 100;
const DWORD xMaxRuleNameLen = 128;
const DWORD xMaxRuleDescriptionLen = 255;
const DWORD xMaxRuleConditionLen = 512;
const DWORD xMaxRuleActionLen = 512;

//
// Define the delimiters used when expressing actions, conditions and conditional-values
//
const TCHAR xConditionDelimiter = _T('\t');
const TCHAR xActionDelimiter = _T('\t');

const TCHAR xConditionValueDelimiter = _T('=');
const TCHAR xActionValueDelimiter = _T('\t');

const TCHAR xCOMAction[] = _T("COM");
const TCHAR xEXEAction[] = _T("EXE");

// Define the constants that will be used to set the rule result flag
const LONG xRuleResultStopProcessing	= 1;
const LONG xRuleResultActionExecutedFailed = 2;


enum eConditionTypeId
{
    eMsgLabelContains = 0,
    eMsgLabelDoesNotContain,
    eMsgBodyContains,
    eMsgBodyDoesNotContain,
    ePriorityEquals,
    ePriorityNotEqual,
    ePriorityGreaterThan,
    ePriorityLessThan,
    eAppspecificEquals,
    eAppspecificNotEqual,
    eAppSpecificGreaterThan,
    eAppSpecificLessThan,
    eSrcMachineEquals,
    eSrcMachineNotEqual,
};


//
// Define the bstrs that represents message and / or trigger attributes
//
enum eInvokeParameters
{
    eMsgId = 0,
    eMsgLabel,
    eMsgBody,
    eMsgBodyAsString,
    eMsgPriority,
    eMsgArrivedTime,
    eMsgSentTime,
    eMsgCorrelationId,
    eMsgAppspecific,
    eMsgQueuePathName,
    eMsgQueueFormatName,
    eMsgRespQueueFormatName,
    eMsgDestQueueFormatName,
    eMsgAdminQueueFormatName,
    eMsgSrcMachineId,
    eMsgLookupId,
    eTriggerName,
    eTriggerId,
    eLiteralString,
    eLiteralNumber,
};


#endif // __MQTRIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqwin64.h ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64.h

Abstract:

    win64 related definitions for MSMQ (Enhanced), CANNOT be part of AC

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#ifndef _MQWIN64_H_
#define _MQWIN64_H_

#pragma once

#include <mqwin64a.h>

//
// we have code that needs the name of this file for logging (also in release build)
//
extern const __declspec(selectany) WCHAR s_FN_MQWin64[] = L"mqwin64.h";


//
// CAutoCloseHandle32
// on win64 it is much like CAutoCloseHandle, just based on HANDLE32 instead of HANDLE
// on win32 it is defined as to CAutoCloseHandle
//
#ifdef _WIN64
class CAutoCloseHandle32
{
public:
    CAutoCloseHandle32(HANDLE32 h = NULL) { m_h = h; };
    ~CAutoCloseHandle32() { if (m_h) CloseHandle(DWORD_TO_HANDLE(m_h)); };

public:
    CAutoCloseHandle32 & operator =(HANDLE32 h) {m_h = h; return *this; };
    HANDLE32 * operator &() { return &m_h; };
    operator HANDLE32() { return m_h; };
    operator HANDLE() { return DWORD_TO_HANDLE(m_h); };

private:
    HANDLE32 m_h;
};
#else //!_WIN64
#define CAutoCloseHandle32 CAutoCloseHandle
#endif //_WIN64

//
// mapping between a PTR and DWORD
//
#include <cs.h>

//
// the mapped DWORD looks like this:
// 0xABCDEFGH, where 0x00ABCDEF is the index into the mapping table, 0xGH is the generation of the entry
// The generation of the entry is incremented each time an entry is re-used (unless the table is shrinked,
// in which case when it grows up, it starts again with a zero generation), so that we can tell for
// a mapped DWORD whether it is still valid (e.g. belongs to the current generation), or an invalid DWORD
// (e.g. belongs to another generation)
//
#define DWCONTEXT_GENERATION(dwContext)      (BYTE)((DWORD)(dwContext) & 0x000000ff)
#define DWCONTEXT_INDEX(dwContext)           (DWORD)((DWORD)(dwContext) >> 8)
#define MAKE_DWCONTEXT(dwIndex, bGeneration) (DWORD)(((DWORD)(dwIndex) << 8) + (BYTE)((DWORD)(bGeneration) & 0x000000ff))
#define NEXT_GENERATION(bGeneration)         (BYTE)((DWORD)(bGeneration + 1) & 0x000000ff)
#define MAX_DWCONTEXT_TABLE_SIZE             0x00ffffff

//
// class CContextMap - Map between PVOID ptr and a DWORD value
//
class CContextMap
{
public:
    //
    //exceptions thrown
    //bad_alloc can also be thrown (from AddContext)
    //
    struct illegal_index : public std::exception {};  //CContextMap::illegal_index, from GetContext/DeleteContext.
														  // this can be thrown when the index is out of bounds, bad generation, 
														  // or the context pointed by it is empty (NULL).

    //
    // the functions are not defined virtual, but they can be if someone needs to inherit
    // from this class...there is no core problem regarding it, just need to remove the inline def from 
    // the function implementation
    //
    CContextMap();
    /*virtual*/ ~CContextMap();
    /*virtual*/ DWORD AddContext(PVOID pvContext
#ifdef DEBUG
                                 ,LPCSTR pszFile, int iLine
#endif //DEBUG
                                );
    /*virtual*/ PVOID GetContext(DWORD dwContext);
    /*virtual*/ void DeleteContext(DWORD dwContext);

protected:

    //
    // allocation control:
    //   e_GrowSize must be a power of 2
    //   e_ShrinkSize must be greater than e_GrowSize.
    //      if there are more than e_ShrinkSize empty entries at the end of the table, tha table is shortened
    // BUGBUG - need to come up with a better allocation/free mechanism that is not exponential in nature
    //
    enum {
        e_GrowSize = 16,
        e_ShrinkSize = 24
    };

    //
    // Entry in Map
    //
    typedef struct {
        PVOID pvContext;
        BYTE bGeneration;
#ifdef DEBUG
        LPCSTR pszFile;
        int iLine;
#endif //DEBUG
    } ContextEntry;

    /*virtual*/ ContextEntry * FindContext(DWORD dwContext);
    /*virtual*/ void Grow();
    /*virtual*/ void Shrink();
    /*virtual*/ void Reallocate(ULONG cContexts);

private:
    ULONG m_cContexts;
    ULONG m_idxTop;
    ContextEntry* m_pContexts;    
    ULONG m_cUsedContexts;
    CCriticalSection m_cs;
};

inline CContextMap::CContextMap()
{
    m_idxTop = 0;
    m_pContexts = NULL;
    m_cContexts = 0;
    m_cUsedContexts = 0;
}

inline CContextMap::~CContextMap()
{
	//
	// Note: these asserts are not necessary. There are possible situations
	// where the map is not empty on distruction. For example - when there are open
	// remote queues, and the service goes down.
	//
    //ASSERT(m_idxTop == 0);
    //ASSERT(m_cUsedContexts == 0);
    
	delete [] m_pContexts;
}

//
// AddContext
// returns a DWORD for the context ptr (actually its index in a table (1-based, not zero-based))
// throws a bad_alloc exception if it can't add the context ptr
//
inline DWORD CContextMap::AddContext(PVOID pvContext
#ifdef DEBUG
                              ,LPCSTR pszFile, int iLine
#endif //DEBUG
                              )
{
    ASSERT(pvContext != 0);
    CS lock(m_cs);
    //
    //  First look at top index
    //
    if(m_idxTop < m_cContexts)
    {
        ContextEntry * pEntry = &m_pContexts[m_idxTop];
        pEntry->pvContext = pvContext;
#ifdef DEBUG
        ASSERT(pEntry->pszFile == NULL);
        ASSERT(pEntry->iLine == 0);
        pEntry->pszFile = pszFile;
        pEntry->iLine = iLine;
#endif //DEBUG
        m_cUsedContexts++;
        m_idxTop++;
        return MAKE_DWCONTEXT(m_idxTop, pEntry->bGeneration);
    }
    //
    //  Look for a hole in the already allocated table
    //
    if (m_cUsedContexts < m_cContexts)
    {
        for(ULONG idx = 0; idx < m_cContexts; idx++)
        {
           if(m_pContexts[idx].pvContext == NULL)
           {
               ContextEntry * pEntry = &m_pContexts[idx];
               pEntry->pvContext = pvContext;
#ifdef DEBUG
               ASSERT(pEntry->pszFile == NULL);
               ASSERT(pEntry->iLine == 0);
               pEntry->pszFile = pszFile;
               pEntry->iLine = iLine;
#endif //DEBUG
               m_cUsedContexts++;
               return MAKE_DWCONTEXT(idx + 1, pEntry->bGeneration);
           }
        }
        //
        // we should not get here, we must find a hole when m_cUsedContexts < m_cContexts
        //
        ASSERT(0);
    }
    //
    //  No free entry, grow the table
    //
    Grow(); //this can throw bad_alloc
    ASSERT(m_idxTop < m_cContexts);
    //
    //  Fill top index
    //
    ContextEntry * pEntry = &m_pContexts[m_idxTop];
    pEntry->pvContext = pvContext;
#ifdef DEBUG
    ASSERT(pEntry->pszFile == NULL);
    ASSERT(pEntry->iLine == 0);
    pEntry->pszFile = pszFile;
    pEntry->iLine = iLine;
#endif //DEBUG
    m_cUsedContexts++;
    m_idxTop++;
    return MAKE_DWCONTEXT(m_idxTop, pEntry->bGeneration);
}

//
// GetContext
// returns the PVOID ptr that is saved for the DWORD context
// throws a CContextMap::illegal_index exception if it can't find the context ptr
//
inline PVOID CContextMap::GetContext(DWORD dwContext)
//
//
{
    CS lock(m_cs);
    //
    // Find context entry
    //
    ContextEntry * pEntry = FindContext(dwContext); //this may throw
    return pEntry->pvContext;
}

//
// DeleteContext
// deletes the PVOID ptr that is saved for the DWORD context
// throws a CContextMap::illegal_index exception if it can't find the context ptr
//
inline void CContextMap::DeleteContext(DWORD dwContext)
{
    CS lock(m_cs);
    //
    // Find context entry
    //
    ContextEntry * pEntry = FindContext(dwContext); //this may throw
    //
    // delete the reference
    // increment the generation in preparation for entry re-use later
    //
    pEntry->pvContext = NULL;
    pEntry->bGeneration = NEXT_GENERATION(pEntry->bGeneration);
#ifdef DEBUG
    pEntry->pszFile = NULL;
    pEntry->iLine = 0;
#endif //DEBUG
    m_cUsedContexts--;
    //
    // set new top
    //
    if (DWCONTEXT_INDEX(dwContext) == m_idxTop)
    {
        m_idxTop--;
        while (m_idxTop > 0)
        {
            if (m_pContexts[m_idxTop - 1].pvContext == NULL)
            {
                m_idxTop--;
            }
            else
            {
                break;
            }
        }
    }
    //
    // try to shrink
    //        
    Shrink();
}

inline CContextMap::ContextEntry * CContextMap::FindContext(DWORD dwContext)
{
    DWORD dwIndex = DWCONTEXT_INDEX(dwContext);
    //
    // check index valid
    //
    if ((dwIndex < 1) || (dwIndex > m_idxTop))
    {
        //
        // Illegal index, throw an exception
        //
        throw CContextMap::illegal_index();
    }
    CContextMap::ContextEntry * pEntry = &m_pContexts[dwIndex - 1];
    //
    //  check context generation
    //
    BYTE bGeneration = DWCONTEXT_GENERATION(dwContext);
    if (bGeneration != pEntry->bGeneration)
    {
        //
        // Invalid generation, dwContext uses a different generation than this entry, throw an exception
        //
        throw CContextMap::illegal_index();
    }
    //
    //  check context valid
    //
    if (pEntry->pvContext == NULL)
    {
        //
        // Illegal context.
        // Cannot differentiate illegal index from illegal context. illegal context can happen because of
        // an illegal index, and an illegal index can be caused by a deleted context (e.g. illegal context)
        // and the table being shortened.
        // throw an exception
        //
        ASSERT_BENIGN(0);
        throw CContextMap::illegal_index();
    }
    return pEntry;
}

inline void CContextMap::Grow()
{
    ASSERT(m_cUsedContexts == m_cContexts);
    ASSERT(m_idxTop == m_cContexts);
    Reallocate(m_cContexts + e_GrowSize); //this may throw
}

#define ALIGNUP_ULONG(x, g) (((ULONG)((x) + ((g)-1))) & ~((ULONG)((g)-1)))

inline void CContextMap::Shrink()
{
    if((m_cContexts - m_idxTop) >= e_ShrinkSize)
    {
        try
        {
            Reallocate(ALIGNUP_ULONG(m_idxTop + 1, e_GrowSize));
        }
        catch(const std::bad_alloc&)
        {
            //
            // allocation of smaller table failed, no problem, we can still use the existing larger table
            //
        }
    }
}

inline void CContextMap::Reallocate(ULONG cContexts)
{
    ASSERT(m_idxTop <= cContexts);
    ASSERT(cContexts != m_cContexts);
    //
    // check size of new table
    //
    if (cContexts > MAX_DWCONTEXT_TABLE_SIZE)
    {
        //
        // New table will be too large, indexes may not fit into the index mask in the mapped dword
        //
        ASSERT(0);
        throw std::bad_alloc();
    }
    //
    // alloc new table
    //
    ContextEntry* pContexts = new ContextEntry[cContexts]; //this may throw bad_alloc
    if(pContexts == NULL)
    {
        ASSERT(0);
        throw std::bad_alloc();
    }
    memcpy(pContexts, m_pContexts, m_idxTop*sizeof(ContextEntry));
    memset(pContexts + m_idxTop, 0, (cContexts - m_idxTop)*sizeof(ContextEntry));
    m_cContexts = cContexts;
    delete [] m_pContexts;
    m_pContexts = pContexts;
}

//
// Several wrappers to CContextMap that also do MSMQ logging, exception handling etc...
//
// Not inline because they may be called from a function with a different
// exception handling mechanism. We might want to introduce _SEH functions for use from SEH routines
// Implementation is in mqwin64.cpp
//

//
// MQ_AddToContextMap, can throw bad_alloc
//
DWORD MQ_AddToContextMap(CContextMap& map,
                          PVOID pvContext
#ifdef DEBUG
                          ,LPCSTR pszFile, int iLine
#endif //DEBUG
                         );

//
// MQ_DeleteFromContextMap, doesn't throw exceptions
//
void MQ_DeleteFromContextMap(CContextMap& map, DWORD dwContext);

//
// MQ_GetFromContextMap, can throw CContextMap::illegal_index
//
PVOID MQ_GetFromContextMap(CContextMap& map,  DWORD dwContext);

//
// ADD_TO_CONTEXT_MAP
//
//
// It adds a context ptr to a map, and returns its id as a DWORD
// On debug we also save the file/line with the context
//
#ifdef DEBUG
#define ADD_TO_CONTEXT_MAP(map, pvContext) MQ_AddToContextMap(map, pvContext, __FILE__, __LINE__)
#else //!DEBUG
#define ADD_TO_CONTEXT_MAP(map, pvContext) MQ_AddToContextMap(map, pvContext)
#endif //DEBUG


//
// DELETE_FROM_CONTEXT_MAP
//

//
// It deletes the mapping betweeb a DWORD and a context ptr, based on the dword value
//
#define DELETE_FROM_CONTEXT_MAP(map, dwContext) MQ_DeleteFromContextMap(map, dwContext)


//
// GET_FROM_CONTEXT_MAP
//
//
// It gets the associated context based on the DWORD id value
//
#define GET_FROM_CONTEXT_MAP(map, dwContext) MQ_GetFromContextMap(map, dwContext)


//
// CAutoDeleteDwordContext
//
class CAutoDeleteDwordContext
{
public:
    inline CAutoDeleteDwordContext(CContextMap &map, DWORD dwContext)
    {
        m_pmap = &map;
        m_dwContext = dwContext;
    };
    
    inline ~CAutoDeleteDwordContext()
    {
        if (m_dwContext)
        {
            try
            {
                m_pmap->DeleteContext(m_dwContext);
            }
            catch(const exception&)
            {
                //
                // ignore errors
                //
            }
        }
    }

    inline DWORD detach()
    {
        DWORD dwContext = m_dwContext;
        m_dwContext = 0;
        return dwContext;
    };

private:
    CContextMap *m_pmap;
    DWORD m_dwContext;
};

#endif //_MQWIN64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqwin64a.h ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64a.h

Abstract:

    win64 related definitions for MSMQ (Basic), suitable for AC as well

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#pragma once

#ifndef _MQWIN64A_H_
#define _MQWIN64A_H_

#include <basetsd.h>

//
// Low and High dwords of DWORD64
//
#define HIGH_DWORD(dw64) PtrToUlong((void*)((DWORD64)(dw64) >> 32))
#define LOW_DWORD(dw64)  PtrToUlong((void*)((DWORD64)(dw64) & (DWORD64)0xffffffff))

//
// MQPtrToUlong, wrapper for PtrToUlong, just for debugging
//
#ifdef DEBUG
//
// in DEBUG, we may want to see the DWORD64 value after an ASSERT jumps, so we convert the
// value in a function. It cannot be inline, if it is, the compiler complains in the macro
// UINT64_TO_UINT below
// Make sure high dword is 0, or a sign extension of low dword
//
inline unsigned long MQPtrToUlong(UINT64 uintp)
{
  ASSERT((HIGH_DWORD(uintp) == 0) ||
                 ((HIGH_DWORD(uintp) == 0xffffffff) && ((INT)LOW_DWORD(uintp) < 0))
        );
  return PtrToUlong((void *)uintp);
}
#else //!DEBUG
//
// just define MQPtrToUlong as a macro, anyway we would not be able to view the 64 bit value
//
#define MQPtrToUlong(uintp) PtrToUlong((void *)(uintp))
#endif //DEBUG

//
// Safe truncations from 64 bit to 32 bit
//
#define UINT64_TO_UINT(uintp)    MQPtrToUlong((UINT64)(uintp))
#define INT64_TO_INT(intp)       ((INT)UINT64_TO_UINT(intp))

//
// INT_PTR_TO_INT, UINT_PTR_TO_UINT
//
#ifdef _WIN64
//
// Win64, xxx_PTR are 64 bits, truncate to 32 bit
//
#define INT_PTR_TO_INT(intp)     INT64_TO_INT(intp)
#define UINT_PTR_TO_UINT(uintp)  UINT64_TO_UINT(uintp)
#else //!_WIN64
//
// Win32, xxx_PTR are 32 bits, no truncations needed
//
#define INT_PTR_TO_INT(intp) (intp)
#define UINT_PTR_TO_UINT(uintp) (uintp)
#endif //_WIN64

//
// BOOL_PTR
//
#ifndef BOOL_PTR
#define BOOL_PTR INT_PTR
#endif //BOOL_PTR

//
// DWORD_PTR_TO_DWORD
//
#define DWORD_PTR_TO_DWORD(dwp) UINT_PTR_TO_UINT(dwp)

//
// DWORD_TO_DWORD_PTR
//
#define DWORD_TO_DWORD_PTR(dw) ((DWORD_PTR)(UlongToPtr((DWORD)(dw))))

//
// HANDLE_TO_DWORD
// NT handles can be safely cast to 32 bit DWORD
//
#define HANDLE_TO_DWORD(hndl) DWORD_PTR_TO_DWORD(hndl)

//
// DWORD_TO_HANDLE
// from 32 bit DWORD back to NT handle (need to sign extend the dword)
//
#define DWORD_TO_HANDLE(dw) LongToPtr((long)(dw))

//
// MQLoWord, wrapper for LOWORD, just for debugging
//
#ifdef DEBUG
//
// in DEBUG, we may want to see the DWORD value after an ASSERT jumps, so we convert the
// value in a function. It cannot be inline, if it is, the compiler complains in the macro
// DWORD_TO_WORD below
// Make sure high word is 0, or a sign extension of low word
//
inline WORD MQLoWord(DWORD dw)
{
  ASSERT((HIWORD(dw) == 0) ||
                 ((HIWORD(dw) == 0xffff) && ((SHORT)LOWORD(dw) < 0))
         );
  return LOWORD(dw);
}
#else //!DEBUG
//
// just define MQLoWord as a macro, anyway we would not be able to view the DWORD value
//
#define MQLoWord(dw) LOWORD(dw)
#endif //DEBUG

//
// DWORD_TO_WORD
// Not really related to 64 bit, but needed to remove some warnings
// Safe truncations from 32 bit to 16 bit
//
#define DWORD_TO_WORD(dw) MQLoWord(dw)

//
// TIME32 - 32 bit time (what used to be time_t in win32). BUGBUG bug year 2038
//
#ifndef TIME32
#ifdef _WIN64
#define TIME32 long
#else //!_WIN64
#define TIME32 time_t
#endif //_WIN64
#else //TIME32
#error TIME32 already defined
#endif //TIME32

//
// HACCursor32 - 32 bit AC Cursor (used to be HANDLE in win32)
//
#ifdef _WIN64
#define HACCursor32 ULONG
#else //!_WIN64
#define HACCursor32 HANDLE
#endif //_WIN64

//
// HANDLE32 - 32 bit handle (what used to be HANDLE in win32)
//
#ifndef HANDLE32
#ifdef _WIN64
#define HANDLE32 long
#else //!_WIN64
#define HANDLE32 HANDLE
#endif //_WIN64
#else //HANDLE32
#error HANDLE32 already defined
#endif //HANDLE32


//
// PTR_TO_PTR32
// Truncate PTR32 to PTR
//
#ifdef _WIN64
template <class T>
inline T* POINTER_32 PTR_TO_PTR32(T* pT)
{
  return (T* POINTER_32)(INT_PTR_TO_INT(pT));
}
#endif //_WIN64

//
// ComparePointersAVL (positive if p1 > p2, negative if p1 < p2, zero if p1 == p2)
//
inline int ComparePointersAVL(PVOID p1, PVOID p2)
{
#ifdef _WIN64
   INT_PTR iDiff = (INT_PTR)p1 - (INT_PTR)p2;
   if (iDiff > 0)        //p1 > p2
   {
      return 1;
   }
   else if (iDiff < 0)   //p1 < p2
   {
      return -1;
   }
   else //iDiff == 0       p1 == p2
   {
      return 0;
   }
#else //!_WIN64
   return ((int)p1 - (int)p2);
#endif //_WIN64
}

//
// VT_INTPTR, V_INTPTR, V_INTPTR_REF
//
#ifdef _WIN64
#define VT_INTPTR        VT_I8
#define V_INTPTR(X)      V_I8(X)
#define V_INTPTR_REF(X)  V_I8REF(X)
#else //!_WIN64
#define VT_INTPTR        VT_I4
#define V_INTPTR(X)      V_I4(X)
#define V_INTPTR_REF(X)  V_I4REF(X)
#endif //_WIN64

#endif //_MQWIN64A_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mqwin64.cpp ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64.cpp

Abstract:

    win64 related code for MSMQ (Enhanced), cannot be part of AC
    this file needs to be included once for inside a module that uses the functions below

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#ifndef _MQWIN64_CPP_
#define _MQWIN64_CPP_

#pragma once

#include <mqwin64.h>

//
// We have code that needs the name of this file for logging (also in release build)
//
const WCHAR s_FN_MQWin64_cpp[] = L"mqwin64.cpp";

//
// Several wrappers to CContextMap that also do MSMQ logging, exception handling etc...
//
// Not inline because they may be called from a function with a different
// exception handling mechanism. We might want to introduce _SEH functions for use from SEH routines
//

//
// external function for logging
//
void LogIllegalPointValue(DWORD_PTR dw3264, LPCWSTR wszFileName, USHORT usPoint);

//
// MQ_AddToContextMap, can throw bad_alloc
//
DWORD MQ_AddToContextMap(CContextMap& map,
                          PVOID pvContext
#ifdef DEBUG
                          ,LPCSTR pszFile, int iLine
#endif //DEBUG
                         )
{
    DWORD dwContext;
    ASSERT(pvContext != NULL);
    dwContext = map.AddContext(pvContext
#ifdef DEBUG
                                   , pszFile, iLine
#endif //DEBUG
                                  );
    //
    // everything is OK, return context dword
    //
    ASSERT(dwContext != 0);
    return dwContext;
}

//
// MQ_DeleteFromContextMap, doesn't throw exceptions
//
void MQ_DeleteFromContextMap(CContextMap& map, DWORD dwContext)
{
    map.DeleteContext(dwContext);
}

//
// MQ_GetFromContextMap, can throw CContextMap::illegal_index
//
PVOID MQ_GetFromContextMap(CContextMap& map, DWORD dwContext)
{
    PVOID pvContext = map.GetContext(dwContext);
    ASSERT(pvContext != NULL);
    return pvContext;    
}

#endif //_MQWIN64_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\perfdata.h ===
//*********************************************************************
//*
//* perfdata.h
//*
//*********************************************************************

#ifndef _PERFDATA_H
#define _PERFDATA_H

#include <winperf.h>
#include "perfctr.h"


#include "mqprfsym.h" /* a file which holds the index's for the name's and help's (this is the same file
                        used in the .INI file for the lodctl utility */

/*
 * Maximum number of queues and sessions that can be monitored.
 *
 * 97 queues and 20 sessions sums up to just a little less than 16K (4 pages).
 * When modifying these constants, see that you use all the allocated pages
 * as much as possible.
 *
 * Use the following to calculate the required memmoey size:
 *
 *      NCQM -  Number of performance counters per QM object (9)
 *      S -     Number monitored of sessions (20)
 *      NCS -   Number of performance counters per session (8)
 *      Q -     Number of queues (97)
 *      NCQ -   Number of performance counters per queue (4)
 *      NCDS -  Number of performance counters per DS object (7)
 *
 *      MemSize = S*(NCS*4 + 108) + Q*(NCQ*4 + 108) + (NCS + NCQ)*40 +
 *                (MCQM + NCDS)*44 + 264
 *
 * Currently the above computes to 16276.
 *
 */
#define MAX_MONITORED_QUEUES    97
#define MAX_MONITORED_SESSIONS  20


/* The object array*/
extern PerfObjectDef ObjectArray [];
extern DWORD dwPerfObjectsCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\msmq.inc ===
############################################################################
#
#   Copyright (C) 2000, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the MSMQ project
#   under the NT build environment. It should be included into the sources
#   file of any component with a line of the form
#
#   !include $(FROOT)\src\inc\msmq.inc
#
############################################################################

#
# "C" functions can throw exceptions, don't optimize.
#
USER_C_FLAGS=$(USER_C_FLAGS) /EHc-

#
# Add stack overrun checks (-GS)
#
BUFFER_OVERFLOW_CHECKS=1

#
# Set highest warning level
#
MSC_WARNING_LEVEL=/W4

#
# Use the DLL version of the C runtime libraries
#
USE_MSVCRT=1

#
# Use C++ Standard Template Libraries
#
USE_STL=1

#
# Use C++ exception handling (/GX)
#
USE_NATIVE_EH=1

#
# Include all windows headers
#
NOT_LEAN_AND_MEAN=1

#
# Set compilation to Unicode
#
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

#
# Set to debug/checked build
#
!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /D_DEBUG
!ENDIF

#
# Temporary set for checked builds
#
!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /D_CHECKED
!ENDIF

#
# make dlldata.c file name prefixed by the name of the idl file.
#
USE_IDLBASED_DLLDATA=1

#
# Set MC flags so it gives unique names instead of MSG00001.bin (to avoid MP collisions)
#
MC_FLAGS=-b

#
# Set default location for pass 0 generated files.
# Use the same defaults as in inetsrv
#
MC_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
PASS0_CLIENTDIR=$(O)
PASS0_SERVERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)

#
# When MQBSC is defined, Generate browser files
#
!IF "$(MQBSC)" == ""
NO_BROWSER_FILE=1
!ELSE
BROWSER_INFO=1
!ENDIF

#
# When MQT is defined, build verbose version (with TALK compiled)
#
!IF "$(MQT)" != ""
C_DEFINES=$(C_DEFINES) /D_TOOL
!ENDIF

#
# The MSMQ libraries include path
#
MSMQ_LIBINC_PATH=$(FROOT)\src\lib\inc

#
# The MSMQ include path
#
MSMQ_INC_PATH=$(FROOT)\src\inc

#
# The MSMQ generated files path
#
MSMQ_BINS_PATH=$(FROOT)\src\bins\$(O)

#
# The Stack allocation library include and library path
#
ALLOCA_INC_PATH=$(BASEDIR)\public\internal\ds\inc
ALLOCA_LIB_PATH=$(BASEDIR)\public\internal\ds\lib


#
# We need mfc42 for RC compilations that include afxres.h, however, we need it last so we can
# override it, that is why we don't use MFC_INCLUDES
#
# SDK_LIB_PATH is included to grant access to stdole32.tlb
#
INCLUDES=$(MSMQ_LIBINC_PATH);$(MSMQ_INC_PATH);$(MSMQ_BINS_PATH);$(SDK_LIB_PATH);$(SDK_INC_PATH)\mfc42;$(ALLOCA_INC_PATH)

#
# We want to keep checked results in objd directory
#
CHECKED_ALT_DIR=1

#
# Genereate Codeview and NTSD debug information, make PDB files
#
NTDEBUGTYPE=both
USE_PDB=1

#
# The MSMQ library path
#
MSMQ_LIB_PATH=$(FROOT)\src\lib\$(O)

#
# Set MSMQ version file
#
MASTER_VERSION_FILE=$(FROOT)\src\inc\version.h

#
# Set all-bins target directory
#
ALL_BINS=$(FROOT)\src\bins\$(_OBJ_DIR)

#
# Remove build noise with -D on header without .h suffix
#
CONDITIONAL_INCLUDES=\
    $(CONDITIONAL_INCLUDES) \
    new list map set algorithm string iostream vector sstream iomanip functional fstream limits utility \
    winwlm.h rpcmac.h rpcerr.h macpub.h macapi.h macname1.h macname2.h macocidl.h \
    ntamd64.h \

#
# Enable Wpp tracing porcessor
#
RUN_WPP=\
    $(SOURCES) \
    -noshrieks \
    -gen:{$(FROOT)\src\inc\msmqwpp.tpl}*.tmh \
    -ini:$(FROOT)\src\inc\msmqwpp.ini \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\perfctr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfctr.h

Abstract    :

This file defines the functions and data structers needed to add counter objects and counters to the
performance monitor.

The user will specify in advance the counter objects and their counters in an include file named perfdata.h

The counter objects will be stored in an  array.
For each counter object the user will specify :

    a) The name of the object.
    b) The maximum number of instances the object will have.
    c) The number of counters for the object.
    d) An array of counters for the object.
    e) The objects name index as specified in the .ini file that was passed to 'lodctr' utility.
    f) The objects help index as specified in the .ini file that was passed to 'lodctr' utility.


Counters will be stored in an array.
For each counter the user will supply the following entries:

    a) The counters name index as specified in the .ini file that was passed to 'lodctr' utility.
    b) The counters help index as specified in the .ini file that was passed to 'lodctr' utility.
    c) The scale for the counter (this value is the power of 10 that will be used to scale the counter)
    d) The counter type. Counter types can be found in winperf.h. Note that you can use only 32 Bit counters
       with this library.Also counters that need their own time measurement can not be used.


Data organization in shared memory of objects
Objects will be stored in a block of shared memory.
Each object will be allocated sapce in the shared memory block with the following organization;

PERF_OBJECT_TYPE (performance monitor definition of object counter)

    1 PERF_COUNTER_DEFINITION (performance monitor definition of counter)
    .
    .
    .
    N PERF_COUNTER_DEFINITION

    1 instance definition
        PERF_INSTANCE_DEFINITION (performance monitor definition of instance)
        Instance name
        PERF_COUNTER_BLOCK  (number of counters)
        Counter data -----> The user will be given a direct pointer to this array for fast updates

    2 instance definition
    .
    .
    .
    N instance definition

    This layout is the exact lay out that is passed to the performance monitor so when the DLL will be sampled
    all it will need to do is copy this definition for each object into the buffer passed by the performance
    monitor.

    To simplify the code all instance names will have a fixed length of INSTANCE_NAME_LEN characters
    Since the users access the counters directly we can't change the address of the counters.
    When an instance is deleted its entry will be filled with a INVALID_INSTANCE_CODE code.
    New allocations of instances will be added to the first free block.

    The functions which removes and add instances are protected by critical sections so multiple
    threads may be used to add and remove instances.

    There is include file named perfdata.h. In this file global data that is used by the application and the DLL
    is defined.After this file is modified the DLL should be recompiled.




Prototype   :

Author:

    Gadi Ittah (t-gadii)

--*/

#ifndef _PERFCTR_H_
#define _PERFCTR_H_


#include <winperf.h>

#define INSTANCE_NAME_LEN 64
#define INSTANCE_NAME_LEN_IN_BYTES (INSTANCE_NAME_LEN * sizeof(WCHAR))

#define IN
#define OUT

// some defiens used to signal the objects state
#define PERF_INVALID        0xFEFEFEFE
#define PERF_VALID          0xCECECECE

typedef struct _PerfCounterDef
{
    DWORD dwCounterNameTitleIndex;  // The counters name index
    DWORD dwCounterHelpTitleIndex;  // The counters help index (for the NT perforamce monitor this value is
                                    // identical to the name index)
    DWORD dwDefaultScale;           // The scale for the counter (in powers of 10)
    DWORD dwCounterType;            // The counter type.
} PerfCounterDef;

typedef struct _PerfObjectDef
{
   LPTSTR   pszName;                    // name of object must be uniqe
   DWORD    dwMaxInstances;             // the maximum number of instances this object will have
   DWORD    dwObjectNameTitleIndex;     // The objects name index.
   DWORD    dwObjectHelpTitleIndex;     // The objects help index.
   PerfCounterDef * pCounters;          // A pointer to the objects array of counters
   DWORD    dwNumOfCounters;            // The number of counters for the object

} PerfObjectDef;


typedef struct _PerfObjectInfo
{

   DWORD    dwNumOfInstances;   // the number of instances the object has
   PVOID    pSharedMem;         // A pointer to the objects postion in shared memory
} PerfObjectInfo;


// some macros to make code more readable

#define COUNTER_BLOCK_SIZE(NumCounters) sizeof (DWORD)* (NumCounters)+sizeof (PERF_COUNTER_BLOCK)

#define INSTANCE_SIZE(NumCounters) (sizeof (DWORD)* NumCounters+ \
                                    sizeof (PERF_COUNTER_BLOCK)+ \
                                    INSTANCE_NAME_LEN_IN_BYTES+  \
                                    sizeof (PERF_INSTANCE_DEFINITION))

#define OBJECT_DEFINITION_SIZE(NumCounters) (sizeof (PERF_OBJECT_TYPE)+\
                                             NumCounters*sizeof(PERF_COUNTER_DEFINITION))



// Functions that are used by the DLL and the application

void MapObjects (BYTE * pSharedMemBase,DWORD dwObjectCount,PerfObjectDef * pObjects,PerfObjectInfo * pObjectDefs);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phbase.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phbase.h

Abstract:

    Falcon Packet header base

Author:

    Uri Habusha (urih) 1-Feb-96

--*/

#ifndef __PHBASE_H
#define __PHBASE_H

#include <mqprops.h>

//
// Packet Version
//
#define FALCON_PACKET_VERSION 0x10

#define FALCON_USER_PACKET     0x0
#define FALCON_INTERNAL_PACKET 0x1

//
//  BUGBUG: FALCON_SIGNATURE is none portable
//
#define FALCON_SIGNATURE       'ROIL'

//
//  define INFINITE for infinite timeout
//  It is defined here since it is not defined in the DDK
//  INFINITE is defined in winbase.h
//

#ifndef INFINITE
#define INFINITE            0xFFFFFFFF  // Infinite timeout
#endif

/*+++

    Packet Base header, used in INTERNAL and USER packets.

+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Version number | Version number is used to identify the  packet format.| 1 byte   |
+----------------+-------------------------------------------------------+----------+
|OnDisk Signature| Signature that is kept on disk only.                  | 1 bytes  |
+----------------+-------------------------------------------------------+----------+
| Flags          | The flag field is a bit map indicating                | 2 bytes  |
|                | format and inclusion of other data sections in        |          |
|                | the packet.                                           |          |
|                |                                                       |          |
|                |  1 1 1 1 1 1                                          |          |
|                |  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0                      |          |
|                | +---------+-+---+-+-+-+-+-+-----+                     |          |
|                | |0 0 0 0 0|F|T T|R|A|D|S|I|P P P|                     |          |
|                | +---------+-+---+-+-+-+-+-+-----+                     |          |
|                |                                                       |          |
|                | Bits                                                  |          |
|                | 0:2      Packet priority (0 to 7,  7 is high)         |          |
|                |                                                       |          |
|                | 3        Internal packet                              |          |
|                |              0 - Falcon user packet                   |          |
|                |              1 - Falcon internal packet               |          |
|                |                                                       |          |
|                | 4        Session information indication               |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 5        Debug section indication                     |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 6        ACK on receiving.                            |          |
|                |              0 - No immediate ACK                     |          |
|                |              1 - immediate ACK                        |          |
|                |                                                       |          |
|                | 7        Reserved (was: Duplicate packet)             |          |
|                |              0 - No duplicate, first transmition.     |          |
|                |              1 - Possibly duplicate packet.           |          |
|                |                                                       |          |
|                | 8:9      Trace Packet                                 |          |
|                |              0 - Don't strore tracing information     |          |
|                |              1 - Strore tracing information           |          |
|                |                                                       |          |
|                | 10       Packet fragmentation                         |          |
|                |              0 - Packet is not a fragmented           |          |
|                |              1 - Packet is fragmented                 |          |
|                |                                                       |          |
|                | 11:15    Reserved, MUST be set to zero                |          |
+----------------+-------------------------------------------------------+----------+
| Signature/CRC  |                                                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Packet size    | The size of packet in bytes.                          | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
|Absolute Time2Q | on disk: Absolute time, on wire: Relative time        | 4 bytes  |
+----------------+-------------------------------------------------------+----------+

---*/




#pragma pack(push,1)

//
// struct CBaseHeader
//

struct CBaseHeader {
public:

    inline CBaseHeader(ULONG ulPacketSize);

    static ULONG CalcSectionSize(void);
    inline PCHAR GetNextSection(void) const;

    inline void  SetPacketSize(ULONG ulPacketSize);
    inline ULONG GetPacketSize(void) const;

    inline UCHAR GetVersion(void) const;
    inline BOOL  VersionIsValid(void) const;

    inline BOOL  SignatureIsValid(void) const;
	inline void  SetSignature(void);

    inline void  SetPriority(UCHAR bPriority);
    inline UCHAR GetPriority(void) const;

    inline void SetType(UCHAR bType);
    inline UCHAR GetType(void) const;

    inline void IncludeSession(BOOL);
    inline BOOL SessionIsIncluded(void) const;

    inline void IncludeDebug(BOOL);
    inline BOOL DebugIsIncluded(void) const;

    inline void SetImmediateAck(BOOL);
    inline BOOL AckIsImmediate(void) const;

    inline void  SetTrace(USHORT);
    inline USHORT GetTraced(void) const;

    inline void SetFragmented(BOOL);
    inline BOOL IsFragmented(void) const;

    inline void  SetAbsoluteTimeToQueue(ULONG ulTimeout);
    inline ULONG GetAbsoluteTimeToQueue(void) const;

	inline PUCHAR GetCRCBuffer();
	inline GetCRCBufferSize();
	inline void SetCRC(ULONG ulCRC);
	inline ULONG GetCRC();
	inline BOOL ValidCRC(ULONG ulCRC);
	inline void SetOnDiskSignature();
	inline void ClearOnDiskSignature();
	inline BOOL ValidOnDiskSignature();

	void SectionIsValid(DWORD MessageSizeLimit, bool ValidateSig = true) const;
	inline const PCHAR GetPacketEnd() const;

	template <class SECTION_PTR> SECTION_PTR section_cast(void* pSection) const
	{
			SECTION_PTR tmp;		  

			const PCHAR PacketEnd =  GetPacketEnd();
			if(reinterpret_cast<PCHAR>(pSection) + sizeof(*tmp) >  PacketEnd)
			{
				ReportAndThrow("section_cast: buffer to small for casting");
			}


			const PCHAR PacketStart =  GetPacketStart();
			if(pSection <  PacketStart)
			{
				ReportAndThrow("section_cast: section is before packet start");
			}

	  	
			return reinterpret_cast<SECTION_PTR>(pSection);
	}


private:
	inline const PCHAR GetPacketStart() const;

private:

//
// BEGIN Network Monitor tag
//
    UCHAR  m_bVersion;
    UCHAR  m_bOnDiskSignature;
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfPriority : 3;
            USHORT m_bfInternal : 1;
            USHORT m_bfSession  : 1;
            USHORT m_bfDebug    : 1;
            USHORT m_bfAck      : 1;
            USHORT m_bfReserved : 1; // was m_bfDuplicate now obsolete
            USHORT m_bfTrace    : 2;
            USHORT m_bfFragment : 1;
        };
    };

	union {
		ULONG m_ulSignature;
		ULONG m_ulCRC;
	};
	
	ULONG  m_ulPacketSize;
    ULONG  m_ulAbsoluteTimeToQueue;
//
// END Network Monitor tag
//
};

#pragma pack(pop)




/*======================================================================

 Function:      CBaseHeader::CBaseHeader

 Description:   Packet contructor

 =======================================================================*/
inline CBaseHeader::CBaseHeader(ULONG ulPacketSize) :
    m_bVersion(FALCON_PACKET_VERSION),
    m_wFlags(DEFAULT_M_PRIORITY),
    m_ulSignature(FALCON_SIGNATURE),
    m_ulPacketSize(ulPacketSize),
    m_ulAbsoluteTimeToQueue(INFINITE)
{
    SetType(FALCON_USER_PACKET);
}



/*===========================================================

  Routine Name: CBaseHeader::GetPacketEnd

  Description:  Calculate the pointer after the packet end.

  Arguments:

  Return Value:

=============================================================*/
inline const PCHAR CBaseHeader::GetPacketEnd() const
{
	const PCHAR pPachetStart = (PCHAR)this;
	const PCHAR pPacketEnd = pPachetStart + GetPacketSize();
	return pPacketEnd;	
}


/*===========================================================

  Routine Name: CBaseHeader::GetPacketStart

  Description:  Return	pointer to packet start.

  Arguments:

  Return Value:

=============================================================*/
inline const PCHAR CBaseHeader::GetPacketStart() const
{
	return (PCHAR)this;	
}



/*======================================================================

 Function:     CBaseHeader::GetSectionSize

 Description:

 =======================================================================*/
inline PCHAR CBaseHeader::GetNextSection(void) const
{
    return (PCHAR)this + sizeof(*this);
}

/*======================================================================

 Function:     CBaseHeader::CalcSectionSize

 Description:

 =======================================================================*/
inline ULONG CBaseHeader::CalcSectionSize(void)
{
    return sizeof(CBaseHeader);
}


/*======================================================================

 Function:     CBaseHeader::SetPacketSize

 Description:  Set Packet Size field

 =======================================================================*/
inline void CBaseHeader::SetPacketSize(ULONG ulPacketSize)
{
    m_ulPacketSize = ulPacketSize;
}

/*======================================================================

 Function:     CBaseHeader::GetPacketSize

 Description:  Returns the packet size

 =======================================================================*/
inline ULONG CBaseHeader::GetPacketSize(void) const
{
    return m_ulPacketSize;
}

/*======================================================================

 Function:     CBaseHeader::GetVersion

 Description:  returns the packet version field

 =======================================================================*/
inline UCHAR CBaseHeader::GetVersion(void) const
{
    return m_bVersion;
}

/*======================================================================

 Function:     CBaseHeader::VersionIsValid

 Description:  returns the packet version field

 =======================================================================*/
inline BOOL CBaseHeader::VersionIsValid(void) const
{
    return (m_bVersion == FALCON_PACKET_VERSION);
}

/*======================================================================

 Function:     CBaseHeader::SignatureIsValid

 Description:  return TRUE if Falcon packet signature is ok, False otherwise

 =======================================================================*/
inline BOOL CBaseHeader::SignatureIsValid(void) const
{
    return(m_ulSignature == FALCON_SIGNATURE);
}


/*======================================================================

 Function:     CBaseHeader::SetSignature

 Description:  Set packet signature to a valid signature

 =======================================================================*/
inline void  CBaseHeader::SetSignature(void)
{
	m_ulSignature = FALCON_SIGNATURE;
}

/*======================================================================

 Function:     CBaseHeader::SetPriority

 Description:  Set the packet priority bits in FLAGS field

 =======================================================================*/
inline void CBaseHeader::SetPriority(UCHAR bPriority)
{
    m_bfPriority = bPriority;
}

/*======================================================================

 Function:     CBaseHeader::GetPriority

 Description:  returns the packet priority

 =======================================================================*/
inline UCHAR CBaseHeader::GetPriority(void) const
{
    return (UCHAR)m_bfPriority;
}

/*======================================================================

 Function:     CBaseHeader::SetType

 Description:  Set the packet type field

 =======================================================================*/
inline void CBaseHeader::SetType(UCHAR bType)
{
    m_bfInternal = bType;
}

/*======================================================================

 Function:     CBaseHeader::GetType

 Description:  returns the packet type

 =======================================================================*/
inline UCHAR CBaseHeader::GetType(void) const
{
    return((UCHAR)m_bfInternal);
}

/*======================================================================

 Function:     CBaseHeader::SetSessionInclusion

 Description:  Set the secttion inclusion bit in Flags field

 =======================================================================*/
inline void CBaseHeader::IncludeSession(BOOL f)
{
    m_bfSession = (USHORT)f;
}

/*======================================================================

 Function:    CBaseHeader::IsSessionIncluded

 Description: returns TRUE if session section included, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::SessionIsIncluded(void) const
{
    return m_bfSession;
}

/*======================================================================

 Function:     CBaseHeader::SetDbgInclusion

 Description:  Set the debug section inclusion bit in FLAGS field

 =======================================================================*/
inline void CBaseHeader::IncludeDebug(BOOL f)
{

    m_bfDebug = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsDbgIncluded

 Description:  returns TRUE if debug section included, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::DebugIsIncluded(void) const
{
    return m_bfDebug;
}

/*======================================================================

 Function:     CBaseHeader::SetImmediateAck

 Description:  Set ACK immediately bit in Flag field

 =======================================================================*/
inline void CBaseHeader::SetImmediateAck(BOOL f)
{
    m_bfAck = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsImmediateAck

 Description:  Return TRUE if the ACK immediately bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::AckIsImmediate(void) const
{
    return m_bfAck;
}

/*======================================================================

 Function:      CBaseHeader::SetTrace

 Description:   Set the Trace packet bit in FLAGS section

 =======================================================================*/
inline void CBaseHeader::SetTrace(USHORT us)
{
    m_bfTrace = us;
}

/*======================================================================

 Function:    CBaseHeader::GetTraced

 =======================================================================*/
inline USHORT CBaseHeader::GetTraced(void) const
{
    return m_bfTrace;
}

/*======================================================================

 Function:    CBaseHeader::SetSegmented

 Description: set the segmented bit in FLAGS field

 =======================================================================*/
inline void CBaseHeader::SetFragmented(BOOL f)
{
    m_bfFragment = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsFragmented

 Description:  returns TRUE if the segmented bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::IsFragmented(void) const
{
    return m_bfFragment;
}

/*======================================================================

 Function:     CBaseHeader::SetAbsoluteTimeToQueue

 Description:  Set The Message Time-out to queue field

 =======================================================================*/
inline void CBaseHeader::SetAbsoluteTimeToQueue(ULONG ulTimeout)
{
    m_ulAbsoluteTimeToQueue = ulTimeout;
}

/*======================================================================

 Function:     CBaseHeader::GetAbsoluteTimeToQueue

 Description:  Returns the message Time-Out to queue

 =======================================================================*/
inline ULONG CBaseHeader::GetAbsoluteTimeToQueue(void) const
{
    return m_ulAbsoluteTimeToQueue;
}

/*======================================================================

 Function:     CBaseHeader::GetCRCBuffer

 Description:  Returns a pointer to the beginning of the CRC

 =======================================================================*/
inline PUCHAR CBaseHeader::GetCRCBuffer()
{
	return (PUCHAR) &m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::GetCRCBufferSize

 Description:  Returns the size of the CRC

 =======================================================================*/
inline CBaseHeader::GetCRCBufferSize()
{
	return sizeof m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::SetCRC

 Description:  Sets the CRC

 =======================================================================*/
inline void CBaseHeader::SetCRC(ULONG ulCRC)
{
	m_ulCRC = ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::ValidCRC

 Description:  Validates the CRC against ulCRC

 =======================================================================*/
inline BOOL CBaseHeader::ValidCRC(ULONG ulCRC)
{
	return m_ulCRC == ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::GetCRC

 Description:  Gets the CRC

 =======================================================================*/
inline ULONG CBaseHeader::GetCRC()
{
	return m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::SetOnDiskSignature

 Description:  Sets the header signature

 =======================================================================*/
inline void CBaseHeader::SetOnDiskSignature()
{
	m_bOnDiskSignature = 0x7c;
}

/*======================================================================

 Function:     CBaseHeader::ClearOnDiskSignature

 Description:  Clears the header signature

 =======================================================================*/
inline void CBaseHeader::ClearOnDiskSignature()
{
	m_bOnDiskSignature = 0;
}
/*======================================================================

 Function:     CBaseHeader::ValidOnDiskSignature

 Description:  Checks the header signature

 =======================================================================*/
inline BOOL CBaseHeader::ValidOnDiskSignature()
{
	return (m_bOnDiskSignature & 0xff) == 0x7c;
}


#endif // __PHBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\ph.h ===
/*++
               
Copyright (c) 1996  Microsoft Corporation

Module Name:

    ph.h

Abstract:

    Falcon Packet Header master include file

Author:

    Erez Haba (erezh) 5-Feb-96

Environment:

    Kerenl Mode, User Mode

--*/

#ifndef __PH_H
#define __PH_H

#include "limits.h"   // for UINT_MAX

/*+++

    Falcon Packet header sections order

+------------------------------+-----------------------------------------+----------+
| SECTION NAME                 | DESCRIPTION                             | SIZE     |
+------------------------------+-----------------------------------------+----------+
| Base                         | Basic packet info. Fixed size.          |  Fixed   |
+---------------+--------------+-----------------------------------------+----------+
| User          |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Xact          |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Security      |              |                                         |          |
+---------------+   Internal   +-----------------------------------------+----------+
| Properties    |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Debug         |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| MQF           |              | MQF:  MSMQ 3.0 (Whistler) or higher.    |          |
+---------------+--------------+-----------------------------------------+----------+
| SRMP                         | SRMP: MSMQ 3.0 (Whistler) or higher.    |          |
+------------------------------+-----------------------------------------+----------+
| EOD                          | EOD:  MSMQ 3.0 (Whistler) or higher.    |          |
+------------------------------+-----------------------------------------+----------+
| SOAP                         | Write-only props, not sent on wire.     |          |
+------------------------------+-----------------------------------------+----------+
| Session                      |                                         |          |
+------------------------------+-----------------------------------------+----------+

---*/

//
//  Alignment on DWORD bounderies
//
#define ALIGNUP4_ULONG(x) ((((ULONG)(x))+3) & ~((ULONG)3))
#define ISALIGN4_ULONG(x) (((ULONG)(x)) == ALIGNUP4_ULONG(x))
#define ALIGNUP4_PTR(x) ((((ULONG_PTR)(x))+3) & ~((ULONG_PTR)3))
#define ISALIGN4_PTR(x) (((ULONG_PTR)(x)) == ALIGNUP4_PTR(x))

//
//  Alignment on USHORT bounderies
//
#define ALIGNUP2_ULONG(x) ((((ULONG)(x))+1) & ~((ULONG)1))
#define ISALIGN2_ULONG(x) (((ULONG)(x)) == ALIGNUP2_ULONG(x))
#define ALIGNUP2_PTR(x) ((((ULONG_PTR)(x))+1) & ~((ULONG_PTR)1))
#define ISALIGN2_PTR(x) (((ULONG_PTR)(x)) == ALIGNUP2_PTR(x))

void ReportAndThrow(LPCSTR ErrorString);


inline size_t mqwcsnlen(const wchar_t * s, size_t MaxSize)
{
	for (size_t size = 0; (size<MaxSize) && (*(s+size) !=L'\0') ; size++);

    ASSERT(("String length must be 32 bit max", size <= UINT_MAX));
    return size;
}


inline ULONG_PTR SafeAlignUp4Ptr(ULONG_PTR ptr)
{
	ULONG_PTR ret = ALIGNUP4_PTR(ptr);
	if (ret < ptr)
	{
		ReportAndThrow("SafeAlignUp4Ptr cause overflow");
	}
	return ret;
}


inline ULONG_PTR SafeAddPointers(int count, ULONG_PTR PtrArray[])
{
	ULONG_PTR oldSum, sum = 0;

	for (int j=0; j<count; j++)
	{
		oldSum = sum;
		sum += PtrArray[j];
		if (sum < oldSum)
		{
		    ReportAndThrow("SafeAddPointers cause overflow");
		}
	}
	return sum;
}


template <class T> void ChekPtrIsAlligned(const UCHAR* p)
/*
	Checks pointer allignment to the specified type.
*/
{
	if((ULONG_PTR)p % TYPE_ALIGNMENT(T) != 0)
	{
		ReportAndThrow("ChekPtrIsAlligned: pointer is not alligned for the given poindted type");		
	}
}


//
// template function to get data from buffer which need to be verified
// for bounderies first
//

template <class T> UCHAR * GetSafeDataAndAdvancePointer(
	const UCHAR  * pBuffer,
    const UCHAR  * pEnd,
    T* 			   pData
    )
{
	ChekPtrIsAlligned<T>(pBuffer);
	
	if ((pEnd != NULL) && (pBuffer > pEnd - sizeof(T)))
	{
        ReportAndThrow("GetSafeDataAndAdvancePointer: too small buffer to read from");
	}
	*pData = *(reinterpret_cast<const T*>(pBuffer));
	pBuffer += sizeof(T);
	return const_cast<UCHAR*>(pBuffer);
}


#include <_ta.h>
#include "qformat.h"
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"
#include "phsecure.h"
#include "phxact.h"
#include "phdebug.h"
#include "phmqf.h"
#include "phmqfsign.h"
#include "phSrmpEnv.h"
#include "phCompoundMsg.h"
#include "pheod.h"
#include "pheodack.h"
#include "phSoap.h"
#include "phsenderstream.h"

#endif // __PH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phcompoundmsg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phCompoundMsg.h

Abstract:

    Packet header for Compound Message.

Author:

    Shai Kariv  (shaik)  11-Oct-2000

--*/

#ifndef __PHCOMPOUND_MSG_H
#define __PHCOMPOUND_MSG_H


/*+++

    Note: Packet may contain 0 or 2 SRMP headers (one for envelope, one for CompoundMessage).
          Packet may not contain only 1 SRMP header.

    CompoundMessage header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| HTTP Body Size | Size of the HTTP Body in BYTEs.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Msg Body Size  | Size of the message body part in BYTEs.               | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Msg Body Offset| Offset of the message body in the data, in BYTEs.     | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data bytes.                                       | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CCompoundMessageHeader
{
public:

    //
    // Construct the Compound Message header
    //
    CCompoundMessageHeader(
        UCHAR * pHttpHeader, 
        ULONG   HttpHeaderSizeInBytes, 
        UCHAR * pHttpBody, 
        ULONG   HttpBodySizeInBytes, 
        ULONG   MsgBodySizeInBytes,
        ULONG   MsgBodyOffsetInBytes,
        USHORT id
        );

    //
    // Get size in BYTEs of the Compound Message header.
    //
    static ULONG CalcSectionSize(ULONG HeaderSizeInBytes, ULONG DataSizeInBytes);

    //
    // Get pointer to first byte after the Compound Message header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Copy the data from the Compound Message header
    //
    VOID   GetData(UCHAR * pBuffer, ULONG BufferSizeInBytes) const;

    //
    // Get pointer to the data in the Compound Message header
    //
    const UCHAR* GetPointerToData(VOID) const;

    //
    // Get the size of the data in BYTEs from the Compound Message header
    //
    ULONG  GetDataSizeInBytes(VOID) const;

    //
    // Copy the message body part of the data from the Compound Message header
    //
    VOID   GetBody(UCHAR * pBuffer, ULONG BufferSizeInBytes) const;

    //
    // Get pointer to the message body part of the data in the Compound Message header
    //
    const UCHAR* GetPointerToBody(VOID) const;

    //
    // Get the size of the message body part of the data in BYTEs from the Compound Message header
    //
    ULONG  GetBodySizeInBytes(VOID) const;

private:

    //
    // ID number of the Compound Message header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in BYTEs of the data
    //
    ULONG  m_DataSize;

    //
    // Size in BYTEs of the message body part of the data
    //
    ULONG m_MsgBodySize;

    //
    // Offset in BYTEs of the message body part of the data
    //
    ULONG m_MsgBodyOffset;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CCompoundMessageHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CCompoundMessageHeader::CCompoundMessageHeader(
    UCHAR*  pHttpHeader,
    ULONG   HttpHeaderSizeInBytes,
    UCHAR*  pHttpBody, 
    ULONG   HttpBodySizeInBytes, 
    ULONG   MsgBodySizeInBytes,
    ULONG   MsgBodyOffsetInBytes,
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataSize(HttpHeaderSizeInBytes + HttpBodySizeInBytes),
    m_MsgBodySize(MsgBodySizeInBytes),
    m_MsgBodyOffset(MsgBodyOffsetInBytes + HttpHeaderSizeInBytes)
{
    ASSERT(MsgBodyOffsetInBytes + MsgBodySizeInBytes <=  HttpBodySizeInBytes);
    ASSERT(HttpHeaderSizeInBytes != 0);
    ASSERT(pHttpHeader != NULL);
 	
    memcpy(&m_buffer[0], pHttpHeader, HttpHeaderSizeInBytes);
    
    if (HttpBodySizeInBytes != 0)
    {
        memcpy(&m_buffer[HttpHeaderSizeInBytes], pHttpBody, HttpBodySizeInBytes);
    }
} // CCompoundMessageHeader::CCompoundMessageHeader


inline 
ULONG
CCompoundMessageHeader::CalcSectionSize(
    ULONG HeaderSizeInBytes,
    ULONG DataSizeInBytes
    )
{
    size_t cbSize = sizeof(CCompoundMessageHeader) + HeaderSizeInBytes + DataSizeInBytes;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CCompoundMessageHeader::CalcSectionSize


inline PCHAR CCompoundMessageHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CCompoundMessageHeader) + m_DataSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CCompoundMessageHeader::GetNextSection


inline VOID CCompoundMessageHeader::GetData(UCHAR * pBuffer, ULONG BufferSizeInBytes) const
{
    ULONG size = min(BufferSizeInBytes, m_DataSize);

    if (size != 0)
    {
        memcpy(pBuffer, &m_buffer[0], size);
    }
} // CCompoundMessageHeader::GetData


inline const UCHAR* CCompoundMessageHeader::GetPointerToData(VOID) const
{
    return &m_buffer[0];

} // CCompoundMessageHeader::GetPointerToData


inline ULONG CCompoundMessageHeader::GetDataSizeInBytes(VOID) const
{
    return m_DataSize;

} // CCompoundMessageHeader::GetDataSizeInBytes


inline VOID CCompoundMessageHeader::GetBody(UCHAR * pBuffer, ULONG BufferSizeInBytes) const
{
    ULONG size = min(BufferSizeInBytes, m_MsgBodySize);

    if (size != 0)
    {
        memcpy(pBuffer, &m_buffer[m_MsgBodyOffset], size);
    }
} // CCompoundMessageHeader::GetBody


inline const UCHAR* CCompoundMessageHeader::GetPointerToBody(VOID) const
{
    if (m_MsgBodySize == 0)
    {
        return NULL;
    }

    return &m_buffer[m_MsgBodyOffset];

} // CCompoundMessageHeader::GetPointerToBody


inline ULONG CCompoundMessageHeader::GetBodySizeInBytes(VOID) const
{
    return m_MsgBodySize;

} // CCompoundMessageHeader::GetBodySizeInBytes



#endif // __PHCOMPOUND_MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phdebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phdebug.h

Abstract:

    Packet header for message tracing.

Author:

    Shai Kariv  (shaik)  24-Apr-2000

--*/

#ifndef __PHDEBUG_H
#define __PHDEBUG_H


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CDebugSection {
public:
    CDebugSection(IN const QUEUE_FORMAT* pReportQueue);

    static ULONG CalcSectionSize(IN const QUEUE_FORMAT* pReportQueue);

    PCHAR GetNextSection(void) const;

    void SetReportQueue(IN const QUEUE_FORMAT* pReportQueue);

    BOOL GetReportQueue(OUT QUEUE_FORMAT* pReportQueue);

	void SectionIsValid(PCHAR PacketEnd) const;

private:
    enum QType {
        qtNone      = 0,    //  0 - None                    ( 0 bytes)
        qtGUID      = 1,    //  1 - Public  Queue           (16 bytes)
        qtPrivate   = 2,    //  2 - Private Queue           (20 bytes)
        qtDirect    = 3     //  3 - Direct  Queue           (var size)
    };
//
// BEGIN Network Monitor tag
//
    union {
        USHORT   m_wFlags;
        struct {
            USHORT m_bfRQT: 2;
        };
    };
    WORD m_wReserved;
    UCHAR m_abReportQueue[0];
//
// END Network Monitor tag
//


};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
CDebugSection::CDebugSection(
        IN const QUEUE_FORMAT* pReportQueue
        ) :
        m_wFlags(0),
        m_wReserved(0)
{
    SetReportQueue(pReportQueue);
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline ULONG
CDebugSection::CalcSectionSize(const QUEUE_FORMAT* pReportQueue)
{
    ULONG ulSize = sizeof(CDebugSection);

    switch (pReportQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            ulSize += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_UNKNOWN:
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            break;

	    default:
	        ASSERT(0);
           
    }

    return ALIGNUP4_ULONG(ulSize);
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
 inline PCHAR CDebugSection::GetNextSection(void) const
 {
    int size = sizeof(*this);
    switch (m_bfRQT)
    {
    case qtNone:
        size += 0;
        break;
    case qtGUID:
        size += sizeof(GUID);
        break;
    default:
        ASSERT(0);
    }

    return (PCHAR)this + ALIGNUP4_ULONG(size);
 }


/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline void
CDebugSection::SetReportQueue(IN const QUEUE_FORMAT* pReportQueue)
{
    PUCHAR pQueue = m_abReportQueue;

    switch (pReportQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            //  Report Queue is PUBLIC
            //
            m_bfRQT = qtGUID;
            *(GUID*)pQueue = pReportQueue->PublicID();
            break;

        case QUEUE_FORMAT_TYPE_UNKNOWN:
        {
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            m_bfRQT = qtNone;
            break;
        }
        default:
            //
            // ASSERT(0) for warning level 4
            //
            ASSERT(0);
    }

}

inline BOOL CDebugSection::GetReportQueue(QUEUE_FORMAT* pReportQueue)
{
    PUCHAR pQueue = m_abReportQueue;

    switch (m_bfRQT)
    {
        case qtNone:
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            pReportQueue->UnknownID(0);
            break;

        case qtGUID:
            //
            //  Report Queue is PUBLIC
            //
            pReportQueue->PublicID(*(GUID*)pQueue);
            break;

        default:
            ASSERT(0);
            return FALSE;
    }

    return TRUE;
}


#endif // __PHDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\pheod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pheod.h

Abstract:

    Packet header for Exactly Once Delivery over http.

Author:

    Shai Kariv  (shaik)  22-Oct-2000

--*/

#ifndef __PHEOD_H
#define __PHEOD_H


/*+++

    EOD header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Stream ID Size | Size of the stream ID in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Order Q Size   | Size of the order queue in bytes.                     | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Buffer         | Buffer that holds the stream ID and order queue.      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CEodHeader
{
public:

    //
    // Construct the EOD header
    //
    CEodHeader(
        USHORT      id, 
        ULONG       cbStreamIdSize, 
        UCHAR *     pStreamId,
        ULONG       cbOrderQueueSize,
        UCHAR *     pOrderQueue
        );

    //
    // Get size in bytes of the EOD header
    //
    static ULONG CalcSectionSize(ULONG cbStreamIdSize, ULONG cbOrderQueueSize);

    //
    // Get pointer to first byte after the EOD header
    //
    PCHAR  GetNextSection(VOID) const;

    //
    // Get the size of the stream ID in bytes from the EOD header
    //
    ULONG  GetStreamIdSizeInBytes(VOID) const;

    //
    // Get the stream ID from the EOD header
    //
    VOID   GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;

    //
    // Get pointer to the stream ID in the EOD header
    //
    const UCHAR* GetPointerToStreamId(VOID) const;

    //
    // Get the size of the order queue in bytes from the EOD header
    //
    ULONG  GetOrderQueueSizeInBytes(VOID) const;

    //
    // Get pointer to the order queue in the EOD header
    //
    const UCHAR* GetPointerToOrderQueue(VOID) const;

private:

    //
    // ID number of the EOD header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in bytes of the stream ID
    //
    ULONG  m_cbStreamIdSize;

    //
    // Size in bytes of the order queue
    //
    ULONG  m_cbOrderQueueSize;

    //
    // Buffer with the stream ID and order queue
    //
    UCHAR  m_buffer[0];

}; // CEodHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CEodHeader::CEodHeader(
    USHORT      id,
    ULONG       cbStreamIdSize, 
    UCHAR *     pStreamId,
    ULONG       cbOrderQueueSize,
    UCHAR *     pOrderQueue
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_cbStreamIdSize(cbStreamIdSize),
    m_cbOrderQueueSize(cbOrderQueueSize)
{
    if (cbStreamIdSize != 0)
    {
        memcpy(&m_buffer[0], pStreamId, cbStreamIdSize);
    }

    if (cbOrderQueueSize != 0)
    {
        memcpy(&m_buffer[cbStreamIdSize], pOrderQueue, cbOrderQueueSize);
    }
} // CEodHeader::CEodHeader

    
inline 
ULONG
CEodHeader::CalcSectionSize(
    ULONG cbStreamIdSize,
    ULONG cbOrderQueueSize
    )
{
    size_t cbSize = sizeof(CEodHeader) + cbStreamIdSize + cbOrderQueueSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CEodHeader::CalcSectionSize


inline PCHAR CEodHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CEodHeader) + m_cbStreamIdSize + m_cbOrderQueueSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CEodHeader::GetNextSection


inline ULONG CEodHeader::GetStreamIdSizeInBytes(VOID) const
{
    return m_cbStreamIdSize;

} // CEodHeader::GetStreamIdSizeInBytes


inline VOID CEodHeader::GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ULONG cbSize = min(cbBufferSize, m_cbStreamIdSize);

    if (cbSize != 0)
    {
        memcpy(pBuffer, &m_buffer[0], cbSize);
    }
} // CEodHeader::GetStreamId


inline const UCHAR* CEodHeader::GetPointerToStreamId(VOID) const
{
    return &m_buffer[0];

} // GetPointerToStreamId


inline ULONG CEodHeader::GetOrderQueueSizeInBytes(VOID) const
{
    return m_cbOrderQueueSize;

} // CEodHeader::GetOrderQueueSizeInBytes


inline const UCHAR* CEodHeader::GetPointerToOrderQueue(VOID) const
{
    return &m_buffer[m_cbStreamIdSize];

} // GetPointerToStreamId



#endif // __PHEOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phmqf.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phmqf.h

Abstract:

    Packet header for Multi Queue Format.

Author:

    Shai Kariv  (shaik)  24-Apr-2000

--*/

#ifndef __PHMQF_H
#define __PHMQF_H

/*+++

    Note: Packet either contains none of the headers of all 4 (destination,
	admin, response, signature).

    BaseMqf header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header Size    | Size of the header, in bytes, including header size   | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| nMqf           | Number of queue format elements.                      | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | Representation of the queue format names.             | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CBaseMqfHeader
{
public:

    //
    // Construct the base mqf header
    //
    CBaseMqfHeader(const QUEUE_FORMAT mqf[], ULONG nMqf, USHORT id);

    //
    // Get size in bytes of the base mqf header
    //
    static ULONG CalcSectionSize(const QUEUE_FORMAT mqf[], ULONG nMqf);

    //
    // Get pointer to first byte after the base mqf header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Get array of multi queue formats from the base mqf header
    //
    VOID   GetMqf(QUEUE_FORMAT * mqf, ULONG nMqf);

    //
    // Get one queue format from the base mqf header buffer
    //
    UCHAR * GetQueueFormat(const UCHAR * pBuffer, QUEUE_FORMAT * pqf, UCHAR * pEnd = NULL);

    //
    // Get a pointer to the serialization buffer
    //
    UCHAR * GetSerializationBuffer(VOID);

    //
    // Get number of queue format elements in the base mqf header
    //
    ULONG  GetNumOfElements(VOID) const;

	void SectionIsValid(PCHAR PacketEnd);

private:

    //
    // Store one queue format data in the base mqf header buffer
    //
    UCHAR * SerializeQueueFormat(const QUEUE_FORMAT * pqf, UCHAR * pBuffer);

    //
    // Get size, in bytes, up to and including queue format
    //
    static size_t CalcQueueFormatSize(const QUEUE_FORMAT * pqf, size_t cbSize);

private:

    //
    // Size in bytes of the base mqf header including data
    //
    ULONG  m_cbSize;

    //
    // ID number of the base mqf header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Number of queue format elements in the base mqf header
    //
    ULONG  m_nMqf;

    //
    // Buffer with all queue formats data
    //
    UCHAR  m_queues[0];

}; // CBaseMqfHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CBaseMqfHeader::CBaseMqfHeader(
    const QUEUE_FORMAT mqf[],
    ULONG              nMqf,
    USHORT             id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_nMqf(nMqf)
{
    //
    // Store data of each queue format in the buffer
    //
    UCHAR * pBuffer = &m_queues[0];
    ASSERT(ISALIGN4_PTR(pBuffer));
    UCHAR * pStart = pBuffer;

    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        pBuffer = SerializeQueueFormat(&mqf[ix], pBuffer);
    }

    //
    // Calculate size of the entire header
    //
    m_cbSize = sizeof(*this) + static_cast<ULONG>(pBuffer - pStart);
    if (!ISALIGN4_ULONG(m_cbSize))
    {
        m_cbSize = ALIGNUP4_ULONG(m_cbSize);
    }
    ASSERT(m_cbSize == CalcSectionSize(mqf, nMqf));

} // CBaseMqfHeader::CBaseMqfHeader

    
inline 
ULONG
CBaseMqfHeader::CalcSectionSize(
    const QUEUE_FORMAT mqf[], 
    ULONG nMqf
    )
{
    size_t cbSize = sizeof(CBaseMqfHeader);

    //
    // Add size of each queue format data
    //
    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        cbSize = CalcQueueFormatSize(&mqf[ix], cbSize);
    }

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CBaseMqfHeader::CalcSectionSize


inline ULONG CBaseMqfHeader::GetNumOfElements(VOID) const
{
    return m_nMqf;

} // CBaseMqfHeader::GetNumOfElements


inline PCHAR CBaseMqfHeader::GetNextSection(VOID) const
{
    ASSERT(ISALIGN4_ULONG(m_cbSize));
	ULONG_PTR ptrArray[] = {(ULONG_PTR)this, m_cbSize};
	ULONG_PTR size = SafeAddPointers (2, ptrArray);
    return (PCHAR)size;

} // CBaseMqfHeader::GetNextSection


inline VOID CBaseMqfHeader::GetMqf(QUEUE_FORMAT * mqf, ULONG nMqf)
{
    //
    // Caller must pass exactly the size we have
    //
    ASSERT(nMqf == m_nMqf);

    //
    // Get data of each queue format from the buffer and store it
    // as QUEUE_FORMAT in the specified array
    //
    UCHAR * pBuffer = &m_queues[0];
    ASSERT(ISALIGN4_PTR(pBuffer));

    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        pBuffer = GetQueueFormat(pBuffer, &mqf[ix]);
    }
} // CBaseMqfHeader::GetMqf


inline UCHAR * CBaseMqfHeader::GetSerializationBuffer(VOID)
{
    return &m_queues[0];
}


inline 
UCHAR * 
CBaseMqfHeader::SerializeQueueFormat(
    const QUEUE_FORMAT * pqf, 
    UCHAR *              pBuffer
    )
{
    //
    // Two bytes hold the queue format type.
    // Note that pBuffer is not necessarily aligned to 4 bytes boundaries here.
    //
    USHORT type = static_cast<USHORT>(pqf->GetType());
    (*reinterpret_cast<USHORT*>(pBuffer)) = type;
    pBuffer += sizeof(USHORT);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            //
            // Align to 4 bytes boundaries and serialize GUID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            (*reinterpret_cast<GUID*>(pBuffer)) = pqf->PublicID();
            pBuffer += sizeof(GUID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            //
            // Align to 4 bytes boundaries and serialize GUID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            const DL_ID& id = pqf->DlID();
            (*reinterpret_cast<GUID*>(pBuffer)) = id.m_DlGuid;
            pBuffer += sizeof(GUID);

            //
            // Serialize the domain (string) if exists, empty string otherwise.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            if (id.m_pwzDomain == NULL)
            {
                memcpy(pBuffer, L"", sizeof(WCHAR));
                pBuffer += sizeof(WCHAR);
                break;
            }

            size_t cbSize = (wcslen(id.m_pwzDomain) + 1) * sizeof(WCHAR);
            memcpy(pBuffer, id.m_pwzDomain, cbSize);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            //
            // Align to 4 bytes boundaries and serialize OBJECTID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            (*reinterpret_cast<OBJECTID*>(pBuffer)) = pqf->PrivateID();
            pBuffer += sizeof(OBJECTID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            //
            // Serialize the direct ID (string) into the buffer.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPCWSTR pDirectId = pqf->DirectID();
            ASSERT(pDirectId != NULL);
            size_t cbSize = (wcslen(pDirectId) + 1) * sizeof(WCHAR);
            memcpy(pBuffer, pDirectId, cbSize);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Align to 4 bytes boundaries and serialize MULTICAST_ID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            const MULTICAST_ID& id = pqf->MulticastID();
            (*reinterpret_cast<ULONG*>(pBuffer)) = id.m_address;
            pBuffer += sizeof(ULONG);
            (*reinterpret_cast<ULONG*>(pBuffer)) = id.m_port;
            pBuffer += sizeof(ULONG);
            break;
        }

        default:
        {
            ASSERT(("Unexpected queue format type", 0));
            break;
        }
    }

    //
    // Return pointer to next available byte in buffer.
    //
    return pBuffer;

} // CBaseMqfHeader::SerializeQueueFormat


inline
UCHAR *
CBaseMqfHeader::GetQueueFormat(
    const UCHAR  * pBuffer,
    QUEUE_FORMAT * pqf,
    UCHAR        * pEnd //= NULL,
    )
{
    //
    // First 2 bytes hold the queue type.
    // Note that pBuffer is not necessarily aligned to 4 bytes boundaries here.
    //
    USHORT type;
    pBuffer = GetSafeDataAndAdvancePointer<USHORT>(pBuffer, pEnd, &type);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            //
            // Align to 4 bytes boundaries and get the GUID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            GUID publicID;
			pBuffer = GetSafeDataAndAdvancePointer<GUID>(pBuffer, pEnd, &publicID);
            pqf->PublicID(publicID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            //
            // Align to 4 bytes boundaries and get the GUID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            DL_ID id;
			pBuffer = GetSafeDataAndAdvancePointer<GUID>(pBuffer, pEnd, &id.m_DlGuid);
            //
            // Get the domain (string) from the buffer. Empty string means no domain.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPWSTR pDomain = const_cast<WCHAR*>(reinterpret_cast<const WCHAR*>(pBuffer));
            size_t cbSize = mqwcsnlen(pDomain, (pEnd - pBuffer) / sizeof(WCHAR));
            if (cbSize >= (pEnd - pBuffer) / sizeof(WCHAR))
            {
		        ReportAndThrow("MQF section is not valid: DL queue without NULL terminator");
            }
            id.m_pwzDomain = NULL;
            if (cbSize != 0)
            {
                id.m_pwzDomain = pDomain;
            }
            cbSize = (cbSize + 1) * sizeof(WCHAR);
            pBuffer += cbSize;

            pqf->DlID(id);
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            //
            // Align to 4 bytes boundaries and get the OBJECTID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
			OBJECTID objectID;
			pBuffer = GetSafeDataAndAdvancePointer<OBJECTID>(pBuffer, pEnd, &objectID);
			if (0 == objectID.Uniquifier)
			{
		        ReportAndThrow("Mqf section is not valid: private queue Uniquifier can not be 0");
			}		

            pqf->PrivateID(objectID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            //
            // Get the direct ID (string) from the buffer.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPWSTR pDirectId = const_cast<LPWSTR>(reinterpret_cast<const WCHAR*>(pBuffer));
            size_t cbSize = mqwcsnlen(pDirectId, (pEnd - pBuffer) / sizeof(WCHAR));
            if (cbSize >= (pEnd - pBuffer) / sizeof(WCHAR))
            {
		        ReportAndThrow("MQF section is not valid: Direct queue without NULL terminator");
            }
            pqf->DirectID(pDirectId);

			cbSize = (cbSize + 1) * sizeof(WCHAR);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Align to 4 bytes boundaries and get the address and port from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            MULTICAST_ID id;
			pBuffer = GetSafeDataAndAdvancePointer<ULONG>(pBuffer, pEnd, &id.m_address);
 			pBuffer = GetSafeDataAndAdvancePointer<ULONG>(pBuffer, pEnd, &id.m_port);
			pqf->MulticastID(id);
            break;
        }

        default:
        {
	        ReportAndThrow("MQF section is not valid: Queue type is not valid");
        }
    }

    //
    // Return pointer to next available byte in buffer.
    //
    return const_cast<UCHAR*>(pBuffer);

} // CBaseMqfHeader::GetQueueFormat


inline
size_t
CBaseMqfHeader::CalcQueueFormatSize(
    const QUEUE_FORMAT * pqf,
    size_t               cbSize
    )
{
    //
    // Two bytes hold the queue type
    //
    cbSize += sizeof(USHORT);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (pqf->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(GUID);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(GUID);

            ASSERT(ISALIGN2_ULONG(cbSize));
            const DL_ID& id = pqf->DlID();
            if (id.m_pwzDomain == NULL)
            {
                cbSize += sizeof(WCHAR);
                break;
            }

            cbSize += (wcslen(id.m_pwzDomain) + 1) * sizeof(WCHAR);
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(OBJECTID);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            ASSERT(ISALIGN2_ULONG(cbSize));
            LPCWSTR pDirectId = pqf->DirectID();
            cbSize += (wcslen(pDirectId) + 1) * sizeof(WCHAR);
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(ULONG);
            cbSize += sizeof(ULONG);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        default:
        {
            ASSERT(("Unexpected queue format type", 0));
            break;
        }
    }

    //
    // Note that cbSize is not necessarily aligned at this point.
    //
    return cbSize;

} // CBaseMqfHeader::CalcQueueFormatSize

#endif // __PHMQF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phmqfsign.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phmqfsign.h

Abstract:

    Packet header for MQF Signature.

Author:

    Ilan Herbst  (ilanh)  05-Nov-2000

--*/

#ifndef __PHMQFSIGN_H
#define __PHMQFSIGN_H


/*+++

    MQF Signature header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Signature Size | Size of the signature in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Signature      | Buffer that holds the signature                .      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CMqfSignatureHeader
{
public:

    //
    // Construct the CMqfSignatureHeader header
    //
    CMqfSignatureHeader(
        USHORT      id, 
        ULONG       cbSignatureSize, 
        UCHAR *     pSignature
        );

    //
    // Get size in bytes of the CMqfSignatureHeader header
    //
    static ULONG CalcSectionSize(ULONG cbSignatureSize);

    //
    // Get pointer to first byte after the CMqfSignatureHeader header
    //
    PCHAR  GetNextSection(void) const;

    //
    // Get the size of the signature in bytes from the CMqfSignatureHeader header
    //
    ULONG  GetSignatureSizeInBytes(void) const;

    //
    // Get pointer to the signature in CMqfSignatureHeader header
    //
    const UCHAR* GetPointerToSignature(ULONG* pSize) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:

    //
    // ID number of the CMqfSignatureHeader header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in bytes of the signature
    //
    ULONG  m_cbSignatureSize;

    //
    // Buffer with the signature
    //
    UCHAR  m_buffer[0];

}; // CMqfSignatureHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CMqfSignatureHeader::CMqfSignatureHeader(
    USHORT      id,
    ULONG       cbSignatureSize, 
    UCHAR *     pSignature
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_cbSignatureSize(cbSignatureSize)
{
    if (cbSignatureSize != 0)
    {
        memcpy(&m_buffer[0], pSignature, cbSignatureSize);
    }
} // CMqfSignatureHeader::CMqfSignatureHeader

    
inline 
ULONG
CMqfSignatureHeader::CalcSectionSize(
    ULONG cbSignatureSize
    )
{
    size_t cbSize = sizeof(CMqfSignatureHeader) + cbSignatureSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CMqfSignatureHeader::CalcSectionSize


inline PCHAR CMqfSignatureHeader::GetNextSection(void) const
{
	ULONG_PTR ptrArray[] = {sizeof(CMqfSignatureHeader), m_cbSignatureSize};
	ULONG_PTR size = SafeAddPointers (2, ptrArray);

	size = SafeAlignUp4Ptr(size);
	ULONG_PTR ptrArray2[] = {(ULONG_PTR)this, size};
	size = SafeAddPointers(2, ptrArray2);

    return (PCHAR)size;

} // CMqfSignatureHeader::GetNextSection


inline ULONG CMqfSignatureHeader::GetSignatureSizeInBytes(void) const
{
    return m_cbSignatureSize;

} // CMqfSignatureHeader::GetSignatureSizeInBytes


inline const UCHAR* CMqfSignatureHeader::GetPointerToSignature(ULONG* pSize) const
{
	*pSize = m_cbSignatureSize;
    return &m_buffer[0];

} // CMqfSignatureHeader::GetPointerToSignature


#endif // __PHMQFSIGN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phintr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.h

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/

#ifndef __QM_INTERNAL_PACKET__
#define __QM_INTERNAL_PACKET__

#include "ph.h"

#define STORED_ACK_BITFIELD_SIZE 32
#define INTERNAL_SESSION_PACKET              1
#define INTERNAL_ESTABLISH_CONNECTION_PACKET 2
#define INTERNAL_CONNECTION_PARAMETER_PACKET 3

#define ESTABLISH_CONNECTION_BODY_SIZE       512
#define CONNECTION_PARAMETERS_BODY_SIZE      512


/*
================= Session Packet =====================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|ACK Sequence number    | The transmitted packet sequence number.        | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Store ACK sequence     | The reliable packet sequence number.           | 2 bytes  |
|number (ps)            |                                                |          |
+-----------------------+------------------------------------------------+----------+
|Storage Ack bits       | Bit i:refers to recoverable packet no. Ps+I+ 1 | 4 bytes  |
|                       |    0 - no acknowledgment.                      |          |
|                       |    1 - the packet is acknowledgment.           |          |
+-----------------------+------------------------------------------------+----------+
| Window size           | number of packet in specific priority that     | 2 bytes  |
|                       | can be sent before getting a new window size.  |          |
+-----------------------+------------------------------------------------+----------+
| window priority       |message priority, in which the window size refer| 1 byte   |         |
+-----------------------+------------------------------------------------+----------+
| Reserved              |                                                | 1 byte   |
+-----------------------+------------------------------------------------+----------+

*/

#pragma pack(push, 1)

struct  CSessionSection {
    public:
        CSessionSection(WORD     wAckSequenceNo,
                        WORD     wAckRecoverNo,
                        DWORD    wAckRecoverBitField,
                        WORD     wSyncAckSequenceNo,
                        WORD     wSyncAckRecoverNo,
                        WORD     wWindowSize
                       );

        CSessionSection() {};

        static ULONG CalcSectionSize(void);

        inline WORD GetAcknowledgeNo(void) const;
        inline WORD GetStorageAckNo(void) const;
        inline DWORD GetStorageAckBitField(void) const;
        inline void GetSyncNo(WORD* wSyncAckSequenceNo,
                              WORD* wSyncAckRecoverNo);
        WORD GetWindowSize(void) const;

    private:
//
// BEGIN Network Monitor tag
//
        WORD    m_wAckSequenceNo;
        WORD    m_wAckRecoverNo;
        DWORD   m_wAckRecoverBitField;
        WORD    m_wSyncAckSequenceNo;
        WORD    m_wSyncAckRecoverNo;
        WORD    m_wWinSize;
        UCHAR   m_bWinPriority;
        UCHAR   m_bReserve;
//
// END Network Monitor tag
//
};
#pragma pack(pop)


/*====================================================


 Routine Name: CSession::Csession

 Description: Constructor

 Arguments:  wAckSequenceNo - Acknowledge sequence number
             wAckRecoverNo  - Acknowledge Recover packet number
             wAckRecoverBitField - Acknowledge recover bit field

=====================================================*/
inline
CSessionSection::CSessionSection(WORD     wAckSequenceNo,
                                 WORD     wAckRecoverNo,
                                 DWORD    wAckRecoverBitField,
                                 WORD     wSyncAckSequenceNo,
                                 WORD     wSyncAckRecoverNo,
                                 WORD     wWindowSize
                                )
{
    m_wAckSequenceNo      = wAckSequenceNo;
    m_wAckRecoverNo       = wAckRecoverNo;
    m_wAckRecoverBitField = wAckRecoverBitField;
    m_wSyncAckSequenceNo  = wSyncAckSequenceNo;
    m_wSyncAckRecoverNo   = wSyncAckRecoverNo;
    m_wWinSize            = wWindowSize;
    m_bWinPriority        = 0x0;
    m_bReserve            = 0x0;
}


/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline ULONG
CSessionSection::CalcSectionSize(void)
{
    return sizeof(CSessionSection);
}
/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD
CSessionSection::GetAcknowledgeNo(void) const
{
    return(m_wAckSequenceNo);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD
CSessionSection::GetStorageAckNo(void) const
{
    return(m_wAckRecoverNo);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline void
CSessionSection::GetSyncNo(WORD* wSyncAckSequenceNo,
                           WORD* wSyncAckRecoverNo)
{
    *wSyncAckSequenceNo = m_wSyncAckSequenceNo;
    *wSyncAckRecoverNo  = m_wSyncAckRecoverNo;
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline DWORD
CSessionSection::GetStorageAckBitField(void) const
{
    return(m_wAckRecoverBitField);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD 
CSessionSection::GetWindowSize(void) const
{
    return m_wWinSize;
}
/*
======================== Establish Connection Section ================================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|Client QM Guid         | The Client QM Identifier                       | 16 bytes |
+-----------------------+------------------------------------------------+----------+
|SErver QM Guid         | The Server QM Identifier                       | 16 bytes |
+-----------------------+------------------------------------------------+----------+
|Time Stamp             | send packet time stamp. use for determine the  | 4 bytes  |
|                       | line quality                                   |          |
+-----------------------+------------------------------------------------+----------+
|Flags                  |                                                | 4 bytes  |
|                       | Version                  1 byte                |          |
|                       | Check new session flag   1 bit                 |          |
|                       | Server flag              1 bit                 |          |
|                       | QoS flag                 1 bit                 |          |
+-----------------------+------------------------------------------------+----------+
|Body                   |                                                | 512 bytes|
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CECSection {
    public:
        CECSection(const GUID* ClientQMId,
                   const GUID* ServerQMId,
                   BOOL  fServer,
                   bool  fQoS
                  );

        CECSection(const GUID* ClientQMId,
                   const GUID* ServerQMId,
                   ULONG dwTime,
                   BOOL  fServer,
                   bool  fQoS
                  );

        static ULONG CalcSectionSize(void);

        void CheckAllowNewSession(BOOL);
        BOOL CheckAllowNewSession() const;

        const GUID* GetServerQMGuid() const;
        const GUID* GetClientQMGuid() const;
        ULONG GetTimeStamp() const;
        DWORD GetVersion() const;
        BOOL  IsOtherSideServer()const;
        bool  IsOtherSideQoS()const;


    private:
//
// BEGIN Network Monitor tag
//
        GUID    m_guidClientQM;
        GUID    m_guidServerQM;
        ULONG   m_ulTimeStampe;
        union {
            ULONG m_ulFlags;
            struct {
                ULONG m_bVersion : 8;
                ULONG m_fCheckNewSession : 1;
                ULONG m_fServer : 1;
                ULONG m_fQoS    : 1;
            };
        };

        UCHAR   m_abBody[ESTABLISH_CONNECTION_BODY_SIZE];
//
// END Network Monitor tag
//

};

#pragma pack(pop)

/*================================================================

 Routine Name: CECPacket::CECPacket

 Description: Constructor

==================================================================*/

inline  CECSection::CECSection(const GUID* ClientQMId,
                               const GUID* ServerQMId,
                               BOOL  fServer,
                               bool  fQoS
                              ) : m_guidClientQM(*ClientQMId),
                                  m_guidServerQM(*ServerQMId),
                                  m_ulTimeStampe(GetTickCount()),
                                  m_ulFlags(0)
{
    m_bVersion = FALCON_PACKET_VERSION;
    m_fServer = fServer;
    m_fQoS = fQoS ? 1 : 0;
}

inline  CECSection::CECSection(const GUID* ClientQMId,
                               const GUID* ServerQMId,
                               ULONG dwTime,
                               BOOL  fServer,
                               bool  fQoS
                              ) : m_guidClientQM(*ClientQMId),
                                  m_guidServerQM(*ServerQMId),
                                  m_ulTimeStampe(dwTime),
                                  m_ulFlags(0)
{
    m_bVersion = FALCON_PACKET_VERSION;
    m_fServer = fServer;
    m_fQoS = fQoS ? 1: 0;
}

inline ULONG
CECSection::CalcSectionSize(void)
{
    return sizeof(CECSection);
}

inline void 
CECSection::CheckAllowNewSession(BOOL f)
{
    m_fCheckNewSession = f;
}

inline BOOL 
CECSection::CheckAllowNewSession() const
{
    return m_fCheckNewSession;
}

inline const GUID*
CECSection::GetClientQMGuid(void) const
{
    return &m_guidClientQM;
}

inline const GUID*
CECSection::GetServerQMGuid(void) const
{
    return &m_guidServerQM;
}

inline DWORD
CECSection::GetTimeStamp(void) const
{
    return m_ulTimeStampe;
}

inline DWORD
CECSection::GetVersion(void) const
{
    return m_bVersion;
}

inline BOOL  
CECSection::IsOtherSideServer()const
{
    return m_fServer;
}

inline bool  
CECSection::IsOtherSideQoS()const
{
    return m_fQoS;
}

/*
==========================  Connection Parameters Section =============================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
| Window size           | number of packet that  can be sent before      | 2 bytes  |
|                       | getting an acknowledge                         |          |
+-----------------------+------------------------------------------------+----------+
|ACK Timeout            | The Max time can be passed before getting an   |          |
|                       | acknowledge                                    | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Store ACK Timeout      | The Max time can be passed before getting an   |          |
|                       | acknowledge on persistence packet              | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Max Segmentaion size   |                                                | 2 bytes  |
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CCPSection {
    public:
        CCPSection(USHORT wWindowSize,
                   DWORD  dwRecoverAckTimeout,
                   DWORD  dwAckTimeout,
                   USHORT wSegmentSize
                  );

        static ULONG CalcSectionSize(void);

        USHORT GetWindowSize(void) const;
        void   SetWindowSize(USHORT);

        DWORD  GetRecoverAckTimeout(void) const;
        DWORD  GetAckTimeout(void) const;
        USHORT GetSegmentSize(void) const;

    private:
//
// BEGIN Network Monitor tag
//
        DWORD   m_dwRecoverAckTimeout;
        DWORD   m_dwAckTimeout;
        USHORT  m_wSegmentSize;
        USHORT  m_wWindowSize;

#if 0
        UCHAR   m_abBody[ CONNECTION_PARAMETERS_BODY_SIZE ] ;
#endif
//
// END Network Monitor tag
//
};

#pragma pack(pop)


/*================================================================

 Routine Name: CCPSection::CCPSection

 Description: Constructor

==================================================================*/

inline  CCPSection::CCPSection(USHORT wWindowSize,
                               DWORD  dwRecoverAckTimeout,
                               DWORD  dwAckTimeout,
                               USHORT wSegmentSize
                              ) : m_wWindowSize(wWindowSize),
                                  m_dwRecoverAckTimeout(dwRecoverAckTimeout),
                                  m_dwAckTimeout(dwAckTimeout),
                                  m_wSegmentSize(wSegmentSize)
{

}

inline ULONG
CCPSection::CalcSectionSize(void)
{
    return sizeof(CCPSection);
}

inline USHORT
CCPSection::GetWindowSize(void) const
{
    return m_wWindowSize;
}

inline void
CCPSection::SetWindowSize(USHORT wWindowSize)
{
    m_wWindowSize = wWindowSize;
}


inline DWORD
CCPSection::GetRecoverAckTimeout(void) const
{
    return m_dwRecoverAckTimeout;
}

inline DWORD
CCPSection::GetAckTimeout(void) const
{
    return m_dwAckTimeout;
}

inline USHORT
CCPSection::GetSegmentSize(void) const
{
    return m_wSegmentSize;
}

/*
=============================== Internal Section ==========================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|                          Falcon BASE HEADER                                       |
|                                                                                   |
+-----------------------+------------------------------------------------+----------+
|Flags                  | 0-3: Packet Type                               | 2 bytes  |
|                       | 4:   Refuse connection bit                     |          |
+-----------------------+------------------------------------------------+----------+
|Reserve                |                                                | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|                         Specific packet body                                      |
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CInternalSection {
    public:
        CInternalSection(USHORT usPacketType);

        static ULONG CalcSectionSize(void);
        PCHAR GetNextSection(void) const;

        USHORT GetPacketType(void) const;
        USHORT GetRefuseConnectionFlag(void) const;

        void SetRefuseConnectionFlag(void);

		void SectionIsValid(PCHAR PacketEnd) const;

    private:
//
// BEGIN Network Monitor tag
//
        USHORT            m_bReserved;
        union
        {
            USHORT m_wFlags;
            struct
            {
                USHORT m_bfType : 4;
                USHORT m_bfConnectionRefuse : 1;
            };
        };
//
// END Network Monitor tag
//
};

#pragma pack(pop)

inline
CInternalSection::CInternalSection(USHORT usPacketType
                                ) : m_bReserved(0),
                                    m_wFlags(0)
{
    m_bfType = usPacketType;
}

inline ULONG
CInternalSection::CalcSectionSize(void)
{
    return sizeof(CInternalSection);
}

inline PCHAR
CInternalSection::GetNextSection(void) const
{
    return (PCHAR)this + sizeof(*this);
}

inline USHORT
CInternalSection::GetPacketType(void) const
{
    return m_bfType;
}

inline USHORT
CInternalSection::GetRefuseConnectionFlag(void) const
{
    return m_bfConnectionRefuse;
}

inline void
CInternalSection::SetRefuseConnectionFlag(void)
{
    m_bfConnectionRefuse = (USHORT) TRUE;
}


#endif //__QM_INTERNAL_PACKET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\pheodack.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pheodack.h

Abstract:

    Packet header for Exactly Once Delivery Ack over http.

Author:

    Shai Kariv  (shaik)  22-Oct-2000

--*/

#ifndef __PHEODACK_H
#define __PHEODACK_H


/*+++

    EodAck header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Seq ID         | Seq ID.                                               | 8 bytes  |
+----------------+-------------------------------------------------------+----------+
| Seq number     | Seq number.                                           | 8 bytes  |
+----------------+-------------------------------------------------------+----------+
| Stream ID Size | Size of the stream ID in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Buffer         | Buffer that holds the stream ID.                      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CEodAckHeader
{
public:

    //
    // Construct the EodAck header
    //
    CEodAckHeader(
        USHORT      id, 
        LONGLONG * pSeqId,
        LONGLONG * pSeqNum,
        ULONG       cbStreamIdSize, 
        UCHAR *     pStreamId
        );

    //
    // Get size in bytes of the EodAck header
    //
    static ULONG CalcSectionSize(ULONG cbStreamIdSize);

    //
    // Get pointer to first byte after the EodAck header
    //
    PCHAR  GetNextSection(VOID) const;

    //
    // Get the Seq ID from the EodAck header
    //
    LONGLONG GetSeqId(VOID) const;

    //
    // Get the Seq number form the EodAck header
    //
    LONGLONG GetSeqNum(VOID) const;

    //
    // Get the size of the stream ID in bytes from the EodAck header
    //
    ULONG  GetStreamIdSizeInBytes(VOID) const;

    //
    // Get the stream ID from the EodAck header
    //
    VOID   GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;

    //
    // Get pointer to the stream ID in the EodAck header
    //
    const UCHAR* GetPointerToStreamId(VOID) const;

private:

    //
    // ID number of the EodAck header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Seq ID
    //
    LONGLONG m_SeqId;

    //
    // Seq number
    //
    LONGLONG m_SeqNum;

    //
    // Size in bytes of the stream ID
    //
    ULONG  m_cbStreamIdSize;

    //
    // Buffer with the stream ID
    //
    UCHAR  m_buffer[0];

}; // CEodAckHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CEodAckHeader::CEodAckHeader(
    USHORT      id,
    LONGLONG * pSeqId,
    LONGLONG * pSeqNum,
    ULONG       cbStreamIdSize, 
    UCHAR *     pStreamId
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_SeqId(pSeqId == NULL ? 0 : *pSeqId),
    m_SeqNum(pSeqNum == NULL ? 0 : * pSeqNum),
    m_cbStreamIdSize(cbStreamIdSize)
{
    if (cbStreamIdSize != 0)
    {
        memcpy(&m_buffer[0], pStreamId, cbStreamIdSize);
    }
} // CEodAckHeader::CEodAckHeader

    
inline 
ULONG
CEodAckHeader::CalcSectionSize(
    ULONG cbStreamIdSize
    )
{
    size_t cbSize = sizeof(CEodAckHeader) + cbStreamIdSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CEodAckHeader::CalcSectionSize


inline PCHAR CEodAckHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CEodAckHeader) + m_cbStreamIdSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CEodAckHeader::GetNextSection


inline LONGLONG CEodAckHeader::GetSeqId(VOID) const
{
    return m_SeqId;

} // CEodAckHeader::GetSeqId


inline LONGLONG CEodAckHeader::GetSeqNum(VOID) const
{
    return m_SeqNum;

} // CEodAckHeader::GetSeqNum


inline ULONG CEodAckHeader::GetStreamIdSizeInBytes(VOID) const
{
    return m_cbStreamIdSize;

} // CEodAckHeader::GetStreamIdSizeInBytes


inline VOID CEodAckHeader::GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ULONG cbSize = min(cbBufferSize, m_cbStreamIdSize);

    if (cbSize != 0)
    {
        memcpy(pBuffer, &m_buffer[0], cbSize);
    }
} // CEodAckHeader::GetStreamId


inline const UCHAR* CEodAckHeader::GetPointerToStreamId(VOID) const
{
    return &m_buffer[0];

} // GetPointerToStreamId



#endif // __PHEODACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phinfo.h

Abstract:

    Falcon Packet header info, not passed on network, only stored on disk

Author:

    Erez Haba (erezh) 4-Jun-1996

--*/

#ifndef __PHINFO_H
#define __PHINFO_H

class CPacket;

//---------------------------------------------------------
//
// class CPacketInfo
//
//---------------------------------------------------------

#pragma pack(push, 1)

class CPacketInfo {
public:
    CPacketInfo(ULONGLONG SequentialId);

    ULONG SequentialIdLow32() const;
    ULONG SequentialIdHigh32() const;
    ULONGLONG SequentialId() const;
    void SequentialID(ULONGLONG SequentialId);

    ULONG ArrivalTime() const;
    void ArrivalTime(ULONG ulArrivalTime);

    BOOL InSourceMachine() const;
    void InSourceMachine(BOOL);

    BOOL InTargetQueue() const;
    void InTargetQueue(BOOL);

    BOOL InJournalQueue() const;
    void InJournalQueue(BOOL);

    BOOL InMachineJournal() const;
    void InMachineJournal(BOOL);

    BOOL InDeadletterQueue() const;
    void InDeadletterQueue(BOOL);

    BOOL InMachineDeadxact() const;
    void InMachineDeadxact(BOOL);

    BOOL InConnectorQueue() const;
    void InConnectorQueue(BOOL);

    BOOL InTransaction() const;
    void InTransaction(BOOL);

    BOOL TransactSend() const;
    void TransactSend(BOOL);

    const XACTUOW* Uow() const;
    void Uow(const XACTUOW* pUow);

	void SetOnDiskSignature();
	void ClearOnDiskSignature();
	BOOL ValidOnDiskSignature();

    BOOL SequentialIdMsmq3Format() const;
    void SequentialIdMsmq3Format(BOOL);

private:
    union {
        //
        // Used by MSMQ 3.0 (Whistler) and higher
        //
        ULONGLONG m_SequentialId;

        struct {
            //
            // Used by MSMQ 1.0 and 2.0 for m_pPacket
            //
            ULONG m_SequentialIdLow32;

            //
            // Used by MSMQ 1.0 and 2.0 for a 32 bit SequentialId
            //
            ULONG m_SequentialIdHigh32;
        };
    };
    ULONG m_ulArrivalTime;
    union {
        ULONG m_ulFlags;
        struct {
            ULONG m_bfInSourceMachine   : 1;    // The packet was originaly send from this machine
            ULONG m_bfInTargetQueue     : 1;    // The packet has reached destination queue
            ULONG m_bfInJournalQueue    : 1;    // The packet is in a journal queue
            ULONG m_bfInMachineJournal  : 1;    // The packet is in the machine journal
            ULONG m_bfInDeadletterQueue : 1;    // The packet is in a deadletter queue
            ULONG m_bfInMachineDeadxact : 1;    // The packet is in the machine deadxact
            ULONG m_bfTransacted        : 1;    // The packet is under transaction control
            ULONG m_bfTransactSend      : 1;    // The transacted packet is sent (not received)
            ULONG m_bfInConnectorQueue  : 1;    // The packet has reached the Connector queue
                                                // used in recovery of transacted messages in Connector
			ULONG m_bfSignature			: 12;	// Signature required for valid header
            ULONG m_bfSequentialIdMsmq3 : 1;    // SequentialId is in msmq3 format (i.e. 64 bit)
        };
    };
    XACTUOW m_uow;
};

#pragma pack(pop)


inline CPacketInfo::CPacketInfo(ULONGLONG SequentialId) :
    m_SequentialId(SequentialId),
    m_ulArrivalTime(0),
    m_ulFlags(0)
{
    memset(&m_uow, 0, sizeof(XACTUOW));
    SequentialIdMsmq3Format(TRUE);
}

inline ULONGLONG CPacketInfo::SequentialId() const
{
    return m_SequentialId;
}

inline ULONG CPacketInfo::SequentialIdLow32() const
{
    return m_SequentialIdLow32;
}

inline ULONG CPacketInfo::SequentialIdHigh32() const
{
    return m_SequentialIdHigh32;
}

inline void CPacketInfo::SequentialID(ULONGLONG SequentialId)
{
    m_SequentialId = SequentialId;
}

inline ULONG CPacketInfo::ArrivalTime() const
{
    return m_ulArrivalTime ;
}

inline void CPacketInfo::ArrivalTime(ULONG ulArrivalTime)
{
    m_ulArrivalTime = ulArrivalTime;
}

inline BOOL CPacketInfo::InSourceMachine() const
{
    return m_bfInSourceMachine;
}

inline void CPacketInfo::InSourceMachine(BOOL f)
{
    m_bfInSourceMachine = f;
}

inline BOOL CPacketInfo::InTargetQueue() const
{
    return m_bfInTargetQueue;
}

inline void CPacketInfo::InTargetQueue(BOOL f)
{
    m_bfInTargetQueue = f;
}

inline BOOL CPacketInfo::InJournalQueue() const
{
    return m_bfInJournalQueue;
}

inline void CPacketInfo::InJournalQueue(BOOL f)
{
    m_bfInJournalQueue = f;
}

inline BOOL CPacketInfo::InMachineJournal() const
{
    return m_bfInMachineJournal;
}

inline void CPacketInfo::InMachineJournal(BOOL f)
{
    m_bfInMachineJournal = f;
}

inline BOOL CPacketInfo::InDeadletterQueue() const
{
    return m_bfInDeadletterQueue;
}

inline void CPacketInfo::InDeadletterQueue(BOOL f)
{
    m_bfInDeadletterQueue = f;
}

inline BOOL CPacketInfo::InMachineDeadxact() const
{
    return m_bfInMachineDeadxact;
}

inline void CPacketInfo::InMachineDeadxact(BOOL f)
{
    m_bfInMachineDeadxact = f;
}

inline BOOL CPacketInfo::InConnectorQueue() const
{
    return m_bfInConnectorQueue;
}

inline void CPacketInfo::InConnectorQueue(BOOL f)
{
    m_bfInConnectorQueue = f;
}

inline BOOL CPacketInfo::InTransaction() const
{
    return m_bfTransacted;
}

inline void CPacketInfo::InTransaction(BOOL f)
{
    m_bfTransacted = f;
}

inline BOOL CPacketInfo::TransactSend() const
{
    return m_bfTransactSend;
}

inline void CPacketInfo::TransactSend(BOOL f)
{
   m_bfTransactSend = f;
}

inline const XACTUOW* CPacketInfo::Uow() const
{
    return &m_uow;
}

inline void CPacketInfo::Uow(const XACTUOW* pUow)
{
    memcpy(&m_uow, pUow, sizeof(XACTUOW));
}

inline void CPacketInfo::SetOnDiskSignature()
{
	m_bfSignature = 0xabc;
}

inline void CPacketInfo::ClearOnDiskSignature()
{
	m_bfSignature = 0;
}

inline BOOL CPacketInfo::ValidOnDiskSignature()
{
	return (m_bfSignature & 0xfff) == 0xabc;
}

inline BOOL CPacketInfo::SequentialIdMsmq3Format() const
{
    return m_bfSequentialIdMsmq3;
}

inline void CPacketInfo::SequentialIdMsmq3Format(BOOL f)
{
    m_bfSequentialIdMsmq3 = f;
}

#endif // __PHINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phprop.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phprop.h

Abstract:

    Handle Message properties section

Author:

    Uri Habusha (urih) 5-Feb-96


--*/

#ifndef __PHPROP_H
#define __PHPROP_H

#include "mqprops.h"

#define TitleLengthInBytes (m_bTitleLength*sizeof(WCHAR))
/*

    Following is a description of the Message Property packet fields:

+-----------------+------------------------------------------------------+----------+
| FIELD NAME      | DESCRIPTION                                          | SIZE     |
+-----------------+------------------------------------------------------+----------+
| Reserved        | Must Be Zero                                         | 2 byte   |
+-----------------+------------------------------------------------------+----------+
| Flags           | 0:2: Packet acknowledgment mode:                     | 1 byte   |
|                 |   0  :  No acknowledgment                            |          |
|                 |   1  :  Negative acknowledgment                      |          |
|                 |   2  :  Full acknowledgment                          |          |
+-----------------+------------------------------------------------------+----------+
| Message Class   | The message class, an Falcon acknowledgment          | 1 byte   |
|                 | field.                                               |          |
+-----------------+------------------------------------------------------+----------+
| Correlation ID  | The message correlation number.                      | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| Application Tag | Application specific data.                           | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| message size    | The message body size.                               | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| message title   |                                                      | 0:128    |
+-----------------+------------------------------------------------------+----------+
| message boey    |                                                      | variable |
+-----------------+------------------------------------------------------+----------+

 */

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CPropertyHeader {
public:

    inline CPropertyHeader();

    static ULONG CalcSectionSize(ULONG ulTitleLength,
                                 ULONG ulMsgExtensionSize,
                                 ULONG ulBodySize);
    inline PCHAR GetNextSection(void) const;


    inline void  SetClass(USHORT usClass);
    inline USHORT GetClass(void) const;

    inline void  SetAckType(UCHAR bAckType);
    inline UCHAR GetAckType(void) const;

    inline void SetCorrelationID(const UCHAR * pCorrelationID);
    inline void GetCorrelationID(PUCHAR) const;
    inline const UCHAR *GetCorrelationID(void) const;

    inline void  SetApplicationTag(ULONG dwApplicationTag);
    inline ULONG GetApplicationTag(void) const;

    inline void  SetBody(const UCHAR* pBody, ULONG ulSize, ULONG ulAllocSize);
    inline void  GetBody(PUCHAR pBody, ULONG ulSize) const;
    inline const UCHAR* GetBodyPtr() const;
    inline ULONG GetBodySize(void) const;
    inline void  SetBodySize(ULONG ulBodySize);
    inline ULONG GetAllocBodySize(void) const;

    inline void SetMsgExtension(const UCHAR* pMsgExtension,
                                ULONG ulSize);
    inline void GetMsgExtension(PUCHAR pMsgExtension,
                                ULONG ulSize) const;
    inline const UCHAR* GetMsgExtensionPtr(void) const;
    inline ULONG GetMsgExtensionSize(void) const;

    inline void  SetTitle(const WCHAR* pwTitle, ULONG ulTitleLength);
    inline void  GetTitle(PWCHAR pwTitle, ULONG ulBufferSizeInWCHARs) const;
    inline const WCHAR* GetTitlePtr(void) const;
    inline ULONG GetTitleLength(void) const;

    inline void SetPrivLevel(ULONG);
    inline ULONG GetPrivLevel(void) const;
    inline ULONG GetPrivBaseLevel(void) const;

    inline void SetHashAlg(ULONG);
    inline ULONG GetHashAlg(void) const;

    inline void SetEncryptAlg(ULONG);
    inline ULONG GetEncryptAlg(void) const;

    inline void SetBodyType(ULONG);
    inline ULONG GetBodyType(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;
	
private:
//
// BEGIN Network Monitor tag
//
    UCHAR m_bFlags;
    UCHAR m_bTitleLength;
    USHORT m_usClass;
    UCHAR m_acCorrelationID[PROPID_M_CORRELATIONID_SIZE];
    ULONG m_ulBodyType;
    ULONG m_ulApplicationTag;
    ULONG m_ulBodySize;
    ULONG m_ulAllocBodySize;
    ULONG m_ulPrivLevel;
    ULONG m_ulHashAlg;
    ULONG m_ulEncryptAlg;
    ULONG m_ulExtensionSize;
    UCHAR m_awTitle[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline CPropertyHeader::CPropertyHeader() :
    m_bFlags(DEFAULT_M_ACKNOWLEDGE),
    m_bTitleLength(0),
    m_usClass(MQMSG_CLASS_NORMAL),
    m_ulBodyType(0),
    m_ulApplicationTag(0),
    m_ulBodySize(0),
    m_ulAllocBodySize(0),
    m_ulPrivLevel(MQMSG_PRIV_LEVEL_NONE),
    m_ulHashAlg(0),
    m_ulEncryptAlg(0),
    m_ulExtensionSize(0)
{
    memset(m_acCorrelationID, 0, PROPID_M_CORRELATIONID_SIZE);
    //
    // BUGBUG: CPropertyHeader::CPropertyHeader implementation
    //
}

/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline ULONG CPropertyHeader::CalcSectionSize(ULONG ulTitleLength,
                                              ULONG ulMsgExtensionSize,
                                              ULONG ulBodySize)
{
    return ALIGNUP4_ULONG(
            sizeof(CPropertyHeader) +
            min(ulTitleLength, MQ_MAX_MSG_LABEL_LEN) * sizeof(WCHAR) +
            ulMsgExtensionSize +
            ulBodySize
            );
}


/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline PCHAR CPropertyHeader::GetNextSection(void) const
{
	ULONG_PTR ptrArray[] = {sizeof(*this),
							TitleLengthInBytes,
							m_ulExtensionSize,
		                	m_ulAllocBodySize
		                	};

	ULONG_PTR size = SafeAddPointers(4, ptrArray);
	size = SafeAlignUp4Ptr(size);
	ULONG_PTR ptrArray2[] = {size, (ULONG_PTR)this};
	size = SafeAddPointers(2, ptrArray2);
	return (PCHAR)size;
}


/*======================================================================

 Function:    CPropertyHeader::SetClass

 Description: Set/Clear Message Class

 =======================================================================*/
inline void CPropertyHeader::SetClass(USHORT usClass)
{
    m_usClass = usClass;
}
/*======================================================================

 Function:     CPropertyHeader::GetClass

 Description:  Returns message class

 =======================================================================*/
inline USHORT CPropertyHeader::GetClass(void) const
{
    return m_usClass;
}

/*===========================================================

  Routine Name:  CPropertyHeader::SetAckType

  Description:   Set The Ack Type

=============================================================*/
inline void CPropertyHeader::SetAckType(UCHAR bAckType)
{
    //
    //  BUGBUG: ack type
    //

    m_bFlags = bAckType;
}

/*===========================================================

  Routine Name:  CPropertyHeader::GetAckType

  Description:   Returns The Ack Type

=============================================================*/
inline UCHAR CPropertyHeader::GetAckType(void) const
{
    //
    //  BUGBUG: ack type
    //

    return m_bFlags;
}

/*======================================================================

 Function:    CPropertyHeader::SetCorrelation

 Description: Set Message correlation

 =======================================================================*/
inline void CPropertyHeader::SetCorrelationID(const UCHAR * pCorrelationID)
{
    memcpy(m_acCorrelationID, pCorrelationID, PROPID_M_CORRELATIONID_SIZE);
}

/*======================================================================

 Function:    CPropertyHeader::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline void CPropertyHeader::GetCorrelationID(PUCHAR pCorrelationID) const
{
    ASSERT (pCorrelationID != NULL);
    memcpy(pCorrelationID, m_acCorrelationID, PROPID_M_CORRELATIONID_SIZE);
}

/*======================================================================

 Function:    CPropertyHeader::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline const UCHAR *CPropertyHeader::GetCorrelationID(void) const
{
    return m_acCorrelationID;
}

/*======================================================================

 Function:    CPropertyHeader::SetApplicationTag

 Description: Set Applecation specific data

 =======================================================================*/
inline void CPropertyHeader::SetApplicationTag(ULONG ulApplicationTag)
{
    m_ulApplicationTag = ulApplicationTag;
}

/*======================================================================

 Function:    CPropertyHeader::GetApplicationTag

 Description: Returns Applecation specific data

 =======================================================================*/
inline ULONG CPropertyHeader::GetApplicationTag(void) const
{
    return m_ulApplicationTag;
}

/*======================================================================

 Function:    CPropertyHeader::SetBody

 Description: Get Message body size

 =======================================================================*/
inline void CPropertyHeader::SetBody(const UCHAR * pBody, ULONG ulSize, ULONG ulAllocSize)
{
    m_ulAllocBodySize = ulAllocSize;
    m_ulBodySize = ulSize;
    memcpy(&m_awTitle[TitleLengthInBytes + m_ulExtensionSize], pBody, ulSize);
}

/*======================================================================

 Function:    CPropertyHeader::GetBody

 Description: Get Message body size

 =======================================================================*/
inline void CPropertyHeader::GetBody(PUCHAR pBody, ULONG ulSize) const
{
    memcpy( pBody,
            &m_awTitle[TitleLengthInBytes + m_ulExtensionSize],
            ((ulSize < m_ulBodySize) ?  ulSize : m_ulBodySize)
            );
}

/*======================================================================

 Function:    CPropertyHeader::GetBodyPtr

 Description: Get Message body size

 =======================================================================*/
inline const UCHAR* CPropertyHeader::GetBodyPtr() const
{
    return (PUCHAR)&m_awTitle[TitleLengthInBytes + m_ulExtensionSize];
}
/*======================================================================

 Function:    CPropertyHeader::GetBodySize

 Description: Get Message body size

 =======================================================================*/
inline ULONG CPropertyHeader::GetBodySize(void) const
{
    return m_ulBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::SetBodySize

 Description: Set Message body size

 =======================================================================*/
inline void CPropertyHeader::SetBodySize(ULONG ulBodySize)
{
    ASSERT(ulBodySize <= m_ulAllocBodySize);
    m_ulBodySize = ulBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::GetAllocBodySize

 Description: Get the allocated message body size

 =======================================================================*/
inline ULONG CPropertyHeader::GetAllocBodySize(void) const
{
    return m_ulAllocBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::SetMsgExtension

 Description: Set Message Extension

 =======================================================================*/
inline void
CPropertyHeader::SetMsgExtension(const UCHAR* pMsgExtension,
                                 ULONG ulSize)
{
    m_ulExtensionSize = ulSize;
    memcpy(&m_awTitle[TitleLengthInBytes], pMsgExtension, ulSize);
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtension

 Description: Get Message Extension

 =======================================================================*/
inline void
CPropertyHeader::GetMsgExtension(PUCHAR pMsgExtension,
                                 ULONG ulSize) const
{
    memcpy( pMsgExtension,
            &m_awTitle[TitleLengthInBytes],
            ((ulSize < m_ulExtensionSize) ?  ulSize : m_ulExtensionSize)
            );
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtensionPtr

 Description: Get pointer to Message Extension

 =======================================================================*/
inline const UCHAR*
CPropertyHeader::GetMsgExtensionPtr(void) const
{
    return &m_awTitle[TitleLengthInBytes];
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtensionSize

 Description: Get Message Extension size

 =======================================================================*/
inline ULONG CPropertyHeader::GetMsgExtensionSize(void) const
{
    return m_ulExtensionSize;
}

/*======================================================================

 Function:    CPropertyHeader::SetTitle

 Description: Set Message title

 =======================================================================*/
inline void CPropertyHeader::SetTitle(const WCHAR* pwTitle, ULONG ulTitleLength)
{
    if(ulTitleLength > MQ_MAX_MSG_LABEL_LEN)
    {
        ulTitleLength = MQ_MAX_MSG_LABEL_LEN;
    }

    m_bTitleLength = (UCHAR)ulTitleLength;
    memcpy(m_awTitle, pwTitle, ulTitleLength * sizeof(WCHAR));
}

/*======================================================================

 Function:    CPropertyHeader::GetTitle

 Description: Get Message title

 =======================================================================*/
inline void CPropertyHeader::GetTitle(PWCHAR pwTitle, ULONG ulBufferSizeInWCHARs) const
{
    if(ulBufferSizeInWCHARs > m_bTitleLength)
    {
        ulBufferSizeInWCHARs = m_bTitleLength;
    }

    if(ulBufferSizeInWCHARs == 0)
    {
        return;
    }

    --ulBufferSizeInWCHARs;

    memcpy(pwTitle, m_awTitle, ulBufferSizeInWCHARs * sizeof(WCHAR));
    pwTitle[ulBufferSizeInWCHARs] = L'\0';
}

/*======================================================================

 Function:    CPropertyHeader::GetTitlePtr

 Description: Get Message title

 =======================================================================*/
inline const WCHAR* CPropertyHeader::GetTitlePtr(void) const
{
    return ((WCHAR*)m_awTitle);
}

/*======================================================================

 Function:    CPropertyHeader::GetTitleSize

 Description: Get the size of Message title

 =======================================================================*/
inline ULONG CPropertyHeader::GetTitleLength(void) const
{
    return(m_bTitleLength);
}

/*======================================================================

 Function:    CPropertyHeader::SetPrivLevel

 Description: Set the privacy level of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetPrivLevel(ULONG ulPrivLevel)
{
    m_ulPrivLevel = ulPrivLevel;
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetPrivLevel(void) const
{
    return(m_ulPrivLevel);
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivBaseLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetPrivBaseLevel(void) const
{
    return(m_ulPrivLevel & MQMSG_PRIV_LEVEL_BODY_BASE) ;
}

/*======================================================================

 Function:    CPropertyHeader::SetHashAlg

 Description: Set the hash algorithm of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetHashAlg(ULONG ulHashAlg)
{
    m_ulHashAlg = ulHashAlg;
}

/*======================================================================

 Function:    CPropertyHeader::GetHashAlg

 Description: Get the hash algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetHashAlg(void) const
{
    return(m_ulHashAlg);
}

/*======================================================================

 Function:    CPropertyHeader::SetEncryptAlg

 Description: Set the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetEncryptAlg(ULONG ulEncryptAlg)
{
    m_ulEncryptAlg = ulEncryptAlg;
}

/*======================================================================

 Function:    CPropertyHeader::GetEncryptAlg

 Description: Get the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetEncryptAlg(void) const
{
    return(m_ulEncryptAlg);
}

/*======================================================================

 Function:    CPropertyHeader::SetBodyType

 =======================================================================*/
inline void CPropertyHeader::SetBodyType(ULONG ulBodyType)
{
    m_ulBodyType = ulBodyType;
}

/*======================================================================

 Function:    CPropertyHeader::GetBodyType

 =======================================================================*/
inline ULONG CPropertyHeader::GetBodyType(void) const
{
    return  m_ulBodyType;
}

#endif // __PHPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phsecure.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phsecure.h

Abstract:

    Handle Security section in Falcon Header

Author:

    Uri Habusha (urih) 5-Feb-96

--*/

#ifndef __PHSECURE_H
#define __PHSECURE_H

#include <mqmacro.h>

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
// The following structures are used to add new security related data into
// the m_abSecurityInfo[] buffer. By "new" I mean anything which was not in
// MSMQ1.0 or win2k RTM.
// The new data appear at the end of the buffer. If we add new subsections in
// future releases of MSMQ, they will be backward compatible because old
// versions of msmq will see them an unknown type and ignore them.
// compatibility with msmq1.0 and win2k rtm:
// These versions of msmq look at m_ulProvInfoSize to determine size of name
// of authentication provider and then read the provider name as string, using
// wcslen. so I'll add the new section after the null termination and update
// m_ulProvInfoSize to reflect new size (authentication provider + new data).
// So old code will compute size correctly, will read provider correctly and
// will ignore all new data.
//

//
// define types of subsections.
//
enum enumSecInfoType
{
    //
    // Used for testing only.
    //
    e_SecInfo_Test = 0,
    //
    // This one is the extra signature, done by run-time in the context of
    // the user process, using the user private key.
    //
    e_SecInfo_User_Signature_ex = 1,

    //
    // This one is the extra signature, done by msmq service, using the
    // private key of the service. The msmq service will add this signature,
    // (instead of being add by the run time) for dependent clients and for
    // connector applications that sign by themselves. The default is that
    // user sign. We can't sent a packet without this extra signature,
    // because it will be rejected by the receiver side.
    //
    e_SecInfo_QM_Signature_ex
} ;

//
//  Structure members:
// eType- type of subsection.
// wSubSectionLen- length of the entire subsection structure, including data.
// wFlags- flags to specify features of this subsection. This word is context
//   sensitive and depend on the type of subsection. So each type of
//   subsection may have its own definition of a bitfield structure.
//   m_bfDefault- 1 if the section has default data. In that case, the aData
//     buffer is not present.
// aData[]- buffer containing the data. This buffer may have internal
//          structure, known to the specific code.
//
struct _SecuritySubSectionEx
{
    enum enumSecInfoType eType ;
    USHORT               wSubSectionLen ;

    union
    {
        USHORT wFlags;
        struct _DefaultFlag
        {
            USHORT m_bfDefault    : 1;
        } _DefaultFlags ;
        struct _UserSigEx
        {
            //
            // This is the structure definitions for subsection type
            // e_SecInfo_User_Signature_ex.
            // a 0 mean the relevant field is not included in the enhanced
            // signature.
            //
            USHORT m_bfTargetQueue  : 1;
            USHORT m_bfSourceQMGuid : 1;
            //
            // Flags provider by caller to MQSendMessage()
            //
            USHORT m_bfUserFlags  : 1;
            USHORT m_bfConnectorType : 1;
        } _UserSigEx ;
    } _u ;

    CHAR   aData[0] ;
} ;

//
//  Structure members:
// cSubSectionCount - number of subsections.
// wSectionLen - overall length of this section, including all subsections.
// aData[]- buffer containing all the subsection.
//
struct _SecuritySectionEx
{
    USHORT  cSubSectionCount ;
    USHORT  wSectionLen ;

    CHAR    aData[0] ;
} ;

//
//  struct CSecurityHeader
//

struct CSecurityHeader {
public:

    inline CSecurityHeader();

    static ULONG CalcSectionSize(USHORT, USHORT, USHORT, ULONG, ULONG);
    inline PCHAR GetNextSection(void) const;

    inline void SetAuthenticated(BOOL);
    inline BOOL IsAuthenticated(void) const;

    inline void SetLevelOfAuthentication(UCHAR);
    inline UCHAR GetLevelOfAuthentication(void) const;

    inline void SetEncrypted(BOOL);
    inline BOOL IsEncrypted(void) const;

    inline void SetSenderIDType(USHORT wSenderID);
    inline USHORT GetSenderIDType(void) const;

    inline void SetSenderID(const UCHAR *pbSenderID, USHORT wSenderIDSize);
    inline const UCHAR* GetSenderID(USHORT* pwSize) const;

    inline void SetSenderCert(const UCHAR *pbSenderCert, ULONG ulSenderCertSize);
    inline const UCHAR* GetSenderCert(ULONG* pulSize) const;
    inline BOOL SenderCertExist(void) const;

    inline void SetEncryptedSymmetricKey(const UCHAR *pbEncryptedKey, USHORT wEncryptedKeySize);
    inline const UCHAR* GetEncryptedSymmetricKey(USHORT* pwSize) const;

    inline void SetSignature(const UCHAR *pbSignature, USHORT wSignatureSize);
	inline USHORT GetSignatureSize(void) const;
    inline const UCHAR* GetSignature(USHORT* pwSize) const;

    inline void SetProvInfoEx( ULONG    ulSize,
                               BOOL     bDefProv,
                               LPCWSTR  wszProvName,
                               ULONG    dwPRovType ) ;
    inline void GetProvInfo(BOOL *pbDefProv, LPCWSTR *wszProvName, ULONG *pdwPRovType) const;

    inline void SetSectionEx(const UCHAR *pSection, ULONG wSectionSize);
    inline const struct _SecuritySubSectionEx *
                     GetSubSectionEx( enum enumSecInfoType eType ) const ;

	void SectionIsValid(PCHAR PacketEnd) const;
	
private:
    inline const UCHAR *GetSectionExPtr() const ;
    inline void SetProvInfo(BOOL bDefProv, LPCWSTR wszProvName, ULONG dwPRovType);

//
// BEGIN Network Monitor tag
//   m_bfSecInfoEx- this flag indicates that "m_abSecurityInfo" buffer
//      contains more data than was in MSMQ1.0 and win2k rtm.
//      In MSMQ1.0, this buffer optionally contained the security provider
//      used for authentication (at the end of the bufferm after sender
//      sid and flags).
//
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfSenderIDType			: 4;
            USHORT m_bfAuthenticated		: 1;
            USHORT m_bfEncrypted			: 1;
            USHORT m_bfDefProv				: 1;
            USHORT m_bfSecInfoEx			: 1;
            USHORT m_LevelOfAuthentication	: 4;
        };
    };
    USHORT m_wSenderIDSize;
    USHORT m_wEncryptedKeySize;
    USHORT m_wSignatureSize;
    ULONG  m_ulSenderCertSize;
    ULONG  m_ulProvInfoSize;
    UCHAR  m_abSecurityInfo[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline CSecurityHeader::CSecurityHeader():
    m_wFlags(0),
    m_wSenderIDSize(0),
    m_wEncryptedKeySize(0),
    m_wSignatureSize(0),
    m_ulSenderCertSize(0),
    m_ulProvInfoSize(0)
{
}

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline
ULONG
CSecurityHeader::CalcSectionSize(
    USHORT wSenderIDSize,
    USHORT wEncryptedKeySize,
    USHORT wSignatureSize,
    ULONG  ulSenderCertSize,
    ULONG  ulProvInfoSize
    )
{
    if (!wSenderIDSize &&
        !wEncryptedKeySize &&
        !wSignatureSize &&
        !ulSenderCertSize &&
        !ulProvInfoSize)
    {
        return 0;
    }
    else
    {
        // If the message is signed, we must have also the user identity.
        return (
               sizeof(CSecurityHeader) +
               ALIGNUP4_ULONG(wSenderIDSize) +
               ALIGNUP4_ULONG(wEncryptedKeySize) +
               ALIGNUP4_ULONG(wSignatureSize) +
               ALIGNUP4_ULONG(ulSenderCertSize) +
               ALIGNUP4_ULONG(ulProvInfoSize)
               );
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline PCHAR CSecurityHeader::GetNextSection(void) const
{
    // At least one of the security parameters should exist inorder to
    // have the security header, otherwise no need to include it in the
    // message.
    ASSERT(m_wSenderIDSize ||
           m_wEncryptedKeySize ||
           m_wSignatureSize ||
           m_ulSenderCertSize ||
           m_ulProvInfoSize);

	ULONG_PTR ptrArray[] = {(ULONG_PTR)this,
					        sizeof(*this),
							SafeAlignUp4Ptr(m_wSenderIDSize),
							SafeAlignUp4Ptr(m_wEncryptedKeySize),
							SafeAlignUp4Ptr(m_wSignatureSize),
							SafeAlignUp4Ptr(m_ulSenderCertSize),
							SafeAlignUp4Ptr(m_ulProvInfoSize)
							};
	ULONG_PTR size = SafeAddPointers (7, ptrArray);
	return (PCHAR)size;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetAuthenticated

 Description:   Set the authenticated bit

===============================================================*/
inline void CSecurityHeader::SetAuthenticated(BOOL f)
{
    m_bfAuthenticated = (USHORT)f;
}

/*=============================================================

 Routine Name:   CSecurityHeader::IsAuthenticated

 Description:    Returns TRUE if the msg is authenticated, False otherwise

===============================================================*/
inline BOOL
CSecurityHeader::IsAuthenticated(void) const
{
    return m_bfAuthenticated;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetLevelOfAuthentication

 Description:   Set the Level Of Authentication

===============================================================*/
inline void CSecurityHeader::SetLevelOfAuthentication(UCHAR Level)
{
    ASSERT(Level < 16); // There are four bits for LevelOfAuthentication.
    m_LevelOfAuthentication = (USHORT)Level;
}

/*==========================================================================

 Routine Name:   CSecurityHeader::GetLevelOfAuthentication

 Description:    Return the Level Of Authentication.

===========================================================================*/
inline UCHAR
CSecurityHeader::GetLevelOfAuthentication(void) const
{
    return m_LevelOfAuthentication;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetEncrypted

 Description:   Set Encrypted message bit

===============================================================*/
inline void CSecurityHeader::SetEncrypted(BOOL f)
{
    m_bfEncrypted = (USHORT)f;
}

/*=============================================================

 Routine Name:   CSecurityHeader::IsEncrypted

 Description:    Returns TRUE if the msg is Encrypted, False otherwise

===============================================================*/
inline BOOL CSecurityHeader::IsEncrypted(void) const
{
    return m_bfEncrypted;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderIDType

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderIDType(USHORT wSenderID)
{
    ASSERT(wSenderID < 16); // There are four bits for the user ID type.
    m_bfSenderIDType = wSenderID;
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderIDType

 Description:

===============================================================*/
inline USHORT CSecurityHeader::GetSenderIDType(void) const
{
    return m_bfSenderIDType;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderID

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderID(const UCHAR *pbSenderID, USHORT wSenderIDSize)
{
    // Should set the user identity BEFORE setting the encription and
    // authentication sections.
    ASSERT(!m_wEncryptedKeySize &&
           !m_wSignatureSize &&
           !m_ulSenderCertSize &&
           !m_ulProvInfoSize);
    m_wSenderIDSize = wSenderIDSize;
    memcpy(m_abSecurityInfo, pbSenderID, wSenderIDSize);
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderID

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSenderID(USHORT* pwSize) const
{
    *pwSize = m_wSenderIDSize;
    return m_abSecurityInfo;
}

/*=============================================================

 Routine Name:

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetEncryptedSymmetricKey(
    const UCHAR *pbEncryptedKey,
    USHORT wEncryptedKeySize
    )
{
    // Should set the encryption section BEFORE setting the authentication
    // section.
    ASSERT(m_wEncryptedKeySize ||
           (!m_wSignatureSize && !m_ulSenderCertSize && !m_ulProvInfoSize));
    ASSERT(!m_wEncryptedKeySize || (m_wEncryptedKeySize == wEncryptedKeySize));
    m_wEncryptedKeySize = wEncryptedKeySize;
    //
    // It is possible to call this function with no buffer for the encrypted
    // key. This is done by the device driver. the device driver only makes
    // room in the security header for the symmetric key. The QM writes
    // the symmetric key in the security header after encrypting the message
    // body.
    //
    if (pbEncryptedKey)
    {
        memcpy(
            &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)],
            pbEncryptedKey,
            wEncryptedKeySize);
    }
}

/*=============================================================

 Routine Name:

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetEncryptedSymmetricKey(USHORT* pwSize) const
{
    *pwSize = m_wEncryptedKeySize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)];
}
/*=============================================================

 Routine Name:   CSecurityHeader::SetSignature

 Description:

===============================================================*/
inline void CSecurityHeader::SetSignature(const UCHAR *pbSignature, USHORT wSignatureSize)
{
    ASSERT(!m_ulSenderCertSize && !m_ulProvInfoSize);
    m_wSignatureSize = wSignatureSize;
    memcpy(
        &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                          ALIGNUP4_ULONG(m_wEncryptedKeySize)],
        pbSignature,
        wSignatureSize
        );
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSignatureSize

 Description:

===============================================================*/
inline USHORT CSecurityHeader::GetSignatureSize(void) const
{
    return m_wSignatureSize;
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSignature

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSignature(USHORT* pwSize) const
{
    *pwSize = m_wSignatureSize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize)];
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderCert

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderCert(const UCHAR *pbSenderCert, ULONG ulSenderCertSize)
{
    // Should set the user identity BEFORE setting the encription and
    // authentication sections.
    ASSERT(!m_ulProvInfoSize);
    m_ulSenderCertSize = ulSenderCertSize;
    memcpy(&m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                             ALIGNUP4_ULONG(m_wSignatureSize)],
           pbSenderCert,
           ulSenderCertSize);
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderCert

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSenderCert(ULONG* pulSize) const
{
    *pulSize = m_ulSenderCertSize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                             ALIGNUP4_ULONG(m_wSignatureSize)];
}

/*=============================================================

 Routine Name:  CSecurityHeader::SenderCertExist

 Description:	Returns TRUE if Sender Certificate exist

===============================================================*/
inline BOOL CSecurityHeader::SenderCertExist(void) const
{
    return(m_ulSenderCertSize != 0);
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetProvInfo

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetProvInfo(
    BOOL bDefProv,
    LPCWSTR wszProvName,
    ULONG ulProvType)
{
    m_bfDefProv = (USHORT)bDefProv;
    if(!m_bfDefProv)
    {
        //
        // We fill the provider info only if this is not the default provider.
        //
        UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize) +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];

        //
        // Write the provider type.
        //
        *(ULONG *)pProvInfo = ulProvType;
        pProvInfo += sizeof(ULONG);

        //
        // Write the provider name. we use unsafe API because the packet size
        // was computed before, if we did it wrong -> AV
        //
        wcscpy((WCHAR*)pProvInfo, wszProvName);

        //
        // Compute the size of the provider information.
        //
        m_ulProvInfoSize = static_cast<ULONG>((wcslen(wszProvName) + 1) * sizeof(WCHAR) + sizeof(ULONG));
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetProvInfoEx

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetProvInfoEx(
        ULONG    ulSize,
        BOOL     bDefProv,
        LPCWSTR  wszProvName,
        ULONG    ulProvType )
{
    SetProvInfo(bDefProv, wszProvName, ulProvType);

    if (ulSize != 0)
    {
        ASSERT(ulSize >= m_ulProvInfoSize);
        if (ulSize > m_ulProvInfoSize)
        {
            m_ulProvInfoSize = ulSize;
        }
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetProvInfo

 Description:

===============================================================*/
inline
void
CSecurityHeader::GetProvInfo(
    BOOL *pbDefProv,
    LPCWSTR *wszProvName,
    ULONG *pulProvType) const
{
    *pbDefProv = m_bfDefProv;
    if(!m_bfDefProv)
    {
        //
        // We fill the provider type and name only if this is not the default
        // provider.
        //
        ASSERT(m_ulProvInfoSize);
        const UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize) +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];

        //
        // Fill the provider type.
        //
        *pulProvType = *(ULONG *)pProvInfo;
        pProvInfo += sizeof(ULONG);

        //
        // Fill the provider name.
        //
        *wszProvName = (WCHAR*)pProvInfo;
    }
}

/*=============================================================

 Routine Name: CSecurityHeader::GetSectionExPtr()

===============================================================*/

inline const UCHAR *
CSecurityHeader::GetSectionExPtr() const
{
    if (m_bfSecInfoEx == 0)
    {
        return NULL ;
    }

    const UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)     +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize)    +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];
    //
    // First see if authentication provider is present.
    //
    if ((m_wSignatureSize != 0) && !m_bfDefProv)
    {
        //
        // Skip provider of authentication.
        //
        pProvInfo += sizeof(ULONG) ;

        size_t MaxLength = (m_ulProvInfoSize - 4) / sizeof(WCHAR);
		size_t Length = mqwcsnlen((WCHAR*)pProvInfo, MaxLength);
		if (Length >= MaxLength)
		{
			ReportAndThrow("provider string is not NULL terminated");
		}

		pProvInfo += sizeof(WCHAR) * (1 + Length);
        pProvInfo = (UCHAR*) ALIGNUP4_PTR(pProvInfo) ;
    }

    return pProvInfo ;
}

/*=============================================================

 Routine Name: CSecurityHeader::SetSectionEx()

===============================================================*/

inline void
CSecurityHeader::SetSectionEx(const UCHAR *pSection, ULONG wSectionSize)
{
    m_bfSecInfoEx = 1 ;

    UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;

    if (pProvInfo)
    {
        memcpy( pProvInfo,
                pSection,
                wSectionSize ) ;
    }
    else
    {
        m_bfSecInfoEx = 0 ;
    }

    ASSERT(m_bfSecInfoEx == 1) ;
}

/*=============================================================

 Routine Name: pGetSubSectionEx()

===============================================================*/

inline
struct _SecuritySubSectionEx  *pGetSubSectionEx(
                            IN enum enumSecInfoType  eType,
                            IN const UCHAR          *pSectionEx,
                            IN const UCHAR          *pEnd)
{
	if ((pEnd != NULL) && (pSectionEx + sizeof(_SecuritySectionEx) >= pEnd))
	{
        ReportAndThrow("Security section is not valid: No roon for _SecuritySectionEx");
	}
    struct _SecuritySectionEx *pSecEx = (struct _SecuritySectionEx *) pSectionEx ;
    USHORT  cSubSections = pSecEx->cSubSectionCount ;

    struct _SecuritySubSectionEx *pSubSecEx = (struct _SecuritySubSectionEx *) &(pSecEx->aData[0]) ;

    for ( USHORT j = 0 ; j < cSubSections ; j++ )
    {
		if ((pEnd != NULL) && ((UCHAR*)pSubSecEx + sizeof(_SecuritySubSectionEx) > pEnd))
		{
	        ReportAndThrow("Security section is not valid: No roon for _SecuritySubSectionEx");
		}

		//
		// no need to use safe functions because wSubSectionLen is only USHORT
		//
		
        ULONG ulSubSecLen = ALIGNUP4_ULONG((ULONG)pSubSecEx->wSubSectionLen) ;

        if ((NULL == pEnd) && (eType == pSubSecEx->eType))
        {
            return  pSubSecEx ;
        }

        UCHAR *pTmp = (UCHAR*) pSubSecEx ;
        pTmp += ulSubSecLen ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pTmp ;
    }

    return NULL ;
}

/*=============================================================

 Routine Name: CSecurityHeader::GetSubSectionEx()

===============================================================*/

inline
const struct _SecuritySubSectionEx *
CSecurityHeader::GetSubSectionEx( enum enumSecInfoType eType ) const
{
    const UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;
    if (!pProvInfo)
    {
        return NULL ;
    }

    struct _SecuritySubSectionEx  *pSecEx =
                                 pGetSubSectionEx( eType, pProvInfo, NULL) ;
    return pSecEx ;
}


#endif // __PHSECURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phsenderstream.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phxact2.h

Abstract:

    Stream information Section for exaclly once delivery (used only in sender side)

Author:

    Gilsh    11-Sep-2001
--*/

#ifndef __PHSENDERSTREAM_H
#define __PHSENDERSTREAM_H
//
//  struct CSenderStreamHeader
//
#include <mqwin64a.h>
#include <acdef.h>

#pragma pack(push, 1)
 
class CSenderStreamHeader {
public:
    inline CSenderStreamHeader(const CSenderStream& SenderStream, USHORT id);
	inline static DWORD CalcSectionSize();
    inline PCHAR GetNextSection(void) const;
	inline const CSenderStream* GetSenderStream() const;

private:
	CSenderStream m_SenderStream;
	USHORT m_id;
};

#pragma pack(pop)

/*=============================================================

 Routine Name:  CSenderStreamHeader

 Description:

===============================================================*/
inline CSenderStreamHeader::CSenderStreamHeader(
									const CSenderStream& SenderStream,
									USHORT id
									):
									m_id(id),
									m_SenderStream(SenderStream)
{
	ASSERT(SenderStream.IsValid() );	
}




/*=============================================================

 Routine Name:  CSenderStreamHeader::CalcSectionSize()

 Description:

===============================================================*/
inline ULONG CSenderStreamHeader::CalcSectionSize()
{
	ULONG ulSize = sizeof(CSenderStreamHeader);
	return ALIGNUP4_ULONG(ulSize);
}



/*=============================================================

 Routine Name:  CSenderStreamHeader::GetNextSection

 Description:

===============================================================*/
inline PCHAR CSenderStreamHeader::GetNextSection(void) const
{
    int size = sizeof(*this);

    return (PCHAR)this + ALIGNUP4_ULONG(size);
}



/*=============================================================

 Routine Name:  CSenderStreamHeader::GetSenderStream

 Description:

===============================================================*/
inline const CSenderStream* CSenderStreamHeader::GetSenderStream() const
{
	return &m_SenderStream;
}



#endif // __PHSENDERSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phsrmpenv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phSrmpEnv.h

Abstract:

    Packet header for SRMP Envelope.

Author:

    Shai Kariv  (shaik)  11-Oct-2000

--*/

#ifndef __PHSRMP_ENV_H
#define __PHSRMP_ENV_H


/*+++

    Note: Packet may contain 0 or 2 SRMP headers (one for envelope, one for CompoundMessage).
          Packet may not contain only 1 SRMP header.

    SrmpEnvelope header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data Length    | Length of the data in WCHARs.                         | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data WCHARs including NULL terminator.            | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CSrmpEnvelopeHeader
{
public:

    //
    // Construct the SRMP Envelope header
    //
    CSrmpEnvelopeHeader(WCHAR * pData, ULONG DataLengthInWCHARs, USHORT id);

    //
    // Get size in BYTEs of the SRMP Envelope header.
    //
    static ULONG CalcSectionSize(ULONG DataLengthInWCHARs);

    //
    // Get pointer to first byte after the SRMP Envelope header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Copy the data from the SRMP Envelope header
    //
    VOID   GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const;

    //
    // Get the length of the data in WCHARs from the SRMP Envelope header
    //
    ULONG  GetDataLengthInWCHARs(VOID) const;

    const WCHAR* GetPointerToData(VOID) const;


private:

    //
    // ID number of the SRMP Envelope header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Length in WCHARs of the data
    //
    ULONG  m_DataLength;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CSrmpEnvelopeHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CSrmpEnvelopeHeader::CSrmpEnvelopeHeader(
    WCHAR * pData, 
    ULONG   DataLengthInWCHARs, 
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataLength(DataLengthInWCHARs + 1)
{
    if (DataLengthInWCHARs != 0)
    {
        memcpy(&m_buffer[0], pData, DataLengthInWCHARs * sizeof(WCHAR));
    }

	//
	// Putting unicode null terminator at end of buffer.
	//
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR)]     = '\0';
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR) + 1] = '\0';

} // CSrmpEnvelopeHeader::CSrmpEnvelopeHeader


inline 
ULONG
CSrmpEnvelopeHeader::CalcSectionSize(
    ULONG DataLengthInWCHARs
    )
{
    size_t cbSize = sizeof(CSrmpEnvelopeHeader) + ((DataLengthInWCHARs + 1) * sizeof(WCHAR));

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CSrmpEnvelopeHeader::CalcSectionSize


inline PCHAR CSrmpEnvelopeHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CSrmpEnvelopeHeader) + (m_DataLength * sizeof(WCHAR));
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CSrmpEnvelopeHeader::GetNextSection


inline VOID CSrmpEnvelopeHeader::GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const
{
    ULONG length = min(BufferLengthInWCHARs, m_DataLength);

    if (length != 0)
    {
        memcpy(pBuffer, &m_buffer[0], length * sizeof(WCHAR));
        pBuffer[length - 1] = L'\0';
    }
} // CSrmpEnvelopeHeader::GetData


inline ULONG CSrmpEnvelopeHeader::GetDataLengthInWCHARs(VOID) const
{
    return m_DataLength;

} // CSrmpEnvelopeHeader::GetDataLengthInWCHARs


inline const WCHAR* CSrmpEnvelopeHeader::GetPointerToData() const
{
	return reinterpret_cast<const WCHAR*>(&m_buffer[0]);
}



#endif // __PHSRMP_ENV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phuser.h ===
/*++
                
Copyright (c) 1995  Microsoft Corporation

Module Name:

    userhead.h

Abstract:

    Handle of PACKET class definition

Author:

    Uri Habusha (urih) 1-Feb-96

--*/

#ifndef __PHUSER_H
#define __PHUSER_H

/*+++

    User header fields. (following base header)

+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Source QM      | Identifier of the packet originating QM. (GUID)       | 16 bytes |
+----------------+-------------------------------------------------------+----------+
| Destination QM | Identifier of the destination QM. (GUID)              | 16 bytes |
+----------------+-------------------------------------------------------+----------+
|QM Time-to-Live | The packet time to live until dequeued by             |          |
|   Delta        | application (in seconds, relative to TTQ)             | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Sent Time      | Abs time (in seconds) when packet was sent by user.   | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Message ID     | The message number. unique per source QM.             | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Flags          | A bit map of some of the packet parameters:           | 4 bytes  |
|                |                                                       |          |
|                |                                                       |          |
|                |                                                       |          |
|                |  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1                      |          |
|                |  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6                      |          |
|                | +-----+-+-+-+-+-+-+-+-+-+-+-----+                     |          |
|                | |0 0 0|S|E|E|S|M|M|C|P|X|S|Resp |                     |          |
|                | +-----+-+-+-+-+-+-+-+-+-+-+-----+                     |          |
|                |                                                       |          |
|                |  1 1 1 1 1 1                                          |          |
|                |  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0                      |          |
|                | +-----+-----+---+-+---+---------+                     |          |
|                | |Admin|Dest |Aud|R|Dlv|  Hop    |                     |          |
|                | +-----+-----+---+-+---+---------+                     |          |
|                |                                                       |          |
|                | Bits                                                  |          |
|                | 0:4      Hop count. Valid values 0 to 15.             |          |
|                |                                                       |          |
|                | 5:6      Delivery mode:                               |          |
|                |              0 - Guaranteed                           |          |
|                |              1 - Recoverable                          |          |
|                |              2 - On-Line                              |          |
|                |              3 - Reserved.                            |          |
|                |                                                       |          |
|                | 7        Routing mode                                 |          |
|                |              0 - Reserved                             |          |
|                |                                                       |          |
|                | 8        Audit dead letter file                       |          |
|                | 9        Audit journal file                           |          |
|                |                                                       |          |
|                | 10:12    Destination queue type                       |          |
|                |              0 - Illigal value                        |          |
|                |              1 - Illigal value                        |          |
|                |              2 - Illigal value                        |          |
|                |              3 - Illigal value                        |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Illigal value                        |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Illigal value                        |          |
|                |                                                       |          |
|                | 13:15    Admin Queue type                             |          |
|                |              0 - None                      ( 0 bytes) |          |
|                |              1 - Same as Dest..Q           ( 0 bytes) |          |
|                |              2 - Illigal value                        |          |
|                |              3 - Private at Src...QM       ( 4 bytes) |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Illigal value                        |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Private Queue             (20 bytes) |          |
|                |                                                       |          |
|                | 16:18    Response queue type                          |          |
|                |              0 - None                      ( 0 bytes) |          |
|                |              1 - Same as Dest..Q           ( 0 bytes) |          |
|                |              2 - Same as Admin.Q           ( 0 bytes) |          |
|                |              3 - Private at Src...QM       ( 4 bytes) |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Private at Admin.QM       ( 4 bytes) |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Private Queue             (20 bytes) |          |
|                |                                                       |          |
|                | 19       Security section included                    |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 20       Xact section included                        |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 21       Properties section included                  |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 22       Connector Type included                      |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 23       MQF sections included                        |          |
|                |              0 - None of the MQF sections included    |          |
|                |              1 - All of the MQF sections included     |          |
|                |                                                       |          |
|                | 24       Multicast destination                        |          |
|                |              0 - Destination is not multicast         |          |
|                |              1 - Destination is multicast address     |          |
|                |                                                       |          |
|                | 25       SRMP sections included                       |          |
|                |              0 - None of the SRMP sections included   |          |
|                |              1 - All of the SRMP sections included    |          |
|                |                                                       |          |
|                | 26       EOD section included                         |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 27       EOD-ACK section included                     |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 28       SOAP sections included                       |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          | 
|                |                                                       |          |
|		 | 29       SenderStream sections included                      |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 30:31    Reserved. MUST be set to zero.               |          |
+----------------+-------------------------------------------------------+----------+
| Destination Q  | Destination Queue Description                         |4-16 bytes|
+----------------+-------------------------------------------------------+----------+
| Admin Queue    | Admin Queue Description                               |0-20 bytes|
+----------------+-------------------------------------------------------+----------+
| Response Queue | Response Queue Description                            |0-20 bytes|
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
// struct CUserHeader
//

struct CUserHeader {
private:

    //
    // Queue type: 3 bits (values 0-7 only)
    //
    enum QType {
        qtNone      = 0,    //  0 - None                    ( 0 bytes)
        qtAdminQ    = 1,    //  1 - Same as Admin.Q         ( 0 bytes)
        qtSourceQM  = 2,    //  2 - Private at Src...QM     ( 4 bytes)
        qtDestQM    = 3,    //  3 - Private at Dest..QM     ( 4 bytes)
        qtAdminQM   = 4,    //  4 - Private at Admin.QM     ( 4 bytes)
        qtGUID      = 5,    //  5 - Public  Queue           (16 bytes)
        qtPrivate   = 6,    //  6 - Private Queue           (20 bytes)
        qtDirect    = 7     //  7 - Direct  Queue           (var size)
     };

public:

    inline CUserHeader(
            const GUID* pSourceQM,
            const GUID* pDestinationQM,
            const QUEUE_FORMAT* pDestinationQueue,
            const QUEUE_FORMAT* pAdminQueue,
            const QUEUE_FORMAT* pResponseQueue,
            ULONG ulMessageID
           );

    static ULONG CalcSectionSize(
            const GUID* pSourceQM,
            const GUID* pDestinationQM,
            const GUID* pgConnectorType,
            const QUEUE_FORMAT* pDestinationQueue,
            const QUEUE_FORMAT* pAdminQueue,
            const QUEUE_FORMAT* pResponseQueue
            );

    inline PCHAR GetNextSection(PUCHAR PacketEnd = 0) const;

    inline void  SetSourceQM(const GUID* pGUID);
    inline const GUID* GetSourceQM(void) const;

    inline void  SetAddressSourceQM(const TA_ADDRESS *pa);
    inline const TA_ADDRESS *GetAddressSourceQM(void) const;

    inline void  SetDestQM(const GUID* pGUID);
    inline const GUID* GetDestQM(void) const;

    inline BOOL GetDestinationQueue(QUEUE_FORMAT*) const;
    inline BOOL GetAdminQueue(QUEUE_FORMAT*) const;
    inline BOOL GetResponseQueue(QUEUE_FORMAT*) const;

    inline void  SetTimeToLiveDelta(ULONG ulTimeout);
    inline ULONG GetTimeToLiveDelta(void) const;

    inline void  SetSentTime(ULONG ulSentTime);
    inline ULONG GetSentTime(void) const;

    inline void  SetMessageID(const OBJECTID* MessageID);
    inline void  GetMessageID(OBJECTID * pMessageId) const;

    inline void  IncHopCount(void);
    inline UCHAR GetHopCount(void) const;

    inline void  SetDelivery(UCHAR bDelivery);
    inline UCHAR GetDelivery(void) const;

    inline void  SetAuditing(UCHAR bAuditing);
    inline UCHAR GetAuditing(void) const;

    inline void IncludeSecurity(BOOL);
    inline BOOL SecurityIsIncluded(void) const;

    inline void IncludeXact(BOOL);
	
    inline BOOL IsOrdered(void) const;

    inline void IncludeProperty(BOOL);
    inline BOOL PropertyIsIncluded(void) const;

    inline VOID IncludeMqf(bool);
    inline bool MqfIsIncluded(VOID) const;

    inline VOID IncludeSrmp(bool);
    inline bool SrmpIsIncluded(VOID) const;

    inline VOID IncludeEod(bool);
    inline bool EodIsIncluded(VOID) const;

    inline VOID IncludeEodAck(bool);
    inline bool EodAckIsIncluded(VOID) const;

    inline VOID IncludeSoap(bool);
    inline bool SoapIsIncluded(VOID) const;

	inline void IncludeSenderStream(BOOL);
	inline bool SenderStreamIsIncluded()const;

    inline void SetConnectorType(const GUID*);
    inline BOOL ConnectorTypeIsIncluded(void) const;
    inline const GUID* GetConnectorType(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:

    static int QueueSize(bool, ULONG, const UCHAR*, PUCHAR PacketEnd = NULL);
    inline BOOL GetQueue(const UCHAR*, bool, ULONG, QUEUE_FORMAT*) const;
    inline PUCHAR SetDirectQueue(PUCHAR, const WCHAR*);

private:

//
// BEGIN Network Monitor tag
//
    GUID    m_gSourceQM;
    union {
        GUID        m_gDestQM;
        TA_ADDRESS  m_taSourceQM;
    };
    ULONG   m_ulTimeToLiveDelta;
    ULONG   m_ulSentTime;
    ULONG   m_ulMessageID;
    union {
        ULONG   m_ulFlags;
        struct {
            ULONG m_bfHopCount  : 5;
            ULONG m_bfDelivery  : 2;
            ULONG m_bfRouting   : 1;
            ULONG m_bfAuditing  : 2;
            ULONG m_bfDQT       : 3;
            ULONG m_bfAQT       : 3;
            ULONG m_bfRQT       : 3;
            ULONG m_bfSecurity  : 1;
            ULONG m_bfXact      : 1;
			ULONG m_bfProperties: 1;
            ULONG m_bfConnectorType : 1;
            ULONG m_bfMqf       : 1;
            ULONG m_bfPgm       : 1;
            ULONG m_bfSrmp      : 1;
            ULONG m_bfEod       : 1;
            ULONG m_bfEodAck    : 1;
            ULONG m_bfSoap      : 1;
			ULONG m_bfSenderStream : 1;
        };
    }; 

    UCHAR m_abQueues[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
CUserHeader::CUserHeader(
    const GUID* pSourceQM,
    const GUID* pDestinationQM,
    const QUEUE_FORMAT* pDestinationQueue,
    const QUEUE_FORMAT* pAdminQueue,
    const QUEUE_FORMAT* pResponseQueue,
    ULONG ulMessageID
    ) :
    m_gSourceQM(*pSourceQM),
    m_gDestQM(*pDestinationQM),
    m_ulTimeToLiveDelta(INFINITE),
    m_ulSentTime(0),
    m_ulMessageID(ulMessageID),
    m_ulFlags(0)
{
    ASSERT(pSourceQM);
    ASSERT(pDestinationQM);
    ASSERT(pDestinationQueue);

    //
    //  Set default flags
    //
    m_bfDelivery = DEFAULT_M_DELIVERY;
    m_bfRouting  = 0;                   //reserved
    m_bfAuditing = DEFAULT_M_JOURNAL;
    m_bfProperties = TRUE;

    //
    //  Set Queue Information.
    //  Queues that are the same should *point* to same QUEUE_FORMAT
    //
    PUCHAR pQueue = m_abQueues;
    ASSERT(ISALIGN4_PTR(pQueue));


    //
    //  Destination Queue
    //
    switch (pDestinationQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            //  Destination Queue is PUBLIC
            //
            m_bfDQT = qtGUID;
            *(GUID*)pQueue = pDestinationQueue->PublicID();
            pQueue += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            //
            //  Destination Queue is PRIVATE
            //
            ASSERT(("Mismatch between destination QM ID and the private queue ID", ((pDestinationQueue->PrivateID()).Lineage == *pDestinationQM)));

            m_bfDQT = qtDestQM;
            *(PULONG)pQueue = pDestinationQueue->PrivateID().Uniquifier;
            pQueue += sizeof(ULONG);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Destination queue is direct
            //
            m_bfDQT = qtDirect;
            pQueue = SetDirectQueue(pQueue, pDestinationQueue->DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Destination queue is multicast
            //
            m_bfDQT = qtNone;
            m_bfPgm = 1;
            const MULTICAST_ID& id = pDestinationQueue->MulticastID();
            *(PULONG)pQueue = id.m_address;
            pQueue += sizeof(ULONG);
            *(PULONG)pQueue = id.m_port;
            pQueue += sizeof(ULONG);
            break;
        }

        default:
            //
            //  Unexpected type, assert with no Warning level 4.
            //
            ASSERT(pDestinationQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    }

    ASSERT(ISALIGN4_PTR(pQueue));

    //
    //  Admin Queue
    //

    if(pAdminQueue != 0)
    {
        switch (pAdminQueue->GetType())
        {
            case  QUEUE_FORMAT_TYPE_PUBLIC:
                //
                //  Admin Queue is PUBLIC
                //
                m_bfAQT = qtGUID;
                *(GUID*)pQueue = pAdminQueue->PublicID();
                pQueue += sizeof(GUID);
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                if(pAdminQueue->PrivateID().Lineage == *pSourceQM)
                {
                    //
                    //  Private Queue in source QM
                    //
                    m_bfAQT = qtSourceQM;
                    *(PULONG)pQueue = pAdminQueue->PrivateID().Uniquifier;
                    pQueue += sizeof(ULONG);
                }
                else if(
                    (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                    (pAdminQueue->PrivateID().Lineage == *pDestinationQM))
                {
                    //
                    //  Private Queue in Destination QM
                    //
                    m_bfAQT = qtDestQM;
                    *(PULONG)pQueue = pAdminQueue->PrivateID().Uniquifier;
                    pQueue += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Private Queue in some other Machine
                    //
                    m_bfAQT = qtPrivate;
                    *(OBJECTID*)pQueue = pAdminQueue->PrivateID();
                    pQueue += sizeof(OBJECTID);
                }
                break;

            case QUEUE_FORMAT_TYPE_DIRECT:
                //
                // Destination queue is direct
                //
                m_bfAQT = qtDirect;
                pQueue = SetDirectQueue(pQueue, pAdminQueue->DirectID());
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
            case QUEUE_FORMAT_TYPE_DL:
            default:
                //
                //  Unexpected type, assert with no Warning level 4.
                //
                ASSERT(pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
        }
    }

    ASSERT(ISALIGN4_PTR(pQueue));

    //
    //  Response Queue
    //

    if(pResponseQueue != 0)
    {
        if(pResponseQueue == pAdminQueue)
        {
            //
            //  Same as admin queue (private or guid)
            //
            m_bfRQT = qtAdminQ;
        }
        else
        {
            switch(pResponseQueue->GetType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    //
                    //  GUID Queue that is not the same as admin queue.
                    //
                    m_bfRQT = qtGUID;
                    *(GUID*)pQueue = pResponseQueue->PublicID();
                    pQueue += sizeof(GUID);
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    if(pResponseQueue->PrivateID().Lineage == *pSourceQM)
                    {
                        //
                        //  Private Queue in source QM
                        //
                        m_bfRQT = qtSourceQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else if(
                        (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                        (pResponseQueue->PrivateID().Lineage == *pDestinationQM))
                    {
                        //
                        //  Private Queue in Destination QM
                        //
                        m_bfRQT = qtDestQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else if((pAdminQueue !=0) &&
                            (pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) &&
                            (pResponseQueue->PrivateID().Lineage == pAdminQueue->PrivateID().Lineage))
                    {
                        //
                        //  Private Queue in Admin machine QM
                        //
                        m_bfRQT = qtAdminQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else
                    {
                        //
                        //  Private Queue in some other Machine
                        //
                        m_bfRQT = qtPrivate;
                        *(OBJECTID*)pQueue = pResponseQueue->PrivateID();
                        pQueue += sizeof(OBJECTID);
                    }
                    break;

                case QUEUE_FORMAT_TYPE_DIRECT:
                    {
                        //
                        // Destination queue is direct
                        //
                        m_bfRQT = qtDirect;
                        pQueue = SetDirectQueue(pQueue, pResponseQueue->DirectID());
                        break;
                    }

                case QUEUE_FORMAT_TYPE_MULTICAST:
                case QUEUE_FORMAT_TYPE_DL:
                default:
                    //
                    //  Unexpected type, assert with no Warning level 4.
                    //
                    ASSERT(pResponseQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
            }
        }
    }
    
    ASSERT(ISALIGN4_PTR(pQueue));
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
ULONG
CUserHeader::CalcSectionSize(
    const GUID* pSourceQM,
    const GUID* pDestinationQM,
    const GUID* pgConnectorType,
    const QUEUE_FORMAT* pDestinationQueue,
    const QUEUE_FORMAT* pAdminQueue,
    const QUEUE_FORMAT* pResponseQueue
    )
{

    ULONG ulSize = sizeof(CUserHeader);

    //
    //  Destination Queue
    //
    switch(pDestinationQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            ulSize += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            //
            //  Destination Queue is private
            //
            ulSize += sizeof(ULONG);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Destination Queue is Direct
            //
            ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                       (wcslen(pDestinationQueue->DirectID()) + 1) * sizeof(WCHAR));
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            //
            // Destination Queue is Multicast
            //
            ulSize += ALIGNUP4_ULONG(sizeof(ULONG) + sizeof(ULONG));
            break;

        case QUEUE_FORMAT_TYPE_DL:
            ASSERT(("DL type is not allowed", 0));
            break;
    }

    //
    //  Admin Queue
    //

    if(pAdminQueue != 0)
    {
        switch(pAdminQueue->GetType())
        {
            case QUEUE_FORMAT_TYPE_PUBLIC:
                //
                //  Admin Queue is PUBLIC
                //
                ulSize += sizeof(GUID);
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                if(pAdminQueue->PrivateID().Lineage == *pSourceQM)
                {
                    //
                    //  Private Queue in source QM
                    //
                    ulSize += sizeof(ULONG);
                }
                else if(
                    (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                    (pAdminQueue->PrivateID().Lineage == *pDestinationQM))
                {
                    //
                    //  Private Queue in Destination QM
                    //
                    ulSize += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Private Queue in some other Machine
                    //
                    ulSize += sizeof(OBJECTID);
                }
                break;

            case QUEUE_FORMAT_TYPE_DIRECT:
                //
                // Destination Queue is Direct
                //
                ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                           (wcslen(pAdminQueue->DirectID()) + 1) * sizeof(WCHAR));
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
            case QUEUE_FORMAT_TYPE_DL:
            default:
                ASSERT(("unexpected type", 0));
                break;
        }
    }

    //
    //  Response Queue
    //

    if(pResponseQueue != 0)
    {
        if(pResponseQueue == pAdminQueue)
        {
            //
            //  Same as admin queue (private or guid)
            //
        }
        else
        {
            switch(pResponseQueue->GetType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    //
                    //  GUID Queue that is not the same as admin queue.
                    //
                    ulSize += sizeof(GUID);
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    if (pResponseQueue->PrivateID().Lineage == *pSourceQM)
                    {
                        //
                        //  Private Queue in source QM
                        //
                        ulSize += sizeof(ULONG);
                    }
                    else if(
                        (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                        (pResponseQueue->PrivateID().Lineage == *pDestinationQM))
                    {
                        //
                        //  Private Queue in Destination QM
                        //

                        ulSize += sizeof(ULONG);
                    }
                    else if((pAdminQueue != 0) &&
                            (pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) &&
                            (pResponseQueue->PrivateID().Lineage == pAdminQueue->PrivateID().Lineage))
                    {
                        //
                        //  Private Queue in Admin machine QM
                        //
                        ulSize += sizeof(ULONG);
                    }
                    else
                    {
                        //
                        //  Private Queue in some other Machine
                        //
                        ulSize += sizeof(GUID) + sizeof(ULONG);
                    }
                    break;

                case QUEUE_FORMAT_TYPE_DIRECT:
                    //
                    // Destination Queue is Direct
                    //
                    ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                               (wcslen(pResponseQueue->DirectID()) + 1) * sizeof(WCHAR));
                    break;

                case QUEUE_FORMAT_TYPE_MULTICAST:
                case QUEUE_FORMAT_TYPE_DL:
                default:
                    ASSERT(("unexpected type", 0));
            }
        }
    }

    if (pgConnectorType)
    {
        ulSize += sizeof(GUID);
    }

    return ALIGNUP4_ULONG(ulSize);
}


/*======================================================================

 Function:

 Description:

 =======================================================================*/
 inline PCHAR CUserHeader::GetNextSection(PUCHAR PacketEnd) const
 {
    ULONG_PTR size = 0;
    size += QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0],PacketEnd);
    size += QueueSize(false,   m_bfAQT, &m_abQueues[size],PacketEnd);
    size += QueueSize(false,   m_bfRQT, &m_abQueues[size],PacketEnd);
    size += (int)(m_bfConnectorType ? sizeof(GUID) : 0);
    size += sizeof(*this);

    return (PCHAR)this + ALIGNUP4_ULONG(size);
 }

/*======================================================================

 Function:     CUserHeader::SetSrcQMGuid

 Description:  Set The source QM guid

 =======================================================================*/
inline void CUserHeader::SetSourceQM(const GUID* pGUID)
{
    m_gSourceQM = *pGUID;
}

/*======================================================================

 Function:     CUserHeader::GetSourceQM

 Description:  returns the source QM guid

 =======================================================================*/
inline const GUID* CUserHeader::GetSourceQM(void) const
{
    return &m_gSourceQM;
}

/*======================================================================

 Function:     CUserHeader::GetAddressSourceQM

 Description:  returns the source QM guid

 =======================================================================*/
inline const TA_ADDRESS *CUserHeader::GetAddressSourceQM(void) const
{
    return &m_taSourceQM;
}

/*======================================================================

 Function:     CUserHeader::SetAddressSourceQM

 Description:  Set The source QM address

 =======================================================================*/
inline void CUserHeader::SetAddressSourceQM(const TA_ADDRESS *pa)
{
    ULONG ul = TA_ADDRESS_SIZE + pa->AddressLength;

    memcpy((PVOID)&m_taSourceQM, 
           (PVOID)pa, 
           (ul < sizeof(GUID) ? ul : sizeof(GUID)));
}

/*======================================================================

 Function:    CUserHeader::SetDstQMGuid

 Description:

 =======================================================================*/
inline void CUserHeader::SetDestQM(const GUID* pGUID)
{
    m_gDestQM = *pGUID;
}

/*======================================================================

 Function:    CUserHeader::GetDstQMGuid

 Description:

 =======================================================================*/
inline const GUID* CUserHeader::GetDestQM(void) const
{
    return &m_gDestQM;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetDestinationQueue(QUEUE_FORMAT* pqf) const
{
    return GetQueue(&m_abQueues[0], m_bfPgm, m_bfDQT, pqf);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetAdminQueue(QUEUE_FORMAT* pqf) const
{
    //
    //  Prevent infinit recursion
    //
    ASSERT((m_bfAQT != qtAdminQ) && (m_bfAQT != qtAdminQM));

    int qsize = QueueSize(m_bfPgm, m_bfDQT, m_abQueues);
    return GetQueue(&m_abQueues[qsize], false, m_bfAQT, pqf);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetResponseQueue(QUEUE_FORMAT* pqf) const
{
    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    return GetQueue(&m_abQueues[qsize], false, m_bfRQT, pqf);
}

/*======================================================================

 Function:     CUserHeader::SetTimeToLiveDelta

 Description:  Set The Message Time-out to live field

 =======================================================================*/
inline void CUserHeader::SetTimeToLiveDelta(ULONG ulTimeout)
{
    m_ulTimeToLiveDelta = ulTimeout;
}

/*======================================================================

 Function:     CUserHeader::GetTimeToLiveDelta

 Description:  Returns the message Time-Out to Live

 =======================================================================*/
inline ULONG CUserHeader::GetTimeToLiveDelta(void) const
{
    return m_ulTimeToLiveDelta;
}

/*======================================================================

 Function:     CUserHeader::SetSentTime

 Description:  Set The Message Sent Time field

 =======================================================================*/
inline void CUserHeader::SetSentTime(ULONG ulSentTime)
{
    m_ulSentTime = ulSentTime;
}

/*======================================================================

 Function:     CUserHeader::GetSentTime

 Description:  Returns the message Sent Time

 =======================================================================*/
inline ULONG CUserHeader::GetSentTime(void) const
{
    return m_ulSentTime;
}

/*======================================================================

 Function:     CUserHeader::SetId

 Description:  Set Message ID (Uniq per QM)

 =======================================================================*/
inline void CUserHeader::SetMessageID(const OBJECTID* pMessageID)
{
    ASSERT(pMessageID->Lineage == *GetSourceQM());
    m_ulMessageID = pMessageID->Uniquifier;
}

/*======================================================================

 Function:    CUserHeader::GetId

 Description: Return the Message ID field

 =======================================================================*/
inline void CUserHeader::GetMessageID(OBJECTID* pMessageID) const
{
    pMessageID->Lineage = *GetSourceQM();
    pMessageID->Uniquifier = m_ulMessageID;
}

/*======================================================================

 Function:    CUserHeader::IncHopCount

 Description: Increment the message Hop count

 =======================================================================*/
inline void CUserHeader::IncHopCount(void)
{
    m_bfHopCount++;
}

/*======================================================================

 Function:    CUserHeader::GetHopCount

 Description: returns the message hop count

 =======================================================================*/
inline UCHAR CUserHeader::GetHopCount(void) const
{
    return (UCHAR)m_bfHopCount;
}

/*======================================================================

 Function:    CUserHeader::SetDeliveryMode

 Description: Set Messge Delivery mode

 =======================================================================*/
inline void CUserHeader::SetDelivery(UCHAR bDelivery)
{
    m_bfDelivery = bDelivery;
}

/*======================================================================

 Function:     CUserHeader::GetDeliveryMode

 Description:  return the message delivery mode

 =======================================================================*/
inline UCHAR CUserHeader::GetDelivery(void) const
{
    return (UCHAR)m_bfDelivery;
}

/*======================================================================

 Function:     CUserHeader::SetAuditing

 Description:  Set Auditing mode

 =======================================================================*/
inline void CUserHeader::SetAuditing(UCHAR bAuditing)
{
    m_bfAuditing = bAuditing;
}

/*======================================================================

 Function:      CUserHeader::GetAuditingMode

 Description:   return message auditing mode

 =======================================================================*/
inline UCHAR CUserHeader::GetAuditing(void) const
{
    return (UCHAR)m_bfAuditing;
}

/*======================================================================

 Function:    CUserHeader::

 Description: Set Message Security inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeSecurity(BOOL f)
{
    m_bfSecurity = f;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::SecurityIsIncluded(void) const
{
    return m_bfSecurity;
}


/*======================================================================

 Function:    CUserHeader::SenderStreamIncluded

 Description:

 =======================================================================*/
inline bool CUserHeader::SenderStreamIsIncluded()const
{
	return m_bfSenderStream;
}


/*======================================================================

 Function:    CUserHeader::IncludeSenderStream

 Description: Set Message SenderStream inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeSenderStream(BOOL f)
{
    m_bfSenderStream = f;
}



/*======================================================================

 Function:    CUserHeader::

 Description: Set Message Xaction inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeXact(BOOL f)
{
    m_bfXact= f;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::IsOrdered(void) const
{
    return m_bfXact;
}

/*======================================================================

 Function:    CUserHeader::SetPropertyInc

 Description: Set Message property inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeProperty(BOOL f)
{
    m_bfProperties = f;
}

/*======================================================================

 Function:    CUserHeader::IsPropertyInc

 Description: Returns TRUE if Message property section included, FALSE otherwise

 =======================================================================*/
inline BOOL CUserHeader::PropertyIsIncluded(VOID) const
{
    return m_bfProperties;
}

/*======================================================================

 Function:    CUserHeader::IncludeMqf

 Description: Set MQF sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeMqf(bool include)
{
    m_bfMqf = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::MqfIsIncluded

 Description: Returns true if MQF sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::MqfIsIncluded(VOID) const
{
    return (m_bfMqf != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeSrmp

 Description: Set SRMP sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeSrmp(bool include)
{
    m_bfSrmp = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::SrmpIsIncluded

 Description: Returns true if SRMP sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::SrmpIsIncluded(VOID) const
{
    return (m_bfSrmp != 0);
}



/*======================================================================

 Function:    CUserHeader::IncludeEod

 Description: Set Eod section inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeEod(bool include)
{
    m_bfEod = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::EodIsIncluded

 Description: Returns true if Eod section included, false otherwise

 =======================================================================*/
inline bool CUserHeader::EodIsIncluded(VOID) const
{
    return (m_bfEod != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeEodAck

 Description: Set EodAck section inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeEodAck(bool include)
{
    m_bfEodAck = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::EodAckIsIncluded

 Description: Returns true if EodAck section included, false otherwise

 =======================================================================*/
inline bool CUserHeader::EodAckIsIncluded(VOID) const
{
    return (m_bfEodAck != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeSoap

 Description: Set Soap sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeSoap(bool include)
{
    m_bfSoap = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::SoapIsIncluded

 Description: Returns true if Soap sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::SoapIsIncluded(VOID) const
{
    return (m_bfSoap != 0);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline int CUserHeader::QueueSize(bool fPgm, ULONG qt, const UCHAR* pQueue, PUCHAR PacketEnd)
{
    if (fPgm)
    {
        ASSERT(("if PGM packet then queue type is none", qt == qtNone));
        return (sizeof(ULONG) + sizeof(ULONG));
    }

    if(qt < qtSourceQM)
    {
        return 0;
    }

    if(qt < qtGUID)
    {
    	if (PacketEnd != NULL)
    	{
			ULONG Uniquifier;
			GetSafeDataAndAdvancePointer<ULONG>(pQueue, PacketEnd, &Uniquifier);
			if (0 == Uniquifier)
			{
		        ReportAndThrow("User section is not valid: Uniquifier can not be 0");
			}		
    	}
        return sizeof(ULONG);
    }

    if(qt == qtGUID)
    {
        return sizeof(GUID);
    }

    if (qt == qtPrivate)
    {
    	if (PacketEnd != NULL)
    	{
			pQueue += sizeof(GUID);
			ULONG Uniquifier;
			GetSafeDataAndAdvancePointer<ULONG>(pQueue, PacketEnd, &Uniquifier);
			if (0 == Uniquifier)
			{
		        ReportAndThrow("User section is not valid: private queue Uniquifier can not be 0");
			}		
    	}
        return (sizeof(GUID) + sizeof(ULONG));
    }

    if (qt == qtDirect)
    {
    	USHORT length;
    	GetSafeDataAndAdvancePointer<USHORT>(pQueue, PacketEnd, &length);

    	if (PacketEnd != NULL)
    	{
			WCHAR wch;
	    	GetSafeDataAndAdvancePointer<WCHAR>(&pQueue[length], PacketEnd, &wch);
	    	if (wch != L'\0')
	    	{
		        ReportAndThrow("User section is not valid: Direct queue need to be NULL terminated");
	    	}
    	}
        length += sizeof(USHORT);
        return ALIGNUP4_ULONG(length);
    }

    //
    //  Unexpected type, assert with no Warning level 4.
    //
    ASSERT(qt == qtDirect);

    return 0;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetQueue(const UCHAR* pQueue, bool fPgm, ULONG qt, QUEUE_FORMAT* pqf) const
{
    ASSERT(("If PGM packet then queue type is none", !fPgm || qt == qtNone));

    switch(qt)
    {
        case qtNone:
            if (fPgm)
            {
                MULTICAST_ID id;
                id.m_address = *(ULONG*)pQueue;
                id.m_port    = *(ULONG*)(pQueue + sizeof(ULONG));
                pqf->MulticastID(id);
                return TRUE;
            }

            pqf->UnknownID(0);
            return FALSE;

        case qtAdminQ:
            return GetAdminQueue(pqf);

        case qtSourceQM:
            pqf->PrivateID(*GetSourceQM(), *(PULONG)pQueue);
            return TRUE;

        case qtDestQM:
            pqf->PrivateID(*GetDestQM(), *(PULONG)pQueue);
            return TRUE;

        case qtAdminQM:
            //
            //  Note that this case implies that Admin queue exists
            //
            GetAdminQueue(pqf);
            pqf->PrivateID(pqf->PrivateID().Lineage, *(PULONG)pQueue);
            return TRUE;

        case qtGUID:
            pqf->PublicID(*(GUID*)pQueue);
            return TRUE;

        case qtPrivate:
            pqf->PrivateID(*(OBJECTID*)pQueue);
            return TRUE;

        case qtDirect:
            pqf->DirectID((WCHAR*)(pQueue + sizeof(USHORT)));
            return TRUE;

        default:
            //
            //  Unexpected type, assert with no Warning level 4.
            //
            ASSERT(qt != qtNone);
    };
    return FALSE;
}


/*======================================================================

 Function:    CUserHeader::SetDirectQueue

 Description: Set direct queue.

 =======================================================================*/
inline PUCHAR CUserHeader::SetDirectQueue(PUCHAR pQueue, const WCHAR* pwcsDirectQueue)
{
    ASSERT(ISALIGN4_PTR(pQueue));

    size_t size = (wcslen(pwcsDirectQueue) + 1) * sizeof(WCHAR);

    *reinterpret_cast<USHORT*>(pQueue) = static_cast<USHORT>(size);
    memcpy(pQueue + sizeof(USHORT), pwcsDirectQueue, size);
    return (pQueue + ALIGNUP4_ULONG(sizeof(USHORT) + size));
}


/*===========================================================

  Function: CUserHeader::SetConnectorType

  Description:

=============================================================*/
inline void CUserHeader::SetConnectorType(const GUID* pgConnectorType)
{
    ASSERT(pgConnectorType);

    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    qsize +=    QueueSize(false,   m_bfRQT, &m_abQueues[qsize]);
    memcpy(&m_abQueues[qsize], pgConnectorType, sizeof(GUID));

    m_bfConnectorType = TRUE;
}

/*===========================================================

  Function: CUserHeader::ConnectorTypeIsIncluded

  Description:

=============================================================*/
inline BOOL CUserHeader::ConnectorTypeIsIncluded(void) const
{
    return m_bfConnectorType;
}

/*===========================================================

  Function: CUserHeader::GetConnectorType

  Description:

=============================================================*/
inline const GUID* CUserHeader::GetConnectorType(void) const
{
    if(!ConnectorTypeIsIncluded())
    {
        return 0;
    }

    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    qsize +=    QueueSize(false,   m_bfRQT, &m_abQueues[qsize]);
    return reinterpret_cast<const GUID*>(&m_abQueues[qsize]);
}


#endif // __PHUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\portapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    portapi.h

Abstract:

    Mapping Win32 API to HRESULT APIs.

Author:

    Erez Haba (erezh) 23-Jan-96

Revision History:

--*/

#ifndef _PORTAPI_H
#define _PORTAPI_H

#define MQpDuplicateHandle DuplicateHandle

// --- implementation -------------------------------------
//
// Mapped Win32 APIs
//

inline
HRESULT
MQpCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDistribution,
    DWORD dwFlagsAndAttributes,
    PHANDLE pHandle
   )
{
    HANDLE hFile = CreateFileW(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    dwFlagsAndAttributes,
                    0
                    );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        //
        //  The create can fail on either, the AC driver has not been
        //  started, or this is not the QM service.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *pHandle = hFile;

    return STATUS_SUCCESS;
}


inline
HRESULT
MQpCloseHandle(
    HANDLE handle
    )
{
    NTSTATUS rc = NtClose(handle);
    return rc;
}


inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPOVERLAPPED lpOverlapped
    )
{
    ASSERT(lpOverlapped != 0);

    //
    //  NOTE: This section was taken out of NT source code.
    //

    lpOverlapped->Internal = STATUS_PENDING;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            lpOverlapped->hEvent,
            0,  // APC routine
            ((DWORD_PTR)lpOverlapped->hEvent & (DWORD_PTR)1) ? 0 : lpOverlapped,
            (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
            dwIoControlCode,
            lpInBuffer,
            nInBufferSize,
            lpOutBuffer,
            nOutBufferSize
            );

    return rc;
}


inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize
    )
{
    static IO_STATUS_BLOCK Iosb;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            0,
            0,             // APC routine
            0,             // APC Context
            &Iosb,
            dwIoControlCode,  // IoControlCode
            lpInBuffer,       // Buffer for data to the FS
            nInBufferSize,
            lpOutBuffer,      // OutputBuffer for data from the FS
            nOutBufferSize    // OutputBuffer Length
            );

    return rc;
}


#endif // _PORTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\privque.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    privque.h

Abstract:

   Definitions for system private queues

Author:

    Doron Juster  (DoronJ)   17-Apr-97  Created

--*/

#ifndef  __PRIVQUE_H_
#define  __PRIVQUE_H_

//
// System Private queue identifiers
//
#define REPLICATION_QUEUE_ID         1
#define ADMINISTRATION_QUEUE_ID      2
#define NOTIFICATION_QUEUE_ID        3
#define ORDERING_QUEUE_ID            4
#define NT5PEC_REPLICATION_QUEUE_ID  5
#define TRIGGERS_QUEUE_ID            6

#define MIN_SYS_PRIVATE_QUEUE_ID   1
#define MAX_SYS_PRIVATE_QUEUE_ID   6

//
// System Private queue name
//
#define ADMINISTRATION_QUEUE_NAME  (TEXT("admin_queue$"))
#define NOTIFICATION_QUEUE_NAME    (TEXT("notify_queue$"))
#define ORDERING_QUEUE_NAME        (TEXT("order_queue$"))
#define TRIGGERS_QUEUE_NAME        (TEXT("triggers_queue$"))

#endif //  __PRIVQUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phxact.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phxact.h

Abstract:

    Handle Transaction Section in Falcon Header

Author:

    Alexdad    26-Nov-96

--*/

#ifndef __PHXACT_H
#define __PHXACT_H

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
//  struct CXactHeader
//

struct CXactHeader {
public:

    inline CXactHeader(const GUID* pgConnectorQM);

    static ULONG CalcSectionSize(PVOID pUow, const GUID* pgConnectorQM);
    inline PCHAR GetNextSection(void) const;

    inline void     SetSeqID(LONGLONG liSeqID);
    inline LONGLONG GetSeqID(void) const;

    inline void    SetSeqN(ULONG ulSeqN);
    inline ULONG   GetSeqN(void) const;

    inline void    SetPrevSeqN(ULONG ulPrevSeqN);
    inline ULONG   GetPrevSeqN(void) const;

    inline void    SetConnectorQM(const GUID* pGUID);
    inline const GUID* GetConnectorQM(void) const;
    inline BOOL    ConnectorQMIncluded(void) const;

    inline void    SetCancelFollowUp(BOOL  fCancelFollowUp);
    inline BOOL    GetCancelFollowUp(void) const;

    inline PUCHAR  GetPrevSeqNBuffer() const;
    inline ULONG   GetPrevSeqNBufferSize() const;
	inline PUCHAR  GetConnectorQMBuffer() const;
	inline ULONG   GetConnectorQMBufferSize() const;

    inline UCHAR   GetFirstInXact(void) const;
    inline void    SetFirstInXact(UCHAR fFirst);

    inline UCHAR   GetLastInXact(void) const;
    inline void    SetLastInXact(UCHAR fLast);

    inline void    SetXactIndex(ULONG ulXactIndex);
    inline ULONG   GetXactIndex(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:
//
// BEGIN Network Monitor tag
//
    union {
        ULONG   m_ulFlags;
        struct {
            ULONG m_bfConnector      : 1;
            ULONG m_bfCancelFollowUp : 1;
            ULONG m_bfFirst          : 1;
            ULONG m_bfLast           : 1;
            ULONG m_bfXactIndex      : 20;
        };
    };
    LONGLONG m_liSeqID;
    ULONG    m_ulSeqN;
    ULONG    m_ulPrevSeqN;
    UCHAR    m_gConnectorQM[0];

//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*=============================================================

 Routine Name:  CXactHeader::

 Description:

===============================================================*/
inline CXactHeader::CXactHeader(const GUID* pgConnectorQM):
    m_ulFlags(0),
    m_liSeqID(0),
    m_ulSeqN(0),
    m_ulPrevSeqN(0)
{
    if (pgConnectorQM)
    {
        m_bfConnector = TRUE;
        memcpy(m_gConnectorQM, pgConnectorQM, sizeof(GUID));
    }
}

/*=============================================================

 Routine Name:  CXactHeader::CalcSectionSize(PVOID pUow)

 Description:

===============================================================*/
inline ULONG CXactHeader::CalcSectionSize(PVOID pUow, const GUID* pgConnectorQM)
{
    ULONG ulSize = (ULONG)(pUow == NULL ? 0 : sizeof(CXactHeader));
    if (pUow && pgConnectorQM)
    {
        ulSize = ulSize + sizeof(GUID);
    }
    return ALIGNUP4_ULONG(ulSize);
}

/*=============================================================

 Routine Name:  CXactHeader::

 Description:

===============================================================*/
inline PCHAR CXactHeader::GetNextSection(void) const
{
    int size = sizeof(*this);

    size += (int)((m_bfConnector) ? sizeof(GUID) : 0);

    return (PCHAR)this + ALIGNUP4_ULONG(size);
}

/*======================================================================

 Function:    CXactHeader::SetSeqID

 Description: Sets the Sequence ID

 =======================================================================*/
inline void CXactHeader::SetSeqID(LONGLONG liSeqID)
{
    m_liSeqID = liSeqID;
}

/*======================================================================

 Function:    CXactHeader::GetSeqID

 Description: Gets the Sequence ID

 =======================================================================*/
inline LONGLONG CXactHeader::GetSeqID(void) const
{
    return m_liSeqID;
}

/*======================================================================

 Function:    CXactHeader::SetSeqN

 Description: Sets the Sequence Number

 =======================================================================*/
inline void CXactHeader::SetSeqN(ULONG ulSeqN)
{
    m_ulSeqN = ulSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetSeqN

 Description: Gets the Sequence Number

 =======================================================================*/
inline ULONG CXactHeader::GetSeqN(void) const
{
    return m_ulSeqN;
}

/*======================================================================

 Function:    CXactHeader::SetPrevSeqN

 Description: Sets the Previous Sequence Number

 =======================================================================*/
inline void CXactHeader::SetPrevSeqN(ULONG ulPrevSeqN)
{
    m_ulPrevSeqN = ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqN

 Description: Gets the Previous Sequence Number

 =======================================================================*/
inline ULONG CXactHeader::GetPrevSeqN(void) const
{
    return m_ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::SetCancelFollowUp

 Description: Sets the flag of Follow-Up cancelation

 =======================================================================*/
inline void CXactHeader::SetCancelFollowUp(BOOL fCancelFollowUp)
{
    m_bfCancelFollowUp = fCancelFollowUp;
}

/*======================================================================

 Function:    CXactHeader::GetCancelFollowUp

 Description: Gets the flag of Follow-Up cancelation

 =======================================================================*/
inline BOOL CXactHeader::GetCancelFollowUp(void) const
{
    return m_bfCancelFollowUp;
}


/*======================================================================

 Function:    CXactHeader::SetFirstInXact

 Description: Sets the flag of First In Transaction

 =======================================================================*/
inline void CXactHeader::SetFirstInXact(UCHAR fFirst)
{
    m_bfFirst= fFirst;
}

/*======================================================================

 Function:    CXactHeader::GetFirstInXact

 Description: Gets the flag of First In Transaction

 =======================================================================*/
inline UCHAR CXactHeader::GetFirstInXact(void) const
{
    return (UCHAR)m_bfFirst;
}

/*======================================================================

 Function:    CXactHeader::SetLastInXact

 Description: Sets the flag of Last In Transaction

 =======================================================================*/
inline void CXactHeader::SetLastInXact(UCHAR fLast)
{
    m_bfLast= fLast;
}


/*======================================================================

 Function:    CXactHeader::GetLastInXact

 Description: Gets the flag of Last In Transaction

 =======================================================================*/
inline UCHAR CXactHeader::GetLastInXact(void) const
{
    return (UCHAR)m_bfLast;
}

/*======================================================================

 Function:    CXactHeader::SetXactIndex

 Description: Sets the Transaction Index

 =======================================================================*/
inline void CXactHeader::SetXactIndex(ULONG ulXactIndex)
{
    m_bfXactIndex = (ulXactIndex & 0x000FFFFF);
}

/*======================================================================

 Function:    CXactHeader::GetXactIndex

 Description: Gets the Transaction Index

 =======================================================================*/
inline ULONG CXactHeader::GetXactIndex(void) const
{
    return m_bfXactIndex;
}


/*======================================================================

 Function:    CXactHeader::SetConnectorQM

 Description:

 =======================================================================*/
inline void CXactHeader::SetConnectorQM(const GUID* pGUID)
{
    m_bfConnector = TRUE;
    memcpy(m_gConnectorQM, pGUID, sizeof(GUID));
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQM

 Description:

 =======================================================================*/
inline const GUID* CXactHeader::GetConnectorQM(void) const
{
    ASSERT(m_bfConnector);
    return (GUID*)m_gConnectorQM;
}

/*======================================================================

 Function:    CXactHeader::ConnectorQMIncluded

 Description:

 =======================================================================*/
inline BOOL CXactHeader::ConnectorQMIncluded(void) const
{
    return m_bfConnector;
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQMBuffer()

 Description:

 =======================================================================*/
inline PUCHAR CXactHeader::GetConnectorQMBuffer() const
{
	return (PUCHAR) m_gConnectorQM;
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQMBufferSize

 Description:

 =======================================================================*/
inline ULONG CXactHeader::GetConnectorQMBufferSize() const
{
	return sizeof GUID;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqNBuffer()

 Description:

 =======================================================================*/
inline PUCHAR CXactHeader::GetPrevSeqNBuffer() const
{
	return (PUCHAR) &m_ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqNBufferSize

 Description:

 =======================================================================*/
inline ULONG CXactHeader::GetPrevSeqNBufferSize() const
{
	return sizeof m_ulPrevSeqN;
}


#endif // __PHXACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\phsoap.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phsoap.h

Abstract:

    Packet sections for SOAP header and SOAP body write-only properties.

Author:

    Shai Kariv  (shaik)  11-Apr-2001

--*/

#ifndef __PH_SOAP_H
#define __PH_SOAP_H


/*+++

    Note: Packet may contain 0 or 2 SOAP sections (SOAP Header and SOAP Body),
          a SOAP section can be empty (with no date).
          Packet may not contain only 1 SOAP section

    SOAP section fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Section ID     | Identification of the section                         | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data Length    | Length of the data in WCHARs.                         | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data WCHARs including NULL terminator.            | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CSoapSection
{
public:

    //
    // Construct the SOAP section
    //
    CSoapSection(WCHAR * pData, ULONG DataLengthInWCHARs, USHORT id);

    //
    // Get size in BYTEs of the SOAP section
    //
    static ULONG CalcSectionSize(ULONG DataLengthInWCHARs);

    //
    // Get pointer to first byte after the SOAP section
    //
    PCHAR  GetNextSection(VOID) const;

	//
	// Get pointer to the data on the SOAP section
	//
    const WCHAR* GetPointerToData(VOID) const;

    //
    // Copy the data from the SOAP section
    //
    VOID   GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const;

    //
    // Get the length of the data in WCHARs from the SOAP section
    //
    ULONG  GetDataLengthInWCHARs(VOID) const;

private:

    //
    // ID number of the SOAP section
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Length in WCHARs of the data
    //
    ULONG  m_DataLength;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CSoapSection


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CSoapSection::CSoapSection(
    WCHAR * pData, 
    ULONG   DataLengthInWCHARs, 
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataLength(DataLengthInWCHARs + 1)
{
    if (DataLengthInWCHARs != 0)
    {
        memcpy(&m_buffer[0], pData, DataLengthInWCHARs * sizeof(WCHAR));
    }

	//
	// Putting unicode null terminator at end of buffer.
	//
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR)]     = '\0';
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR) + 1] = '\0';

} // CSoapSection::CSoapSection


inline 
ULONG
CSoapSection::CalcSectionSize(
    ULONG DataLengthInWCHARs
    )
{
    size_t cbSize = sizeof(CSoapSection) + ((DataLengthInWCHARs + 1) * sizeof(WCHAR));

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CSoapSection::CalcSectionSize


inline PCHAR CSoapSection::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CSoapSection) + (m_DataLength * sizeof(WCHAR));
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CSoapSection::GetNextSection


inline const WCHAR* CSoapSection::GetPointerToData(VOID) const
{
	//
	// A NULL terminated string is stored on the SOAP section so miminum
	// length is 1
	//
    if (m_DataLength <= 1)
    {
        return NULL;
    }

    return reinterpret_cast<const WCHAR*>(&m_buffer[0]);

} // CSoapSection::GetPointerToData


inline VOID CSoapSection::GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const
{
    ULONG length = min(BufferLengthInWCHARs, m_DataLength);

    if (length != 0)
    {
        memcpy(pBuffer, &m_buffer[0], length * sizeof(WCHAR));
        pBuffer[length - 1] = L'\0';
    }
} // CSoapSection::GetData


inline ULONG CSoapSection::GetDataLengthInWCHARs(VOID) const
{
    return m_DataLength;

} // CSoapSection::GetDataLengthInWCHARs


#endif // __PH_SOAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\pnotify.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pnotify.h

Abstract:

    Notification message header definition

Author:


--*/

#ifndef __PNOTIFY_H
#define __PNOTIFY_H

#define DS_NOTIFICATION_MSG_VERSION 1
#define QM_NOTIFICATION_MSG_VERSION 2

//
// struct CNotificationHeader
//

struct CNotificationHeader {
public:

    inline void SetVersion(const unsigned char ucVersion);
    inline const unsigned char GetVersion(void) const;

    inline void SetNoOfNotifications( const unsigned char ucNoOfNotifications);
    inline const unsigned char GetNoOfNotifications( void) const;

    inline unsigned char * GetPtrToData( void) const;

    inline const DWORD GetBasicSize( void) const;


private:

    unsigned char   m_ucVersion;
    unsigned char   m_ucNoOfNotifications;
    unsigned char   m_ucData;
};

/*======================================================================

 Function:     CNotificationHeader::SetVersion

 Description:  Set version number

 =======================================================================*/
inline void CNotificationHeader::SetVersion(const unsigned char ucVersion)
{
    m_ucVersion = ucVersion;
}

/*======================================================================

 Function:     CNotificationHeader::GetVersion

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CNotificationHeader::GetVersion(void) const
{
    return m_ucVersion;
}

/*======================================================================

 Function:     CNotificationHeader::SetNoOfNotifications

 Description:  Set number of notifications

 =======================================================================*/
inline void CNotificationHeader::SetNoOfNotifications( const unsigned char ucNoOfNotifications)
{
    m_ucNoOfNotifications = ucNoOfNotifications;
}
/*======================================================================

 Function:     CNotificationHeader::GetNoOfNotifications

 Description:  returns the number of notifications

 =======================================================================*/
inline const unsigned char CNotificationHeader::GetNoOfNotifications( void) const
{
    return m_ucNoOfNotifications;
}
/*======================================================================

 Function:     CNotificationHeader::GetPtrToData

 Description:  returns pointer to packet data

 =======================================================================*/
inline  unsigned char * CNotificationHeader::GetPtrToData( void) const
{
    return (unsigned char *)&m_ucData;
}
/*======================================================================

 Function:     CNotificationHeader::GetBasicSize

 Description:  returns pointer to packet data

 =======================================================================*/
inline const DWORD CNotificationHeader::GetBasicSize( void) const
{
    return( sizeof(*this) - sizeof(m_ucData));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rpccli.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name: rpccli.h

Abstract: rpc related code.


Author:

    Ilan Herbst    (ilanh)   9-July-2000 

--*/

#ifndef _RPCCLI_H_
#define _RPCCLI_H_

#include "qformat.h"

HRESULT 
GetRpcClientHandle(
	handle_t *phBind
	);

HRESULT 
QMRpcSendMsg(
    IN handle_t hBind,
    IN QUEUE_FORMAT* pqfDestination,
    IN DWORD dwSize,
    IN const unsigned char *pBuffer,
    IN DWORD dwTimeout,
    IN unsigned char bAckMode,
    IN unsigned char bPriority,
    IN LPWSTR lpwszAdminResp
	);

//
// from replserv\mq1repl\replrpc.h
// 
#define  QMREPL_PROTOCOL   (TEXT("ncalrpc"))
#define  QMREPL_ENDPOINT   (TEXT("QmReplService"))
#define  QMREPL_OPTIONS    (TEXT("Security=Impersonation Dynamic True"))

#endif //_RPCCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\qformat.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    qformat.h

Abstract:
    Falcon Internal Queue format represintation for FormatQueue string.

Author:
    Erez Haba (erezh) 14-Mar-96

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef __QFORMAT_H
#define __QFORMAT_H

#ifndef _QUEUE_FORMAT_DEFINED
#define _QUEUE_FORMAT_DEFINED

#ifdef __midl
cpp_quote("#ifndef __cplusplus")
cpp_quote("#ifndef _QUEUE_FORMAT_DEFINED")
cpp_quote("#define _QUEUE_FORMAT_DEFINED")
#endif // __midl

enum QUEUE_FORMAT_TYPE {
    QUEUE_FORMAT_TYPE_UNKNOWN = 0,
    QUEUE_FORMAT_TYPE_PUBLIC,
    QUEUE_FORMAT_TYPE_PRIVATE,
    QUEUE_FORMAT_TYPE_DIRECT,
    QUEUE_FORMAT_TYPE_MACHINE,
    QUEUE_FORMAT_TYPE_CONNECTOR,
    QUEUE_FORMAT_TYPE_DL,
    QUEUE_FORMAT_TYPE_MULTICAST
};

//
// Note - four bits value. No more than 16 Suffixes are allowed
//
enum QUEUE_SUFFIX_TYPE {
    QUEUE_SUFFIX_TYPE_NONE = 0,
    QUEUE_SUFFIX_TYPE_JOURNAL,
    QUEUE_SUFFIX_TYPE_DEADLETTER,
    QUEUE_SUFFIX_TYPE_DEADXACT,
    QUEUE_SUFFIX_TYPE_XACTONLY,
};

#define QUEUE_FORMAT_SUFFIX_MASK 0x0F
//
// Queue type flags - bit flags in the high order four bits of QUEUE_FORMAT::m_SuffixAndFlags
// No more than four flags are allowed. Last four bits must be 0 (YoelA - 5/30/99).
// 
#define QUEUE_FORMAT_FLAG_SYSTEM 0x80


//---------------------------------------------------------
//
//  struct MULTICAST_ID
//
//  This struct is RPC'able. Use LPWSTR and not WCHAR* .
//
//---------------------------------------------------------
typedef struct _MULTICAST_ID {
    ULONG m_address;
    ULONG m_port;
} MULTICAST_ID;


//---------------------------------------------------------
//
//  struct DL_ID
//
//  This struct is RPC'able. Use LPWSTR and not WCHAR* .
//
//---------------------------------------------------------
#ifndef _WIN64
#pragma pack(push, 4)
#endif

typedef struct _DL_ID {
    GUID   m_DlGuid;
    LPWSTR m_pwzDomain;
} DL_ID;

#ifndef __midl
const size_t xSizeOfDlId32 = 20;
#ifndef _WIN64
C_ASSERT(sizeof(DL_ID) == xSizeOfDlId32);
#endif
#endif

#ifndef _WIN64
#pragma pack(pop)
#endif


//---------------------------------------------------------
//
//  struct DL_ID_32
//
//  This struct is not RPC'able. It is OK to use WCHAR* .
//
//---------------------------------------------------------
#ifdef _WIN64
#ifndef __midl

#pragma pack(push, 4)

typedef struct _DL_ID_32 {
    GUID               m_DlGuid;
    WCHAR * POINTER_32 m_pwzDomain;
} DL_ID_32;

C_ASSERT(sizeof(DL_ID_32) == xSizeOfDlId32);

#pragma pack(pop)

#endif // __midl
#endif // _WIN64


//---------------------------------------------------------
//
//  struct QUEUE_FORMAT
//
//  NOTE:   This structure should NOT contain virtual
//          functions. They are not RPC-able.
//
//---------------------------------------------------------

#ifdef _WIN64
struct QUEUE_FORMAT_32; //forward def
#endif //_WIN64

struct QUEUE_FORMAT {

#ifndef __midl
public:

    bool Legal() const;
    bool IsValid() const;

    QUEUE_FORMAT_TYPE GetType() const;
    QUEUE_SUFFIX_TYPE Suffix() const;
    void Suffix(QUEUE_SUFFIX_TYPE);

    QUEUE_FORMAT();
    void UnknownID(PVOID);

    QUEUE_FORMAT(const GUID&);
    void PublicID(const GUID&);
    const GUID& PublicID() const;

    QUEUE_FORMAT(const DL_ID&);
    void DlID(const DL_ID&);
    const DL_ID& DlID() const;

    QUEUE_FORMAT(const OBJECTID&);
    void PrivateID(const OBJECTID&);
    QUEUE_FORMAT(const GUID&, ULONG);
    void PrivateID(const GUID&, ULONG);
    const OBJECTID& PrivateID() const;

    QUEUE_FORMAT(LPWSTR);
    void DirectID(LPWSTR);
    void DirectID(LPWSTR, UCHAR);
    LPCWSTR DirectID() const;

    QUEUE_FORMAT(PVOID, const GUID&);
    void MachineID(const GUID&);
    const GUID& MachineID() const;

    void  ConnectorID(const GUID&);
    const GUID& ConnectorID() const;

    QUEUE_FORMAT(const MULTICAST_ID&);
    void MulticastID(const MULTICAST_ID&);
    const MULTICAST_ID& MulticastID() const;

    void DisposeString();
    bool IsSystemQueue() const;

#ifdef _WIN64
    //
    // initialize from a QUEUE_FORMAT_32 (32 bit ptrs)
    //
    void InitFromQueueFormat32(IN const struct QUEUE_FORMAT_32 *);
#endif //_WIN64    

private:

#endif // !__midl

    UCHAR m_qft;

    //
    //  m_SuffixAndFlags - Most significant 4 bits are flags, least significant 4 bits are suffix.
    //  (Used to be m_qst in MSMQ 1.0 - YoelA, 5/31/99).
    //
    UCHAR m_SuffixAndFlags;

    //
    // Note - do not use m_reserved if you need MSMQ 1.0 compatibility over RPC.
    // This is because MSMQ 1.0 does not put zero in m_reserved, so it can have any value.
    // (YoelA - 5/31/99)
    //
    USHORT m_reserved; 

#ifdef __midl
    [switch_is(m_qft)]
#endif // __midl

    union {
#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_UNKNOWN)]
#endif
            ;
#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_PUBLIC)]
#endif // __midl
        GUID m_gPublicID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_PRIVATE)]
#endif // __midl

        OBJECTID m_oPrivateID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_DIRECT)]
#endif // __midl

        LPWSTR m_pDirectID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_MACHINE)]
#endif // __midl

        GUID m_gMachineID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_CONNECTOR)]
#endif // __midl

        GUID m_gConnectorID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_DL)]
#endif // __midl

        //
        // We must use a struct to pack multiple fields since we're
        // inside a union.
        //
        DL_ID m_DlID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_MULTICAST)]
#endif // __midl

        MULTICAST_ID m_MulticastID;
    };
};

#ifndef __midl
const size_t xSizeOfQueueFormat32 = 24;
#ifndef _WIN64
C_ASSERT(sizeof(QUEUE_FORMAT) == xSizeOfQueueFormat32);
#endif
#endif

#ifdef _WIN64
#ifndef __midl
//---------------------------------------------------------
//
//  struct QUEUE_FORMAT_32
//  
//  Contains the data of queue format as it is in 32 bit apps
//  since it is part of AC driver which can accept an ioctl
//  from 32 bit rt that uses this struct
//
//---------------------------------------------------------
#pragma pack(push, 4)
struct QUEUE_FORMAT_32 {
    UCHAR m_qft;
    UCHAR m_SuffixAndFlags;
    USHORT m_reserved; 
    union {
        GUID m_gPublicID;
        OBJECTID m_oPrivateID;
        WCHAR * POINTER_32 m_pDirectID;
        GUID m_gMachineID;
        GUID m_gConnectorID;
        DL_ID_32 m_DlID32;
        MULTICAST_ID m_MulticastID;
    };
};

C_ASSERT(sizeof(QUEUE_FORMAT_32) == xSizeOfQueueFormat32);

#pragma pack(pop)
#endif //!__midl
#endif //_WIN64

#ifdef __midl
cpp_quote("#endif // _QUEUE_FORMAT_DEFINED")
cpp_quote("#endif // __cplusplus")
#endif // __midl

#endif // _QUEUE_FORMAT_DEFINED


#ifdef __cplusplus

inline bool QUEUE_FORMAT::Legal() const
{
    switch(Suffix())
    {
        case QUEUE_SUFFIX_TYPE_NONE:
            return (!IsSystemQueue());

        case QUEUE_SUFFIX_TYPE_JOURNAL:
            return ((m_qft != QUEUE_FORMAT_TYPE_CONNECTOR)
                    &&
                    (m_qft != QUEUE_FORMAT_TYPE_DL)
                    &&
                    (m_qft != QUEUE_FORMAT_TYPE_MULTICAST));

        case QUEUE_SUFFIX_TYPE_DEADLETTER:
        case QUEUE_SUFFIX_TYPE_DEADXACT:
            return (IsSystemQueue());

        case QUEUE_SUFFIX_TYPE_XACTONLY:
            return (m_qft == QUEUE_FORMAT_TYPE_CONNECTOR);
    }
    return false;
}


inline bool QUEUE_FORMAT::IsValid() const
{
    if(m_qft > QUEUE_FORMAT_TYPE_MULTICAST)
        return false;

    if(Suffix() > QUEUE_SUFFIX_TYPE_XACTONLY)
        return false;

    if(m_qft == QUEUE_FORMAT_TYPE_UNKNOWN)
        return false;

    if((m_qft == QUEUE_FORMAT_TYPE_DIRECT) && (DirectID() == NULL))
        return false;

    return Legal();
}


inline QUEUE_FORMAT_TYPE QUEUE_FORMAT::GetType() const
{
    return ((QUEUE_FORMAT_TYPE)m_qft);
}

inline QUEUE_SUFFIX_TYPE QUEUE_FORMAT::Suffix() const
{
    return ((QUEUE_SUFFIX_TYPE)(m_SuffixAndFlags & QUEUE_FORMAT_SUFFIX_MASK));
}

inline void QUEUE_FORMAT::Suffix(QUEUE_SUFFIX_TYPE qst)
{
    m_SuffixAndFlags &= ~QUEUE_FORMAT_SUFFIX_MASK;
    m_SuffixAndFlags |= static_cast<UCHAR>(qst);
}

inline void QUEUE_FORMAT::UnknownID(PVOID)
{
    m_qft = QUEUE_FORMAT_TYPE_UNKNOWN;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
}

inline QUEUE_FORMAT::QUEUE_FORMAT()
{
    UnknownID(0);
    m_pDirectID = NULL;

    //
    // a bunch of C_ASSERTS here to make sure alignment of struct members is what we
    // expect it to be.
    // it is here inside a class function just because struct members are private
    //
#ifdef _WIN64
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gPublicID)      == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_oPrivateID)     == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_pDirectID)      == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gConnectorID)   == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_DlID)           == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_MulticastID)    == 8);

    //
    // The C_ASSERTs below ensure that the 64 bit driver can accept
    // QUEUE_FORMAT comming from 32 bit application
    //
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_gPublicID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_oPrivateID)     == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_pDirectID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_gConnectorID)   == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_DlID32)         == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_MulticastID)    == 4);
#else //!_WIN64
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gPublicID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_oPrivateID)     == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_pDirectID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gConnectorID)   == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_DlID)           == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_MulticastID)    == 4);
#endif //_WIN64
}

inline void QUEUE_FORMAT::PublicID(const GUID& gPublicID)
{
    m_qft = QUEUE_FORMAT_TYPE_PUBLIC;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_gPublicID = gPublicID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const GUID& gPublicID)
{
    PublicID(gPublicID);
}

inline const GUID& QUEUE_FORMAT::PublicID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_PUBLIC);
    return m_gPublicID;
}

inline void QUEUE_FORMAT::DlID(const DL_ID& DlID)
{
    m_qft = QUEUE_FORMAT_TYPE_DL;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_DlID = DlID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const DL_ID& id)
{
    DlID(id);
}

inline const DL_ID& QUEUE_FORMAT::DlID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_DL);
    return m_DlID;
}

inline void QUEUE_FORMAT::PrivateID(const GUID& Lineage, ULONG Uniquifier)
{
    m_qft = QUEUE_FORMAT_TYPE_PRIVATE;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_oPrivateID.Lineage = Lineage;
    m_oPrivateID.Uniquifier = Uniquifier;
    ASSERT(Uniquifier != 0);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const GUID& Lineage, ULONG Uniquifier)
{
    PrivateID(Lineage, Uniquifier);
}

inline void QUEUE_FORMAT::PrivateID(const OBJECTID& oPrivateID)
{
    PrivateID(oPrivateID.Lineage, oPrivateID.Uniquifier);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const OBJECTID& oPrivateID)
{
    PrivateID(oPrivateID);
}

inline const OBJECTID& QUEUE_FORMAT::PrivateID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_PRIVATE);
    return m_oPrivateID;
}

inline void QUEUE_FORMAT::DirectID(LPWSTR pDirectID, UCHAR flags)
{
    ASSERT((flags & QUEUE_FORMAT_SUFFIX_MASK) == 0);
    ASSERT(("Invalid direct format name", pDirectID != NULL));

    m_qft = QUEUE_FORMAT_TYPE_DIRECT;
    m_SuffixAndFlags = static_cast<UCHAR>(((UCHAR)QUEUE_SUFFIX_TYPE_NONE) | flags);
    m_pDirectID = pDirectID;
}

inline void QUEUE_FORMAT::DirectID(LPWSTR pDirectID)
{
    DirectID(pDirectID, 0);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(LPWSTR pDirectID)
{
    DirectID(pDirectID);
}

inline LPCWSTR QUEUE_FORMAT::DirectID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    return m_pDirectID;
}

inline void QUEUE_FORMAT::MachineID(const GUID& gMachineID)
{
    m_qft = QUEUE_FORMAT_TYPE_MACHINE;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_DEADLETTER; // Flags = 0
    m_gMachineID = gMachineID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(PVOID, const GUID& gMachineID)
{
    MachineID(gMachineID);
}

inline const GUID& QUEUE_FORMAT::MachineID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_MACHINE);
    return m_gMachineID;
}

inline void QUEUE_FORMAT::ConnectorID(const GUID& gConnectorID)
{
    m_qft = QUEUE_FORMAT_TYPE_CONNECTOR;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_gConnectorID = gConnectorID;
}

inline const GUID& QUEUE_FORMAT::ConnectorID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);
    return m_gConnectorID;
}

inline void QUEUE_FORMAT::MulticastID(const MULTICAST_ID& MulticastID)
{
    m_qft = QUEUE_FORMAT_TYPE_MULTICAST;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_MulticastID = MulticastID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const MULTICAST_ID& id)
{
    MulticastID(id);
}

inline const MULTICAST_ID& QUEUE_FORMAT::MulticastID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
    return m_MulticastID;
}


inline void QUEUE_FORMAT::DisposeString()
{
    switch (GetType())
    {
        case QUEUE_FORMAT_TYPE_DIRECT:
            delete [] m_pDirectID;
            m_pDirectID = NULL;
            break;

        case QUEUE_FORMAT_TYPE_DL:
            delete [] m_DlID.m_pwzDomain;
            m_DlID.m_pwzDomain = NULL;
            break;

        default:
            NULL;
            break;
    }
}

inline bool QUEUE_FORMAT::IsSystemQueue() const
{
    return ((GetType() == QUEUE_FORMAT_TYPE_MACHINE) || ((m_SuffixAndFlags & QUEUE_FORMAT_FLAG_SYSTEM) != 0));
}

#ifdef _WIN64
inline void QUEUE_FORMAT::InitFromQueueFormat32(const struct QUEUE_FORMAT_32 * pqft32)
//
// initialize from a QUEUE_FORMAT_32 (32 bit ptrs)
//
{
    m_qft = pqft32->m_qft; 
    m_SuffixAndFlags = pqft32->m_SuffixAndFlags;
    m_reserved = pqft32->m_reserved;

    switch (pqft32->m_qft)
    {
    case QUEUE_FORMAT_TYPE_UNKNOWN:
       //
       // Like in an UnknownID call
       //
       ASSERT(pqft32->m_pDirectID == NULL);
       m_pDirectID = pqft32->m_pDirectID;
       break;

    case QUEUE_FORMAT_TYPE_PUBLIC:
       m_gPublicID = pqft32->m_gPublicID;
       break;

    case QUEUE_FORMAT_TYPE_DL:
       m_DlID.m_DlGuid = pqft32->m_DlID32.m_DlGuid;
       m_DlID.m_pwzDomain = pqft32->m_DlID32.m_pwzDomain;
       break;

    case QUEUE_FORMAT_TYPE_PRIVATE:
       m_oPrivateID = pqft32->m_oPrivateID;
       break;

    case QUEUE_FORMAT_TYPE_DIRECT:
       m_pDirectID = pqft32->m_pDirectID;
       break;

    case QUEUE_FORMAT_TYPE_MACHINE:
       m_gMachineID = pqft32->m_gMachineID;
       break;

    case QUEUE_FORMAT_TYPE_CONNECTOR:
       m_gConnectorID = pqft32->m_gConnectorID;
       break;

    case QUEUE_FORMAT_TYPE_MULTICAST:
        m_MulticastID = pqft32->m_MulticastID;
        break;

    default:
       //
       // ASSERT(0) for warning level 4
       //
       ASSERT(pqft32->m_qft == QUEUE_FORMAT_TYPE_DIRECT);
       break;
    }    
}

#endif //_WIN64    


#endif // __cplusplus

#endif // __QFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rpcsrv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name: rpcsrv.h

Abstract: rpc related code.


Author:

    Nela Karpel (nelak)   2-Aug-2001

--*/

#ifndef _RPCSRV_H_
#define _RPCSRV_H_


class CBaseContextType {

public:	
	enum eContextType {
		eOpenRemoteCtx = 0,
		eQueueCtx,
		eTransactionCtx,
		eRemoteSessionCtx,
		eRemoteReadCtx,
		eQueryHandleCtx,
		eDeleteNotificationCtx,
		eNewRemoteReadCtx
	};

	CBaseContextType() {};

	CBaseContextType(eContextType eType) : m_eType(eType) {};

public:	
	eContextType m_eType;
};

#endif //_RPCSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\qm.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qm.h

Abstract:

    QM DLL interface

Author:

    Uri Habusha (urih) 1-Jan-1996

--*/

#pragma once

#ifndef __QM_H__
#define __QM_H__


//---------------------------------------------------------
//
// QM APIs
//
//---------------------------------------------------------

#ifdef _QM_
#define QM_EXPORT  __declspec(dllexport)
#else
#define QM_EXPORT  __declspec(dllimport)
#endif


QM_EXPORT
int
APIENTRY
QMMain(
    int argc,
    LPCTSTR argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rrdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    rrdef.h

Abstract:
    Remote Read Ack definitions

Author:
    Ilan Herbst (ilanh) 29-Jan-2002

--*/

#ifndef _REMOTE_READ_ACK_DEFINED
#define _REMOTE_READ_ACK_DEFINED

#ifdef __midl
cpp_quote("#ifndef _REMOTE_READ_ACK_DEFINED")
cpp_quote("#define _REMOTE_READ_ACK_DEFINED")
#endif // __midl

typedef enum _REMOTEREADACK {
        RR_UNKNOWN,
        RR_NACK,
        RR_ACK
} REMOTEREADACK;

#ifdef __midl
cpp_quote("#endif // _REMOTE_READ_ACK_DEFINED")
#endif // __midl

#endif // _REMOTE_READ_ACK_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rt.h

Abstract:
    Message Queuing Header File

--*/

#ifndef __RT_H
#define __RT_H

#include <mqtypes.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <_mqdef.h>
#include <transact.h>

//  begin_mq_h

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  RECEIVE CALLBACK
//********************************************************************

typedef
VOID
(APIENTRY *PMQRECEIVECALLBACK)(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
    );


//********************************************************************
// MSMQ API
//********************************************************************

HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    );

HRESULT
APIENTRY
MQLocateBegin(
    IN LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    );

HRESULT
APIENTRY
MQLocateNext(
    IN HANDLE hEnum,
    IN OUT DWORD* pcProps,
    OUT MQPROPVARIANT aPropVar[]
    );

HRESULT
APIENTRY
MQLocateEnd(
    IN HANDLE hEnum
    );

HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
MQReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

#if(_WIN32_WINNT >= 0x0501)

HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN QUEUEHANDLE hSource,
    IN ULONGLONG ullLookupId,
    IN DWORD dwLookupAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    );

#endif

HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    );

HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    );

HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQInstanceToFormatName(
    IN GUID* pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

#if(_WIN32_WINNT >= 0x0501)

HRESULT
APIENTRY
MQADsPathToFormatName(
    IN LPCWSTR lpwcsADsPath,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

#endif

VOID
APIENTRY
MQFreeMemory(
    IN PVOID pvMemory
    );
// end_mq_h

PVOID
APIENTRY
MQAllocateMemory(
    IN  DWORD size
    );

// begin_mq_h

HRESULT
APIENTRY
MQGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID* pguidMachineId,
    IN OUT MQQMPROPS* pQMProps
    );

HRESULT
APIENTRY
MQGetSecurityContext(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

HRESULT
APIENTRY
MQGetSecurityContextEx(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

VOID
APIENTRY
MQFreeSecurityContext(
    IN HANDLE hSecurityContext
    );

HRESULT
APIENTRY
MQRegisterCertificate(
    IN DWORD dwFlags,
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength
    );

HRESULT
APIENTRY
MQBeginTransaction(
    OUT ITransaction **ppTransaction
    );

HRESULT
APIENTRY
MQGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    );

HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    );

HRESULT
APIENTRY
MQPurgeQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

#ifdef __cplusplus
}
#endif
// end_mq_h

#endif // __RT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\qmpkt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.h

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/

#ifndef __QM_PACKET__
#define __QM_PACKET__

#include <time.h>

#include <qformat.h>
#include <xactdefs.h>
#include <ph.h>
#include <phintr.h>
#include <phinfo.h>
#include <mqtime.h>

//
// CQmPacket Class
//
class CQmPacket{
    public:
        CQmPacket(
			CBaseHeader *pPkt,
			CPacket *pDriverPkt,
			bool ValidityCheck = false,
			bool ValidateSig = true
			);

        inline CBaseHeader *GetPointerToPacket(void) const;
        inline UCHAR *GetPointerToUserHeader(void) const;
        inline UCHAR *GetPointerToSecurHeader(void) const;
		inline UCHAR* GetPointerToPropertySection(void) const;
		inline UCHAR* GetPointerToDebugSection(void) const;
		inline UCHAR* GetPointerToCompoundMessageSection(void) const;
		
        inline CPacket *GetPointerToDriverPacket(void) const;

        inline ULONG  GetSize(void) const;

        inline USHORT  GetVersion(void) const;
        inline BOOL    VersionIsValid(void) const;
        inline BOOL    SignatureIsValid(void) const;
        inline USHORT  GetType(void) const;

        inline BOOL   IsSessionIncluded(void) const;
        inline void   IncludeSession(BOOL);

        inline BOOL   IsDbgIncluded(void) const;

        inline USHORT  GetPriority(void) const;

        inline BOOL   IsImmediateAck(void) const;

        inline USHORT GetTrace(void) const;

        inline BOOL   IsSegmented(void);

        inline const GUID *GetSrcQMGuid(void) const;

        inline const TA_ADDRESS *GetSrcQMAddress(void);

        inline const GUID *GetDstQMGuid(void);

        inline void GetMessageId(OBJECTID*) const;

        inline ULONG GetDeliveryMode(void) const;

        inline ULONG GetAuditingMode(void) const;

        inline BOOL GetCancelFollowUp(void) const;

        inline BOOL IsPropertyInc(void) const;

        inline BOOL IsSecurInc(void) const;

        inline BOOL IsBodyInc(void) const;

        inline void SetConnectorQM(const GUID* pConnector);
        inline const GUID* GetConnectorQM(void) const;
        inline BOOL  ConnectorQMIncluded(void) const;

        inline BOOL IsFirstInXact(void) const;
        inline BOOL IsLastInXact(void) const;

        inline ULONG GetHopCount(void) const;
        inline void  IncHopCount(void);

        inline BOOL GetDestinationQueue(QUEUE_FORMAT* pqdQueue, BOOL = FALSE) const;

        inline BOOL GetTestQueue(QUEUE_FORMAT* pqdQueue);

        inline BOOL GetAdminQueue(QUEUE_FORMAT* pqdQueue) const;

        inline BOOL GetResponseQueue(QUEUE_FORMAT* pqdQueue) const;

        inline bool  GetDestinationMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfDestinationMqfElements(VOID) const;

        inline bool  GetAdminMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfAdminMqfElements(VOID) const;

        inline bool  GetResponseMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfResponseMqfElements(VOID) const;

        inline ULONG GetSentTime(void) const;

        inline USHORT GetClass(void) const;

        inline UCHAR GetAckType(void) const;

        inline void GetCorrelation(PUCHAR pCorrelationID) const;
        inline const UCHAR *GetCorrelation(void) const;

        inline ULONG GetApplicationTag(void) const;

        inline ULONG GetBodySize(void) const;
        inline void SetBodySize(ULONG ulBodySize);
        inline ULONG GetAllocBodySize(void) const;
        inline ULONG GetBodyType(void) const;

        inline const WCHAR* GetTitlePtr(void) const;
        inline ULONG GetTitleLength(void) const;

        inline const UCHAR* GetMsgExtensionPtr(void) const;
        inline ULONG GetMsgExtensionSize(void) const;

        inline void SetPrivLevel(ULONG);
        inline ULONG GetPrivLevel(void) const;
        inline ULONG GetPrivBaseLevel(void) const;

        inline ULONG GetHashAlg(void) const;

        inline ULONG GetEncryptAlg(void) const;

        inline void SetAuthenticated(BOOL);
        inline BOOL IsAuthenticated(void) const;

		inline void SetLevelOfAuthentication(UCHAR);
		inline UCHAR GetLevelOfAuthentication(void) const;

        inline void SetEncrypted(BOOL);
        inline BOOL IsEncrypted(void) const;

        inline USHORT GetSenderIDType(void) const;
        inline void SetSenderIDType(USHORT);

        inline const UCHAR* GetSenderID(USHORT* pwSize) const;

        inline const UCHAR* GetSenderCert(ULONG* pulSize) const;
        inline BOOL SenderCertExist(void) const;

        inline const UCHAR* GetEncryptedSymmetricKey(USHORT* pwSize) const;
        inline void SetEncryptedSymmetricKey(const UCHAR *pPacket, USHORT wSize);

		inline USHORT GetSignatureSize(void) const;
        inline const UCHAR* GetSignature(USHORT* pwSize) const;

        inline void GetProvInfo(BOOL *bDefPRov, LPCWSTR *wszProvName, ULONG *pulProvType) const;
        inline const struct _SecuritySubSectionEx *
                     GetSubSectionEx( enum enumSecInfoType eType ) const ;

        inline const UCHAR* GetPacketBody(ULONG* pulSize) const;
		inline const UCHAR* GetPointerToPacketBody(void) const;

        void CreateAck(USHORT usClass);

        inline DWORD  GetRelativeTimeToQueue(void) const;
        inline DWORD  GetRelativeTimeToLive(void) const;
		inline DWORD  GetAbsoluteTimeToLive(void) const;
		inline DWORD  GetAbsoluteTimeToQueue(void) const;

        inline void    SetAcknowldgeNo(WORD  dwPacketAckNo);
        inline void    SetStoreAcknowldgeNo(DWORD_PTR dwPacketStoreAckNo);
        inline WORD    GetAcknowladgeNo(void) const;
        inline DWORD_PTR   GetStoreAcknowledgeNo(void) const;

        inline BOOL IsRecoverable();    // TRUE if packet is recoverable

        inline BOOL  GetReportQueue(OUT QUEUE_FORMAT* pReportQueue) const;

        HRESULT GetDestSymmKey(OUT HCRYPTKEY *phSymmKey,
                               OUT BYTE  **ppEncSymmKey,
                               OUT DWORD *pdwEncSymmKeyLen,
                               OUT PVOID *ppQMCryptInfo);
        HRESULT EncryptExpressPkt(IN HCRYPTKEY hKey,
                                  IN BYTE *pbSymmKey,
                                  IN DWORD dwSymmKeyLen);
        HRESULT Decrypt(void);

        inline BOOL     IsOrdered(void) const;
        inline BOOL     ConnectorTypeIsIncluded(void) const;
        inline const GUID* GetConnectorType(void) const ;

        inline void     SetSeqID(LONGLONG liSeqID);
        inline LONGLONG GetSeqID(void) const;

        inline void    SetSeqN(ULONG ulSeqN);
        inline ULONG   GetSeqN(void) const;

        inline void    SetPrevSeqN(ULONG ulPrevSeqN);
        inline ULONG   GetPrevSeqN(void) const;

        //
        //  BUGBUG: you should not really have Save in qmpkt. erezh
        //
        HRESULT Save(void);  // saves the changes in header

		inline ULONG GetSignatureMqfSize(void) const;
		inline const UCHAR* GetPointerToSignatureMqf(ULONG* pSize) const;

        inline bool  IsSrmpIncluded(VOID) const;
		inline const UCHAR* GetPointerToCompoundMessage(VOID) const;
		inline ULONG GetCompoundMessageSizeInBytes(VOID) const;

        inline bool      IsEodIncluded(VOID) const;
        inline ULONG     GetEodStreamIdSizeInBytes(VOID) const;
        inline VOID      GetEodStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;
        inline const UCHAR* GetPointerToEodStreamId(VOID) const;
        inline ULONG     GetEodOrderQueueSizeInBytes(VOID) const;
        inline const UCHAR* GetPointerToEodOrderQueue(VOID) const;

        inline bool      IsEodAckIncluded(VOID) const;
        inline LONGLONG  GetEodAckSeqId(VOID) const;
        inline LONGLONG  GetEodAckSeqNum(VOID) const;
        inline ULONG     GetEodAckStreamIdSizeInBytes(VOID) const;
        inline VOID      GetEodAckStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;
        inline const UCHAR* GetPointerToEodAckStreamId(VOID) const;

		inline bool IsSoapIncluded(VOID) const;
		inline bool IsSenderStreamIncluded(VOID) const;
		inline const WCHAR* GetPointerToSoapBody(VOID) const;
		inline ULONG GetSoapBodyLengthInWCHARs(VOID) const;
		inline const WCHAR* GetPointerToSoapHeader(VOID) const;
		inline ULONG GetSoapHeaderLengthInWCHARs(VOID) const;
		inline const CSenderStream* GetSenderStream() const;
		inline const WCHAR* GetPointerToSrmpEnvelopeHeader() const;
		WCHAR* GetDestinationQueueFromSrmpSection()const;
		bool IsSrmpMessageGeneratedByMsmq(void) const; 
		

    public:
        LIST_ENTRY m_link;

    private:
        WORD   m_dwPacketAckNo;
        DWORD_PTR  m_dwPacketStoreAckNo;


	private:
		template <class SECTION_PTR> SECTION_PTR section_cast(void* pSection) const
		{
			return m_pBasicHeader->section_cast<SECTION_PTR>(pSection);
		}
		void PacketIsValid() const;


    private:
        CPacket*            m_pDriverPacket;

    private:
        CBaseHeader *               m_pBasicHeader;
        CUserHeader *               m_pcUserMsg;
        CXactHeader *               m_pXactSection;
        CSecurityHeader *           m_pSecuritySection;
        CPropertyHeader *           m_pcMsgProperty;
        CDebugSection *             m_pDbgPkt;
        CBaseMqfHeader *            m_pDestinationMqfHeader;
        CBaseMqfHeader *            m_pAdminMqfHeader;
        CBaseMqfHeader *            m_pResponseMqfHeader;
		CMqfSignatureHeader *       m_pMqfSignatureHeader;
        CSrmpEnvelopeHeader  *      m_pSrmpEnvelopeHeader;
        CCompoundMessageHeader *    m_pCompoundMessageHeader;
        CEodHeader *                m_pEodHeader;
        CEodAckHeader *             m_pEodAckHeader;
		CSoapSection *              m_pSoapHeaderSection;
		CSoapSection *              m_pSoapBodySection;
		CSenderStreamHeader*        m_pSenderStreamHeader;
        CSessionSection *           m_pSessPkt;
};

/*======================================================================

 Function:     CQmPacket::GetPointerToPacket

 Description:  returns pointer to packet

 =======================================================================*/
inline CBaseHeader *
CQmPacket::GetPointerToPacket(void) const
{
    return( m_pBasicHeader);
}

/*======================================================================

 Function:     CQmPacket::GetPointerToDriverPacket

 Description:  returns pointer to packet

 =======================================================================*/
inline CPacket *
CQmPacket::GetPointerToDriverPacket(void) const
{
    return( m_pDriverPacket);
}


/*======================================================================

 Function:     CQmPacket::GetPointerToUserHeader

 Description:  returns pointer to user header section

 =======================================================================*/
inline UCHAR *
CQmPacket::GetPointerToUserHeader(void) const
{
    return (UCHAR*) m_pcUserMsg;
}

/*======================================================================

 Function:     CQmPacket::GetPointerToSecurHeader

 Description:  returns pointer to security section

 =======================================================================*/
inline UCHAR *
CQmPacket::GetPointerToSecurHeader(void) const
{
    return (UCHAR*) m_pSecuritySection;
}

inline 
UCHAR* 
CQmPacket::GetPointerToPropertySection(void) const
{
	return reinterpret_cast<UCHAR*>(m_pcMsgProperty); 
}

inline 
UCHAR* 
CQmPacket::GetPointerToDebugSection(void) const
{
    return reinterpret_cast<UCHAR*>(m_pDbgPkt);
}


/*======================================================================

 Function:    CQmPacket::GetPointerToCompoundMessageSection

 Description:  returns pointer to CompoundMessage section

 =======================================================================*/
inline UCHAR* CQmPacket::GetPointerToCompoundMessageSection(void) const
{
	ASSERT(IsSrmpIncluded());
	return reinterpret_cast<UCHAR*>(m_pCompoundMessageHeader); 
}


/*======================================================================

 Function:     CQmPacket::GetSize

 Description:  returns the packet size

 =======================================================================*/
inline ULONG
CQmPacket::GetSize(void) const
{
    return(m_pBasicHeader->GetPacketSize());
}

/*======================================================================

 Function:     CQmPacket::GetVersion

 Description:  returns the packet version field

 =======================================================================*/
inline USHORT
CQmPacket::GetVersion(void) const
{
    return(m_pBasicHeader->GetVersion());
}

/*======================================================================

 Function:     CQmPacket::VersionIsValid

 Description:  returns the packet type

 =======================================================================*/
inline BOOL
CQmPacket::VersionIsValid(void) const
{
    return(m_pBasicHeader->VersionIsValid());
}

/*======================================================================

 Function:     CQmPacket::SignatureIsValid

 Description:  return TRUE if Falcon packet signature is ok, False otherwise

 =======================================================================*/
inline BOOL CQmPacket::SignatureIsValid(void) const
{
    return(m_pBasicHeader->SignatureIsValid());
}

/*======================================================================

 Function:     CQmPacket::GetType

 Description:  returns the packet type

 =======================================================================*/
inline USHORT
CQmPacket::GetType(void) const
{
    return(m_pBasicHeader->GetType());
}

/*======================================================================

 Function:    CQmPacket::IncludeSession

 Description:

 =======================================================================*/
inline void
CQmPacket::IncludeSession(BOOL f)
{
    m_pBasicHeader->IncludeSession(f);
}

/*======================================================================

 Function:    CQmPacket::IsSessionIncluded

 Description: returns TRUE if session section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsSessionIncluded(void) const
{
    return(m_pBasicHeader->SessionIsIncluded());
}

/*======================================================================

 Function:     CQmPacket::IsDbgIncluded

 Description:  returns TRUE if debug section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsDbgIncluded(void) const
{
    return(m_pBasicHeader->DebugIsIncluded());
}

/*======================================================================

 Function:     CQmPacket::GetPriority

 Description:  returns the packet priority

 =======================================================================*/
inline USHORT
CQmPacket::GetPriority(void) const
{
    return(m_pBasicHeader->GetPriority());
}

/*======================================================================

 Function:     CQmPacket::IsImmediateAck

 Description:  Return TRUE if the ACK immediately bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsImmediateAck(void) const
{
    return(m_pBasicHeader->AckIsImmediate());
}


/*======================================================================

 Function:    CQmPacket::IsTrace

 Description: returns TRUE if the trace bit is set, FALSE otherwise

 =======================================================================*/
inline USHORT
CQmPacket::GetTrace(void) const
{
    return(m_pBasicHeader->GetTraced());
}

/*======================================================================

 Function:     CQmPacket::IsSegmented

 Description:  returns TRUE if the segmented bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsSegmented(void)
{
    return(m_pBasicHeader->IsFragmented());
}


/*======================================================================

 Function:     CUserMsgHeader::GetSrcQMGuid

 Description:  returns the source QM guid

 =======================================================================*/
inline const GUID *
CQmPacket::GetSrcQMGuid(void) const
{
    return(m_pcUserMsg->GetSourceQM());
}

/*======================================================================

 Function:     CUserMsgHeader::GetSrcQMGuid

 Description:  returns the source QM guid

 =======================================================================*/
inline const TA_ADDRESS *
CQmPacket::GetSrcQMAddress(void)
{
    return(m_pcUserMsg->GetAddressSourceQM());
}

/*======================================================================

 Function:    CQmPacket::GetDstQMGuid

 Description:

 =======================================================================*/
inline const GUID *
CQmPacket::GetDstQMGuid(void)
{
    return(m_pcUserMsg->GetDestQM());
}

/*======================================================================

 Function:    CQmPacket::GetId

 Description: Return the Message ID field

 =======================================================================*/
inline void
CQmPacket::GetMessageId(OBJECTID * pMessageId) const
{
    m_pcUserMsg->GetMessageID(pMessageId);
}

/*======================================================================

 Function:     CQmPacket::getDeliveryMode

 Description:  return the message delivery mode

 =======================================================================*/
inline ULONG
CQmPacket::GetDeliveryMode(void) const
{
    return(m_pcUserMsg->GetDelivery());
}

/*======================================================================

 Function:      CQmPacket::GetAuditingMode

 Description:   return message auditing mode

 =======================================================================*/
inline ULONG
CQmPacket::GetAuditingMode(void) const
{
    return(m_pcUserMsg->GetAuditing());
}

/*======================================================================

 Function:      CQmPacket::GetCancelFollowUp

 Description:   return message Cancel Follow Up mode

 =======================================================================*/
inline BOOL
CQmPacket::GetCancelFollowUp(void) const
{
    if (!m_pXactSection)
    {
        return FALSE;
    }
    else
    {
        return(m_pXactSection->GetCancelFollowUp());
    }
}

/*======================================================================

 Function:    CQmPacket::IsPropertyInc

 Description: Returns TRUE if Message property section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsPropertyInc(VOID) const
{
    return(m_pcUserMsg->PropertyIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::IsSecurInc

 Description:

 =======================================================================*/
inline BOOL
CQmPacket::IsSecurInc(void) const
{
    return(m_pcUserMsg->SecurityIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::IsBodyInc

 Description: return TRUE if message body included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsBodyInc(void) const
{
	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetBodySizeInBytes() != 0);
    }

    return(m_pcMsgProperty->GetBodySize() != 0);
}

/*======================================================================

  Function:     CQmPacket::GetConnectorQM

  Description:  Returns the ID of the destination Connector QM

========================================================================*/
inline const GUID*
CQmPacket::GetConnectorQM(void) const
{
    return (ConnectorQMIncluded() ? m_pXactSection->GetConnectorQM() : NULL);
}


inline BOOL CQmPacket::IsFirstInXact(void) const
{
    return (m_pXactSection ? m_pXactSection->GetFirstInXact() : FALSE);
}


inline BOOL CQmPacket::IsLastInXact(void) const
{
    return (m_pXactSection ? m_pXactSection->GetLastInXact() : FALSE);
}


/*======================================================================

  Function:     CQmPacket::SetConnectorQM

  Description:  Set the Connector Qm on the packet

========================================================================*/
inline void
CQmPacket::SetConnectorQM(const GUID* pConnector)
{
    ASSERT(ConnectorQMIncluded());

    m_pXactSection->SetConnectorQM(pConnector);
}

/*======================================================================

  Function:     CQmPacket::ConnectorQMIncluded

  Description:  returns TRUE if the message contains destination Connector QM ID.
                (the message is transacted message and it send to foreign queue)

========================================================================*/
inline BOOL
CQmPacket::ConnectorQMIncluded(void) const
{
    return (m_pXactSection ? m_pXactSection->ConnectorQMIncluded() : FALSE);
}

/*======================================================================

 Function:    CQmPacket::IncHopCount

 Description: Increment hop count

 =======================================================================*/
inline void CQmPacket::IncHopCount(void)
{
    m_pcUserMsg->IncHopCount();
}

/*======================================================================

 Function:    CQmPacket::GetHopCount

 Description: returns the message hop count

 =======================================================================*/
inline ULONG
CQmPacket::GetHopCount(void) const
{
    return(m_pcUserMsg->GetHopCount());
}


/*======================================================================

 Function:    CQmPacket::GetDestinationQueue

 Description: returns the destination queue

 =======================================================================*/
inline BOOL
CQmPacket::GetDestinationQueue(QUEUE_FORMAT* pqdQueue,
                               BOOL fGetConnectorQM /*=FALSE*/) const
{
    const GUID* pConnectorGuid;

    pConnectorGuid = (fGetConnectorQM && ConnectorQMIncluded()) ? GetConnectorQM() : NULL;

    if (pConnectorGuid && (*pConnectorGuid != GUID_NULL))
    {
        pqdQueue->MachineID(*pConnectorGuid);
        return TRUE;
    }
    else
    {
        return(m_pcUserMsg->GetDestinationQueue(pqdQueue));
    }
}

/*======================================================================

 Function:    CQmPacket::GetAdminQueue

 Description: returns the Admin queue

 =======================================================================*/
inline BOOL
CQmPacket::GetAdminQueue(QUEUE_FORMAT* pqdQueue) const
{
    return(m_pcUserMsg->GetAdminQueue(pqdQueue));
}


/*======================================================================

 Function:    CQmPacket::GetResponseQueue

 Description: returns the Response queue

 =======================================================================*/
inline BOOL
CQmPacket::GetResponseQueue(QUEUE_FORMAT* pqdQueue) const
{
    return(m_pcUserMsg->GetResponseQueue(pqdQueue));
}


/*======================================================================

 Function:    CQmPacket::GetDestinationMqf

 Description: returns the Destination MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetDestinationMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pDestinationMqfHeader == NULL)
    {
        //
        // Destination MQF header may not be included in the packet
        //
        return false;
    }

    m_pDestinationMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfDestinationMqfElements

 Description: returns the number of queue format elements in the
              Destination MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfDestinationMqfElements(VOID) const
{
    if (m_pDestinationMqfHeader == NULL)
    {
        //
        // Destination MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pDestinationMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetAdminMqf

 Description: returns the Admin MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetAdminMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pAdminMqfHeader == NULL)
    {
        //
        // Admin MQF header may not be included in the packet
        //
        return false;
    }

    m_pAdminMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfAdminMqfElements

 Description: returns the number of queue format elements in the
              Admin MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfAdminMqfElements(VOID) const
{
    if (m_pAdminMqfHeader == NULL)
    {
        //
        // Admin MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pAdminMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetResponseMqf

 Description: returns the Response MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetResponseMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pResponseMqfHeader == NULL)
    {
        //
        // Response MQF header may not be included in the packet
        //
        return false;
    }

    m_pResponseMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfResponseMqfElements

 Description: returns the number of queue format elements in the
              Response MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfResponseMqfElements(VOID) const
{
    if (m_pResponseMqfHeader == NULL)
    {
        //
        // Response MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pResponseMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetSentTime

 Description: returns packet sent time

 =======================================================================*/
inline ULONG CQmPacket::GetSentTime(void) const
{
    return m_pcUserMsg->GetSentTime();
}


/*======================================================================

 Function:     CQmPacket::GetClass

 Description:  Returns message class

 =======================================================================*/
inline USHORT
CQmPacket::GetClass(void) const
{
    return(m_pcMsgProperty->GetClass());
}

/*===========================================================

  Routine Name:  CQmPacket::GetAckType

  Description:   Returns The Ack Type

=============================================================*/
inline UCHAR
CQmPacket::GetAckType(void) const
{
    return(m_pcMsgProperty->GetAckType());
}

/*======================================================================

 Function:    CQmPacket::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline const UCHAR *
CQmPacket::GetCorrelation(void) const
{
    return m_pcMsgProperty->GetCorrelationID();
}

/*======================================================================

 Function:    CQmPacket::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline void
CQmPacket::GetCorrelation(PUCHAR pCorrelationID) const
{
    m_pcMsgProperty->GetCorrelationID(pCorrelationID);
}

/*======================================================================

 Function:    CQmPacket::GetAppsData

 Description: Returns Applecation specific data

 =======================================================================*/
inline ULONG
CQmPacket::GetApplicationTag(void) const
{
    return(m_pcMsgProperty->GetApplicationTag());
}

/*======================================================================

 Function:    CQmPacket::GetBodySize

 Description: Get Message body size

 =======================================================================*/
inline ULONG
CQmPacket::GetBodySize(void) const
{
	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetBodySizeInBytes());
    }

    return(m_pcMsgProperty->GetBodySize());
}

/*======================================================================

 Function:    CQmPacket::SetBodySize

 Description: Set Message body size

 =======================================================================*/
inline void
CQmPacket::SetBodySize(ULONG ulBodySize)
{

	ASSERT(!IsSrmpIncluded());


    m_pcMsgProperty->SetBodySize(ulBodySize);
}

/*======================================================================

 Function:    CQmPacket::GetTitle

 Description: Get Message title

 =======================================================================*/
inline const WCHAR*
CQmPacket::GetTitlePtr(void) const
{
    return(m_pcMsgProperty->GetTitlePtr());
}


/*======================================================================

 Function:    CQmPacket::GetTitleSize

 Description: Get Message title size

 =======================================================================*/
inline ULONG
CQmPacket::GetTitleLength(void) const
{
    return(m_pcMsgProperty->GetTitleLength());
}

/*======================================================================

 Function:    CQmPacket::GetMsgExtensionPtr

 Description: Get pointer to Message Extension property

 =======================================================================*/
inline const UCHAR*
CQmPacket::GetMsgExtensionPtr(void) const
{
    return(m_pcMsgProperty->GetMsgExtensionPtr());
}


/*======================================================================

 Function:    CQmPacket::GetMsgExtensionSize

 Description: Get Message Extension size

 =======================================================================*/
inline ULONG
CQmPacket::GetMsgExtensionSize(void) const
{
    return(m_pcMsgProperty->GetMsgExtensionSize());
}

/*======================================================================

 Function:    CPropertyHeader::SetPrivLevel

 Description: Set the privacy level of the message in the message packet.

 =======================================================================*/
inline void
CQmPacket::SetPrivLevel(ULONG ulPrivLevel)
{
    m_pcMsgProperty->SetPrivLevel(ulPrivLevel);
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetPrivLevel(void) const
{
    return(m_pcMsgProperty->GetPrivLevel());
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivBaseLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetPrivBaseLevel(void) const
{
    return(m_pcMsgProperty->GetPrivBaseLevel()) ;
}

/*======================================================================

 Function:    CPropertyHeader::GetHashAlg

 Description: Get the hash algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetHashAlg(void) const
{
    return(m_pcMsgProperty->GetHashAlg());
}

/*======================================================================

 Function:    CPropertyHeader::GetEncryptAlg

 Description: Get the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetEncryptAlg(void) const
{
    return(m_pcMsgProperty->GetEncryptAlg());
}

/*=============================================================

 Routine Name:  CQmPacket::SetEncrypted

 Description:   Set Encrypted message bit

===============================================================*/
inline void CQmPacket::SetEncrypted(BOOL f)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetEncrypted(f);
}

/*=============================================================

 Routine Name:   CQmPacket::IsEncrypted

 Description:    Returns TRUE if the msg is Encrypted, False otherwise

===============================================================*/
inline BOOL CQmPacket::IsEncrypted(void) const
{
    return(m_pSecuritySection ? m_pSecuritySection->IsEncrypted() :
        FALSE);
}

/*=============================================================

 Routine Name:   CQmPacket::IsOrdered

 Description:    Returns TRUE if the msg is Ordered, False otherwise

===============================================================*/
inline BOOL CQmPacket::IsOrdered(void) const
{
    return m_pcUserMsg->IsOrdered();
}

/*=============================================================

 Routine Name:   CQmPacket::ConnectorTypeIsIncluded

 Description:    Returns TRUE if the msg came from Connector

===============================================================*/
inline BOOL CQmPacket::ConnectorTypeIsIncluded(void) const
{
    return m_pcUserMsg->ConnectorTypeIsIncluded();
}

/*=============================================================

 Routine Name:   CQmPacket::GetConnectorType(void) const

 Description:    Get the guid of the connector type.

===============================================================*/
inline const GUID* CQmPacket::GetConnectorType(void) const
{
    return m_pcUserMsg->GetConnectorType();
}

/*=============================================================

 Routine Name:  CQmPacket::SetAuthenticated

 Description:   Set the authenticated bit

===============================================================*/
inline void CQmPacket::SetAuthenticated(BOOL f)
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->SetAuthenticated(f);
    }
}

/*=============================================================

 Routine Name:   CQmPacket::IsAuthenticated

 Description:    Returns TRUE if the msg is authenticated, False otherwise

===============================================================*/
inline BOOL
CQmPacket::IsAuthenticated(void) const
{
    return(m_pSecuritySection ? m_pSecuritySection->IsAuthenticated() :
        FALSE);
}

/*=============================================================

 Routine Name:  CQmPacket::SetLevelOfAuthentication

 Description:   Set the Level Of Authentication

===============================================================*/
inline void CQmPacket::SetLevelOfAuthentication(UCHAR Level)
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->SetLevelOfAuthentication(Level);
    }
}

/*=============================================================

 Routine Name:   CQmPacket::GetLevelOfAuthentication

 Description:    Return the Level Of Authentication

===============================================================*/
inline UCHAR
CQmPacket::GetLevelOfAuthentication(void) const
{
    return((UCHAR)(m_pSecuritySection ? m_pSecuritySection->GetLevelOfAuthentication() : 
								MQMSG_AUTHENTICATION_NOT_REQUESTED));
}




/*=============================================================

 Routine Name:  CQmPacket::GetSenderIDType

 Description:

===============================================================*/
inline USHORT
CQmPacket::GetSenderIDType(void) const
{
    return((USHORT)(m_pSecuritySection ? m_pSecuritySection->GetSenderIDType() :
        MQMSG_SENDERID_TYPE_NONE));
}



/*=============================================================

 Routine Name:  CQmPacket::SetSenderIDType

 Description:

===============================================================*/
inline void CQmPacket::SetSenderIDType(USHORT uSenderIDType)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetSenderIDType(uSenderIDType);
}

/*=============================================================

 Routine Name:  CQmPacket::GetSenderID

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSenderID(USHORT* pwSize) const
{
    if (GetSenderIDType() == MQMSG_SENDERID_TYPE_NONE)
    {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetSenderID(pwSize));
}

/*=============================================================

 Routine Name:  CQmPacket::GetSenderCert

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSenderCert(ULONG* pulSize) const
{
    if (!m_pSecuritySection)
    {
        *pulSize = 0;
        return(NULL);
    }

    return(m_pSecuritySection->GetSenderCert(pulSize));
}

/*=============================================================

 Routine Name:  CQmPacket::SenderCertExist

 Description:

 Arguments:

 Return Value:	Returns TRUE if Sender Certificate exist

===============================================================*/
inline BOOL
CQmPacket::SenderCertExist(void) const
{
    if (!m_pSecuritySection)
        return(false);

    return(m_pSecuritySection->SenderCertExist());
}

/*=============================================================

 Routine Name:

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetEncryptedSymmetricKey(USHORT* pwSize) const
{
    if (!m_pSecuritySection) {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetEncryptedSymmetricKey(pwSize));
}

/*=============================================================

 Routine Name:

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline void
CQmPacket::SetEncryptedSymmetricKey(const UCHAR *pbKey, USHORT wSize)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetEncryptedSymmetricKey(pbKey, wSize);
}

/*=============================================================

 Routine Name:  CQmPacket::GetSignatureSize

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline USHORT
CQmPacket::GetSignatureSize(void) const
{
    if (!m_pSecuritySection) 
	{
        return 0;
    }

    return(m_pSecuritySection->GetSignatureSize());
}

/*=============================================================

 Routine Name:  CQmPacket::GetSignature

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSignature(USHORT* pwSize) const
{
    if (!m_pSecuritySection) {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetSignature(pwSize));
}

/*=============================================================

 Routine Name:  CQmPacket::GetProvInfo

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline void
CQmPacket::GetProvInfo(
    BOOL *pbDefProv,
    LPCWSTR *wszProvName,
    ULONG *pulProvType) const
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->GetProvInfo(
                                    pbDefProv,
                                    wszProvName,
                                    pulProvType);
    }
    else
    {
        *pbDefProv = TRUE;
    }
}

/*=============================================================

 Routine Name:  CQmPacket::GetSubSectionEx()

===============================================================*/

inline
const struct _SecuritySubSectionEx *
CQmPacket::GetSubSectionEx( enum enumSecInfoType eType ) const
{
    const struct _SecuritySubSectionEx * pSecEx = NULL ;

    if (m_pSecuritySection)
    {
        pSecEx = m_pSecuritySection->GetSubSectionEx( eType ) ;
    }

    return pSecEx ;
}

/*=============================================================

 Routine Name:  CQmPacket::GetPacketBody

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetPacketBody(ULONG* pulSize) const
{
    *pulSize = GetBodySize();

	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetPointerToBody());
    }

    return  m_pcMsgProperty->GetBodyPtr();
}


/*=============================================================

 Routine Name:  CQmPacket::GetPointerToPacketBody

 Description: Get pointer to Packet Body 

===============================================================*/
inline const UCHAR* CQmPacket::GetPointerToPacketBody(void) const
{
	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetPointerToBody());
    }

    return  m_pcMsgProperty->GetBodyPtr();
}


/*=============================================================

 Routine Name:  CQmPacket::GetAllocBodySize

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline ULONG
CQmPacket::GetAllocBodySize(void) const
{
    if(IsSrmpIncluded())
	return 0;

    return m_pcMsgProperty->GetAllocBodySize();
}

/*=============================================================

 Routine Name:  CQmPacket::GetBodyType

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline ULONG
CQmPacket::GetBodyType(void) const
{
    return m_pcMsgProperty->GetBodyType();
}

/*=============================================================

 Routine Name:  CQmPacket::GetAbsoluteTimeToQueue

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline DWORD  CQmPacket::GetAbsoluteTimeToQueue(void) const
{
    return  m_pBasicHeader->GetAbsoluteTimeToQueue();
}



/*=============================================================

 Routine Name:  CQmPacket::GetAbsoluteTimeToLive

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetAbsoluteTimeToLive(void) const
{
    DWORD dwTimeout = m_pcUserMsg->GetTimeToLiveDelta();
    if(dwTimeout == INFINITE)
		return 	INFINITE;
    
    return   dwTimeout + m_pBasicHeader->GetAbsoluteTimeToQueue();
}





/*=============================================================

 Routine Name:  CQmPacket::GetRelativeTimeToQueue

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetRelativeTimeToQueue(void) const
{
    DWORD dwTimeout = m_pBasicHeader->GetAbsoluteTimeToQueue();
    if(dwTimeout != INFINITE)
    {
        DWORD dwCurrentTime = MqSysTime();
        if(dwTimeout > dwCurrentTime)
        {
            dwTimeout -= dwCurrentTime;
        }
        else
        {
            //
            //  Underflow, timeout has expired already.
            //
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}

/*=============================================================

 Routine Name:  CQmPacket::GetRelativeTimeToLive

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetRelativeTimeToLive(void) const
{
    DWORD dwTimeout = m_pcUserMsg->GetTimeToLiveDelta();
    if(dwTimeout != INFINITE)
    {
        dwTimeout += m_pBasicHeader->GetAbsoluteTimeToQueue();

        DWORD dwCurrentTime = MqSysTime();
        if(dwTimeout > dwCurrentTime)
        {
            dwTimeout -= dwCurrentTime;
        }
        else
        {
            //
            //  Underflow, timeout has expired already.
            //
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}


/*=============================================================

 Routine Name:  CQmPacket::SetAcknowldgeNo

 Description:   Set the send ACK number.

===============================================================*/
inline void
CQmPacket::SetAcknowldgeNo(WORD  dwPacketAckNo)
{
    m_dwPacketAckNo = dwPacketAckNo;
}

/*=============================================================

 Routine Name:  CQmPacket::SetStoreAcknowldgeNo

 Description:   Set the packet store ACK number

===============================================================*/
inline void
CQmPacket::SetStoreAcknowldgeNo(DWORD_PTR dwPacketStoreAckNo)
{
    m_dwPacketStoreAckNo = dwPacketStoreAckNo;
}

/*=============================================================

 Routine Name:  CQmPacket::GetAcknowladgeNo

 Description:   return the packet send hop-ACK number

===============================================================*/
inline WORD
CQmPacket::GetAcknowladgeNo(void) const
{
    return(m_dwPacketAckNo);
}

/*=============================================================

 Routine Name:  CQmPacket::GetStoreAcknowledgeNo

 Description:  Return the Packet store hop-ACK number

===============================================================*/
inline DWORD_PTR
CQmPacket::GetStoreAcknowledgeNo(void) const
{
    return(m_dwPacketStoreAckNo);
}

/*=============================================================

 Routine Name:  CQmPacket::IsRecoverable

 Description:   Return TRUE is packet is recoverable and
                should be stored on disk.

===============================================================*/
inline BOOL
CQmPacket::IsRecoverable()
{
    return (GetDeliveryMode() == MQMSG_DELIVERY_RECOVERABLE) ;
}

/*=============================================================

 Routine Name:  CQmPacket::GetReportQueue

 Description:   Return the report queue that associate to the packet

===============================================================*/
inline BOOL
CQmPacket::GetReportQueue(OUT QUEUE_FORMAT* pReportQueue) const
{
    if (m_pDbgPkt == NULL)
        return FALSE;

    return (m_pDbgPkt->GetReportQueue(pReportQueue));
}

/*======================================================================

 Function:    CQmPacket::SetSeqID

 Description: Sets the Sequence ID

 =======================================================================*/
inline void CQmPacket::SetSeqID(LONGLONG liSeqID)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetSeqID(liSeqID);
}

/*======================================================================

 Function:    CQmPacket::GetSeqID

 Description: Gets the Sequence ID

 =======================================================================*/
inline LONGLONG CQmPacket::GetSeqID(void) const

{
    return (m_pXactSection ? m_pXactSection->GetSeqID() : 0);
}

/*======================================================================

 Function:    CQmPacket::SetSeqN

 Description: Sets the Sequence Number

 =======================================================================*/
inline void CQmPacket::SetSeqN(ULONG ulSeqN)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetSeqN(ulSeqN);
}

/*======================================================================

 Function:    CQmPacket::GetSeqN

 Description: Gets the Sequence Number

 =======================================================================*/
inline ULONG CQmPacket::GetSeqN(void) const
{
    return (m_pXactSection ? m_pXactSection->GetSeqN() : 0);
}

/*======================================================================

 Function:    CQmPacket::SetPrevSeqN

 Description: Sets the Previous Sequence Number

 =======================================================================*/
inline void CQmPacket::SetPrevSeqN(ULONG ulPrevSeqN)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetPrevSeqN(ulPrevSeqN);
}

/*======================================================================

 Function:    CQmPacket::GetPrevSeqN

 Description: Gets the Previous Sequence Number

 =======================================================================*/
inline ULONG CQmPacket::GetPrevSeqN(void) const
{
    return (m_pXactSection ? m_pXactSection->GetPrevSeqN() : 0);
}

/*======================================================================

 Function:    CQmPacket::IsSrmpIncluded

 Description: Checks if SRMP section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsSrmpIncluded(VOID) const  
{
    return (m_pcUserMsg->SrmpIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::GetCompoundMessageSizeInBytes

 Description: Returns the size of the CompoundMessage property

 =======================================================================*/
inline ULONG CQmPacket::GetCompoundMessageSizeInBytes(VOID) const
{
	ASSERT(IsSrmpIncluded());
	return m_pCompoundMessageHeader->GetDataSizeInBytes();	
}


/*======================================================================

 Function:    CQmPacket::GetPointerToCompoundMessage

 Description: Get pointer to CompoundMessage 

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToCompoundMessage(VOID) const
{
	ASSERT(IsSrmpIncluded());
	return m_pCompoundMessageHeader->GetPointerToData();
}


/*======================================================================

 Function:    CQmPacket::IsEodIncluded

 Description: Checks if EOD section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsEodIncluded(VOID) const  
{
    return (m_pcUserMsg->EodIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::GetEodStreamIdSizeInBytes

 Description: Returns the Eod stream ID size

 =======================================================================*/
inline ULONG CQmPacket::GetEodStreamIdSizeInBytes(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetStreamIdSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetEodStreamId

 Description: Returns the Eod stream ID

 =======================================================================*/
inline VOID CQmPacket::GetEodStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ASSERT(IsEodIncluded());

    m_pEodHeader->GetStreamId(pBuffer, cbBufferSize);
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodStreamId

 Description: Returns a pointer to the Eod stream ID

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodStreamId(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetPointerToStreamId();
}


/*======================================================================

 Function:    CQmPacket::GetEodOrderQueueSizeInBytes

 Description: Returns the EOD order queue size

 =======================================================================*/
inline ULONG CQmPacket::GetEodOrderQueueSizeInBytes(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetOrderQueueSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodOrderQueue

 Description: Returns a pointer to the EOD order queue

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodOrderQueue(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetPointerToOrderQueue();
}


/*======================================================================

 Function:    CQmPacket::IsEodAckIncluded

 Description: Checks if EodAck section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsEodAckIncluded(VOID) const  
{
    return (m_pcUserMsg->EodAckIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::GetEodAckSeqId

 Description: Returns the EodAck seq ID

 =======================================================================*/
inline LONGLONG CQmPacket::GetEodAckSeqId(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetSeqId();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckSeqNum

 Description: Returns the EodAck seq num

 =======================================================================*/
inline LONGLONG CQmPacket::GetEodAckSeqNum(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetSeqNum();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckStreamIdSizeInBytes

 Description: Returns the EodAck stream ID size

 =======================================================================*/
inline ULONG CQmPacket::GetEodAckStreamIdSizeInBytes(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetStreamIdSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckStreamId

 Description: Returns the EodAck stream ID

 =======================================================================*/
inline VOID CQmPacket::GetEodAckStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetStreamId(pBuffer, cbBufferSize);
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodAckStreamId

 Description: Returns a pointer to the EodAck stream ID

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodAckStreamId(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetPointerToStreamId();
}


/*======================================================================

 Function:    CQmPacket::GetSignatureMqfSize

 Description: Returns the size of the signature MQF in bytes

 =======================================================================*/
inline ULONG CQmPacket::GetSignatureMqfSize(void) const
{
	//
	// The MQF headers are optional and may not be included in the packet
	//
	if (m_pMqfSignatureHeader == NULL)
	{
		return 0;
	}

	return m_pMqfSignatureHeader->GetSignatureSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetPointerToSignatureMqf

 Description: Get pointer to signatureMqf

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToSignatureMqf(ULONG* pSize) const
{
    ASSERT(("Must call GetSignatureMqfSize first!", m_pMqfSignatureHeader != NULL));

	return m_pMqfSignatureHeader->GetPointerToSignature(pSize);
}

/*======================================================================

 Function:    CQmPacket::IsSoapIncluded

 Description: Checks if SOAP section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsSoapIncluded(VOID) const  
{
    return (m_pcUserMsg->SoapIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::GetSoapHeaderLengthInWchars

 Description: Returns the length of the SOAP Header property including NULL terminator

 =======================================================================*/
inline ULONG CQmPacket::GetSoapHeaderLengthInWCHARs(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapHeaderSection->GetDataLengthInWCHARs();	
}

/*======================================================================

 Function:    CQmPacket::GetPointerToSoapHeader

 Description: Get pointer to SOAP Header data

 =======================================================================*/
inline const WCHAR* CQmPacket::GetPointerToSoapHeader(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapHeaderSection->GetPointerToData();
}

/*======================================================================

 Function:    CQmPacket::GetSoapBodyLengthInWchars

 Description: Returns the length of the SOAP Body property including NULL terminator

 =======================================================================*/
inline ULONG CQmPacket::GetSoapBodyLengthInWCHARs(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapBodySection->GetDataLengthInWCHARs();	
}

/*======================================================================

 Function:    CQmPacket::GetPointerToSoapBody

 Description: Get pointer to SOAP Body data

 =======================================================================*/
inline const WCHAR* CQmPacket::GetPointerToSoapBody(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapBodySection->GetPointerToData();
}


/*======================================================================

 Function:    CQmPacket::IsSenderStreamIncluded

 Description: Checks if SenderStream section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsSenderStreamIncluded(VOID) const
{
	return (m_pcUserMsg->SenderStreamIsIncluded());
}




/*======================================================================

 Function:    CQmPacket::GetSenderStream

 Description: Returns the length of the Sender Stream 

 =======================================================================*/
inline const CSenderStream* CQmPacket::GetSenderStream() const
{
	ASSERT(IsSenderStreamIncluded());
	return m_pSenderStreamHeader->GetSenderStream();
}

inline const WCHAR* CQmPacket::GetPointerToSrmpEnvelopeHeader() const
{
	ASSERT(IsSrmpIncluded());
	return m_pSrmpEnvelopeHeader->GetPointerToData();
}


#endif //__QM_PACKET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rtdepcert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtdepcert.h

Abstract:

    Non public certificate-related functions that are exported from MQRTDEP.DLL

--*/


#pragma once

#ifndef _RTDEP_CERT_H_
#define _RTDEP_CERT_H_

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
APIENTRY
DepCreateInternalCertificate(
    OUT CMQSigCertificate **ppCert
    );

HRESULT
APIENTRY
DepDeleteInternalCert(
    IN CMQSigCertificate *pCert
    );

HRESULT
APIENTRY
DepOpenInternalCertStore(
    OUT CMQSigCertStore **pStore,
    IN LONG              *pnCerts,
    IN BOOL               fWriteAccess,
    IN BOOL               fMachine,
    IN HKEY               hKeyUser
    );

HRESULT
APIENTRY
DepGetInternalCert(
    OUT CMQSigCertificate **ppCert,
    OUT CMQSigCertStore   **ppStore,
    IN  BOOL              fGetForDelete,
    IN  BOOL              fMachine,
    IN  HKEY              hKeyUser
    );

 //
 // if fGetForDelete is TRUE then the certificates store is open with write
 // access. Otherwise the store is opened in read-only mode.
 //

HRESULT
APIENTRY
DepRegisterUserCert(
    IN CMQSigCertificate *pCert,
    IN BOOL               fMachine
    );

HRESULT
APIENTRY
DepGetUserCerts(
    CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
    );

HRESULT
APIENTRY
DepRemoveUserCert(
    IN CMQSigCertificate *pCert
    );

#ifdef __cplusplus
}
#endif

#endif // _RTDEP_CERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\shrutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    shrutil.h

Abstract:


Author:

--*/

#ifndef __SHRUTILS_H
#define __SHRUTILS_H

bool
MQUTIL_EXPORT
APIENTRY
IsLocalSystemCluster(
    VOID
    );

#endif //  __MQFUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rtcert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtcert.h

Abstract:

    Non public certificate-related functions that are exported from MQRT.DLL

--*/


#pragma once

#ifndef _RT_CERT_H_
#define _RT_CERT_H_

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
APIENTRY
RTLogOnRegisterCert(
	bool fRetryDs
	);

typedef HRESULT
(APIENTRY *RTLogOnRegisterCert_ROUTINE)(
	bool fRetryDs
	);


HRESULT
APIENTRY
RTCreateInternalCertificate(
    OUT CMQSigCertificate **ppCert
    );

HRESULT
APIENTRY
RTDeleteInternalCert(
    IN CMQSigCertificate *pCert
    );

HRESULT
APIENTRY
RTOpenInternalCertStore(
    OUT CMQSigCertStore **pStore,
    IN LONG              *pnCerts,
    IN BOOL               fWriteAccess,
    IN BOOL               fMachine,
    IN HKEY               hKeyUser
    );

HRESULT
APIENTRY
RTGetInternalCert(
    OUT CMQSigCertificate **ppCert,
    OUT CMQSigCertStore   **ppStore,
    IN  BOOL              fGetForDelete,
    IN  BOOL              fMachine,
    IN  HKEY              hKeyUser
    );

 //
 // if fGetForDelete is TRUE then the certificates store is open with write
 // access. Otherwise the store is opened in read-only mode.
 //

HRESULT
APIENTRY
RTRegisterUserCert(
    IN CMQSigCertificate *pCert,
    IN BOOL               fMachine
    );

HRESULT
APIENTRY
RTGetUserCerts(
    CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
    );

HRESULT
APIENTRY
RTRemoveUserCert(
    IN CMQSigCertificate *pCert
    );

HRESULT
APIENTRY
RTRemoveUserCertSid(
    IN CMQSigCertificate *pCert,
    IN const SID         *pSid
    );

#ifdef __cplusplus
}
#endif

#endif // _RT_CERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\rtdep.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rt.h

Abstract:
    Message Queuing Header File

Note: [ConradC]
    We have implemented delayload failure handling code for MQRTDEP.DLL and the stub code is currently resides in lib\dld\lib\rtdep.cpp. If you add more export functions to mqrtdep.dll, you also need to create the corresponding stub code and update the map.
    

--*/

#ifndef __RTDEP_H
#define __RTDEP_H

#include <mqtypes.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <_mqdef.h>
#include <transact.h>

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  RECEIVE CALLBACK
//********************************************************************

typedef
VOID
(APIENTRY *PMQRECEIVECALLBACK)(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
    );


//********************************************************************
// MSMQ API
//********************************************************************

HRESULT
APIENTRY
DepCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    );

HRESULT
APIENTRY
DepLocateBegin(
    IN LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    );

HRESULT
APIENTRY
DepLocateNext(
    IN HANDLE hEnum,
    IN OUT DWORD* pcProps,
    OUT MQPROPVARIANT aPropVar[]
    );

HRESULT
APIENTRY
DepLocateEnd(
    IN HANDLE hEnum
    );

HRESULT
APIENTRY
DepOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

HRESULT
APIENTRY
DepSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
DepReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

HRESULT
APIENTRY
DepCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    );

HRESULT
APIENTRY
DepCloseCursor(
    IN HANDLE hCursor
    );

HRESULT
APIENTRY
DepCloseQueue(
    IN HANDLE hQueue
    );

HRESULT
APIENTRY
DepSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
DepGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
DepGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

HRESULT
APIENTRY
DepSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
APIENTRY
DepPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepInstanceToFormatName(
    IN GUID* pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

void
APIENTRY
DepFreeMemory(
    IN PVOID pvMemory
    );

HRESULT
APIENTRY
DepGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID* pguidMachineId,
    IN OUT MQQMPROPS* pQMProps
    );

HRESULT
APIENTRY
DepGetSecurityContext(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* hSecurityContext
    );

HRESULT 
APIENTRY
DepGetSecurityContextEx( 
	LPVOID lpCertBuffer,
    DWORD dwCertBufferLength,
    HANDLE* hSecurityContext 
	);

void
APIENTRY
DepFreeSecurityContext(
    IN HANDLE hSecurityContext
    );

HRESULT
APIENTRY
DepRegisterCertificate(
    IN DWORD dwFlags,
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength
    );

HRESULT
APIENTRY
DepRegisterServer(
	VOID
	);

HRESULT
APIENTRY
DepBeginTransaction(
    OUT ITransaction** ppTransaction
    );

HRESULT
APIENTRY
DepGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    );

HRESULT
APIENTRY
DepGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    );

HRESULT
APIENTRY
DepPurgeQueue(
    IN HANDLE hQueue
    );

HRESULT
APIENTRY
DepMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
DepMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

HRESULT
APIENTRY
DepXactGetDTC(
	OUT IUnknown** ppunkDTC
	);

#ifdef __cplusplus
}
#endif

#endif // __RTDEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\version.h ===
#define rmj         5				 	
#define rmm         2					
#define rup       1716				
#define szVerName ""					
#define szVerUser ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\uniansi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    uniansi.h

Abstract:

    Unicode/Ansi conversion macros

Author:

    Doron Juster  (DoronJ)  20-Aug-97

--*/
#ifndef __FALCON_UNIANSI_H
#define __FALCON_UNIANSI_H

#define ConvertToMultiByteString(wcsSrc, mbsDest, umbSize)   \
    WideCharToMultiByte( CP_ACP,                             \
                         0,                                  \
                         wcsSrc,                             \
                         -1,                                 \
                         mbsDest,                            \
                         umbSize,                            \
                         NULL,                               \
                         NULL ) ;

#define ConvertToWideCharString(mbsSrc, wcsDest, uwcSize)    \
    MultiByteToWideChar( CP_ACP,                             \
                         0,                                  \
                         mbsSrc,                             \
                         -1,                                 \
                         wcsDest,                            \
                         uwcSize ) ;

#define CompareSubStringsNoCaseGeneral(str1, str2, len, CompareFunc) \
    (CompareFunc(                                            \
        LOCALE_SYSTEM_DEFAULT,                               \
        NORM_IGNORECASE,                                     \
        str1,                                                \
        len,                                                 \
        str2,                                                \
        len) - 2)

#define CompareSubStringsNoCase(str1, str2, len)             \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareString)             

#define CompareSubStringsNoCaseAnsi(str1, str2, len)         \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareStringA)     

#define CompareSubStringsNoCaseUnicode(str1, str2, len)         \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareStringW)             

#define CompareStringsNoCase(str1, str2) CompareSubStringsNoCase(str1, str2, -1)

#define CompareStringsNoCaseAnsi(str1, str2) CompareSubStringsNoCaseAnsi(str1, str2, -1)

#define CompareStringsNoCaseUnicode(str1, str2) CompareSubStringsNoCaseUnicode(str1, str2, -1)

#define MAX_BYTES_PER_CHAR 2
#endif // __FALCON_UNIANSI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\seqnum.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    seqnum.h

Abstract:

Author:
    Ronit Hartmann (ronith)

--*/

#ifndef __SEQNUM_H
#define __SEQNUM_H


const _SEQNUM MQIS_SMALLEST_SEQNUM =   { 0, 0, 0, 0, 0, 0, 0, 0};
const _SEQNUM MQIS_INFINITE_LSN   =  { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff};



//-----------------------------
//
//  Sequence number class
//
class CSeqNum 
{
public:
    CSeqNum();
    CSeqNum( _SEQNUM * pSN);
    CSeqNum( const CSeqNum & sn);
	~CSeqNum() {};
    void Increment();
    void Decrement();
    DWORD Serialize( unsigned char * pBuf) const; 
    DWORD SetValue( const unsigned char * pBuf);
    static const DWORD GetSerializeSize();
    operator <=( const CSeqNum & sn) const;
    operator <( const CSeqNum & sn) const;
    operator >( const CSeqNum & sn) const;
    operator ==( const CSeqNum & sn) const;
    operator >=( const CSeqNum & sn) const;
    operator !=( const CSeqNum & sn) const;
    CSeqNum & operator = ( const CSeqNum & sn);
    const unsigned char * GetPtr() const;
    void GetValue(BLOB * pblob) const;
    void GetValueForPrint( OUT WCHAR * pBuffer) const;
    BOOL IsSmallestValue() const;
    BOOL IsSmallerByMoreThanOne( const CSeqNum & sn) const;
	BOOL NotGreaterByMoreThanFrom(DWORD diff, const CSeqNum &other) const;
    BOOL IsInfiniteLsn() const;
    void SetSmallestValue();
    void SetInfiniteLSN();
	BOOL IsMultipleOf(IN DWORD dwFrequency) const;
	void operator -= (DWORD dwSub);
	void operator += (DWORD dwAdd);
	
private:

	DWORD GetHighDWORD() const;
	DWORD GetLowDWORD() const;
	DWORD GetDWORD(IN int offset) const;
	void SetHighDWORD(IN DWORD dw);
	void SetLowDWORD(IN DWORD dw);
	void SetDWORD(IN int offset, IN DWORD dw);

    _SEQNUM    m_SeqNum;

};

inline CSeqNum::CSeqNum():m_SeqNum( MQIS_SMALLEST_SEQNUM)
{
}

inline CSeqNum::CSeqNum( _SEQNUM * pSN): m_SeqNum(*pSN)
{ 
}

inline CSeqNum::CSeqNum( const CSeqNum & sn)
{
    m_SeqNum = sn.m_SeqNum;
}

inline DWORD CSeqNum::Serialize( unsigned char * pBuf) const
{
    memcpy( pBuf, &m_SeqNum, sizeof(_SEQNUM));
    return( sizeof(_SEQNUM));
}

inline DWORD CSeqNum::SetValue( const unsigned char * pBuf)
{
    memcpy( &m_SeqNum, pBuf, sizeof(_SEQNUM));
    return( sizeof(_SEQNUM));
}

inline const DWORD CSeqNum::GetSerializeSize()
{
    return(sizeof(_SEQNUM));
}

inline BOOL CSeqNum::IsSmallestValue() const
{
    return ( !memcmp( &m_SeqNum,&MQIS_SMALLEST_SEQNUM,sizeof(_SEQNUM)));
}

inline void CSeqNum::Increment()
{
    long i;

    for ( i = 7 ; i >= 0 ; i--)
    {
        m_SeqNum.c[i]++;
        if (m_SeqNum.c[i] != 0) // no wrap around
        {
            break;
        }
    }
}
inline void CSeqNum::Decrement()
{
    long i;
    BOOL fToContinue;
    for ( i = 7; i >=0 ; i--)
    {
        fToContinue = ( m_SeqNum.c[i] == 0);  //  decrement the next digit also
        m_SeqNum.c[i]--;

        if ( !fToContinue)
        {
            break;
        }
    }
}

inline  CSeqNum::operator !=( const CSeqNum & sn) const
{
    return( memcmp( &m_SeqNum,&sn.m_SeqNum,sizeof(_SEQNUM)));
}
inline  CSeqNum::operator ==( const CSeqNum & sn) const
{
    return( !memcmp( &m_SeqNum,&sn.m_SeqNum,sizeof(_SEQNUM)));
}
inline  CSeqNum::operator <=( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(TRUE);
}
inline  CSeqNum::operator >=( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(TRUE);
}
inline  CSeqNum::operator <( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(FALSE);
}
inline  CSeqNum::operator >( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(FALSE);
}
inline void CSeqNum::SetSmallestValue()
{
    m_SeqNum = MQIS_SMALLEST_SEQNUM;
}
inline const unsigned char *  CSeqNum::GetPtr() const
{
    return( m_SeqNum.c);
}

inline BOOL CSeqNum::IsInfiniteLsn() const
{
     return( !memcmp(&m_SeqNum,&MQIS_INFINITE_LSN, sizeof(_SEQNUM)));
}

inline void CSeqNum::SetInfiniteLSN()
{
    m_SeqNum = MQIS_INFINITE_LSN;
}
inline void CSeqNum::GetValue(BLOB * pblob) const
{
    pblob->cbSize = sizeof(_SEQNUM);
    pblob->pBlobData = (unsigned char *)&m_SeqNum.c[0];
}  
inline void CSeqNum::GetValueForPrint(OUT WCHAR * pBuffer) const 
{
	swprintf(pBuffer,L"%02x%02x%02x%02x%02x%02x%02x%02x",m_SeqNum.c[0],m_SeqNum.c[1],m_SeqNum.c[2],m_SeqNum.c[3],m_SeqNum.c[4],m_SeqNum.c[5],m_SeqNum.c[6],m_SeqNum.c[7]);
}
inline BOOL CSeqNum::IsSmallerByMoreThanOne( const CSeqNum & sn) const
{
    
    CSeqNum tmp( (_SEQNUM *)&m_SeqNum);
    tmp.Increment();
    return( tmp < sn);


}

inline	BOOL CSeqNum::NotGreaterByMoreThanFrom(DWORD diff, const CSeqNum &other) const
{
    CSeqNum tmpThis( (_SEQNUM *)&m_SeqNum);
	tmpThis -= diff;
	return(tmpThis < other);
}

inline CSeqNum & CSeqNum::operator = ( const CSeqNum & sn)
{
    m_SeqNum = sn.m_SeqNum;
    return(*this);
}

inline DWORD CSeqNum::GetHighDWORD() const
{
	return GetDWORD(0);
}

inline DWORD CSeqNum::GetLowDWORD() const
{
	return GetDWORD(4);
}

inline void CSeqNum::SetHighDWORD(IN DWORD dw)
{
	SetDWORD(0,dw);
}

inline void CSeqNum::SetLowDWORD(IN DWORD dw)
{
	SetDWORD(4,dw);
}

inline DWORD CSeqNum::GetDWORD(IN int offset) const
{
	unsigned char ac[4];
	int i,j;
	ASSERT(offset == 0 || offset == 4);
	for (i=0, j=offset+3; i< 4; i++,j--)
		ac[i] = m_SeqNum.c[j];
	return(*(DWORD *) ac);
}

inline void CSeqNum::SetDWORD(IN int offset, IN DWORD dw)
{
	ASSERT(offset == 0 || offset == 4);

	unsigned char * pc = (unsigned char *) &dw;
	int i,j;
	for (i=0,j=offset+3; i< 4; i++,j--)
		m_SeqNum.c[j] = pc[i];
}

inline BOOL CSeqNum::IsMultipleOf(IN DWORD dwFrequency) const
{
	return ((GetLowDWORD() % dwFrequency) == 0);
}

inline void CSeqNum::operator -= (DWORD dwSub)
{
	DWORD dwLow  = GetLowDWORD();

	if (dwSub <= dwLow)
	{
		dwLow -= dwSub;
	}
	else
	{
		DWORD dwHigh = GetHighDWORD();
		if (dwHigh > 0)
		{
			dwHigh--;
			dwLow -= dwSub;
		}
		else
		{
			dwHigh = dwLow = 0;
		}
		SetHighDWORD(dwHigh);
	}
	SetLowDWORD(dwLow);
}

inline void CSeqNum::operator += (DWORD dwAdd)
{
	DWORD dwLow  = GetLowDWORD();

	BOOL over = (dwLow + dwAdd < dwLow);

	dwLow += dwAdd;

	if (over)
	{
		DWORD dwHigh = GetHighDWORD();
		dwHigh++;

		if (dwHigh==0)
		{
			dwHigh=dwLow=0xffffffff;
		}

		SetHighDWORD(dwHigh);
	}

	SetLowDWORD(dwLow);
}

   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\seccom.h ===
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) 1991-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _SECURECOM_ERROR_
#define _SECURECOM_ERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
//  Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE                  _HRESULT_TYPEDEF_(0x800B0005L)

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
//  Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE                  _HRESULT_TYPEDEF_(0x800B0006L)

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
//  Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY           _HRESULT_TYPEDEF_(0x800B0007L)

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
//  Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO                  _HRESULT_TYPEDEF_(0x800B0008L)

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
//  The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE           _HRESULT_TYPEDEF_(0x800B0009L)

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
//  The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE         _HRESULT_TYPEDEF_(0x800B000AL)

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
//  This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING          _HRESULT_TYPEDEF_(0x800B000BL)

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE              _HRESULT_TYPEDEF_(0x800B0100L)

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period.
//
#define CERT_E_EXPIRED                   _HRESULT_TYPEDEF_(0x800B0101L)

//
// MessageId: CERT_E_VALIDIYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDIYPERIODNESTING      _HRESULT_TYPEDEF_(0x800B0102L)

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE                      _HRESULT_TYPEDEF_(0x800B0103L)

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST              _HRESULT_TYPEDEF_(0x800B0104L)

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  An extension of unknown type that is labeled 'critical' is present in a certificate.
//
#define CERT_E_CRITICAL                  _HRESULT_TYPEDEF_(0x800B0105L)

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate is being used for a purpose other than that for which it is permitted.
//
#define CERT_E_PURPOSE                   _HRESULT_TYPEDEF_(0x800B0106L)

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING            _HRESULT_TYPEDEF_(0x800B0107L)

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED                 _HRESULT_TYPEDEF_(0x800B0108L)

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certification chain processed correctly, but terminated in a root certificate which isn't trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT             _HRESULT_TYPEDEF_(0x800B0109L)

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A chain of certs didn't chain as they should in a certain application of chaining.
//
#define CERT_E_CHAINING                  _HRESULT_TYPEDEF_(0x800B010AL)

#endif // _SECURECOM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\verstamp.h ===
#include <windows.h>
#include <ntverp.h>
#include "version.h"

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#define VER_PRODUCTBUILD rup
#define VER_FILESUBTYPE VFT2_UNKNOWN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqbegin.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    _mqbegin.h

Abstract:

    Head of Falcon SDK file mq.h

Author:

    Erez Haba (erezh) 24-Jan-96

--*/

// begin_mq_h
/*++

Copyright (c) 1996-2001, Microsoft Corporation

Module Name:

    mq.h

Abstract:

    Master include file for Message Queuing applications

--*/

#ifndef __MQ_H__
#define __MQ_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif


#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif  // __ITransaction_FWD_DEFINED__

// end_mq_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\xactdefs.h ===
// We don't want include transaction files here; so redefining what we need
// BUGBUG: not too good - better to use the same definitions
#ifndef __transact_h__
#ifndef __xactdefs_h__
#define __xactdefs_h__
typedef struct  BOID
    {
    unsigned char rgb[ 16 ];
    }   BOID;

typedef BOID XACTUOW;
#endif
#endif

//class CTransaction;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _mqdef.h

Abstract:

    TEMPORARY DEFINITION FILE

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __TEMP_MQDEF_H
#define __TEMP_MQDEF_H

// begin_mq_h

typedef HANDLE QUEUEHANDLE;

typedef PROPID MSGPROPID;
typedef struct tagMQMSGPROPS
{
    DWORD           cProp;
    MSGPROPID*      aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQMSGPROPS;


typedef PROPID QUEUEPROPID;
typedef struct tagMQQUEUEPROPS
{
    DWORD           cProp;
    QUEUEPROPID*    aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQUEUEPROPS;


typedef PROPID QMPROPID;
typedef struct tagMQQMPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQMPROPS;


typedef struct tagMQPRIVATEPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQPRIVATEPROPS;


typedef PROPID MGMTPROPID;
typedef struct tagMQMGMTPROPS
{
    DWORD cProp;
    MGMTPROPID* aPropID;
    MQPROPVARIANT* aPropVar;
    HRESULT* aStatus;
} MQMGMTPROPS;

typedef struct tagSEQUENCE_INFO
{
    LONGLONG SeqID;
    ULONG SeqNo; 
    ULONG PrevNo;
} SEQUENCE_INFO;

    

// end_mq_h

#include <_mqreg.h>
#include <_ta.h>

#endif // __TEMP_MQDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_guid.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _guid.h

Abstract:

    Definition of a guid class 

Author:

    Ronit Hartmann (ronith) ??-???-??

--*/
#ifndef __GUID_H
#define __GUID_H
#include <fntoken.h>

//
// Note: not all files that include this file include the definition
// for underlying HashKey template - thus we need to declare it here
//
template<typename ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key);

//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID, const GUID&, ...>
//
//  This is the *only* instance to use. don't define your own.
//  we has as manny as 4 different flavors. erezh
//
template<>
inline UINT AFXAPI HashKey(const GUID& rGuid)
{
    //
    //  Data1 is the most changing member of a uuid.
    //  this is the fastest and the safest of all other
    //  method of hassing a guid.
    //
    return rGuid.Data1;
}


//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID*, GUID*, ...>
//
//  This is the *only* instance to use. don't define your own.
//  we has as manny as 4 different flavors. erezh
//
template<>
inline UINT AFXAPI HashKey(GUID* pGuid)
{
    //
    //  Data1 is the most changing member of a uuid.
    //  this is the fastest and the safest of all other
    //  method of hassing a guid.
    //
    return pGuid->Data1;
}

//
// Note: not all files that include this file include the definition
// for underlying CompareElements template - thus we need to declare it here
//
template<typename TYPE, typename ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE *pElement1, const ARG_TYPE *pElement2);


//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID*, GUID*, ...>
//
#if _MSC_VER > 1300
template<>
#endif
inline BOOL AFXAPI CompareElements(GUID* const* key1, GUID* const* key2)
{
    return (**key1 == **key2);
}

//---------------------------------------------------------
//
//  Convert guid into a pre-allocatd buffer
//
typedef WCHAR GUID_STRING[GUID_STR_LENGTH + 1];

inline
void
MQpGuidToString(
    const GUID* pGuid,
    GUID_STRING& wcsGuid
    )
{
    _snwprintf(
        wcsGuid,
        GUID_STR_LENGTH + 1,
        GUID_FORMAT,             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(pGuid)
        );

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqend.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    _mqend.h

Abstract:

    Tail of Falcon SDK file mq.h

Author:

    Erez Haba (erezh) 24-Jan-96

--*/

// begin_mq_h

#endif // __MQ_H__

// end_mq_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqini.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _mqini.h

Abstract:

    Definitions of parameters that can be read from ini file.
    Definitions of default values.
    General definitions shared among setup and QM (YoelA, 10-Feb-97)

Author:

    Doron Juster  (DoronJ)   14-May-96  Created

--*/

#ifndef __TEMP_MQINI_H
#define __TEMP_MQINI_H

#define MSMQ_PROGRESS_REPORT_TIME_DEFAULT 900000
#define MSMQ_PROGRESS_REPORT_TIME_REGNAME TEXT("ProgressReportTime")


//---------------------------------------------------------
//  Definition for client configuration
//---------------------------------------------------------

// Registry name for remote QM machine name
#define RPC_REMOTE_QM_REGNAME     TEXT("RemoteQMMachine")

//---------------------------------------------------------
//  Definition of RPC end points
//---------------------------------------------------------

//
// If this registry does not exist (default) or it's 0 then use dynamic
// endpoints. Otherwise, use predefined ones, from registry.
// This is for MQIS interfaces.
//
#define RPC_DEFAULT_PREDEFINE_DS_EP     0
#define RPC_PREDEFINE_DS_EP_REGNAME     TEXT("UseDSPredefinedEP")

//Default local  RPC End Point between RT and QM
#define RPC_LOCAL_EP             TEXT("QMsvc")
#define RPC_LOCAL_EP_REGNAME     TEXT("RpcLocalEp")

#define RPC_LOCAL_EP2            TEXT("QMsvc2")
#define RPC_LOCAL_EP_REGNAME2    TEXT("RpcLocalEp2")

//  Default local RPC End Point between MQAD and QM
#define DEFAULT_NOTIFY_EP           TEXT("QMNotify")

// default for RPC IP port (for DS)
#define FALCON_DEFAULT_DS_RPC_IP_PORT   TEXT("2879")
#define FALCON_DS_RPC_IP_PORT_REGNAME   TEXT("MsmqDSRpcIpPort")

// default for IPX port for RPC (for DS)
#define FALCON_DEFAULT_DS_RPC_IPX_PORT  TEXT("2879")
#define FALCON_DS_RPC_IPX_PORT_REGNAME  TEXT("MsmqDSRpcIpxPort")

//+--------------------------------------------------------
//
// Definitions for RPC keep alive.
//
//+--------------------------------------------------------

//
// time before sending first keep alive packet.
// unit- seconds. Default- 5 minutes.
//
#define  MSMQ_DEFAULT_KEEPALIVE_TIME_TO_FIRST   (300)
#define  MSMQ_KEEPALIVE_TIME_TO_FIRST_REGNAME   TEXT("KeepAliveTimeToFirst")

//
// Internal between keep alive packets.
// unit- seconds. Default- 5 minutes.
//
#define  MSMQ_DEFAULT_KEEPALIVE_INTERVAL        (5)
#define  MSMQ_KEEPALIVE_INTERVAL_REGNAME        TEXT("KeepAliveInterval")

//---------------------------------------------------------
//  Definition of winsock ports
//---------------------------------------------------------

// default IP port for Falcon sessions.
#define FALCON_DEFAULT_IP_PORT   1801
#define FALCON_IP_PORT_REGNAME   TEXT("MsmqIpPort")

// default IP port for ping.
#define FALCON_DEFAULT_PING_IP_PORT   3527
#define FALCON_PING_IP_PORT_REGNAME   TEXT("MsmqIpPingPort")


// Default for ack timeout
#define MSMQ_DEFAULT_ACKTIMEOUT  5000
#define MSMQ_ACKTIMEOUT_REGNAME  TEXT("AckTimeout")

// Default for Storage ack timeout
#define MSMQ_DEFAULT_STORE_ACKTIMEOUT  500
#define MSMQ_STORE_ACKTIMEOUT_REGNAME  TEXT("StoreAckTimeout")

// Default for Idle acknowledge delay (in milisecond)
#define MSMQ_DEFAULT_IDLE_ACK_DELAY 500
#define MSMQ_IDLE_ACK_DELAY_REGNAME  TEXT("IdleAckDelay")

// Default size for remove duplicate tabel
#define MSMQ_DEFAULT_REMOVE_DUPLICATE_SIZE 10000
#define MSMQ_REMOVE_DUPLICATE_SIZE_REGNAME  TEXT("RemoveDuplicateSize")

// Default interval for remove duplicate tabel cleanup
#define MSMQ_DEFAULT_REMOVE_DUPLICATE_CLEANUP (30 * 60 * 1000)
#define MSMQ_REMOVE_DUPLICATE_CLEANUP_REGNAME  TEXT("RemoveDuplicateCleanup")


// Default for Max Unacked Packet
#ifdef _DEBUG
#define MSMQ_DEFAULT_WINDOW_SIZE_PACKET  32
#else
#define MSMQ_DEFAULT_WINDOW_SIZE_PACKET  64
#endif
#define MSMQ_MAX_WINDOW_SIZE_REGNAME  TEXT("MaxUnackedPacket")

//Default for MAX mapped files (used during recovery for performance reasons)
#define MSMQ_DEFAULT_MAPPED_LIMIT    8
#define MSMQ_MAPPED_LIMIT_REGNAME  TEXT("MaxMappedFiles")


// Default for Cleanup interval
#define MSMQ_DEFAULT_SERVER_CLEANUP    120000
#define MSMQ_DEFAULT_CLIENT_CLEANUP    300000

// QoS session should be cleaned up less frequently than
// regular sessions, because it takes more time to
// establish a QoS session.
// By default, QoS sessions cleanup time is twice as large as
// the regular cleanup time
#define MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER 2

#define MSMQ_CLEANUP_INTERVAL_REGNAME  TEXT("CleanupInterval")
#define MSMQ_QOS_CLEANUP_INTERVAL_MULTIPLIER_REGNAME  TEXT("QosCleanupIntervalMultiplier")

#define MSMQ_DEFAULT_MESSAGE_CLEANUP    (6 * 60 * 60 * 1000)
#define MSMQ_MESSAGE_CLEANUP_INTERVAL_REGNAME  TEXT("MessageCleanupInterval")

//
// Default time interval for refreshing the DS servers list
//
// Default time interval for refreshing the DS current site servers list and Longlive time (in hours - 7 days)
#define MSMQ_DEFAULT_DS_SITE_LIST_REFRESH  (7 * 24)
#define MSMQ_DS_SITE_LIST_REFRESH_REGNAME  TEXT("DSSiteListRefresh")

// Default time interval for refreshing the DS enterprise data -  sites / servers list
// (in hours - 28 days)
#define MSMQ_DEFAULT_DS_ENTERPRISE_LIST_REFRESH  (28 * 24)
#define MSMQ_DS_ENTERPRISE_LIST_REFRESH_REGNAME  TEXT("DSEnterpriseListRefresh")

// Default time interval for refreshing the DS lists, in case the previous call failed
// (in Minutes - 1 hour)
#define MSMQ_DEFAULT_DSLIST_REFRESH_ERROR_RETRY_INTERVAL  60
#define MSMQ_DSLIST_REFRESH_ERROR_RETRY_INTERVAL          TEXT("DSListRefreshErrorRetryInterval")

//
// Next Site and enterprise refresh times
// This values are quad word and set by the QM (should not be set manually)
// However, deleting these values from the registry will cause Site / Enterprise
// refresh on the next QM startup (YoelA - 23-Oct-2000)
//
#define MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME        TEXT("DSNextSiteListRefreshTime")
#define MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME  TEXT("DSNextEnterpriseListRefreshTime")

// Default time interval for updating the DS (5 minutes)
#define MSMQ_DEFAULT_DSUPDATE_INTERVAL  (5 * 60 * 1000)
#define MSMQ_DSUPDATE_INTERVAL_REGNAME  TEXT("DSUpdateInterval")

// Default time interval for updating the sites information in the DS (12 hours)
#define MSMQ_DEFAULT_SITES_UPDATE_INTERVAL  (12 * 60 * 60 * 1000)
#define MSMQ_SITES_UPDATE_INTERVAL_REGNAME  TEXT("SitesUpdateInterval")

// Minimum interval between successive ADS searches to find DS servers (in seconds) (30 minutes)
#define MSMQ_DEFAULT_DSCLI_ADSSEARCH_INTERVAL  (60 * 30)
#define MSMQ_DSCLI_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSCliSearchAdsForServersIntervalSecs")

// Minimum interval between successive ADS searches to refresh IPSITE mapping (in seconds) (60 minutes)
#define MSMQ_DEFAULT_IPSITE_ADSSEARCH_INTERVAL  (60 * 60)
#define MSMQ_IPSITE_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSAdsRefreshIPSitesIntervalSecs")

// For generating write requests
// Minimum interval between successive ADS searches to refresh NT4SITES mapping (in seconds) (6 hours)
#define MSMQ_DEFAULT_NT4SITES_ADSSEARCH_INTERVAL  (60 * 60 * 6)
#define MSMQ_NT4SITES_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSAdsRefreshNT4SitesIntervalSecs")

// Default driver and service name
#define MSMQ_DEFAULT_DRIVER      TEXT("MQAC")
#define MSMQ_DRIVER_REGNAME      TEXT("DriverName")
#define QM_DEFAULT_SERVICE_NAME  TEXT("MSMQ")

// Name of storage folders
#define MSMQ_STORE_RELIABLE_PATH_REGNAME        TEXT("StoreReliablePath")
#define MSMQ_STORE_PERSISTENT_PATH_REGNAME      TEXT("StorePersistentPath")
#define MSMQ_STORE_JOURNAL_PATH_REGNAME         TEXT("StoreJournalPath")
#define MSMQ_STORE_LOG_PATH_REGNAME             TEXT("StoreLogPath")


//name of the queue mapping folder
#define MSMQ_MAPPING_PATH_REGNAME   TEXT("QueuesAliasPath")


// Deafult size of memory mapped file
#define MSMQ_MESSAGE_SIZE_LIMIT_REGNAME         TEXT("MaxMessageSize")
#define MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT         (4 * 1024 * 1024)

// Next message ID to be used (low order 32 bit)
#define MSMQ_MESSAGE_ID_LOW_32_REGNAME                 TEXT("MessageID")

// Next message ID to be used (high order 32 bit)
#define MSMQ_MESSAGE_ID_HIGH_32_REGNAME                TEXT("MessageIdHigh32")

// Current SeqID value at the last restore time
#define MSMQ_LAST_SEQID_REGNAME                 TEXT("SeqIDAtLastRestore")

// Next SeqID to be used
#define MSMQ_SEQ_ID_REGNAME                 TEXT("SeqID")

//
// Name of DS servers.
//
// MQISServer is the list of MQIS servers in present site. This list is not
//      present when machine is in workgroup mode.
// CurrentMQISServer is an online MQIS server found by the msmq service.
//
// LkgMQISServer is the LastKnownGood list. this is used to fix 4723.
//
#define MSMQ_DEFAULT_DS_SERVER         TEXT("\\\\")
#define MSMQ_DS_SERVER_REGVALUE        TEXT("MQISServer")
#define MSMQ_DS_SERVER_REGNAME         TEXT("MachineCache\\MQISServer")
#define MSMQ_DS_CURRENT_SERVER_REGNAME \
                                   TEXT("MachineCache\\CurrentMQISServer")
#define MAX_REG_DSSERVER_LEN  1500
#define DS_SERVER_SEPERATOR_SIGN    ','

// Static DS server option
#define MSMQ_STATIC_DS_SERVER_REGNAME TEXT("MachineCache\\StaticMQISServer")

//
// When automatic search for msmq server on domain controller fail, or return
// no result, then this registry entry is read. If available, then this is
// the result of the "automatic" search. See ds\getmqds\getmqds.cpp.
//
#define MSMQ_FORCED_DS_SERVER_REGNAME TEXT("MachineCache\\ForcedDSServer")

// DS server per thread
#define MSMQ_THREAD_DS_SERVER_REGNAME TEXT("MachineCache\\PerThreadDSServer")
#define MSMQ_DEFAULT_THREAD_DS_SERVER   0

// Name of MQ service
#define MSMQ_MQS_REGNAME                TEXT("MachineCache\\MQS")
#define MSMQ_MQS_ROUTING_REGNAME        TEXT("MachineCache\\MQS_Routing")
#define MSMQ_MQS_DSSERVER_REGNAME       TEXT("MachineCache\\MQS_DsServer")
#define MSMQ_MQS_TSFD_REGNAME           TEXT("MachineCache\\MQS_TransparentSFD")

#define MSMQ_MQS_DEPCLINTS_REGNAME      TEXT("MachineCache\\MQS_DepClients")
#define MSMQ_DEAFULT_MQS_DEPCLIENTS		0

// Name of QM id
#define MSMQ_QMID_REGVALUE  TEXT("QMId")
#define MSMQ_QMID_REGNAME   TEXT("MachineCache\\QMId")

// Dependent client Supporting Server QM id
#define MSMQ_SUPPORT_SERVER_QMID_REGVALUE	TEXT("ServerQMId")
#define MSMQ_SUPPORT_SERVER_QMID_REGNAME	TEXT("MachineCache\\ServerQMId")

// Name of DS Security Cache
#define MSMQ_DS_SECURITY_CACHE_REGNAME TEXT("DsSecurityCache")

// Name of site id
#define MSMQ_SITEID_REGNAME     TEXT("MachineCache\\SiteId")
#define MSMQ_SITENAME_REGNAME   TEXT("MachineCache\\SiteName")

// Name of enterprise id
#define MSMQ_ENTERPRISEID_REGNAME   TEXT("MachineCache\\EnterpriseId")

// Name of MQIS master id
#define MSMQ_MQIS_MASTERID_REGNAME  TEXT("MachineCache\\MasterId")

// Name of key for servers cache.
#define MSMQ_SERVERS_CACHE_REGNAME  TEXT("ServersCache")

// machine quota
#define MSMQ_MACHINE_QUOTA_REGNAME TEXT("MachineCache\\MachineQuota")

// Machine journal quota
#define MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME TEXT("MachineCache\\MachineJournalQuota")

// Name & Default for transaction crash point
#define FALCON_DEFAULT_CRASH_POINT    0
#define FALCON_CRASH_POINT_REGNAME    TEXT("XactCrashPoint")

// Name & Default for transaction crash latency
#define FALCON_DEFAULT_CRASH_LATENCY  0
#define FALCON_CRASH_LATENCY_REGNAME  TEXT("XactCrashLatency")

// Name for transaction exit failure probability
#define FALCON_XACT_EXIT_PROBABILITY_REGNAME  TEXT("XactExitProbability")

// Name for transaction hr calls failure probability
#define FALCON_XACT_FAILURE_PROBABILITY_REGNAME  TEXT("XactFailureProbability")

// Name & Default for transaction Commit/Abort internal retry
#define FALCON_DEFAULT_XACT_RETRY_INTERVAL   1500
#define FALCON_XACT_RETRY_REGNAME             TEXT("XactAbortCommitRetryInterval")

// Name & Default for transaction v1 Compatibility Mode
#define FALCON_DEFAULT_XACT_V1_COMPATIBLE   0
#define FALCON_XACT_V1_COMPATIBLE_REGNAME   TEXT("XactDeadLetterAlways")

// Name for the delay of local receive expiration for transacted messages
#define FALCON_XACT_DELAY_LOCAL_EXPIRE_REGNAME  TEXT("XactDelayReceiveNack")

// Default for sequential acks resend time
#define FALCON_DEFAULT_SEQ_ACK_RESEND_TIME  60
#define FALCON_SEQ_ACK_RESEND_REGNAME  TEXT("SeqAckResendTime")

// Default for ordered resend times: 1-3, 4-6, 7-9, all further
#define FALCON_DEFAULT_ORDERED_RESEND13_TIME  30
#define FALCON_ORDERED_RESEND13_REGNAME  TEXT("SeqResend13Time")

#define FALCON_DEFAULT_ORDERED_RESEND46_TIME  (5 * 60)
#define FALCON_ORDERED_RESEND46_REGNAME  TEXT("SeqResend46Time")

#define FALCON_DEFAULT_ORDERED_RESEND79_TIME  (30 * 60)
#define FALCON_ORDERED_RESEND79_REGNAME  TEXT("SeqResend79Time")

#define FALCON_DEFAULT_ORDERED_RESEND10_TIME  (6 * 60 * 60)
#define FALCON_ORDERED_RESEND10_REGNAME  TEXT("SeqResend10Time")

// Debugging lever: all resend times the same
#define FALCON_DBG_RESEND_REGNAME       TEXT("XactResendTime")

// Max delay for sending ordering ack
#define FALCON_MAX_SEQ_ACK_DELAY                10
#define FALCON_MAX_SEQ_ACK_DELAY_REGNAME  TEXT("SeqMaxAckDelay")

// Interval(minutes) for QM to check for inactive sequences and delete them
#define FALCON_DEFAULT_INSEQS_CHECK_INTERVAL    60 * 24
#define FALCON_INSEQS_CHECK_REGNAME             TEXT("InSeqCheckInterval")

// Interval(days) for QM to clean away inactive sequences
#define FALCON_DEFAULT_INSEQS_CLEANUP_INTERVAL  90
#define FALCON_INSEQS_CLEANUP_REGNAME           TEXT("InSeqCleanupInterval")

// Interval(msec) for log manager to check if the flush/chkpoint is needed
#define FALCON_DEFAULT_LOGMGR_TIMERINTERVAL     5
#define FALCON_LOGMGR_TIMERINTERVAL_REGNAME     TEXT("LogMgrTimerInterval")

// Max interval (msec) for log manager flushes (if there was no other reason to do it before)
#define FALCON_DEFAULT_LOGMGR_FLUSHINTERVAL     5
#define FALCON_LOGMGR_FLUSHINTERVAL_REGNAME     TEXT("LogMgrFlushInterval")

// Max interval (msec) for log manager internal checkpoints (if there was no other reason to do it before)
#define FALCON_DEFAULT_LOGMGR_CHKPTINTERVAL     10000
#define FALCON_LOGMGR_CHKPTINTERVAL_REGNAME     TEXT("LogMgrChkptInterval")

// Log manager buffers number
#define FALCON_DEFAULT_LOGMGR_BUFFERS           400
#define FALCON_LOGMGR_BUFFERS_REGNAME           TEXT("LogMgrBuffers")

// Log manager file size
#define FALCON_DEFAULT_LOGMGR_SIZE              0x600000
#define FALCON_LOGMGR_SIZE_REGNAME              TEXT("LogMgrFileSize")

// Log manager sleep time if not enough append asynch threads
#define FALCON_DEFAULT_LOGMGR_SLEEP_ASYNCH      500
#define FALCON_LOGMGR_SLEEP_ASYNCH_REGNAME      TEXT("LogMgrSleepAsynch")

// Log manager append asynch repeat limit
#define FALCON_DEFAULT_LOGMGR_REPEAT_ASYNCH     100
#define FALCON_LOGMGR_REPEAT_ASYNCH_REGNAME     TEXT("LogMgrRepeatAsynchLimit")

// Falcon interval (msec) for probing log manager flush
#define FALCON_DEFAULT_LOGMGR_PROBE_INTERVAL    100
#define FALCON_LOGMGR_PROBE_INTERVAL_REGNAME    TEXT("LogMgrProbeInterval")

// Resource manager checkpoints period (msec)
#define FALCON_DEFAULT_RM_FLUSH_INTERVAL        1800000
#define FALCON_RM_FLUSH_INTERVAL_REGNAME        TEXT("RMFlushInterval")

// Resource manager client name
#define FALCON_DEFAULT_RM_CLIENT_NAME           TEXT("Falcon")
#define FALCON_RM_CLIENT_NAME_REGNAME           TEXT("RMClientName")

// RT stub RM name
#define FALCON_DEFAULT_STUB_RM_NAME             TEXT("StubRM")
#define FALCON_RM_STUB_NAME_REGNAME             TEXT("RMStubName")

// Transactions persistant file location
#define FALCON_DEFAULT_XACTFILE_PATH            TEXT("MQTrans")
#define FALCON_XACTFILE_PATH_REGNAME            TEXT("StoreXactLogPath")
#define FALCON_XACTFILE_REFER_NAME              TEXT("Transactions")

// Incoming sequences persistant file location
#define FALCON_DEFAULT_INSEQFILE_PATH           TEXT("MQInSeqs")
#define FALCON_INSEQFILE_PATH_REGNAME           TEXT("StoreInSeqLogPath")
#define FALCON_INSEQFILE_REFER_NAME             TEXT("Incoming Sequences")

// Outgoming sequences persistant file location
#define FALCON_DEFAULT_OUTSEQFILE_PATH          TEXT("MQOutSeqs")
#define FALCON_OUTSEQFILE_PATH_REGNAME          TEXT("StoreOutSeqLogPath")
#define FALCON_OUTSEQFILE_REFER_NAME            TEXT("Outgoing Sequences")

// Logger file
#define FALCON_DEFAULT_LOGMGR_PATH              TEXT("QMLog")
#define FALCON_LOGMGR_PATH_REGNAME              TEXT("StoreMqLogPath")

// Logger data are created
#define FALCON_LOGDATA_CREATED_REGNAME          TEXT("LogDataCreated")

// Default for TIME_TO_REACH_QUEUE (4 days, in seconds; XP client cand earlier used to be 90 days).
#define MSMQ_LONG_LIVE_REGNAME        TEXT("MachineCache\\LongLiveTime")
#define MSMQ_DEFAULT_LONG_LIVE       (4 * 24 * 60 * 60)

// Expiration time of entries in the base crypto key cache.
#define CRYPT_KEY_CACHE_DEFAULT_EXPIRATION_TIME (60000 * 10) // 10 minutes.
#define CRYPT_KEY_CACHE_EXPIRATION_TIME_REG_NAME TEXT("CryptKeyExpirationTime")

// Expiration time of entries in the enhanced crypto key cache.
#define CRYPT_KEY_ENH_CACHE_DEFAULT_EXPIRATION_TIME		(60000 * 60 * 12) // 12 hours.
#define CRYPT_KEY_ENH_CACHE_EXPIRATION_TIME_REG_NAME	TEXT("CryptKeyEnhExpirationTime")

// Cache size for send crypto keys.
#define CRYPT_SEND_KEY_CACHE_DEFAULT_SIZE       53
#define CRYPT_SEND_KEY_CACHE_REG_NAME           TEXT("CryptSendKeyCacheSize")

// Cache size for receive crypto keys.
#define CRYPT_RECEIVE_KEY_CACHE_DEFAULT_SIZE    127
#define CRYPT_RECEIVE_KEY_CACHE_REG_NAME        TEXT("CryptReceiveKeyCacheSize")

// Certificate info cache.
#define CERT_INFO_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 20) // 20 minutes.
#define CERT_INFO_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("CertInfoCacheExpirationTime")
#define CERT_INFO_CACHE_DEFAULT_SIZE            53
#define CERT_INFO_CACHE_SIZE_REG_NAME           TEXT("CertInfoCacheSize")

// QM public key cache.
#define QM_PB_KEY_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 45) // 45 minutes.
#define QM_PB_KEY_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("QmPbKeyCacheExpirationTime")
#define QM_PB_KEY_CACHE_DEFAULT_SIZE            53
#define QM_PB_KEY_CACHE_SIZE_REG_NAME           TEXT("QmPbKeyCacheSize")

// User authz context info cache.
#define USER_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 30) // 30 minutes.
#define USER_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("UserCacheExpirationTime")
#define USER_CACHE_SIZE_DEFAULT_SIZE            253
#define USER_CACHE_SIZE_REG_NAME                TEXT("UserCacheSize")

// Key indicating operation in lockdown mode
#define MSMQ_LOCKDOWN_DEFAULT       0
#define MSMQ_LOCKDOWN_REGNAME	TEXT("Hardened_MSMQ")

// Key indicating if the service will create public queues in the AD on behalf of local users
#define MSMQ_SERVICE_QUEUE_CREATION_DEFAULT		1
#define MSMQ_SERVICE_QUEUE_CREATION_REGNAME		TEXT("EnableCreateQueueThroughService")

//---------------------------------------------------------
// Definition for private system queues
//---------------------------------------------------------

#define MSMQ_MAX_PRIV_SYSQUEUE_REGNAME   TEXT("MaxSysQueue")
#define MSMQ_PRIV_SYSQUEUE_PRIO_REGNAME  TEXT("SysQueuePriority")
//
// the default for private system queue priority is defined in
// mqprops.h:
// #define DEFAULT_SYS_Q_BASEPRIORITY  0x7fff
//

//---------------------------------------------------------
//  Wolfpack support
//---------------------------------------------------------

// cluster name
#define FALCON_CLUSTER_NAME_REGNAME  TEXT("ClusterName")

//
// This registry is to choose the income binging address
// in cluster
//
#define MSMQ_BIND_INTERFACE_IP_STR			TEXT("BindInterfaceIP")



//---------------------------------------------------------
//  Definition for remote read.
//---------------------------------------------------------

// Deny old remote read interface
#define MSMQ_DENY_OLD_REMOTE_READ_REGNAME	TEXT("Security\\DenyOldRemoteRead")
#define MSMQ_DENY_OLD_REMOTE_READ_REGVALUE	TEXT("DenyOldRemoteRead")
#define MSMQ_DENY_OLD_REMOTE_READ_DEFAULT       0

// New remote read interface: Server Deny workgroup clients
#define MSMQ_NEW_REMOTE_READ_SERVER_DENY_WORKGROUP_CLIENT_REGNAME	TEXT("Security\\NewRemoteReadServerDenyWorkgroupClient")
#define MSMQ_NEW_REMOTE_READ_SERVER_DENY_WORKGROUP_CLIENT_REGVALUE	TEXT("NewRemoteReadServerDenyWorkgroupClient")
#define MSMQ_NEW_REMOTE_READ_SERVER_DENY_WORKGROUP_CLIENT_DEFAULT       0

// New remote read interface: Server Allow None Security clients
#define MSMQ_NEW_REMOTE_READ_SERVER_ALLOW_NONE_SECURITY_CLIENT_REGNAME		TEXT("Security\\NewRemoteReadServerAllowNoneSecurityClient")
#define MSMQ_NEW_REMOTE_READ_SERVER_ALLOW_NONE_SECURITY_CLIENT_REGVALUE		TEXT("NewRemoteReadServerAllowNoneSecurityClient")
#define MSMQ_NEW_REMOTE_READ_SERVER_ALLOW_NONE_SECURITY_CLIENT_DEFAULT       0

// New remote read interface: client Deny workgroup server
#define MSMQ_NEW_REMOTE_READ_CLIENT_DENY_WORKGROUP_SERVER_REGNAME	TEXT("Security\\NewRemoteReadClientDenyWorkgroupServer")
#define MSMQ_NEW_REMOTE_READ_CLIENT_DENY_WORKGROUP_SERVER_REGVALUE	TEXT("NewRemoteReadClientDenyWorkgroupServer")
#define MSMQ_NEW_REMOTE_READ_CLIENT_DENY_WORKGROUP_SERVER_DEFAULT       0

//---------------------------------------------------------
//  Definition for licensing
//---------------------------------------------------------

// maximum number of connections per server (limitted server on NTS).
#define DEFAULT_FALCON_SERVER_MAX_CLIENTS  25

// number of allowed sessions for clients.
#define DEFAULT_FALCON_MAX_SESSIONS_WKS    10

//----------------------------------------------------------
//  Definition for RPC cancel
//----------------------------------------------------------

#define FALCON_DEFAULT_RPC_CANCEL_TIMEOUT       ( 5 )	// 5 minutes
#define FALCON_RPC_CANCEL_TIMEOUT_REGNAME       TEXT("RpcCancelTimeout")

//----------------------------------------------------------
//  General definitions shared among setup and QM
//----------------------------------------------------------

// Registry name for MSMQ root folder
#define MSMQ_ROOT_PATH                  TEXT("MsmqRootPath")

#define MQ_SETUP_CN GUID_NULL

// Registry name for sysprep environment (NT disk image duplication)
#define MSMQ_SYSPREP_REGNAME            TEXT("Sysprep")

// Registry name for workgroup environment
#define MSMQ_WORKGROUP_REGNAME          TEXT("Workgroup")

// Registry name for allowing NT4 users to connect to DC
#define MSMQ_ALLOW_NT4_USERS_REGNAME	TEXT("AllowNt4Users")

// Registry name for disabling weaken security
#define MSMQ_DISABLE_WEAKEN_SECURITY_REGNAME	TEXT("DisableWeakenSecurity")

// Registry for converting packet sequential id to msmq 3.0 (whistler) format
#define MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME  TEXT("PacketSequentialIdMsmq3Format")

// Registry for checking if QM GUID was changed
#define MSMQ_QM_GUID_CHANGED_REGNAME  TEXT("QMGuidChanged")

// Registry for installation status
#define MSMQ_SETUP_STATUS_REGNAME       TEXT("SetupStatus")
#define MSMQ_SETUP_DONE                 0
#define MSMQ_SETUP_FRESH_INSTALL        1
#define MSMQ_SETUP_UPGRADE_FROM_NT      2
#define MSMQ_SETUP_UPGRADE_FROM_WIN9X   3

#define MSMQ_CURRENT_BUILD_REGNAME      TEXT("CurrentBuild")
#define MSMQ_PREVIOUS_BUILD_REGNAME     TEXT("PreviousBuild")

//
// The following registry values are used by setup to cache values that
// are later used by the msmq service when it create the msmqConfiguration
// object.
//
// Registry name for creating msmqConfiguration object
#define MSMQ_CREATE_CONFIG_OBJ_REGNAME  TEXT("setup\\CreateMsmqObj")

// Registry name for OS type.
#define MSMQ_OS_TYPE_REGNAME            TEXT("setup\\OSType")

// Registry name for SID of user that run setup
#define MSMQ_SETUP_USER_SID_REGNAME      TEXT("setup\\UserSid")
//
// if setup from local user, then following REG_DWORD registry
// has the value 1.
//
#define MSMQ_SETUP_USER_LOCAL_REGNAME    TEXT("setup\\LocalUser")

//
// This dword indicate whether or not upgrade of BSC was complete. This
// upgrade is done by the msmq service. When starting, this dword is set
// to 1. When completing, it's set to 0. So if machine crash in middle of
// upgrade, we can resume after boot.
//
#define MSMQ_BSC_NOT_YET_UPGRADED_REGNAME  TEXT("setup\\BscNotYetUpgraded")
#define MSMQ_SETUP_BSC_ALREADY_UPGRADED    0
#define MSMQ_SETUP_BSC_NOT_YET_UPGRADED    1

//
// Hresult of creating the msmq configuration object.
// This key should contain only one value, because the setup UI wait until
// this value is modified.
//
#define MSMQ_CONFIG_OBJ_RESULT_KEYNAME   TEXT("setupResult")
#define MSMQ_CONFIG_OBJ_RESULT_REGNAME   TEXT("setupResult\\MsmqObjResult")


//----------------------------------------------------------
//  General directory definitions shared among setup and QM
//----------------------------------------------------------
#define  DIR_MSMQ                TEXT("\\msmq")             // Root dir for MSMQ
#define  DIR_MSMQ_STORAGE        TEXT("\\storage")		    // Under MSMQ root
#define  DIR_MSMQ_LQS            TEXT("\\storage\\lqs")     // Under MSMQ root
#define  DIR_MSMQ_MAPPING        TEXT("\\mapping")          // Under MSMQ root

#define  MAPPING_FILE			 TEXT("sample_map.xml")		// Sample mapping file name
#define  OUTBOUNT_MAPPING_FILE	 TEXT("sample_outbound_map.xml")	// Sample outbound mapping file name
#define  STREAM_RECEIPT_FILE	 TEXT("StreamReceipt_map.xml")		// Sample stream receipt file name

//-------------------------------
//  Setup subcomponents registry
//-------------------------------
#define MSMQ                    TEXT("msmq")
#define MSMQ_CORE_SUBCOMP       TEXT("msmq_Core")
#define MQDSSERVICE_SUBCOMP     TEXT("msmq_MQDSService")
#define TRIGGERS_SUBCOMP        TEXT("msmq_TriggersService")
#define HTTP_SUPPORT_SUBCOMP    TEXT("msmq_HTTPSupport")
#define AD_INTEGRATED_SUBCOMP   TEXT("msmq_ADIntegrated")
#define ROUTING_SUBCOMP         TEXT("msmq_RoutingSupport")
#define LOCAL_STORAGE_SUBCOMP   TEXT("msmq_LocalStorage")


//----------------------------------------------------
//  Registry values used for join/leave domain
//----------------------------------------------------

// Registry name for machine's domain. Used for join/leave domain.
#define MSMQ_MACHINE_DOMAIN_REGNAME     TEXT("setup\\MachineDomain")

// Registry name for machine's distinguished name (in active directory).
// Used for join/leave domain.
#define MSMQ_MACHINE_DN_REGNAME         TEXT("setup\\MachineDN")

// Registry name for always remaining in workgroup.
#define MSMQ_SETUP_KEY              TEXT("setup\\")
#define ALWAYS_WITHOUT_DS_NAME      TEXT("AlwaysWithoutDS")
#define MSMQ_ALWAYS_WORKGROUP_REGNAME  \
      (MSMQ_SETUP_KEY ALWAYS_WITHOUT_DS_NAME)

//
// http subcomponent registry for upgrade purpose
// this registry indicates that msmq web directory location is under Inetpub directory
//
#define MSMQ_INETPUB_WEB_KEY_REGNAME   TEXT("InetpubWebDir")
#define MSMQ_INETPUB_WEB_DIR_REGNAME   (MSMQ_SETUP_KEY MSMQ_INETPUB_WEB_KEY_REGNAME)

#define DEFAULT_MSMQ_ALWAYS_WORKGROUP     0

// Registry name for join status. This is used to implement "transaction"
// semantic in the code that automatically join msmq to a domain.
#define MSMQ_JOIN_STATUS_REGNAME        TEXT("setup\\JoinStatus")
#define MSMQ_JOIN_STATUS_START_JOINING          1
#define MSMQ_JOIN_STATUS_JOINED_SUCCESSFULLY    2
#define MSMQ_JOIN_STATUS_FAIL_TO_JOIN           3
#define MSMQ_JOIN_STATUS_UNKNOWN                4

//------------------------------------------------------------------
// Registry name for Ds Environment
//------------------------------------------------------------------
#define MSMQ_DS_ENVIRONMENT_REGNAME				TEXT("DsEnvironment")
#define MSMQ_DS_ENVIRONMENT_UNKNOWN             0
#define MSMQ_DS_ENVIRONMENT_MQIS				1
#define MSMQ_DS_ENVIRONMENT_PURE_AD				2

//------------------------------------------------------------------
// Registry name for enabling local user (force the use of dscli)
//------------------------------------------------------------------
#define MSMQ_ENABLE_LOCAL_USER_REGNAME			TEXT("EnableLocalUser")

//------------------------------------------------------------------
// Registry name for disabling downlevel notification support
//------------------------------------------------------------------
#define MSMQ_DOWNLEVEL_REGNAME				TEXT("DisableDownlevelNotifications")
#define DEFAULT_DOWNLEVEL                   0


//---------------------------------------------------------
//  General definition for controling QM operation
//---------------------------------------------------------
#define FALCON_WAIT_TIMEOUT_REGNAME     TEXT("WaitTime")
#define FALCON_USING_PING_REGNAME       TEXT("UsePing")
#define FALCON_QM_THREAD_NO_REGNAME     TEXT("QMThreadNo")
#define FALCON_CONNECTED_NETWORK        TEXT("Connection State")
#define MSMQ_DEFERRED_INIT_REGNAME      TEXT("DeferredInit")
#define MSMQ_TCP_NODELAY_REGNAME        TEXT("TCPNoDelay")
#define MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE_REGNAME     TEXT("DeliveryRetryTimeOutScale")
#define DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE     1


//
//  Bug 8760
//  If this value is set to one, then ignore computer name validation
//  when receiving messages with direct=os and assume they are for local
//  computer. this mainly solves the problem of sending with direct=os
//  to nlb computers.
//
#define DEFAULT_MSMQ_IGNORE_OS_VALIDATION   0
#define MSMQ_IGNORE_OS_VALIDATION_REGNAME  TEXT("IgnoreOsNameValidation")

//---------------------------------------------------------
//  Registry used for QoS
//---------------------------------------------------------
#define MSMQ_USING_QOS_REGNAME             TEXT("UseQoS")
#define DEFAULT_MSMQ_QOS_SESSION_APP_NAME  "Microsoft Message Queuing"
#define MSMQ_QOS_SESSIONAPP_REGNAME        TEXT("QosSessAppName")

#define DEFAULT_MSMQ_QOS_POLICY_LOCATOR    "GUID=http://www.microsoft.com/App=MSMQ/VER=2.000/SAPP=Express"
#define MSMQ_QOS_POLICYLOCATOR_REGNAME     TEXT("QosSessPolicyLoc")


//
// QFE for Ford.
// Allocate more bytes when creating packet in driver, so packet is same
// when copied to connector. see session.cpp. Default- 0.
//
#define MSMQ_ALLOCATE_MORE_REGNAME      TEXT("AllocateMore")

//---------------------------------------------------------
//  Registry used for transaciton mode (default commit, default abort)
//---------------------------------------------------------
#define MSMQ_TRANSACTION_MODE_REGNAME   TEXT("TransactionMode")
#define MSMQ_ACTIVE_NODE_ID_REGNAME		TEXT("ActiveNodeId")

//---------------------------------------------------------
//
//  Registry used for server authentication.
//
//---------------------------------------------------------

// Use server authentication when communicating via RPC
// with the parent server (BSC->PSC, PSC->PEC)
#define DEFAULT_SRVAUTH_WITH_PARENT           1
#define SRVAUTH_WITH_PARENT_REG_NAME      TEXT("UseServerAuthWithParentDs")

//
// Crypto Store where server certificate is placed.
//
#define SRVAUTHN_STORE_NAME_REGNAME    TEXT("security\\ServerCertStore")
//
// Digest (16 bytes) of server certificate.
//
#define SRVAUTHN_CERT_DIGEST_REGNAME   TEXT("security\\ServerCertDigest")


//---------------------------------------------------------
//
//  Registry used for message authentication.
//
//---------------------------------------------------------

//
// DWORD.
// When 1, only messages with enhanced authentication are accepted.
// Messages with only msmq1.0 signature are rejected.
//
#define  DEFAULT_USE_ONLY_ENH_MSG_AUTHN  0
#define  USE_ONLY_ENH_MSG_AUTHN_REGNAME  TEXT("security\\RcvOnlyEnhMsgAuthn")

//
// DWORD.
// When 2, MQSend compute only the msmq1.0 signature, unless MSMQ20 was
// specified by caller.
// When 4, MQSend compute only the win2k signature, unless MSMQ10 was
// specified by caller.
// when 1, compute both signatures, unless caller specify what he wants.
// These values match those for PROPID_M_AUTH_LEVEL in mqprops.h
//
#define  DEFAULT_SEND_MSG_AUTHN   2
#define  SEND_MSG_AUTHN_REGNAME   TEXT("security\\SendMsgAuthn")

//---------------------------------------------------------
//
//  Registry used for client certificates.
//
//---------------------------------------------------------

//
// Enable (or disable) auto registration of internal certificate.
// Enabled by default.
//
#define AUTO_REGISTER_INTCERT_REGNAME  TEXT("security\\AutoRegisterIntCert")
#define DEFAULT_AUTO_REGISTER_INTCERT  1

//
// used for mqrt to tell what error was encountered while trying to
// register a certificate at logon.
//
#define AUTO_REGISTER_ERROR_REGNAME  TEXT("AutoRegisterError")

//
// Time to wait until domain controller MSMQ server is up and running.
// this value is number of 15 seconds internal.
// default 40 mean 10 minutes (40 * 15 seconds).
//
#define AUTO_REGISTER_WAIT_DC_REGNAME  \
                                TEXT("security\\AutoIntCertWaitIntervals")
#define DEFAULT_AUTO_REGISTER_WAIT_DC  40

//
// Value under HKCU that is set to 1 after auto registration succeed.
//
#define CERTIFICATE_REGISTERD_REGNAME  TEXT("CertificateRegistered")

//
// Value under HKCU that is set to 1 when the certificate exist on the local store
// but not registered in the DS
//
#define CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME  TEXT("ShouldRegisterCertInDs")

//
// Name and value of registry under the "Run" key
//
#define RUN_INT_CERT_REGNAME           TEXT("MsmqIntCert")
#define DEFAULT_RUN_INT_CERT           TEXT("regsvr32 /s mqrt.dll")

//+--------------------------------------------
//
//  Registry used for caching machine account
//
//+--------------------------------------------

//
// sid of machine account.
//
#define MACHINE_ACCOUNT_REGNAME   TEXT("security\\MachineAccount")

//+--------------------------------------------
//
//  Registry used for authz flags
//
//+--------------------------------------------

//
// authz flags.
//
#define MSMQ_AUTHZ_FLAGS_REGNAME   TEXT("security\\AuthzFlags")

#define MSMQ_SECURITY_REGKEY   		TEXT("security")
#define MSMQ_AUTHZ_FLAGS_REGVALUE   TEXT("AuthzFlags")

//+-----------------------------------------------------------------------
//
//  Registry used for marking lqs files Security descriptor was updated
//
//+-----------------------------------------------------------------------

#define MSMQ_LQS_UPDATED_SD_REGNAME   TEXT("security\\LqsUpdatedSD")

//
// By default we use RPC_C_AUTHN_LEVEL_PKT_PRIVACY - data encrypted.
// If this registry is defined we go down to RPC_C_AUTHN_LEVEL_PKT_INTEGRITY.
// This is usually done for debugging purposes - if you want to see the network traffic unencrypted on the wire.
//
#define MSMQ_DEBUG_RPC_REGNAME   TEXT("security\\DebugRpc")

//+--------------------------------------------
//
//  Registry used for encryption
//
//+--------------------------------------------

//
// Regname for name of Crypto container.
//
#define MSMQ_CRYPTO40_DEFAULT_CONTAINER         TEXT("MSMQ")
#define MSMQ_CRYPTO40_CONTAINER_REG_NAME    \
                                     TEXT("security\\Crypto40Container")

#define MSMQ_CRYPTO128_DEFAULT_CONTAINER        TEXT("MSMQ_128")
#define MSMQ_CRYPTO128_CONTAINER_REG_NAME   \
                                     TEXT("security\\Crypto128Container")

//
// Because of a bug in beta3 and rc1 crypto api, control panel can not
// renew crypto key. To workaround, on first boot, first time the service
// acquire the crypto provider, it sets again the container security.
//
#define MSMQ_ENH_CONTAINER_FIX_REGNAME   TEXT("security\\EnhContainerFixed")
#define MSMQ_BASE_CONTAINER_FIX_REGNAME  TEXT("security\\BaseContainerFixed")

//
// Regname for name of Crypto container, to be used by the mqforgn tool.
//
#define MSMQ_FORGN_BASE_DEFAULT_CONTAINER      TEXT("MSMQ_FOREIGN_BASE")
#define MSMQ_FORGN_BASE_KEY_REGNAME            TEXT("security\\")
#define MSMQ_FORGN_BASE_VALUE_REGNAME          TEXT("ForeignBaseContainer")
#define MSMQ_FORGN_BASE_CONTAINER_REGNAME   \
             (MSMQ_FORGN_BASE_KEY_REGNAME  MSMQ_FORGN_BASE_VALUE_REGNAME)

#define MSMQ_FORGN_ENH_DEFAULT_CONTAINER      TEXT("MSMQ_FOREIGN_ENH")
#define MSMQ_FORGN_ENH_KEY_REGNAME            TEXT("security\\")
#define MSMQ_FORGN_ENH_VALUE_REGNAME          TEXT("ForeignEnhContainer")
#define MSMQ_FORGN_ENH_CONTAINER_REGNAME   \
                (MSMQ_FORGN_ENH_KEY_REGNAME  MSMQ_FORGN_ENH_VALUE_REGNAME)

//
// Enable Report (Tracking) Messages
//
#define MSMQ_REPORT_MESSAGES_DEFAULT  0
#define MSMQ_REPORT_MESSAGES_REGNAME  TEXT("security\\EnableReportMessages")

//
// Windows bug 562586.
// RC2 effective enhanced key len changed from 40 bits to 128 bits.
//
// The following registry let user revert to 40 bits key, to enable backward
// compatibility. default- 0. non-zero value force using 40 bits keys.
//
#define MSMQ_RC2_SNDEFFECTIVE_40_REGNAME  TEXT("security\\SendEnhRC2With40")
//
// The following registry force rejection of messages encrypted with RC2
// if enhanced provider is used but effective length is 40.
// By default (value 0), all RC2 encryption are accepted. To enforce strong
// security, set this one to 1. Then messages from win2k or xp that use
// effective length of 40 will be rejected.
//
#define MSMQ_REJECT_RC2_IFENHLEN_40_REGNAME     \
                                 TEXT("security\\RejectEnhRC2IfLen40")


// if set revocation check of the certificate will be ignored. 


#define MSMQ_SKIP_REVOCATION_CHECK_REGNAME     \
                                 TEXT("SkipRevocationCheck")

//---------------------------------------------------------
//
//  Registry used by the NT5 replication service.
//
//---------------------------------------------------------

// Interval to next replication cycle, if present one failed. in Seconds.
#define RP_DEFAULT_FAIL_REPL_INTERVAL   (120)
#define RP_FAIL_REPL_INTERVAL_REGNAME   TEXT("Migration\\FailReplInterval")

// Interval to next hello, in seconds
#define RP_DEFAULT_HELLO_INTERVAL   (20 * 60)
#define RP_HELLO_INTERVAL_REGNAME   TEXT("Migration\\HelloInterval")

#define RP_DEFAULT_TIMES_HELLO      (1)
#define RP_TIMES_HELLO_FOR_REPLICATION_INTERVAL_REGNAME   \
                                    TEXT("Migration\\TimesHelloForReplicationInterval")

// Buffer between current and allowed purge SN
#define RP_DEFAULT_PURGE_BUFFER   (PURGE_BUFFER_SN)
#define RP_PURGE_BUFFER_REGNAME   TEXT("Migration\\PurgeBuffer")

// Frequency to send PSC Ack
#define RP_DEFAULT_PSC_ACK_FREQUENCY   (PSC_ACK_FREQUENCY_SN)
#define RP_PSC_ACK_FREQUENCY_REGNAME   TEXT("Migration\\PSCAckFrequencySN")

// Timeout of replication messages. in second.
#define RP_DEFAULT_REPL_MSG_TIMEOUT        (20 * 60)
#define RP_REPL_MSG_TIMEOUT_REGNAME        TEXT("Migration\\ReplMsgTimeout")

// My site id in NT4.
#define MSMQ_NT4_MASTERID_REGNAME  TEXT("Migration\\MasterIdOnNt4")

// Number of threads for answering replication/sync messages from NT4 servers.
#define RP_DEFAULT_REPL_NUM_THREADS        8
#define RP_REPL_NUM_THREADS_REGNAME        TEXT("Migration\\ReplThreads")

// DS query: Number of returned objects per ldap page
#define RP_DEFAULT_OBJECT_PER_LDAPPAGE	   1000	
#define RP_OBJECT_PER_LDAPPAGE_REGNAME	   TEXT("Migration\\ObjectPerLdapPage")

// If "ON_DEMAND" is 1, then replication is done on demand when
// "REPLICATE_NOW" is 1. The service read the "_NOW" flag each second.
#define RP_REPL_ON_DEMAND_REGNAME        TEXT("Migration\\ReplOnDemand")
#define RP_REPLICATE_NOW_REGNAME         TEXT("Migration\\ReplicateNow")

//
// Value of MQS before upgrade. Relevant only on ex-PEC
//
#define MSMQ_PREMIG_MQS_REGNAME          TEXT("PreMigMQS")

// Default interval for refreshing routing information. the default is 12 hours
// The granolarity is in minutes.
#define MSMQ_DEFAULT_ROUTING_REFRESH_INTERVAL (12 * 60)
#define MSMQ_ROUTING_REFRESH_INTERVAL_REGNAME  L"RoutingRefreshInterval"


//+----------------------------------------
//
// Registry key for debugging.
//
//+----------------------------------------

//
// DWORD. If set to 1, then Rt will mark the provider used for authentication
// as non default and will send the provider name.
//
#define USE_NON_DEFAULT_AUTHN_PROV_REGNAME  TEXT("debug\\UseNonDefAuthnProv")
//
// DWORD. Number of security subsections to insert before the real one.
//
#define PREFIX_SUB_SECTIONS_REGNAME         TEXT("debug\\PrefixSubSections")
//
// DWORD. Number of security subsections to insert after the real one.
//
#define POSTFIX_SUB_SECTIONS_REGNAME        TEXT("debug\\PostfixSubSections")

//
// DWORD. If set then it will enable assert benign
//

#define ASSERT_BENIGN_REGNAME               TEXT("debug\\AssertBenign")

//+----------------------------------------
//
//  Registry value for tracing
//
//+----------------------------------------

#define  MSMQ_DEFAULT_TRACE_FLAGS              1                            // Default Trace Level for MSMQ
#define  MSMQ_TRACE_FILENAME                   TEXT("Debug\\msmqlog.")
#define  MSMQ_TRACE_FILENAME_EXT               TEXT("bin")
#define  MSMQ_TRACE_FILENAME_BACKUP_EXT        TEXT("bak")
#define  MSMQ_TRACE_LOGSESSION_NAME            TEXT("MSMQ")
#define  MSMQ_TRACE_FLAG_VALUENAME             TEXT("Flags")
#define  MSMQ_TRACEKEY_NAME                    TEXT("Trace")
#define  MSMQ_NO_TRACE_FILES_LIMIT_REGNAME     TEXT("BackupwithNoTraceFileLimit")



//+----------------------------------------
//
//  Registry value for local admin api
//
//+----------------------------------------

//
// If this reg value is 1, then query operations of local admin api
// are restricted to administrators only. Bug 7520.
// Defualt is unrestricted, for backward compatibility.
//
#define  MSMQ_DEFAULT_RESTRICT_ADMIN_API    0
#define  MSMQ_RESTRICT_ADMIN_API_TO_LA      1
#define  MSMQ_RESTRICT_ADMIN_API_REGNAME    TEXT("RestrictAdminApi")

#endif  // __TEMP_MQINI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqreg.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _mqreg.h

Abstract:

    Registry location.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

--*/

#ifndef __MQREG_H_
#define __MQREG_H_

#define FALCON_REG_POS       HKEY_LOCAL_MACHINE
#define FALCON_USER_REG_POS  HKEY_CURRENT_USER

// The name of the service in the services registry.
#define MQQM_SERVICE_NAME       TEXT("MSMQ")

// Name of registry section.
#define MSMQ_DEFAULT_REGISTRY    TEXT("MSMQ")
#define MSMQ_REGISTRY_REGNAME    TEXT("RegistrySection")

#define FALCON_REG_KEY_ROOT  TEXT("SOFTWARE\\Microsoft\\")
#define FALCON_REG_KEY_PARAM TEXT("\\Parameters")
#define FALCON_REG_KEY_MACHINE_CACHE TEXT("\\MachineCache")

#define CLUSTERED_QMS_KEY    TEXT("\\Clustered QMs\\")

#define FALCON_REG_KEY  \
      (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY FALCON_REG_KEY_PARAM)

#define MSMQ_REG_SETUP_KEY   (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY TEXT("\\Setup"))

#define MSMQ_REG_PARAMETER_SETUP_KEY   (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY FALCON_REG_KEY_PARAM TEXT("\\Setup"))

#define FALCON_MACHINE_CACHE_REG_KEY  \
     (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY FALCON_REG_KEY_PARAM FALCON_REG_KEY_MACHINE_CACHE)

#define FALCON_CLUSTERED_QMS_REG_KEY \
      (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY CLUSTERED_QMS_KEY)

#define FALCON_REG_MSMQ_KEY   (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY)

#define FALCON_USER_REG_MSMQ_KEY  (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY)

#endif // __MQREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqres.h ===
//
// _mqres.h
//
// Resource related function in MQUTIL.DLL
//
#ifndef _MQRES_H
#define _MQRES_H

HMODULE MQGetResourceHandle();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_mqrpc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _mqrpc.h

Abstract:

   prototypes of RPC related utility functions.
   called from RT and QM.

--*/

#ifndef __MQRPC_H__
#define __MQRPC_H__

#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

//
//  Default protocol and options
//
#define RPC_LOCAL_PROTOCOLA  "ncalrpc"
#define RPC_LOCAL_PROTOCOL   TEXT(RPC_LOCAL_PROTOCOLA)
#define RPC_LOCAL_OPTION     TEXT("Security=Impersonation Dynamic True")

#define  RPC_TCPIP_NAME   TEXT("ncacn_ip_tcp")

//
// Define types of rpc ports.
//
enum PORTTYPE {
	IP_HANDSHAKE = 0,
	IP_READ = 1,
};

//
// Use this authentication "flag" for remote read. We don't use the
// RPC negotiate protocol, as it can't run against nt4 machine listening
// on NTLM. (actually, it can, but this is not trivial or straight forward).
// So we'll implement our own negotiation.
// We'll first try Kerberos. If client can't obtain principal name of
// server, then we'll switch to ntlm.
//
//  Value of this flag should be different than any RPC_C_AUTHN_* flag.
//
#define  MSMQ_AUTHN_NEGOTIATE   101

//
//  type of machine, return with port number
//
#define  PORTTYPE_WIN95  0x80000000

//
//  Prototype of functions
//

typedef DWORD
(* GetPort_ROUTINE) ( IN handle_t  Handle,
                      IN DWORD     dwPortType ) ;

HRESULT
MQUTIL_EXPORT
mqrpcBindQMService(
	IN  LPWSTR lpwzMachineName,
	IN  LPWSTR lpszPort,
	IN  OUT ULONG* peAuthnLevel,
	OUT handle_t* lphBind,
	IN  PORTTYPE PortType,
	IN  GetPort_ROUTINE pfnGetPort,
	IN  ULONG ulAuthnSvc
	);

HRESULT
MQUTIL_EXPORT
mqrpcUnbindQMService(
            IN handle_t*    lphBind,
            IN TBYTE      **lpwBindString) ;

BOOL
MQUTIL_EXPORT
mqrpcIsLocalCall( IN handle_t hBind) ;


BOOL
MQUTIL_EXPORT
mqrpcIsTcpipTransport( IN handle_t hBind) ;

unsigned long
MQUTIL_EXPORT
mqrpcGetLocalCallPID( IN handle_t hBind) ;

VOID
MQUTIL_EXPORT
APIENTRY
ComposeRPCEndPointName(
    LPCWSTR pwzEndPoint,
    LPCWSTR pwzComputerName,
    LPWSTR * ppwzBuffer
    );


VOID 
MQUTIL_EXPORT 
APIENTRY 
ProduceRPCErrorTracing(
	WCHAR *szFileName, 
	DWORD dwLineNumber);

#define PRODUCE_RPC_ERROR_TRACING  ProduceRPCErrorTracing(s_FN, __LINE__)


#endif // __MQRPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_registr.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _registr.h

Abstract:


--*/

#ifndef __REGISTER_H__
#define __REGISTER_H__

#include "_mqini.h"

#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

LPCWSTR
MQUTIL_EXPORT
APIENTRY
GetFalconSectionName(
    VOID
    );

DWORD
MQUTIL_EXPORT
APIENTRY
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    );


typedef VOID (APIENTRY *SetFalconServiceName_ROUTINE) (LPCWSTR);

VOID
MQUTIL_EXPORT
APIENTRY
SetFalconServiceName(
    LPCWSTR pwzServiceName
    );


LONG
MQUTIL_EXPORT
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey);


typedef LONG (APIENTRY *GetFalconKeyValue_ROUTINE) (
                    LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue /*= NULL*/ ) ;
LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(  LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;


typedef LONG (APIENTRY *SetFalconKeyValue_ROUTINE) (LPCWSTR, PDWORD, const VOID*, PDWORD);

LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(LPCWSTR  pszValueName,
                  PDWORD   pdwType,
                  const VOID * pData,
                  PDWORD   pdwSize);


LONG
MQUTIL_EXPORT
DeleteFalconKeyValue(
                  LPCWSTR pszValueName ) ;

//
//  Macros for reading registry/ini file
//
#define MAX_REG_DEFAULT_LEN  260

#define READ_REG_STRING(string, ValueName, default)            \
	WCHAR  string[ MAX_REG_DEFAULT_LEN ] = default;            \
   {                                                           \
     DWORD  dwSize = MAX_REG_DEFAULT_LEN * sizeof(WCHAR)  ;    \
     DWORD  dwType = REG_SZ ;                                  \
                                                               \
     ASSERT(wcslen(default) < MAX_REG_DEFAULT_LEN) ;           \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   string,                     \
                                   &dwSize,                    \
                                   default ) ;                 \
	 if(res == ERROR_MORE_DATA)									\
	{															\
		wcscpy(string, default);								\
	}															\
     ASSERT(res == ERROR_SUCCESS || res == ERROR_MORE_DATA) ;   \
   }

#define READ_REG_DWORD(outvalue, ValueName, default)           \
   {                                                           \
     DWORD  dwSize = sizeof(DWORD) ;                           \
     DWORD  dwType = REG_DWORD ;                               \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   &outvalue,                  \
                                   &dwSize,                    \
                                   (LPCTSTR) default ) ;       \
     ((void)res);                                              \
     ASSERT(res == ERROR_SUCCESS) ;                            \
   }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_propvar.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _propvar.h

Abstract:

    CMQVariant class

--*/

#ifndef __PROPVAR_H
#define __PROPVAR_H

//---------------------------------------------------------
//
//  class CMQVariant
//
//---------------------------------------------------------
class CMQVariant : private tagMQPROPVARIANT {
public:
    //
    // Simple types
    //
    CMQVariant();
    CMQVariant(unsigned char ch);
    CMQVariant(short i);
    CMQVariant(long l);

    CMQVariant& operator=(CMQVariant const &var);
    CMQVariant& operator=(short i);
    CMQVariant& operator=(long l);
    CMQVariant& operator=(unsigned char uc);

    //
    // Types with indirection
    //
    CMQVariant(BLOB const& b);
    CMQVariant(TCHAR const *pwsz);
    CMQVariant(CLSID const *pcid);

    CMQVariant& operator=(BLOB const& b);
    CMQVariant& operator=(TCHAR const *pwsz);
    CMQVariant& operator=(CLSID const *pcid);

    //
    // Counted array types.
    //

    CMQVariant(CACLSID const* pcauuid);
    CMQVariant(CALPWSTR const* pcalpwstr);
    CMQVariant(CAPROPVARIANT const* pcaprovar);

    CMQVariant& operator=(CACLSID const *pcauuid);
    CMQVariant& operator=(CALPWSTR const *pcalpwstr);
    CMQVariant& operator=(CAPROPVARIANT const *pcapropvar);

    //
    // To/From C style STGVARIANT and copy constructor
    //

    CMQVariant(CMQVariant const &var);
    CMQVariant(MQPROPVARIANT const &var);

    MQPROPVARIANT * CastToStruct();

    ~CMQVariant();

    //
    // Set/Get, all types including arrays.
    //

    void SetEMPTY();
    void SetNULL();
    void SetUI1(unsigned char uc);
    void SetI2(short i);
    void SetI4(long l);
    void SetLPTSTR(TCHAR const *psz);
    void SetBLOB(BLOB const& b);
    void SetCLSID(CLSID const *pc);
    void SetCACLSID(CACLSID const *pc);
    void SetCALPWSTR(CALPWSTR const *pc);
    void SetCAPROPVARIANT(CAPROPVARIANT const *pc);
    void SetPROPVARIANT(MQPROPVARIANT const* p);

    CLSID* GetCLSID(void);
    const CACLSID *GetCACLSID(void);
    LPWSTR GetLPWSTR(void);
    LPTSTR GetLPTSTR(void);
    const CALPWSTR * GetCALPWSTR(void);

private:
    void FreeVariant();

    void _setUI1(unsigned char);
    void _setI2(short);
    void _setI4(long);
    void _setLPTSTR(TCHAR const*);
    void _setBLOB(BLOB const&);
    void _setCLSID(CLSID const&);
    void _setCACLSID(CACLSID const&);
    void _setCALPWSTR(CALPWSTR const&);
    void _setPROPVARIANT(MQPROPVARIANT const&);
    void _setCAPROPVARIANT(CAPROPVARIANT const&);

private:
    static LPWSTR DupString(LPCWSTR);
    static CALPWSTR DupStringArray(CALPWSTR const&);
    static CAPROPVARIANT DupVariantArray(CAPROPVARIANT const&);
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
//  class CMQVariant
//
//  NOTE: Always set vt after allocating memory, so if
//      no memory available the variant is not changed, and
//      can be destructed correctly.
//---------------------------------------------------------
inline LPWSTR CMQVariant::DupString(LPCWSTR src)
{
    if(src == 0)
        return 0;

    LPWSTR dst = new WCHAR[wcslen(src)+1];

    wcscpy(dst,src);
    return dst;
}


inline CALPWSTR CMQVariant::DupStringArray(CALPWSTR const& src)
{
    ULONG cElems = src.cElems;
    CALPWSTR dst = {0, 0};
    if(cElems != 0)
    {
        dst.pElems = new LPWSTR[cElems];
    }

    try
    {
        for( ; cElems; cElems--)
        {
            dst.pElems[dst.cElems] = DupString(src.pElems[dst.cElems]);
            dst.cElems++;
        }
    }
    catch(...)
    {
        //
        //  Deallocate all allocated strings
        //  N.B.: we don't catch bad_alloc here since it is compiled with the explorer too.
        //
        while(dst.cElems != 0)
        {
            delete[] dst.pElems[--dst.cElems];
        }

        delete[] dst.pElems;
        dst.pElems = 0;

        //
        //  Rethrow the *same* exception.
        //
        throw;
    }

    return dst;
}


inline CAPROPVARIANT CMQVariant::DupVariantArray(CAPROPVARIANT const& src)
{
    ULONG cElems = src.cElems;
    CAPROPVARIANT dst = {0, 0};
    if(cElems != 0)
    {
        dst.pElems = new PROPVARIANT[cElems];
    }

    try
    {
        for( ; cElems; cElems--)
        {
#ifdef _DEBUG
#undef new
#endif

            new (&dst.pElems[dst.cElems]) CMQVariant(src.pElems[dst.cElems]);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

            dst.cElems++;
        }
    }
    catch(...)
    {
        //
        //  Deallocate all allocated variants
        //  N.B.: we don't catch bad_alloc here since it is compiled with the explorer too.
        //
        while(dst.cElems != 0)
        {
            static_cast<CMQVariant&>(dst.pElems[--dst.cElems]).~CMQVariant();
        }

        delete[] dst.pElems;
        dst.pElems = 0;

        //
        //  Rethrow the *same* exception.
        //
        throw;
    }

    return dst;
}


inline CMQVariant::~CMQVariant()
{
    FreeVariant();
}

inline MQPROPVARIANT* CMQVariant::CastToStruct(void)    
{
    return this;
}

inline void CMQVariant::_setUI1(unsigned char ch)
{
    bVal = ch;
    vt = VT_UI1;
}

inline void CMQVariant::_setI2(short i)
{
    iVal = i;
    vt = VT_I2;
}

inline void CMQVariant::_setI4(long l)
{
    lVal = l;
    vt = VT_I4;
}

inline void CMQVariant::_setLPTSTR(TCHAR const* pwsz)
{
    pwszVal = DupString(pwsz);
    vt = VT_LPWSTR;
}

inline void CMQVariant::_setBLOB(BLOB const& b)
{
    ULONG cbSize = b.cbSize;
    blob.pBlobData = new BYTE[cbSize];
    memcpy(blob.pBlobData, b.pBlobData, cbSize);
    blob.cbSize = cbSize;
    vt = VT_BLOB;
}

inline void CMQVariant::_setCLSID(CLSID const& g)
{
    puuid = new GUID;
    memcpy(puuid, &g, sizeof(GUID));
    vt = VT_CLSID;
}

inline void CMQVariant::_setCACLSID(CACLSID const& x)
{
    ULONG cElems = x.cElems;
    cauuid.pElems = new GUID[cElems];
    memcpy(cauuid.pElems, x.pElems, sizeof(GUID) * cElems);
    cauuid.cElems = cElems;
    vt = VT_VECTOR | VT_CLSID;
}

inline void CMQVariant::_setCALPWSTR(CALPWSTR const& x)
{
    calpwstr = DupStringArray(x);
    vt = VT_VECTOR | VT_LPWSTR;
}

inline void CMQVariant::_setPROPVARIANT(MQPROPVARIANT const& v)
{
    switch (v.vt)
    {
        case VT_UI1:
            _setUI1(v.bVal);
            break;
        case VT_UI2:
        case VT_I2:
            _setI2(v.iVal);
            break;
        case VT_UI4:
        case VT_I4:
            _setI4(v.lVal);
            break;
        case VT_CLSID:
            _setCLSID(*v.puuid);
            break;
        case VT_LPWSTR:
            _setLPTSTR(v.pwszVal);
            break;
        case VT_BLOB:
            _setBLOB(v.blob);
            break;
        case (VT_VECTOR | VT_CLSID):
            _setCACLSID(v.cauuid);
            break;
        case (VT_VECTOR | VT_LPWSTR):
            _setCALPWSTR(v.calpwstr);
            break;
        case (VT_VECTOR | VT_VARIANT):
            _setCAPROPVARIANT(v.capropvar);
            break;
        default:
            break;
    }
    vt = v.vt;

}

inline void CMQVariant::_setCAPROPVARIANT(CAPROPVARIANT const& x)
{
    capropvar = DupVariantArray(x);
    vt = VT_VECTOR | VT_VARIANT;
}


inline CMQVariant::CMQVariant()                         { vt = VT_EMPTY; }
inline CMQVariant::CMQVariant(unsigned char ch)         { _setUI1(ch); }
inline CMQVariant::CMQVariant(short i)                  { _setI2(i); }
inline CMQVariant::CMQVariant(long l)                   { _setI4(l); }
inline CMQVariant::CMQVariant(BLOB const& b)            { _setBLOB(b); }
inline CMQVariant::CMQVariant(LPCWSTR p)                { _setLPTSTR(p); }
inline CMQVariant::CMQVariant(CLSID const* pg)          { _setCLSID(*pg); }
inline CMQVariant::CMQVariant(CACLSID const* p)         { _setCACLSID(*p); }
inline CMQVariant::CMQVariant(CALPWSTR const* p)        { _setCALPWSTR(*p); }
inline CMQVariant::CMQVariant(CAPROPVARIANT const* p) { _setCAPROPVARIANT(*p); }
inline CMQVariant::CMQVariant(MQPROPVARIANT const &v)   { _setPROPVARIANT(v); }
inline CMQVariant::CMQVariant(CMQVariant const &v)      { _setPROPVARIANT(v); }

inline void CMQVariant::SetEMPTY()                      { FreeVariant(); vt = VT_EMPTY; }
inline void CMQVariant::SetNULL()                       { FreeVariant(); vt = VT_NULL; }
inline void CMQVariant::SetUI1(unsigned char ch)        { FreeVariant(); _setUI1(ch); }
inline void CMQVariant::SetI2(short i)                  { FreeVariant(); _setI2(i); }
inline void CMQVariant::SetI4(long l)                   { FreeVariant(); _setI4(l); }
inline void CMQVariant::SetBLOB(BLOB const& b)          { FreeVariant(); _setBLOB(b); }
inline void CMQVariant::SetLPTSTR(TCHAR const* p)       { FreeVariant(); _setLPTSTR(p); }
inline void CMQVariant::SetCLSID(CLSID const* pg)       { FreeVariant(); _setCLSID(*pg); }
inline void CMQVariant::SetCACLSID(CACLSID const* p)    { FreeVariant(); _setCACLSID(*p); }
inline void CMQVariant::SetCALPWSTR(CALPWSTR const* p)  { FreeVariant(); _setCALPWSTR(*p); }
inline void CMQVariant::SetCAPROPVARIANT(CAPROPVARIANT const* p)  { FreeVariant(); _setCAPROPVARIANT(*p); }
inline void CMQVariant::SetPROPVARIANT(MQPROPVARIANT const* p)      { FreeVariant(); _setPROPVARIANT(*p); }

inline CMQVariant& CMQVariant::operator=(unsigned char ch)  { SetUI1(ch); return(*this); }
inline CMQVariant& CMQVariant::operator=(short i)           { SetI2(i); return(*this); }
inline CMQVariant& CMQVariant::operator=(long l)            { SetI4(l); return(*this); }
inline CMQVariant& CMQVariant::operator=(BLOB const& b)     { SetBLOB(b); return(*this); }
inline CMQVariant& CMQVariant::operator=(TCHAR const *p)    { SetLPTSTR(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CLSID const *p)    { SetCLSID(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CACLSID const* p)  { SetCACLSID(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CALPWSTR const* p) { SetCALPWSTR(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CAPROPVARIANT const* p) {SetCAPROPVARIANT(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CMQVariant const& v){ SetPROPVARIANT(&v); return(*this); }

inline CLSID* CMQVariant::GetCLSID(void)
{
    return(puuid);
}

inline const CACLSID *CMQVariant::GetCACLSID(void)
{
    return(&cauuid);
}

inline LPWSTR CMQVariant::GetLPWSTR(void)
{
    return(pwszVal);
}

inline LPTSTR CMQVariant::GetLPTSTR(void)
{
    return(pwszVal);
}

inline const CALPWSTR * CMQVariant::GetCALPWSTR(void)
{
    return(&calpwstr);
}

inline void MQFreeVariant(MQPROPVARIANT& var)
{
    ULONG i;

    switch (var.vt)
    {
        case VT_CLSID:
            delete[] var.puuid;
            var.puuid = NULL;
            break;

        case VT_LPWSTR:
            delete[] var.pwszVal;
            var.pwszVal = NULL;
            break;

        case VT_BLOB:
            delete[] var.blob.pBlobData;
            var.blob.pBlobData = NULL;
            break;

        case (VT_VECTOR | VT_CLSID):
            delete[] var.cauuid.pElems;
            var.cauuid.pElems = NULL;
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for(i = 0; i < var.calpwstr.cElems; i++)
            {
                delete[] var.calpwstr.pElems[i];
            }
            delete [] var.calpwstr.pElems;
            var.calpwstr.pElems = NULL;
            break;
            
        case (VT_VECTOR | VT_VARIANT):
            for(i = 0; i < var.capropvar.cElems; i++)
            {
                MQFreeVariant(var.capropvar.pElems[i]);
            }
            delete[] var.capropvar.pElems;
            var.capropvar.pElems = NULL;
            break;
            
        default:
            break;
    }

    var.vt = VT_EMPTY;
}

inline void CMQVariant::FreeVariant()
{
	MQFreeVariant(*this);
}

//
//-------------------------------------------------------
// class to auto clean propvar array
//
class CAutoCleanPropvarArray
{
public:

    CAutoCleanPropvarArray()
    {
        m_rgPropVars = NULL;
    }

    ~CAutoCleanPropvarArray()
    {
        if (m_rgPropVars)
        {
            if (m_fFreePropvarArray)
            {
                //
                // we need to free the propvars and the array itself
                // free the propvars and the array by assigning it to an auto free propvar
                // of type VT_VECTOR | VT_VARIANT
                //
                CMQVariant mqvar;
                PROPVARIANT * pPropVar = mqvar.CastToStruct();
                pPropVar->capropvar.pElems = m_rgPropVars;
                pPropVar->capropvar.cElems = m_cProps;
                pPropVar->vt = VT_VECTOR | VT_VARIANT;
            }
            else
            {
                //
                // we must not free the array itself, just the contained propvars
                // free the propvars only by by assigning each one to an auto free propvar
                //
                PROPVARIANT * pPropVar = m_rgPropVars;
                for (ULONG ulProp = 0; ulProp < m_cProps; ulProp++, pPropVar++)
                {
                    CMQVariant mqvar;
                    *(mqvar.CastToStruct()) = *pPropVar;
                    pPropVar->vt = VT_EMPTY;
                }
            }
        }
    }

    PROPVARIANT * allocClean(ULONG cProps)
    {
        PROPVARIANT * rgPropVars = new PROPVARIANT[cProps];
        attachClean(cProps, rgPropVars);
        return rgPropVars;
    }

    void attachClean(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, TRUE /*fClean*/,  TRUE /*fFreePropvarArray*/);
    }

    void attach(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, FALSE /*fClean*/, TRUE /*fFreePropvarArray*/);
    }

    void attachStaticClean(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, TRUE /*fClean*/,  FALSE /*fFreePropvarArray*/);
    }

    void attachStatic(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, FALSE /*fClean*/, FALSE /*fFreePropvarArray*/);
    }

    void detach()
    {
        m_rgPropVars = NULL;
    }

private:
    PROPVARIANT * m_rgPropVars;
    ULONG m_cProps;
    BOOL m_fFreePropvarArray;

    void attachInternal(ULONG cProps,
                        PROPVARIANT * rgPropVars,
                        BOOL fClean,
                        BOOL fFreePropvarArray)
    {
        ASSERT(m_rgPropVars == NULL);
        if (fClean)
        {
            PROPVARIANT * pPropVar = rgPropVars;
            for (ULONG ulTmp = 0; ulTmp < cProps; ulTmp++, pPropVar++)
            {
                pPropVar->vt = VT_EMPTY;
            }
        }
        m_rgPropVars = rgPropVars;
        m_cProps = cProps;
        m_fFreePropvarArray = fFreePropvarArray;
    }
};



#endif // __PROPVAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_secutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    _secutil.h

    Header file for the various security related functions and cleses.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _SECUTILS_H_
#define _SECUTILS_H_

#ifndef MQUTIL_EXPORT
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

#include <mqcrypt.h>
#include <qformat.h>

extern MQUTIL_EXPORT CHCryptProv g_hProvVer;

MQUTIL_EXPORT
HRESULT
HashProperties(
    HCRYPTHASH  hHash,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar
    );

void MQUInitGlobalScurityVars() ;


MQUTIL_EXPORT
HRESULT
HashMessageProperties(
    HCRYPTHASH hHash,
    const BYTE *pbCorrelationId,
    DWORD dwCorrelationIdSize,
    DWORD dwAppSpecific,
    const BYTE *pbBody,
    DWORD dwBodySize,
    const WCHAR *pwcLabel,
    DWORD dwLabelSize,
    const QUEUE_FORMAT *pRespQueueFormat,
    const QUEUE_FORMAT *pAdminQueueFormat
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_rstrct.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _rstrct.h

Abstract:
    C++ wrappers for restrictions.

--*/

#ifndef __RSTRCT_H
#define __RSTRCT_H

#ifdef _MQUTIL      
#define MQUTIL_EXPORT  DLL_EXPORT
#else           
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

#include "_propvar.h"


//+-------------------------------------------------------------------------
//
//  Class:      CColumns
//
//  Purpose:    C++ wrapper for MQCOLUMNSET
//
//  History:    
//
//--------------------------------------------------------------------------

class MQUTIL_EXPORT CColumns
{
public:

    //
    // Constructors
    //

    CColumns( unsigned size = 0 );

    //
    // Copy constructors/assignment
    //

    CColumns( CColumns const & src );
    CColumns & operator=( CColumns const & src );

    //
    // Destructor
    //

    ~CColumns();

    //
    // C/C++ conversion
    //

    inline MQCOLUMNSET * CastToStruct();

    //
    // Member variable access
    //

    void Add( PROPID const& Property );
    void Remove( unsigned pos );
    inline PROPID const & Get( unsigned pos ) const;

    inline unsigned Count() const;


private:

    unsigned        m_cCol;
    PROPID		  * m_aCol;
    unsigned        m_size;
};

//+-------------------------------------------------------------------------
//
//  Structure:  SortKey
//
//  Purpose:    wraper for SORTKEY class
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CSortKey
{
public:

    //
    // Constructors
    //

    inline CSortKey();
    inline CSortKey( PROPID const & ps, ULONG dwOrder );
    inline ~CSortKey() {};

    //
    // assignment
    //

    CSortKey & operator=( CSortKey const & src );

    //
    // Member variable access
    //

    inline void SetProperty( PROPID const & ps );
    inline PROPID const & GetProperty() const;
    inline ULONG GetOrder() const;
	inline void SetOrder( ULONG const & dwOrder);

private:

    PROPID		        m_property;
    ULONG               m_dwOrder;
};


//+-------------------------------------------------------------------------
//
//  Class:      CSort
//
//  Purpose:    C++ wrapper for SORTSET
//
//  History:    22-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CSort
{
public:

    //
    // Constructors
    //

    CSort( unsigned size = 0 );

    //
    // Copy constructors/assignment
    //

    CSort( CSort const & src );
    CSort & operator=( CSort const & src );

    //
    // Destructor
    //

    ~CSort();

    //
    // C/C++ conversion
    //

    inline MQSORTSET * CastToStruct();

    //
    // Member variable access
    //

    void Add( CSortKey const &sk );
    void Add( PROPID const & Property, ULONG dwOrder );
    void Remove( unsigned pos );
    inline CSortKey const & Get( unsigned pos ) const;

    inline unsigned Count() const;

private:

    unsigned        m_csk;		// largest position filled
    CSortKey *      m_ask;
    unsigned        m_size;
};

//+-------------------------------------------------------------------------
//
//  Class:      CPropertyRestriction
//
//  Purpose:    Property <relop> constant restriction
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CPropertyRestriction 
{
public:

    //
    // Constructors
    //

    CPropertyRestriction();

    CPropertyRestriction( ULONG relop,
                          PROPID const & Property,
                          CMQVariant const & prval );
	// 
	// Assignment
	//
    CPropertyRestriction & operator=( CPropertyRestriction const & src );

    //
    // Destructors
    //

    ~CPropertyRestriction();

    //
    // Member variable access
    //

    inline void SetRelation( ULONG relop );
    inline ULONG Relation();

    inline void SetProperty( PROPID const & Property );
    inline PROPID const & GetProperty() const;
    
    inline void SetValue( ULONG ulValue );
    inline void SetValue( LONG lValue );
    inline void SetValue( SHORT sValue );
	inline void SetValue( UCHAR ucValue );
	inline void SetValue( const CMQVariant &prval );


    
    void SetValue ( CACLSID * caclsValue);
    void SetValue ( CALPWSTR  * calpwstrValue);
    void SetValue( BLOB & bValue );
    void SetValue( TCHAR * pwcsValue );
    void SetValue( GUID * pguidValue);
    void SetValue( CAPROPVARIANT * cavarValue);

    inline CMQVariant const & Value();

private:

    void            m_CleanValue();

    ULONG           m_relop;       // Relation
    PROPID		    m_Property;    // Property Name
    CMQVariant      m_prval;       // Constant value
};


//+-------------------------------------------------------------------------
//
//  Class:      CRestriction
//
//  Purpose:    Boolean AND of propertrt restrictions
//
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CRestriction 
{
public:

    //
    // Constructors
    //

    CRestriction(  unsigned cInitAllocated = 2 );

    //
    // Copy constructors/assignment
    //

    CRestriction( const CRestriction& Rst );

	CRestriction & operator=( CRestriction const & Rst );

    //
    // Destructor
    //

    ~CRestriction();

	//
    // C/C++ conversion
    //

    inline MQRESTRICTION * CastToStruct();



    //
    // Node manipulation
    //

    void AddChild( CPropertyRestriction const & presChild );
    CPropertyRestriction const & RemoveChild( unsigned pos );

    //
    // Member variable access
    //

    inline void SetChild( CPropertyRestriction const & presChild, unsigned pos );
    inline CPropertyRestriction const & GetChild( unsigned pos ) const;

	void AddRestriction( ULONG ulValue, PROPID property, ULONG relop);
	void AddRestriction( LONG lValue, PROPID property, ULONG relop);
	void AddRestriction( SHORT sValue, PROPID property, ULONG relop);
	void AddRestriction( UCHAR ucValue, PROPID property, ULONG relop);
	void AddRestriction(const CMQVariant & prval, PROPID property, ULONG relop);
	void AddRestriction( CACLSID * caclsValus, PROPID property, ULONG relop);
	void AddRestriction( LPTSTR pwszVal, PROPID property, ULONG relop);
	void AddRestriction( CALPWSTR * calpwstr, PROPID property, ULONG relop);
	void AddRestriction( GUID * pguidValue, PROPID property, ULONG relop);
    void AddRestriction( BLOB  & blobValue, PROPID property, ULONG relop);

    inline unsigned Count() const;

private:

    void Grow();

protected:

    ULONG           m_cNode;
    CPropertyRestriction *m_paNode;

    //
    // Members mapped to C structure end here.  The following will
    // be reserved in the C structure to maintain to C <--> C++
    // facade.
    //

    ULONG m_cNodeAllocated;
};


//--------------------------------------------------------------------------
//
// Inline methods for CColumns
//
//--------------------------------------------------------------------------
inline PROPID const & CColumns::Get( unsigned pos ) const
{
    if ( pos < m_cCol )
        return( m_aCol[pos] );
    else
        return( *(PROPID *)0 );
}


inline unsigned CColumns::Count() const
{
    return( m_cCol );
}

inline MQCOLUMNSET * CColumns::CastToStruct()
{
    return( (MQCOLUMNSET *)this );
}
//--------------------------------------------------------------------------
//
// Inline methods for CSortKey
//
//--------------------------------------------------------------------------
inline CSortKey::CSortKey()
{
}

inline CSortKey::CSortKey( PROPID const & ps, ULONG dwOrder )
        : m_property( ps ),
          m_dwOrder( dwOrder )
{
}

inline CSortKey & CSortKey::operator=( CSortKey const & src )
{
	m_property = src.m_property;
	m_dwOrder = src.m_dwOrder;
	return (*this);
}
inline void CSortKey::SetProperty( PROPID const & ps )
{
    m_property = ps;
}


inline PROPID const & CSortKey::GetProperty() const
{
    return( m_property );
}

inline ULONG CSortKey::GetOrder() const
{
    return( m_dwOrder );
}

inline void CSortKey::SetOrder( ULONG const & dwOrder)
{
	m_dwOrder = dwOrder;
}

//--------------------------------------------------------------------------
//
// Inline methods of CSort
//
//--------------------------------------------------------------------------
inline MQSORTSET * CSort::CastToStruct()
{
    return( (MQSORTSET *)this );
}

inline CSortKey const & CSort::Get( unsigned pos ) const
{
    if ( pos < m_csk )
    {
        return( m_ask[pos] );
    }
    else
    {
        return( *(CSortKey *)0 );
    }
}

inline unsigned
CSort::Count() const
{
    return( m_csk );
}


//--------------------------------------------------------------------------
//
// Inline methods of CRestriction
//
//--------------------------------------------------------------------------
inline unsigned CRestriction::Count() const
{
    return( m_cNode );
}


inline void CRestriction::SetChild( CPropertyRestriction const & presChild,
                                        unsigned pos )
{
    if ( pos < m_cNode )
    
		m_paNode[pos] = presChild;
}       

inline CPropertyRestriction const & CRestriction::GetChild( unsigned pos ) const
{
    if ( pos < m_cNode )
        return( m_paNode[pos] );
    else
        return( *(CPropertyRestriction *)0 );
}

inline MQRESTRICTION * CRestriction::CastToStruct()
{
    return( (m_cNode == 0) ? NULL : (MQRESTRICTION *)this );
}

//--------------------------------------------------------------------------
//
// Inline methods of CPropertyRestriction
//
//--------------------------------------------------------------------------
inline void CPropertyRestriction::SetRelation( ULONG relop )
{
    m_relop = relop;
}

inline ULONG CPropertyRestriction::Relation()
{
    return( m_relop );
}

inline void CPropertyRestriction::SetProperty( PROPID const & Property )
{
    m_Property = Property;
}


inline void CPropertyRestriction::SetValue( UCHAR ucValue )
{
    m_prval = ucValue;
}

inline void CPropertyRestriction::SetValue( SHORT sValue )

{
    m_prval = sValue;
}
inline void CPropertyRestriction::SetValue( ULONG ulValue )
{
    m_prval.SetI4( ulValue );
}

inline void CPropertyRestriction::SetValue( LONG lValue )
{
    m_prval = lValue;
}


inline void CPropertyRestriction::SetValue( const CMQVariant &prval )
{
    m_prval = prval;
}

inline CMQVariant const & CPropertyRestriction::Value()
{
    return( m_prval );
}  

#endif // __RSTRCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    _stdh.h

Abstract:
    Global Falcon project header file

Author:
    Erez Haba (erezh) 16-Jan-96

Note:
    DO NOT INCLUDE THIS FILE DIRECTLY IN YOUR SOURCE CODE,
    INCLUDE IT ONLY IN YOUR COMPONENT stdh.h FILE.

--*/
#ifndef __FALCON_STDH_H
#define __FALCON_STDH_H

#include <mqenv.h>
#include <mfc\afx.h>
#include <mfc\afxtempl.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)


//
// Make a BUGBUG messages appear in compiler output
//
// Usage: #pragma BUGBUG("This line appears in the compiler output")
//
#define MAKELINE0(a, b) a "(" #b ") : BUGBUG: "
#define MAKELINE(a, b)  MAKELINE0(a, b)
#define BUGBUG(a)       message(MAKELINE(__FILE__,__LINE__) a)



#include <crtwin.h>
#include <mqmacro.h>
#include <autoptr.h>
#include <mqreport.h>
#include <mqwin64.h>
#include <mqstl.h>
#include <allocaptr.h>
//
//  DO NOT ADD
//

#endif // __FALCON_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_ta.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ta.h

Abstract:

    Definition of the address type

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __TA_H
#define __TA_H
//
// AddressType values
//
#define IP_ADDRESS_TYPE         1
#define IP_RAS_ADDRESS_TYPE     2

#define IPX_ADDRESS_TYPE        3
#define IPX_RAS_ADDRESS_TYPE    4

#define FOREIGN_ADDRESS_TYPE    5


#define IP_ADDRESS_LEN           4
#define IPX_ADDRESS_LEN         10
#define FOREIGN_ADDRESS_LEN     16

#define TA_ADDRESS_SIZE         4  // To be changed if following struct is changing
typedef struct  _TA_ADDRESS
{
    USHORT AddressLength;
    USHORT AddressType;
    UCHAR Address[ 1 ];
} TA_ADDRESS;


C_ASSERT(TA_ADDRESS_SIZE == FIELD_OFFSET(TA_ADDRESS, Address));

#endif // _TA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mfc\afx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#include <mfc\afxver_.h>        // Target version control

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

class CObject;                        // the root of all objects classes

// Non CObject classes
class CString;                        // growable string type

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types

// abstract iteration position
struct __POSITION { int unused; };
typedef __POSITION* POSITION;

#define CPlex CPlexNew
struct CPlex;

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support


#ifdef _DEBUG

inline BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#define TRACE              ::AfxTrace
#define THIS_FILE          __FILE__

#define ASSERT_VALID(pOb)  ((pOb)->AssertValid())

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::AfxTrace(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          ::AfxTrace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::AfxTrace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::AfxTrace(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else   // _DEBUG

#define ASSERT_VALID(pOb)  ((void)0)
#define DEBUG_ONLY(f)      ((void)0)
inline void AFX_CDECL AfxTrace(LPCTSTR, ...) { }
#define TRACE              1 ? (void)0 : ::AfxTrace
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
	void AFX_CDECL Format(UINT nFormatID, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	void AFX_CDECL FormatMessage(UINT nFormatID, ...);
#endif

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL AFXAPI operator==(const CString& s1, const CString& s2);
BOOL AFXAPI operator==(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator==(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator!=(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator<(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator>(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator<=(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern AFX_DATA TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

class CObject
{
public:
    virtual ~CObject() {}

#ifdef _DEBUG
	virtual void AssertValid() const {}
#endif
};

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the vtbl pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(class base_class));

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT nBytes, BOOL bReadWrite = TRUE);
inline BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength)
{
	if (lpsz == NULL)
		return FALSE;
	return !::IsBadReadPtr(lpsz, nLength);
}

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)

// Memory tracking allocation
#define DEBUG_NEW new(__FILE__, __LINE__)

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = 0x01,         // turn on debugging allocator
	delayFreeMemDF      = 0x02,         // delay freeing memory
	checkAlwaysMemDF    = 0x04          // AfxCheckMemory on every alloc/free
};

#ifdef _UNICODE
#define AfxOutputDebugString(lpsz) \
	do \
	{ \
		int _convert; _convert = 0; \
		_RPT0(_CRT_WARN, W2CA(lpsz)); \
	} while (0)
#else
#define AfxOutputDebugString(lpsz) _RPT0(_CRT_WARN, lpsz)
#endif

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif


/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#define _AFX_INLINE inline
#include <mfc\afx.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\_stdafx.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _stdafx.h

Abstract:

    Global Falcon project header file, for components that uses MFC libraries.

Author:

    Erez Haba (erezh) 25-Nov-96

Note:

    DO NOT INCLUDE THIS FILE DIRECTLY IN YOUR SOURCE CODE,
    INCLUDE IT ONLY IN YOUR COMPONENT stdh.h FILE.

--*/
#ifndef __FALCON_STDAFX_H
#define __FALCON_STDAFX_H

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT
#define MAXDWORD    0xffffffff  
typedef TUCHAR TBYTE , *PTBYTE ;

#undef _DEBUG
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxtempl.h>

#undef ASSERT
#undef VERIFY

#ifdef DBG
#define _DEBUG
#define new DEBUG_NEW
#endif

#include <tr.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)


#include <crtwin.h>
#include <autoptr.h>
#include <mqreport.h>
#include <mqwin64a.h>

//
//  DO NOT ADD 
//

#endif // __FALCON_STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mfc\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef AFX_COLL_SEG
#pragma code_seg(AFX_COLL_SEG)
#endif

struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

inline CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
			// may throw exception
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

inline void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}

#ifdef AFX_COLL_SEG
#pragma code_seg()
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\libpch.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    libpch.h

Abstract:
    MSMQ Static Libraries master include file

Author:
    Erez Haba (erezh) 20-Dec-98

--*/

#pragma once

#ifndef _MSMQ_LIBPCH_H_
#define _MSMQ_LIBPCH_H_


#include <mqenv.h>
#include <mqmacro.h>
#include <mqstl.h>

#include <tr.h>
#include <cs.h>
#include <autoptr.h>
#include <autohandle.h>
#include <ref.h>
#include <allocaptr.h>


#endif // _MSMQ_LIBPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mfc\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
	#include <mfc\afxplex_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
static char _szAfxTempl[] = "afxtempl.h";
#undef THIS_FILE
#define THIS_FILE _szAfxTempl
#endif

#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

#ifdef new
#undef new
#define _REDEF_NEW
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(TYPE), FALSE));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
#ifdef _WIN64
#pragma warning(push)
#pragma warning(disable : 4311) //'type cast' : pointer truncation from 'const unsigned short *__ptr64 ' to 'unsigned long'
#endif //_WIN64
	return ((UINT)(ULONG_PTR)key) >> 4;
#ifdef _WIN64
#pragma warning(pop) 
#endif //_WIN64
}

// special versions for CString
template<>
void AFXAPI ConstructElements(CString* pElements, int nCount);
template<>
void AFXAPI DestructElements(CString* pElements, int nCount);
template<>
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
template<>
UINT AFXAPI HashKey(LPCTSTR key);

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray : public CObject
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:
	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#undef new
#ifdef _REDEF_NEW
#define new DEBUG_NEW
#undef _REDEF_NEW
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mfc\afxver_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxver_.h - target version/configuration control

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _AFX     1      // Microsoft Application Framework Classes
#define _MFC_VER 0x0410 // Microsoft Foundation Classes version 4.10

/////////////////////////////////////////////////////////////////////////////
// Default swap tuning for AFX library

#ifndef _68K_
	#define _TEXTSEG(name)  ".text$" #name
#else
	#define _TEXTSEG(name)  #name, "swappable"
#endif

// Most segments are tuned via function order list (DLL version)
#ifndef _AFX_FUNCTION_ORDER
#define AFX_CORE1_SEG   _TEXTSEG(AFX_CORE1) // core functionality
#define AFX_CORE2_SEG   _TEXTSEG(AFX_CORE2) // more core functionality
#define AFX_CORE3_SEG   _TEXTSEG(AFX_CORE3) // more core functionality
#define AFX_CORE4_SEG   _TEXTSEG(AFX_CORE4) // more core functionality
#define AFX_AUX_SEG     _TEXTSEG(AFX_AUX)   // auxilliary functionality
#define AFX_COLL_SEG    _TEXTSEG(AFX_COL1)  // collections
#define AFX_COLL2_SEG   _TEXTSEG(AFX_COL2)  // more collections
#define AFX_OLE_SEG     _TEXTSEG(AFX_OLE1)  // OLE support
#define AFX_OLE2_SEG    _TEXTSEG(AFX_OLE2)  // more OLE support
#define AFX_OLE3_SEG    _TEXTSEG(AFX_OLE3)  // and more OLE support
#define AFX_OLE4_SEG    _TEXTSEG(AFX_OLE4)  // and more OLE support
#define AFX_OLE5_SEG    _TEXTSEG(AFX_OLE5)  // and even more OLE support
#define AFX_OLERA_SEG	_TEXTSEG(AFX_OLERA) // (reserved for future use)
#define AFX_PRINT_SEG   _TEXTSEG(AFX_PRNT)  // Printing functionality
#define AFX_DBG1_SEG    _TEXTSEG(AFX_DBG1)  // inlines go here in _DEBUG
#define AFX_DBG2_SEG    _TEXTSEG(AFX_DBG2)  // inlines go here in _DEBUG
#define AFX_VDEL_SEG    _TEXTSEG(AFX_VDEL)  // vector deleting destructors
#define AFX_TERM_SEG    _TEXTSEG(AFX_TERM)  // cleanup routines
#define AFX_MAPI_SEG    _TEXTSEG(AFX_MAPI)  // simple MAPI support
#define AFX_SOCK_SEG    _TEXTSEG(AFX_SOCK)  // windows sockets support
#else
#define AFX_CORE1_SEG                       // core functionality
#define AFX_CORE2_SEG                       // more core functionality
#define AFX_CORE3_SEG                       // more core functionality
#define AFX_CORE4_SEG                       // more core functionality
#define AFX_AUX_SEG                         // auxilliary functionality
#define AFX_COLL_SEG                        // collections
#define AFX_COLL2_SEG                       // more collections
#define AFX_OLE_SEG                         // OLE support
#define AFX_OLE2_SEG                        // more OLE support
#define AFX_OLE3_SEG                        // and more OLE support
#define AFX_OLE4_SEG                        // and more OLE support
#define AFX_OLE5_SEG                        // and even more OLE support
#define AFX_OLERA_SEG						// (reserved for future use)
#define AFX_PRINT_SEG                       // Printing functionality
#define AFX_DBG1_SEG                        // inlines go here in _DEBUG
#define AFX_DBG2_SEG                        // inlines go here in _DEBUG
#define AFX_VDEL_SEG                        // vector deleting destructors
#define AFX_TERM_SEG                        // cleanup routines
#define AFX_MAPI_SEG                        // simple MAPI support
#define AFX_SOCK_SEG                        // windows sockets support
#endif

// AFX_INIT_SEG is hand tuned even in DLL version
#define AFX_INIT_SEG    _TEXTSEG(AFX_INIT)  // initialization

/////////////////////////////////////////////////////////////////////////////
// turn off reference tracking for certain often used symbols

#ifndef _AFX_PORTABLE
#pragma component(browser, off, references, "ASSERT")
#pragma component(browser, off, references, "BOOL")
#pragma component(browser, off, references, "BYTE")
#pragma component(browser, off, references, "DECLSPEC_IMPORT")
#pragma component(browser, off, references, "DWORD")
#pragma component(browser, off, references, "FALSE")
#pragma component(browser, off, references, "FAR")
#pragma component(browser, off, references, "LPSTR")
#pragma component(browser, off, references, "NULL")
#pragma component(browser, off, references, "PASCAL")
#pragma component(browser, off, references, "THIS_FILE")
#pragma component(browser, off, references, "TRUE")
#pragma component(browser, off, references, "UINT")
#pragma component(browser, off, references, "WINAPI")
#pragma component(browser, off, references, "WORD")
#endif  //!_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
// For target version (one of)
//   _CUSTOM   : for custom configurations (causes afxv_cfg.h to be included)
//
// Additional build options:
//  _DEBUG              debug versions (full diagnostics)
//  _AFXDLL             use shared MFC DLL
//  _AFXEXT             extension DLL version, implies _AFXDLL
//  _USRDLL             create regular DLL (_AFXDLL is valid too)
//

#define _AFX_NO_NESTED_DERIVATION

/////////////////////////////////////////////////////////////////////////////
// Special configurations

// _AFXEXT implies _AFXDLL
#if defined(_AFXEXT) && !defined(_AFXDLL)
	#define _AFXDLL
#endif

#if defined(_AFXDLL) && !defined(_DLL)
	#error Please use the /MD switch for _AFXDLL builds
#endif

#ifndef _MAC
#if defined(_AFXDLL) && !defined(_MT)
	#error Please use the /MD switch (multithreaded DLL C-runtime)
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// special include files

#if defined(_X86_) || defined(_MAC)
	#define _AFX_MINREBUILD
#endif

// setup default packing value
#ifndef _AFX_PACKING
    #ifdef _WIN64
        #define _AFX_PACKING    8
    #else
	    #define _AFX_PACKING    4   // default packs structs at 4 bytes
    #endif //_WIN64
#endif

#ifdef _AFXDLL
#else
	#define _AFX_NO_OCX_SUPPORT
#endif

// Define this virtual key for use by status bar
#ifndef VK_KANA
#define VK_KANA             0x15
#endif

/////////////////////////////////////////////////////////////////////////////
// Standard preprocessor symbols if not already defined
/////////////////////////////////////////////////////////////////////////////

// SIZE_T_MAX is used by the collection classes
#ifndef SIZE_T_MAX
	#define SIZE_T_MAX  UINT_MAX
#endif

// PASCAL is used for static member functions
#ifndef PASCAL
	#define PASCAL
#endif

// CDECL and EXPORT are defined in case WINDOWS.H doesn't
#ifndef CDECL
	#define CDECL __cdecl
#endif

#ifndef EXPORT
	#define EXPORT
#endif

// UNALIGNED is used for unaligned data access (in CArchive mostly)
#ifndef UNALIGNED
	#define UNALIGNED
#endif

// AFXAPI is used on global public functions
#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFXOLEAPI is used for some special OLE functions
#ifndef AFXOLEAPI
	#define AFXOLEAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// AFX_EXPORT is used for functions which need to be exported
#ifndef AFX_EXPORT
	#define AFX_EXPORT EXPORT
#endif

// The following macros are used to enable export/import

// for data
#ifndef AFX_DATA_EXPORT
	#define AFX_DATA_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_DATA_IMPORT
	#define AFX_DATA_IMPORT __declspec(dllimport)
#endif

// for classes
#ifndef AFX_CLASS_EXPORT
	#define AFX_CLASS_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_CLASS_IMPORT
	#define AFX_CLASS_IMPORT __declspec(dllimport)
#endif

// for global APIs
#ifndef AFX_API_EXPORT
	#define AFX_API_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_API_IMPORT
	#define AFX_API_IMPORT __declspec(dllimport)
#endif

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF

// used when building the "core" MFC40.DLL
#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA
	#define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO40.DLL
#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA
	#define AFX_OLE_DATADEF
#endif

// used when building the MFC/DB support MFCD40.DLL
#ifndef AFX_DB_DATA
	#define AFX_DB_DATA
	#define AFX_DB_DATADEF
#endif

// used when building the MFC/NET support MFCN40.DLL
#ifndef AFX_NET_DATA
	#define AFX_NET_DATA
	#define AFX_NET_DATADEF
#endif

// used when building extension DLLs
#ifndef AFX_EXT_DATA
	#define AFX_EXT_DATA
	#define AFX_EXT_DATADEF
	#define AFX_EXT_CLASS
	#define AFX_EXT_API
#endif

// BASED_XXXX macros are provided for backward compatibility
#ifndef BASED_CODE
	#define BASED_CODE
#endif

#ifndef BASED_DEBUG
	#define BASED_DEBUG
#endif

#ifndef BASED_STACK
	#define BASED_STACK
#endif

// setup default code segment
#ifdef AFX_DEF_SEG
	#pragma code_seg(AFX_DEF_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mqmakefile.inc ===
############################################################################
#
#   Copyright (C) 2000, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the MSMQ static
#   libraries under the NT build environment. It should be included into
#   the sources file of any library and unit test with a line of the form
#
#   !include $(FROOT)\src\lib\inc\mqmakefile.inc
#
############################################################################

#
# Include master source file
#
!include $(FROOT)\src\inc\msmq.inc

#
# Set warning level
#
MSC_WARNING_LEVEL=/W4

#
# Set include path
#
INCLUDES=$(MSMQ_LIBINC_PATH);$(FROOT)\src\lib;$(ALLOCA_INC_PATH)

#
# Precompiled directives. Sharing a common precompiled header for all
# libraries and tests.
#
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(FROOT)\src\lib\inc\libpch.h
PRECOMPILED_OBJ=$(MSMQ_LIB_PATH)\libpch.obj
PRECOMPILED_TARGET=$(MSMQ_LIB_PATH)\libpch.pch
PRECOMPILED_OPTION=/Yulibpch.h /Fp$(PRECOMPILED_TARGET)

#
# Browser file directives. Sharing a common browser file for all libraries
# and unit tests.
#
BROWSERFILE=$(MSMQ_LIB_PATH)\lib.bsc
OTHER_SBR_FILES=$(FROOT)\src\lib\Ts\lib\$(O)\pch_hdr.sbr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cm\lib\cminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmInit.cpp

Abstract:
    Configuration Manager initialization

Author:
    Uri Habusha (urih) 18-Jul-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cm.h"
#include "Cmp.h"

#include "cminit.tmh"

VOID
CmInitialize(
	HKEY hKey,
	LPCWSTR KeyPath,
	REGSAM securityAccess
	)
/*++

Routine Description:
    Intialize the configuration manger. Open the specified registery key as a
	default key for subsequent calls. The key handle is stored for further use

Arguments:
    hKey - An open key handle or any of the registery predefined handle values

	KeyPath - The name of the default subkey to open

Returned value:
	None.

Note:
	If the function can't opened the registery key an exception is raised.

 --*/
{
    ASSERT(!CmpIsInitialized());

    CmpSetInitialized();

	ASSERT(hKey != NULL);
	ASSERT(KeyPath != NULL);

    //
    // The root key must exist otherwise an exception will be thrown
    //
	RegEntry Root(KeyPath, 0, 0, RegEntry::MustExist, hKey);
    try
    {
		HKEY hRootKey = CmOpenKey(Root, securityAccess);
	    ASSERT(hRootKey != NULL);

		CmpSetDefaultRootKey(hRootKey);
    }
    catch(const exception&)
    {
		CmpSetNotInitialized();
		throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\inc\mfc\afx.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifdef _AFX_INLINE

// CString
_AFX_INLINE CStringData* CString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
_AFX_INLINE const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
_AFX_INLINE const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
_AFX_INLINE CString AFXAPI operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
_AFX_INLINE CString AFXAPI operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

_AFX_INLINE int CString::GetLength() const
	{ return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
	{ return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
_AFX_INLINE int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cm\lib\cmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cmp.h

Abstract:
    Configuration Manager private functions.

Author:
    Uri Habusha (urih) 18-Jul-99

--*/

#pragma once

#ifdef _DEBUG

void CmpAssertValid(void);
void CmpSetInitialized(void);
void CmpSetNotInitialized(void);
BOOL CmpIsInitialized(void);
void CmpRegisterComponent(void);

#else // _DEBUG

#define CmpAssertValid() ((void)0)
#define CmpSetInitialized() ((void)0)
#define CmpSetNotInitialized() ((void)0)
#define CmpIsInitialized() TRUE
#define CmpRegisterComponent() ((void)0)

#endif // _DEBUG

void CmpSetDefaultRootKey(HKEY hKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cm\lib\cmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmDebug.cpp

Abstract:
    Configuration Manager debugging

Author:
    Uri Habusha (urih) 28-Apr-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Cmp.h"

#include "cmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Configuration Manager state
//
void CmpAssertValid(void)
{
    //
    // CmInitalize() has *not* been called. You should initialize the
    // Configuration Manager library before using any of its funcionality.
    //
    ASSERT(CmpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void CmpSetInitialized(void)
{
    LONG fCmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Configuration Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fCmAlreadyInitialized);
}

void CmpSetNotInitialized(void)
{
    LONG fCmAlreadyInitialized = InterlockedExchange(&s_fInitialized, FALSE);

    //
    // The Configuration Manager library  has been initialized unsuccessfully. 
    // Since we mark the libarary as initialized at the beginning of function CmInitialize,
    // if something goes wrong afterwards we have to set it as not initialized.
    //
    ASSERT(fCmAlreadyInitialized);
}


BOOL CmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "CmDumpState(queue path name)",
        "Dump Configuration Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Configuration Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void CmpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cm\test\cmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmTest.cpp

Abstract:
    Configuration Manager library test

Author:
    Uri Habusha (urih) 18-Jul-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <TimeTypes.h>
#include "Cm.h"

#include "CmTest.tmh"

const WCHAR REGSTR_PATH_CMTEST_ROOT[] = L"SOFTWARE\\Microsoft\\CMTEST";
const WCHAR REGSTR_PATH_CMTEST_PARAM[] = L"PARAMETERS";

void PrintError(char* msg, DWORD line)
{
    TrERROR(GENERAL, "Failed in line %d ( %hs)", line, msg);

    RegEntry regKey1(REGSTR_PATH_CMTEST_ROOT, NULL, 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
	CmDeleteKey(regKey1);

    RegEntry regKey2(REGSTR_PATH_CMTEST_ROOT, NULL, 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	CmDeleteKey(regKey2);

    exit(-1);
}


void EnumrateValuesTest(void)
{
	LPCWSTR pRootEnumKey=L"ENUMTEST";

	//
	// Delete and create the root key
	//
	RegEntry reg(pRootEnumKey, NULL);
	CmDeleteKey(reg);
	CmCreateKey(reg,KEY_ALL_ACCESS);


	LPCWSTR pEnumArray[]={L"1234567",L"2666",L"3777",L"4666",L"5777",L"6777",L"7",L"8",L"9"};

	//
    // Set values for the test for the test
    //
    for(int i=0; i<sizeof(pEnumArray)/sizeof(LPWSTR);i++)
	{
		RegEntry reg(pRootEnumKey, pEnumArray[i]);
		CmSetValue(reg,pEnumArray[i]);
	}

	//
	// enumerate the values
	//
	CRegHandle hKey = CmOpenKey(reg, KEY_ALL_ACCESS);
	for(DWORD i=0;i<sizeof(pEnumArray)/sizeof(LPWSTR);i++)
	{
		AP<WCHAR> pEnumResult;
		bool fSuccess = CmEnumValue(hKey,i,&pEnumResult);		
		ASSERT(fSuccess);
		UNREFERENCED_PARAMETER(fSuccess);

		if(wcscmp(pEnumResult,pEnumResult)!= 0)
		{
			PrintError("Wrong enumeration value \n", __LINE__);
		}
	}

	//
	// cleanup- delete the key
	//
	CmDeleteKey(reg);
}


void TestQueryExpandValue(void)
{
	const WCHAR xValueName[] = L"TestExpandSz";
	const WCHAR xValue[] = L"%lib%;%path%";
    //
    // open registery keys for the test
    //
    RegEntry reg(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	HKEY hKey = CmCreateKey(reg, KEY_ALL_ACCESS);

    int rc = RegSetValueEx(
                hKey,
                xValueName, 
                0,
                REG_EXPAND_SZ, 
                reinterpret_cast<const BYTE*>(xValue),
                STRLEN(xValue)*sizeof(WCHAR)
                );

    if (rc != ERROR_SUCCESS)
    {
	    TrERROR(GENERAL, "Failed to create expand string value. Error=%d", rc);
		return;
    }

    RegEntry regTest(REGSTR_PATH_CMTEST_ROOT, xValueName, 0, RegEntry::MustExist, HKEY_CURRENT_USER);
    
	P<WCHAR> pRetValue;
	CmQueryValue(regTest, &pRetValue);

	WCHAR checkValue[512];
	ExpandEnvironmentStrings(xValue, checkValue, TABLE_SIZE(checkValue));

	if (wcscmp(pRetValue, checkValue) != 0)
	{
       PrintError( "Failed to retrieve REG_EXPAND_VALUE", __LINE__);
	}

	//
	// Cleanup
	//
	CmCloseKey(hKey);
 	CmDeleteKey(reg);
}


void TestAbsouloteKey(void)
{
    //
    // open registery keys for the test
    //
    RegEntry reg(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	HKEY hKey = CmOpenKey(reg, KEY_ALL_ACCESS);

    //
    // Create registery keys for the test
    //
    RegEntry regTest(REGSTR_PATH_CMTEST_PARAM, L"try", 1345, RegEntry::Optional, hKey);

	//
	// the value doesn't exist check that the default value is returened
	//
	DWORD RetValue;
    CmQueryValue(regTest, &RetValue);
    if (RetValue != 1345)
    {
       PrintError( "invalid CmQueryValue", __LINE__);
    }

    // 
    // Set a new value to registery and check that we 
    // get it back. 
    //
    CmSetValue(regTest, 12345);
    CmQueryValue(regTest, &RetValue);
    if (RetValue != 12345)
    {
       PrintError( "invalid CmQueryValue", __LINE__);
    }

	CmDeleteKey(regTest);

    RegEntry regTestKey(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	CmDeleteKey(regTestKey);

	CmCloseKey(hKey);
}


BOOL CmTestCreateRegisteryKey(HKEY RootKey)
{
	CRegHandle hKey = NULL;
	DWORD Disposition;
	int rc = RegCreateKeyEx(
				RootKey,
				REGSTR_PATH_CMTEST_ROOT,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				KEY_NOTIFY,
				NULL,
				&hKey,
				&Disposition
				);

    if (rc != ERROR_SUCCESS)
    {
        return FALSE;
    }
	
	return TRUE;
}


void CmTestCreateRegisterSubKeys(HKEY hRoot = NULL)
{
	RegEntry reg(REGSTR_PATH_CMTEST_PARAM, L"", 0, RegEntry::MustExist, hRoot);

	CmCreateKey(reg, KEY_ALL_ACCESS);
}


void CmTestInitialization(void)
{
	if (!CmTestCreateRegisteryKey(HKEY_LOCAL_MACHINE))
    {
	    printf("Cm Test Failed in line %d (Failed to create subkey) \n", __LINE__);
		exit(-1);
    }

	if (!CmTestCreateRegisteryKey(HKEY_CURRENT_USER))
    {
	    printf("Cm Test Failed in line %d (Failed to create subkey) \n", __LINE__);
		exit(-1);
    }

	//
	// Initialize configuration manager
	//
	CmInitialize(HKEY_LOCAL_MACHINE, REGSTR_PATH_CMTEST_ROOT, KEY_ALL_ACCESS);

	//
	// Initialize Tracing
	//
	TrInitialize();

	CmTestCreateRegisterSubKeys();

	CRegHandle hKey;
	int rc = RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_CMTEST_ROOT, 0, KEY_ALL_ACCESS,&hKey);
	if (rc != ERROR_SUCCESS)
	{
		PrintError("Failed to open register key", __LINE__);
	}
	CmTestCreateRegisterSubKeys(hKey);
}


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	CmTestInitialization();

	EnumrateValuesTest();


    DWORD RetValue;
    {
        //
        // Create RegEntry on the stack. Test the constructor and destructor
        // functions
        //
        RegEntry RegTest(NULL, L"try", 1345, RegEntry::Optional);

		//
		// the value doesn't exist check that the default value is returened
		//
        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 1345)
        {
           PrintError( "invalid CmQueryValue", __LINE__);
        }

        // 
        // Set a new value to registery and check that we 
        // get it back. 
        //
        CmSetValue(RegTest, 12345);
        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 12345)
        {
           PrintError( "invalid CmQueryValue", __LINE__);
        }

        //
        // Set a new value
        //
        RegEntry RegTest1(NULL, L"try");
        CmSetValue(RegTest1, 54321);

        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 54321)
        {
            PrintError("invalid CmQueryValue", __LINE__);
        }

    }
    //
    // Check that the value is realy store in registery. We use a new 
    // Regentry to featch the information from Registery
    //
    RegEntry RegTest(NULL, L"try");
    CmQueryValue(RegTest, &RetValue);
    if (RetValue != 54321)
    {
        PrintError( "invalid CmQueryValue", __LINE__);
    }

    //
    // Remove the entry from registery
    //
    CmDeleteValue(RegTest);

    //
    // Check returning of the default value when the registery isn't exist
    //
    {
        RegEntry* pRegTest = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"defaultTry", 98765 , RegEntry::Optional);
        CmQueryValue(*pRegTest, &RetValue);
        if (RetValue != 98765)
        {
            PrintError( "invalid CmQueryValue", __LINE__);
        }
        delete pRegTest;
    }

    //
    // Check that exception is raised when the value isn't exist in registery
    // but it mark as must exist in RegEntry
    //
    RetValue = 0;
    RegEntry* pRegTest = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"defaultTry", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(*pRegTest, &RetValue);
        PrintError( "We don't expected to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    if (RetValue != 0)
    {
        PrintError( "invalid CmQueryValue", __LINE__);
    }

    //
    //set value to reg vale
    //
    CmSetValue(*pRegTest, 987);
    CmQueryValue(*pRegTest, &RetValue);
    if (RetValue != 987)
    {
        PrintError("invalid CmQueryValue", __LINE__);
    }

    CmDeleteValue(*pRegTest);

    //
    // Check that CmDelete mark the RegEntry as Non cached. As a result
    // Cm try to featch the value from registery and failed. Since the 
    // registery mark as must exist, an exception is raised
    //
    try
    {
        CmQueryValue(*pRegTest, &RetValue);
        PrintError( "We don't expected to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    delete pRegTest;

    //
    // Check Set and Get of guid
    //
    GUID Guid;
    RPC_STATUS rc;
    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // Try to read non existing GUID value. Must return a null GUID
    //
    RegEntry RegTest1(REGSTR_PATH_CMTEST_PARAM, L"tryGuid");
    GUID RetGuid;
    CmQueryValue(RegTest1, &RetGuid);
    if (memcmp(&RetGuid, &GUID_NULL, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }

    //
    // Test seting of GUID value
    //
    CmSetValue(RegTest1, &Guid);

    // 
    // Check that the GUID value is stored in registery and that the
    // new read GUID value is equivalent to the set value
    //
    RegEntry* pRegTest2 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryGuid");
    CmQueryValue(*pRegTest2, &RetGuid);
    if (memcmp(&RetGuid, &Guid, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }
    CmQueryValue(*pRegTest2, &RetGuid);
    if (memcmp(&RetGuid, &Guid, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }
    delete pRegTest2;
    CmDeleteValue(RegTest1);


    RegEntry RegTest3(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest3, &RetGuid);
        PrintError( "We don't expecte to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    //
    // Check Set/Get for String
    //
    WCHAR Str[] = L"abcd edfgr";
    RegEntry RegTest4(REGSTR_PATH_CMTEST_PARAM, L"tryStr");
    WCHAR* pRetStr;
    //
    // Check that reading non existing string return size NULL
    //
    CmQueryValue(RegTest4, &pRetStr);
    if (pRetStr != NULL)
    {
        PrintError("invalid Return Size", __LINE__);
    }

    //
    // Test setting of string
    //
    CmSetValue(RegTest4, Str);

    //
    // Geting of existing string. Check that the return string
    // Is equivalent to the set string 
    //
    RegEntry* RegTest5 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryStr");
    CmQueryValue(*RegTest5, &pRetStr);
    if (wcscmp(pRetStr, Str))
    {
        PrintError("invalid String value", __LINE__);
    }

	delete [] pRetStr;
    delete RegTest5;

    // Delete the string from registery
    //
    CmDeleteValue(RegTest4);


    //
    // Check that reading non existing value that set as must exist cause
    // an exception
    //
    RegEntry RegTest6(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest6, &RetGuid);
        PrintError("We Don't expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    CmDeleteValue(RegTest6);
    
    //
    // Check Set/Get for Bytes
    //
    UCHAR byteBuffer[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    DWORD BufferSize = TABLE_SIZE(byteBuffer);
    DWORD Size;
    
    RegEntry RegTest7(REGSTR_PATH_CMTEST_PARAM, L"tryByte");
    BYTE* pRetByte;
    //
    // Check that reading of non existing Byte return size 0
    //
    CmQueryValue(RegTest7, &pRetByte, &Size);
    if ((Size != 0)	|| (pRetByte != NULL))
    {
        PrintError("invalid Return Size", __LINE__);
    }

    //
    // Test setting of Byte
    //
    CmSetValue(RegTest7, byteBuffer, BufferSize);

    //
    // Geting of existing string. Check that the return string
    // Is equivalent to the set string 
    //
    RegEntry* RegTest9 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryByte");
    CmQueryValue(*RegTest9, &pRetByte, &Size);
    if ((Size != BufferSize) || 
        memcmp(pRetByte, byteBuffer, BufferSize) )
    {
        PrintError("invalid String value", __LINE__);
    }

	delete [] pRetByte;
    delete RegTest9;

    //
    // Delete the string from registery
    //
    CmDeleteValue(RegTest7);

    //
    // Check that reading of non existing value that set as must exist cause
    // an exception
    //
    RegEntry RegTest10(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest10, &RetGuid);
        PrintError( "We don't expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    //
    //  try to get the machine ID. Delete it and try to read it. We 
    // expect to get an exception
    //
    RegEntry RegTest11(REGSTR_PATH_CMTEST_PARAM, L"MachineID", 0, RegEntry::MustExist);
    CmDeleteValue(RegTest11);

    try
    {
		GUID MachineId;
		CmQueryValue(RegTest11, &MachineId);

        PrintError("We don't Expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // Test setting of machine ID
    //
    CmSetValue(RegTest11, &Guid);
    GUID tempGuid;
	GUID prevGuid;
	CmQueryValue(RegTest11, &tempGuid);
	prevGuid = tempGuid;

    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // set a new machine ID. e want to check that we get the cahched value
    //
    RegEntry RegTest12(REGSTR_PATH_CMTEST_PARAM, L"MachineID", 0, RegEntry::MustExist);
    CmSetValue(RegTest12, &Guid);

    GUID newGuid;
	CmQueryValue(RegTest11, &tempGuid);
	newGuid = tempGuid;

    if (memcmp(&prevGuid, &newGuid, sizeof(GUID)) == 0)
    {
        PrintError("Illegal Machine ID", __LINE__);
    }

    //
    // set value of un-existing key
    //
    RegEntry RegTest13(L"temp Subkey", L"try", 0, RegEntry::Optional); 
    CmSetValue(RegTest13, 1);
    CmDeleteKey(RegTest13);

    //
    // delete unexisting value
    //
    RegEntry RegTest14(REGSTR_PATH_CMTEST_PARAM, L"try", 0, RegEntry::MustExist);
    CmDeleteValue(RegTest14);

    //
    // test time  duration setting/querying 
    //
    RegEntry RegTest15(REGSTR_PATH_CMTEST_PARAM, L"timeout", 123456);
    CmSetValue(RegTest15, CTimeDuration(123456i64));

    CTimeDuration queryValue;
    CmQueryValue(RegTest15, &queryValue);
    if (!(queryValue == 120000))
    {
        PrintError("Failed to setting/querying timeout value", __LINE__);
    }

    RegEntry regTestSubKey(REGSTR_PATH_CMTEST_PARAM, L"", 0, RegEntry::MustExist);
	CmDeleteKey(regTestSubKey);

    RegEntry regTestKey(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
	CmDeleteKey(regTestKey);


	TestAbsouloteKey();

	TestQueryExpandValue();

    TrTRACE(GENERAL, "pass successfully");

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cm\lib\cm.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cm.cpp

Abstract:
    This module contains configuration Manager stub.

Author:
    Uri Habusha (urih) 12-Jan-98

Enviroment:
    Platform-independent

--*/

#include <libpch.h>
#include <TimeTypes.h>
#include "Cm.h"
#include "Cmp.h"

#include <strsafe.h>

#include "cm.tmh"

static HKEY s_hCmRootKey = NULL;

void CmpSetDefaultRootKey(HKEY hKey)
{
	s_hCmRootKey = hKey;
}

inline
void
ThrowMissingValue(
    const RegEntry& re
    )
{
    if(re.m_Flags == RegEntry::MustExist)
    {
        throw bad_alloc();
    }
}


inline
HKEY
GetRootKey(
	const RegEntry& re
	)
{
	//
	// If the key handle is specified, the function use it
	// otherwise the root key that was defined on initilization
	// is used
	//
	return ((re.m_Key != NULL) ? re.m_Key : s_hCmRootKey);
}


inline
void
ExpandRegistryValue(
	LPWSTR pBuffer,
	DWORD bufferSize
	)
{
	SP<WCHAR> ptemp;
    StackAllocSP(ptemp, bufferSize*sizeof(WCHAR));

	HRESULT hr = StringCchCopy(ptemp.get(),bufferSize, pBuffer);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "bufferSize parameter too small. bufferSize:%d, Actual buffer:%ls",bufferSize, pBuffer);
		throw bad_alloc();
	}

	DWORD s = ExpandEnvironmentStrings(ptemp.get(), pBuffer, bufferSize);

	ASSERT(s != 0);
	ASSERT(bufferSize >= s);

	if (s == 0 || bufferSize < s)
	{
		TrERROR(GENERAL, "ExpandEnvironmentStrings failed. bufferSize:%d, Returned size:%d",bufferSize, s);
		throw bad_alloc();
	}
	
	return;
}


static
void
QueryValueInternal(
    const RegEntry& re,
    DWORD RegType,
    VOID* pBuffer,
    DWORD BufferSize
    )
{
    CRegHandle hKey = CmOpenKey(re, KEY_QUERY_VALUE);
    if (hKey == NULL)
    {
        return;
    }

    DWORD Type = RegType;
    DWORD Size = BufferSize;
    int rc = RegQueryValueEx (
                hKey,
                re.m_ValueName,
                0,
                &Type,
                static_cast<BYTE*>(pBuffer),
                &Size
                );

	if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
		return;
    }

	if ((Type == REG_EXPAND_SZ)	&& (RegType == REG_SZ))
	{
		//
		// The size is in bytes but it should be multiple of WCHAR size
		//
		ASSERT((BufferSize % sizeof(WCHAR)) == 0);

		//
		// Calculate the buffer size in WCHAR. ExpandRegistryValue expects to
		// get the size in WCHAR
		//
		DWORD bufSizeInWchar = BufferSize / 2;

		ExpandRegistryValue(static_cast<LPWSTR>(pBuffer), bufSizeInWchar);
		return;
	}

    //
    // The registery value was featched, but its type or size isn't compatible
    //
    ASSERT((Type == RegType) && (BufferSize == Size));

}


static
DWORD
QueryExapndStringSize(
    const RegEntry& re,
    DWORD Size
    )
/*++
    Routine Description:
        The routine retreive the size of the expanded registry value.

    Arguments:
        None

    returned value:
        The size of expanded string

 --*/
{
	//
	// Alocate new buffer for reading the value
	//
    SP<WCHAR> pRetValue;
    StackAllocSP(pRetValue, Size);

	//
	// featch the information from the registery
	//
	QueryValueInternal(re, REG_EXPAND_SZ, pRetValue.get(), Size);

	DWORD expandedSize = ExpandEnvironmentStrings(pRetValue.get(), NULL, 0);

	if (expandedSize == 0)
	{
        ThrowMissingValue(re);
        return 0;
	}

	return (DWORD)(max((expandedSize * sizeof(WCHAR)), Size));
}


static
DWORD
QueryValueSize(
    const RegEntry& re,
    DWORD Type
    )
/*++
    Routine Description:
        The routine retreive the Register value size.

    Arguments:
        None

    returned value:
        TRUE if the intialization completes successfully. FALSE, otherwise

 --*/
{
    CRegHandle hKey = CmOpenKey(re, KEY_QUERY_VALUE);
    if (hKey == NULL)
    {
        return 0;
    }

    DWORD Size;
    int rc = RegQueryValueEx(
                hKey,
                re.m_ValueName,
                0,
                &Type,
                NULL,
                &Size
                );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return 0;
    }

	if (Type == REG_EXPAND_SZ)
	{
		Size = QueryExapndStringSize(re, Size);
	}

    return Size;
}


static
void
SetValueInternal(
    const RegEntry& re,
    DWORD RegType,
    const VOID* pBuffer,
    DWORD Size
    )
{
    //
    // Open the specified key. If the key doesn't exist in the registry, the function creates it.
    //
    CRegHandle hKey = CmCreateKey(re, KEY_SET_VALUE);

    int rc = RegSetValueEx(
                hKey,
                re.m_ValueName,
                0,
                RegType,
                static_cast<const BYTE*>(pBuffer),
                Size
                );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


void
CmQueryValue(
    const RegEntry& re,
    DWORD* pValue
    )
{
    CmpAssertValid();

	*pValue = re.m_DefaultValue;
    QueryValueInternal(re, REG_DWORD, pValue, sizeof(DWORD));
}


void
CmQueryValue(
    const RegEntry& re,
    GUID* pValue
    )
{
    CmpAssertValid();

	*pValue = GUID_NULL;
    QueryValueInternal(re, REG_BINARY, pValue, sizeof(GUID));
}


void
CmQueryValue(
    const RegEntry& re,
    CTimeDuration* pValue
    )
{
    CmpAssertValid();

    DWORD timeout = re.m_DefaultValue;
    QueryValueInternal(re, REG_DWORD, &timeout, sizeof(DWORD));

    //
    // The time is stored in millisec units in registery. Convert it to
    // CTimeDuration tick units (100 ns).
    //
    *pValue = CTimeDuration(timeout * CTimeDuration::OneMilliSecond().Ticks());
}


void
CmQueryValue(
    const RegEntry& re,
    BYTE** pValue,
    DWORD* pSize
    )
{
    CmpAssertValid();

    *pSize = 0;
	*pValue = NULL;

    //
    // Get the data size
    //
    DWORD Size = QueryValueSize(re, REG_BINARY);
    if (Size != 0)
    {
		//
		// Alocate new buffer for reading the value
		//
		AP<BYTE> pRetValue = new BYTE[Size];

		//
		// featch the information from the registery
		//
		QueryValueInternal(re, REG_BINARY, pRetValue, Size);

		*pSize = Size;
		*pValue = pRetValue.detach();
	}
}


void
CmQueryValue(
    const RegEntry& re,
    WCHAR** pValue
    )
{
    CmpAssertValid();

	*pValue = NULL;

    //
    // Get the data size
    //
    DWORD Size = QueryValueSize(re, REG_SZ);

	//
	// The size returnes in bytes but it should be multiple of WCHAR size
	//
	ASSERT((Size % sizeof(WCHAR)) == 0);

    if (Size != 0)
    {
		//
		// Alocate new buffer for reading the value
		//
		AP<WCHAR> pRetValue = new WCHAR[Size / 2];

		//
		// featch the information from the registery
		//
		QueryValueInternal(re, REG_SZ, pRetValue, Size);
		*pValue = pRetValue.detach();
	}
}


void
CmSetValue(
    const RegEntry& re,
    DWORD Value
    )
{
    CmpAssertValid();

    SetValueInternal(re, REG_DWORD, &Value, sizeof(DWORD));
}


void
CmSetValue(
    const RegEntry& re,
    const CTimeDuration& Value
    )
{
    CmpAssertValid();

    //
    // Store the time in registry in millisec units
    //
    DWORD timeout = static_cast<DWORD>(Value.InMilliSeconds());

    SetValueInternal(re, REG_DWORD, &timeout, sizeof(DWORD));
}


bool
CmEnumValue(
	HKEY hKey,
	DWORD index,
	LPWSTR* ppValueName
	)
/*++

Routine Description:
	Return value name of a given key in a given index

Arguments:
    IN - hKey - An open key handle or any of the registery predefined handle values

	IN - DWORD index - index of the value name - to enumerate - on first call should be  0 -
		then increament on each call.

	OUT - LPWSTR* ppValueName - receive the value name when the function returns.

Returned value:
	True if the function succeeded  in returning the value name - otherwise false.
	In case of unexpected errors - the function throw std::bad_alloc

Note:
	For some reason - the function RegEnumValue - does not return the actual length of the
	value name. You just have to try to increament the buffer untill it fits			

 --*/
{
    CmpAssertValid();

	ASSERT(ppValueName);
	
	//
	// First try to fit the name value into 16 wide chars
	//
	DWORD len = 16;
	for(;;)
	{
		AP<WCHAR> pValueName = new WCHAR[len];
		LONG hr = RegEnumValue(	
						hKey,
						index,
						pValueName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(hr == ERROR_SUCCESS)
		{
			*ppValueName = pValueName.detach();
			return true;
		}

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			return false;
		}

		if(hr != ERROR_MORE_DATA)
		{
			throw bad_alloc();
		}
	
		//
		// buffer is to small - try dobule size
		//
		len = len * 2;	
	}
	return true;
}


void
CmSetValue(
    const RegEntry& re,
    const GUID* pGuid
    )
{
    CmpAssertValid();

    SetValueInternal(re, REG_BINARY, pGuid, sizeof(GUID));
}


void
CmSetValue(
    const RegEntry& re,
    const BYTE* pByte,
    DWORD Size
    )
{
    CmpAssertValid();

    SetValueInternal(re, REG_BINARY, pByte, Size);

}


void
CmSetValue(
    const RegEntry& re,
    const WCHAR* pString
    )
{
    CmpAssertValid();

	DWORD size = (wcslen(pString) + 1) * sizeof(WCHAR);
    SetValueInternal(re, REG_SZ, pString, size);
}


void CmDeleteValue(const RegEntry& re)
{
    CmpAssertValid();

    CRegHandle hKey = CmOpenKey(re, KEY_SET_VALUE);

    if (hKey == NULL)
        return;

    int rc = RegDeleteValue(hKey, re.m_ValueName);
    if (rc == ERROR_FILE_NOT_FOUND)
    {
        //
        // The value doesn't exist. Handle like delete succeeded
        //
        return;
    }

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


HKEY
CmCreateKey(
    const RegEntry& re,
	REGSAM securityAccess
    )
{
    CmpAssertValid();

    //
    // RegCreateKeyEx doesn't accept NULL subkey. To behave like RegOpenKey
    // pass an empty string instead of the NULL pointer
    //
    LPCWSTR subKey = (re.m_SubKey == NULL) ? L"" : re.m_SubKey;

	HKEY hKey;
	DWORD Disposition;
	int rc = RegCreateKeyEx(
				GetRootKey(re),
                subKey,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				securityAccess,
				NULL,
				&hKey,
				&Disposition
				);

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return NULL;
    }

    return hKey;
}


void CmDeleteKey(const RegEntry& re)
{
    ASSERT(re.m_SubKey != NULL);

	int rc = RegDeleteKey(GetRootKey(re), re.m_SubKey);

    if (rc == ERROR_FILE_NOT_FOUND)
    {
        //
        // The key doesn't exist. Handle like delete succeeded
        //
        return;
    }

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


HKEY
CmOpenKey(
    const RegEntry& re,
	REGSAM securityAccess
    )
{
	CmpAssertValid();

    HKEY hKey;
    int rc = RegOpenKeyEx(
                    GetRootKey(re),
                    re.m_SubKey,
                    0,
                    securityAccess,
                    &hKey
                    );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return NULL;
    }

    return hKey;
}


void CmCloseKey(HKEY hKey)
{
    CmpAssertValid();

	RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cry\lib\cry.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Cry.cpp

Abstract:
    crypt functions

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <wincrypt.h>
#include "Cry.h"
#include "Cryp.h"

#include "cry.tmh"

HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR CspProvider
	)
/*++

Routine Description:
	Aquire Crypto Service Provider (csp) 

Arguments:
    hCsp - (out) handle to csp

Returned Value:
	None.

--*/
{
	//
	// Acquire CSP
	//
	HCRYPTPROV hCsp;
	BOOL fSuccess = CryptAcquireContext(
						&hCsp, 
						NULL, 
						CspProvider, // MS_ENHANCED_PROV, //MS_DEF_PROV, 
						PROV_RSA_FULL, 
						0
						); 

	if(fSuccess)
		return(hCsp);

	//
	// The provider does not exist try to create one
	//
	if(GetLastError() == NTE_BAD_KEYSET)
	{
		//
		// Create new key container
		//
		fSuccess = CryptAcquireContext(
						&hCsp, 
						NULL, 
						CspProvider, // MS_ENHANCED_PROV, //MS_DEF_PROV, 
						PROV_RSA_FULL, 
						CRYPT_NEWKEYSET
						); 

		if(fSuccess)
			return(hCsp);
	}

    DWORD gle = GetLastError();

#ifdef _DEBUG

	if(wcscmp(CspProvider, MS_ENHANCED_PROV) == 0)
	{
		//
		// High Encryption Pack might not installed on the machine
		//
		TrERROR(SECURITY, "Unable to use Windows High Encryption Pack. Error=%x", gle);
	}

#endif // _DEBUG

	TrERROR(SECURITY, "Unable to open Csp '%ls' Error=%x", CspProvider, gle);
	throw bad_CryptoProvider(gle);
}


HCRYPTKEY 
CrypGenKey(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	)
/*++

Routine Description:
	generate a new key (seesion key, public/private key pair, exchange key) 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - key type to create according to the key usage
			AT_SIGNATURE
			AT_KEYEXCHANGE
			CALG_RC2
			.....

Returned Value:
	handle to key that is created

--*/
{
    //
    // Create exportable key. 
    //
	HCRYPTKEY hKey;
    BOOL fSuccess = CryptGenKey(
						hCsp, 
						AlgId, 
						CRYPT_EXPORTABLE, 
						&hKey
						);
	if(fSuccess)
		return(hKey);

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptGenKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


HCRYPTKEY 
CryGenSessionKey(
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	generate session key from the crypto service provider (csp) 

Arguments:
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the session key 

--*/
{
	return(CrypGenKey(hCsp, CALG_RC2));
}


HCRYPTKEY 
CryGetPublicKey(
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	get public key from the crypto service provider (csp) 

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the public key 

--*/
{

	//
	// Get user public key from the csp 
	//
	HCRYPTKEY hKey;

	BOOL fSuccess = CryptGetUserKey(   
						hCsp,    
						PrivateKeySpec, // AT_SIGNATURE,    
						&hKey
						);

	if(fSuccess)
		return(hKey);

	//
	// No such key in the container try to create one 
	//
    DWORD gle = GetLastError();
	if((gle == NTE_BAD_KEY) || (gle == NTE_NO_KEY))
	{
		TrTRACE(SECURITY, "Creating new key, PrivateKeySpec = %x", PrivateKeySpec);
		return(CrypGenKey(hCsp, PrivateKeySpec /* AT_SIGNATURE */));
	}
		
	TrERROR(SECURITY, "CryptGetUserKey and GenKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	)
/*++

Routine Description:
	Create initialized hash object 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - (in) hash algorithm

Returned Value:
	the initialized hash object

--*/
{
	//
	// Create the hash object.
	//
	HCRYPTHASH hHash;
	BOOL fSuccess = CryptCreateHash(
						hCsp, 
						AlgId, 
						0, 
						0, 
						&hHash
						); 
	
	if(fSuccess)
		return(hHash);

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptCreateHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CryHashData(
	const BYTE *Buffer, 
	DWORD BufferLen, 
	HCRYPTHASH hHash
	)
/*++

Routine Description:
	Perform data digest on a buffer and put the result in hash object.

Arguments:
    Buffer - Input data to be hashed/digest.
	BufferLen - Length of the input data.
	hHash - Hash object to put the result of the digested data.

Returned Value:
	None.

--*/
{
	//
	// Compute the cryptographic hash of the buffer.
	//
	BOOL fSuccess = CryptHashData(
						hHash, 
						Buffer, 
						BufferLen, 
						0
						); 

	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptHashData failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryGetHashData(
	const HCRYPTHASH hHash,
	DWORD *HashValLen
	)
/*++

Routine Description:
	Get the Hash value from a Hash object.
	after getting this value we can not use this Hash object again

Arguments:
	hHash - Hash object to put the result of the digested data.
	HashValLen - Length of the hash value.

Returned Value:
	Hash value of the Hash object.

--*/
{
	//
	// Get HashVal length
	//
	BOOL fSuccess = CryptGetHashParam(
						hHash, 
						HP_HASHVAL, 
						NULL, 
						HashValLen, 
						0
						); 

	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptGetHashParam failed Error=%x", gle);
		throw bad_CryptoApi(gle);
	}

	AP<BYTE> HashVal = new BYTE[*HashValLen];

	//
	// Get HashVal
	//
	fSuccess = CryptGetHashParam(
				   hHash, 
				   HP_HASHVAL, 
				   HashVal, 
				   HashValLen, 
				   0
				   ); 

	if(fSuccess)
		return(HashVal.detach());

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptGetHashParam failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryCalcHash(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD *HashLen
	)
/*++

Routine Description:
	Calc Hash buffer 
	this function return the HashData Buffer that was allocated in GetHashData function
	the caller is responsible to free this buffer


Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	HashLen - (out) Hash Value length

Returned Value:
    Hash Value

--*/
{
	//
	// Data digest
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	//
	// Get Hash Value
	//
	AP<BYTE> HashVal = CryGetHashData(
						   hHash,
						   HashLen
						   ); 

	return(HashVal.detach());
}


DWORD 
CrypSignatureLength(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	)
/*++

Routine Description:
	Determinate the signature length 

Arguments:
    hHash - Hash object to be singned
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.

Returned Value:
	Signature length

--*/
{
	//
	// Determine the size of the signature
	//
	DWORD SignLen= 0;
	BOOL fSuccess = CryptSignHash(
						hHash, 
						PrivateKeySpec, // AT_KEYEXCHANGE, // AT_SIGNATURE, 
						NULL, 
						0, 
						NULL, 
						&SignLen
						); 

	if(fSuccess)
		return(SignLen);

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptSignHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CrypSignHashData(
	BYTE* SignBuffer, 
	DWORD *SignBufferLen, 
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	)
/*++

Routine Description:
	Signed the hash data with the private key 

Arguments:
    SignBuffer - (out) the signature buffer of the digested message
	SignBufferLen - (out) length of the SignBuffer
	hHash - (in) Hash object containing the digest data to be signed.
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.

Returned Value:
	None.

--*/
{

	//
	// Sign the hash object.
	//
	BOOL fSuccess = CryptSignHash(
						hHash, 
						PrivateKeySpec, // AT_KEYEXCHANGE, // AT_SIGNATURE, 
						NULL, 
						0, 
						SignBuffer, 
						SignBufferLen
						); 
	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryptSignHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryCreateSignature(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec,
	DWORD* pSignLen
	)
/*++

Routine Description:
	Create the signature on a given hash object. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
	hHash - Hash object to put the result of the digested data.
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	pSignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
	//
	// Sign digested data 
	//
	*pSignLen = CrypSignatureLength(hHash, PrivateKeySpec);
    AP<BYTE> SignBuffer = new BYTE[*pSignLen];
	CrypSignHashData(
		SignBuffer, 
		pSignLen, 
		hHash,
		PrivateKeySpec
		);

	return(SignBuffer.detach());
}


BYTE* 
CryCreateSignature(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	DWORD* pSignLen
	)
/*++

Routine Description:
	Create the signature on a given buffer - digest, sign. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	pSignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
	//
	// Data digest
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	return CryCreateSignature(
				hHash,
				PrivateKeySpec,
				pSignLen
				);
}


bool 
CryValidateSignature(
	HCRYPTPROV hCsp,
	const BYTE* SignBuffer, 
	DWORD SignBufferLen, 
	const BYTE* Buffer,
	DWORD BufferLen,
	ALG_ID AlgId,
	HCRYPTKEY hKey
	)
/*++

Routine Description:
	Validate signature according to the signature buffer and the original
	data buffer that was signed.

Arguments:
    hCsp - handle to the crypto provider.
	SignBuffer - Signature Buffer.
	SignBufferLen - Length of SignBuffer.
	Buffer - Original Buffer that was signed.
	BufferLen - Length of Buffer.
	AlgId - (in) hash algorithm
	hKey - Key for unlocking the signature (signer public key)

Returned Value:
	True if Signature validation was succesful
	False if failure in validate the signature.

--*/
{
	//
	// Data digest on original buffer
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	BOOL fSuccess = CryptVerifySignature(
						hHash, 
						SignBuffer, 
						SignBufferLen, 
						hKey,
						NULL, 
						0
						); 

	return(fSuccess != 0);
}


void
CryGenRandom(
	BYTE* pOutRandom,
	DWORD len
	)
{
	ASSERT(pOutRandom != NULL);

	CCspHandle hProv;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptAcquireContext failed Error = %!winerr!", gle);
		throw bad_CryptoApi(gle);
    }


	BOOL fSuccess = CryptGenRandom(
						hProv, 
						len, 
						pOutRandom
						);

	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(SECURITY, "CryGenRandom failed Error = %!winerr!", gle);
	throw bad_CryptoApi(gle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cry\lib\cryinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryInit.cpp

Abstract:
    Cryptograph initialization

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cry.h"
#include "Cryp.h"

#include "cryinit.tmh"

VOID
CryInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Cryptograph library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Cryptograph library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!CrypIsInitialized());

    //
    // TODO: Write Cryptograph initalization code here
    //

    CrypSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cry\lib\crydebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryDebug.cpp

Abstract:
    Cryptograph debugging

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Cry.h"
#include "Cryp.h"

#include "crydebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Cryptograph state
//
void CrypAssertValid(void)
{
    //
    // CryInitalize() has *not* been called. You should initialize the
    // Cryptograph library before using any of its funcionality.
    //
    ASSERT(CrypIsInitialized());

    //
    // TODO:Add more Cryptograph validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void CrypSetInitialized(void)
{
    LONG fCryAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Cryptograph library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fCryAlreadyInitialized);
}


BOOL CrypIsInitialized(void)
{
    return s_fInitialized;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cry\lib\cryp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cryp.h

Abstract:
    Cryptograph private functions.

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

#ifdef _DEBUG

void CrypAssertValid(void);
void CrypSetInitialized(void);
BOOL CrypIsInitialized(void);

#else // _DEBUG

#define CrypAssertValid() ((void)0)
#define CrypSetInitialized() ((void)0)
#define CrypIsInitialized() TRUE

#endif // _DEBUG


HCRYPTKEY 
CrypGenKey(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	);


DWORD 
CrypSignatureLength(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	);


void 
CrypSignHashData(
	BYTE* SignBuffer, 
	DWORD *SignBufferLen, 
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\cry\test\crytest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryTest.cpp

Abstract:
    Cryptograph library test

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <xstr.h>
#include "Cry.h"

#include "CryTest.tmh"

//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText);
}


DWORD g_PrivateKeySpec = AT_SIGNATURE;
BOOL g_fErrorneous = false;


void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"
--*/
{
	
	if(argc == 1)
	{
		printf("Test AT_SIGNATURE Private Key\n");
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			TrERROR(SECURITY, "invalid option switch %lc, option switch should be - or /", argv[index][0]);
			g_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
			case 's':
			case 'S':
				g_PrivateKeySpec = AT_SIGNATURE;
				printf("Test AT_SIGNATURE Private Key\n");
				break;

			case 'x':
			case 'X':	
				g_PrivateKeySpec = AT_KEYEXCHANGE;
				printf("Test AT_KEYEXCHANGE Private Key\n");
				break;

			case 'H':	
			case 'h':
			case '?':
				g_fErrorneous = true;
				break;

			default:
				TrERROR(SECURITY, "invalid command line argument %ls", argv[index]);
				g_fErrorneous = true;
				return;
		};
	}

	return;
}


bool
CompareBuffers(
	const BYTE* pBuf1, 
	DWORD Buf1Size, 
	const BYTE* pBuf2, 
	DWORD Buf2Size
	)
/*++

Routine Description:
    Compare 2 buffers values

Arguments:
    pBuf1 - pointer to first buffer
	Buf1Size - first buffer size
	pBuf2 - pointer to second buffer
	Buf2Size - second buffer size

Returned Value:
    true if the buffers match, false if not

--*/
{
	//
	// Buffers must have same size 
	//
	if(Buf1Size != Buf2Size)
		return(false);

	return (memcmp(pBuf1, pBuf2, Buf2Size) == 0);
}


void TestCrypto(DWORD PrivateKeySpec, HCRYPTPROV hCsp)
/*++

Routine Description:
	Test various operations with CCrypto class

Arguments:
	PrivateKeySpec - Private Key type AT_SIGNATURE or AT_KEYEXCHANGE
	Crypto - crypto class for cryptograph operation

Returned Value:
	None.

--*/
{
	//
    // Testing Encrypt, Decrypt using Session key
    //
	AP<char> Buffer = newstr("Hello World");
	DWORD BufferLen = strlen(Buffer);

	printf("Original data: %.*s\n", BufferLen, reinterpret_cast<char*>(Buffer.get()));

	//
	// Generate Sessin key
	//
	CCryptKeyHandle hSessionKey(CryGenSessionKey(hCsp));

	//
	// Test signature operation
	//

	//
	// Sign data - CryCreateSignature on input buffer
	//
	DWORD SignLen;
	AP<BYTE> SignBuffer = CryCreateSignature(
							  hCsp,
							  reinterpret_cast<const BYTE*>(Buffer.get()), 
							  BufferLen,
							  CALG_SHA1,
							  PrivateKeySpec,
							  &SignLen
							  );

	printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer.get()));

	//
	// Validate signature
	//
	bool fValidSign = CryValidateSignature(
						  hCsp,
						  SignBuffer, 
						  SignLen, 
						  reinterpret_cast<const BYTE*>(Buffer.get()), 
						  BufferLen,
						  CALG_SHA1,
						  CryGetPublicKey(PrivateKeySpec, hCsp)
						  );

	printf("ValidSign = %d\n", fValidSign);
	ASSERT(fValidSign);

	//
	// Sign data - CryCreateSignature with input hash
	//

	//
	// Create Signature, create hash, calc hash, create signature on the given hash
	//
	CHashHandle hHash1 = CryCreateHash(
							hCsp, 
							CALG_SHA1
							);

	CryHashData(
		reinterpret_cast<const BYTE*>(Buffer.get()), 
		BufferLen,
		hHash1
		);

	AP<BYTE> SignBuff = CryCreateSignature(
								hHash1,
								PrivateKeySpec,
								&SignLen
								);

	printf("sign data: \n%.*s", SignLen, reinterpret_cast<char*>(SignBuff.get()));

	//
	// Validate signature
	//
	fValidSign = CryValidateSignature(
					  hCsp,
					  SignBuff, 
					  SignLen, 
					  reinterpret_cast<const BYTE*>(Buffer.get()), 
					  BufferLen,
					  CALG_SHA1,
					  CryGetPublicKey(PrivateKeySpec, hCsp)
					  );

	printf("ValidSign = %d\n", fValidSign);
	ASSERT(fValidSign);

	//
	// Test Hash operations
	//
	const LPCSTR xData = 
	"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	"            <Ref1Data>\r\n"
	"                This Is Reference Number 1\r\n" 
	"                msmq3 Reference test\r\n" 
	"            </Ref1Data>\r\n"
	"        </ReferenceObject1>\r\n";

	const LPCSTR xData1 = 
	"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	"            <Ref1Data>\r\n";

	const LPCSTR xData2 = 
	"                This Is Reference Number 1\r\n" 
	"                msmq3 Reference test\r\n" 
	"            </Ref1Data>\r\n"
	"        </ReferenceObject1>\r\n";

	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE*>(xData), 
							  strlen(xData),
							  CALG_SHA1,
							  &HashLen
							  );

	printf("HashBuffer (def prov) \n%.*s\n", HashLen, reinterpret_cast<char*>(HashBuffer.get()));

	CHashHandle hHash(CryCreateHash(hCsp, CALG_SHA1));

	CryHashData(
		reinterpret_cast<const BYTE*>(xData1), 
		strlen(xData1),
		hHash
		);

	CryHashData(
		reinterpret_cast<const BYTE*>(xData2), 
		strlen(xData2),
		hHash
		);

	DWORD HashLen1;
	AP<BYTE> HashVal = CryGetHashData(
						   hHash,
						   &HashLen1
						   ); 

	printf("HashBuffer (parts)\n%.*s\n", HashLen1, reinterpret_cast<char*>(HashVal.get()));

	//
	// Compare the 2 hash values - should be exactly the same
	//
	if(!CompareBuffers(HashVal, HashLen1, HashBuffer, HashLen))
	{
		TrERROR(SECURITY, "HashBuffers on full data and on parts of the data must be the same");
		throw bad_CryptoApi(ERROR);
	}


	CCspHandle hCsp1(CryAcquireCsp(MS_DEF_PROV));
	try
	{
		CCspHandle hCsp2(CryAcquireCsp(MS_ENHANCED_PROV));

		AP<BYTE> HashBuffer1 = CryCalcHash(
								   hCsp2,
								   reinterpret_cast<const BYTE*>(xData), 
								   strlen(xData),
								   CALG_SHA1,
								   &HashLen1
								   );

		printf("HashBuffer1 (enhanced prov) \n%.*s\n", HashLen1, reinterpret_cast<char*>(HashBuffer1.get()));

		//
		// Sign data using enhanced provider
		//
		AP<BYTE>SignBuffer1 = CryCreateSignature(
								  hCsp2,
								  reinterpret_cast<const BYTE*>(xData), 
								  strlen(xData),
								  CALG_SHA1,
								  PrivateKeySpec,
								  &SignLen
								  );

		printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer1.get()));

		//
		// Validate signature using enhanched provider
		//
		fValidSign = CryValidateSignature(
						 hCsp2,
						 SignBuffer1, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp2)
						 );

		printf("ValidSign enhanced (create by enhanced) = %d\n", fValidSign);

		//
		// Validate signature using default provider
		//
		fValidSign = CryValidateSignature(
						 hCsp1,
						 SignBuffer1, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp2)
						 );

		printf("ValidSign default (create by enhanced) = %d\n", fValidSign);

		//
		// Sign data using default provider
		//
		AP<BYTE>SignBuffer2 = CryCreateSignature(
								  hCsp1,
								  reinterpret_cast<const BYTE*>(xData), 
								  strlen(xData),
								  CALG_SHA1,
								  PrivateKeySpec,
								  &SignLen
								  );

		printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer2.get()));

		//
		// Validate signature using enhanced provider
		//
		fValidSign = CryValidateSignature(
						 hCsp2,
						 SignBuffer2, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp1)
						 );

		printf("ValidSign enhanced (create by default) = %d\n", fValidSign);

		//
		// Validate signature using default provider
		//
		fValidSign = CryValidateSignature(
						 hCsp1,
						 SignBuffer2, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp1)
						 );

		printf("ValidSign default (create by default) = %d\n", fValidSign);


		//
		//Test random bytes generation
		//
		BYTE Random[128];
		memset(Random, 0, sizeof(Random));
		CryGenRandom(
		Random,
		sizeof(Random)
		);

	}

	
	catch (const bad_CryptoProvider&)
	{
		printf("skip the enhanced provider tests\n");
		return;
	}

}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Cryptograph library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

	SetActivation(argc, argv);

	if(g_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    CryInitialize();

	try
	{
		CCspHandle hCsp(CryAcquireCsp(MS_DEF_PROV));
//		CCspHandle hCsp(CryAcquireCsp(MS_ENHANCED_PROV));


		CCryptKeyHandle hPbKey = CryGetPublicKey(g_PrivateKeySpec, hCsp);

		TestCrypto(g_PrivateKeySpec, hCsp);
	}
	catch (const bad_CryptoProvider& badCspEx)
	{
		TrERROR(SECURITY, "bad Crypto Service Provider Excption ErrorCode = %x", badCspEx.error());
		return(-1);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(SECURITY, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());
		return(-1);
	}

    WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\dldinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    DldInit.cpp

Abstract:
    MSMQ DelayLoad failure handler initialization

Author:
    Conrad Chang (conradc) 12-Apr-01

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Dldp.h"
#include "Dld.h"


#include "dldInit.tmh"




VOID
WINAPI
DldpAssertDelayLoadFailureMapsAreNotSorted(VOID)
{
//
// Leave the function existing in free builds for binary compat on mixed checked/free,
// since the checked in .lib is only free.
#ifdef _DEBUG 
UINT    iDll, iProcName, iOrdinal;
INT     nRet;
WCHAR   wszBuffer[1024];

const DLOAD_DLL_ENTRY*      pDll;
const DLOAD_PROCNAME_MAP*   pProcNameMap;
const DLOAD_ORDINAL_MAP*    pOrdinalMap;

    for (iDll = 0;
         iDll < g_DllMap.NumberOfEntries;
         iDll++)
    {
        if (iDll >= 1)
        {
            nRet = strcmp(g_DllMap.pDllEntry[iDll].pszDll,
                          g_DllMap.pDllEntry[iDll-1].pszDll);

            //
            // If the DLL name is out of order, write the message to the debugger
            // and ASSERT
            //
            if(nRet <= 0)
            {
                wsprintf(wszBuffer, L"dload: rows %u and %u are out of order in dload!g_DllMap",
                        iDll-1, iDll);
                OutputDebugString(wszBuffer);
                ASSERT(FALSE);
                       
            }
        }

        pDll = g_DllMap.pDllEntry + iDll;
        pProcNameMap = pDll->pProcNameMap;
        pOrdinalMap  = pDll->pOrdinalMap;

        if (pProcNameMap)
        {
            ASSERT(pProcNameMap->NumberOfEntries);

            for (iProcName = 0;
                 iProcName < pProcNameMap->NumberOfEntries;
                 iProcName++)
            {
                if (iProcName >= 1)
                {
                    nRet = strcmp(pProcNameMap->pProcNameEntry[iProcName].pszProcName,
                                  pProcNameMap->pProcNameEntry[iProcName-1].pszProcName);


                    if (nRet <= 0)
                    {
                        wsprintf(wszBuffer, 
                                L"dload: rows %u and %u of pProcNameMap are out of order in dload!g_DllMap for pszDll=%hs",
                                iProcName-1, iProcName, pDll->pszDll);
                        OutputDebugString(wszBuffer);
                        ASSERT(FALSE);
                               
                    }
                }
            }
        }

        if (pOrdinalMap)
        {
            ASSERT(pOrdinalMap->NumberOfEntries);

            for (iOrdinal = 0;
                 iOrdinal < pOrdinalMap->NumberOfEntries;
                 iOrdinal++)
            {
                if (iOrdinal >= 1)
                {
                    if (pOrdinalMap->pOrdinalEntry[iOrdinal].dwOrdinal <=
                        pOrdinalMap->pOrdinalEntry[iOrdinal-1].dwOrdinal)
                    {
                        wsprintf(wszBuffer, 
                                L"dload: rows %u and %u of pOrdinalMap are out of order in dload!g_DllMap for pszDll=%hs",
                                iOrdinal-1, iOrdinal, pDll->pszDll);

                        OutputDebugString(wszBuffer);
                        ASSERT(FALSE);

                    }
                }
            }
        }
    }
#endif
}













VOID
DldInitialize( )
/*++

Routine Description:
    Initializes MSMQ DelayLoad failure handler library

Arguments:
    None.

Returned Value:
    None.

--*/
{

    //
    // Validate that the MSMQ DelayLoad failure handler library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!DldpIsInitialized());
    DldpRegisterComponent();

    //
    // In debug build, verify the maps are sorted
    // If the maps are not sorted, throw an assert
    //
    DldpAssertDelayLoadFailureMapsAreNotSorted();      

    //
    // we assume DELAYLOAD_VERSION >= 0x0200
    // so define __pfnDliFailureHook2 should be enough
    //    
    __pfnDliFailureHook2 = DldpDelayLoadFailureHook;

    DldpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\dlddebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    dldDebug.cpp

Abstract:
    MSMQ DelayLoad failure handler debugging

Author:
    Conrad Chang (conradc) 12-Apr-01

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Dldp.h"
#include "Dld.h"


#include "DldDebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate MSMQ DelayLoad failure handler state
//
void DldpAssertValid(void)
{
    //
    // DldInitalize() has *not* been called. You should initialize the
    // MSMQ DelayLoad failure handler library before using any of its funcionality.
    //
    ASSERT(DldpIsInitialized());

    //
    // TODO:Add more MSMQ DelayLoad failure handler validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void DldpSetInitialized(void)
{
    LONG fDldAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The MSMQ DelayLoad failure handler library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fDldAlreadyInitialized);
}


BOOL DldpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
void DldpRegisterComponent(void)
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\dldp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Dldp.h

Abstract:
    MSMQ DelayLoad failure handler private functions.

Author:
    Conrad Chang (conradc) 12-Apr-01

--*/

#pragma once

#ifndef _MSMQ_dldp_H_
#define _MSMQ_dldp_H_
#include <delayimp.h>

#ifdef _DEBUG

void DldpAssertValid(void);
void DldpSetInitialized(void);
BOOL DldpIsInitialized(void);
void DldpRegisterComponent(void);


#else // _DEBUG

#define DldpAssertValid() ((void)0)
#define DldpSetInitialized() ((void)0)
#define DldpIsInitialized() TRUE
#define DldpRegisterComponent() ((void)0)

#endif // _DEBUG

//
// External function prototypes
//
extern FARPROC  WINAPI  DldpDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC          DldpLookupHandler (LPCSTR pszDllName, LPCSTR pszProcName);
extern FARPROC  WINAPI  DldpDelayLoadFailureHandler (LPCSTR pszDllName, LPCSTR pszProcName);

const char szNotExistProcedure[] = "ThisProcedureMustNotExist_ConradC";

#endif // _MSMQ_dldp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\mqdload.cpp ===
#include <libpch.h>
#include "dldp.h"








// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// NOTE: 
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


FARPROC  WINAPI  DldpDelayLoadFailureHook(UINT           unReason,
					                      PDelayLoadInfo pDelayInfo)
{
FARPROC ReturnValue = NULL;
static  HMODULE hModule=NULL;

    //
    // For a failed LoadLibrary, we will return the HINSTANCE of this DLL.
    // This will cause the loader to try a GetProcAddress on our DLL for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    //
    if (dliFailLoadLib == unReason)
    {
        //
        // Obtain the module handle if we don't have it yet
        //
        if(!hModule)
        {
            hModule = GetModuleHandle(NULL);
        }

        ReturnValue = (FARPROC)hModule;

        if (!pDelayInfo->dlp.fImportByName)
        {
            //
            // HACKHACK (reinerf)
            //
            // For ORDINAL delayload failures we cannot just return our base addr and be done with everything.
            // The problem is that the linker stub code will turn around and call GetProcAddress() some random
            // ordinal in our module which probably exists and definately NOT (pDelayInfo->szDll)!(pDelayInfo->dlp.dwOrdinal)
            //
            // So to get around this problem we will stash the ordinal# in the pDelayInfo->pfnCur field and slam the
            // procedure name to "ThisProcedureMustNotExistInMQRT"
            //
            // This will cause the GetProcAddress to fail, at which time our failure hook should be called again and we can then
            // undo the hack below and return the proper function address.
            //
            pDelayInfo->pfnCur = (FARPROC)(DWORD_PTR)pDelayInfo->dlp.dwOrdinal;
            pDelayInfo->dlp.fImportByName = TRUE;
            pDelayInfo->dlp.szProcName = szNotExistProcedure;
        }
    }
    else if (dliFailGetProc == unReason)
    {
        //
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        // If we don't find it, we'll assert with a message about the missing
        // handler.
        //
        FARPROC pfnHandler;

        //
        // HACKHACH (reinerf) -- see above comments...
        //
        if (pDelayInfo->dlp.fImportByName && lstrcmpA(pDelayInfo->dlp.szProcName, szNotExistProcedure) == 0)
        {
            pDelayInfo->dlp.dwOrdinal = (DWORD)(DWORD_PTR)pDelayInfo->pfnCur;
            pDelayInfo->pfnCur = NULL;
            pDelayInfo->dlp.fImportByName = FALSE;
        }

        // Try to find an error handler for the DLL/procedure.
        pfnHandler = DldpDelayLoadFailureHandler(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        if (pfnHandler)
        {
            //
            // Do this on behalf of the handler now that it is about to
            // be called.
            //
            SetLastError (ERROR_MOD_NOT_FOUND);
        }

        ReturnValue = pfnHandler;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\dload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L O A D . C
//
//  Contents:   Delay Load Failure Hook
//
//  Author:     conradc   24 April 2001
//
//----------------------------------------------------------------------------

#include <libpch.h>
#include "tr.h"
#include "dldp.h"

#include "dload.tmh"

//+---------------------------------------------------------------------------
//
//
FARPROC
WINAPI
DldpDelayLoadFailureHandler (LPCSTR pszDllName,
                           LPCSTR pszProcName)
{
FARPROC ReturnValue = NULL;

    ASSERT (pszDllName);
    ASSERT (pszProcName);  


    // Trace some potentially useful information about why we were called.
    //
    if (!IS_INTRESOURCE(pszProcName))
    {
        TrERROR(GENERAL, 
                "DldLIBDelayloadFailureHook: Dll=%hs, ProcName=%hs", 
                 pszDllName, 
                 pszProcName);
        
    }
    else
    {
        TrERROR(GENERAL, 
                "DldpDelayLoadFailureHandler: Dll=%s, Ordinal=%u\n",
                pszDllName,
                (DWORD)((DWORD_PTR)pszProcName));

        
    }


    ReturnValue = DldpLookupHandler(pszDllName, pszProcName);

    if (ReturnValue)
    {
        TrERROR(GENERAL, 
                "Returning handler function at address 0x%x",
                (int)((LONG_PTR)ReturnValue));


    }
    else
    {
        if (!IS_INTRESOURCE(pszProcName))
        {
            TrERROR(GENERAL,
                    "No delayload handler found for Dll=%hs, ProcName=%hs\n Please add one in private\\dload.",
                     pszDllName, 
                     pszProcName);

            
        }
        else
        {
            TrERROR(GENERAL, 
                    "No delayload handler found for Dll=%hs, Ordinal=%u\n Please add one in private\\dload.",
                    pszDllName,
                    (DWORD)((DWORD_PTR)pszProcName));
        }
    }


    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\lookup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L O O K U P . C P P
//
//  Contents:   Routines to find a handler for a DLL procedure.
//
//  Author:     conradc    24 April 2001
//
//  Borrowed from Original Source:  %SDXROOT%\MergedComponents\dload\dload.c
//
//----------------------------------------------------------------------------

#include <libpch.h>
#include "dld.h"
#include "dldp.h"
#include "strsafe.h"

#include "lookup.tmh"

extern "C" 
{
     FARPROC DelayLoadFailureHook(LPCSTR ,LPCSTR);
}

const DLOAD_DLL_ENTRY*FindDll(LPCSTR pszDll)
{
const   DLOAD_DLL_ENTRY* pDll = NULL;
CHAR    pszDllLowerCased [MAX_PATH + 1];
INT     nResult;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT(pszDll);
    ASSERT(strlen (pszDll) <= MAX_PATH);

    HRESULT hr = StringCchCopyA(pszDllLowerCased, TABLE_SIZE(pszDllLowerCased), pszDll);
    if(FAILED(hr))return NULL;

    _strlwr (pszDllLowerCased);

    iLow = 0;
    iHigh = g_DllMap.NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszDllLowerCased, g_DllMap.pDllEntry[iMiddle].pszDll);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            pDll = &g_DllMap.pDllEntry[iMiddle];
            break;
        }
    }
    return pDll;
}

FARPROC
DldpLookupHandlerByName (LPCSTR   pszProcName,
                     const DLOAD_PROCNAME_MAP*   pMap)
{
FARPROC pfnHandler = NULL;
INT     nResult;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT(pszProcName);
    ASSERT(pMap);

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszProcName,
                          pMap->pProcNameEntry[iMiddle].pszProcName);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            pfnHandler = pMap->pProcNameEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
DldpLookupHandlerByOrdinal (DWORD                       dwOrdinal,
                            const DLOAD_ORDINAL_MAP*    pMap)
{
FARPROC pfnHandler = NULL;
DWORD   dwOrdinalProbe;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and dwOrdinal < dwOrdinalProbe.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        dwOrdinalProbe = pMap->pOrdinalEntry[iMiddle].dwOrdinal;

        if (dwOrdinal < dwOrdinalProbe)
        {
            iHigh = iMiddle - 1;
        }
        else if (dwOrdinal > dwOrdinalProbe)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            ASSERT (dwOrdinal == dwOrdinalProbe);
            pfnHandler = pMap->pOrdinalEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
DldpLookupHandler(LPCSTR pszDllName,
                  LPCSTR pszProcName)
{
FARPROC                 pfnHandler = NULL;
const DLOAD_DLL_ENTRY*  pDll;

    ASSERT (pszDllName);
    ASSERT (pszProcName);

    //
    // Find the DLL record if we have one.
    //
    pDll = FindDll (pszDllName);
    if (pDll)
    {
        //
        // Now find the handler whether it be by name or ordinal.
        //
        if (!IS_INTRESOURCE(pszProcName) &&
            pDll->pProcNameMap)
        {
            pfnHandler = DldpLookupHandlerByName (pszProcName,
                                                  pDll->pProcNameMap);
        }
        else if (pDll->pOrdinalMap)
        {
            pfnHandler = DldpLookupHandlerByOrdinal (PtrToUlong(pszProcName),
                                                     pDll->pOrdinalMap);
        }
    }
    else
    {
/*
        //
        // If we can't find the DLL, forward the call the kernel32.dll
        // and have it handle the call
        // 
        typedef FARPROC (WINAPI *KERNEL32DLOADPROC)(LPCSTR ,LPCSTR);
        HMODULE hMod = GetModuleHandle(L"kernel32.dll");
        if(hMod)
        {
        KERNEL32DLOADPROC pKernel32DLoadHandler = (KERNEL32DLOADPROC)GetProcAddress(hMod,
		     							      			                            "DelayLoadFailureHook");

            if(pKernel32DLoadHandler)
            {
                pfnHandler = pKernel32DLoadHandler(pszDllName, pszProcName);
                TrERROR(GENERAL, 
                        "MQDelayLoadHandler redirect the unload DLL to kernel32 DelayLoadFailureHook: Dll=%hs", 
                         pszDllName);
            }
        }
*/
    //
    // Function declaration for a function that we will use from kernl32p.lib
    //
    

        
        pfnHandler = DelayLoadFailureHook(pszDllName, pszProcName);

        TrTRACE(GENERAL,
                "Unable to provide failure handling for module '%hs', redirects to kernel32 DelayLoadFailureHook and return function pointer = 0x%x", 
                pszDllName, (int)((LONG_PTR)pfnHandler));
    }

    return pfnHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dldtest.cpp ===
// Depcreate.cpp : Defines the entry point for the console application.
//

#include "libpch.h"
#include "windows.h"
#include <wchar.h>
#include "ntregapi.h"
#include "tr.h"
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include "mqcert.h"
#include "rtdep.h"
#include "cm.h"
#include "dld.h"
#include "dldtest.h"
#include "..\testdll\testdll.h"


int _cdecl main(int , char* [])
{
HRESULT hr;

    CmInitialize(HKEY_LOCAL_MACHINE, L"", KEY_ALL_ACCESS);
    DldInitialize();
    

    hr = DepCreateQueue(NULL, NULL, NULL, NULL);
    printf("return code from DepCreateQueue call = 0x%x\n", hr);

    hr = DepDeleteQueue(NULL);
    printf("return code from DepDeleteQuue call = 0x%x\n", hr);
    
    hr = DepLocateBegin(NULL, NULL, NULL, NULL, 0);
    printf("return code from DepLocateBegin call = 0x%x\n", hr);


    hr = DepLocateNext(NULL, NULL, NULL);
    printf("return code from DepLocateNext call = 0x%x\n", hr);
    
    hr = DepLocateEnd(NULL);
    printf("return code from DepLocateEnd call = 0x%x\n", hr);

    hr = DepOpenQueue(NULL, 0, 0, NULL);
    printf("return code from DepOpenQueue call = 0x%x\n", hr);
    
    hr = DepSendMessage(NULL, NULL, NULL);
    printf("return code from DepSendMessage call = 0x%x\n", hr);    

    hr = DepReceiveMessage(NULL, 0, 0,NULL, NULL, NULL, NULL, NULL);
    printf("return code from DepReceiveMessage call = 0x%x\n", hr);        

    hr = DepCreateCursor(NULL ,NULL);
    printf("return code from DepCreateCursor call = 0x%x\n", hr);    
    
    hr = DepCloseCursor( NULL );
    printf("return code from DepCloseCursor call = 0x%x\n", hr);    
    
    hr = DepCloseQueue(NULL);
    printf("return code from DepCloseQueue call = 0x%x\n", hr);    
    
    hr = DepSetQueueProperties(NULL , NULL );
    printf("return code from DepSetQueueProperties call = 0x%x\n", hr);    
    

    hr = DepGetQueueProperties(NULL, NULL );
    printf("return code from DepGetQueueProperties call = 0x%x\n", hr);    
    


    hr = DepGetQueueSecurity(NULL, NULL, NULL, 0, NULL );
    printf("return code from DepGetQueueSecurity call = 0x%x\n", hr);    


    hr = DepSetQueueSecurity(NULL , NULL, NULL);
    printf("return code from DepSetQueueSecurity call = 0x%x\n", hr);        


    hr = DepPathNameToFormatName(NULL, NULL, NULL );
    printf("return code from DepPathNameToFormatName call = 0x%x\n", hr);    

 
    hr = DepHandleToFormatName(NULL, NULL, NULL);
    printf("return code from DepHandleToFormatName call = 0x%x\n", hr);        


    hr = DepInstanceToFormatName(NULL, NULL, NULL );
    printf("return code from DepInstanceToFormatName call = 0x%x\n", hr);    

    
    DepFreeMemory(NULL);
    printf("return code from DepFreeMemory call = 0x%x\n", hr);    


    hr = DepGetMachineProperties(NULL, NULL, NULL );
    printf("return code from DepGetMachineProperties call = 0x%x\n", hr);    


    hr = DepGetSecurityContext(NULL, 0, NULL );
    printf("return code from DepGetSecurityContext call = 0x%x\n", hr);        


    DepFreeSecurityContext(NULL );
    printf("return code from DepFreeSecurityContext call = 0x%x\n", hr);    


    hr = DepRegisterCertificate(0, NULL, 0   );
    printf("return code from DepRegisterCertificate call = 0x%x\n", hr);    


    hr = DepRegisterServer();
    printf("return code from DepRegisterServer call = 0x%x\n", hr);    

    
	hr = DepBeginTransaction(NULL);
    printf("return code from DepBeginTransaction call = 0x%x\n", hr);       


    hr = DepGetOverlappedResult(NULL );
    printf("return code from DepGetOverlappedResult call = 0x%x\n", hr);        


    hr = DepGetPrivateComputerInformation(NULL, NULL );
    printf("return code from DepGetPrivateComputerInformation call = 0x%x\n", hr);        


    hr = DepPurgeQueue(NULL );
    printf("return code from DepPurgeQueue call = 0x%x\n", hr);    



    hr = DepMgmtGetInfo((unsigned short *)1, (unsigned short *)1, (MQMGMTPROPS *)1 );
    printf("return code from DepMgmtGetInfo call = 0x%x\n", hr);    

	hr = DepXactGetDTC(NULL);
    printf("return code from DepXactGetDTC call = 0x%x\n", hr);    

//
// The following functions are exported by DepRTDEP.DLL but not used by DepRT.DLL
//



    hr = DepGetUserCerts(NULL, NULL, NULL); 
    printf("return code from DepGetUserCerts call = 0x%x\n", hr);    

 
    hr = DepGetSecurityContextEx(NULL, 0, NULL);
    printf("return code from DepGetSecurityContextEx call = 0x%x\n", hr);    

    hr = DepOpenInternalCertStore(NULL, NULL, FALSE, FALSE, NULL);
    printf("return code from DepOpenInternalCertStore call = 0x%x\n", hr);    

    hr = DepGetInternalCert(NULL, NULL, FALSE, FALSE, NULL);
    printf("return code from DepGetInternalCert call = 0x%x\n", hr);    


    hr = DepRegisterUserCert(NULL, FALSE);
    printf("return code from DepRegisterUserCert call = 0x%x\n", hr);    


    hr = DepRemoveUserCert(NULL); 
    printf("return code from DepRemoveUserCert call = 0x%x\n", hr);    


    hr = DepMgmtAction((const unsigned short *)1, (const unsigned short *)1, (const unsigned short *)1 );
    printf("return code from DepMgmtAction call = 0x%x\n", hr);    


    hr = DepGetUserCerts(NULL, NULL, NULL);
    printf("return code from DepGetUserCerts call = 0x%x\n", hr);    

    // Check for the second delay load DLL
    TCHAR *pData = NULL;

    pData = TestDLLInit();
    if(pData)
    {
        printf("TestDLLInit returns = %ls", pData);
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\lib\rtdep.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rtdep.cpp

Abstract:

    The following code implement Delay Load Failure Hook for mqrtdep.dll in lib/dld/lib.
    When LoadLibrary or GetProcAddress failure, it will call one of the following stub functions as if it
    is the function intented, and returns our error code, i.e. MQ_ERROR_DELAYLOAD_MQRTDEP and 
    set the lasterror accordingly.  

To Use:
    In your sources file, right after you specify the modules you
    are delayloading 
     
     do:
        DLOAD_ERROR_HANDLER=MQDelayLoadFailureHook
        link with $(MSMQ_LIB_PATH)\dld.lib

DelayLoad Reference:
    code sample: %SDXROOT%\MergedComponents\dload\dload.c
    Contact: Reiner Fink (reinerf)

Author:

    Conrad Chang (conradc) 12-April-2001

Revision History:

--*/

#include <libpch.h>
#include "mqsymbls.h"
#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include <rt.h>
#include "mqcert.h"
#include "dld.h"

#include "rtdep.tmh"

////////////////////////////////////////////////////////////////////////
//
//  Stub functions below implements all the MQRTDEP.DLL export functions.
//
////////////////////////////////////////////////////////////////////////

HRESULT
APIENTRY
DepCreateQueue(
    IN PSECURITY_DESCRIPTOR /* pSecurityDescriptor */,
    IN OUT MQQUEUEPROPS* /* pQueueProps */,
    OUT LPWSTR /* lpwcsFormatName */,
    IN OUT LPDWORD /* lpdwFormatNameLength */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepDeleteQueue(
    IN LPCWSTR /* lpwcsFormatName */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepLocateBegin(
    IN LPCWSTR /* lpwcsContext */,
    IN MQRESTRICTION* /* pRestriction */,
    IN MQCOLUMNSET* /* pColumns */,
    IN MQSORTSET* /* pSort */,
    OUT PHANDLE /* phEnum */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepLocateNext(
    IN HANDLE /* hEnum */,
    IN OUT DWORD* /* pcProps */,
    OUT MQPROPVARIANT /* aPropVar */[]
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepLocateEnd(
    IN HANDLE /* hEnum */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepOpenQueue(
    IN LPCWSTR /* lpwcsFormatName */,
    IN DWORD /* dwAccess */,
    IN DWORD /* dwShareMode */,
    OUT QUEUEHANDLE* /* phQueue */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepSendMessage(
    IN QUEUEHANDLE /* hDestinationQueue */,
    IN MQMSGPROPS* /* pMessageProps */,
    IN ITransaction* /* pTransaction */
	)
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepReceiveMessage(
    IN QUEUEHANDLE /* hSource */,
    IN DWORD /* dwTimeout */,
    IN DWORD /* dwAction */,
    IN OUT MQMSGPROPS* /* pMessageProps */,
    IN OUT LPOVERLAPPED /* lpOverlapped */,
    IN PMQRECEIVECALLBACK /* fnReceiveCallback */,
    IN HANDLE /* hCursor */,
    IN ITransaction* /* pTransaction */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepCreateCursor(
    IN QUEUEHANDLE /* hQueue */,
    OUT PHANDLE /* phCursor */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepCloseCursor(
    IN HANDLE /* hCursor */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepCloseQueue(
    IN HANDLE /* hQueue */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepSetQueueProperties(
    IN LPCWSTR /* lpwcsFormatName */,
    IN MQQUEUEPROPS* /* pQueueProps */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepGetQueueProperties(
    IN LPCWSTR /* lpwcsFormatName */,
    OUT MQQUEUEPROPS* /* pQueueProps */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepGetQueueSecurity(
    IN LPCWSTR /* lpwcsFormatName */,
    IN SECURITY_INFORMATION /* RequestedInformation */,
    OUT PSECURITY_DESCRIPTOR /* pSecurityDescriptor */,
    IN DWORD /* nLength */,
    OUT LPDWORD /* lpnLengthNeeded */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepSetQueueSecurity(
    IN LPCWSTR /* lpwcsFormatName */,
    IN SECURITY_INFORMATION /* SecurityInformation */,
    IN PSECURITY_DESCRIPTOR /* pSecurityDescriptor */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepPathNameToFormatName(
    IN LPCWSTR /* lpwcsPathName */,
    OUT LPWSTR /* lpwcsFormatName */,
    IN OUT LPDWORD /* lpdwFormatNameLength */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepHandleToFormatName(
    IN QUEUEHANDLE /* hQueue */,
    OUT LPWSTR /* lpwcsFormatName */,
    IN OUT LPDWORD /* lpdwFormatNameLength */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepInstanceToFormatName(
    IN GUID* /* pGuid */,
    OUT LPWSTR /* lpwcsFormatName */,
    IN OUT LPDWORD /* lpdwFormatNameLength */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

void
APIENTRY
DepFreeMemory(
    IN PVOID /* pvMemory */
    )
{
}

HRESULT
APIENTRY
DepGetMachineProperties(
    IN LPCWSTR /* lpwcsMachineName */,
    IN const GUID* /* pguidMachineId */,
    IN OUT MQQMPROPS* /* pQMProps */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepGetSecurityContext(
    IN PVOID /* lpCertBuffer */,
    IN DWORD /* dwCertBufferLength */,
    OUT HANDLE* /* hSecurityContext */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT 
APIENTRY
DepGetSecurityContextEx( 
	LPVOID /* lpCertBuffer */,
    DWORD /* dwCertBufferLength */,
    HANDLE* /* hSecurityContext */
	)
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


void
APIENTRY
DepFreeSecurityContext(
    IN HANDLE /* hSecurityContext */
    )
{
}

HRESULT
APIENTRY
DepRegisterCertificate(
    IN DWORD /* dwFlags */,
    IN PVOID /* lpCertBuffer */,
    IN DWORD /* dwCertBufferLength */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepRegisterServer(
	VOID
	)
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepBeginTransaction(
    OUT ITransaction** /* ppTransaction */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepGetOverlappedResult(
    IN LPOVERLAPPED /* lpOverlapped */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepGetPrivateComputerInformation(
    IN LPCWSTR /* lpwcsComputerName */,
    IN OUT MQPRIVATEPROPS* /* pPrivateProps */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepPurgeQueue(
    IN HANDLE /* hQueue */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepMgmtGetInfo(
    IN LPCWSTR /* pMachineName */,
    IN LPCWSTR /* pObjectName */,
    IN OUT MQMGMTPROPS* /* pMgmtProps */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepMgmtAction(
    IN LPCWSTR /* pMachineName */,
    IN LPCWSTR /* pObjectName */,
    IN LPCWSTR /* pAction */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepXactGetDTC(
	OUT IUnknown** /* ppunkDTC */
	)
{
	return MQ_ERROR_DELAYLOAD_FAILURE;
}

//
// from rtdepcert.h
//

HRESULT
APIENTRY
DepCreateInternalCertificate(
    OUT CMQSigCertificate** /* ppCert */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}

HRESULT
APIENTRY
DepDeleteInternalCert(
    IN CMQSigCertificate* /* pCert */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepOpenInternalCertStore(
    OUT CMQSigCertStore** /* pStore */,
    IN LONG* /* pnCerts */,
    IN BOOL /* fWriteAccess */,
    IN BOOL /* fMachine */,
    IN HKEY /* hKeyUser */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepGetInternalCert(
    OUT CMQSigCertificate** /* ppCert */,
    OUT CMQSigCertStore** /* ppStore */,
    IN  BOOL /* fGetForDelete */,
    IN  BOOL /* fMachine */,
    IN  HKEY /* hKeyUser */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepRegisterUserCert(
    IN CMQSigCertificate* /* pCert */,
    IN BOOL /* fMachine */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepGetUserCerts(
    CMQSigCertificate** /* ppCert */,
    DWORD* /* pnCerts */,
    PSID /* pSidIn */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}


HRESULT
APIENTRY
DepRemoveUserCert(
    IN CMQSigCertificate* /* pCert */
    )
{
    return MQ_ERROR_DELAYLOAD_FAILURE;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mqrtdep)
{
    DLPENTRY(DepBeginTransaction)
    DLPENTRY(DepCloseCursor)
    DLPENTRY(DepCloseQueue)
    DLPENTRY(DepCreateCursor)
    DLPENTRY(DepCreateInternalCertificate)
    DLPENTRY(DepCreateQueue)
    DLPENTRY(DepDeleteInternalCert)
    DLPENTRY(DepDeleteQueue)
    DLPENTRY(DepFreeMemory)
    DLPENTRY(DepFreeSecurityContext)
    DLPENTRY(DepGetInternalCert)
    DLPENTRY(DepGetMachineProperties)
    DLPENTRY(DepGetOverlappedResult)
    DLPENTRY(DepGetPrivateComputerInformation)
    DLPENTRY(DepGetQueueProperties)
    DLPENTRY(DepGetQueueSecurity)
    DLPENTRY(DepGetSecurityContext)
    DLPENTRY(DepGetSecurityContextEx)
    DLPENTRY(DepGetUserCerts)
    DLPENTRY(DepHandleToFormatName)
    DLPENTRY(DepInstanceToFormatName)
    DLPENTRY(DepLocateBegin)
    DLPENTRY(DepLocateEnd)
    DLPENTRY(DepLocateNext)
    DLPENTRY(DepMgmtAction)
    DLPENTRY(DepMgmtGetInfo)
    DLPENTRY(DepOpenInternalCertStore)
    DLPENTRY(DepOpenQueue)
    DLPENTRY(DepPathNameToFormatName)
    DLPENTRY(DepPurgeQueue)
    DLPENTRY(DepReceiveMessage)
    DLPENTRY(DepRegisterCertificate)    
    DLPENTRY(DepRegisterServer)    
    DLPENTRY(DepRegisterUserCert)
    DLPENTRY(DepRemoveUserCert)
    DLPENTRY(DepSendMessage)
    DLPENTRY(DepSetQueueProperties)
    DLPENTRY(DepSetQueueSecurity)
    DLPENTRY(DepXactGetDTC)
};


DEFINE_PROCNAME_MAP(mqrtdep)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dllmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     conradc   12 April 2001
//              Originated from %sdxroot%\MergedComponents\dload\dllmap.c
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "windows.h"
#include "dld.h"



//
// All of the dll's that dld.lib supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)

DECLARE_PROCNAME_MAP(mqrtdep)




const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // must be in alphabetical increasing order 
    DLDENTRYP(mqrtdep)
};


const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\testdll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	testdll.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dldtest.h ===
HRESULT
APIENTRY
DepGetUserCerts(CMQSigCertificate **,
                             DWORD              *,
                             PSID                );


HRESULT APIENTRY
DepGetSecurityContextEx(LPVOID  ,
                                     DWORD   ,
                                     HANDLE *);


HRESULT
APIENTRY
DepOpenInternalCertStore(OUT CMQSigCertStore **,
                                      IN  LONG            *,
                                      IN  BOOL            ,
                                      IN  BOOL            ,
                                      IN  HKEY            );

HRESULT
APIENTRY
DepGetInternalCert(OUT CMQSigCertificate **,
                                OUT CMQSigCertStore   **,
                                IN  BOOL              ,
                                IN  BOOL              ,
                                IN  HKEY              );

HRESULT  DepCreateInternalCertificate(OUT CMQSigCertificate **);


HRESULT  DepDeleteInternalCert(IN CMQSigCertificate *);


HRESULT
APIENTRY
DepRegisterUserCert(IN CMQSigCertificate *,
                                 IN BOOL               );


HRESULT
APIENTRY
DepRemoveUserCert(IN CMQSigCertificate *);


HRESULT
APIENTRY
DepMgmtAction(IN LPCWSTR ,
                           IN LPCWSTR ,
                           IN LPCWSTR );

HRESULT APIENTRY
DepGetSecurityContextEx(LPVOID  ,
                                     DWORD   ,
                                     HANDLE *);

HRESULT
APIENTRY
DepMgmtGetInfo(IN LPCWSTR ,
                            IN LPCWSTR ,
                            IN OUT MQMGMTPROPS* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\dldtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqcreate.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\testdll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_)
#define AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\dldtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_)
#define AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\testdll\testdll.h ===
#ifndef _TESTDLL_
#define _TESTDLL_

TCHAR * WINAPI TestDLLInit();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\dld\test\testdll\testdll.cpp ===
// testdll.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE , 
                       DWORD , 
                       LPVOID 
					 )
{
    return TRUE;
}

TCHAR   szData[]=L"TestDLL";

TCHAR *WINAPI TestDLLInit()
{
    return szData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\empty_project\lib\ep.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ep.h

Abstract:
    Empty Project public interface

Author:
    Erez Haba (erezh) 13-Aug-65

--*/

#pragma once

#ifndef _MSMQ_Ep_H_
#define _MSMQ_Ep_H_


VOID
EpInitialize(
    *Parameters*
    );



#endif // _MSMQ_Ep_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\empty_project\lib\epinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpInit.cpp

Abstract:
    Empty Project initialization

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ep.h"
#include "Epp.h"

#include "EpInit.tmh"

VOID
EpInitialize(
    *Parameters*
    )
/*++

Routine Description:
    Initializes Empty Project library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Empty Project library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!EppIsInitialized());

    //
    // TODO: Write Empty Project initalization code here
    //

    EppSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\empty_project\lib\epp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Epp.h

Abstract:
    Empty Project private functions.

Author:
    Erez Haba (erezh) 13-Aug-65

--*/

#pragma once

#ifndef _MSMQ_Epp_H_
#define _MSMQ_Epp_H_

#ifdef _DEBUG

void EppAssertValid(void);
void EppSetInitialized(void);
BOOL EppIsInitialized(void);

#else // _DEBUG

#define EppAssertValid() ((void)0)
#define EppSetInitialized() ((void)0)
#define EppIsInitialized() TRUE

#endif // _DEBUG


#endif // _MSMQ_Epp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\empty_project\lib\epdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpDebug.cpp

Abstract:
    Empty Project debugging

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ep.h"
#include "Epp.h"

#include "EpDebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Empty Project state
//
void EppAssertValid(void)
{
    //
    // EpInitalize() has *not* been called. You should initialize the
    // Empty Project library before using any of its funcionality.
    //
    ASSERT(EppIsInitialized());

    //
    // TODO:Add more Empty Project validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void EppSetInitialized(void)
{
    LONG fEpAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Empty Project library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fEpAlreadyInitialized);
}


BOOL EppIsInitialized(void)
{
    return s_fInitialized;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\empty_project\test\eptest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpTest.cpp

Abstract:
    Empty Project library test

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ep.h"


static void Usage()
{
    printf("Usage: EpTest [*switches*]\n");
    printf("\t*-s*\t*Switch description*\n");
    printf("\n");
    printf("Example, EpTest -switch\n");
    printf("\t*example description*\n");
    exit(-1);

} // Usage


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Empty Project library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    EpInitialize(*Parameters*);

    //
    // TODO: Write Empty Project test code here
    //

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\ev.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ev.cpp

Abstract:
    Event Report implementation

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"

#include <strsafe.h>

#include "ev.tmh"


static HANDLE s_hEventSource = NULL;

VOID
EvpSetEventSource(
	HANDLE hEventSource
	)
{
    ASSERT(s_hEventSource == NULL);
    ASSERT(hEventSource != NULL);
	s_hEventSource = hEventSource;
}


#ifdef _DEBUG

static HINSTANCE s_hLibrary = NULL;

void
EvpSetMessageLibrary(
	HINSTANCE  hLibrary
	)
{
    ASSERT(s_hLibrary == NULL);
    ASSERT(hLibrary != NULL);
	s_hLibrary = hLibrary;
}


static 
void
TraceReportEvent(
    DWORD EventId,
    LPCWSTR* Strings
    )
/*++

Routine Description:
   The Routine printd the event-log message into tracing window

Arguments:
    EventId  - Message id
    Strings - Array of strings to be used for formatting the message.

Returned Value:
    None.

--*/
{
    ASSERT(s_hLibrary != NULL);

    LPWSTR msg;
    DWORD ret = FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    s_hLibrary,
                    EventId,
                    0,      // dwLanguageId
                    (LPWSTR)&msg,
                    0,      // nSize
                    (va_list*)(Strings)
                    );
    if (ret == 0)
    {
        TrERROR(GENERAL, "Failed to format Event Log message. Error: %!winerr!", GetLastError());
        return;
    }

    //
    // All events are reported at error level
    //
    TrEVENT(GENERAL, "(0x%x) %ls", EventId, msg);
    LocalFree(msg);
}

#else

#define  TraceReportEvent(EventId, pArglist)  ((void) 0)

#endif


static WORD GetEventType(DWORD id)
/*++

Routine Description:
   The Routine returns the event type of the event-log entry that should be written. 
   The type is taken from the severity bits of the message Id.

Arguments:
    id  - Message id

Returned Value:
    None.

--*/
{
    //
    // looking at the severity bits (bits 31-30) and determining
    // the type of event-log entry to display
    //
    switch (id >> 30)
    {
        case STATUS_SEVERITY_ERROR: 
            return EVENTLOG_ERROR_TYPE;

        case STATUS_SEVERITY_WARNING: 
            return EVENTLOG_WARNING_TYPE;

        case STATUS_SEVERITY_INFORMATIONAL: 
            return EVENTLOG_INFORMATION_TYPE;

        default: 
            ASSERT(0);
    }

    return EVENTLOG_INFORMATION_TYPE;
}


static 
void
ReportInternal(
    DWORD EventId,
    LPCWSTR ErrorText,
    WORD NoOfStrings,
    va_list va
    )
/*++

Routine Description:
    The routine writes to the Event-log of the Windows-NT system.
                         
Arguments:
    EventId - identity of the message that is to be displayed in the event-log
    ErrorText - An optional error text to pass as a %1 string. This string is added
                to the list of strings as the first string.
    NoOfStrings - No Of input strings in arglist
    va - argument list of the input for formatted string

ReturnedValue:
    None.

 --*/
{
    ASSERT((NoOfStrings == 0) || (va != NULL));

    int ixFirst = 0;
    if(ErrorText != NULL)
    {
        ixFirst = 1;
        ++NoOfStrings;
    }

    LPCWSTR EventStrings[32] = { NULL };

    //
    // Verify size. Note that we need room for the NULL termination
    //
    ASSERT(TABLE_SIZE(EventStrings) > NoOfStrings);
    if (TABLE_SIZE(EventStrings) <= NoOfStrings)
    {
    	TrERROR(GENERAL, 
    			"Allocated table size too small : EventID:%x. Table Size:%d, Num of strings:%d, Error Text:%ls", 
    			EventId, 
    			TABLE_SIZE(EventStrings),
    			NoOfStrings,
    			ErrorText);

		//
    	// Print as much as you can
    	//
    	NoOfStrings = TABLE_SIZE(EventStrings)-1;
    	
    }
    
    
    EventStrings[0] = ErrorText;


    for (int i = ixFirst; i < NoOfStrings; ++i)
    {
        EventStrings[i] = va_arg(va, LPWSTR);
    }

    BOOL f = ReportEvent(
                s_hEventSource,
                GetEventType(EventId),
                0,      // wCategory
                EventId,
                NULL,
                NoOfStrings,
                0,      // dwRawDataSize
                EventStrings,
                NULL    // lpRawData
                );
    if (!f)
    {
        TrERROR(GENERAL, "Failed to report event: %x. Error: %!winerr!", EventId, GetLastError());
    }

    TraceReportEvent(EventId, EventStrings);
}


VOID
__cdecl
EvReport(
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    EvpAssertValid();
    
    //     
    // Look at the strings, if they were provided     
    //     
    va_list va;
    va_start(va, NoOfStrings);
   
    ReportInternal(EventId, NULL, NoOfStrings, va);

    va_end(va);
}


VOID
EvReport(
    DWORD EventId
    ) 
{
    EvpAssertValid();
    
    ReportInternal(EventId, NULL, 0, NULL);
}


VOID
__cdecl
EvReportWithError(
    DWORD EventId,
    HRESULT Error,
    WORD NoOfStrings,
    ... 
    )
{
    EvpAssertValid();

    WCHAR ErrorText[20];
    if(FAILED(Error))
    {
        //
        // This is an error value, format it in hex
        //
        StringCchPrintf(ErrorText, TABLE_SIZE(ErrorText), L"0x%x", Error);
    }
    else
    {
        //
        // This is a winerror value, format it in decimal
        //
        StringCchPrintf(ErrorText, TABLE_SIZE(ErrorText), L"%d", Error);
    }

    va_list va;
    va_start(va, NoOfStrings);
   
    ReportInternal(EventId, ErrorText, NoOfStrings, va);
                                    
    va_end(va);
}


VOID
EvReportWithError(
    DWORD EventId,
    HRESULT Error
    )
{
    EvReportWithError(EventId, Error, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\evdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvDebug.cpp

Abstract:
    Event Report debugging

Author:
    Uri Habusha (urih) 17-Sep-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"
#include <mqexception.h>

#include "evdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Event Report state
//
void EvpAssertValid(void)
{
    //
    // EvInitalize() has *not* been called. You should initialize the
    // Event Report library before using any of its funcionality.
    //
    ASSERT(EvpIsInitialized());

    //
    // TODO:Add more Event Report validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void EvpSetInitialized(void)
{
    LONG fEvAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Event Report library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fEvAlreadyInitialized);
}


BOOL EvpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "EvDumpState(queue path name)",
        "Dump Event Report State to debugger",
        DumpState
    ),

    //
    // TODO: Add Event Report debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void EvpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}


void EvpLoadEventReportLibrary(LPCWSTR AppName)
/*++
Routine Description:
  This routine print event in Trace window/File. The routine is 
  compiled only in debug mode.
  The routine access the registery to read the event library and load
  it. If the registery key doen't exist an exception is raised.

Parameters:
  AppName - application name

Return Value:
  None

--*/
{
    //
    // Featch the name of Event Report string library from registery
    //
    AP<WCHAR> LibraryName = EvpGetEventMessageFileName(AppName);

    //
    // get an handle to Event Report string library 
    //
    HINSTANCE hLibrary = ::LoadLibraryEx(LibraryName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hLibrary == NULL) 
    {
        DWORD gle = GetLastError();
        TrERROR(GENERAL, "Can't load Event report library %ls. Error: %!winerr!", LibraryName.get(), gle);
        throw bad_win32_error(gle);
    }

	EvpSetMessageLibrary(hLibrary);
}    

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\evinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvInit.cpp

Abstract:
    Event Report initialization

Author:
    Uri Habusha (urih) 17-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"

#include "evinit.tmh"

VOID
EvInitialize(
    LPCWSTR ApplicationName
    )
/*++

Routine Description:
    Initializes Event Report library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Event Report library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!EvpIsInitialized());
    EvpRegisterComponent();

    //
    // Get a registered handle to an event log
    // 
    HANDLE hEventSource = RegisterEventSource(NULL, ApplicationName);
    if (hEventSource == NULL)
    {
        TrERROR(GENERAL, "Can't initialize Event source. Error %d", GetLastError());
        throw bad_alloc();
    }

	EvpSetEventSource(hEventSource);

    //
    // get an handle to report event module
    //
    EvpLoadEventReportLibrary(ApplicationName);

    EvpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\evp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Evp.h

Abstract:
    Event Report private functions.

Author:
    Uri Habusha (urih) 17-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Evp_H_
#define _MSMQ_Evp_H_


#ifdef _DEBUG

void EvpAssertValid(void);
void EvpSetInitialized(void);
BOOL EvpIsInitialized(void);
void EvpRegisterComponent(void);

#else // _DEBUG

#define EvpAssertValid() ((void)0)
#define EvpSetInitialized() ((void)0)
#define EvpIsInitialized() TRUE
#define EvpRegisterComponent() ((void)0)

#endif // _DEBUG


#ifdef _DEBUG

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName);
void EvpLoadEventReportLibrary(LPCWSTR AppName);
void EvpSetMessageLibrary(HINSTANCE hLibrary);

#else // _DEBUG

#define EvpLoadEventReportLibrary(AppName) ((void) 0)

#endif // _DEBUG


VOID
EvpSetEventSource(
	HANDLE hEventSource
	);


#endif // _MSMQ_Evp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\evsetup.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvSetup.cpp

Abstract:
    Event Log registry setup

Author:
    Tatiana Shubin 14-Jan-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ev.h"
#include "Cm.h"
#include "Evp.h"

#include <strsafe.h>

#include "evsetup.tmh"

const WCHAR REGKEY_EVENT[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

VOID 
EvSetup(
    LPCWSTR ApplicationName,
    LPCWSTR ReportModuleName
    )
{  
    //
    // Create registry key for application event
    //
    WCHAR wszRegKey[MAX_PATH];
    HRESULT hr = StringCchPrintf(wszRegKey, TABLE_SIZE(wszRegKey), L"%s%s", REGKEY_EVENT, ApplicationName);
    if (FAILED(hr))
	{
		TrERROR(GENERAL, "wszRegKey string too small  Num of chars %d", TABLE_SIZE(wszRegKey));
		throw bad_alloc();
	}

    RegEntry regEvent(wszRegKey, 0, 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
    CRegHandle hEvent = CmCreateKey(regEvent, KEY_SET_VALUE);

    RegEntry regEventMsgFile(0, L"EventMessageFile", 0, RegEntry::MustExist, hEvent);
    CmSetValue(regEventMsgFile, ReportModuleName);


    DWORD dwTypes = EVENTLOG_ERROR_TYPE   |
				  EVENTLOG_WARNING_TYPE |
				  EVENTLOG_INFORMATION_TYPE;

    RegEntry regEventTypesSupported(0, L"TypesSupported", 0, RegEntry::MustExist, hEvent);
    CmSetValue(regEventTypesSupported, dwTypes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\lib\evgf.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Evgf.cpp

Abstract:
    Get Event report file name

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"
#include "Cm.h"
#include "Evp.h"

#include <strsafe.h>

#include "evgf.tmh"

//
// This code should be in the EvDebug.cpp, however since the Ev Test overwrite
// this function (in order to remove dependency on cm.lib) we need to put it in
// seperate file.
//

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName)
/*++

Routine Description:
	This routine fetches the event message filename from the registery.

	The routine access the registery to read the event library and load
	it. If the registery key doen't exist an exception is raised.

Parameters:
	AppName - application name

Return Value:
	A heap allocated buffer that holds the event message file name

Note:
	The caller should free the buffer using delete[]

--*/
{
	const WCHAR xEventFileValue[] = L"EventMessageFile";
	const WCHAR xEventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";  

    WCHAR RegPath[MAX_PATH];

    ASSERT(TABLE_SIZE(RegPath) > (wcslen(AppName) + wcslen(xEventSourcePath)));
    HRESULT hr = StringCchPrintf(RegPath, TABLE_SIZE(RegPath), L"%s%s", xEventSourcePath, AppName);
    if (FAILED(hr))
	{
		TrERROR(GENERAL, "RegPath string too small  Num of chars %d", TABLE_SIZE(RegPath));
		throw bad_alloc();
	}




    RegEntry RegModuleName(
				RegPath,
				xEventFileValue,
				0,
                RegEntry::MustExist,
                HKEY_LOCAL_MACHINE
                );

    //
    // Go fetch the event message filename string
    //
	LPWSTR RegValue;
    CmQueryValue(RegModuleName, &RegValue);

	return RegValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ev\test\evtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvTest.cpp

Abstract:
    Event Report library test

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cm.h"
#include "Ev.h"
#include "EvTest.h"

#include "EvTest.tmh"

HANDLE hEventLog = NULL;
LPCWSTR MessageFile = NULL;

const IID GUID_NULL = {0};

const WCHAR x_EventSourceName[] = L"EventTest";
const WCHAR x_EventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\EventTest";  

static 
void
CheckReportEventInternal(
    DWORD RecordNo,
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings,
    va_list* parglist
    )
{
    char EventRecordBuff[1024];
    DWORD nBytesRead;
    DWORD nBytesRequired;

    BOOL fSucc = ReadEventLog(
                        hEventLog, 
                        EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                        RecordNo,
                        EventRecordBuff,
                        TABLE_SIZE(EventRecordBuff),     
                        &nBytesRead,
                        &nBytesRequired
                        );

    if (!fSucc)
    {
        TrERROR(GENERAL, "Read Event Log Failed. Error %d \n", GetLastError());
        throw bad_alloc();
    }

    EVENTLOGRECORD*  pEventRecord = reinterpret_cast<EVENTLOGRECORD*>(EventRecordBuff);
    if (EventId != pEventRecord->EventID) 
    {
        TrERROR(GENERAL, "Test Failed. Read Event Id %x, Expected %x\n", pEventRecord->EventID, EventId);
        throw bad_alloc();
    }

    char* p = reinterpret_cast<char*>(&(pEventRecord->DataOffset));
    LPWSTR SourceName = reinterpret_cast<LPWSTR>(p + sizeof(DWORD));
    if (wcscmp(SourceName, x_EventSourceName) != 0)
    {
        TrERROR(GENERAL, "Test Failed. Source Name %ls, Expected MSMQ\n", SourceName);
        throw bad_alloc();
    }

    if (NoOfStrings != pEventRecord->NumStrings)
    {
        TrERROR(GENERAL, "Test Failed. Number of strings %x, Expected %x\n", pEventRecord->NumStrings, NoOfStrings);
        throw bad_alloc();
    }
    
    LPWSTR strings = reinterpret_cast<LPWSTR>(EventRecordBuff + pEventRecord->StringOffset);
    for (DWORD i = 0; i < NoOfStrings; ++i)
    {
        LPWSTR arg = va_arg(*parglist, LPWSTR);
        if (wcscmp(strings, arg) != 0)
        {
            TrERROR(GENERAL, "Test Failed. Argument mismatch  Read %ls, Expected %lc\n", arg, strings[i]);
            throw bad_alloc();
        }
        strings += (wcslen(arg) + 1);
    }

    if (RawDataSize != pEventRecord->DataLength)
    {
        TrERROR(GENERAL, "Test Failed. Read Data size %x, Expected %x\n", pEventRecord->DataLength, RawDataSize);
        throw bad_alloc();
    }

    if ((RawDataSize != 0) && 
        (memcmp(RawData, EventRecordBuff+pEventRecord->DataOffset, RawDataSize) != 0))
    {
        TrERROR(GENERAL, "Test Failed. Report data mismatch");
        throw bad_alloc();
    }

}



void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings
    ... 
    ) 
{
    //     
    // Look at the strings, if they were provided     
    //     
    va_list arglist;
    va_start(arglist, NoOfStrings);
   
    CheckReportEventInternal(RecordNo, EventId, RawDataSize, RawData, NoOfStrings, &arglist);

    va_end(arglist);
}

void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    //     
    // Look at the strings, if they were provided     
    //     
    va_list arglist;
    va_start(arglist, NoOfStrings);
   
    CheckReportEventInternal(RecordNo, EventId, 0, NULL, NoOfStrings, &arglist);

    va_end(arglist);
}


void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId
    ) 
{
    CheckReportEventInternal(RecordNo, EventId, 0, NULL, 0, NULL);
}

void DeleteTestRegMessageFile()
{
    int rc = RegDeleteKey(HKEY_LOCAL_MACHINE, x_EventSourcePath);
    if (rc != ERROR_SUCCESS)
    {
        TrERROR(GENERAL, "Can't delete  registery key %ls. Error %d",x_EventSourcePath, GetLastError());
    }
}

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName)
{
	ASSERT(wcscmp(AppName, L"EventTest") == 0);
	DBG_USED(AppName);

	LPWSTR retValue = new WCHAR[wcslen(MessageFile) +1];
	wcscpy(retValue, MessageFile);

	return retValue;
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR argv[])
/*++

Routine Description:
    Test Event Report library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    int TestReturnValue = 0;
	MessageFile = argv[0];

    TrInitialize();
    CmInitialize(HKEY_LOCAL_MACHINE, L"", KEY_ALL_ACCESS);

    TrTRACE(GENERAL, "running Event Report test ...");
    try
    {        
        EvSetup(L"EventTest", argv[0]);
    
        EvInitialize(L"EventTest");

        hEventLog = OpenEventLog(NULL, L"Application");
        if (hEventLog == NULL)
        {
            TrERROR(GENERAL, "OpenEventLog Failed. Error %d", GetLastError());
            throw bad_alloc();
        }

        DWORD OldestRecord;
        if(! GetNumberOfEventLogRecords(hEventLog, &OldestRecord))
        {
            TrERROR(GENERAL, "GetNumberOfEventLogRecords Failed. Error %d", GetLastError());
            throw bad_alloc();
        }

        EvReport(TEST_MSG_WITHOUT_PARAMETERS);
        CheckReportEvent(++OldestRecord, TEST_MSG_WITHOUT_PARAMETERS);
    
        EvReport(TEST_MSG_WITH_1_PARAMETERS, 1, L"param 1");
        CheckReportEvent(++OldestRecord, TEST_MSG_WITH_1_PARAMETERS, 1, L"param 1");
    
        EvReport(TEST_INF_MSG_WITH_2_PARAMETERS, 2, L"param 1", L"param 2");
        CheckReportEvent(++OldestRecord, TEST_INF_MSG_WITH_2_PARAMETERS, 2, L"param 1", L"param 2");
        
        EvReport(TEST_ERROR_MSG_WITH_3_PARAMETERS, 3, L"param 1", L"Param 2", L"Param 3");
        CheckReportEvent(++OldestRecord, TEST_ERROR_MSG_WITH_3_PARAMETERS, 3, L"param 1", L"Param 2", L"Param 3");
    
        EvReport(TEST_WARNING_MSG_WITH_4_PARAMETERS, 4, L"param 1", L"Param 2", L"Param 3", L"Param 4");
        CheckReportEvent(++OldestRecord, TEST_WARNING_MSG_WITH_4_PARAMETERS, 4, L"param 1", L"Param 2", L"Param 3", L"Param 4");
    
        EvReportWithError(TEST_ERROR_MSG_WITH_ERROR, 0xc0000006);
        EvReportWithError(TEST_ERROR_MSG_WITH_ERROR_AND_1_PARAMETER, 3, 1, L"param1");
    }
    catch(const exception&)
    {
        TestReturnValue = -1;
    }

    DeleteTestRegMessageFile();
    if (hEventLog)
    {
        CloseEventLog(hEventLog);
    }

    if (TestReturnValue == 0)
    {
        TrTRACE(GENERAL, "Event Test Pass Successfully\n");
    }

    WPP_CLEANUP();
    return TestReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\exinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ExInit.cpp

Abstract:
    Executive initialization

Author:
    Erez Haba (erezh) 03-Jan-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "ExInit.tmh"

static void StartWorkerThreads(DWORD ThreadCount)
{
    TrTRACE(GENERAL, "Creating %d worker threads", ThreadCount);

    for ( ; ThreadCount--; )
    {
        DWORD ThreadID;
        HANDLE hThread;

        hThread = CreateThread(
                    NULL,           // Security attributes
                    0,
                    ExpWorkingThread,
                    NULL,           // Thread paramenter
                    0,
                    &ThreadID
                    );
        
        if (hThread == NULL) 
        {
            TrERROR(GENERAL, "Failed to create worker thread. Error=%d",GetLastError());
            throw bad_alloc();
        }
        
        CloseHandle(hThread);

        TrTRACE(GENERAL, "Created worker thread. id=%x", ThreadID);
    }
}


void
ExInitialize(
    DWORD ThreadCount
    )
/*++

Routine Description:
    Initializes Exceutive, Create a worker thred pool to service the completion port.

Arguments:
    ThreadCount - Number of threads in the worker threads pool

Returned Value:
    None.

--*/
{
    //
    // Validate that this component was not initalized yet. You should call
    // component initalization only once.
    //
    ASSERT(!ExpIsInitialized());
    ExpRegisterComponent();

    ExpInitCompletionPort();
    StartWorkerThreads(ThreadCount);
    ExpInitScheduler();

    ExpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\exdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ExDebug.cpp

Abstract:
    Executive debugging

Author:
    Erez Haba (erezh) 03-Jan-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Exp.h"

#include "exdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate componenet state
//
void ExpAssertValid(void)
{
    //
    // ExInitalize() has *not* been called. You should initialize this
    // componenet before using any of its funcionality.
    //
    ASSERT(ExpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void ExpSetInitialized(void)
{
    LONG fExAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Executive has *already* been initialized. You should not
    // initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fExAlreadyInitialized);
}


BOOL ExpIsInitialized(void)
{
    return s_fInitialized;
}



//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "ExDumpState(queue path name)",
        "Dump Empty Project State to debugger",
        DumpState
    ),

    //
    // TODO: Add component debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void ExpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\exov.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    expioc.cpp

Abstract:
    Executive Overlapped Implementation

Author:
    Erez Haba (erezh) 03-Jan-99

Enviroment:
    Platform-Winnt

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "exov.tmh"

//---------------------------------------------------------
//
// EXOVERLAPPED Implementation
//
//---------------------------------------------------------
VOID EXOVERLAPPED::CompleteRequest()
/*++

Routine Description:
  Invoke the overlapped completion routine.
    
Arguments:
  None.
     
Returned Value:
  None.
      
--*/
{
    if(SUCCEEDED(GetStatus()))
    {
        m_pfnSuccess(this);
    }
    else
    {
        m_pfnFailure(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\exio.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    exio.cpp

Abstract:
    Executive completion port implementation

Author:
    Erez Haba (erezh) 03-Jan-99

Enviroment:
    Platform-Winnt

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "exio.tmh"

//
// The Handle to the Io Completion Port
//
static HANDLE s_hPort = NULL;

static HANDLE CreatePort(HANDLE Handle)
{
    HANDLE hPort;
    hPort = CreateIoCompletionPort(
                Handle,
                s_hPort,
                0,
                0
                );

    if(hPort == NULL)
	{
		TrERROR(GENERAL, "Failed to attach handle=0x%p to port=0x%p. Error=%d", Handle, s_hPort, GetLastError());
        throw bad_alloc();
	}

	return hPort;
}


VOID
ExpInitCompletionPort(
	VOID
	)
/*++

Routine Description:
  Create a new (the only one) Exceutive completion port

Arguments:
  None.

Returned Value:
  None

--*/
{
	ASSERT(s_hPort == NULL);
    s_hPort = CreatePort(INVALID_HANDLE_VALUE);
}


HANDLE
ExIOCPort(
    VOID
    )
/*++

Routine Description:
  Get Executive complition port.

Arguments:
  None

Returned Value:
  Executive complition port.

--*/
{
    ExpAssertValid();

    ASSERT(s_hPort != NULL);
	return s_hPort;
}


VOID
ExAttachHandle(
    HANDLE Handle
    )
/*++

Routine Description:
  Associates a Handle with the Executive complition port.

Arguments:
  Handle - A handle to associate with the completion port

Returned Value:
  None

--*/
{
    ExpAssertValid();

	ASSERT(Handle != INVALID_HANDLE_VALUE);
    ASSERT(s_hPort != NULL);

    HANDLE hPort = CreatePort(Handle);
	DBG_USED(hPort);

    ASSERT(s_hPort == hPort);
}

 
VOID
ExPostRequest(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
  Post an Executive overlapped request to the completion port

Arguments:
  pov - An Executive overlapped structure

Returned Value:
  None

--*/
{
    ExpAssertValid();
    ASSERT(s_hPort != NULL);

    BOOL fSucc;
    fSucc = PostQueuedCompletionStatus(
                s_hPort,
                0,
                0,
                pov
                );

    if (!fSucc)
	{
		TrERROR(GENERAL, "Failed to post overlapped=0x%p to to port=0x%p. Error=%d", pov, s_hPort, GetLastError());
        throw bad_alloc();
	}
}

 
DWORD
WINAPI
ExpWorkingThread(
    LPVOID 
    )
/*++

Routine Description:
  The Executive Worker Thread Routine. It handles all completion port postings.
    
  The Worker Thread waits for completion notifications, as soon as one arrives
  it is dequeued from the port and the completion routine is invoked.
    
Arguments:
  None.

Returned Value:
  None.

--*/
{
    for(;;)
    {
        try
        {
            //
            // Wait for a completion notification
            //
            ULONG_PTR Key;
            OVERLAPPED* pov;
            DWORD nNumberOfBytesTransferred;
            BOOL fSucc;

            fSucc = GetQueuedCompletionStatus(
                        s_hPort,
                        &nNumberOfBytesTransferred,
                        &Key,
                        &pov,
                        INFINITE
                        );

            if(pov == NULL)
            {
                ASSERT(!fSucc);
                continue;
            }

            EXOVERLAPPED* pexov = static_cast<EXOVERLAPPED*>(pov);
            pexov->CompleteRequest();

        }        
        catch(const exception& e)
        {
            TrERROR(GENERAL, "Exception: '%s'", e.what());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\exp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Exp.h

Abstract:
    Executive private functions.

Author:
    Erez Haba (erezh) 03-Jan-99

--*/

#pragma once

#ifndef _MSMQ_Exp_H_
#define _MSMQ_Exp_H_

#ifdef _DEBUG

void ExpAssertValid(void);
void ExpSetInitialized(void);
BOOL ExpIsInitialized(void);
void ExpRegisterComponent(void);

#else // _DEBUG

#define ExpAssertValid() ((void)0)
#define ExpSetInitialized() ((void)0)
#define ExpIsInitialized() TRUE
#define ExpRegisterComponent() ((void)0)

#endif // _DEBUG


DWORD
WINAPI
ExpWorkingThread(
    LPVOID Param
    );

VOID
ExpInitScheduler(
    VOID
    );

VOID
ExpInitCompletionPort(
    VOID
    );

#endif // _MSMQ_Exp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\rwlock.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    rwlock.cpp

Abstract:
    Implementation of read/write lock.

Owner:
    Uri Habusha (urih) 16-Jan-2000


History:    19-Nov-97   stevesw:    Stolen from MTS
            20-Nov-97   stevesw:    Cleaned up
            13-Jan-98   stevesw:    Added to ComSvcs
            23-Sep-98   dickd:      Don't call GetLastError when no error

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <rwlock.h>
#include "Exp.h"

#include "rwlock.tmh"

//+--------------------------------------------------------------------------
//
//        Definitions of the bit fields in CReadWriteLock::m_dwFlag
//       The goal here is to avoid the shifts that bitfields involve
//
//                              -- WARNING --
//              
//               The code assumes that READER_MASK is in the
//                      low-order bits of the DWORD.
//
//           Also, the WRITERS_MASK has two bits so you can see
//                       an overflow when it happens
//
//           Finally, the use of the SafeCompareExchange routine
//      insures that every attempt to change the state of the object
//              either does what was intended, or is a no-op
//
//---------------------------------------------------------------------------

const ULONG READERS_MASK      = 0x000003FF; // # of reader threads
const ULONG READERS_INCR      = 0x00000001; // increment for # of readers

const ULONG WRITERS_MASK      = 0x00000C00; // # of writer threads
const ULONG WRITERS_INCR      = 0x00000400; // increment for # of writers

const ULONG READWAITERS_MASK  = 0x003FF000; // # of threads waiting to read
const ULONG READWAITERS_INCR  = 0x00001000; // increment for # of read waiters

const ULONG WRITEWAITERS_MASK = 0xFFC00000; // # of threads waiting to write
const ULONG WRITEWAITERS_INCR = 0x00400000; // increment for # of write waiters



CReadWriteLock::CReadWriteLock (
    unsigned long ulcSpinCount
    ) :
     m_dwFlag(0),
     m_hReadWaiterSemaphore(NULL),
     m_hWriteWaiterEvent(NULL)
/*++

Routine Description:
    constructs a exclusive/shared lock object

Arguments:
    ulcSpinCount - spin count, for machines on which it's relevant

Returned Value:
    None.

Algorithm:  
    The first trick here, with the static values, is to make sure
    you only go out to figure out whether or not you're on a
    multiprocessor machine once. You need to know because,
    there's no reason to do spin counts on a single-processor
    machine. Once you've checked, the answer you need is cached
    in maskMultiProcessor (which is used to zero out the spin
    count in a single-processor world, and pass it on in a
    multiprocessor one).

    Other than that, this just fills in the members with initial
    values. We don't create the semaphore and event here; there
    are helper routines which create/return them when they're
    needed. 

--*/
{

    static BOOL fInitialized = FALSE;
    static unsigned long maskMultiProcessor;

    if (!fInitialized) 
    {
        SYSTEM_INFO SysInfo;

        GetSystemInfo (&SysInfo);
        if (SysInfo.dwNumberOfProcessors > 1) 
        {
            maskMultiProcessor = 0xFFFFFFFF;
        }
        else 
        {
            maskMultiProcessor = 0;
        }

        fInitialized = TRUE;
    }

    m_ulcSpinCount = ulcSpinCount & maskMultiProcessor;
}


CReadWriteLock::~CReadWriteLock () 
/*++

Routine Description:
    Destructs a exclusive/shared lock object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    What's done here is to check to make sure nobody's using
    the object (no readers, writers, or waiters). Once that's
    checked, we just close the handles of the synchronization
    objects we use here....
 
--*/
{
    //
    // Destroying CReadWriteLock object on which folks are still waiting
    //
    ASSERT(MmIsStaticAddress(this) || (m_dwFlag == 0));

    if (m_hReadWaiterSemaphore != NULL) 
    {
        CloseHandle (m_hReadWaiterSemaphore);
    }

    if (m_hWriteWaiterEvent != NULL) 
    {
        CloseHandle (m_hWriteWaiterEvent);
    }
}


/******************************************************************************
Function : CReadWriteLock::LockRead

Abstract: Obtain a shared lock
//  reader count is zero after acquiring read lock
//  writer count is nonzero after acquiring write lock
******************************************************************************/


void CReadWriteLock::LockRead (void) 
/*++

Routine Description:
    Grabs a read (shared) lock on an object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    This loops, checking on a series of conditions at each
    iteration:

    - If there's only readers, and room for more, become one by 
    incrementing the reader count
    - It may be that we've hit the max # of readers. If so,
    sleep a bit.
    - Otherwise, there's writers or threads waiting for write
    access. If we can't add any more read waiters, sleep a bit.
    - If we've some spin looping to do, now is the time to do it.
    - We've finished spin looping, and there's room, so we can
    add ourselves as a read waiter. Do it, and then hang
    until the WriteUnlock() releases us all....

    On the way out, make sure there's no writers and at least one
    reader (us!) 

    The effect of this is, if there's only readers using the
    object, we go ahead and grab read access. If anyone is doing
    a write-wait, though, then we go into read-wait, making sure
    one writer will get it before us.

--*/
{
    TrTRACE(GENERAL, "Read Lock (this=0x%p)", this);

    ULONG ulcLoopCount = 0;

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag < READERS_MASK) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + READERS_INCR),
                                                dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READERS_MASK) == READERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if ((dwFlag & READWAITERS_MASK) == READWAITERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if (ulcLoopCount++ < m_ulcSpinCount) 
        {
            continue;
        }

        //
        // Call GetReadWaiterSemaphore before changing state to assure semaphore
        // availability. Otherwise state can not be safely restored.
        //
        HANDLE h = GetReadWaiterSemaphore();

        if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + READWAITERS_INCR),
                                                dwFlag)) 
        {
            DWORD rc = WaitForSingleObject(h, INFINITE);

            //
            // WaitForSingleObject must not failed. The number of READWAITERS
            // already incremnt and someone need to decrement it.
            //
            ASSERT(rc == WAIT_OBJECT_0);
            DBG_USED(rc);

            break;
        }
    }

    //
    // Problem with Reader info in CReadWriteLock::LockRead
    //
    ASSERT((m_dwFlag & READERS_MASK) != 0); 

    //
    // Problem with Writer info in CReadWriteLock::LockRead
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == 0);
}


void CReadWriteLock::LockWrite (void) 
/*++

Routine Description:
    Grab a write (exclusive) lock on this object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    What we do is loop, each time checking a series of conditions
    until one matches:

    - if nobody's using the object, grab the exclusive lock
    
    - if the maximum # of threads are already waiting for
      exclusive access, sleep a bit
    
    - if we've spin counting to do, count spins
    
    - otherwise, add ourselves as a write waiter, and hang on the
      write wait event (which will let one write waiter pass
      through each time an UnlockRead() lets readers pass)

    Once we've finished, we check to make sure that there are no
    reader and one writer using the object.

    The effect of this is, we grab write access if there's nobody
    using the object. If anyone is using it, we wait for it.

--*/
{
    TrTRACE(GENERAL, "Write lock (this=0x%p)", this);

    ULONG ulcLoopCount = 0;

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == 0) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*)&m_dwFlag,
                                                    WRITERS_INCR,
                                                    dwFlag)) 
            {
                break;
            }
            continue;
        }

        if ((dwFlag & WRITEWAITERS_MASK) == WRITEWAITERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if (ulcLoopCount++ < m_ulcSpinCount) 
        {
            continue;
        }

        //
        // Call GetWriteWaiterEvent before changing state to assure event
        // availability. Otherwise state can not be safely restored.
        //
        HANDLE h = GetWriteWaiterEvent();

        if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + WRITEWAITERS_INCR),
                                                dwFlag)) 
        {
            DWORD rc = WaitForSingleObject(h, INFINITE);

            //
            // WaitForSingleObject must not failed. The number of READWAITERS
            // already incremnt and someone need to decrement it.
            //
            ASSERT(rc == WAIT_OBJECT_0);
            DBG_USED(rc);

            break;
        }
    }

    //
    // Problem with Reader info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & READERS_MASK) == 0);

    //
    // Problem with Writer info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == WRITERS_INCR);
}


void CReadWriteLock::UnlockRead (void) 
/*++

Routine Description:
    Releases a read (shared) lock on the object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    Again, there's a loop checking a variety of conditions....

    - If it's just us reading, with no write-waiters, set the
      flags to 0
  
    - If there are other readers, just decrement the flag
    
    - If it's just me reading, but there are write-waiters,
      then remove me and the write-waiter, add them as a writer,
      and release (one of) them using the event.

    We check to make sure we're in the right state before doing
    this last, relatively complex operation (one reader; at least
    one write waiter). We let the hanging writer check to make
    sure, on the way out, that there's just one writer and no
    readers....

    The effect of all this is, if there's at least one thread
    waiting for a write, all the current readers will drain, and
    then the one writer will get access to the object. Otherwise
    we just let go....

--*/
{
    TrTRACE(GENERAL, "Read unlock (this=0x%p)", this);

    //
    // Problem with Reader info in CReadWriteLock::UnlockRead
    //
    ASSERT((m_dwFlag & READERS_MASK) != 0); 

    //
    // Problem with Writer info in CReadWriteLock::UnlockRead
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == 0);

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == READERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    0,
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READERS_MASK) > READERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    (dwFlag - READERS_INCR),
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        //
        // Problem with Reader info in CReadWriteLock::UnlockRead
        //
        ASSERT((dwFlag & READERS_MASK) == READERS_INCR);

        //
        // Problem with WriteWatier info in CReadWriteLock::UnlockRead
        //
        ASSERT((dwFlag & WRITEWAITERS_MASK) != 0);

        if (dwFlag == (ULONG) InterlockedCompareExchange (
                                                (LONG*) &m_dwFlag,
                                                (dwFlag -
                                                    READERS_INCR -
                                                    WRITEWAITERS_INCR +
                                                    WRITERS_INCR), 
                                                dwFlag)) 
        {
            //
            // The semaphore is guaranteed to be available here as there is
            // a write waiter that already signaled the event.
            //
            BOOL f = SetEvent(
                        GetWriteWaiterEvent()
                        );
            ASSERT(f);
            DBG_USED(f);

            break;
        }
    }
}


void CReadWriteLock::UnlockWrite (void) 
/*++

Routine Description:
    Lets go of exclusive (write) access

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    We're in a loop, waiting for one or another thing to happen

    - If it's just us writing, and nothing else is going on, we
      let go and scram.

    - If threads are waiting for read access, we fiddle with the
      dwFlag to release them all (by decrementing the writer
      count and read-waiter count, and incrementing the reader
      count, and then incrementing the semaphore enough so that
      all those read-waiters will be released). 

    - If there are only threads waiting for write access, let one
      of them through.... Don't have to fiddle with the write
      count, 'cause there will still be one.

    The upshot of all this is, we make sure that the next threads
    to get access after we let go will be readers, if there are
    any. The whole scene makes it go from one writer to many
    readers, back to one writer and then to many readers again.
    Sharing. Isn't that nice.

 
--*/
{
    TrTRACE(GENERAL, "Write unlock (this=0x%p)", this);

    //
    // Problem with Reader info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & READERS_MASK) == 0);

    //
    // Problem with Writer info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == WRITERS_INCR);

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == WRITERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*)&m_dwFlag,
                                                    0,
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READWAITERS_MASK) != 0) 
        {
            ULONG count = (dwFlag & READWAITERS_MASK) / READWAITERS_INCR;

            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    (dwFlag - 
                                                        WRITERS_INCR - 
                                                        count * READWAITERS_INCR + 
                                                        count * READERS_INCR), 
                                                    dwFlag)) 
            {
                //
                // The semaphore is guaranteed to be available here as there are
                // read waiters that already signaled the semaphore.
                //
                BOOL f = ReleaseSemaphore (
                            GetReadWaiterSemaphore(),
                            count,
                            NULL
                            );
                ASSERT(f);
                DBG_USED(f);

                break;
            }

            continue;
        }

        //
        // Check for problem with WriteWatier info in CReadWriteLock::UnlockWrite
        //
        ASSERT((dwFlag & WRITEWAITERS_MASK) != 0);

        if (dwFlag == (ULONG) InterlockedCompareExchange ( 
                                                (LONG*) &m_dwFlag,
                                                (dwFlag - WRITEWAITERS_INCR),
                                                dwFlag)) 
        {
            //
            // The semaphore is guaranteed to be available here as there is
            // a write waiter that already signaled the event.
            //
            BOOL f = SetEvent(
                        GetWriteWaiterEvent()
                        );
            ASSERT(f);
            DBG_USED(f);

            break;
        }
    }
}


HANDLE CReadWriteLock::GetReadWaiterSemaphore(void) 
/*++

Routine Description:
    Private member function to get the read-waiting semaphore,
    creating it if necessary

Arguments:
    None.

Returned Value:
    semaphore handle (never NULL).

Algorithm:  
    This is a thread-safe, virtually lockless routine that
    creates a semaphore if there's not one there, safely tries to
    shove it into the shared member variable, and cleans up if
    someone snuck in there with a second semaphore from another
    thread. 
--*/
{
    if (m_hReadWaiterSemaphore == NULL) 
    {
        HANDLE h = CreateSemaphore (NULL, 0, MAXLONG, NULL);
        if (h == NULL) 
        {
            TrERROR(GENERAL, "Failed to create semaphore. Error=%d", GetLastError());
            throw bad_alloc();
        }

        if (NULL != InterlockedCompareExchangePointer ((PVOID*) &m_hReadWaiterSemaphore, h, NULL)) 
        {
            CloseHandle (h);
        }
    }

    return m_hReadWaiterSemaphore;
}


HANDLE CReadWriteLock::GetWriteWaiterEvent(void) 
/*++

Routine Description:
    private member function to get the write-waiting barrier, 
    creating it if necessary

Arguments:
    None.

Returned Value:
    event handle (never NULL).

Algorithm:  
    This is a thread-safe, virtually lockless routine that
    creates an event if there's not one there, safely tries to
    shove it into the shared member variable, and cleans up if
    someone snuck in there with a second event from another
    thread.

--*/
{
    if (m_hWriteWaiterEvent == NULL) 
    {
        HANDLE h = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (h == NULL) 
        {
            TrERROR(GENERAL, "Failed to create event. Error=%d", GetLastError());
            throw bad_alloc();
        }
    
        if (NULL != InterlockedCompareExchangePointer((PVOID*) &m_hWriteWaiterEvent, h, NULL)) 
        {
            CloseHandle (h);
        }
    }

    return m_hWriteWaiterEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\test\asyncexecutionrequest.h ===
/*
Module Name:
    AsyncExecutionRequest.h

Abstract:
    Header file for class CTestAsyncExecutionRequest simulates async request
	for testing CReadWriteLockAsyncExcutor class.

Author:	 
    Gil Shafriri (gilsh), 2-July-2001

--*/

#pragma once

#ifndef _MSMQ_AsyncExecutionRequest_H_
#define _MSMQ_AsyncExecutionRequest_H_

#include <ex.h>
#include <rwlockexe.h>

class CAsyncCaller;

class CTestAsyncExecutionRequest : public  IAsyncExecutionRequest, public EXOVERLAPPED, public CReference
{

public:
	CTestAsyncExecutionRequest(CAsyncCaller& AsyncCaller);
	virtual void Run();
	virtual void Close();
	static void WINAPI OnOk(EXOVERLAPPED* povl);
	static void WINAPI OnFailed(EXOVERLAPPED* povl);

private:
	CAsyncCaller& m_AsyncCaller;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\test\casynccaller.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CAsyncCaller.cpp

Abstract:
    Implementation of class CAsyncCaller.cpp (CAsyncCaller.h).


Owner:
    Gil Shafriri(gilsh) 2-July-2001


Environment:
    Platform-independent,

--*/


#include <libpch.h>
#include "CAsyncCaller.h"
#include "AsyncExecutionRequest.h"



void CAsyncCaller::OnOk(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	printf("CAsyncCaller::OnOk called  \n");
	CleanUp(TestAsyncExecutionRequest);
}


void CAsyncCaller::OnFailed(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	printf("CAsyncCaller::OnFailed called  \n");
	CleanUp(TestAsyncExecutionRequest);	
}


void CAsyncCaller::CleanUp(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	if(m_locktype == Read)
	{
		printf("unlock read  \n");
		m_ReadWriteLockAsyncExcutor.UnlockRead();
	}
	else
	{
		printf("unlock write  \n");
		m_ReadWriteLockAsyncExcutor.UnlockWrite();		
	}
	TestAsyncExecutionRequest->Release();	
}



void CAsyncCaller::Run(IAsyncExecutionRequest* AsyncExecutionRequest)
{
	if(m_locktype == Read)
	{
		printf("CAsyncCaller::Run under read lock  \n");
		m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderReadLock(AsyncExecutionRequest);
		return;
	}

	printf("CAsyncCaller::Run under write lock  \n");
	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderWriteLock(AsyncExecutionRequest);
}


CAsyncCaller::CAsyncCaller(
					CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor,
					LockType locktype
					):
					m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor),
					m_locktype(locktype)
{
			
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\rwlockexe.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    rwlockexe.cpp

Abstract:
    Implementation of class CReadWriteLockAsyncExcutor (rwlockexe.h).


Owner:
    Gil Shafriri(gilsh) 26-June-2001


Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <rwlockexe.h>

#include "rwlockexe.tmh"


///////////////////////////////////////////////////////////////
////////////////////////PUBLIC member functions ///////////////
///////////////////////////////////////////////////////////////

CReadWriteLockAsyncExcutor::CReadWriteLockAsyncExcutor(
													void
													):
													m_NumOfActiveReaders(0),
													m_NumOfActiveWritters(0),
													m_fClosed(false)
													{
													}

														


CReadWriteLockAsyncExcutor::~CReadWriteLockAsyncExcutor()
{
	ASSERT(m_WatingForExecutionQueue.empty());
	if(IsClosed())
		return;

	ASSERT(!IsReadLockOn());
	ASSERT(!IsWriteLockOn());
}


void CReadWriteLockAsyncExcutor::AsyncExecuteUnderReadLock(IAsyncExecutionRequest* pAsyncExecuteRequest)
/*++

Routine Description:
    Execute async request under read lock

Arguments:
    pAsyncExecute - async request.
	pov - Request overlapp 

Returned Value:
    None

Note:
	If the is active writer - the request is queued.
	It is the responsibilty of the caller to call UnlockRead() if the call did 
	threw  exception.
--*/ 
{
	CS cs(m_Lock);
	if(IsClosed())
	{
		pAsyncExecuteRequest->Close();
		return;
	}
	
	if(IsWriteLockOn())
	{
		m_WatingForExecutionQueue.push(CExecutionContext(pAsyncExecuteRequest,  Read));
		return;
	}
	ExecuteReader(pAsyncExecuteRequest);
}


void CReadWriteLockAsyncExcutor::AsyncExecuteUnderWriteLock(IAsyncExecutionRequest* pAsyncExecuteRequest)
/*++

Routine Description:
    Execute async request under write lock.

Arguments:
    pAsyncExecute - async request.
	pov - Request overlapp 

Returned Value:
    Note:
	If the is active writer or reader  - the request is queued.
	It is the responsibilty of the caller to call UnlockWrite() if the call did 
	threw  exception.

--*/
{
	CS cs(m_Lock);
	if(IsClosed())
	{
		pAsyncExecuteRequest->Close();
		return;
	}

	if(IsWriteLockOn() || IsReadLockOn())
	{
		m_WatingForExecutionQueue.push(CExecutionContext(pAsyncExecuteRequest, Write));
		return;
	}
	ExecuteWriter(pAsyncExecuteRequest);
}


void CReadWriteLockAsyncExcutor::UnlockRead(void)
/*++

Routine Description:
    Unlock read lock accuired by the call to AsyncExecuteUnderReadLock().
	

Arguments:
   

Returned Value:
   None.

Note:
	Must  be called  only after the request queued by AsyncExecuteUnderReadLock() completed.
	If this is the last reader it goes to execute wating requests.

--*/
{
	CS cs(m_Lock);

	if(IsClosed())
		return;

		
	ASSERT(IsReadLockOn());
	ASSERT(!IsWriteLockOn());

	--m_NumOfActiveReaders;
	if(!IsReadLockOn())
	{
		ExecuteWatingRequeuets();				
	}
}


void CReadWriteLockAsyncExcutor::UnlockWrite(void)
/*++

Routine Description:
    Unlock write lock accuired by the call to AsyncExecuteUnderReadLock() and execute wating requests.

Arguments:
   

Returned Value:
   None.

Note:
	Must  be called  only after the request queued by AsyncExecuteUnderWriteLock() completed.

--*/
{

	CS cs(m_Lock);

	if(IsClosed())
		return;

	ASSERT(IsWriteLockOn());
	ASSERT(!IsReadLockOn());
	--m_NumOfActiveWritters;
	ASSERT(!IsWriteLockOn());
	
	ExecuteWatingRequeuets();		
}


void CReadWriteLockAsyncExcutor::Close()
/*++

Routine Description:
    Cancell all waiting requests

Arguments:
    None.

Returned Value:
    None

Note:

	This function is called to force completion  of all wating requests.
	The function will force callback for all requests that has not yet executed by
	calling Close method on the IAsyncExecutionRequest interface. 
    
--*/
{
	CS cs(m_Lock);

	while(!m_WatingForExecutionQueue.empty())
	{
		const CExecutionContext ExecutionContext = m_WatingForExecutionQueue.front();		
		m_WatingForExecutionQueue.pop();
		ExecutionContext.m_AsyncExecution->Close();				
	}
	m_fClosed = true;
}


///////////////////////////////////////////////////////////////
//////////////////////// private member functions /////////////
///////////////////////////////////////////////////////////////


void CReadWriteLockAsyncExcutor::ExecuteReader(IAsyncExecutionRequest* pAsyncExecute)
/*++

Routine Description:
    Lock for read and excute request.

Arguments:
    pAsyncExecute - async request.
	

Returned Value:
    None

Note:
    
--*/
{
	ASSERT(!IsWriteLockOn());
	++m_NumOfActiveReaders;
	SafeExecute(pAsyncExecute);
}



void CReadWriteLockAsyncExcutor::ExecuteWriter(IAsyncExecutionRequest* pAsyncExecute)
/*++

Routine Description:
    Lock for WRITE and excute request.

Arguments:
    pAsyncExecute - async request.
	

Returned Value:
    None

Note:
--*/
{
	ASSERT(!IsReadLockOn());
	ASSERT(!IsWriteLockOn());
	++m_NumOfActiveWritters;
	SafeExecute(pAsyncExecute);
}


bool CReadWriteLockAsyncExcutor::IsWriteLockOn() const
{
	ASSERT(m_NumOfActiveWritters <= 1);
	return m_NumOfActiveWritters == 1;
}


bool CReadWriteLockAsyncExcutor::IsReadLockOn() const
{
	return m_NumOfActiveReaders > 0;
}


void CReadWriteLockAsyncExcutor::ExecuteWatingRequeuets()
/*++

Routine Description:
    Execurte wating request. 

Arguments:
   

Returned Value:
    None

Note:
	The function execute read requests from the wating queue untill it encounter  a write request.
	If there is no wating read request  - it execute one wating write request  (if exist)

--*/
{
	ASSERT(!IsWriteLockOn());
	ASSERT(!IsReadLockOn());

	while(!m_WatingForExecutionQueue.empty())
	{
		ASSERT(!IsClosed());

		//
		// If the request is reader request - execute it and continute the loop
		// to execute more readers
		//
		const CExecutionContext ExecutionContext = m_WatingForExecutionQueue.front();	
		if(ExecutionContext.m_locktype == Read)
		{
			m_WatingForExecutionQueue.pop();
			ExecuteReader(ExecutionContext.m_AsyncExecution);		
			continue;
		}
		
		//
		// If the request is writer request check there is no read lock -
		// execute it and exit the loop
		//
		if(!IsReadLockOn())
		{
			m_WatingForExecutionQueue.pop();
			ExecuteWriter(ExecutionContext.m_AsyncExecution);				
		}
		
		return;
	}
}



void CReadWriteLockAsyncExcutor::SafeExecute(IAsyncExecutionRequest* pAsyncExecute)throw()
{
	try
	{
		pAsyncExecute->Run();
	}
	catch(const exception&)
	{
		pAsyncExecute->Close();
	}
}




bool CReadWriteLockAsyncExcutor::IsClosed() const
{
	return m_fClosed == true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\test\asyncexecutionrequest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    AsyncExecutionRequest.cpp

Abstract:
    Implementation of class CReadWriteLockAsyncExcutor (AsyncExecutionRequest.h).


Owner:
    Gil Shafriri(gilsh) 2-July-2001


Environment:
    Platform-independent,

--*/


#include <libpch.h>
#include "AsyncExecutionRequest.h"
#include "CAsyncCaller.h"


CTestAsyncExecutionRequest::CTestAsyncExecutionRequest(
					CAsyncCaller& AsyncCaller
					):
					EXOVERLAPPED(OnOk, OnFailed),
					m_AsyncCaller(AsyncCaller)
					{
					}	

void CTestAsyncExecutionRequest::Run()
{
	printf("CTestAsyncExecutionRequest run function called \n"); 
	if(rand() % 2 == 0)
		throw exception();

	ExPostRequest(this);
}



void	CTestAsyncExecutionRequest::Close()throw()
{
	printf("CTestAsyncExecutionRequest close function called \n");
	SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(this);
}



void WINAPI  CTestAsyncExecutionRequest::OnOk(EXOVERLAPPED* povl)
{
	printf("CTestAsyncExecutionRequest run function completed ok ovl=%p \n", povl); 
	CTestAsyncExecutionRequest* Me = static_cast<CTestAsyncExecutionRequest*>(povl); 
	Me->m_AsyncCaller.OnOk(Me);
}



void WINAPI CTestAsyncExecutionRequest::OnFailed(EXOVERLAPPED* povl)
{
	printf("CTestAsyncExecutionRequest run failed  ovl=%p \n", povl); 
	CTestAsyncExecutionRequest* Me = static_cast<CTestAsyncExecutionRequest*>(povl); 
	Me->m_AsyncCaller.OnFailed(Me);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\lib\scheduler.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    scheduler.cpp

Abstract:
    Scheduler Implementation
    The Scheduler enables to schedule a callback when timer occurs.

    The Scheduler maintains a linked list of all the events to be scheduled,
    ordered by the time of their schedule (in ticks).

    The Scheduler object does not assure that the timer events callbacks will be
    called exactly when scheduled. Only never before their schedule.

Author:
    Uri Habusha (urih)   18-Feb-98

Enviroment:
    Pltform-independent

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"
#include <list.h>

#include "scheduler.tmh"

//---------------------------------------------------------
//
// CTimer Implementation
//
//---------------------------------------------------------
inline const CTimeInstant& CTimer::GetExpirationTime() const
{
    return m_ExpirationTime;
}

inline void CTimer::SetExpirationTime(const CTimeInstant& ExpirationTime)
{
    m_ExpirationTime = ExpirationTime;
}


//---------------------------------------------------------
//
// CScheduler
//
//---------------------------------------------------------
class CScheduler {
public:
    CScheduler();
    ~CScheduler();

    void SetTimer(CTimer* pTimer, const CTimeInstant& expirationTime);
    bool CancelTimer(CTimer* pTimer);

private:
    CTimeInstant Wakeup(const CTimeInstant& CurrentTime);

private:
    static DWORD WINAPI SchedulerThread(LPVOID);

private:
	//
	// This critical section is initialized with preallocated resources, to avoid exceptions on entry.
	//
    mutable CCriticalSection m_cs;

    HANDLE m_hNewTimerEvent;
    List<CTimer> m_Timers;
    CTimeInstant m_WakeupTime;
};


CScheduler::CScheduler() :
	m_cs(CCriticalSection::xAllocateSpinCount),
    m_WakeupTime(CTimeInstant::MaxValue())
{
    //
    // m_hNewTimerEvent - use to indicate insert of new object to the schedule.
    // The object is inserted to head of the Scheduler such it must handle immediately
    //
    m_hNewTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hNewTimerEvent == NULL)
    {
        TrERROR(GENERAL, "Failed to create an event. Error=%d", GetLastError());
        throw bad_alloc();
    }

    //
    // Create a scheduling thread. This thread is responsible to handle scheduling
    // expiration
    //
    DWORD tid;
    HANDLE hThread;
    hThread = CreateThread(
                        NULL,
                        0,
                        SchedulerThread,
                        this,
                        0,
                        &tid
                        );
    if (hThread == NULL)
    {
        TrERROR(GENERAL, "Failed to create a thread. Error=%d", GetLastError());
        throw(bad_alloc());
    }

    CloseHandle(hThread);
}


CScheduler::~CScheduler()
{
    CloseHandle(m_hNewTimerEvent);
}


inline CTimeInstant CScheduler::Wakeup(const CTimeInstant& CurrentTime)
/*++

Routine description:
  It dispatches all timers that expired before CurrentTime. Their associated
  callback routine is invoked.

Arguments:
  None

Return Value:
  Next expiration time in 100ns (FILETIME format).

 --*/
{
    CS lock(m_cs);

    for(;;)
    {
        if(m_Timers.empty())
        {
            //
            // No more timers, wait for the longest time.
            //
            m_WakeupTime = CTimeInstant::MaxValue();
            return m_WakeupTime;
        }

        CTimer* pTimer = &m_Timers.front();

        //
        // Is that time expired?
        //
        if (pTimer->GetExpirationTime() > CurrentTime)
        {
            //
            // No, wait for that one to expire.
            //
            m_WakeupTime = pTimer->GetExpirationTime();
            return m_WakeupTime;
        }

        TrTRACE(GENERAL, "Timer 0x%p expired %dms ticks late", pTimer, (CurrentTime - pTimer->GetExpirationTime()).InMilliSeconds());

        //
        // Remove the expired timer from the list
        //
        m_Timers.pop_front();

        //
        // Set the Timer pointer to NULL. This is an indication that the
        // Timer isn't in the list any more. In case of timer cancel
        // the routine checks if the entry is in the list (check Flink)
        // before trying to remove it
        //
        pTimer->m_link.Flink = pTimer->m_link.Blink = NULL;

        //
        // Invoke the timer callback routine using the completion port thread pool
        //
        try
        {
            ExPostRequest(&pTimer->m_ov);
        }
        catch(const exception&)
        {
            TrERROR(GENERAL, "Failed to post a timer to the completion port. Error=%d", GetLastError());

            //
            // Scheduling of even failed (generally becuase lack of resources).
            // returns the event, and try to handle it 1 second later
            //
            m_Timers.push_front(*pTimer);

            m_WakeupTime = CurrentTime + CTimeDuration::OneSecond();
            return m_WakeupTime;
        }
    }
}


DWORD
WINAPI CScheduler::SchedulerThread(
    LPVOID pParam
    )
/*++

Routine Description:
  Wakeup the timer when a timeout occures by calling Wakeup. A timer insertion
  would cause the waiting thread to go and re-arm for the next wakeup time.

Arguments:
  None

Return Value:
  None

Note:
  This routine never terminates.

 --*/
{
    CScheduler* pScheduler = static_cast<CScheduler*>(pParam);

    DWORD Timeout = _I32_MAX;

    for(;;)
    {
        TrTRACE(GENERAL, "Thread sleeping for %dms", Timeout);

        DWORD Result = WaitForSingleObject(pScheduler->m_hNewTimerEvent, Timeout);
		DBG_USED(Result);

        //
        // WAIT_OBJECT_0 Indicates that a new timer was set
        // WAIT_TIMEOUT  Indicates that a timer expired
        //
        ASSERT((Result == WAIT_OBJECT_0) || (Result == WAIT_TIMEOUT));

        CTimeInstant CurrentTime = ExGetCurrentTime();

        //
        // Fire all expired timers.
        //
        CTimeInstant ExpirationTime = pScheduler->Wakeup(CurrentTime);

        //
        // Adjust wakeup time to implementation using relative time, DWORD and milliseconds.
        //
        LONG WakeupTime = (ExpirationTime - CurrentTime).InMilliSeconds();
        ASSERT(WakeupTime >= 0);

        Timeout = WakeupTime;
    }
}


void CScheduler::SetTimer(CTimer* pTimer, const CTimeInstant& ExpirationTime)
{
    //
    // Insert the new entry to the Scheduler list. The routine
    // scans the list and look for the first iteam that its timeout
    // is later than the new one. The routine Insert the new iteam before
    // the previous one
    //
    CS lock(m_cs);

    //
    // The timer is already in the Scheduler
    //
    ASSERT(!pTimer->InUse());

    //
    // Set the Experation time.
    //
    pTimer->SetExpirationTime(ExpirationTime);

    List<CTimer>::iterator p = m_Timers.begin();

    while(p != m_Timers.end())
    {
        if(p->GetExpirationTime() > ExpirationTime)
        {
            break;
        }
        ++p;
    }

    m_Timers.insert(p, *pTimer);

    //
    // Check if the new element is to reschedule next wakeup.
    //
    if (m_WakeupTime > ExpirationTime)
    {
        //
        // The new timer Wakeup time is earlier than the current. Set the thread
        // event so SchedulerThread will update its Wait timeout.
        // Set m_WakeupTime to CurrentTime so new incomming events will not bother
        // to wake the scheduler thread again, until it processes the timers.
        //
        // Setting m_WakeupTime to 0 is also Okay.  erezh 28-Nov-98
        //
        TrTRACE(GENERAL, "Re-arming thread with Timer 0x%p. delta=%I64d", pTimer, (m_WakeupTime - ExpirationTime).Ticks());
        m_WakeupTime = CTimeInstant::MinValue();
        SetEvent(m_hNewTimerEvent);
    }
}


bool CScheduler::CancelTimer(CTimer* pTimer)
{
    //
    // Get the critical section at this point. Otherwise; time experation can't
    // occoured and to remove the timer from the scheduler. Than we try to remove it
    // and fails
    //
    CS lock(m_cs);

	//
	// Check if the timer is in the list. If no it already
	// removed from the list due timeout experation
	// or duplicate cancel operation
	//
	if (!pTimer->InUse())
	{
		return false;
	}

	//
	// The Timer in the list. Remove it and return TRUE
	// to the caller.
	//
	TrTRACE(GENERAL, "Removing timer 0x%p", pTimer);
	m_Timers.remove(*pTimer);

    //
    // Set the Timer pointer to NULL. This is an indication that the
    // Timer isn't in the list any more. In case of duplicate cancel
    // the routine checks if the entry is in the list (check Flink)
    // before trying to remove it
    //
    pTimer->m_link.Flink = pTimer->m_link.Blink = NULL;

    //PrintSchedulerList();

	return true;
}


static CScheduler*  s_pScheduler = NULL;


VOID
ExpInitScheduler(
    VOID
    )
{
    ASSERT(s_pScheduler == NULL);

    s_pScheduler = new CScheduler;
}


VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);

    TrTRACE(GENERAL, "Adding Timer 0x%p. timeout=%dms", pTimer, Timeout.InMilliSeconds());

    //
    // Calculate the Experation time in 100 ns
    //
    CTimeInstant ExpirationTime = ExGetCurrentTime() + Timeout;

    s_pScheduler->SetTimer(pTimer, ExpirationTime);
}


VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeInstant& ExpirationTime
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);

    TrTRACE(GENERAL, "Adding Timer 0x%p. Expiration time %I64d", pTimer, ExpirationTime.Ticks());

    s_pScheduler->SetTimer(pTimer, ExpirationTime);
}


BOOL
ExCancelTimer(
    CTimer* pTimer
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);
    return s_pScheduler->CancelTimer(pTimer);
}


CTimeInstant
ExGetCurrentTime(
    VOID
    )
{
    //
    // Don't need to check if initalized. No use of global date
    //
    //ExpAssertValid();

    ULONGLONG CurrentTime;
    GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&CurrentTime));

    return CTimeInstant(CurrentTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\test\casynccaller.h ===
/*
Module Name:
    CAsyncCaller.h

Abstract:
    Header file for class CAsyncCaller responsible for queueing async 
	requests under read or write lock using the class CAsyncLockExcutor.
	

Author:	 
    Gil Shafriri (gilsh), 2-July-2001

--*/

#pragma once

#ifndef _MSMQ_CAsyncCaller_H_
#define _MSMQ_CAsyncCaller_H_

class CReadWriteLockAsyncExcutor;
class IAsyncExecutionRequest;
class CTestAsyncExecutionRequest;

class CAsyncCaller
{
public:
	enum LockType{Read,Write};	

public:
	CAsyncCaller(CReadWriteLockAsyncExcutor& AsyncLockExcutor, LockType locktype);
	void OnOk(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);
	void OnFailed(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);
	void Run(IAsyncExecutionRequest* AsyncExecutionRequest);
	void CleanUp(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);


private:
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
	LockType m_locktype;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ex\test\extest.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    ExTest.cpp

Abstract:
    Test the Executive manager.

Author:
    Uri Habusha (urih)  25-Feb-98

--*/

#include <libpch.h>
#include <Ex.h>
#include "AsyncExecutionRequest.h"
#include "CAsyncCaller.h"

#include "ExTest.tmh"

class CExTest;

const DWORD MAX_TIMER = 3*64;

static CCriticalSection s_cs;

DWORD TimerNo = 0;
CExTest* TimerArray[MAX_TIMER];

DWORD NoOfCallBack = 0;
DWORD NoOfOKTimeout = 0;


class CExTest {
public:
    CExTest(
        CTimer::CALLBACK_ROUTINE pfnTimerCallbackRoutine,
        DWORD Timeout
        );

    ~CExTest();

    CTimer  m_Timer;
    HANDLE m_hEvent;
    DWORD m_ExperationTime;
    DWORD m_Index;
};

CExTest::CExTest(
    CTimer::CALLBACK_ROUTINE pfnTimerCallbackRoutine,
    DWORD Timeout
    ) :
    m_Timer(pfnTimerCallbackRoutine),
    m_ExperationTime(GetTickCount() + Timeout)
{
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hEvent == NULL)
    {
        TrERROR(GENERAL, "Failed to create event. error=%d", GetLastError());
        exit(-1);
    }
    
    {
        CS lock(s_cs);
        m_Index = TimerNo;
        TimerArray[TimerNo] = this;
        ++TimerNo;
    }
}

CExTest::~CExTest()
{
    Sleep(50);
    CS lock(s_cs);

    SetEvent(m_hEvent);
    TimerArray[m_Index] = NULL;
}

void
WINAPI
ScedulerCallBack(
    CTimer* pTimer
    )
{
    CExTest* p = CONTAINING_RECORD(pTimer, CExTest, m_Timer);

    ++NoOfCallBack;
    DWORD delay = (GetTickCount()-p->m_ExperationTime);
    if (20 >= delay)
    {
        ++NoOfOKTimeout;
    }

    TrTRACE(GENERAL, "Timer 0x%p called-back %dms late", pTimer, GetTickCount() - p->m_ExperationTime);

    SetEvent(p->m_hEvent);
    delete p;
}


void
WINAPI
CancelScedulerCallBack(
    CTimer* pTimer
    )
{
    CExTest* p = CONTAINING_RECORD(pTimer, CExTest, m_Timer);

    TrTRACE(GENERAL, "Timer 0x%p called-back %dms late", pTimer, GetTickCount() - p->m_ExperationTime);

    SetEvent(p->m_hEvent);
    if (ExCancelTimer(pTimer))
    {
        TrERROR(GENERAL, "Succeeded to cancel expired Timer 0x%p", p);
        exit(-1);
    }
    delete p;
}

DWORD 
WINAPI 
TestScheduler(
    LPVOID
    )
{
    srand(1234);
    HANDLE EventArray[64];

    for(int i = 0; i < 64; ++i)
    {
        DWORD WaitTime= rand() % (10000);
        CExTest* p = new CExTest(ScedulerCallBack, WaitTime); 
        EventArray[i] = p->m_hEvent;

        TrTRACE(GENERAL, "Set timer 0x%p with %dms timeout", p, WaitTime);
        ExSetTimer(&p->m_Timer, CTimeDuration(WaitTime * CTimeDuration::OneMilliSecond().Ticks()));
    }


    for(;;)
    {
        DWORD SleepTime = rand() % 100;
        DWORD rc = WaitForMultipleObjects(
                        64,
                        EventArray,
                        TRUE,
                        SleepTime
                        );

        if (rc == WAIT_FAILED)
        {
            TrERROR(GENERAL, "Failed while waiting for a timer. Error=%d", GetLastError());
            ASSERT(0);
            continue;
        }


        if (rc == WAIT_TIMEOUT)
        {
            DWORD RandIndex = rand() % TimerNo;
            CS lock(s_cs);

            for(;; RandIndex++)
            {
                if (RandIndex == TimerNo)
                {
                    break;
                }
                
                if (TimerArray[RandIndex] != NULL)
                {
                    TrTRACE(GENERAL, "Cancle timer 0x%p", TimerArray[RandIndex]);
                    BOOL fSucc = ExCancelTimer(&TimerArray[RandIndex]->m_Timer);
                    if (fSucc)
                    {
                        delete TimerArray[RandIndex];
                    }
                    else
                    {
                        TrTRACE(GENERAL, "Failed to cancel timer 0x%p", TimerArray[RandIndex]);
                    }
                    break;
                }
            }
        }
        else
        {
            break;
        }
    }

    return 0;
}

void 
SchedulerUnitTest(
    VOID
    )
{

    srand(1234);
    HANDLE EventArray[64];
    DWORD rc;

    TimerNo = 0;

    //
    // Create a timer and cancel it before timeout expiration
    //
    CExTest* p1 = new CExTest(ScedulerCallBack, 50);
    
    TrTRACE(GENERAL, "Set Timer 0x%p with 50ms timeout", p1);
    ExSetTimer(&(p1->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));
    if(!ExCancelTimer(&(p1->m_Timer)))
    {
        TrERROR(GENERAL, "Failed to cancel timer 0x%p", p1);
        exit(-1);
    }
    TrTRACE(GENERAL, "Timer 0x%p canceled", p1);

    rc = WaitForSingleObject(p1->m_hEvent, 150);
    if (rc != WAIT_TIMEOUT)
    {
        TrTRACE(GENERAL, "Timer 0x%p called-back after cancel", p1);
        exit(-1);
    }
    CloseHandle(p1->m_hEvent);
	delete p1;


    //
    // Create a timer and check that the callback routine is called
    //
    CExTest*  p = new CExTest(ScedulerCallBack, 50);
    
    TrTRACE(GENERAL, "Set Timer 0x%p with 50ms timeout", p);

    ExSetTimer(&(p->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));

    rc = WaitForSingleObject(p->m_hEvent, 1000);
    if (rc != WAIT_OBJECT_0)
    {
		CloseHandle(p->m_hEvent);

        TrTRACE(GENERAL, "Scheduler failed to expire timer 0x%p after 50ms", p);
        exit(-1);
    }

    //
    // Create 10 scheduler event and checks that they complete in order
    //
    TimerNo = 0;
    for(DWORD i = 0; i < 10; ++i)
    {
        DWORD WaitTime= 100*i +50;
        CExTest* p = new CExTest(ScedulerCallBack, WaitTime); 
        EventArray[i] = p->m_hEvent;

        TrTRACE(GENERAL, "Set Timer 0x%p with %dms timeout", p, WaitTime);
        ExSetTimer(&(p->m_Timer), CTimeDuration(WaitTime * CTimeDuration::OneMilliSecond().Ticks()));
    }

    for (i=0; i < 10; i++)
    {
        DWORD rc = WaitForMultipleObjects(
                        10-i,
                        &EventArray[i],
                        FALSE,
                        300
                        );
        if (rc != WAIT_OBJECT_0)
        {
            TrTRACE(GENERAL, "Timer 0x%p failed to call-back after %dms", TimerArray[i], 50+i*10);
            exit(-1);
        }
        ResetEvent(EventArray[i]);
        TrTRACE(GENERAL, "rc=%d, i=%d", rc, i);
        
    }

    //
    // Setup a Timer and try to cancel it after expiration time.
    // If the cancel success, the test failes and returns -1.
    //
    CExTest* p2 = new CExTest(CancelScedulerCallBack, 50);

    TrTRACE(GENERAL, "Set Timer 0x%p with 50ms timeout", p2);
    ExSetTimer(&(p2->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));

    rc = WaitForSingleObject(p2->m_hEvent, 200);
    if (rc != WAIT_OBJECT_0)
    {
        TrTRACE(GENERAL, "Timer 0x%p failed to call-back after 50ms", p2);
        exit(-1);
    }
    CloseHandle(p2->m_hEvent);
}


void 
SchedulerBlackBoxTest(
    void
    )
{
    HANDLE hThread[3];
 
    NoOfCallBack = 0;
    NoOfOKTimeout = 0;
    TimerNo = 0;
    
    for(int i = 0; i < 3; ++i)
    {
        DWORD tid;
        hThread[i] = CreateThread(
                            NULL, 
                            0, 
                            TestScheduler, 
                            NULL,
                            0,
                            &tid
                            );
        if (hThread[i] == NULL)
        {
            TrERROR(GENERAL, "Failed to create test thread. Error=%d", GetLastError()); 
            exit(-1);
        }
    }
    
    WaitForMultipleObjects(3, hThread, TRUE, INFINITE);
}



void AsyncExecutionReadWriteLockTest()
{
	CReadWriteLockAsyncExcutor ReadWriteLockAsyncExcutor;

	CAsyncCaller::LockType locktype = (rand() % 5 == 0) ? CAsyncCaller::Write : CAsyncCaller::Read;

	CAsyncCaller  AsyncCaller(ReadWriteLockAsyncExcutor, locktype);
	int Loops = 500;

	for(int i = 0; i< Loops; ++i)
	{
		R<CTestAsyncExecutionRequest> TestAsyncExecutionRequest = new CTestAsyncExecutionRequest(AsyncCaller);
		R<CTestAsyncExecutionRequest> ref = TestAsyncExecutionRequest;
		
		AsyncCaller.Run(TestAsyncExecutionRequest.get());

		if(i == Loops - 10)
		{
			ReadWriteLockAsyncExcutor.Close();
		}

		Sleep(1);
		ref.detach();
	}

	
	Sleep(5000);

	
}


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Executive

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
 
    //
    // Initialize the Executive Manager
    //
    ExInitialize(5);

	Sleep(0);

    SchedulerUnitTest();
    SchedulerBlackBoxTest();
	AsyncExecutionReadWriteLockTest();

    TrTRACE(GENERAL, "Executive test pass successfully");

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fninit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnInit.cpp

Abstract:
    Format Name Parsing initialization

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Fn.h"
#include "Fnp.h"

#include "fninit.tmh"

VOID
FnInitialize(
	VOID
	)
/*++

Routine Description:
    Initializes Format Name Parsing library

    Note: Do not add initialization code that access AD, since initialization
    is done at each QM startup.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Format Name Parsing library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!FnpIsInitialized());
    FnpRegisterComponent();

    //
    // TODO: Write Format Name Parsing initalization code here
    //

    FnpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fngeneral.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    FnGenaral.h

Abstract:

Author:
    Nir Aides (niraides) 23-May-2000

--*/

#include <libpch.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "Fnp.h"
#include "FnGeneral.h"

#include "fngeneral.tmh"

bool CFunc_CompareQueueFormat::operator()(const QUEUE_FORMAT& obj1, const QUEUE_FORMAT& obj2) const	
{
	if(obj1.GetType() !=  obj2.GetType())
		return obj1.GetType() < obj2.GetType();

	if(obj1.Suffix() !=  obj2.Suffix())
		return obj1.GetType() < obj2.GetType();

	if(!obj1.IsSystemQueue() &&  obj2.IsSystemQueue())
		return true;	
	
	switch(obj1.GetType())
	{
	case QUEUE_FORMAT_TYPE_UNKNOWN: 
		return true;

	case QUEUE_FORMAT_TYPE_PUBLIC:
		return FnpCompareGuid(obj1.PublicID(), obj2.PublicID());

	case QUEUE_FORMAT_TYPE_PRIVATE:
		if(obj1.PrivateID().Uniquifier != obj2.PrivateID().Uniquifier)
			return obj1.PrivateID().Uniquifier < obj2.PrivateID().Uniquifier;

		return FnpCompareGuid(obj1.PrivateID().Lineage, obj2.PrivateID().Lineage); 

	case QUEUE_FORMAT_TYPE_DIRECT:
		//
		// BUGBUG: Replace with dedicated function. niraides 24-May-00
		//
		return _wcsicmp(obj1.DirectID(), obj2.DirectID()) < 0;

	case QUEUE_FORMAT_TYPE_MULTICAST:
		if(obj1.MulticastID().m_address == obj2.MulticastID().m_address)
			return obj1.MulticastID().m_port < obj2.MulticastID().m_port;
		
		return obj1.MulticastID().m_address < obj2.MulticastID().m_address;

	case QUEUE_FORMAT_TYPE_MACHINE:
		return FnpCompareGuid(obj1.MachineID(), obj2.MachineID());

	case QUEUE_FORMAT_TYPE_CONNECTOR:
		return FnpCompareGuid(obj1.ConnectorID(), obj2.ConnectorID());

	case QUEUE_FORMAT_TYPE_DL:
		return FnpCompareGuid(obj1.DlID().m_DlGuid, obj2.DlID().m_DlGuid);

	default:
		break;
	}

	ASSERT(FALSE);
	return false;
}


LPWSTR 
FnpCopyQueueFormat(
    QUEUE_FORMAT& qfTo, 
    const QUEUE_FORMAT& qfFrom
    )
/*++

Routine Description:
    copy one queue format to another.

Arguments:
    qfTo - destination queue format
    qfForm - source queue format

Returned Value:
    pointer to allocated string

Note:
    The routine doesn't free previous allocation. This is the caller responsibility to call 
    disposeString method before calling the routine

--*/

{
    qfTo = qfFrom;

    //
    // Note that suffix is not relevant since that queues are
    // opened for send.
    //

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
		ASSERT(qfFrom.DirectID() != NULL);

        LPWSTR pw = newwcs(qfFrom.DirectID());
        qfTo.DirectID(pw);
        return pw;
    }

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DL &&
        qfFrom.DlID().m_pwzDomain != NULL)
    {
        LPWSTR pw = newwcs(qfFrom.DlID().m_pwzDomain);

        DL_ID id;
        id.m_DlGuid    = qfFrom.DlID().m_DlGuid;
        id.m_pwzDomain = pw;

        qfTo.DlID(id);

        return pw;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fnformat.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnDebug.cpp

Abstract:
Implementation of class CFnQueueFormat and CFnMqf (fn.h)    

Author:
    Gil Shafriri (gilsh) 16-Aug-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <Fn.h>
#include "fnp.h"
#include <strsafe.h>

#include "fnformat.tmh"

void CFnQueueFormat::CreateFromFormatName(LPCWSTR pfn, bool fDuplicate)
/*++

Routine Description:
	create queue format object from given format name string
	
Arguments:
    IN - pfn - format name string to parse. 

	IN - fDuplicate - if true - copy existing string before parsing.
					  if false copy only if needed by parser and the caller
					  has to keep the input string valid  through the object liftime.
*/
{
	ASSERT(pfn != NULL);


	AP<WCHAR>  OriginalDupAutoDelete;
	pfn = fDuplicate ? (OriginalDupAutoDelete = newwcs(pfn)).get() : pfn;
	AP<WCHAR> ParsingResultAutoDelete;

	BOOL fSuccess = FnFormatNameToQueueFormat(pfn , this, &ParsingResultAutoDelete);
	if(!fSuccess)
		throw bad_format_name(pfn);

	SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
	SafeAssign(m_ParsingResultAutoDelete , ParsingResultAutoDelete);
}

void CFnQueueFormat::CreateFromFormatName(const xwcs_t& fn)
/*++

Routine Description:
		create queue format object from given format name string buffer.
	
Arguments:
    IN - fn - format name buffer to parse. 

    Note - the function copy the buffer supplied 
 
*/
{
	AP<WCHAR>  OriginalDupAutoDelete( fn.ToStr() );
	CreateFromFormatName(OriginalDupAutoDelete.get() , false);
    SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
}



void CFnQueueFormat::CreateFromUrl(LPCWSTR url, bool fDuplicate)
/*++

Routine Description:
		create queue format object from given url string.
	
Arguments:
    IN - url - url string to parse. 

	IN - fDuplicate - if true - copy existing string before parsing.
					  if false copy only if needed by parser and the caller
					  has to keep the input string valid  through the object liftime.
    
 
*/
{
	ASSERT(url != NULL);
	if(!FnIsHttpHttpsUrl(url))
	{
		TrERROR(GENERAL, "Got Invalid url %ls ",url);
		throw bad_format_name(url);
	}

	url = fDuplicate ? (m_OriginalDupAutoDelete = newwcs(url)).get() : url;
	DirectID(const_cast<LPWSTR>(url));     
}

void CFnQueueFormat::CreateFromUrl(const xwcs_t& url)
/*++

Routine Description:
		create queue format object from given url string buffer.
	
Arguments:
    IN - url - url string buffer to parse. 
*/
{
	AP<WCHAR>  OriginalDupAutoDelete( url.ToStr() );
	CreateFromUrl(OriginalDupAutoDelete.get() , false);
	SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
}


void CFnQueueFormat::CreateFromQueueFormat(const QUEUE_FORMAT& qf)
{
    ASSERT(("Illegal input QUEUE_FORMAT", qf.Legal()));

    if (&qf == this)
        return;

    //
    // free previous allocated data
    //
    m_OriginalDupAutoDelete.free();

    //
    // copy Queue Format
    //
    m_OriginalDupAutoDelete = FnpCopyQueueFormat(*this, qf);

    //
    // Set suffix value
    //
    Suffix(qf.Suffix());
}



void CFnMqf::CreateFromMqf(const xwcs_t& fn)
/*++

Routine Description:
		create list of queue formats object from given mqf buffer.
	
Arguments:
    IN - fn - mqf buffer to create the queue formats list from.
--*/
{
	AP<WCHAR> fnstr = fn.ToStr();
	CreateFromMqf(fnstr);
	SafeAssign(m_fnstr, fnstr);
}


void CFnMqf::CreateFromMqf(const WCHAR* fnstr)
/*++

Routine Description:
		create list of queue formats object from given mqf string.
	
Arguments:
    IN - fn - mqf string to create the queue formats list from.
--*/
{
	bool fSuccess = FnMqfToQueueFormats(
				  fnstr,
				  m_AutoQueueFormats,
				  &m_nQueueFormats,
				  strsToFree
				  ) == TRUE;

	if(!fSuccess)
	{
		throw bad_format_name(L"");
	}

	m_QueueFormats = m_AutoQueueFormats.get();
}

static std::wostream& operator<<(std::wostream& os, const MULTICAST_ID& mid)
/*++

Routine Description:
		Serialize multicast address into stream (doted format)
	
Arguments:
    os - stream
	mid - multicast address

Returned Value:
    The stream reference
--*/
{
	const WCHAR xMSMQColon[] = L":";

	os <<	((mid.m_address & 0x000000FF) >> 0)  << L"." << 
		    ((mid.m_address & 0x0000FF00) >> 8)  << L"." << 
		    ((mid.m_address & 0x00FF0000) >> 16) << L"." << 
		    ((mid.m_address & 0xFF000000) >> 24) << 
            xMSMQColon << mid.m_port;

	return os;
}

static std::wostream& operator<<(std::wostream& os, const GUID& guid)
/*++

Routine Description:
		Serialize guild into stream.
	
Arguments:
    os - stream
	guid - guid to serialize

Returned Value:
    The stream reference

--*/
{
    WCHAR strGuid[GUID_STR_LENGTH + 1];

    const GUID* pGuid = &guid;
	StringCchPrintf(strGuid, TABLE_SIZE(strGuid), GUID_FORMAT, GUID_ELEMENTS(pGuid));

    return (os << strGuid);
}



std::wostream& operator<<(std::wostream& os, const CFnSerializeQueueFormat& queue)
/*++

Routine Description:
		Serialize QUEUE_FORMAT into stream.
	
Arguments:
    os - stream
	queue - holds msmq QUEUE_FORMAT to serialize.

Returned Value:
    The stream reference

--*/
{
	switch(queue.m_qf.GetType())
	{
		case QUEUE_FORMAT_TYPE_DIRECT :
		    os <<FN_DIRECT_TOKEN<<FN_EQUAL_SIGN<<queue.m_qf.DirectID();
		    break;
            
        //
        // MSMQ:PUBLIC=guid\queue number
        //
        case QUEUE_FORMAT_TYPE_PUBLIC :
            os << FN_PUBLIC_TOKEN <<FN_EQUAL_SIGN<<queue.m_qf.PublicID();
            break;
            
        //
        // MSMQ:PRIVATE=guid\queue number
        //
        case QUEUE_FORMAT_TYPE_PRIVATE :
            os<< FN_PRIVATE_TOKEN
                << FN_EQUAL_SIGN
                << queue.m_qf.PrivateID().Lineage
                << FN_PRIVATE_SEPERATOR
                << std::hex<< queue.m_qf.PrivateID().Uniquifier << std::dec;
            break;

        //
        // MSMQ:MULTICAST=address:port
        //
        case QUEUE_FORMAT_TYPE_MULTICAST:
            os<< FN_MULTICAST_TOKEN
                << FN_EQUAL_SIGN
                << std::dec << queue.m_qf.MulticastID();
            break;

        //
        // MSMQ:DL=guid@domain
        //
        case QUEUE_FORMAT_TYPE_DL:
            os<< FN_DL_TOKEN
                << FN_EQUAL_SIGN
                << std::hex << queue.m_qf.DlID().m_DlGuid;

            if(queue.m_qf.DlID().m_pwzDomain != NULL)
				os << FN_AT_SIGN  << queue.m_qf.DlID().m_pwzDomain;

            break;

        default:
            ASSERT(("invalid format name found during message sirialization", 0));
	}
	return 	os;
}


std::wostream&
operator<<(
   std::wostream& os, 
   const CFnSerializeMqf& mqf
   )
/*++

Routine Description:
		Serialize array of QUEUE_FORMAT (mqf)  into stream.
	
Arguments:
    os - stream
	mqf - holds array of msmq QUEUE_FORMAT (mqf) to serialize.

Returned Value:
    The stream reference

--*/
{
	for(ULONG i = 0; i< mqf.m_count; i++)
	{
		os<<CFnSerializeQueueFormat(mqf.m_pqf[i]);

		if(i != mqf.m_count - 1 )
		{
			os.put(FN_MQF_SEPARATOR_C);
		}			
	}
	return os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fnp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Fnp.h

Abstract:
    Format Name Parsing private functions.

Author:
    Nir Aides (niraides) 21-May-00

--*/

#pragma once

#ifndef _MSMQ_Fnp_H_
#define _MSMQ_Fnp_H_

#ifdef _DEBUG

void FnpAssertValid(void);
void FnpSetInitialized(void);
BOOL FnpIsInitialized(void);
void FnpRegisterComponent(void);

#else // _DEBUG

#define FnpAssertValid() ((void)0)
#define FnpSetInitialized() ((void)0)
#define FnpIsInitialized() TRUE
#define FnpRegisterComponent() ((void)0)

#endif // _DEBUG


LPWSTR FnpCopyQueueFormat(QUEUE_FORMAT& qfTo, const QUEUE_FORMAT& qfFrom);


#endif // _MSMQ_Fnp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fngeneral.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    FnGenaral.h

Abstract:

Author:
    Nir Aides (niraides) 23-May-2000

--*/



#pragma once



#ifndef _FNGENERAL_H_
#define _FNGENERAL_H_



const LPCWSTR xClassSchemaQueue = L"msMQQueue";
const LPCWSTR xClassSchemaGroup = L"group";
const LPCWSTR xClassSchemaAlias = L"msMQ-Custom-Recipient";

#define LDAP_PREFIX L"LDAP://"
#define GLOBAL_CATALOG_PREFIX L"GC://"

#define LDAP_GUID_FORMAT L"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
#define LDAP_GUID_STR_LEN (32)

#define LDAP_PRINT_GUID_ELEMENTS(p)	\
	p[0],  p[1],  p[2],  p[3],	\
	p[4],  p[5],  p[6],  p[7],	\
	p[8],  p[9],  p[10], p[11],	\
	p[12], p[13], p[14], p[15]

#define LDAP_SCAN_GUID_ELEMENTS(p)	\
	p,		p + 1,	p + 2,	p + 3,	\
	p + 4,	p + 5,	p + 6,	p + 7,	\
	p + 8,	p + 9,	p + 10, p + 11,	\
	p + 12, p + 13, p + 14, p + 15



//
// BSTRWrapper and VARIANTWrapper are used to enable automatic resources 
// deallocation in the case of thrown exceptions.
//

class BSTRWrapper {
private:
    BSTR m_p;

public:
    BSTRWrapper(BSTR p = NULL) : m_p(p) {}
   ~BSTRWrapper()                       { if(m_p != NULL) SysFreeString(m_p); }

    operator BSTR() const     { return m_p; }
    BSTR* operator&()         { return &m_p;}
    BSTR detach()             { BSTR p = m_p; m_p = NULL; return p; }

private:
    BSTRWrapper(const BSTRWrapper&);
    BSTRWrapper& operator=(const BSTRWrapper&);
};



class VARIANTWrapper {
private:
    VARIANT m_p;

public:
    VARIANTWrapper() { VariantInit(&m_p); }
   ~VARIANTWrapper() 
	{ 
		HRESULT hr = VariantClear(&m_p);
		ASSERT(SUCCEEDED(hr));
		DBG_USED(hr);
	}

    operator const VARIANT&() const { return m_p; }
    operator VARIANT&()             { return m_p; }
    VARIANT* operator&()            { return &m_p;}

	const VARIANT& Ref() const { return m_p; }
	VARIANT& Ref() { return m_p; }

    VARIANTWrapper(const VARIANTWrapper& var)
	{
		VariantInit(&m_p);
		HRESULT hr = VariantCopy(&m_p, (VARIANT*)&var.m_p);
		if(FAILED(hr))
		{
            ASSERT(("Failure must be due to low memory", hr == E_OUTOFMEMORY));
			throw bad_alloc();
		} 
	}

private:
    VARIANTWrapper& operator=(const VARIANTWrapper&);
};



inline bool FnpCompareGuid(const GUID& obj1, const GUID& obj2)	
/*++
NOTE: 
	When this routine was written, it was needed, since the existance 
	of an implicit CTOR at QUEUE_FORMAT which takes a GUID object as argument,
	means that if ever an operator < () would be written to QUEUE_FORMAT,
	the expression obj1 < obj2, would invoke it, after an implicit type 
	conversion of obj1 and obj2 to the QUEUE_FORMAT type.

--*/
{
	C_ASSERT(sizeof(obj1) == 16);

	return (memcmp(&obj1, &obj2, sizeof(obj1)) < 0);
}



//
// A "function object" which is used to compare QUEUE_FORMAT objects
//
struct CFunc_CompareQueueFormat: std::binary_function<QUEUE_FORMAT, QUEUE_FORMAT, bool> 
{
	bool operator()(const QUEUE_FORMAT& obj1, const QUEUE_FORMAT& obj2) const;
};



#endif//_FNGENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fndebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnDebug.cpp

Abstract:
    Format Name Parsing debugging

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Fn.h"
#include "Fnp.h"

#include "fndebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Format Name Parsing state
//
void FnpAssertValid(void)
{
    //
    // FnInitalize() has *not* been called. You should initialize the
    // Format Name Parsing library before using any of its funcionality.
    //
    ASSERT(FnpIsInitialized());

    //
    // TODO:Add more Format Name Parsing validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void FnpSetInitialized(void)
{
    LONG fFnAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Format Name Parsing library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fFnAlreadyInitialized);
}


BOOL FnpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "FnDumpState(queue path name)",
        "Dump Format Name Parsing State to debugger",
        DumpState
    ),

    //
    // TODO: Add Format Name Parsing debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void FnpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    Format Name String --> QUEUE_FORMAT conversion routines

Authors:

    Erez Haba (erezh) 17-Jan-1997
	Nir Aides (niraides) 08-Aug-2000

Revision History:

--*/

#include <libpch.h>
#include "mqwin64a.h"
#include <qformat.h>
#include <fntoken.h>
#include <Fn.h>
#include <strutl.h>
#include <mc.h>
#include "Fnp.h"

#include "fnparse.tmh"

//=========================================================
//
//  Format Name String -> QUEUE_FORMAT conversion routines
//
//=========================================================

//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
//  N.B. if no white space is needed uncomment next line
//#define skip_ws(p) (p)
inline LPCWSTR skip_ws(LPCWSTR p)
{
    //
    //  Don't skip first non white space
    //
    while(iswspace(*p))
    {
        ++p;
    }

    return p;
}



//
// Skips white spaces backwards. returns pointer to leftmost whitespace
// found.
//
inline LPCWSTR skip_ws_bwd(LPCWSTR p, LPCWSTR pStartOfBuffer)
{
	ASSERT(p != NULL && pStartOfBuffer != NULL && p >= pStartOfBuffer);

    while(p > pStartOfBuffer && iswspace(*(p - 1)))
    {
        p--;
    }

    return p;
}



inline void ValidateCharLegality(LPCWSTR p)
{
	//
	// Characters that are illegal as part of machine and queue name.
	// L'\x0d' is an escape sequence designating the character whose code is d in hex (carriage return)
	//

	if(*p == L'\x0d' || *p == L'\x0a' || *p == L'+' || *p == L'"' || *p == FN_DELIMITER_C)
	{
		TrERROR(GENERAL, "Queue name contains illegal characters '%ls'", p);
		throw bad_format_name(p);
	}
}



//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR FindPathNameDelimiter(LPCWSTR p)
{
	LPCWSTR PathName = p;

	for(; *p != L'\0' && *p != FN_DELIMITER_C; p++)
	{
		ValidateCharLegality(p);
	}

	if(*p != FN_DELIMITER_C)
	{
		TrERROR(GENERAL, "Failed to find path delimiter in '%ls'", PathName);
		throw bad_format_name(PathName);
	}
	
	return p;
}



//---------------------------------------------------------
//
//  Parse Format Name Type prefix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrefixString(LPCWSTR p, QUEUE_FORMAT_TYPE& qft)
{
    const int unique = 1;
    //----------------0v-------------------------
    ASSERT(L'U' == FN_PUBLIC_TOKEN    [unique]);
    ASSERT(L'U' == FN_MULTICAST_TOKEN [unique]);
    ASSERT(L'R' == FN_PRIVATE_TOKEN   [unique]);
    ASSERT(L'O' == FN_CONNECTOR_TOKEN [unique]);
    ASSERT(L'A' == FN_MACHINE_TOKEN   [unique]);
    ASSERT(L'I' == FN_DIRECT_TOKEN    [unique]);
    ASSERT(L'L' == FN_DL_TOKEN    [unique]);
    //----------------0^-------------------------

    //
    //  accelarate token recognition by checking 2nd character
    //
    switch(towupper(p[unique]))
    {
        //  pUblic or mUlticast
        case L'U':
            qft = QUEUE_FORMAT_TYPE_PUBLIC;
            if(_wcsnicmp(p, FN_PUBLIC_TOKEN, FN_PUBLIC_TOKEN_LEN) == 0)
                return (p + FN_PUBLIC_TOKEN_LEN);

            qft = QUEUE_FORMAT_TYPE_MULTICAST;
            if(_wcsnicmp(p, FN_MULTICAST_TOKEN, FN_MULTICAST_TOKEN_LEN) == 0)
                return (p + FN_MULTICAST_TOKEN_LEN);

            break;

        //  pRivate
        case L'R':
            qft = QUEUE_FORMAT_TYPE_PRIVATE;
            if(_wcsnicmp(p, FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
                return (p + FN_PRIVATE_TOKEN_LEN);
            break;

        //  cOnnector
        case L'O':
            qft = QUEUE_FORMAT_TYPE_CONNECTOR;
            if(_wcsnicmp(p, FN_CONNECTOR_TOKEN, FN_CONNECTOR_TOKEN_LEN) == 0)
                return (p + FN_CONNECTOR_TOKEN_LEN);
            break;

        //  mAchine
        case L'A':
            qft = QUEUE_FORMAT_TYPE_MACHINE;
            if(_wcsnicmp(p, FN_MACHINE_TOKEN, FN_MACHINE_TOKEN_LEN) == 0)
                return (p + FN_MACHINE_TOKEN_LEN);
            break;

        //  dIrect
        case L'I':
            qft = QUEUE_FORMAT_TYPE_DIRECT;
            if(_wcsnicmp(p, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TOKEN_LEN);
            break;

        //  dL
        case L'L':
            qft = QUEUE_FORMAT_TYPE_DL;
            if(_wcsnicmp(p, FN_DL_TOKEN, FN_DL_TOKEN_LEN) == 0)
                return (p + FN_DL_TOKEN_LEN);
            break;

    }

	TrERROR(GENERAL, "Failed to find format name prefix in '%ls'.", p);
    throw bad_format_name(p);
}


//---------------------------------------------------------
//
//  Parse a guid string, into guid.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR FnParseGuidString(LPCWSTR p, GUID* pg)
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    int n;
    UINT w2, w3, d[8];
	unsigned long Data1;

    if(_snwscanf(
            p,
			GUID_STR_LENGTH,
            GUID_FORMAT L"%n",
            &Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7],     //  Data4[4..7]
            &n                              //  number of characters scaned
            ) != 11)
    {
        //
        //  not all 11 fields where not found.
        //
		TrERROR(GENERAL, "Failed parsing of GUID string '%ls'.", p);
        throw bad_format_name(p);
    }

	pg->Data1 = Data1;
    pg->Data2 = (WORD)w2;
    pg->Data3 = (WORD)w3;
    for(int i = 0; i < 8; i++)
    {
        pg->Data4[i] = (BYTE)d[i];
    }

    return (p + n);
}


//---------------------------------------------------------
//
//  Parse private id uniquifier, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrivateIDString(LPCWSTR p, ULONG* pUniquifier)
{
    int n;
    if(_snwscanf(
            p,
			FN_PRIVATE_ID_FORMAT_LEN,
            FN_PRIVATE_ID_FORMAT L"%n",
            pUniquifier,
            &n                              //  number of characters scaned
            ) != 1)
    {
        //
        //  private id field was not found.
        //
		TrERROR(GENERAL, "Failed parsing of private id '%ls'.", p);
        throw bad_format_name(p);
    }

	if(*pUniquifier == 0)
	{
		TrERROR(GENERAL, "Found zero private id in '%ls'.", p);
		throw bad_format_name(p);
	}

    return (p + n);
}

//---------------------------------------------------------
//
//  Parse queue name string, (private, public)
//  N.B. queue name must end with either format name suffix
//      delimiter aka ';' or with end of string '\0'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseQueueNameString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if(_wcsnicmp(p, FN_SYSTEM_QUEUE_PATH_INDICATIOR, FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        p += FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH;
        *pqpt = SYSTEM_QUEUE_PATH_TYPE;
        return p;
    }

    if(_wcsnicmp(p, FN_PRIVATE_QUEUE_PATH_INDICATIOR, FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        *pqpt = PRIVATE_QUEUE_PATH_TYPE;
        p += FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH;
    }
    else
    {
        *pqpt = PUBLIC_QUEUE_PATH_TYPE;
    }

    //
    //  Zero length queue name is illegal
    //
    if(*p == L'\0')
	{
		TrERROR(GENERAL, "Found zero length queue name in '%ls'.", p);
		throw bad_format_name(p);
	}

    while(
        (*p != L'\0') &&
        (*p != FN_SUFFIX_DELIMITER_C) &&
        (*p != FN_MQF_SEPARATOR_C)
        )
    {
		ValidateCharLegality(p);
        ++p;
    }

    return p;
}


//---------------------------------------------------------
//
//  Parse machine name in a path name
//  N.B. machine name must end with a path name delimiter aka slash '\\'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseMachineNameString(LPCWSTR p)
{
    //
    //  Zero length machine name is illegal
    //  don't fall off the string (p++)
    //
    if(*p == FN_DELIMITER_C)
	{
		TrERROR(GENERAL, "Found zero length machine name in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = FindPathNameDelimiter(p);

    return (p + 1);
}


//---------------------------------------------------------
//
//  Check if this is an expandable machine path. i.e., ".\\"
//
inline BOOL IsExpandableMachinePath(LPCWSTR p)
{
    return ((p[0] == FN_LOCAL_MACHINE_C) && ((p[1] == FN_DELIMITER_C) || (p[1] == FN_HTTP_SEPERATOR_C)));
}

//---------------------------------------------------------
//
//  Optionally expand a path name with local machine name.
//  N.B. expansion is done if needed.
//  return pointer to new/old string
//
static LPCWSTR ExpandPathName(LPCWSTR pStart, ULONG_PTR offset, LPWSTR* ppStringToFree)
{
	ASSERT(ppStringToFree != 0);

    LPCWSTR pSeparator = wcschr(pStart, FN_MQF_SEPARATOR_C);
    LPWSTR pCopy;
    ULONG_PTR cbCopySize;

    if(!IsExpandableMachinePath(&pStart[offset]))
    {
        if (pSeparator == 0)
            return pStart;

        if (pSeparator == pStart)
        	throw bad_format_name(pStart);

        //
        // We are part of MQF, but no expansion needed - copy the rest of the string till the separator
        //

        cbCopySize = pSeparator - pStart + 1;
        pCopy = new WCHAR[cbCopySize];
        memcpy(pCopy, pStart, (cbCopySize-1)*sizeof(WCHAR));
    }
    else
    {
        size_t len;

        if (pSeparator != 0)
        {
            len = pSeparator - pStart;
        }
        else
        {
            len = wcslen(pStart);
        }

        cbCopySize = len + McComputerNameLen() + 1 - 1;
        pCopy = new WCHAR[cbCopySize];

        //
        //  copy prefix, till offset '.'
        //
        memcpy(
            pCopy,
            pStart,
            offset * sizeof(WCHAR)
            );

        //
        //  copy computer name to offset
        //
        memcpy(
            pCopy + offset,
            McComputerName(),
            McComputerNameLen() * sizeof(WCHAR)
            );

        //
        //  copy rest of string not including dot '.'
        //
        memcpy(
            pCopy + offset + McComputerNameLen(),
            pStart + offset + 1,                        // skip dot
            (len - offset - 1) * sizeof(WCHAR)      // skip dot
            );
    }

    pCopy[cbCopySize - 1] = '\0';

    *ppStringToFree = pCopy;
    return pCopy;
}


//---------------------------------------------------------
//
//  Parse OS direct format string. (check validity of path
//  name and optionally expand it)
//  ppDirectFormat - expended direct format string. (in out)
//  ppStringToFree - return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectOSString(
    LPCWSTR p,
    LPCWSTR* ppDirectFormat,
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    LPCWSTR pMachineName = p;
    LPCWSTR pStringToCopy = *ppDirectFormat;

    p = ParseMachineNameString(p);

    p = ParseQueueNameString(p, pqpt);

    *ppDirectFormat = ExpandPathName(pStringToCopy, (pMachineName - pStringToCopy), ppStringToFree);

    return p;
}

//---------------------------------------------------------
//
//  Parse net (tcp) address part of direct format string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseNetAddressString(LPCWSTR p)
{
    //
    //  Zero length address string is illegal
    //  don't fall off the string (p++)
    //
    if(*p == FN_DELIMITER_C)
	{
		TrERROR(GENERAL, "Found zero length net address string in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = FindPathNameDelimiter(p);

    return (p + 1);
}

//---------------------------------------------------------
//
//  Parse HTTP / HTTPS direct format string.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR
ParseDirectHttpString(
    LPCWSTR p,
    LPCWSTR* ppDirectFormat,
    LPWSTR* ppStringToFree
    )
{
	size_t MachineNameOffset = p - *ppDirectFormat;

	//
	// Check host name is available
	//
    if(wcschr(FN_HTTP_SEPERATORS, *p) != 0)
	{
		TrERROR(GENERAL, "Found zero length host name in '%ls'.", p);
		throw bad_format_name(p);
	}

	for(; *p != L'\0' && *p != FN_SUFFIX_DELIMITER_C && *p != FN_MQF_SEPARATOR_C; p++)
	{
		NULL;
	}

    *ppDirectFormat = ExpandPathName(*ppDirectFormat, MachineNameOffset, ppStringToFree);

    return p;
}

//---------------------------------------------------------
//
//  Parse net (tcp) direct format string. (check validity of queue name)
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectNetString(
	LPCWSTR p,
    LPCWSTR* ppDirectFormat,
    LPWSTR* ppStringToFree,
	QUEUE_PATH_TYPE* pqpt
	)
{
    p = ParseNetAddressString(p);

    p = ParseQueueNameString(p, pqpt);

    if(wcschr(p, FN_MQF_SEPARATOR_C) == NULL)
		return p;

	//
	// This is an MQF. a copy is needed to seperate our format name.
	//

	size_t Length = p - *ppDirectFormat;
	*ppStringToFree = new WCHAR[Length + 1];

    memcpy(*ppStringToFree, *ppDirectFormat, Length * sizeof(WCHAR));
	(*ppStringToFree)[Length] = L'\0';
	*ppDirectFormat = *ppStringToFree;

	return p;
}



static void RemoveSuffixFromDirect(LPCWSTR* ppDirectFormat, LPWSTR* ppStringToFree)
{
    ASSERT(ppStringToFree != NULL);

    LPCWSTR pSuffixDelimiter = wcschr(*ppDirectFormat, FN_SUFFIX_DELIMITER_C);
    ASSERT(pSuffixDelimiter != NULL);
	if(pSuffixDelimiter == NULL)
	{
		TrERROR(GENERAL, "Expected to find suffix delimiter in format name '%ls'", *ppDirectFormat);
		throw bad_format_name(L"");
	}

    INT_PTR len = pSuffixDelimiter - *ppDirectFormat;
    LPWSTR pCopy = new WCHAR[len + 1];
    wcsncpy(pCopy, *ppDirectFormat, len);
    pCopy[len] = '\0';

    if (*ppStringToFree != NULL)
	{
        delete [] *ppStringToFree;
	}
    *ppDirectFormat = *ppStringToFree = pCopy;
}



inline bool IsPreviousCharDigit(LPCWSTR p, int index)
{
	return ((index > 0) && iswdigit(p[index - 1]));
}



inline bool IsNextCharDigit(LPCWSTR p, int index, int StrLength)
{
	return ((index + 1 < StrLength) && iswdigit(p[index + 1]));
}



LPCWSTR
FnParseMulticastString(
    LPCWSTR p,
    MULTICAST_ID* pMulticastID
	)
/*++
Routine description:
	Parses a multicast address in the form of <ip address>:<port number>
	to a MULTICAST_ID structure.

Return value:
	pointer to end of multicast address. Parsing can continue from there.

	Throws bad format name on failure.
--*/
{
	ASSERT(("Bad parameter", pMulticastID != NULL));

	int n;

	ULONG Byte1;
	ULONG Byte2;
	ULONG Byte3;
	ULONG Byte4;

	MULTICAST_ID MulticastID;

	size_t Result = swscanf(
						p,
						L"%u.%u.%u.%u:%u%n",
						&Byte1,
						&Byte2,
						&Byte3,
						&Byte4,
						&MulticastID.m_port,
						&n
						);
	if(Result < 5)
	{
		TrERROR(GENERAL, "Bad MulticastAddress in '%ls'", p);
		throw bad_format_name(p);
	}

	for(int i = 0; i < n; i++)
	{
		//
		// Check numbers have no leading zeroes
		// A zero is a leading zero if the character before it is not a digit and the
		// character after it is a digit.
		//

		if(!IsPreviousCharDigit(p, i) && p[i] == L'0' && IsNextCharDigit(p, i , n))
		{
			TrERROR(GENERAL, "Bad MulticastAddress. Leading zeroes in '%ls'", p);
			throw bad_format_name(p);
		}

		//
		// Check no whitespaces in address
		//

		if(iswspace(p[i]))
		{
			TrERROR(GENERAL, "Bad MulticastAddress. Spaces found in '%ls'", p);
			throw bad_format_name(p);
		}
	}

	//
	// Does either one of the bytes exceed 255?
	//
	if((Byte1 | Byte2 | Byte3 | Byte4) > 255)
	{
		TrERROR(GENERAL, "Bad IP in Multicast Address. Non byte values in '%ls'", p);
		throw bad_format_name(p);
	}

	if((Byte1 & 0xf0) != 0xe0)
	{
		TrERROR(GENERAL, "Bad IP in Multicast Address. Not a class D IP address in '%ls'", p);
		throw bad_format_name(p);
	}

	MulticastID.m_address =
		(Byte4 << 24) |
		(Byte3 << 16) |
		(Byte2 << 8)  |
		(Byte1);			
	
    //
    // Check that the port is a USHORT
    //
    USHORT port = static_cast<USHORT>(MulticastID.m_port);
    if (port != MulticastID.m_port)
    {
		TrERROR(GENERAL, "Bad port number in Multicast Address in '%ls'", p);
		throw bad_format_name(p);
    }

	*pMulticastID = MulticastID;

	return p + n;
}



//---------------------------------------------------------
//
//  Parse direct format string.
//  return expended direct format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectString(
    LPCWSTR p,
    LPCWSTR* ppExpandedDirectFormat,
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    *ppExpandedDirectFormat = p;

    DirectQueueType dqt;
    p = FnParseDirectQueueType(p, &dqt);

    switch(dqt)
    {
        case dtOS:
            p = ParseDirectOSString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case dtTCP:
            p = ParseDirectNetString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case dtHTTP:
        case dtHTTPS:
            p = ParseDirectHttpString(p, ppExpandedDirectFormat, ppStringToFree);
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    // Remove suffix (like ;Journal)
    //
    if(*p == FN_SUFFIX_DELIMITER_C)
    {
		if(dqt == dtHTTP || dqt == dtHTTPS)
		{
			TrERROR(GENERAL, "Unsuported suffix in DIRECT HTTP format name '%ls'", p);
			throw bad_format_name(p);
		}

        RemoveSuffixFromDirect(ppExpandedDirectFormat, ppStringToFree);
    }
    return p;
}

//---------------------------------------------------------
//
//  Parse DL format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDlString(
    LPCWSTR p,
    GUID* pguid,
    LPWSTR* ppDomainName,
    LPWSTR* ppStringToFree
    )
{
    p = FnParseGuidString(p, pguid);

    *ppDomainName = 0;
    //
    // Check if we have a domain that comes with the DL
    //
    if (*p != FN_AT_SIGN_C)
    {
        return p;
    }
    p++;

    LPCWSTR pSeparator = wcschr(p, FN_MQF_SEPARATOR_C);
    if (pSeparator == 0)
    {
        *ppDomainName = const_cast<LPWSTR>(p);
        return p + wcslen(p);
    }

	//
	// We are to copy the domain name without trailing white spaces.
	//
	LPCWSTR pEndOfDomainString = skip_ws_bwd(pSeparator, p);
    ULONG_PTR cbCopyLen = pEndOfDomainString - p;

	if(cbCopyLen == 0)
	{
		//
		// No none white space characters were found after the '@' sign
		//
		TrERROR(GENERAL, "Domain name expected at '%ls'", p);
        throw bad_format_name(p);
	}

    ASSERT(ppStringToFree != 0);
    ASSERT(*ppStringToFree == 0);
	
    LPWSTR pCopy = new WCHAR[cbCopyLen + 1];
    memcpy(pCopy, p, cbCopyLen * sizeof(WCHAR));
    pCopy[cbCopyLen] = L'\0';

    *ppDomainName = *ppStringToFree = pCopy;

    return pSeparator;
}





//---------------------------------------------------------
//
//  Parse format name suffix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseSuffixString(LPCWSTR p, QUEUE_SUFFIX_TYPE& qst)
{
    const int unique = 5;
    //---------------01234v----------------------
    ASSERT(L'N' == FN_JOURNAL_SUFFIX    [unique]);
    ASSERT(L'L' == FN_DEADLETTER_SUFFIX [unique]);
    ASSERT(L'X' == FN_DEADXACT_SUFFIX   [unique]);
    ASSERT(L'O' == FN_XACTONLY_SUFFIX   [unique]);
    //---------------01234^----------------------

    //
    //  we already know that first character is ";"
    //
    ASSERT(*p == FN_SUFFIX_DELIMITER_C);

    //
    //  accelarate token recognition by checking 6th character
    //
    switch(towupper(p[unique]))
    {
        // ;jourNal
        case L'N':
            qst = QUEUE_SUFFIX_TYPE_JOURNAL;
            if(_wcsnicmp(p, FN_JOURNAL_SUFFIX, FN_JOURNAL_SUFFIX_LEN) == 0)
                return (p + FN_JOURNAL_SUFFIX_LEN);
            break;

        // ;deadLetter
        case L'L':
            qst = QUEUE_SUFFIX_TYPE_DEADLETTER;
            if(_wcsnicmp(p, FN_DEADLETTER_SUFFIX, FN_DEADLETTER_SUFFIX_LEN) == 0)
                return (p + FN_DEADLETTER_SUFFIX_LEN);
            break;

        // ;deadXact
        case L'X':
            qst = QUEUE_SUFFIX_TYPE_DEADXACT;
            if(_wcsnicmp(p, FN_DEADXACT_SUFFIX, FN_DEADXACT_SUFFIX_LEN) == 0)
                return (p + FN_DEADXACT_SUFFIX_LEN);
            break;

        // ;xactOnly
        case L'O':
            qst = QUEUE_SUFFIX_TYPE_XACTONLY;
            if(_wcsnicmp(p, FN_XACTONLY_SUFFIX, FN_XACTONLY_SUFFIX_LEN) == 0)
                return (p + FN_XACTONLY_SUFFIX_LEN);
            break;
    }

	TrERROR(GENERAL, "Found Bad suffix in '%ls'", p);
    throw bad_format_name(p);
}


//---------------------------------------------------------
//
//  Function:
//      ParseOneFormatName
//
//  Description:
//      Parses one format name string (stand alone or part of MQF) and converts it to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
LPCWSTR
ParseOneFormatName(
    LPCWSTR p,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
    QUEUE_FORMAT_TYPE qft;

    p = ParsePrefixString(p, qft);

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
	{
		TrERROR(GENERAL, "Excpecting equal sign after format name prefix in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = skip_ws(p);

    GUID guid;

    switch(qft)
    {
        //
        //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PUBLIC:
            p = FnParseGuidString(p, &guid);
            pqf->PublicID(guid);
            break;

        //
        //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PRIVATE:
            p = FnParseGuidString(p, &guid);
            p = skip_ws(p);

            if(*p++ != FN_PRIVATE_SEPERATOR_C)
			{
				TrERROR(GENERAL, "Excpecting private seperator in '%ls'.", p);
				throw bad_format_name(p);
			}

            p = skip_ws(p);

            ULONG uniquifier;
            p = ParsePrivateIDString(p, &uniquifier);

            pqf->PrivateID(guid, uniquifier);
            break;

        //
        //  "DIRECT=OS:bla-bla\0"
        //
        case QUEUE_FORMAT_TYPE_DIRECT:
		{
            LPCWSTR pExpandedDirectFormat;
            QUEUE_PATH_TYPE qpt = ILLEGAL_QUEUE_PATH_TYPE;
            p = ParseDirectString(p, &pExpandedDirectFormat, ppStringToFree, &qpt);

            if (qpt == SYSTEM_QUEUE_PATH_TYPE)
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat), QUEUE_FORMAT_FLAG_SYSTEM);
            }
            else
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat));
            }
            break;
		}

        //
        // MULTICAST=aaa.bbb.ccc.ddd
        //
        case QUEUE_FORMAT_TYPE_MULTICAST:
			{
				MULTICAST_ID MulticastID;
				p = FnParseMulticastString(p, &MulticastID);
				pqf->MulticastID(MulticastID);
				break;
			}

        //
        //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_MACHINE:
            p = FnParseGuidString(p, &guid);

            pqf->MachineID(guid);
            break;

        //
        //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_CONNECTOR:
            p = FnParseGuidString(p, &guid);

            pqf->ConnectorID(guid);
            break;

        case QUEUE_FORMAT_TYPE_DL:
            {
                DL_ID dlid;
                dlid.m_pwzDomain = 0;

                p = ParseDlString(
                    p,
                    &dlid.m_DlGuid,
                    &dlid.m_pwzDomain,
                    ppStringToFree
                    );

                pqf->DlID(dlid);
            }

            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    //  We're at end of string, return now.
    //  N.B. Machine format name *must* have a suffix
    //
    if(*p == L'\0' || *p == FN_MQF_SEPARATOR_C)
    {
        if (qft == QUEUE_FORMAT_TYPE_MACHINE)
		{
			TrERROR(GENERAL, "Found Machine format without a suffix '%ls'.", p);
			throw bad_format_name(p);
		}
        return p;
    }

    if(*p != FN_SUFFIX_DELIMITER_C)
	{
		TrERROR(GENERAL, "Expecting suffix delimiter in '%ls'.", p);
		throw bad_format_name(p);
	}

    QUEUE_SUFFIX_TYPE qst;
	LPCWSTR Suffix = p;

    p = ParseSuffixString(p, qst);

    p = skip_ws(p);

    //
    //  Only white space padding is allowed.
    //
    if(*p != L'\0' && *p != FN_MQF_SEPARATOR_C)
	{
		TrERROR(GENERAL, "Unexpected characters at end of format name '%ls'.", p);
		throw bad_format_name(p);
	}

    pqf->Suffix(qst);

    if (!pqf->Legal())
	{
		TrERROR(GENERAL, "Ilegal suffix in format name %ls", Suffix);
		throw bad_format_name(p);
	}
    return p;
}





//---------------------------------------------------------
//
//  Function:
//      FnFormatNameToQueueFormat
//
//  Description:
//      Convert a format name string to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
BOOL
FnFormatNameToQueueFormat(
    LPCWSTR pfn,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
	ASSERT(ppStringToFree != NULL);

	try
	{
		AP<WCHAR> StringToFree;

		LPCWSTR p = ParseOneFormatName(pfn, pqf, &StringToFree);

		if (*p != L'\0')
		{
			TrERROR(GENERAL, "Expected end of format name in '%ls'.", p);
			throw bad_format_name(p);
		}

		if(ppStringToFree != NULL)
		{
			*ppStringToFree = StringToFree.detach();
		}

		return TRUE;
	}
	catch(const bad_format_name&)
	{
		return FALSE;
	}
}

//---------------------------------------------------------
//
//  Function:
//      FnMqfToQueueFormats
//
//  Description:
//      Convert a format name string to an array of QUEUE_FORMAT unions (supports MQF).
//
//---------------------------------------------------------
BOOL
FnMqfToQueueFormats(
    LPCWSTR pfn,            // pointer to format name string
    AP<QUEUE_FORMAT> &pmqf,    // returned pointer to allocated QUEUE_FORMAT pointers array
    DWORD   *pnQueues,      // Number of queues in MQF format
    CStringsToFree &strsToFree // Holding buffers of strings to be free
    )
{
	ASSERT(("Null out pointer supplied to function.", (pnQueues != NULL)));
	//
	// Out argument is already in use.
	//
	if(pmqf.get() != NULL)
	{
        return FALSE;
	}

	
    *pnQueues = 0;

    AP<QUEUE_FORMAT> QueuesArray;
    DWORD nQueues = 0;
    DWORD nQueueFormatAllocated = 0;

    LPCWSTR p;
    for (p=pfn;; p++)
    {
        QUEUE_FORMAT qf;
        AP<WCHAR> StringToFree;

        try
		{
			p = ParseOneFormatName(p, &qf, &StringToFree);
		}
		catch(const bad_format_name&)
		{
			return FALSE;
		}

        strsToFree.Add(StringToFree.detach());

        if (nQueueFormatAllocated <= nQueues)
        {
            DWORD nOldAllocated = nQueueFormatAllocated;
            nQueueFormatAllocated = nQueueFormatAllocated*2 + 1;
            QUEUE_FORMAT* tempQueuesArray = new QUEUE_FORMAT[nQueueFormatAllocated];
            memcpy(tempQueuesArray, QueuesArray, nOldAllocated*sizeof(QUEUE_FORMAT));
            delete [] QueuesArray.detach();

            QueuesArray = tempQueuesArray;
        }

        QueuesArray[nQueues] = qf;
        nQueues++;

        if (*p == L'\0')
        {
            break;
        }

        ASSERT(*p == FN_MQF_SEPARATOR_C);
    }

    pmqf = QueuesArray.detach();
    *pnQueues = nQueues;

    return TRUE;
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathType
//
//  Description:
//      Validate, Expand and return type for Path Name.
//
//---------------------------------------------------------
QUEUE_PATH_TYPE
FnValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    )
{
    ASSERT(ppStringToFree != 0);

    LPCWSTR pwcsPathNameNoSpaces = pwcsPathName;
    AP<WCHAR> pStringToFree;
    *ppStringToFree = 0;

    //
    // Remove leading white spaces
    //
    while (*pwcsPathNameNoSpaces != 0 && iswspace(*pwcsPathNameNoSpaces))
    {
        pwcsPathNameNoSpaces++;
    }

    //
    // Remove trailing white spaces
    //
    DWORD dwLen = wcslen(pwcsPathNameNoSpaces);
	if(dwLen == 0)
		return ILLEGAL_QUEUE_PATH_TYPE;

    if (iswspace(pwcsPathNameNoSpaces[dwLen-1]))
    {
        pStringToFree = newwcs(pwcsPathNameNoSpaces);
        for (DWORD i = dwLen; i-- > 0; )
        {
            if (iswspace(pStringToFree[i]))
            {
                pStringToFree[i] = 0;
            }
            else
            {
                break;
            }
        }
        pwcsPathNameNoSpaces = pStringToFree;
    }

    LPCWSTR p = pwcsPathNameNoSpaces;
	QUEUE_PATH_TYPE qpt;


	try
	{
	    p = ParseMachineNameString(p);
		p = ParseQueueNameString(p, &qpt);
		//
	    //  No characters are allowed at end of queue name.
	    //
	    if(*p != L'\0')
	        return ILLEGAL_QUEUE_PATH_TYPE;

	    *ppwcsExpandedPathName = ExpandPathName(pwcsPathNameNoSpaces, 0, ppStringToFree);
	}
	catch(const bad_format_name&)
	{
		return ILLEGAL_QUEUE_PATH_TYPE;
	}



    //
    // if ExpandPathName does not return a string to free, we will
    // give the caller the string we allocated, so the caller will free it.
    // Otherwise, we will do nothing and "our" string will be auto-release.
    //
    if (*ppStringToFree == 0)
    {
        *ppStringToFree = pStringToFree.detach();
    }

    return (qpt);
}


//+-------------------------------------------
//
//  CStringsToFree implementation
//
//+-------------------------------------------
CStringsToFree::CStringsToFree() :
    m_nStringsToFree(0),
    m_nStringsToFreeAllocated(0)
    {}

void
CStringsToFree::Add(
    LPWSTR pStringToFree
    )
{
    if(pStringToFree == 0)
        return;

    if (m_nStringsToFree >= m_nStringsToFreeAllocated)
    {
        m_nStringsToFreeAllocated = m_nStringsToFreeAllocated*2 + 1;
        AP<WCHAR>* tempPstringsBuffer = new AP<WCHAR>[m_nStringsToFreeAllocated];
        for (size_t i=0; i<m_nStringsToFree; i++)
        {
            tempPstringsBuffer[i] = m_pStringsBuffer[i].detach();
        }

        delete [] m_pStringsBuffer.detach();

        m_pStringsBuffer = tempPstringsBuffer;
    }
    m_pStringsBuffer[m_nStringsToFree] = pStringToFree;
    m_nStringsToFree++;
}


//---------------------------------------------------------
//
//  Function:
//      RTpIsHttp
//
//  Description:
//      Decide if this is an http format
//		check for "DIRECT=http://" or "DIRECT=https://"
//		case insensitive of "DIRECT", "http" or "https" and white space insensitive
//
//---------------------------------------------------------
bool
FnIsHttpFormatName(
    LPCWSTR p            // pointer to format name string
    )
{
    QUEUE_FORMAT_TYPE qft;

	try
	{
		p = ParsePrefixString(p, qft);
	}
	catch(const bad_format_name&)
	{
		return false;
	}	

	//
	// DIRECT
	//
	if(qft != QUEUE_FORMAT_TYPE_DIRECT)
		return(false);

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
        return(false);

    p = skip_ws(p);

	//
	// http
	//
	bool fIsHttp = (_wcsnicmp(
						p,
						FN_DIRECT_HTTP_TOKEN,
						FN_DIRECT_HTTP_TOKEN_LEN
						) == 0);

	if(fIsHttp)
		return(true);

	//
	// https
	//
	bool fIsHttps = (_wcsnicmp(
						p,
						FN_DIRECT_HTTPS_TOKEN,
						FN_DIRECT_HTTPS_TOKEN_LEN
						) == 0);


	return(fIsHttps);
}

VOID
FnExtractMachineNameFromPathName(
	LPCWSTR PathName,
	AP<WCHAR>& MachineName
	)
/*++

  Routine Description:
	The routine extracts the machine name from the Path-Name

  Arguments:
	- Path name that should be extracted
	- Buffer to copy the machine name

  Arguments:
	None.

  NOTE:
	It is the user responsiblity to supply buffer big enough
 --*/
{
    LPWSTR FirstDelimiter = wcschr(PathName, FN_DELIMITER_C);

	if(FirstDelimiter == NULL)
	{
		TrERROR(GENERAL, "Pathname without delimiter '%ls'", PathName);
		throw bad_format_name(PathName);
	}
		
	size_t Length = FirstDelimiter - PathName;

	MachineName = new WCHAR[Length + 1];

    wcsncpy(MachineName.get(), PathName, Length);
    MachineName.get()[Length] = L'\0';
}

VOID
FnExtractMachineNameFromDirectPath(
	LPCWSTR PathName,
	AP<WCHAR>& MachineName
	)
{
    LPWSTR FirstDelimiter = wcspbrk(PathName, FN_HTTP_SEPERATORS FN_HTTP_PORT_SEPERATOR);
	
	size_t Length;
	if(FirstDelimiter == NULL)
	{
		Length = wcslen(PathName);
	}
	else
	{
		Length = FirstDelimiter - PathName;
	}

	MachineName = new WCHAR[Length + 1];

    wcsncpy(MachineName.get(), PathName, Length);
    MachineName.get()[Length] = L'\0';
}

//---------------------------------------------------------
//
//  Parse direct token type infix string.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR
FnParseDirectQueueType(
	LPCWSTR p,
	DirectQueueType* dqt
	)
{
	ASSERT(("Bad parameters", p != NULL && dqt != NULL));

    const int unique = 0;
    //-----------------------v-------------------
    ASSERT(L'O' == FN_DIRECT_OS_TOKEN   [unique]);
    ASSERT(L'T' == FN_DIRECT_TCP_TOKEN  [unique]);
    ASSERT(L'H' == FN_DIRECT_HTTP_TOKEN [unique]);
    ASSERT(L'H' == FN_DIRECT_HTTPS_TOKEN[unique]);
    //-----------------------^-------------------

    //
    //  accelarate token recognition by checking 1st character
    //
    switch(towupper(p[unique]))
    {
        // Os:
        case L'O':
            if(_wcsnicmp(p, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN) == 0)
			{
				*dqt = dtOS;
                return p + FN_DIRECT_OS_TOKEN_LEN;
			}
            break;

        // Tcp:
        case L'T':
            if(_wcsnicmp(p, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN) == 0)
			{
				*dqt = dtTCP;
                return p + FN_DIRECT_TCP_TOKEN_LEN;
			}
            break;

        // http:// or https://
        case L'H':
			if (!_wcsnicmp(p, FN_DIRECT_HTTPS_TOKEN, FN_DIRECT_HTTPS_TOKEN_LEN))
			{
				*dqt = dtHTTPS;
				return p + FN_DIRECT_HTTPS_TOKEN_LEN;
			}
			if (!_wcsnicmp(p, FN_DIRECT_HTTP_TOKEN, FN_DIRECT_HTTP_TOKEN_LEN))
			{
				*dqt = dtHTTP;
				return p + FN_DIRECT_HTTP_TOKEN_LEN;
			}
			break;

		default:
			break;
    }

	TrERROR(GENERAL, "Failed parsing direct token string in '%ls'.", p);
    throw bad_format_name(p);
}


static
BOOL
IsSeperator(
	WCHAR c
	)
{
	return (c == FN_DELIMITER_C || c == L'/');
}


VOID
FnDirectIDToLocalPathName(
	LPCWSTR DirectID,
	LPCWSTR LocalMachineName,
	AP<WCHAR>& PathName
	)
{
    DirectQueueType QueueType;
	LPCWSTR p = FnParseDirectQueueType(DirectID, &QueueType);

    if(QueueType == dtHTTP || QueueType == dtHTTPS)
    {
		p = wcspbrk(p, FN_HTTP_SEPERATORS);
		if(p == NULL)
		{
			TrERROR(GENERAL, "Failed to find url delimiter in '%ls'.", DirectID);
			throw bad_format_name(DirectID);
		}

		p++;
        //
        // skip '\msmq' prefix to queue name in http format name
        //
        if(_wcsnicmp(p, FN_MSMQ_HTTP_NAMESPACE_TOKEN, FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN) != 0
			|| !IsSeperator(p[FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN]))
		{
			TrERROR(GENERAL, "Missing '\\MSMQ\\' namespace token '%ls'.", DirectID);
			throw bad_format_name(DirectID);
		}

		//
		// This section converts the possilble slashes in ".../[private$/]..." that are legal
		// in http format name to "...\[private$\]..."
		//

		p += FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN + 1;

		size_t LocalMachineNameLen = wcslen(LocalMachineName);
		size_t Length = LocalMachineNameLen + 1 + wcslen(p);

		PathName = new WCHAR[Length + 1];

		wcscpy(PathName.get(), LocalMachineName);
		wcscat(PathName.get(), L"\\");
		wcscat(PathName.get(), p);

		const WCHAR PrivateKeyword[] = L"PRIVATE$/";
		ASSERT(STRLEN(PrivateKeyword) == FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

        if(_wcsnicmp(PathName.get() + LocalMachineNameLen + 1, PrivateKeyword, STRLEN(PrivateKeyword)) == 0)
		{
			wcsncpy(PathName.get() + LocalMachineNameLen + 1, FN_PRIVATE_QUEUE_PATH_INDICATIOR, FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);
		}

		CharLower(PathName.get());

		return;
    }

	p = wcschr(p, FN_DELIMITER_C);
	if(p == NULL)
	{
		TrERROR(GENERAL, "Failed to find path delimiter in '%ls'.", DirectID);
		throw bad_format_name(DirectID);
	}

	size_t Length = wcslen(LocalMachineName) + wcslen(p);

	PathName = new WCHAR[Length + 1];

	wcscpy(PathName.get(), LocalMachineName);
	wcscat(PathName.get(), p);

	CharLower(PathName.get());
}

bool
FnIsPrivatePathName(
	LPCWSTR PathName
	)
{
	LPCWSTR p = wcschr(PathName, FN_DELIMITER_C);

	ASSERT(("Pathname without '\\' delimiter.", p != NULL));
	if(p == NULL)
	{
		TrERROR(GENERAL, "Pathname is illegal. The '\\' delimiter was not found in '%ls'", PathName);
		throw bad_format_name(L"");
	}

    return _wcsnicmp(
				p + 1,
                FN_PRIVATE_QUEUE_PATH_INDICATIOR,
                FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH
				) == 0;
}

bool
FnIsHttpDirectID(
	LPCWSTR p
	)
{
	try
	{
		DirectQueueType QueueType;
		FnParseDirectQueueType(p, &QueueType);

		return (QueueType == dtHTTP || QueueType == dtHTTPS);
	}
	catch(const exception&)
	{
		return false;
	}
}

static
bool
FnpIsHttpsUrl(LPCWSTR url)
{
	return (_wcsnicmp(url, FN_DIRECT_HTTPS_TOKEN, STRLEN(FN_DIRECT_HTTPS_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpsUrl(
	const xwcs_t& url
	)
{
	if(url.Length() <  STRLEN(FN_DIRECT_HTTPS_TOKEN))
		return false;

	return (_wcsnicmp(url.Buffer(), FN_DIRECT_HTTPS_TOKEN, STRLEN(FN_DIRECT_HTTPS_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpUrl(
	LPCWSTR url
	)
{
	return (_wcsnicmp(url, FN_DIRECT_HTTP_TOKEN, STRLEN(FN_DIRECT_HTTP_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpUrl(
	const xwcs_t& url
	)
{
	if(url.Length() <  STRLEN(FN_DIRECT_HTTP_TOKEN))
		return false;

	return (_wcsnicmp(url.Buffer(), FN_DIRECT_HTTP_TOKEN, STRLEN(FN_DIRECT_HTTP_TOKEN) ) == 0);		
}


//
// Is given url string is http or https url (starts with http:// or https://)
//
bool FnIsHttpHttpsUrl(
				LPCWSTR url
				)
{
	return FnpIsHttpUrl(url) || FnpIsHttpsUrl(url);	
}

//
// Is given url string buffer is http or https url (starts with "http://" or "https://")
//
bool
FnIsHttpHttpsUrl
		(
	const xwcs_t& url
	)
{	
	return FnpIsHttpUrl(url) || FnpIsHttpsUrl(url);
}


//
// Is given url string is MSMQ url (starts with "MSMQ:")
//
bool
FnIsMSMQUrl
		(
	LPCWSTR url
	)
{
	return (_wcsnicmp(url, FN_MSMQ_URI_PREFIX_TOKEN, FN_MSMQ_URI_PREFIX_TOKEN_LEN)) == 0;
}

//
// Is given url string buffer is MSMQ url (starts with "MSMQ:")
//
bool
FnIsMSMQUrl
		(
	const xwcs_t& url
	)
{
	if(url.Length() <  FN_MSMQ_URI_PREFIX_TOKEN_LEN )
		return false;

	return _wcsnicmp(url.Buffer(), FN_MSMQ_URI_PREFIX_TOKEN, FN_MSMQ_URI_PREFIX_TOKEN_LEN ) == 0;
}


bool FnIsDirectHttpFormatName(const QUEUE_FORMAT* pQueueFormat)
/*++

Routine Description:
		check if given format name is direct http or direct https
	
Arguments:
    IN - pQueueFormat - format name to test

Return - true if the given format namr is http or https - false otherwise.
*/
{
	if(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return false;	
	}
 	return FnIsHttpDirectID(pQueueFormat->DirectID());
}



LPCWSTR
FnFindResourcePath(
	LPCWSTR url
	)
/*++

Routine Description:
		Find  resource path in uri.
	
Arguments:
    IN - uri (absolute or relative)

Return - pointer to local resource path.
for example :
url = "http://host/msmq\q" - the function returns pointer to "host/msmq\"
url = /msmq\q - the function returns pointer to "/msmq\q".

*/
{	LPCWSTR ptr = url;
	if(FnpIsHttpUrl(ptr))
	{
		ptr += FN_DIRECT_HTTP_TOKEN_LEN;
	}
	else
	if(FnpIsHttpsUrl(ptr))
	{
		ptr += FN_DIRECT_HTTPS_TOKEN_LEN;
	}
	
	return ptr;
}


void
FnReplaceBackSlashWithSlash(
	LPWSTR url
	)throw()
{
	while(*url != L'\0')
	{
		if(*url == FN_PRIVATE_SEPERATOR_C)
		{
			*url = FN_HTTP_SEPERATOR_C; 						
		}
		++url;
	}
}


bool
FnAbsoluteMsmqUrlCanonization(
	LPCWSTR url
	)throw()
/*++

Routine Description:
		Convert all '\' sperator in given msmq url to '/'
	
Arguments:
    IN - url - Absolute msmq url (http://host\msmq\private$\q )

    Example :
	http://host\msmq\private$\q  -> http://host/msmq/private$/q

Return value - true if the url transfered to canonical form - false if bad MSMQ url format.

*/
{
	LPCWSTR ptr = url;

	if(FnpIsHttpUrl(ptr))
	{
		ptr += FN_DIRECT_HTTP_TOKEN_LEN;
	}
	else
	if(FnpIsHttpsUrl(ptr))
	{
		ptr += FN_DIRECT_HTTPS_TOKEN_LEN;
	}

	//
	// if not http pr https - bad format
	//
	if(ptr ==  url)
		return false;
	
	return true;
}


bool
FnIsValidQueueFormat(
	const QUEUE_FORMAT* pQueueFormat
	)
{
    ASSERT(FnpIsInitialized());

	if (!pQueueFormat->IsValid())
	{
		return false;
	}

	//
	// For non-direct format names no parsing is needed
	//
	if (pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return true;
	}

	//
	// Validate direct format name
	//
	try
	{
		AP<WCHAR> pStringToFree;
		LPCWSTR pExpandedDirectFormat;
		QUEUE_PATH_TYPE qpt = ILLEGAL_QUEUE_PATH_TYPE;

		ParseDirectString(pQueueFormat->DirectID(), &pExpandedDirectFormat, &pStringToFree, &qpt);
	}
	catch(const exception&)
	{
		return false;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\lib\mqfexpander.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    DLExpander.cpp

Abstract:
    FnExpandMqf() - does a DFS on an array of QUEUE_FORMATS.
	It "flattens" the graph created by possible DL queue formats, 
	to a linear array of QUEUE_FORMATS which contains no duplicates 
	and no DLs.

NOTES:
	Functions interact directly with the Active directory,
	through the use of the following interfaces and functions:
	IADs, IADsGroup, GetADsObject().

	Binding is done through the Serverless notation mechanism,
	e.g. "LDAP://<GUID=00112233445566778899aabbccddeeff>
	instead of "LDAP://server-name/<GUID=00112233445566778899aabbccddeeff>

	NOTE: Active Directory does not seperate a GUID string with hyphens ('-')
	as is done in MSMQ!

Author:
    Nir Aides (niraides) 23-May-2000

--*/

#pragma warning( disable : 4786 )

#include <libpch.h>
#include <activeds.h>
#include <Oleauto.h>
#include "mqwin64a.h"
#include <qformat.h>
#include <fntoken.h>
#include <bufutl.h>
#include "Fn.h"
#include "fnp.h"
#include "FnGeneral.h"
#include <strsafe.h>
#include <adsiutl.h>

#include "mqfexpander.tmh"


using namespace std;



typedef set<QUEUE_FORMAT, CFunc_CompareQueueFormat> QueueFormatSet;



static
VOID 
FnpExpandDL(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	);



static GUID FnpString2Guid(BSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = _snwscanf(
						GuidStr,
						SysStringLen(GuidStr),
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);    
    DBG_USED(nFields);
    ASSERT(("Bad Guid string format, in FnpString2Guid()", nFields == 16));
    
	for(size_t i = 0; i < 16; i++)
	{
		((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
	}

	return Guid;
}



static R<IADsGroup> FnpGetDLInterface(IADs* pADObject)
{
	IADsGroup* pGroup;

	HRESULT hr = pADObject->QueryInterface(IID_IADsGroup, (void**)&pGroup);
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed IADs->QueryInterface, status 0x%x. Verify the object is an AD Group.", hr);
        throw bad_ds_result(hr);
	}

	return pGroup;
}


			
static R<IADs> FnpGCBindGuid(const GUID* pGuid)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		GLOBAL_CATALOG_PREFIX L"<GUID=" LDAP_GUID_FORMAT L">",
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}

			
static R<IADs> FnpServerlessBindGuid(const GUID* pGuid)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		LDAP_PREFIX L"<GUID=" LDAP_GUID_FORMAT L">",
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);


    if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}

			
static R<IADs> FnpDomainBindGuid(const GUID* pGuid, LPCWSTR pDomainName)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		LDAP_PREFIX L"%ls/<GUID=" LDAP_GUID_FORMAT L">",
		pDomainName,
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);


    if(FAILED(hr))
	{
        TrTRACE(GENERAL, "Failed ADsOpenObject with specified domain '%ls', status 0x%x. Will try Serverless binding", pDomainName, hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}


static R<IADs> FnpBindGuid(const GUID* pGuid, LPCWSTR* pDomainName)
{
	ASSERT(pDomainName != NULL);

	try
	{
		if(*pDomainName != NULL)
			return FnpDomainBindGuid(pGuid, *pDomainName);
	}
	catch(const exception&)
	{
		//
		// Failed to bind with domain name. Reset this domain name string.
		//
		*pDomainName = NULL;
	}

	try
	{
		return FnpServerlessBindGuid(pGuid);
	}
	catch(const exception&)
	{
		//
		// Failed to bind in the directory service. 
		// Try binding through the global catalog.
		//

		return FnpGCBindGuid(pGuid);
	}
}


VOID 
HandleQueueFormat(
	const QUEUE_FORMAT& QueueFormat,
	set<wstring>& DLSet,			 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet		//Set of encountered QUEUE_FORMATs
	)
{
	if(QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DL)
	{
		GUID DLGuid = QueueFormat.DlID().m_DlGuid;
		LPCWSTR DomainName = QueueFormat.DlID().m_pwzDomain;

		R<IADs> pADObject = FnpBindGuid(&DLGuid, &DomainName);
		R<IADsGroup> pGroup = FnpGetDLInterface(pADObject.get());

		FnpExpandDL(pGroup.get(), DLSet, LeafMQFSet, DomainName);

		return;
	}

	if(LeafMQFSet.find(QueueFormat) == LeafMQFSet.end())
	{
		QUEUE_FORMAT QueueFormatCopy;

		FnpCopyQueueFormat(QueueFormatCopy, QueueFormat);
		LeafMQFSet.insert(QueueFormatCopy);

		TrTRACE(GENERAL, "Object inserted to set. INSERTED");

		return;
	}

	TrTRACE(GENERAL, "duplicate object discarded. DUPLICATE");
}



static 
VOID
HandleQueueAlias(
	IADs* QueueAlias,			  //Queue alias interface 
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet	//Set of encountered QUEUE_FORMATs
	)
{
	VARIANTWrapper var;
	
	HRESULT hr;
	hr = QueueAlias->Get(L"msMQ-Recipient-FormatName", &var);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Can't retrieve format name of queue alias. Status = %d", hr);
		throw bad_ds_result(hr);
	}

	TrTRACE(GENERAL, "Queue alias format name is %ls", var.Ref().bstrVal);

	AP<WCHAR> StringToFree;
	QUEUE_FORMAT QueueFormat;

	BOOL Result = FnFormatNameToQueueFormat(
					var.Ref().bstrVal,
					&QueueFormat,
					&StringToFree
					);

	if(!Result)
	{
		TrERROR(GENERAL, "Bad format name in queue alias. %ls", StringToFree.get());
		throw bad_format_name(L"");
	}

	HandleQueueFormat(
		QueueFormat,
		DLSet,
		LeafMQFSet
		);
}



static 
VOID
FnpProcessADs(
	IADs* pADObject,			  //Group interface (the DL object)
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	)
/*++
Routine Description:
	Process Active Directory object.
	If it is a Group object, Recurse into it.
	If it is a queue, generate a public QUEUE_FORMAT, and try to insert it  
	to 'LeafMQFSet'.
	If it is neither, ignore it and return. 

Arguments:

Returned Value:
	throws exception objects on any failure
--*/
{
	BSTRWrapper ClassStr;

	HRESULT hr;
	hr = pADObject->get_Class(&ClassStr);
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed pADObject->get_Class, status 0x%x", hr);
        throw bad_ds_result(hr);
	}	

	TrTRACE(GENERAL, "Object Class Name is '%ls'", *&ClassStr);
	
	//
	// "switch" on the object type
	//
	if(_wcsicmp(ClassStr, xClassSchemaGroup) == 0)
	{
		R<IADsGroup> pGroup = FnpGetDLInterface(pADObject);

		FnpExpandDL(pGroup.get(), DLSet, LeafMQFSet, DomainName);
		return;
	}
	else if(_wcsicmp(ClassStr, xClassSchemaQueue) == 0)
	{
		BSTRWrapper GuidStr;

		HRESULT hr;
		hr = pADObject->get_GUID(&GuidStr);
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed pADObject->get_GUID, status 0x%x", hr);
			throw bad_ds_result(hr);
		}		

		GUID Guid = FnpString2Guid(GuidStr);
		QUEUE_FORMAT QueueFormat(Guid);

		bool fInserted = LeafMQFSet.insert(QueueFormat).second;

		TrTRACE(GENERAL, "Object is Queue Guid=%ls, %s", GuidStr, (fInserted ? "INSERTED" : "DUPLICATE"));

		return;
	}
	else if(_wcsicmp(ClassStr, xClassSchemaAlias) == 0)
	{
		HandleQueueAlias(
			pADObject,
			DLSet,
			LeafMQFSet
			);

		return;
	}

	TrWARNING(GENERAL, "Unsupported object '%ls' IGNORED", ClassStr);
}



static 
BOOL 
FnpInsert2DLSet(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet			 //Set of processed DL objects
	)
{
	BSTRWrapper GuidStr;

	HRESULT hr = pGroup->get_GUID(&GuidStr);
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed pGroup->get_GUID, status 0x%x", hr);
        throw bad_ds_result(hr);
	}

	BOOL fInserted = DLSet.insert(wstring(GuidStr)).second;

	return fInserted;
}



static R<IADs> FnpServerlessBindDN(BSTR DistinugishedName)
{
	WCHAR ADsPath[MAX_PATH];

	HRESULT hr = StringCchPrintf(
								ADsPath,
								MAX_PATH,
								LDAP_PREFIX L"%ls",
								DistinugishedName
								);
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "ADs path exceeds MAX_PATH characters, '%ls', %!hresult!", ADsPath, hr);
		throw bad_hresult(hr);
	}

	//
	// Attempt bind
	// 

	IADs* pADObject;
	AP<WCHAR> pEscapeAdsPathNameToFree;

	hr = ADsOpenObject( 
					UtlEscapeAdsPathName(ADsPath, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr)) 
	{
        TrERROR(GENERAL, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}



static R<IADs> FnpBindDN(BSTR DistinugishedName, LPCWSTR* pDomainName)
{
	ASSERT(pDomainName != NULL);

	if(*pDomainName == NULL)
		return FnpServerlessBindDN(DistinugishedName);

	WCHAR ADsPath[MAX_PATH];

	HRESULT hr = StringCchPrintf(
								ADsPath,
								MAX_PATH,
								LDAP_PREFIX L"%ls/%ls",
								*pDomainName,
								DistinugishedName
								);
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "ADs path exceeds MAX_PATH characters, %ls, %!hresult!", ADsPath, hr);
		throw bad_hresult(hr);
	}

	//
	// Attempt bind
	// 

	IADs* pADObject;
	AP<WCHAR> pEscapeAdsPathNameToFree;

	hr = ADsOpenObject( 
					UtlEscapeAdsPathName(ADsPath, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr)) 
	{
        TrTRACE(GENERAL, "Failed ADsOpenObject with specified domain '%ls', status 0x%x. Will try Serverless binding", *pDomainName, hr);
		*pDomainName = NULL;
		return FnpServerlessBindDN(DistinugishedName);
	}

	return pADObject;
}



//
// AttrInfoWrapper is used to enable automatic release of ADS_ATTR_INFO structures.
//

class AttrInfoWrapper {
private:
    PADS_ATTR_INFO m_p;

public:
    AttrInfoWrapper(PADS_ATTR_INFO p = NULL) : m_p(p) {}
   ~AttrInfoWrapper()					{ if(m_p != NULL) FreeADsMem(m_p); }

    operator PADS_ATTR_INFO() const     { return m_p; }
    PADS_ATTR_INFO operator ->() const	{ return m_p; }
    PADS_ATTR_INFO* operator&()         { return &m_p;}
    PADS_ATTR_INFO detach()             { PADS_ATTR_INFO p = m_p; m_p = NULL; return p; }

private:
    AttrInfoWrapper(const AttrInfoWrapper&);
    AttrInfoWrapper& operator=(const AttrInfoWrapper&);
};



VOID 
FnpExpandDL(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	)
{
	//
	// if DL allready encountered return without further processing.
	//
	if(!FnpInsert2DLSet(pGroup, DLSet))
	{
		TrTRACE(GENERAL, "DL allready processed. IGNORED");
		return;
	}

	//
	// ------------------- Enumerate DL members ---------------------
	//

	R<IDirectoryObject> DirectoryObject;

	HRESULT hr = pGroup->QueryInterface(IID_IDirectoryObject, (void**)&DirectoryObject.ref());
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed pGroup->QueryInterface(), status 0x%x", hr);
        throw bad_ds_result(hr);
	}

	//
	// iterate 100 group members at a time.
	//
	const DWORD MembersBlockSize = 100;
	DWORD index = 0;

	while(true)
	{
		WCHAR	pwszRangeAttrib[256];                           
		LPWSTR	pAttrNames[] = {pwszRangeAttrib};                 
		DWORD	dwNumAttr = TABLE_SIZE(pAttrNames);   
		
		AttrInfoWrapper	pAttrInfo;                                
		DWORD			dwReturn;  

		HRESULT hr = StringCchPrintf(
									pwszRangeAttrib, 
									TABLE_SIZE(pwszRangeAttrib), 
									L"member;Range=%d-%d", 
									index, 
									index + MembersBlockSize - 1
									);
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to construct a string, '%ls', %!hresult!", pwszRangeAttrib, hr);
			throw bad_hresult(hr);
		}
 
		hr = DirectoryObject->GetObjectAttributes(
								pAttrNames, 
								dwNumAttr, 
								&pAttrInfo, 
								&dwReturn
								);

		//
		// Iterated all members
		//
		if(hr == S_ADS_NOMORE_ROWS)
			break;
		
		if(hr != S_OK)
		{
			TrERROR(GENERAL, "Failed DirectoryObject->GetObjectAttributes(), status 0x%x", hr);
			throw bad_ds_result(hr);
		}

		//
		// DL with no members.
		//
		if(dwReturn == 0)
			break;

		//
		// Asked for only one attribute.
		// 
		ASSERT(dwReturn == 1);

		//
		// member attribute returned should be of this type. It may be ADSTYPE_PROV_SPECIFIC if schema is not available.
		//
		ASSERT(pAttrInfo->dwADsType == ADSTYPE_DN_STRING);

		if(pAttrInfo->dwADsType != ADSTYPE_DN_STRING)
		{
			TrERROR(GENERAL, "Failed DirectoryObject->GetObjectAttributes(), member attribute returned is not of type ADSTYPE_DN_STRING. Probably schema access problems.");
			throw bad_ds_result(ERROR_DS_OPERATIONS_ERROR);
		}

		//
		// Iterate the multivalue attribute "member"
		//			
		for (DWORD dwVal = 0; dwVal < pAttrInfo->dwNumValues; dwVal++)
		{
			LPWSTR DistinguishedName = (pAttrInfo->pADsValues+dwVal)->CaseIgnoreString;
			R<IADs> pADObject = FnpBindDN(DistinguishedName, &DomainName);
			
			FnpProcessADs(pADObject.get(), DLSet, LeafMQFSet, DomainName);
		}

		//
		// Finished iterating all members. 
		// If the last character in pAttrInfo->pszAttrName is L'*' then there are no more members.
		//
		if(pAttrInfo->pszAttrName[wcslen(pAttrInfo->pszAttrName) - 1] == L'*')
			break;

		index += MembersBlockSize;
	}
	
	TrTRACE(GENERAL, "End of DL Iteration.");
}



VOID 
FnExpandMqf(
	ULONG nTopLevelMqf, 
	const QUEUE_FORMAT TopLevelMqf[], 
	ULONG* pnLeafMqf,
	QUEUE_FORMAT** ppLeafMqf
	)
/*++
Routine Description:
	Does a DFS on an array of QUEUE_FORMATS.
	It "flattens" the graph created by possible DL queue formats, 
	to a linear array of QUEUE_FORMATS which contains no duplicates 
	and no DLs.

Arguments:
	[in] TopLevelMqf - array of QUEUE_FORMAT (with possible DL queue formats)
	[out] ppLeafMqf - the "expanded" array of QUEUE_FORMAT. contains no DL 
		queue formats, and no duplicates.
	[out] pnLeafMqf - size of 'ppLeafMqf' array

Returned Value:
	throws exception objects on any failure

	IMPORTANT: Any strings pointed by queue formats in array ppLeafMqf[] are 
	newly allocated copies of strings in array TopLevelMqf[].

--*/
{
	//
	// Set of processed DL objects. all encountered Active Directory DL objects
	// are inserted. it is used to avoid circles in the DFS
	//
	set<wstring> DLSet;

	//
	// Set of encountered QUEUE_FORMATs. all encountered Queues are inserted.
	// It is used to avoid duplicate queues.
	//
	QueueFormatSet LeafMQFSet;

	try
	{
		for(DWORD i = 0; i < nTopLevelMqf; i++)
		{
			HandleQueueFormat(TopLevelMqf[i], DLSet, LeafMQFSet);
		}

		if(LeafMQFSet.size() == 0)
		{
			//
			// MQF can be expanded to an empty list if it contains references 
			// to empty DL objects.
			//
			*ppLeafMqf = NULL;
			*pnLeafMqf = 0;

			return;
		}

		//
		// BUGBUG: Scale: We may optimize here to allocate as minimum as possible
		// (i.e. only for DL= format name). (ShaiK, 30-May-2000).
		//
		AP<QUEUE_FORMAT> LeafMqf = new QUEUE_FORMAT[LeafMQFSet.size()];

		QueueFormatSet::const_iterator Itr = LeafMQFSet.begin();
		QueueFormatSet::const_iterator ItrEnd = LeafMQFSet.end();

		for(int j = 0; Itr != ItrEnd; j++, Itr++)
		{
			LeafMqf[j] = *Itr;
		}

		*ppLeafMqf = LeafMqf.detach();
		*pnLeafMqf = UINT64_TO_UINT(LeafMQFSet.size());
	}
	catch(const exception&)
	{
		QueueFormatSet::iterator Itr = LeafMQFSet.begin();
		QueueFormatSet::iterator ItrEnd = LeafMQFSet.end();

		for(; Itr != ItrEnd; Itr++)
		{
			Itr->DisposeString();
		}

		TrERROR(GENERAL, "Failed FnExpandMqf");
		throw;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\test\fniads.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnIADs.cpp

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <activeds.h>
#include <Oleauto.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "Fnp.h"
#include "FnGeneral.h"
#include "FnIADs.h"

#include "FnIADs.tmh"

using namespace std;


EXTERN_C const IID IID_IADsGroup = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x00}
	};

EXTERN_C const IID IID_IADs = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x01}
	};

EXTERN_C const IID IID_IEnumVARIANT = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x02}
	};

EXTERN_C const IID IID_IDirectoryObject = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x03}
	};



class CADObject: public CADInterface
{
public:
	//
	// IADsGroup interface methods
	//

	virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE);
		return S_FALSE;
	}
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
        /* [in] */ BSTR /*bstrDescription*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Members( 
        /* [retval][out] */ IADsMembers __RPC_FAR *__RPC_FAR * /*ppMembers*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsMember( 
        /* [in] */ BSTR /*bstrMember*/,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR * /*bMember*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
        /* [in] */ BSTR /*bstrNewItem*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
        /* [in] */ BSTR /*bstrItemToBeRemoved*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}

public:
	//
	// IDirectoryObject interface methods
	//

	virtual HRESULT STDMETHODCALLTYPE GetObjectInformation( 
		/* [out] */ PADS_OBJECT_INFO  * /*ppObjInfo*/ )
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes( 
		/* [in] */ LPWSTR *pAttributeNames,
		/* [in] */ DWORD dwNumberAttributes,
		/* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
		/* [out] */ DWORD *pdwNumAttributesReturned);

	virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes( 
		/* [in] */ PADS_ATTR_INFO /*pAttributeEntries*/,
		/* [in] */ DWORD /*dwNumAttributes*/,
		/* [out] */ DWORD * /*pdwNumAttributesModified*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE CreateDSObject( 
		/* [in] */ LPWSTR /*pszRDNName*/,
		/* [in] */ PADS_ATTR_INFO /*pAttributeEntries*/,
		/* [in] */ DWORD /*dwNumAttributes*/,
		/* [out] */ IDispatch ** /*ppObject*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE DeleteDSObject( 
		/* [in] */ LPWSTR /*pszRDNName*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}
        
public:
	//
	// IADs interface methods
	//

    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Name.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Class.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GUID( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Guid.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ADsPath( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Schema( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfo( void) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetInfo( void) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
        /* [in] */ BSTR bstrName,
        /* [retval][out] */ VARIANT __RPC_FAR *pvProp);
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
        /* [in] */ BSTR /*bstrName*/,
        /* [in] */ VARIANT /*vProp*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEx( 
        /* [in] */ BSTR /*bstrName*/,
        /* [retval][out] */ VARIANT __RPC_FAR * /*pvProp*/)
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutEx( 
        /* [in] */ long /*lnControlCode*/,
        /* [in] */ BSTR /*bstrName*/,
        /* [in] */ VARIANT /*vProp*/)
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfoEx( 
        /* [in] */ VARIANT /*vProperties*/,
        /* [in] */ long /*lnReserved*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
public:
	//
	// IDispatch interface methods
	//

    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( 
        /* [out] */ UINT __RPC_FAR * /*pctinfo*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
        /* [in] */ UINT /*iTInfo*/,
        /* [in] */ LCID /*lcid*/,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR * /*ppTInfo*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( 
        /* [in] */ REFIID /*riid*/,
        /* [size_is][in] */ LPOLESTR __RPC_FAR * /*rgszNames*/,
        /* [in] */ UINT /*cNames*/,
        /* [in] */ LCID /*lcid*/,
        /* [size_is][out] */ DISPID __RPC_FAR * /*rgDispId*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Invoke( 
        /* [in] */ DISPID /*dispIdMember*/,
        /* [in] */ REFIID /*riid*/,
        /* [in] */ LCID /*lcid*/,
        /* [in] */ WORD /*wFlags*/,
        /* [out][in] */ DISPPARAMS __RPC_FAR * /*pDispParams*/,
        /* [out] */ VARIANT __RPC_FAR * /*pVarResult*/,
        /* [out] */ EXCEPINFO __RPC_FAR * /*pExcepInfo*/,
        /* [out] */ UINT __RPC_FAR * /*puArgErr*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}

public:
	//
	// IUnknown interface methods
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID /*riid*/,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    {
        InterlockedIncrement(&m_ref);

		return 0;
    }
    
    virtual ULONG STDMETHODCALLTYPE Release( void) 
	{
        ASSERT(m_ref > 0);
        LONG ref = InterlockedDecrement(&m_ref);

        ASSERT(!(ref < 0));

        if(ref == 0)
        {
            delete this;
        }

		return 0;
	}

public:
	CADObject(
		LPCWSTR Name,
		LPCWSTR Class,
		LPCWSTR Guid
		): 
		m_ref(1)
	{
		m_Name = wstring(Name);
		m_Class = wstring(Class);
		m_Guid = wstring(Guid);
	}

    VOID TestPut( 
        BSTR bstrName,
        VARIANT vProp);

public: //protected:
    virtual ~CADObject()
    {
        ASSERT((m_ref == 0) || (m_ref == 1));
    }

private:
    mutable LONG m_ref;

private:
	wstring m_Name;
	wstring m_Class;
	wstring m_Guid;

	//
	// Map that stores attribute names and values
	//
	map<wstring, VARIANTWrapper> m_Attributes;
};



HRESULT STDMETHODCALLTYPE CADObject::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	if(riid == IID_IADsGroup)
	{
		*ppvObject = static_cast<IADsGroup*>(SafeAddRef(this));
		return S_OK;
	}

	if(riid == IID_IADs)
	{
		*ppvObject = static_cast<IADs*>(SafeAddRef(this));
		return S_OK;
	}

	if(riid == IID_IDirectoryObject)
	{
		*ppvObject = static_cast<IDirectoryObject*>(SafeAddRef(this));
		return S_OK;
	}

	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CADObject::Get( 
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvProp)
{
	map<wstring, VARIANTWrapper>::iterator itr = m_Attributes.find(wstring(bstrName));

	ASSERT(itr != m_Attributes.end());

	if(itr == m_Attributes.end())
		return E_ADS_PROPERTY_NOT_FOUND;

	return VariantCopy(pvProp, &itr->second);
}



VOID CADObject::TestPut( 
        BSTR bstrName,
        VARIANT vProp)
{
	VARIANTWrapper& var = m_Attributes[wstring(bstrName)];

	if(FAILED(VariantCopy(&var, &vProp)))
	{
		throw bad_alloc();
	}
}


HRESULT STDMETHODCALLTYPE CADObject::GetObjectAttributes( 
	/* [in] */ LPWSTR *pAttributeNames,
	/* [in] */ DWORD dwNumberAttributes,
	/* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
	/* [out] */ DWORD *pdwNumAttributesReturned)
{
	ASSERT(pAttributeNames != NULL && *pAttributeNames != NULL);
	ASSERT(dwNumberAttributes == 1);
	DBG_USED(dwNumberAttributes);
	ASSERT(ppAttributeEntries != NULL);
	ASSERT(pdwNumAttributesReturned != NULL);

	int RangeLow;
	int RangeHigh;

	int n =swscanf(*pAttributeNames, L"member;Range=%d-%d", &RangeLow, &RangeHigh);
	ASSERT(n == 2);
	DBG_USED(n);
	
	*pdwNumAttributesReturned = 1;
	*ppAttributeEntries = new ADS_ATTR_INFO;

	(*ppAttributeEntries)->dwADsType = ADSTYPE_DN_STRING;
	(*ppAttributeEntries)->pADsValues = new _adsvalue[RangeHigh - RangeLow];
	//
	// Retrieve value of the multi valued 'member' attribute of the 'Group' object
	//
	// Value returns embeded in a VARIANT, as a SAFEARRAY of VARIANTS
	// which hold the BSTR (strings) of the Distinguished Names of 
	// the Group members.
	//
	map<wstring, VARIANTWrapper>::iterator itr = m_Attributes.find(wstring(L"member"));

	ASSERT(itr != m_Attributes.end());

	VARIANTWrapper& var = itr->second;

	//
	// Get the lower and upper bound of the SAFEARRAY
	//
	LONG lstart;
	LONG lend;
	SAFEARRAY* sa = V_ARRAY(&var);

	HRESULT hr = SafeArrayGetLBound(sa, 1, &lstart);
    ASSERT(("Failed SafeArrayGetLBound(sa, 1, &lstart)", SUCCEEDED(hr)));

	hr = SafeArrayGetUBound(sa, 1, &lend);
    ASSERT(("Failed SafeArrayGetUBound(sa, 1, &lend)", SUCCEEDED(hr)));

	ASSERT(RangeLow <= lend - lstart);

	long index = 0;

	for(; (index < RangeHigh - RangeLow) && (index <= lend - lstart); index++)
	{
		VARIANT* pVarItem;
		long i = index + lstart;
		
		hr = SafeArrayPtrOfIndex(sa, &i, (void**)&pVarItem);

		ASSERT(("Failed SafeArrayGetElement(sa, &i, &pVarItem)", SUCCEEDED(hr)));
		ASSERT(pVarItem->vt == VT_BSTR);

		BSTR DistinugishedName = V_BSTR(pVarItem);

		((*ppAttributeEntries)->pADsValues + i)->CaseIgnoreString = newwcs(DistinugishedName);
		((*ppAttributeEntries)->pADsValues + i)->dwType = ADSTYPE_CASE_IGNORE_STRING;
	}

	(*ppAttributeEntries)->dwNumValues = index;
	(*ppAttributeEntries)->pszAttrName = newwcs(*pAttributeNames);

	if(RangeHigh > lend - lstart)
	{
		wcscpy(wcschr((*ppAttributeEntries)->pszAttrName, L'-'), L"*");
	}

	return S_OK;
}



//
// Map stores AD objects with their ADsPath as key
//
map<wstring, R<CADObject> > g_ObjectMap;



extern "C" 
HRESULT 
WINAPI
ADsOpenObject(
    LPCWSTR lpszPathName,
    LPCWSTR /*lpszUserName*/,
    LPCWSTR /*lpszPassword*/,
    DWORD  /*dwReserved*/,
    REFIID /*riid*/,
    VOID * * ppObject
    )
{	
	map<wstring, R<CADObject> >::iterator itr = g_ObjectMap.find(wstring(lpszPathName));

	if(itr == g_ObjectMap.end())
		return E_ADS_UNKNOWN_OBJECT;

	*ppObject = static_cast<IADs*>(SafeAddRef(itr->second.get()));

	return S_OK;
}



extern "C"
BOOL 
WINAPI
FreeADsMem(
   LPVOID pMem
)
{
	PADS_ATTR_INFO pAttrInfo = static_cast<PADS_ATTR_INFO>(pMem);

	ASSERT(pAttrInfo->dwADsType == ADSTYPE_DN_STRING);

	for(unsigned long index = 0; index < pAttrInfo->dwNumValues; index++)
	{
		delete pAttrInfo->pADsValues[index].CaseIgnoreString;
	}

	delete pAttrInfo->pADsValues;
	delete pAttrInfo->pszAttrName;
	delete pAttrInfo;

	return true;
}



R<CADInterface>
CreateADObject(
	const CObjectData& obj
	)
{
	R<CADObject> pObj = new CADObject(
								obj.odDistinguishedName, 
								obj.odClassName, 
								obj.odGuid
								);
	
	g_ObjectMap[wstring(obj.odADsPath)] = pObj;
	
	return pObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\test\fniads.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnIADs.h

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/



struct CObjectData
{
	LPCWSTR odADsPath;
	LPCWSTR odDistinguishedName;
	LPCWSTR odClassName;
	LPCWSTR odGuid;
};



class CADInterface : 
	public IADsGroup, 
	public IDirectoryObject
{
public:
    using IADsGroup::Release;

    virtual VOID TestPut( 
        BSTR bstrName,
        VARIANT vProp) = 0;
};



R<CADInterface> 
CreateADObject(
		const CObjectData& obj
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\adsiutl.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:
    Adsiutl.h

Abstract:
    Decleration of the UtlEscapeAdsPathName() function, used before calling ADsOpenObject(),
	to escape the '/' chars.

Author:
    Oren Weimann (t-orenw) 08-July-02

--*/

#ifndef _MSMQ_ADSIUTL_H_
#define _MSMQ_ADSIUTL_H_

LPCWSTR
UtlEscapeAdsPathName(
    IN LPCWSTR pAdsPathName,
    OUT AP<WCHAR>& pEscapeAdsPathNameToFree
    );

#endif // _MSMQ_ADSIUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\test\mc.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Machine configuration

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <mqmacro.h>

#include "mc.tmh"

static WCHAR s_ComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
static DWORD s_ComputerNameLen = 0;


static
VOID 
ComputerNameInit()
{
    s_ComputerNameLen = TABLE_SIZE(s_ComputerName);
	BOOL fSucc = GetComputerName(s_ComputerName, (LPDWORD)&s_ComputerNameLen);
	
	ASSERT(fSucc);
    DBG_USED(fSucc);
	ASSERT(s_ComputerNameLen <= TABLE_SIZE(s_ComputerName));
}



LPCWSTR
McComputerName(
	VOID
	)
/*++

Routine Description:
    Returns the computer name

Arguments:
    None.

Returned Value:
    A pointer to the computer name string buffer.

--*/
{
	if(s_ComputerName[0] == L'\0')
	{
		ComputerNameInit();
	}

	return s_ComputerName;
}



DWORD
McComputerNameLen(
	VOID
	)
{
	if(s_ComputerNameLen == 0)
	{
		ComputerNameInit();
	}

	return s_ComputerNameLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\allocaptr.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    Module Name:    allocaptr.h

    Abstract:
        Smart pointer used with stack based allocations

    Author:
        Vlad Dovlekaev  (vladisld)      2/18/2002

    History:
        2/18/2002   vladisld    Created

--*/

#pragma once
#ifndef __ALLOCAPTR_H__
#define __ALLOCAPTR_H__

#include <alloca.h>

//---------------------------------------------------------
//
//  SP class.
//
//  Used to auto-release the pointers allocated by SafeAllocaAllocate macro
//
//  Limitations:
//       Since the memory may be allocated from stack, there are some limitation
//       using this class:
//          1. Obviously you can't return this class out of scope.
//          2. It's not gurantered that memory will be deallocated untill return
//             from the function, even if smart pointers is out of scope.
//---------------------------------------------------------

template<class T>
class SP {
private:
    T* m_p;

public:
    SP(T* p = 0) : m_p(p)    {}
   ~SP()                     { SafeAllocaFree(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { T* p = detach(); SafeAllocaFree(p); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    SP& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }


    VOID*& ref_unsafe()
    {
        // unsafe ref to auto pointer, for special uses like
        // InterlockedCompareExchangePointer

        return *reinterpret_cast<VOID**>(&m_p);
    }


private:
    SP(const SP&);
	SP<T>& operator=(const SP<T>&);
};

#define StackAllocSP( p, size ) SafeAllocaAllocate( (p).ref_unsafe(), (size) )

//
// Alloca safe allocator compatible heap allocation routines
//
inline PVOID APIENTRY AllocaHeapAllocate( SIZE_T Size)
{
    return MmAllocate(Size);
}

inline VOID APIENTRY AllocaHeapFree(PVOID BaseAddress)
{
    return MmDeallocate(BaseAddress);
}

const SIZE_T xMaxStackAllocSize = 0x4000;
const SIZE_T xAdditionalProbeSize = 0x4000;

class CSafeAllocaInitializer
{
public:
    CSafeAllocaInitializer()
    {
        SafeAllocaInitialize(xMaxStackAllocSize, xAdditionalProbeSize, AllocaHeapAllocate, AllocaHeapFree);
    }
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\fn\test\fntest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnTest.cpp

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <activeds.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "fntoken.h"
#include "FnGeneral.h"
#include "Fn.h"
#include "FnIADs.h"
#include <strsafe.h>

#include "FnTest.tmh"

using namespace std;


#define LDAP_ADSPATH_PREFIX L"LDAP://"
#define CLASS_NAME_QUEUE L"msMQQueue"
#define CLASS_NAME_ALIAS L"msMQ-Custom-Recipient"
#define CLASS_NAME_GROUP L"group"



/*static void Usage()
{
    printf("Usage: FnTest [*switches*]\n");
    printf("\t*-s*\t*Switch description*\n");
    printf("\n");
    printf("Example, FnTest -switch\n");
    printf("\t*example description*\n");
    exit(-1);

} // Usage
*/



VARIANT String2Variant(LPCWSTR Str)
{
	BSTR bstr = SysAllocString(Str);

	if(bstr == NULL)
	{
		TrERROR(GENERAL, "Failed string allocation");
		throw bad_alloc();
	}

	VARIANT var;
	VariantInit(&var);
	
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = bstr;
		
	return var;
}



VARIANT Array2Variant(LPCWSTR Members[], long nMembers)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = nMembers;

	SAFEARRAY* sa = SafeArrayCreate(
						VT_VARIANT,   //VARTYPE  vt,
						1,			 //unsigned int  cDims,
						rgsabound	//SAFEARRRAYBOUND *  rgsabound
						);

	if(sa == NULL)
	{
		TrERROR(GENERAL, "Failed SafeArrayCreate()");
		throw bad_alloc();
	}

	long indice[1] = {0};
	long& idx = indice[0];

	for(; idx < nMembers; idx++)
	{
		VARIANTWrapper VarItem;
		
		BSTR bstr = SysAllocString(Members[idx]);

		if(bstr == NULL)
		{
			TrERROR(GENERAL, "Failed SysAllocString(Members[idx])");
			throw bad_alloc();
		}

		V_VT(&VarItem) = VT_BSTR;
		V_BSTR(&VarItem) = bstr;
		
		HRESULT hr = SafeArrayPutElement(sa, indice, &VarItem);
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed SafeArrayPutElement(sa, indice, &VarItem)");
			throw bad_alloc();
		}
	}

	VARIANT var;
	VariantInit(&var);
	
	V_VT(&var) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(&var) = sa;

	return var;
}



GUID String2Guid(LPCWSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = _snwscanf(
						GuidStr,
						LDAP_GUID_STR_LEN,
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);
	if(nFields != 16)
	{
		TrERROR(GENERAL, "Bad Guid string format, in String2Guid()");
		throw exception();
    }

	for(size_t i = 0; i < 16; i++)
	{
		((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
	}

 	return Guid;
}



VOID TestExpandMqf()
/*++

Routine Description:
	For this purpose we construct a tree of objects in a simulated Directory

                        DL0
                      / /\ \
                    /  |  |   \
                  /    |  |      \
                /     /    \        \
           Queue0   DL1   Queue2      DL2
                  / /| \             /\ \ \
               /   / |  \           |  |  \   \
            /     /  |   \          |  |    \     \
         /       /   |    \        /    \     \       \
	Computer Alias0 DL0 Queue1  Printer  DL3   Queue4  Alias0
                                       / /|\ \
                                     /  / | \   \
                                   /   /  |  \     \
                                 /    /   |   \       \
                            Queue1 User Alias1 Queue3  DL1
							

	This tree is actually a graph with circles, and contains unsupported objects.

	After the expansion, we should have an array with the 5 queues from Queue0
	to Queue4.

--*/
{
	//
	// CoInitialize() and CoUninitialize() are not needed for the test,
	// but should be invoked when using the library
	//
    //	HRESULT hr;
	//	hr = CoInitialize(NULL);
    //	if(FAILED(hr))
	//	{
	//		TrERROR(GENERAL, "Failed CoInitialize() with status %d", hr);
	//		throw exception();
	//	}
	
	//
	// --------------- Test queues definitions ----------------
	//

	CObjectData Queue[5] = {
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue0",
			L"CN=Queue0",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0000"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue1",
			L"CN=Queue1",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0001"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue2",
			L"CN=Queue2",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0002"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue3",
			L"CN=Queue3",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0003"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue4",
			L"CN=Queue4",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0004"
		}
	};

	CreateADObject(Queue[0]);
	CreateADObject(Queue[1]);
	CreateADObject(Queue[2]);
	CreateADObject(Queue[3]);
	CreateADObject(Queue[4]);

	//
	// --------------- Test Alias definitions -------------------
	//

	CObjectData Alias[2] = {
		{
			LDAP_ADSPATH_PREFIX L"CN=Alias0",
			L"CN=Alias0",
			CLASS_NAME_ALIAS,
			L"00112233445566778899aabbccdd0300"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Alias1",
			L"CN=Alias1",
			CLASS_NAME_ALIAS,
			L"00112233445566778899aabbccdd0301"
		}
	};

	LPCWSTR AliasFormatName[] = {
		L"DIRECT=OS:host\\private$\\queue0",
		L"DIRECT=OS:host\\private$\\queue1"
	};

	R<CADInterface> Alias0 = CreateADObject(Alias[0]);
	R<CADInterface> Alias1 = CreateADObject(Alias[1]);

	try
	{
		Alias0->TestPut(
			L"msMQ-Recipient-FormatName",
			String2Variant(AliasFormatName[0])
			);
		Alias1->TestPut(
			L"msMQ-Recipient-FormatName",
			String2Variant(AliasFormatName[1])
			);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "CADObject::TestPut() threw an exception()");
		throw;
	}

	//
	// --------------- Test DLs definitions -------------------
	//

	CObjectData DL[4] = {
		//
		// Note that first DL's ADsPath value is a Guid path (LDAP://<GUID=...>).
		// This is since it is the root DL, and as such is passed to FnExpandMqf()
		// in the TopLevelMqf array, as a QUEUE_FORMAT object.
		//
		// Inside FnExpandMqf(), its GUID is extracted and form it the ADsPath
		// is constructed. thus, the ADsPath is based on a GUID.
		//
		{
			LDAP_ADSPATH_PREFIX L"<GUID=00112233445566778899aabbccdd0100>" ,
			L"<GUID=00112233445566778899aabbccdd0100>",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0100"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL1",
			L"CN=DL1",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0101"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL2",
			L"CN=DL2",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0102"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL3",
			L"CN=DL3",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0103"
		}
	};

	R<CADInterface> DLObject[4] = {
		CreateADObject(DL[0]),
		CreateADObject(DL[1]),
		CreateADObject(DL[2]),
		CreateADObject(DL[3])
	};

	//
	// ----------- Test unsupported objects definitions ----------
	//

	//
	// UO stands for Unsupported Objects
	//

	CObjectData Computer =
	{
		LDAP_ADSPATH_PREFIX L"CN=Computer",
		L"CN=Computer",
		L"Computer",
		L"00112233445566778899aabbccdd0200"
	};

	CObjectData Printer =
	{
			LDAP_ADSPATH_PREFIX L"CN=Printer",
			L"CN=Printer",
			L"Printer",
			L"00112233445566778899aabbccdd0201"
	};

	CObjectData User =
	{
			LDAP_ADSPATH_PREFIX L"CN=User",
			L"CN=User",
			L"User",
			L"00112233445566778899aabbccdd0202"
	};

	CreateADObject(Computer);
	CreateADObject(Printer);
	CreateADObject(User);

	//
	// ---------------- Membership definitions -----------------
	//

	try
	{
		LPCWSTR Dl0Members[] = {
			Queue[0].odDistinguishedName,
			DL[1].odDistinguishedName,
			Queue[2].odDistinguishedName,
			DL[2].odDistinguishedName
		};

		DLObject[0]->TestPut(L"member", Array2Variant(Dl0Members, TABLE_SIZE(Dl0Members)));

		LPCWSTR Dl1Members[] = {
			Computer.odDistinguishedName,
			Alias[0].odDistinguishedName,
			DL[0].odDistinguishedName,
			Queue[1].odDistinguishedName
		};

		DLObject[1]->TestPut(L"member", Array2Variant(Dl1Members, TABLE_SIZE(Dl1Members)));

		LPCWSTR Dl2Members[] = {
			Printer.odDistinguishedName,
			DL[3].odDistinguishedName,
			Queue[4].odDistinguishedName,
			Alias[0].odDistinguishedName
		};

		DLObject[2]->TestPut(L"member", Array2Variant(Dl2Members, TABLE_SIZE(Dl2Members)));

		LPCWSTR Dl3Members[] = {
			Queue[1].odDistinguishedName,
			User.odDistinguishedName,
			Alias[1].odDistinguishedName,
			Queue[3].odDistinguishedName,
			DL[1].odDistinguishedName,
		};

		DLObject[3]->TestPut(L"member", Array2Variant(Dl3Members, TABLE_SIZE(Dl3Members)));
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "CADObject::TestPut() threw an exception()");
		throw;
	}

	//
	// --------------- Call FnExpandMqf() ------------------
	//

	DL_ID dlid;
	dlid.m_pwzDomain = NULL;
	dlid.m_DlGuid = String2Guid(DL[0].odGuid);

	QUEUE_FORMAT TopLevelMqf[] = {
		QUEUE_FORMAT(dlid)
	};

	QUEUE_FORMAT* pLeafMqf;
	ULONG nLeafMqf;

	FnExpandMqf(TABLE_SIZE(TopLevelMqf), TopLevelMqf, &nLeafMqf, &pLeafMqf);

	if(nLeafMqf != 7)
	{
		TrERROR(GENERAL, "Array Returned Does not contain 7 QueueFormats.");
		throw exception();
	}

	//
	// Check the array contains Queue[0]...Queue[4], in that order
	//

	for(int i = 0; i < 5; i++)
	{
		if(pLeafMqf[i].GetType() != QUEUE_FORMAT_TYPE_PUBLIC)
		{
			TrERROR(GENERAL, "Queue Format is not public.");
			throw exception();
		}

		WCHAR GuidStr[MAX_PATH];
		GUID Guid = pLeafMqf[i].PublicID();

		StringCchPrintf(
			GuidStr,
			MAX_PATH,
			LDAP_GUID_FORMAT,
			LDAP_PRINT_GUID_ELEMENTS(((BYTE*)&Guid))
		);

		if(wcscmp(GuidStr, Queue[i].odGuid) != 0)
		{
			TrERROR(GENERAL, "Not Guid of expected queue.");
			throw exception();
		}
	}

	//
	// Check the array contains Alias[0]...Alias[1], in that order
	//

	for(int j = 0; j < 2; i++, j++)
	{
		if(pLeafMqf[i].GetType() != QUEUE_FORMAT_TYPE_DIRECT)
		{
			TrERROR(GENERAL, "Queue Format is not direct.");
			throw exception();
		}

		LPCWSTR DirectID = wcschr(AliasFormatName[j], L'=') ;
		ASSERT(("Bad Alias name. Missing '='", DirectID != 0));
		DirectID++;

		if(wcscmp(DirectID, pLeafMqf[i].DirectID()) != 0)
		{
			TrERROR(GENERAL, "Not DirectID of expected queue.");
			throw exception();
		}
	}
}



LPCWSTR GoodFormatNames[] = {
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff",
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",

	L"DL=" L"00112233-4455-6677-8899-aabbccddeeff" L"@" L"Domain",

	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"00000010",
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"00000010" L";JOURNAL",

	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"QueueName",
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"QueueName",
	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"HTTP://Host" L"\\" L"QueueName",
	L"DIRECT=" L"HTTP://Host" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"HTTPS://Host" L"\\" L"QueueName",
	L"DIRECT=" L"HTTPS://Host" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";DEADXACT",

	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADLETTER",
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADXACT",

	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff",
	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff" L";XACTONLY",

	L"MULTICAST=224.224.222.123:1234",
	L"MULTICAST=224.10.20.30:8080",
	L"MULTICAST=224.10.0.30:8080"
};

LPCWSTR BadFormatNames[] = {
	//Bad Prefix
	L"PUBLIK=" L"00112233-4455-6677-8899-aabbccddeeff",

	//Bad PUBLIC GUID
	L"PUBLIC=" L"00112233+4455-6677-8899-aabbccddeeff",
	//Bad PUBLIC GUID
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeefff",
	//Bad PUBLIC suffix
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";JURNAL",
	//Bad PUBLIC. Unexpected suffix
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADLETTER",

	//Bad DL separator
	L"DL=" L"00112233-4455-6677-8899-aabbccddeeff" L"#" L"Domain",
	
	//Bad PRIVATE GUID
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeffg" L"\\" L"00000001",
	//Bad PRIVATE seperator
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"," L"00000001",
	//Bad PRIVATE private id
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"000000001",

	//Bad DIRECT token
	L"DIRECT=" L"TCB:10.20.30.40" L"\\" L"QueueName",

	//Bad DIRECT tcp address
//	L"DIRECT=" L"TCP:10.20.30.40.50" L"\\" L"QueueName",
	//Bad DIRECT tcp address
//	L"DIRECT=" L"TCP:10,20.30.40" L"\\" L"QueueName",
	//Bad DIRECT tcp (Contains carriage return in machinename.)
	L"DIRECT=" L"TCP:10.20.30\x0d.40" L"\\" L"QueueName",
	//Bad DIRECT tcp queue name seperator
	L"DIRECT=" L"TCP:10.20.30.40" L";" L"QueueName",
	//Bad DIRECT tcp queue name
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"Queue\x0dName",
	//Bad DIRECT tcp private specifier
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"PRIVETE$" L"\\" L"QueueName",
	//Bad DIRECT tcp system specifier
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SISTEM$" L";JOURNAL",
	//Bad DIRECT tcp suffix seperator
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L":JOURNAL",
	//Bad DIRECT tcp suffix
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";JURNAL",
	//Bad DIRECT os address
	L"DIRECT=" L"OS:" L"\\" L"QueueName",
	//Bad DIRECT os address (Contains carriage return in machinename.)
	L"DIRECT=" L"OS:" L"Machi\x0dne1\\" L"QueueName",
	//Bad DIRECT os address
	L"DIRECT=" L"OS:" L"Machine\\" L"Queue\x0dName",
	//Bad DIRECT os address
//	L"DIRECT=" L"OS:Machine,Domain" L"\\" L"QueueName",

	//Bad MACHINE. Missing suffix
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff",
	//Bad MACHINE GUID
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeefff" L";JOURNAL",

	//Bad CONNECTOR GUID
	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeffg",
	//Bad CONNECTOR. Unexpected suffix
//	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",

	//Bad MQF
//	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff,",

	//Bad MULTICAST format name. Not class D ip address.
	L"MULTICAST=223.10.20.30:8080",

	//Bad MULTICAST format name. Bad ip address
	L"MULTICAST=224.10.20.301:8080",

	//Bad MULTICAST format name. Bad ip address
	L"MULTICAST=224.10.20:8080",

	//Bad MULTICAST format name. Missing port
	L"MULTICAST=224.10.20.30",

	//Bad MULTICAST format name. Bad port number
	L"MULTICAST=224.10.20.30:-8080",

	//Bad MULTICAST format name. Leading zeroes
	L"MULTICAST=224.10.20.030:8080",

	//Bad MULTICAST format name. white spaces
	L"MULTICAST=224.10.20. 30:8080",

	// Bad MULTICAST address
	L"MULTICAST=224.0xaa.0xbb.0xcc:8080"

};



VOID TestParsingRoutines()
{
	size_t cGoodFormatNames = TABLE_SIZE(GoodFormatNames);
	size_t cBadFormatNames = TABLE_SIZE(BadFormatNames);

	for(size_t i = 0; i < cGoodFormatNames; i++)
	{
		QUEUE_FORMAT QueueFormat;
		AP<WCHAR> StringToFree;

		TrTRACE(GENERAL, "Parsing good format name '%ls'", GoodFormatNames[i]);

		BOOL Result = FnFormatNameToQueueFormat(
						GoodFormatNames[i], //LPCWSTR lpwcsFormatName,
						&QueueFormat, //QUEUE_FORMAT* pQueueFormat,
						&StringToFree //LPWSTR* ppStringToFree
						);
	
		if(!Result)
		{
			TrERROR(GENERAL, "Failed Parsing of '%ls'", GoodFormatNames[i]);
			throw exception();
		}
	}

	for(size_t i = 0; i < cBadFormatNames; i++)
	{
		QUEUE_FORMAT QueueFormat;
		AP<WCHAR> StringToFree;

		TrERROR(GENERAL, "Parsing bad format name '%ls'", BadFormatNames[i]);

		BOOL Result = FnFormatNameToQueueFormat(
						BadFormatNames[i], //LPCWSTR lpwcsFormatName,
						&QueueFormat, //QUEUE_FORMAT* pQueueFormat,
						&StringToFree //LPWSTR* ppStringToFree
						);
	
		if(Result)
		{
			TrERROR(GENERAL, "Passed Parsing of '%ls'", BadFormatNames[i]);
			throw exception();
		}
	}

	wstring mqf;
	size_t j = 0;

	for(; j < cGoodFormatNames; j++)
	{
		mqf += wstring(GoodFormatNames[j]);

		if(j + 1 < cGoodFormatNames)
		{
			mqf += L',';
		}
	}
	
	TrTRACE(GENERAL, "Parsing good MQF '%ls'", mqf.c_str());

	AP<QUEUE_FORMAT> pQueueFormat;
	DWORD nQueues;
	CStringsToFree StringsToFree;

	BOOL Result = FnMqfToQueueFormats(
					mqf.c_str(),
					pQueueFormat,
					&nQueues,
					StringsToFree
					);
	
	if(!Result || nQueues != j)
	{
		TrERROR(GENERAL, "Failed Parsing of good mqf.");
		throw exception();
	}
}


const WCHAR xDirectQueueFormat1[] = L"msmq\\private$\\temp1";
const WCHAR xDirectQueueFormat2[] = L"msmq\\private$\\temp2";

void TestFnQueueFormat(void)
{
    CFnQueueFormat fnqf;
    GUID guid;

    //
    // Test public queue
    //
    UuidCreate(&guid);

    QUEUE_FORMAT publicQueue(guid);
    fnqf.CreateFromQueueFormat(publicQueue);

    if ((fnqf.PublicID() != publicQueue.PublicID()) ||
        (fnqf.Suffix() != publicQueue.Suffix()))
        throw exception();

    //
    // Test private queue
    //
    UuidCreate(&guid);
    QUEUE_FORMAT privateQueue(guid, rand());
    privateQueue.Suffix(QUEUE_SUFFIX_TYPE_JOURNAL);

    fnqf.CreateFromQueueFormat(privateQueue);

    if ((fnqf.PrivateID().Lineage != privateQueue.PrivateID().Lineage) ||
        (fnqf.PrivateID().Uniquifier != privateQueue.PrivateID().Uniquifier) ||
        (fnqf.Suffix() != privateQueue.Suffix()))
        throw exception();

    //
    // Test direct queue
    //
    QUEUE_FORMAT directQueue(const_cast<LPWSTR>(xDirectQueueFormat1));
    fnqf.CreateFromQueueFormat(directQueue);

    if ((wcscmp(fnqf.DirectID(), directQueue.DirectID()) != 0) ||
        (fnqf.Suffix() != directQueue.Suffix()))
        throw exception();

    QUEUE_FORMAT directQueue2(const_cast<LPWSTR>(xDirectQueueFormat2));
    fnqf.CreateFromQueueFormat(directQueue2);

    if ((wcscmp(fnqf.DirectID(), directQueue2.DirectID()) != 0) ||
        (fnqf.Suffix() != directQueue2.Suffix()))
        throw exception();

}

static void TestCFnMqf()
{
	std::vector<std::wstring> qf;
	qf.push_back(L"direct=http://gilsh10\\msmq\\private$\\t");
	qf.push_back(L"direct=os:gilsh10\\private$\\t");
    qf.push_back(L"direct=http://gilsh10\\msmq\\t");

	std::wstring mqf;
	std::vector<std::wstring>::const_iterator it = qf.begin();
	while(it!= qf.end() )
	{
		mqf += *it;
		if(++it != qf.end())
		{
			mqf += FN_MQF_SEPARATOR_C;
		}
	}

	CFnMqf FnMqf(xwcs_t(mqf.begin(), mqf.size()) );
	if(FnMqf.GetCount() != 	qf.size())
	{
		 throw exception();
	}

	for(DWORD i = 0;i< FnMqf.GetCount(); ++i)
	{
		const QUEUE_FORMAT*  CreatetedQueueFormat = FnMqf.GetQueueFormats();
		UNREFERENCED_PARAMETER(CreatetedQueueFormat);
	}

}

static void TestDirectFormatNames()
{
	QUEUE_FORMAT goodDirectQueue(L"os:nelatest3\\q1");
	QUEUE_FORMAT badDirectQueue1(L"");
	QUEUE_FORMAT badDirectQueue2(L"badstring");

	if (!FnIsValidQueueFormat(&goodDirectQueue))
	{
		TrERROR(GENERAL, "FnIsValidQueueFormat has a bug!!");
		throw exception();
	}

	if (FnIsValidQueueFormat(&badDirectQueue1) || FnIsValidQueueFormat(&badDirectQueue2))
	{
		TrERROR(GENERAL, "FnIsValidQueueFormat has a bug!!");
		throw exception();
	}
}


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Format Name Parsing library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    TrInitialize();

    FnInitialize();

	try
	{
		TestCFnMqf();
		TestExpandMqf(); 
		TrTRACE(GENERAL, "TestExpandMqf() passed.");

		TestParsingRoutines();
		TrTRACE(GENERAL, "TestParsingRoutines() passed.");

        TestFnQueueFormat();
        TrTRACE(GENERAL, "TestFnQueueFormat() passed.");

		TestDirectFormatNames();
        TrTRACE(GENERAL, "TestDirectFormatNames() passed.");
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Test FAILED.");
		return 1;
	}

	TrTRACE(GENERAL, "Test PASSED.");

    WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\automqfr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    snapptr.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Nela Karpel (nelak) 14-Jan-01

--*/

#pragma once

#ifndef _MSMQ_SNAPIN_AUTOPTR_H_
#define _MSMQ_SNAPIN_AUTOPTR_H_

//---------------------------------------------------------
//
//  template class SP
//
//---------------------------------------------------------
template<class T>
class CAutoMQFree {
private:
    T* m_p;

public:
    CAutoMQFree(T* p = 0) : m_p(p)    {}
   ~CAutoMQFree()                     { MQFreeMemory(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { MQFreeMemory(detach()); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    CAutoMQFree& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CAutoMQFree(const CAutoMQFree&);
	CAutoMQFree<T>& operator=(const CAutoMQFree<T>&);
};

#endif // _MSMQ_SNAPIN_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\autosec.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autosec.h

Abstract:
    Auto classes for all kind of security objects

Author:
    Gil Shafriri (gilsh) 06-Jan-97

--*/

#pragma once

#ifndef _MSMQ_AUTOSEC_H_
#define _MSMQ_AUTOSEC_H_


#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>


//---------------------------------------------------------
//
//  class CCertificateContext
//
//---------------------------------------------------------
class CCertificateContext{
public:
    CCertificateContext(PCCERT_CONTEXT h = NULL) : m_h(h) {}
   ~CCertificateContext()                   { if (m_h != NULL) CertFreeCertificateContext(m_h); }

    PCCERT_CONTEXT* operator &()            { return &m_h; }
    operator PCCERT_CONTEXT() const         { return m_h; }
    PCCERT_CONTEXT  detach()                { PCCERT_CONTEXT  h = m_h; m_h = NULL; return h; }

private:
    CCertificateContext(const CCertificateContext&);
    CCertificateContext& operator=(const CCertificateContext&);

private:
    PCCERT_CONTEXT  m_h;
};


//---------------------------------------------------------
//
//  class CCertificateContext
//
//---------------------------------------------------------
class CCertOpenStore
{
public:
    CCertOpenStore(HCERTSTORE h = NULL,DWORD flags = 0) : m_h(h),m_flags(flags) {}
   ~CCertOpenStore()             { if (m_h != NULL) CertCloseStore(m_h,m_flags); }

    HCERTSTORE* operator &()         { return &m_h; }
    operator HCERTSTORE() const      { return m_h; }
    HCERTSTORE   detach()            { HCERTSTORE  h = m_h; m_h = NULL; return h; }

private:
    CCertOpenStore(const CCertOpenStore&);
    CCertOpenStore& operator=(const CCertOpenStore&);

private:
    HCERTSTORE  m_h;
	DWORD m_flags;
};


//---------------------------------------------------------
//
//  helper class CSSPISecurityContext
//
//---------------------------------------------------------
class CSSPISecurityContext
{
public:
    CSSPISecurityContext(const CtxtHandle& h ):m_h(h)
	{
	}

	
	CSSPISecurityContext()
	{
		m_h.dwUpper = 0xFFFFFFFF;
		m_h.dwLower = 0xFFFFFFFF;
	}

	CredHandle operator=(const CredHandle& h)
	{
		free();
		m_h = h;
        return h;
	}	

    ~CSSPISecurityContext()
    {
		if(IsValid())
		{
		   DeleteSecurityContext(&m_h);	 //lint !e534
		}
    }

	CredHandle* getptr(){return &m_h;}

	void free()
	{
		if(IsValid())
		{
		   DeleteSecurityContext(&m_h);
		}
	}
 
	bool IsValid()const
	{
		return (m_h.dwUpper != 0xFFFFFFFF) ||( m_h.dwLower != 0xFFFFFFFF);		
	}



private:
    CSSPISecurityContext(const CSSPISecurityContext&);
    CSSPISecurityContext& operator=(const CSSPISecurityContext&);

private:
    CredHandle  m_h;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\autohandle.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autohandle.h

Abstract:
    Auto handle classes, free the handle resoruce when destructed.

Author:
    Erez Haba (erezh) 06-Jan-97

--*/

#pragma once

#ifndef _MSMQ_AUTOHANDLE_H_
#define _MSMQ_AUTOHANDLE_H_


//---------------------------------------------------------
//
//  class CHandle
//
//---------------------------------------------------------
class CHandle {
public:
    CHandle(HANDLE h = 0) : m_h(h)  {}
   ~CHandle()                       { if (m_h != 0) CloseHandle(m_h); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CHandle(const CHandle&);
    CHandle& operator=(const CHandle&);

private:
    HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CFileHandle
//
//---------------------------------------------------------
class CFileHandle {
public:
    CFileHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CFileHandle()                   { if (m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }

private:
    CFileHandle(const CFileHandle&);
    CFileHandle& operator=(const CFileHandle&);

private:
    HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CSearchFileHandle
//
//---------------------------------------------------------
class CSearchFileHandle {
public:
    CSearchFileHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CSearchFileHandle()                   { free(); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }
    void free()
    {
        if (m_h != INVALID_HANDLE_VALUE)
        {
            FindClose(m_h);
            m_h = INVALID_HANDLE_VALUE;
        }
    }

private:
    CSearchFileHandle(const CSearchFileHandle&);
    CSearchFileHandle& operator=(const CSearchFileHandle&);

private:
    HANDLE m_h;
};

//---------------------------------------------------------
//
//  class CDirChangeNotificationHandle
//
//---------------------------------------------------------
class CDirChangeNotificationHandle {
public:
   CDirChangeNotificationHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CDirChangeNotificationHandle()
   {
		if (m_h != INVALID_HANDLE_VALUE) FindCloseChangeNotification(m_h);
   }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }

private:
    CDirChangeNotificationHandle(const CDirChangeNotificationHandle&);
    CDirChangeNotificationHandle& operator=(const CDirChangeNotificationHandle&);

private:
    HANDLE m_h;
};



//---------------------------------------------------------
//
//  class CSocketHandle
//
//---------------------------------------------------------
class CSocketHandle {
public:
    CSocketHandle(SOCKET h = INVALID_SOCKET) : m_h(h) {}
   ~CSocketHandle()                 { if (m_h != INVALID_SOCKET) closesocket(m_h); }

    SOCKET* operator &()            { return &m_h; }
    operator SOCKET() const         { return m_h; }
    SOCKET detach()                 { SOCKET h = m_h; m_h = INVALID_SOCKET; return h; }
    void free()
    {
		if (m_h != INVALID_SOCKET)
		{
			closesocket(detach());
		}		
    }

private:
    CSocketHandle(const CSocketHandle&);
    CSocketHandle& operator=(const CSocketHandle&);

private:
    SOCKET m_h;
};

//---------------------------------------------------------
//
//  class CRegHandle
//
//---------------------------------------------------------
class CRegHandle {
public:
    CRegHandle(HKEY h = 0) : m_h(h) {}
   ~CRegHandle()                    { if (m_h != 0) RegCloseKey(m_h); }

    HKEY* operator &()              { return &m_h; }
    operator HKEY() const           { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CRegHandle(const CRegHandle&);
    CRegHandle& operator=(const CRegHandle&);

private:
    HKEY m_h;
};


//---------------------------------------------------------
//
//  class CLibHandle
//
//---------------------------------------------------------
class CLibHandle {
public:
    CLibHandle(HINSTANCE h = 0) : m_h(h) {}
   ~CLibHandle()                    { if (m_h != 0) FreeLibrary(m_h); }

    HINSTANCE* operator &()         { return &m_h; }
    operator HINSTANCE() const      { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CLibHandle(const CLibHandle&);
    CLibHandle& operator=(const CLibHandle&);

private:
    HINSTANCE m_h;
};


//---------------------------------------------------------
//
//  class CBitmapHandle
//
//---------------------------------------------------------
class CBitmapHandle {
public:
    CBitmapHandle(HBITMAP h = 0) : m_h(h) {}
   ~CBitmapHandle()					{ if (m_h != 0) DeleteObject(m_h); }

    HBITMAP* operator &()			{ return &m_h; }
    operator HBITMAP() const		{ return m_h; }
    HBITMAP detach()					{ HBITMAP h = m_h; m_h = 0; return h; }

private:
    CBitmapHandle(const CBitmapHandle&);
    CBitmapHandle& operator=(const CBitmapHandle&);

private:
    HBITMAP m_h;
};

#endif // _MSMQ_AUTOHANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\bufutl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    bufutl.h

Abstract:
    Header file for some utilities that deals with buffers.
	implementation is in bufutl.cpp in the utl.lib

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef BUFUTL_H
#define BUFUTL_H

#include <buffer.h>

//
// Appending formatted string to resizable buffer
//
template <class BUFFER, class T>
size_t 
__cdecl 
UtlSprintfAppend(
	BUFFER* pResizeBuffer, 
	const T* format ,...
	);



//
// Appending  string to resizable buffer
//
template <class BUFFER, class T>
size_t 
UtlStrAppend(
	BUFFER* pResizeBuffer, 
	const T* str
	);








#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\autoptr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    autoptr.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba (erezh) 11-Mar-96

--*/

#pragma once

#ifndef _MSMQ_AUTOPTR_H_
#define _MSMQ_AUTOPTR_H_


//---------------------------------------------------------
//
//  template class P
//
//---------------------------------------------------------
template<class T>
class P {
private:
    T* m_p;

public:
    P(T* p = 0) : m_p(p)    {}
   ~P()                     { delete m_p; }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { delete detach(); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    P& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }


    VOID*& ref_unsafe()
    {
        // unsafe ref to auto pointer, for special uses like
        // InterlockedCompareExchangePointer

        return *reinterpret_cast<VOID**>(&m_p);
    }


private:
    P(const P&);
	P<T>& operator=(const P<T>&);
};


//---------------------------------------------------------
//
//  template class AP
//
//---------------------------------------------------------
template<class T>
class AP {
private:
    T* m_p;

public:
    AP(T* p = 0) : m_p(p)   {}
   ~AP()                    { delete[] m_p; }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { delete[] detach(); }
    void swap(AP& rhs)      { T* t = m_p; m_p = rhs.m_p, rhs.m_p = t;}

    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    AP& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign", m_p == 0));
        m_p = p;
        return *this;
    }


    VOID*& ref_unsafe()
    {
        // unsafe ref to auto pointer, for special uses like
        // InterlockedCompareExchangePointer

        return *reinterpret_cast<VOID**>(&m_p);
    }

private:
    AP(const AP&);
	AP<T>& operator=(const AP<T>&);

};

//---------------------------------------------------------
//
//  template SafeAssign helper function.
//
//---------------------------------------------------------
template <class T> T&  SafeAssign(T& dest , T& src)
{
	if(dest.get() != src.get() )
	{
		dest.free();
		if(src.get() != NULL)
		{
			dest = 	src.detach();
		}
	}
	return dest;
}


template<class T> void SafeDestruct(T* p)
{
    if (p != NULL)
    {
        p->~T();
    }
}

//---------------------------------------------------------
//
//  template class D
//
//---------------------------------------------------------
template<class T>
class D {
private:
    T* m_p;

public:
    D(T* p = 0) : m_p(p)    {}
   ~D()                     { SafeDestruct<T>(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { SafeDestruct<T>(detach()); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    D& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    D(const D&);
};


//---------------------------------------------------------
//
//  template SafeAddRef/SafeRelease helper functions.
//
//---------------------------------------------------------
template<class T> T* SafeAddRef(T* p)
{
    if (p != NULL)
    {
        p->AddRef();
    }

    return p;
}


template<class T> void SafeRelease(T* p)
{
    if (p != NULL)
    {
        p->Release();
    }
}


//---------------------------------------------------------
//
//  template class R
//
//---------------------------------------------------------
template<class T>
class R {
private:
    T* m_p;

public:
    R(T* p = 0) : m_p(p)    {}
   ~R()                     { SafeRelease<T>(m_p); }

    //
    // Removed casting operator, this oprator leads to bugs that are
    // hard to detect. To get the object pointer use get() explicitly.
    // erezh 8-Feb-2000
    //
    //operator T*() const     { return m_p; }

    //
    // Removed pointer reference operator, this oprator prevents R usage in
    // STL containers. Use the ref() member instade. e.g., &p.ref()
    // erezh 17-May-2000
    //
    //T** operator&()       { return &m_p; }

    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }

    T*& ref()
    {
        ASSERT(("Auto release in use, can't take object reference", m_p == 0));
        return m_p;
    }


    void free()
    {
        SafeRelease<T>(detach());
    }


    R& operator=(T* p)
    {
        SafeRelease<T>(m_p);
        m_p = p;

        return *this;
    }


    template <class O> R(const R<O>& r)
    {
        m_p = SafeAddRef<O>(r.get());
    }


    template <class O> R& operator=(const R<O>& r)
    {
        SafeAddRef<O>(r.get());
        SafeRelease<T>(m_p);
        m_p = r.get();
        return *this;
    }


    R(const R& r)
    {
        m_p = SafeAddRef<T>(r.get());
    }


    R& operator=(const R& r)
    {
        SafeAddRef<T>(r.get());
        SafeRelease<T>(m_p);
        m_p = r.get();

        return *this;
    }
};


#endif // _MSMQ_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\cs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cs.h

Abstract:
    Critical Section Auto classes

Author:
    Erez Haba (erezh) 06-jan-97

--*/

#pragma once

#ifndef _MSMQ_CS_H_
#define _MSMQ_CS_H_

#include <new>

//---------------------------------------------------------
//
//  class CCriticalSection
//
//---------------------------------------------------------
class CCriticalSection {

    friend class CS;

public:

    static const DWORD xAllocateSpinCount = 0x80000000;

public:
    CCriticalSection()
    {
    	__try
    	{
			InitializeCriticalSection(&m_cs);
    	}
    	__except(GetExceptionCode() == STATUS_NO_MEMORY)
    	{
			//
            // In low memory situations, InitializeCriticalSection can raise
            // a STATUS_NO_MEMORY exception.
            //
            ThrowBadAlloc();
    	}
    }

	//
	// Use xAllocateSpinCount as argument to construct a critical section with
	// allocated resources. i.e. it will not throw exceptions on Lock()
	//
	CCriticalSection(DWORD SpinCount)
	{
        __try
        {
            if(!InitializeCriticalSectionAndSpinCount(&m_cs, SpinCount))
            {
                ThrowBadAlloc();
            }
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
            //
            // In low memory situations, EnterCriticalSection can raise
            // a STATUS_NO_MEMORY exception. We translate this exception
            // to a low memory exception.
            //
            ThrowBadAlloc();
        }
    }


    ~CCriticalSection()
    {
        DeleteCriticalSection(&m_cs);
    }
    
private:
    void Lock()
    {
        __try
        {
            EnterCriticalSection(&m_cs);
        }
        __except(GetExceptionCode() == STATUS_INVALID_HANDLE)
        {
            //
            // In low memory situations, EnterCriticalSection can raise
            // a STATUS_INVALID_HANDLE exception. We translate this exception
            // to a low memory exception.
            //
            ThrowBadAlloc();
        }
    }


    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }


    static void ThrowBadAlloc()
    {
        //
        // Workaround to enable PREfast. This can not be thrown directly
        // from within an __except block.
        //
        throw std::bad_alloc();
    }

private:
    CRITICAL_SECTION m_cs;       
};


//---------------------------------------------------------
//
//  class CS
//
//---------------------------------------------------------
class CS {
public:
    CS(CCriticalSection& lock) : m_lock(&lock)
		{
			m_lock->Lock();
	}


    ~CS()
    {
			m_lock->Unlock();
		}

private:
    CCriticalSection* m_lock;
};



#endif // _MSMQ_CS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\cm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cm.h

Abstract:
    Configuration Manager public interface

Author:
    Uri Habusha (urih) 28-Apr-99

--*/

#pragma once

#ifndef _MSMQ_Cm_H_
#define _MSMQ_Cm_H_

class RegEntry 
{
public:
    enum RegFlag { Optional, MustExist };

public:
    RegEntry(
        LPCWSTR SubKey,
        LPCWSTR ValueName, 
        DWORD DefaultValue = 0,
        RegFlag Flags = Optional,
		HKEY Key = NULL
        );

public:
    RegFlag m_Flags;
    LPCWSTR m_SubKey;
    LPCWSTR m_ValueName;
	DWORD m_DefaultValue;
	HKEY m_Key;
};

inline
RegEntry::RegEntry(
        LPCWSTR SubKey,
        LPCWSTR ValueName, 
        DWORD DefaultValue, //  = 0,
        RegFlag Flags,  // = Optional,
		HKEY Key 
    ) :
    m_Key(Key),
	m_SubKey(SubKey),
    m_ValueName(ValueName),
	m_Flags(Flags),
	m_DefaultValue(DefaultValue)
{
}

class CTimeDuration;

void CmInitialize(HKEY hKey, LPCWSTR RootKeyPath,REGSAM securityAccess);

//
// Fixed size
//
void CmQueryValue(const RegEntry& Entry, DWORD* pValue);
void CmQueryValue(const RegEntry& Entry, GUID* pValue);
void CmQueryValue(const RegEntry& Entry, CTimeDuration* pValue);


//
// Variable size, use "delete" to free
//
void CmQueryValue(const RegEntry& Entry, WCHAR** pValue);
void CmQueryValue(const RegEntry& Entry, BYTE** pValue, DWORD* pSize);


void CmSetValue(const RegEntry& Entry, DWORD Value);
void CmSetValue(const RegEntry& Entry, const CTimeDuration& Value);

void CmSetValue(const RegEntry& Entry, const GUID* pValue);
void CmSetValue(const RegEntry& Entry, const BYTE* pValue, DWORD Size);
void CmSetValue(const RegEntry& Entry, const WCHAR* pValue);

void CmDeleteValue(const RegEntry& Entry);
void CmDeleteKey(const RegEntry& Entry);

HKEY CmCreateKey(const RegEntry& Entry, REGSAM securityAccess);
HKEY CmOpenKey(const RegEntry& Entry, REGSAM securityAccess);
void CmCloseKey(HKEY hKey);

//
// Enum functions
//
bool CmEnumValue(HKEY hKey, DWORD Index, LPWSTR* ppValueName);

#endif // _MSMQ_Cm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\buffer.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    buffer.h

Abstract:
    Header for buffer classes that canact as  resizable array.
	Use it when ever you need buffer that needs resizing and also
	supplies low level access to it's memory.
	The implementation is based on std::vector. Unlike std::vector
	the size of the buffer is manualy reset by calling resize().
	This call will not invalidate any data in the buffer memory (like std::vector does)
	but just set a flag indicating the new size.
	A common use to it might be - reading data from the network. You reserver memory 
	calling reserve() , then read raw memory to the buffer, then increament 
	it size by calling resize().

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef BUFFER_H
#define BUFFER_H


//---------------------------------------------------------
//
//  CResizeBuffer class  -  resizable buffer class - the memory is heap allocated
//
//---------------------------------------------------------
template <class T>
class CResizeBuffer
{

typedef  std::vector<T>  BufferType;
typedef  typename BufferType::const_iterator const_iterator;
typedef  typename BufferType::iterator iterator;


public:
   	CResizeBuffer(
		size_t capacity
		):
		m_validlen(0),
		m_Buffer (capacity)	
		{
		}
	
	
	//
	// const start buffer position
	//
 	const_iterator begin() const
	{
		return m_Buffer.begin();
	}
   

	void append(const T& x)
	{
		size_t CurrentCapacity = capacity();
		if(CurrentCapacity == 	m_validlen)
		{
			reserve( (CurrentCapacity + 1)*2 );
		}
	  
		*(begin() + m_validlen ) = x;
		++m_validlen;
	}


	void append(const T* x, size_t len)
	{
		size_t CurrentCapacity = capacity();

		if(CurrentCapacity <  m_validlen +  len )
		{
			reserve( (CurrentCapacity + len)*2 );
		}

		//
		// Copy the data to the end of the buffer
		//
		std::copy(
			x,
			x + len,
			begin() +  m_validlen
			);

		m_validlen += len;
	}


    //
	// non const start buffer position
	// 
	iterator begin() 
	{
		return m_Buffer.begin();
	}

	
	//
	// const end buffer position
	//
 	const_iterator  end() const
	{
		return m_Buffer.begin() + size();
	}


	//
	// non const end buffer position
	//
 	iterator  end() 
	{
		return m_Buffer.begin() + size();
	}



	//
	// The buffer capacity (physical storage)
	//
	size_t capacity()const
	{
		return m_Buffer.size();
	} 

	//
	// Request to enlarge the buffer capacity - note we should resize() not reserve()
	// the internal vector because if realocation is needed the vector will copy
	// only size() elements.
	//
	void reserve(size_t newsize)
	{
		ASSERT(size() <= capacity());
		if(capacity() >=  newsize)
		{
			return;
		}
		m_Buffer.resize(newsize);
	}

	//
	// Set valid length value of the buffer
	// You can't set it to more then allocated (capacity())
	//
	void resize(size_t newsize)
	{
		ASSERT(size() <= capacity());
		ASSERT(newsize <= capacity());
		m_validlen = newsize;
	}

	//
	// free memory and resize to 0
	//
	void free()
	{
		//
		// This the only documented way to force deallocation of memory
		//
		BufferType().swap(m_Buffer);
		m_validlen = 0;
	}


	//
	// Get valid length of the buffer. 
	// 
	size_t size() const
	{
		return m_validlen;
	}

private:
	size_t  m_validlen; 
	std::vector<T>  m_Buffer;
};



//---------------------------------------------------------
//
//  CResizeBuffer class  -  resizable buffer class that starts  using pre allocated buffer.
//  during usage - it may switch to use dynamicly allocated buffer( if needed)
//
//---------------------------------------------------------
template <class T>
class CPreAllocatedResizeBuffer
{

typedef  std::vector<T>  BufferType;
typedef  typename BufferType::const_iterator const_iterator;
typedef  typename BufferType::iterator iterator;

public:
   	CPreAllocatedResizeBuffer(
		T* pStartBuffer, 
		size_t cbStartBuffer
		)
		:
		m_validlen(0),
		m_ResizeBuffer(0),
		m_pStartBuffer(pStartBuffer),
		m_cbStartBuffer(cbStartBuffer)
		{
		}
	
	
	//
	// const start buffer position
	//
 	const_iterator begin() const
	{
		return m_pStartBuffer ? m_pStartBuffer : m_ResizeBuffer.begin();	
	}
   



    //
	// non const start buffer position
	// 
	iterator begin() 
	{
		return m_pStartBuffer ? m_pStartBuffer : m_ResizeBuffer.begin();	
	}


	void append(const T& x)
	{
		if(m_pStartBuffer == NULL)
		{
			return m_ResizeBuffer.append(x);
		}

		if(m_cbStartBuffer == m_validlen)
		{
			reserve((m_cbStartBuffer +1)*2);
			return m_ResizeBuffer.append(x);
		}
		m_pStartBuffer[m_validlen++] = x;
	}

	
	void append(const T* x, size_t len)
	{
 		if(m_pStartBuffer == NULL)
		{
			return m_ResizeBuffer.append(x, len);
		}

		if(m_cbStartBuffer < m_validlen + len)
		{
			reserve((m_cbStartBuffer + len)*2);
			return m_ResizeBuffer.append(x, len);
		}

		std::copy(
			x,
			x + len,
			m_pStartBuffer +  m_validlen
		  );

		m_validlen += len;
	}


	
	//
	// const start buffer position
	//
 	const_iterator  end() const
	{
		return m_pStartBuffer ? m_pStartBuffer + m_validlen : m_ResizeBuffer.end();	
	}


	//
	// The buffer capacity (physical storage)
	//
	size_t capacity()const
	{
		return m_pStartBuffer ? m_cbStartBuffer : m_ResizeBuffer.capacity();
	} 

	//
	// Reserve memeory - if the requested reserver memory
	// could not fit into the start buffer - copy the start buffer
	// in to the dynamicly allocated buffer.
	//
	void reserve(size_t newsize)
	{
		if(m_pStartBuffer == NULL)
		{
			m_ResizeBuffer.reserve(newsize);
			return;
		}

		if(newsize <= capacity())
			return;
		
		//
		//copy the data from the pre allocated  buffer to dynamic buffer
		//from now on - we work only with dynamic data. 
		//
		m_ResizeBuffer.reserve(newsize);
		std::copy(
			m_pStartBuffer,
			m_pStartBuffer + m_validlen,
			m_ResizeBuffer.begin()
			);
		
		m_ResizeBuffer.resize(m_validlen);	
		m_pStartBuffer = NULL;			
	}


	//
	// Set valid length value of the buffer
	// You can't set it to more then  (capacity())
	//
	void resize(size_t newsize)
	{
		ASSERT(newsize <= capacity());
		if(m_pStartBuffer == NULL)
		{
			m_ResizeBuffer.resize(newsize);						
		}
		else
		{
			m_validlen = newsize;
		}
	}

	//
	// free memory and resize to 0
	//
	void free()
	{
		if(m_pStartBuffer != NULL)
		{
			m_validlen = 0;
			return;
		}
		m_ResizeBuffer.free();
	}


	//
	// Get valid length of the buffer. 
	// 
	size_t size() const
	{
		return m_pStartBuffer ? m_validlen : m_ResizeBuffer.size();	
	}


private:
	size_t  m_validlen; 
	CResizeBuffer<T> m_ResizeBuffer; 
	T* m_pStartBuffer;
	size_t m_cbStartBuffer;
};




//---------------------------------------------------------
//
//  CStaticResizeBuffer class  -  resizable buffer class that starts  with compile time buffer.
//  during usage - it may switch to use dynamicly allocated buffer( if needed).
//
//---------------------------------------------------------
template <class T, size_t N>
class CStaticResizeBuffer	: private CPreAllocatedResizeBuffer<T>
{
public:
	using CPreAllocatedResizeBuffer<T>::size;
	using CPreAllocatedResizeBuffer<T>::reserve;
	using CPreAllocatedResizeBuffer<T>::resize;
	using CPreAllocatedResizeBuffer<T>::capacity;
	using CPreAllocatedResizeBuffer<T>::begin;
	using CPreAllocatedResizeBuffer<T>::end;
	using CPreAllocatedResizeBuffer<T>::append;
	using CPreAllocatedResizeBuffer<T>::free;




public:
	CStaticResizeBuffer(
		void
		):
		CPreAllocatedResizeBuffer<T>(m_buffer, N)
		{
		}

	CPreAllocatedResizeBuffer<T>* get() 
	{
		return this;
	}
	
	const CPreAllocatedResizeBuffer<T>* get() const
	{
		return this;
	}

private:
	T m_buffer[N];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\cry.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Cry.h

Abstract:
    Cryptograph public interface

Author:
    Ilan Herbst (ilanh) 28-Feb-00

--*/

#pragma once

#ifndef _MSMQ_CRY_H_
#define _MSMQ_CRY_H_


#include <mqexception.h>


//-------------------------------------------------------------------
//
// Exception class bad_CryptoProvider
//
//-------------------------------------------------------------------
class bad_CryptoProvider : public bad_win32_error
{
    typedef bad_win32_error Inherited;

public:

    bad_CryptoProvider(ULONG error): Inherited(error) {}

}; // class bad_CryptoProvider


//-------------------------------------------------------------------
//
// Exception class bad_CryptoApi
//
//-------------------------------------------------------------------
class bad_CryptoApi : public bad_win32_error
{
    typedef bad_win32_error Inherited;

public:

    bad_CryptoApi(ULONG error): Inherited(error) {}

}; // class bad_CryptoApi


//---------------------------------------------------------
//
//  class CCryptKeyHandle
//
//---------------------------------------------------------
class CCryptKeyHandle {
public:
    CCryptKeyHandle(HCRYPTKEY h = 0) : m_h(h)  {}
   ~CCryptKeyHandle()               { if (m_h != 0) CryptDestroyKey(m_h); }

    HCRYPTKEY* operator &()         { return &m_h; }
    operator HCRYPTKEY() const      { return m_h; }
    HCRYPTKEY detach()              { HCRYPTKEY h = m_h; m_h = 0; return h; }

private:
    CCryptKeyHandle(const CCryptKeyHandle&);
    CCryptKeyHandle& operator=(const CCryptKeyHandle&);

private:
	HCRYPTKEY m_h;
};

//---------------------------------------------------------
//
//  class CCspHandle
//
//---------------------------------------------------------
class CCspHandle {
public:
    CCspHandle(HCRYPTPROV h = 0) : m_h(h)  {}
   ~CCspHandle()                    { if (m_h != 0) CryptReleaseContext(m_h,0); }

    HCRYPTPROV* operator &()        { return &m_h; }
    operator HCRYPTPROV() const     { return m_h; }
    HCRYPTPROV detach()             { HCRYPTPROV h = m_h; m_h = 0; return h; }

private:
    CCspHandle(const CCspHandle&);
    CCspHandle& operator=(const CCspHandle&);

private:
	HCRYPTPROV m_h;
};


//---------------------------------------------------------
//
//  class CHashHandle
//
//---------------------------------------------------------
class CHashHandle {
public:
    CHashHandle(HCRYPTHASH h = 0) : m_h(h)  {}
   ~CHashHandle()                    { if (m_h != 0) CryptDestroyHash(m_h); }

    HCRYPTHASH* operator &()        { return &m_h; }
    operator HCRYPTHASH() const     { return m_h; }
    HCRYPTHASH detach()             { HCRYPTHASH h = m_h; m_h = 0; return h; }

private:
    CHashHandle(const CHashHandle&);
    CHashHandle& operator=(const CHashHandle&);

private:
	HCRYPTHASH m_h;
};


VOID
CryInitialize(
    VOID
    );


HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR CspProvider
	);


HCRYPTKEY 
CryGenSessionKey(
	HCRYPTPROV hCsp
	);


HCRYPTKEY 
CryGetPublicKey(
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	);


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	);


void 
CryHashData(
	const BYTE *Buffer, 
	DWORD BufferLen, 
	HCRYPTHASH hHash
	);


BYTE* 
CryGetHashData(
	const HCRYPTHASH hHash,
	DWORD *HashValLen
	);


BYTE* 
CryCalcHash(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD *HashLen
	);


BYTE* 
CryCreateSignature(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	DWORD *SignLen
	);


BYTE* 
CryCreateSignature(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec,
	DWORD *SignLen
	);


bool 
CryValidateSignature(
	HCRYPTPROV hCsp,
	const BYTE* SignBuffer, 
	DWORD SignBufferLen, 
	const BYTE* Buffer,
	DWORD BufferLen,
	ALG_ID AlgId,
	HCRYPTKEY hKey
	);


void
CryGenRandom(
BYTE* pOutRandom,
DWORD len
);




#endif // _MSMQ_CRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\dld.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    dldt.h

Abstract:
    Delay Load Handler public interface

Author:
    conradc (conradc) 24-Apr-01

--*/

#pragma once

#ifndef _MSMQ_dld_H_
#define _MSMQ_dld_H_


VOID  DldInitialize();

#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYB_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },



extern const DLOAD_DLL_MAP g_DllMap;

#endif // _MSMQ_dld_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\dloaddef.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dloaddef.h

Abstract:

    This header defines the basic data types and macros needed to support
    building delay-load stubs to be linked into ker