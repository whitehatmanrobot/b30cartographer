&& (lDirection <= ControlItemConst::lNorthWest) )
	{
		rlValX = crControlItemDesc.DPAD.pRangeTable->lMinX;
	}
	//	Otherwise Centered w.r.t East-West
	else
	{
		//If max - min is an odd number we cheat the center to the high side(i.e. add back the remainder)
		rlValX 	= crControlItemDesc.DPAD.pRangeTable->lCenterX;
	}
	// Check North (North cannot do range, because NorthWest is not contiguous
	if( 
		(lDirection == ControlItemConst::lNorthEast) || 
		(lDirection == ControlItemConst::lNorth) || 
		(lDirection == ControlItemConst::lNorthWest)
	)
	{
		rlValY = crControlItemDesc.DPAD.pRangeTable->lMinY;
	}
	//	Check South
	else if( (lDirection >= ControlItemConst::lSouthEast) && (lDirection <= ControlItemConst::lSouthWest) )
	{
		rlValY = crControlItemDesc.DPAD.pRangeTable->lMaxY;
	}
	// Otherwsie Centered w.r.t North-South
	else
	{
		//If max - min is an odd number we cheat the center to the high side (i.e. add back the remainder)
		rlValY = crControlItemDesc.DPAD.pRangeTable->lCenterY;
	}

}

void ControlItemsFuncs::XY2Direction(LONG lValX, LONG lValY, LONG& rlDirection, const CONTROL_ITEM_DESC& crControlItemDesc)
{
	const ULONG localNorth	= 0x01;
	const ULONG localSouth	= 0x02;
	const ULONG localEast	= 0x04;
	const ULONG localWest	= 0x08;

	// Check North - North equals minimum Y value
	rlDirection = 0;
	if( crControlItemDesc.DPAD.pRangeTable->lNorth >= lValY )
	{
		rlDirection += localNorth;
	}
	//Check South - South equals maximum Y value
	else if( crControlItemDesc.DPAD.pRangeTable->lSouth <= lValY )
	{
		rlDirection += localSouth;
	}
	// Check East - East equals maximum X value
	if( crControlItemDesc.DPAD.pRangeTable->lEast <= lValX )
	{
		rlDirection += localEast;
	}
	//Check West - West equals minimum X value
	else if( crControlItemDesc.DPAD.pRangeTable->lWest >= lValX )
	{
		rlDirection += localWest;
	}

	//We have built a uniue value for each direction, but it is not what we need
	//use lookup table to convert to what we need
	static LONG DirectionLookUp[] =
	{
		ControlItemConst::lCenter,		// 0 = Nothing
		ControlItemConst::lNorth,		// 1 = localNorth 
		ControlItemConst::lSouth,		// 2 = localSouth
		ControlItemConst::lCenter,		// 3 = Not Possible with above code
		ControlItemConst::lEast,		// 4 = localEast
		ControlItemConst::lNorthEast,	// 5 = localNorth + localEast
		ControlItemConst::lSouthEast,	// 6 = localSouth + localEast
		ControlItemConst::lCenter,		// 7 = Not Possible with above code
		ControlItemConst::lWest,		// 8 = localWest
		ControlItemConst::lNorthWest,	// 9 = localNorth + localWest
		ControlItemConst::lSouthWest	// 10 = localSouth + localWest
	};
	rlDirection = DirectionLookUp[rlDirection];
}

NTSTATUS CAxesItem::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.Axes.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( FAILED(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinX < 0)
	{
		m_ItemState.Axes.lValX = SignExtend(m_ItemState.Axes.lValX, m_cpControlItemDesc->usBitSize);
	}

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.Axes.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinY < 0)
	{
		m_ItemState.Axes.lValY = SignExtend(m_ItemState.Axes.lValY, m_cpControlItemDesc->usBitSize);
	}
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CAxesItem::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
) const
{
	NTSTATUS NtStatus;

	// Clear the sign extension before writing
	ULONG ulX, ulY;
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinX < 0)
	{
		ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.Axes.lValX, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulX = static_cast<ULONG>(m_ItemState.Axes.lValX);
	}

	if (m_cpControlItemDesc->Axes.pRangeTable->lMinY < 0)
	{
		ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.Axes.lValY, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulY = static_cast<ULONG>(m_ItemState.Axes.lValY);
	}

	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
	
    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CDPADItem::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.DPAD.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//Sign extend it
	m_ItemState.DPAD.lValX = SignExtend(m_ItemState.DPAD.lValX, m_cpControlItemDesc->usBitSize);

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.DPAD.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	//Sign extend it
	m_ItemState.DPAD.lValY = SignExtend(m_ItemState.DPAD.lValY, m_cpControlItemDesc->usBitSize);
	return NtStatus;
}

NTSTATUS CDPADItem::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
) const
{
	NTSTATUS NtStatus;
	// Clear the sign extension before writing
	ULONG ulX, ulY;
	ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.DPAD.lValX, m_cpControlItemDesc->usBitSize));
	ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.DPAD.lValY, m_cpControlItemDesc->usBitSize));
	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
    
    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CPropDPADItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.PropDPAD.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//Sign extend it
	m_ItemState.PropDPAD.lValX = SignExtend(m_ItemState.PropDPAD.lValX, m_cpControlItemDesc->usBitSize);

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.PropDPAD.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	//Sign extend it
	m_ItemState.PropDPAD.lValY = SignExtend(m_ItemState.PropDPAD.lValY, m_cpControlItemDesc->usBitSize);

	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;

}
NTSTATUS CPropDPADItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	//Clear sign extension before writing
	ULONG ulX, ulY;
	ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.PropDPAD.lValX, m_cpControlItemDesc->usBitSize));
	ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.PropDPAD.lValY, m_cpControlItemDesc->usBitSize));
	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

BOOLEAN CPropDPADItem::GetModeSwitchFeaturePacket(BOOLEAN fDigital, UCHAR rguReport[2], PHIDP_PREPARSED_DATA pHidPreparsedData)
{
	if(m_fProgrammable)
	{
		PMODIFIER_ITEM_DESC pModifierDesc;
		ASSERT(m_cpControlItemDesc->pModifierDescTable->ulModifierCount > m_ucProgramModifierIndex);
		pModifierDesc = &m_cpControlItemDesc->pModifierDescTable->pModifierArray[m_ucProgramModifierIndex];
		
		rguReport[0] = pModifierDesc->ucReportId;
		rguReport[1] = NULL;
		NTSTATUS NtStatus;
		ULONG ulNumButtons = 1;
		if(fDigital)
		{
			NtStatus = HidP_SetButtons( 
					HidP_Feature,
					pModifierDesc->UsagePage,
					pModifierDesc->usLinkCollection,
					&pModifierDesc->Usage,
					&ulNumButtons,
					pHidPreparsedData,
					(char *)rguReport,
					2);
		}
		else
		{
			NtStatus = HidP_UnsetButtons( 
					HidP_Feature,
					pModifierDesc->UsagePage,
					pModifierDesc->usLinkCollection,
					&pModifierDesc->Usage,
					&ulNumButtons,
					pHidPreparsedData,
					(char *)rguReport,
					2);
			if(HIDP_STATUS_BUTTON_NOT_PRESSED == NtStatus)
			{
				NtStatus = HIDP_STATUS_SUCCESS;
			}
		}
		ASSERT(NT_SUCCESS(NtStatus));
		if( NT_ERROR(NtStatus) )
		{
			return FALSE;
		}
	}
	return m_fProgrammable;
}

/***********************************************************************************
**
**	CControlItemCollectionImpl::InitDigitalModeInfo
**
**	@mfunc	Initializes info regarding whether and how digital\proportional
**			information can be manipulated.
**
*************************************************************************************/
void CPropDPADItem::InitDigitalModeInfo()
{
	//Walk modifiers table looking for a proportional\digital mode switch
	//The first in the table should always be a bit in the input report
	//that indicates the state.  This is true of all proportional\digital
	//axes controls.  After that we look for a feature request that should
	//be at least writable.  If we find one, than we indicate that device programmable.
	PMODIFIER_DESC_TABLE pModifierDescTable = m_cpControlItemDesc->pModifierDescTable;
	PMODIFIER_ITEM_DESC pModifierItemDesc;
	ULONG ulModifierIndex;
	m_ucDigitalModifierBit = 0xff; //initialize to indicate none
	for(
		ulModifierIndex = pModifierDescTable->ulShiftButtonCount; //skip shift buttons
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeInput == pModifierItemDesc->ucReportType)
		)
		{
			if(ControlItemConst::HID_VENDOR_TILT_SENSOR == pModifierItemDesc->Usage)
			{
				m_ucDigitalModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
			if(ControlItemConst::HID_VENDOR_PROPDPAD_MODE == pModifierItemDesc->Usage)
			{
				m_ucDigitalModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
		}
	}
	m_fProgrammable = FALSE;
	m_ucProgramModifierIndex = 0xFF;
	//Now look for switching feature
	for(
		ulModifierIndex = 0;	//start at 0 index
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeFeature & pModifierItemDesc->ucReportType) &&
			(ControlItemConst::ucReportTypeWriteable & pModifierItemDesc->ucReportType) &&
			(ControlItemConst::HID_VENDOR_PROPDPAD_SWITCH == pModifierItemDesc->Usage)
		)
		{
			m_fProgrammable = TRUE;
			m_ucProgramModifierIndex = static_cast<UCHAR>(ulModifierIndex);
			break;
		}
	}
}

NTSTATUS CButtonsItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 15 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		//
		// Start with all buttons up
		//
		m_ItemState.Button.ulButtonBitArray = 0x0;
		if(ulNumUsages)
		{
			m_ItemState.Button.usButtonNumber = pUsages[0];
		}
		else
		{
			m_ItemState.Button.usButtonNumber = 0;
		}

		//
		//	Now that we have button info fill in the state information
		//
		for(ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			//
			//	Check Range and set bit of down buttons in range
			//
			if(
				(pUsages[ulIndex] >= m_cpControlItemDesc->Buttons.UsageMin) &&
				(pUsages[ulIndex] <= m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				//
				//	Set Bit in array
				//
				m_ItemState.Button.ulButtonBitArray |=
					(1 << (pUsages[ulIndex]-m_cpControlItemDesc->Buttons.UsageMin));
				//
				//	Update lowest number
				//
				if( m_ItemState.Button.usButtonNumber > pUsages[ulIndex] )
				{
					m_ItemState.Button.usButtonNumber = pUsages[ulIndex];
				}

			} //end of check if in range
		} //end of loop over buttons
	} //end of check for success
	
	return NtStatus;
}

NTSTATUS CButtonsItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	
	ULONG ulMaxUsages = 
		(m_cpControlItemDesc->Buttons.UsageMax -
		m_cpControlItemDesc->Buttons.UsageMin) + 1;

	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 10 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(10 >= ulMaxUsages && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[10];
		
	//
	//	Fill in array of usages
	//
	ULONG ulNextToFill=0;
	for(ULONG ulIndex = 0; ulIndex < ulMaxUsages; ulIndex++)
	{
		if( (1 << ulIndex) & m_ItemState.Button.ulButtonBitArray )
		{
			pUsages[ulNextToFill++] = static_cast<USAGE>(ulIndex + 
										m_cpControlItemDesc->Buttons.UsageMin);
		}
	}

	NtStatus = HidP_SetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNextToFill,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	
	return NtStatus;

}

//------------------------------------------------------------------
//	Implementation of CZoneIndicatorItem
//------------------------------------------------------------------
const ULONG CZoneIndicatorItem::X_ZONE = 0x00000001;
const ULONG CZoneIndicatorItem::Y_ZONE = 0x00000002;
const ULONG CZoneIndicatorItem::Z_ZONE = 0x00000004;

//
//	Read\Write to Report
//
NTSTATUS CZoneIndicatorItem::ReadFromReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value three was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from three to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(3 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[3];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

    ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		//
		// Start with no indicators set
		//
		m_ItemState.ZoneIndicators.ulZoneIndicatorBits = 0x0;
		
		//
		//	Now that we have button info fill in the state information
		//
		for(ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			//
			//	Set Bit in array
			//
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |=
				(1 << (pUsages[ulIndex]-m_cpControlItemDesc->ZoneIndicators.BaseIndicatorUsage));
		} //end of loop over buttons
	} //end of check for success
	
	return NtStatus;
}

NTSTATUS CZoneIndicatorItem::WriteToReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	) const
{
	NTSTATUS NtStatus;
	
	ULONG ulMaxUsages = m_cpControlItemDesc->usReportCount;

	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value three was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from three to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(3 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[3];
	
	//
	//	Fill in array of usages
	//
	ULONG ulNextToFill=0;
	for(ULONG ulIndex = 0; ulIndex < ulMaxUsages; ulIndex++)
	{
		if( (1 << ulIndex) & m_ItemState.ZoneIndicators.ulZoneIndicatorBits )
		{
			pUsages[ulNextToFill++] = static_cast<USAGE>(ulIndex +
										m_cpControlItemDesc->ZoneIndicators.BaseIndicatorUsage);
		}
	}

	NtStatus = HidP_SetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNextToFill,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	

	return NtStatus;

}



// **************** Implementation of DualZoneIndicator Item ******************* //
void CDualZoneIndicatorItem::SetActiveZone(LONG lZone)
{
	ASSERT((lZone >= 0) && (lZone <= m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones));

	if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[1] == 0)
	{
		ASSERT(m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones == 2);
		
		if (lZone == 1)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
		}
		else if (lZone == 2)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
		}
		else
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
		}
		return;
	}

	m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
	m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1];
	switch (lZone)
	{
		case 1:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
		case 2:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[1];
			break;
		case 3:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[1];
		case 4:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
			break;
		case 5:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
		case 6:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
			break;
		case 7:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
		case 8:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
			break;
	}
}

/*
USHORT g_FourByFourTileMaps[7] =
{
	0x0000,
	0x0011,
	0xFFFF,
	0x3377,
	0xFFC0,
	0xC000,
	0x3348
};

USHORT g_EightByEightTiles[16] =	// 4 Entries (4 bits each) - 4x4 array
{
	0x0000, 0x0103, 0x2222, 0x2222,
	0x0000, 0x1232, 0x2222, 0x2222,
	0x0103, 0x2222, 0x2245, 0x4500,
	0x1265, 0x4500, 0x0000, 0x0000
};

// Currently Fixed for 8 zones
LONG CDualZoneIndicatorItem::GetActiveZone()
{
	LONG lxReading = 0 - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	LONG lyReading = 0 - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;

	LONG lxHalfRange = m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lMaxX - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	LONG lyHalfRange = m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lMaxY - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;

	for (int n = 0; n < 2; n++)
	{
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] == HID_USAGE_GENERIC_X)
		{
			lxReading += m_ItemState.DualZoneIndicators.rglVal[n];
		}
		else
		{
			lyReading += m_ItemState.DualZoneIndicators.rglVal[n];
		}
	}

	// Translate to +/+ quadrant
	LONG lxTranslation = lxReading - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	if (lxTranslation < 0)
	{
		lxTranslation = 0 - lxTranslation;
	}
	LONG lyTranslation = lyReading - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;
	if (lyTranslation < 0)
	{
		lyTranslation = 0 - lyTranslation;
	}

	// What 32nd of the Quadrant am I in (512 << 5 fits fine in a ULONG)
	USHORT us32QuadrantX = USHORT(ULONG((ULONG(lxTranslation << 5) + lxHalfRange - 1)/lxHalfRange));
	USHORT us32QuadrantY = USHORT(ULONG((ULONG(lyTranslation << 5) + lyHalfRange - 1)/lxHalfRange));

	// What Eight of the Quadrant am I in?
	USHORT us8QuadrantX = us32QuadrantX >> 2;
	USHORT us8QuadrantY = us32QuadrantY >> 2;

	// What Quarter of the Quadrant am I in
	USHORT us4QuadrantX = us8QuadrantX >> 1;
	USHORT us4QuadrantY = us8QuadrantX >> 1;

	// Use the magic from above to find the pixel value
	USHORT usOctantValue = g_EightByEightTiles[us4QuadrantX + us8QuadrantY];	// x + 4*y
	USHORT usOctantNibble = (us8QuadrantX % 2) + ((us8QuadrantY % 2) << 1) * 4;
	USHORT usOctantNibbleValue = (usOctantValue & (0x0F << usOctantNibble)) >> usOctantNibble;
	USHORT usBit = g_FourByFourTileMaps[usOctantNibbleValue] & (1 << ((us32QuadrantX % 4) + ((us32QuadrantX % 4) << 2)));

	return usBit;
};
*/

inline BOOLEAN FirstSlopeGreater(LONG x1, LONG y1, LONG x2, LONG y2)
{
	return BOOLEAN((y1 * x2) > (y2 * x1));
}

inline BOOLEAN FirstSlopeLess(LONG x1, LONG y1, LONG x2, LONG y2)
{
	return BOOLEAN((y1 * x2) < (y2 * x1));
}

// Dansan's method (much simplier)
// Currently Fixed for 8 zones (or 2)
LONG CDualZoneIndicatorItem::GetActiveZone(SHORT sXDeadZone, SHORT sYDeadZone)
{
	// Get the two values (assume x/y or just x)
	LONG lxReading = m_ItemState.DualZoneIndicators.rglVal[0] - m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
	LONG lyReading = 0;
	if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[1] != 0)
	{	// Also flip Y about the axis
		lyReading = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1] - m_ItemState.DualZoneIndicators.rglVal[1];
	}
	else	// Single axis
	{
		if (lxReading < -sXDeadZone)
		{
			return 1;
		}
		if (lxReading > sXDeadZone)
		{
			return 2;
		}
		return 0;
	}

	// Rule out the center
	if (lxReading < sXDeadZone)
	{
		if (lxReading > -sXDeadZone)
		{
			if (lyReading < sYDeadZone)
			{
				if (lyReading > -sYDeadZone)
				{
					return 0;
				}
			}
		}
	}

	// First find the quadrant (++0 +-1 --2 -+3)
	UCHAR ucQuadrant = 0;
	if (lxReading >= 0)
	{
		ucQuadrant = (lyReading >= 0) ?  0 : 1;
	}
	else
	{
		ucQuadrant = (lyReading < 0) ? 2 : 3;
	}

	// Determine the reading based on the quadrant
	switch (ucQuadrant)
	{
		case 0:	// Slope goes from infinity to 0 (sectors 2,3,4)
			if (FirstSlopeGreater(lxReading, lyReading, c_lM1X, c_lM1Y))
			{
				return 2;
			}
			if (FirstSlopeLess(lxReading, lyReading, c_lM2X, c_lM2Y))
			{
				return 4;
			}
			return 3;
		case 1: // Slope goes from 0 to -infinity (sectors 4,5,6)
			if (FirstSlopeGreater(lxReading, lyReading, c_lM2X, -c_lM2Y))
			{
				return 4;
			}
			if (FirstSlopeLess(lxReading, lyReading, c_lM1X, -c_lM1Y))
			{
				return 6;
			}
			return 5;
		case 2:	// Slope goes from infinity to 0 (sectors 6,7,8)
			if (FirstSlopeGreater(lxReading, lyReading, -c_lM1X, -c_lM1Y))
			{
				return 6;
			}
			if (FirstSlopeLess(lxReading, lyReading, -c_lM2X, -c_lM2Y))
			{
				return 8;
			}
			return 7;
		case 3:	// Slope goes from 0 to -infinity (sectors 8,1,2)
			if (FirstSlopeGreater(lxReading, lyReading, -c_lM2X, c_lM2Y))
			{
				return 8;
			}
			if (FirstSlopeLess(lxReading, lyReading, -c_lM1X, c_lM1Y))
			{
				return 2;
			}
			return 1;
		default:
			ASSERT(FALSE);
			return 0;
	}
}

LONG CDualZoneIndicatorItem::GetActiveZone()
{
	return GetActiveZone(	SHORT(m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lDeadZone[0]), 
							SHORT(m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lDeadZone[1])
	);
}

//
//	Read\Write to Report
//
NTSTATUS CDualZoneIndicatorItem::ReadFromReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	)
{
	NTSTATUS NtStatus;

	//
	//	Read Data
	//
	for (int n = 0; n < 2; n++)
	{
		// Read if the item is valid
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] != 0)
		{
			NtStatus = HidP_GetUsageValue( 
					HidP_Input,
					m_cpControlItemDesc->UsagePage,
					m_cpControlItemDesc->usLinkCollection,
					m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n],
					reinterpret_cast<PULONG>(&m_ItemState.DualZoneIndicators.rglVal[n]),
					pHidPreparsedData,
					pcReport,
					lReportLength
					);

			if( FAILED(NtStatus) )
			{
				ASSERT( NT_SUCCESS(NtStatus) );
				return NtStatus;
			}

			//Sign extend it
			m_ItemState.DualZoneIndicators.rglVal[n] = SignExtend(m_ItemState.DualZoneIndicators.rglVal[n], m_cpControlItemDesc->usBitSize);
		}
		else
		{
			m_ItemState.DualZoneIndicators.rglVal[n] = 0;
		}
	}

	return NtStatus;
}

NTSTATUS CDualZoneIndicatorItem::WriteToReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	) const
{
	NTSTATUS NtStatus;

	for (int n = 0; n < 2; n++)
	{
		// Clear the sign extension before writing
		ULONG ulItem =
			static_cast<ULONG>(ClearSignExtension(m_ItemState.DualZoneIndicators.rglVal[n], m_cpControlItemDesc->usBitSize));

		//	Write Item if it is valid
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] != 0)
		{
			NtStatus = HidP_SetUsageValue( 
				HidP_Input,
				m_cpControlItemDesc->UsagePage,
				m_cpControlItemDesc->usLinkCollection,
				m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n],
				ulItem,
				pHidPreparsedData,
				pcReport,
				lReportLength
				);
    
			if( NT_ERROR(NtStatus) )
			{
				ASSERT( NT_SUCCESS(NtStatus) );
				return NtStatus;
			}
		}
	}

	return NtStatus;
}


		
NTSTATUS CGenericItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	//
	//	Read Value
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Generic.Usage,
			reinterpret_cast<PULONG>(&m_ItemState.Generic.lVal),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	//Sign extend it
	if(m_cpControlItemDesc->Generic.lMin < 0)
	{
		m_ItemState.Generic.lVal = SignExtend(m_ItemState.Generic.lVal, m_cpControlItemDesc->usBitSize);
	}
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}



/***********************************************************************************
**
**	CPedalItem::InitPedalPresentInfo
**
**	@mfunc	Initializes info how to read if pedals are present.
**
*************************************************************************************/
void	CPedalItem::InitPedalPresentInfo()
{
	//Walk modifiers table looking for a Pedals present switch
	//The first in the table should always be a bit in the input report
	//that indicates the state.  This is true of all proportional\digital
	//axes controls.  After that we look for a feature request that should
	//be at least writable.  If we find one, than we indicate that device programmable.
	PMODIFIER_DESC_TABLE pModifierDescTable = m_cpControlItemDesc->pModifierDescTable;
	PMODIFIER_ITEM_DESC pModifierItemDesc;
	ULONG ulModifierIndex;
	m_ucPedalsPresentModifierBit = 0xff; //initialize to indicate none
	for(
		ulModifierIndex = pModifierDescTable->ulShiftButtonCount; //skip shift buttons
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeInput == pModifierItemDesc->ucReportType)
		)
		{
			if(ControlItemConst::HID_VENDOR_PEDALS_PRESENT == pModifierItemDesc->Usage)
			{
				m_ucPedalsPresentModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
		}
	}
}

NTSTATUS CGenericItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	//Clear sign extension before writing
	ULONG ulVal;
	if(m_cpControlItemDesc->Generic.lMin < 0)
	{
		ulVal = static_cast<ULONG>(ClearSignExtension(m_ItemState.Generic.lVal, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulVal = m_ItemState.Generic.lVal;
	}
	//
	//	Write Value
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Generic.Usage,
			ulVal,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS ControlItemsFuncs::ReadModifiersFromReport
(
	  PMODIFIER_DESC_TABLE pModifierDescTable,
	  ULONG& rulModifiers,
	  PHIDP_PREPARSED_DATA pHidPPreparsedData,
	  PCHAR	pcReport,
	  LONG	lReportLength
)
{
    if (NULL == pModifierDescTable)
        return 42;
	CIC_DBG_RT_ENTRY_PRINT(("ControlItemsFuncs::ReadModifiersFromReport ModTable = 0x%0.8x\n", pModifierDescTable));
	NTSTATUS NtStatus = 0;
	rulModifiers = 0;

	//	A caveat here is that each entry must have usReportCount as large as the largest
	ULONG ulNumUsages = static_cast<ULONG>(pModifierDescTable->pModifierArray->usReportCount);
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all originally.  If this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from ten to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= pModifierDescTable->pModifierArray->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	USAGE UsageToGet;

	//	Loop over all the modifiers
	ULONG ulIndex=0;
	for(ulIndex = 0; ulIndex < pModifierDescTable->ulModifierCount; ulIndex++)
	{
		//
		//	Only try to read inputs
		//
		if( ControlItemConst::ucReportTypeInput != pModifierDescTable->pModifierArray[ulIndex].ucReportType)
		{ continue;	}

		UsageToGet = pModifierDescTable->pModifierArray[ulIndex].Usage;
		// The tilt sensor (legacy) is a special case, it has a digital value,
		// but is actually a two bit value and therefore we transform it.
		if( ControlItemConst::HID_VENDOR_TILT_SENSOR == UsageToGet)
		{
			ULONG ulValueToRead;
			NtStatus = HidP_GetUsageValue(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				UsageToGet,
				&ulValueToRead,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
			if( NT_ERROR(NtStatus) )
			{
				break;
			}
			//Set the bit appropriately
			if(ulValueToRead)
			{
				rulModifiers |= (1 << ulIndex);
			}
			else
			{
				rulModifiers &= ~(1 << ulIndex);
			}
			continue;
		}
				
		//Processing for all modifiers other than the Tilt Sensor continues here
		ulNumUsages = static_cast<ULONG>(pModifierDescTable->pModifierArray->usReportCount);
		NtStatus = HidP_GetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				pUsages,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_CRITICAL_PRINT(("HidP_GetButtons returned = 0x%0.8x\n", NtStatus));
			break;
		}

		//
		// Loop over usages returned
		//
		for(ULONG ulUsageIndex = 0; ulUsageIndex < ulNumUsages; ulUsageIndex++)
		{
			if( pUsages[ulUsageIndex] == UsageToGet )
			{
				rulModifiers |= (1 << ulIndex);
				break;
			}
		}
	}
	return NtStatus;
}

NTSTATUS ControlItemsFuncs::WriteModifiersToReport
(
	  PMODIFIER_DESC_TABLE pModifierDescTable,
	  ULONG ulModifiers,
	  PHIDP_PREPARSED_DATA pHidPPreparsedData,
	  PCHAR	pcReport,
	  LONG	lReportLength
)
{
    if (NULL == pModifierDescTable)
        return 42;
	NTSTATUS NtStatus = 0;
	
	ULONG ulNumUsages=1;
	USAGE UsageToSet;


	//
	//	Loop over all the modifiers
	//
	ULONG ulIndex=0;
	for(ulIndex = 0; ulIndex < pModifierDescTable->ulModifierCount; ulIndex++)
	{
		ulNumUsages = 1;
		UsageToSet = pModifierDescTable->pModifierArray[ulIndex].Usage;

		// The tilt sensor (legacy) is a special case, it has a digital value,
		// but is actually a two bit value and therefore we transform it.
		if( ControlItemConst::HID_VENDOR_TILT_SENSOR == UsageToSet)
		{
			ULONG ValueToWrite = (ulModifiers & (1 << ulIndex)) ? 2 : 0;
			NtStatus = HidP_SetUsageValue(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				UsageToSet,
				ValueToWrite,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
			if( NT_ERROR(NtStatus) )
			{
				break;
			}
			continue;
		}
		
		//	All modifiers beside the legacy tilt-sensor are one bit values
		if( ulModifiers	& (1 << ulIndex) )
		{
			//	Now set the binary value
			NtStatus = HidP_SetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				&UsageToSet,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		}
		else
		{
			//	Now set the binary value
			NtStatus = HidP_UnsetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				&UsageToSet,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		}
		if( NT_ERROR(NtStatus) )
		{
			break;
		}
	}
	return NtStatus;
}



NTSTATUS CForceMapItem::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CForceMapItem::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CProfileSelector::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 15 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);


	ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		for (int usageIndex = 0; usageIndex < (long)ulNumUsages; usageIndex++)
		{
			if (pUsages[usageIndex] >= m_cpControlItemDesc->ProfileSelectors.UsageButtonMin)
			{
				if (pUsages[usageIndex] <= m_cpControlItemDesc->ProfileSelectors.UsageButtonMax)
				{
					m_ItemState.ProfileSelector.lVal = pUsages[usageIndex] - m_cpControlItemDesc->ProfileSelectors.UsageButtonMin;
					if (m_cpControlItemDesc->ProfileSelectors.ulFirstProfile < m_cpControlItemDesc->ProfileSelectors.ulLastProfile)
					{
						m_ItemState.ProfileSelector.lVal += m_cpControlItemDesc->ProfileSelectors.ulFirstProfile;
					}
					else
					{
						m_ItemState.ProfileSelector.lVal = m_cpControlItemDesc->ProfileSelectors.ulFirstProfile - m_ItemState.ProfileSelector.lVal;
					}
					return NtStatus;
				}
			}
		}
	}
	
	return NtStatus;
}

NTSTATUS CProfileSelector::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CButtonLED::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	return HIDP_STATUS_SUCCESS;		// We really don't care what they look like
}

NTSTATUS CButtonLED::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitems.h ===
#ifndef __ControlItems_h__
#define __ControlItems_h__
//@doc
/**********************************************************************
*
*	@module	ControlItems.h	|
*
*	Declares basic structures for CControlItem and derived objects
*	that go in CControlItemCollections
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ControlItems	|
*	Control items represent a group of controls that share the same
*	HID UsagePage, Link-Collection, and are in a range of USAGES.
*
**********************************************************************/

namespace ControlItemConst
{
	//Device Item Types
    const USHORT usAxes              =  1;
    const USHORT usDPAD              =  2;
    const USHORT usPropDPAD          =  3;
    const USHORT usWheel             =  4;
    const USHORT usPOV               =  5;
    const USHORT usThrottle          =  6;
    const USHORT usRudder            =  7;
    const USHORT usPedal             =  8;
    const USHORT usButton            =  9;
    const USHORT usZoneIndicator     = 10;
    const USHORT usShiftedButton     = 11;
    const USHORT usForceMap          = 12;
	const USHORT usButtonLED         = 13;
    const USHORT usAxisToKeyMapModel = 14;
	const USHORT usProfileSelectors  = 15;
	const USHORT usDualZoneIndicator = 16;
	// To be used where there is more than one shift button
    // Reserve 255 of these: 0x101 Shift 1, 0x102 Shift 2, ..., 0x1ff Shift 255
    const USHORT usShiftedButtonN = 0x100;
    
	//DPAD and POV directions
	const LONG lCenter		= -1;
	const LONG lNorth		= 0;
	const LONG lNorthEast	= 1;
	const LONG lEast		= 2;
	const LONG lSouthEast	= 3;
	const LONG lSouth		= 4;
	const LONG lSouthWest	= 5;
	const LONG lWest		= 6;
	const LONG lNorthWest	= 7;

	//Report Types
	const UCHAR ucReportTypeReadable	= 0x80;
	const UCHAR ucReportTypeWriteable	= 0x40;
	const UCHAR ucReportTypeInput		= 0x01 | ucReportTypeReadable;
	const UCHAR ucReportTypeOutput		= 0x02 | ucReportTypeWriteable;
	const UCHAR ucReportTypeFeature		= 0x04;
	const UCHAR ucReportTypeFeatureRO	= ucReportTypeFeature | ucReportTypeReadable;
	const UCHAR ucReportTypeFeatureWO	= ucReportTypeFeature | ucReportTypeWriteable;
	const UCHAR ucReportTypeFeatureRW	= ucReportTypeFeature | ucReportTypeReadable | ucReportTypeWriteable;

	//Non-standard HID definitions
	const USHORT HID_VENDOR_PAGE			= 0xff01;
	const USHORT HID_VENDOR_TILT_SENSOR		= 0x0001; //legacy
	const USHORT HID_VENDOR_PROPDPAD_MODE	= 0x0030;
	const USHORT HID_VENDOR_PROPDPAD_SWITCH	= 0x0030;
	const USHORT HID_VENDOR_ZONE_INDICATOR_X= 0x0046;
	const USHORT HID_VENDOR_ZONE_INDICATOR_Y= 0x0047;
	const USHORT HID_VENDOR_ZONE_INDICATOR_Z= 0x0048;
	const USHORT HID_VENDOR_PEDALS_PRESENT	= 0x0049;

	// Behaviours of Button LEDS							-- Default Modes
	const UCHAR LED_DEFAULT_MODE_ON					= 0;	// On
	const UCHAR LED_DEFAULT_MODE_OFF				= 1;	// Off
	const UCHAR LED_DEFAULT_MODE_BLINK				= 2;	// Blinking
	const UCHAR LED_DEFAULT_MODE_CORRESPOND_ON		= 3;	// On if corresp. button has action (else off)
	const UCHAR LED_DEFAULT_MODE_CORRESPOND_OFF		= 4;	// Off if corresp. button has action (else on)
	const UCHAR LED_DEFAULT_MODE_BLINK_OFF			= 5;	// Blinking if c. button has action (else off)
	const UCHAR LED_DEFAULT_MODE_BLINK_ON			= 6;	// Blinking if c. button has action (else on)
};


#pragma pack(push ,foo, 1)
//
//	@struct MODIFIER_ITEM_DESC |
//		Contains all the data for reading a modifier button
//
struct MODIFIER_ITEM_DESC
{
	USAGE	UsagePage;			// @field Usage Page of Modifier Button
	USAGE	Usage;				// @field Usage of Modifier Button
	USHORT	usLinkCollection;	// @field Link Collection Modifier Button is in
	USAGE	LinkUsage;			// @field Usage of Link Collection Modifier Button is in
	USAGE	LinkUsagePage;		// @field Usage Page of Link Collection Modifier Button is in 
	USHORT	usReportCount;		// @field Report count of Buttons in same collection
	UCHAR	ucReportType;		// @field Report Type (Input\Feature(RO\WO\RW)\Output)
	UCHAR	ucReportId;			// @field Report ID for modifier
};
typedef MODIFIER_ITEM_DESC *PMODIFIER_ITEM_DESC;

struct MODIFIER_DESC_TABLE
{
	ULONG				ulModifierCount;
	ULONG				ulShiftButtonCount;
	PMODIFIER_ITEM_DESC pModifierArray;
};
typedef MODIFIER_DESC_TABLE *PMODIFIER_DESC_TABLE;

typedef struct tagAXES_RANGE_TABLE
{
	LONG	lMinX;						// @field Minimum value of X axis
	LONG	lCenterX;					// @field Center value for X
	LONG	lMaxX;						// @field Maximum value of X axis	
	LONG	lMinY;						// @field Minimum value of Y axis
	LONG	lCenterY;					// @field Center value for Y
	LONG	lMaxY;						// @field Maximum value of Y axis
	LONG	lNorth;						// @field Cut off for North
	LONG	lSouth;						// @field Cut off for South
	LONG	lWest;						// @field Cut off for West
	LONG	lEast;						// @field Cut off for East
} AXES_RANGE_TABLE, *PAXES_RANGE_TABLE;	

typedef struct tagDUALZONE_AXES_RANGE_TABLE
{
	LONG	lMin[2];					// @field Minimum value of each axis
	LONG	lCenter[2];					// @field Center value for each axis
	LONG	lMax[2];					// @field Maximum value of each axis	
	LONG	lDeadZone[2];				// @field DeadZone value of each axis
} DUALZONE_RANGE_TABLE, *PDUALZONE_RANGE_TABLE;	

//
// @struct 	RAW_CONTROL_ITEM_DESC |
//	This first raw structure is good for declaring tables, it contains all the information
//	an object needs to know about it self statically.
//
struct RAW_CONTROL_ITEM_DESC
{
	ULONG					ulItemIndex;		// @field Index of item in collection
	USHORT					usType;				// @field Type of item (type defined in ControlItemConst namespace)
	USAGE					UsagePage;			// @field Usage Page of Item
	USHORT					usLinkCollection;	// @field Link of collection item is in  
	USAGE					LinkUsage;			// @field Usage of link collection item is in
	USAGE					LinkUsagePage;		// @field Usage PAge of link collection item is in
	USHORT					usBitSize;			// @field Number of bits item occupies in report
	USHORT					usReportCount;		// @field Number of count of items if array (or buttons)
	PMODIFIER_DESC_TABLE	pModifierDescTable;	// @field Points to modifier descriptor table
	USAGE					SubItemUsage1;		// @field Interpretation depends on usType
	USAGE					SubItemUsage2;		// @field Interpretation depends on usType
	LONG					lSubItemMin1;		// @field Interpretation depends on usType
	LONG					lSubItemMax1;		// @field Interpretation depends on usType
};
typedef RAW_CONTROL_ITEM_DESC *PRAW_CONTROL_ITEM_DESC;

//
//	@struct CONTROL_ITEM_DESC |
//	Same as RawControlItemDesc but uses Union to give better names to the SubItem fields.
//
struct CONTROL_ITEM_DESC
{
	ULONG					ulItemIndex;		// @field Index of item in collection
	USHORT					usType;				// @field Type of item (type defined in ControlItemConst namespace)
	USAGE					UsagePage;			// @field Usage Page of Item
	USHORT					usLinkCollection;	// @field Link of collection item is in  
	USAGE					LinkUsage;			// @field Usage of link collection item is in
	USAGE					LinkUsagePage;		// @field Usage Page of link collection item is in
	USHORT					usBitSize;			// @field Number of bits item occupies in report
	USHORT					usReportCount;		// @field Number of count of items if array (or buttons)
	PMODIFIER_DESC_TABLE	pModifierDescTable;	// @field Points to modifier descriptor table
	union
	{
		struct
		{
			USAGE	UsageX;						// @field Usage of X axis
			USAGE	UsageY;						// @field Usage of Y axis
			PAXES_RANGE_TABLE pRangeTable;		// @field Pointer to range table
			LONG	lReserved2;					// @field Placeholder to match other structs in union
		}	Axes, DPAD, PropDPAD;
		struct
		{
			USAGE	Usage;						// @field Usage of item
			USHORT	usSubIndex;					// @field If item is in array(usReportCount > 1), holds the index
			LONG	lMin;						// @field Minimum value of usage
			LONG	lMax;						// @field Maximum value of usage
		}	Generic, Wheel, POV, Throttle, Rudder, Pedal;
		struct
		{
			USAGE	UsageMin;					// @field Usage of minimum buton
			USAGE	UsageMax;					// @field Usage of maximum buton
			LONG	lReserved1;					// @field Placeholder to match other structs in union
			LONG	lReserved2;					// @field Placeholder to match other structs in union
		}	Buttons;
		struct
		{
			USAGE	BaseIndicatorUsage;			// @field Base Usage for Zone indicators	
			USAGE	ReservedUsage;				// @field Placeholder to match other structs in union
			ULONG	ulAxesBitField;				// @field Bit field showing which indicators are available. X is bit 0
			LONG	lReserved1;					// @field Placeholder to match other structs in union
		} ZoneIndicators;
		struct
		{
			USAGE	rgUsageAxis[2];						// @field Usage of the two axis
			PDUALZONE_RANGE_TABLE pZoneRangeTable;		// @field Pointer to range table
			LONG	lNumberOfZones;						// @field How many zones does this divide into
		} DualZoneIndicators;
        struct
        {
            USAGE   Usage;                      // @field Usage
            UCHAR   bMapYToX;                   // @field Bool value 
            USHORT  usRTC;                      // @field return to center force (0-10000)
            USHORT  usGain;                     // @field gain for the device
            UCHAR   ucReserved;                 // @field Placeholder to match other structs in union
        } ForceMap;
		struct
		{
			USAGE	UsageMinLED;				// @field Usage of lowest LED (they better be consecutive)
			UCHAR	ucReportType;				// @field Report Type LED is in (Input\Feature(RO\WO\RW)\Output)
			UCHAR	ucReportId;					// @field Report ID for LED
			UCHAR	ucCorrespondingButtonItem;	// @field What button item does this refer to?
			UCHAR	ucDefaultMode;				// @field Defaullt LED behaviour (see ControlItemConst)
			UCHAR	ucReserved;					// @field Reserved (should be 0)
			ULONG	ulReserved;					// @field Reserved (should be 0)
		} ButtonLEDs;
		struct
		{
			USAGE	UsageButtonMin;				// @field Usage of first button for selector
			USAGE	UsageButtonMax;				// @field Usage of last button for selector
			ULONG	ulFirstProfile;				// @field What profile does the min select
			ULONG	ulLastProfile;				// @field What profile does the max select
		} ProfileSelectors;
	};
};
typedef CONTROL_ITEM_DESC *PCONTROL_ITEM_DESC;

//
//	@struct CONTROL_ITEM_XFER |
//	Used to transfer states between device item objects in different collections - input to outputs.
//	Used to represent in the state of items in Actions, and to idendity the trigger element for an action.
//
struct CONTROL_ITEM_XFER
{
	ULONG	ulItemIndex;
	union
	{
		struct
		{
			LONG	lValX;
			LONG	lValY;
		} Axes, DPAD, PropDPAD;
		struct
		{
			LONG	rglVal[2];
		} DualZoneIndicators;
		struct
		{
			LONG	lVal;
		} Generic, Wheel, POV, Throttle, Rudder, Pedal, ProfileSelector;
		struct
		{
			USHORT	usButtonNumber;
			ULONG	ulButtonBitArray;
		} Button;
		struct
		{
			ULONG ulZoneIndicatorBits;
		}	ZoneIndicators;
		struct
		{
			UCHAR ucModifierByte;
			UCHAR rgucKeysDown[6];
		} Keyboard;
        struct
        {
            ULONG  bMapYToX : 1;
            ULONG  usRTC : 15; 
            ULONG  usGain: 15;
            ULONG  Reserved : 1;
        } ForceMap;
		struct
		{
			ULONG dwValue;	// In milliseconds
		} Delay;
		struct
		{
			ULONG dwMouseButtons;	// Bit field
		} MouseButtons;
	};
	ULONG ulModifiers;

#ifdef __cplusplus
	bool operator==(const CONTROL_ITEM_XFER& rhs)
	{
		// Are we even the same type
		if (ulItemIndex != rhs.ulItemIndex)
		{
			return false;
		}
		return ((Axes.lValX == rhs.Axes.lValX) && (Axes.lValY == rhs.Axes.lValY) && (ulModifiers == rhs.ulModifiers));
	}

	bool operator!=(const CONTROL_ITEM_XFER& rhs)
	{
		if (ulItemIndex != rhs.ulItemIndex)
		{
			return true;
		}
		return ((Axes.lValX != rhs.Axes.lValX) || (Axes.lValY != rhs.Axes.lValY) || (ulModifiers != rhs.ulModifiers));
	}
#endif __cplusplus
};

typedef CONTROL_ITEM_XFER *PCONTROL_ITEM_XFER;

#pragma pack(pop , foo)

#ifdef COMPILE_FOR_WDM_KERNEL_MODE
	namespace NonGameDeviceXfer
	{
		const ULONG c_ulMaxXFerKeys = 6;

		// Non game device XFers
		const ULONG ulKeyboardIndex = 0xFFFF0000;
		const ULONG ulMouseIndex = 0xFFFF0001;
		const ULONG ulDelayIndex = 0xFFFF0002;

		// Checks for non device xfer types
		inline BOOLEAN IsKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulKeyboardIndex);
		}
		inline BOOLEAN IsMouseXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulMouseIndex);
		}
		inline BOOLEAN IsDelayXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulDelayIndex);
		}
	};
#else
	#include "ieevents.h"	// For IE_KEYEVENT definition
	namespace NonGameDeviceXfer
	{
		const ULONG c_ulMaxXFerKeys = 6;
		const ULONG ulKeyboardIndex = 0xFFFF0000;
		const ULONG ulMouseIndex = 0xFFFF0001;
		const ULONG ulDelayIndex = 0xFFFF0002;

		inline BOOLEAN IsKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulKeyboardIndex);
		}
		inline BOOLEAN IsMouseXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulMouseIndex);
		}
		inline BOOLEAN IsDelayXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulDelayIndex);
		}

		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, ULONG ulScanCodeCount, const USHORT* pusScanCodes);
		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent);
		void AddScanCodeToXfer(CONTROL_ITEM_XFER& rControlItemXfer, WORD wScanCode);
		void ScanCodesFromKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer, ULONG& rulScanCodeCount, USHORT* pusScanCodes);
		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent);

		void MakeDelayXfer(CONTROL_ITEM_XFER& rControlItemXfer, DWORD dwDelay);
	};
#endif

namespace ControlItemsFuncs
{
	void Direction2XY(
		LONG&	rlValX,
		LONG&	rlValY,
		LONG	lDirection,
		const CONTROL_ITEM_DESC& crControlItemDesc
		);
	void XY2Direction(
		LONG	lValX,
		LONG	lValY,
		LONG&	rlDirection,
		const CONTROL_ITEM_DESC& crControlItemDesc
		);
	NTSTATUS ReadModifiersFromReport(
		PMODIFIER_DESC_TABLE pModifierDescTable,
		ULONG& rulModifiers,
		PHIDP_PREPARSED_DATA pHidPPreparsedData,
		PCHAR	pcReport,
		LONG	lReportLength
		);
	NTSTATUS WriteModifiersToReport(
		PMODIFIER_DESC_TABLE pModifierDescTable,
		ULONG rulModifiers,
		PHIDP_PREPARSED_DATA pHidPPreparsedData,
		PCHAR	pcReport,
		LONG	lReportLength
		);

};


/******************************************************************************/
/**	@class CControlItem |
/**	Base class for containing information about a control or group of controls
/** on a device
/******************************************************************************/
class CControlItem
{
	public:
		
		/**********************************************************************
		**
		**	CControlItem::CControlItem
		**
		**	@cmember c'tor initialize with pointer to table describing item
		**
		***********************************************************************/
		CControlItem() : m_ulFirstDwordMask(0), m_ulSecondDwordMask(0)
		{
			memset(&m_ItemState, 0, sizeof(CONTROL_ITEM_XFER));
		}

		/**********************************************************************
		**
		**	virtual CControlItem::~CControlItem
		**
		**	@cmember c'tor initialize with pointer to table describing item
		**
		***********************************************************************/
		virtual ~CControlItem(){}
		
		/***********************************************************************
		**
		**	inline USHORT CControlItem::GetType() const
		**
		**	@cmember Returns the type of the item. See ControlItemConst namespace
		**			 for constants representing the type
		***********************************************************************/
		inline USHORT CControlItem::GetType() const
		{
			return m_cpControlItemDesc->usType;
		}


		/***********************************************************************
		**
		**	inline void CControlItem::GetItemState
		**
		**	@cmember Returns the item state in a CONTROL_ITEM_XFER packet
		**
		***********************************************************************/
		inline void GetItemState
		(
			CONTROL_ITEM_XFER& rControlItemXfer	// @parm [out] state of device
		) const
		{
			rControlItemXfer = m_ItemState;
		}		

		/************************************************************************
		**
		**	inline BOOLEAN CControlItem::SetItemState
		**
		**	@cmember	Set the control items state from a CONTROL_ITEM_XFER.
		**
		**	@rdesc	TRUE if successful,
		**			FALSE if CONTROL_ITEM_XFER is not intended for item.
		**
		*************************************************************************/
		inline BOOLEAN SetItemState
		(
			const CONTROL_ITEM_XFER& crControlItemXfer	// @parm [in] const reference to CONTROL_ITEM_XFER
		)
		{
			if(m_ItemState.ulItemIndex != crControlItemXfer.ulItemIndex)
			{
				return FALSE;
			}
			
			//Copy the data
			m_ItemState.Axes.lValX &= m_ulFirstDwordMask;
			m_ItemState.Axes.lValX |= crControlItemXfer.Axes.lValX;
			m_ItemState.Axes.lValY &= m_ulSecondDwordMask;
			m_ItemState.Axes.lValY |= crControlItemXfer.Axes.lValY;
			m_ItemState.ulModifiers = crControlItemXfer.ulModifiers;
				 
			return TRUE;
		}
		
		virtual void SetDefaultState()=0;

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetNumModifiers
		**
		**	@cmember Gets the number of modifiers available.
		**
		*****************************************************************************/
		inline ULONG GetNumModifiers() const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				return 0;
			}
			return m_cpControlItemDesc->pModifierDescTable->ulModifierCount;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetNumShiftButtons
		**
		**	@cmember Gets the number of modifiers available.
		**
		*****************************************************************************/
		inline ULONG GetNumShiftButtons() const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				return 0;
			}
			return m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetShiftButtonUsage
		**
		**	@cmember Gets the usage (bit array index) of the specified shift button
		**
		*****************************************************************************/
		inline USHORT GetShiftButtonUsage
		(
			USHORT uShiftButtonIndex	// @parm [in] Zero-based index of shift button
		) const
		{
			if ((m_cpControlItemDesc->pModifierDescTable == NULL) || (uShiftButtonIndex >= m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount))
			{
				return 0;
			}

			return m_cpControlItemDesc->pModifierDescTable->pModifierArray[uShiftButtonIndex].Usage;
		}
			
		/*****************************************************************************
		**
		**	inline void CControlItem::GetModifiers(ULONG& rulModifiers)
		**
		**	@cmember	Gets modifier bit array of item state.
		**
		******************************************************************************/
		inline void GetModifiers
		(
			ULONG& rulModifiers	// @parm [out] Bit Array showing state of modifiers
		) const
		{
			rulModifiers = m_ItemState.ulModifiers;
		}

		/*****************************************************************************
		**
		**	inline void CControlItem::GetShiftButtons(ULONG& rulShiftButtons)
		**
		**	@cmember	Gets Shift buttons from the modifier bit array of item state.
		**
		******************************************************************************/
		inline void GetShiftButtons
		(
			ULONG& rulShiftButtons	// @parm [out] Bit Array showing state of modifiers
		) const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				rulShiftButtons = 0;
			}
			else
			{
				ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
				rulShiftButtons = m_ItemState.ulModifiers & ulMask;
			}
			return;
		}


		/*****************************************************************************
		**
		**	inline void CControlItem::SetModifiers(ULONG ulModifiers)
		**
		**	@cmember	Set state modifier flags from bit array
		**
		******************************************************************************/
		inline void SetModifiers
		(
			ULONG ulModifiers	// @parm [in] Bit array showing state of modifiers
		)
		{
			m_ItemState.ulModifiers = ulModifiers;
		}

		/*****************************************************************************
		**
		**	inline void CControlItem::SetShiftButtons(ULONG ulShiftButtons)
		**
		**	@cmember	Gets Shift buttons from the modifier bit array of item state.
		**
		******************************************************************************/
		inline void SetShiftButtons
		(
			ULONG ulShiftButtons	// @parm [out] Bit Array showing state of modifiers
		)
		{
			if (m_cpControlItemDesc->pModifierDescTable != NULL)
			{
				ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
				m_ItemState.ulModifiers = (ulShiftButtons & ulMask) | (m_ItemState.ulModifiers & ~ulMask);
			}
			return;
		}

		//
		//	Read\Write to Report
		//
		virtual NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA,
			PCHAR,
			LONG
			)
		{
			//
			//	Should always be overridden
			//
			ASSERT(FALSE);
			return E_FAIL;
		}
		virtual NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA,
			PCHAR,
			LONG
			) const
		{
			//
			//	Should always be overridden
			//
			ASSERT(FALSE);
			return E_FAIL;
		}

		virtual void SetStateOverlayMode(BOOLEAN){}
		
	protected:

		//@cmember Pointer to entry in table describing item
		const CONTROL_ITEM_DESC *m_cpControlItemDesc;	
		
		//
		//	State of item
		//
		//@cmember State of item
		CONTROL_ITEM_XFER m_ItemState;	
		//@cmember Oring mask for overlay flag
		ULONG	m_ulFirstDwordMask;
		ULONG	m_ulSecondDwordMask;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CControlItem& operator =(const CControlItem& rControlItem);
};

/******************************************************************************/
/**	@class CAxesItem |
/**	Derived from CControlItem represents Axes of device
******************************************************************************/
class CAxesItem : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CAxesItem::CAxesItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes does nothing
		**
		*************************************************************************************/
		CAxesItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.Axes.lValX = m_cpControlItemDesc->Axes.pRangeTable->lCenterX;
			m_ItemState.Axes.lValY= m_cpControlItemDesc->Axes.pRangeTable->lCenterY	;
			m_ItemState.ulModifiers = 0;
		}
		
		virtual BOOLEAN IsDefaultState()
		{
			if(
					m_ItemState.Axes.lValX == m_cpControlItemDesc->Axes.pRangeTable->lCenterX &&
					m_ItemState.Axes.lValY == m_cpControlItemDesc->Axes.pRangeTable->lCenterY
			){
				return TRUE;
			}
			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::SetXY(ULONG lValX, ULONG lValY)
		**
		**	@cmember	Sets the X and Y states of the axes
		**
		*************************************************************************************/
		inline void SetXY
		(
			LONG lValX,	// @parm [in] Position of X axis
			LONG lValY	// @parm [in] Position of Y axis
		)
		{
			m_ItemState.Axes.lValX = lValX;
			m_ItemState.Axes.lValY = lValY;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::GetXY(ULONG& rlValX, ULONG& rlValY) const
		**
		**	@cmember	Get the X and Y states of the device
		**
		*************************************************************************************/
		inline void GetXY
		(
			LONG& rlValX,	// @parm [out] X value of axis
			LONG& rlValY	// @parm [out] Y value of axis 
		) const
		{
			rlValX = m_ItemState.Axes.lValX;
			rlValY = m_ItemState.Axes.lValY;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::GetXYRange(LONG& rlMinX,	LONG& rlMaxX, LONG& rlMinY,	LONG& rlMaxY) const
		**
		**	@cmember	Get the minimum and maximum values for X and Y
		**
		*************************************************************************************/
		inline void GetXYRange
		(
			LONG& rlMinX,	// @parm [out] Minimum value X can attain
			LONG& rlMaxX,	// @parm [out] Maximum value X can attain
			LONG& rlMinY,	// @parm [out] Minimum value Y can attain
			LONG& rlMaxY	// @parm [out] Maximum value Y can attain
		) const
		{
			rlMinX = m_cpControlItemDesc->Axes.pRangeTable->lMinX;
			rlMaxX = m_cpControlItemDesc->Axes.pRangeTable->lMaxX;
			rlMinY = m_cpControlItemDesc->Axes.pRangeTable->lMinY;
			rlMaxY = m_cpControlItemDesc->Axes.pRangeTable->lMaxY;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:

		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CAxesItem& operator =(const CAxesItem& rAxesItem);
};


/******************************************************************************/
/**	@class CDPADItem |
/**	Derived from CControlItem represents DPAD of device
******************************************************************************/
class CDPADItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CDPADItem::CDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes DPAD to center
		**
		*************************************************************************************/
		CDPADItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.DPAD.lValX = m_cpControlItemDesc->DPAD.pRangeTable->lCenterX;
			m_ItemState.DPAD.lValY= m_cpControlItemDesc->DPAD.pRangeTable->lCenterY;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			LONG lDirection;
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
			if(ControlItemConst::lCenter == lDirection)
			{
				return TRUE;
			}
			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CDPADItem::SetDirection(LONG lDirection)
		**
		**	@cmember	Sets Direction of Item
		**
		*************************************************************************************/
		inline void SetDirection
		(
			LONG lDirection	// @parm [in] Direction to set
		)
		{
			ControlItemsFuncs::Direction2XY
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
		}

		/***********************************************************************************
		**
		**	inline void CDPADItem::GetDirection(LONG& rlDirection)
		**
		**	@cmember	Get Direction of DPAD item
		**
		*************************************************************************************/
		inline void GetDirection
		(
			LONG& rlDirection	// @parm [out] Direction of DPAD item
		) const
		{
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				rlDirection, 
				*m_cpControlItemDesc
			);
		}
		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

	private:
		
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CDPADItem& operator =(const CDPADItem& rDPADItem);

};

/******************************************************************************/
/**	@class CPropDPADItem |
/**	Derived from CControlItem represents DPAD of device
******************************************************************************/
class CPropDPADItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CDPADItem::CPropDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes PropDPAD to center
		**
		*************************************************************************************/
		CPropDPADItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			//Get PropDPAD switch Info
			InitDigitalModeInfo();

			SetDefaultState();
		}
		
		virtual void SetDefaultState()
		{
			m_ItemState.PropDPAD.lValX = m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterX;
			m_ItemState.PropDPAD.lValY= m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterY	;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(IsDigitalMode())
			{
				LONG lDirection;
				ControlItemsFuncs::XY2Direction
				(
					m_ItemState.PropDPAD.lValX,
					m_ItemState.PropDPAD.lValY,
					lDirection, 
					*m_cpControlItemDesc
				);
				if(ControlItemConst::lCenter == lDirection)
				{
					return TRUE;
				}
			}
			else
			{
				if(
					m_ItemState.PropDPAD.lValX == m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterX &&
					m_ItemState.PropDPAD.lValY == m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterY
				)	return TRUE;
			}

			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetDigitalMode()
		**
		**	@cmember	Sets the packet to indicate digital mode
		**
		*************************************************************************************/
		inline void CPropDPADItem::SetDigitalMode()
		{
			m_ItemState.ulModifiers |= (1 << m_ucDigitalModifierBit);
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetProportionalMode()
		**
		**	@cmember	Sets the packet to indicate proportional mode
		**
		*************************************************************************************/
		inline void CPropDPADItem::SetProportionalMode()
		{
			m_ItemState.ulModifiers &= ~(1 << m_ucDigitalModifierBit);
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CPropDPADItem::IsDigitalMode()
		**
		**	@cmember Determines if th internal state is digital or proportional
		**	@rdesc TRUE if in digital mode, false if in proportional mode
		**
		*************************************************************************************/
		inline BOOLEAN CPropDPADItem::IsDigitalMode()
		{
			return (m_ItemState.ulModifiers & (1 << m_ucDigitalModifierBit)) ? TRUE : FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetXY(ULONG lValX, ULONG lValY)
		**
		**	@cmember	Sets the X and Y states of the axes
		**
		*************************************************************************************/
		inline void SetXY
		(
			LONG lValX,	// @parm [in] Position of X axis
			LONG lValY	// @parm [in] Position of Y axis
		)
		{
			m_ItemState.PropDPAD.lValX = lValX;
			m_ItemState.PropDPAD.lValY = lValY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetXY(ULONG& rlValX, ULONG& rlValY)
		**
		**	@cmember	Get the X and Y states of the device
		**
		*************************************************************************************/
		inline void GetXY
		(
			LONG& rlValX,	// @parm [out] X value of axis
			LONG& rlValY	// @parm [out] Y value of axis 
		) const
		{
			rlValX = m_ItemState.PropDPAD.lValX;
			rlValY = m_ItemState.PropDPAD.lValY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetXYRange(LONG& rlMinX,	LONG& rlMaxX, LONG& rlMinY,	LONG& rlMaxY) const
		**
		**	@cmember	Get the minimum and maximum values for X and Y
		**
		*************************************************************************************/
		inline void GetXYRange
		(
			LONG& rlMinX,	// @parm [out] Minimum value X can attain
			LONG& rlMaxX,	// @parm [out] Maximum value X can attain
			LONG& rlMinY,	// @parm [out] Minimum value Y can attain
			LONG& rlMaxY	// @parm [out] Maximum value Y can attain
		) const
		{
			rlMinX = m_cpControlItemDesc->PropDPAD.pRangeTable->lMinX;
			rlMaxX = m_cpControlItemDesc->PropDPAD.pRangeTable->lMaxX;
			rlMinY = m_cpControlItemDesc->PropDPAD.pRangeTable->lMinY;
			rlMaxY = m_cpControlItemDesc->PropDPAD.pRangeTable->lMaxY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetDirection(LONG lDirection)
		**
		**	@cmember	Sets Direction of Item
		**
		*************************************************************************************/
		inline void SetDirection
		(
			LONG lDirection	// @parm [in] Direction to set
		)
		{
			ControlItemsFuncs::Direction2XY
			(
				m_ItemState.PropDPAD.lValX,
				m_ItemState.PropDPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetDirection(LONG& rlDirection)
		**
		**	@cmember	Get Direction of PropDPAD item
		**
		*************************************************************************************/
		inline void GetDirection
		(
			LONG& rlDirection	// @parm [out] Direction of PropDPAD item
		) const
		{
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.PropDPAD.lValX,
				m_ItemState.PropDPAD.lValY,
				rlDirection, 
				*m_cpControlItemDesc
			);
		}

	 	//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

		
		//	Init Digital Mode Info
		void InitDigitalModeInfo();
		BOOLEAN GetModeSwitchFeaturePacket(BOOLEAN fDigital, UCHAR rguReport[2], PHIDP_PREPARSED_DATA pHidPreparsedData);
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPropDPADItem& operator =(const CPropDPADItem& rPropDPADItem);
		UCHAR	m_ucDigitalModifierBit;	//Bit in ulModifiers that identifies the State of the switch
	protected:
		BOOLEAN	m_fProgrammable;		//Means that SetFeature/GetFeature can be used
		UCHAR	m_ucProgramModifierIndex; //Index in Modifier table that describes feature for setting mode
};

/******************************************************************************/
/**	@class CButtonsItem |
/**	Derived from CControlItem represents group of buttons on device
******************************************************************************/
class CButtonsItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CButtonsItem::CButtonsItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes all buttons up
		**
		*************************************************************************************/
		CButtonsItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.Button.usButtonNumber = 0;
			m_ItemState.Button.ulButtonBitArray = 0x00000000;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(!m_ItemState.Button.usButtonNumber && !m_ItemState.Button.ulButtonBitArray)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline USHORT	CButtonsItem::GetButtonMin()
		**
		**	@cmember	Gets the minimum button number
		**
		**	@rdesc	Number of the minimum button
		**
		*************************************************************************************/
		inline USHORT GetButtonMin() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->Buttons.UsageMin); 
		}

		/***********************************************************************************
		**
		**	inline USHORT CButtonsItem::GetButtonMax()
		**
		**	@cmember	Gets the maximum button number
		**
		**	@rdesc	Number of the maximum button
		**
		*************************************************************************************/
		inline USHORT GetButtonMax() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->Buttons.UsageMax);
		}

		/***********************************************************************************
		**
		**	inline void CButtonsItem::GetButtons(USHORT usButtonNum, ULONG ulButtonBitArray)
		**
		**	@cmember	Returns the Button Number and BitArray - these are really independent
		**			a client may use either field.  As an Action trigger the button number
		**			is used, as part of an Action Event the bit-array is used
		**			Reading from a packet sets the bitarray and the button number as the lowest
		**			button pressed.  The Bitarray is biased by the minimum usage.
		**			Writing to a report uses the BitArray and ignores the button number.
		**
		*************************************************************************************/
		inline void GetButtons
		(
			USHORT& rusButtonNumber,	// @parm [out] Button number that is down
			ULONG& rulButtonBitArray		// @parm [out] BitArray of Buttons that are down
		) const
		{
			rusButtonNumber		= m_ItemState.Button.usButtonNumber;
			rulButtonBitArray	= m_ItemState.Button.ulButtonBitArray;
		}

		inline BOOLEAN IsButtonDown(USHORT usButtonNumber) const
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				ASSERT(FALSE);
				return FALSE;
			}

			//
			//	Return state
			//
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			return (m_ItemState.Button.ulButtonBitArray & (1 << usBitPos)) ? TRUE : FALSE;
		}

		inline NTSTATUS SetButton(USHORT usButtonNumber)
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				return E_INVALIDARG;
			}
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			m_ItemState.Button.ulButtonBitArray |= (1 << usBitPos);
			m_ItemState.Button.usButtonNumber = usButtonNumber;
			return S_OK;
		}

		inline NTSTATUS ClearButton(USHORT usButtonNumber)
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				return E_INVALIDARG;
			}
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			m_ItemState.Button.ulButtonBitArray &= ~(1 << usBitPos);
			return S_OK;
		}
		/***********************************************************************************
		**
		**	inline void CButtonsItem::SetButtons(USHORT usButtonNum, ULONG ulButtonBitArray)
		**
		**	@cmember	Set the Button Number and BitArray - these are really independent
		**			a client may use either field.  As an Action trigger the button number
		**			is used, as part of an Action Event the bit-array is used
		**			Reading from a report sets the bitarray and the button number as the lowest
		**			button pressed.  The Bitarray is biased by the minimum usage.
		**			Writing to a report uses the BitArray and ignores the button number.
		**
		*************************************************************************************/
		inline void SetButtons
		(
			USHORT usButtonNumber,	// @parm [in] Button number that is down
			ULONG ulButtonBitArray	// @parm [in] BitArray of Buttons that are down
		)
		{
			m_ItemState.Button.usButtonNumber = usButtonNumber;
			m_ItemState.Button.ulButtonBitArray = ulButtonBitArray;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
		virtual void SetStateOverlayMode(BOOLEAN fEnable)
		{
			if(fEnable)
			{
				m_ulFirstDwordMask = 0xFFFF0000;
				m_ulSecondDwordMask = 0x0000FFFF;
			}
			else
			{
				m_ulFirstDwordMask = 0;
				m_ulSecondDwordMask = 0;
			}
			return;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CButtonsItem& operator =(const CButtonsItem& rButtonsItem);
};

/******************************************************************************/
/**	@class CGenericItem |
/**	Derived from CControlItem represents generic control on device -
/** base class for POV, Throttle, Wheel, Pedals, etc.
******************************************************************************/

class CGenericItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CGenericItem::CGenericItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	default c'tor
		**
		*************************************************************************************/
		CGenericItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		
		}

		virtual void SetDefaultState()
		{
				m_ItemState.Generic.lVal = m_cpControlItemDesc->Generic.lMin;
				m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(m_ItemState.Generic.lVal == m_cpControlItemDesc->Generic.lMin)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline void CGenericItem::GetValue(LONG& rlVal)
		**
		**	@cmember	Gets value of item
		**
		*************************************************************************************/
		inline void GetValue
		(
			LONG& rlVal	// @parm [out] Value of control item
		) const
		{
			rlVal = m_ItemState.Generic.lVal;	
		}

		/***********************************************************************************
		**
		**	inline void CGenericItem::SetValue(LONG& rlVal)
		**
		**	@cmember	Sets value of item
		**
		*************************************************************************************/
		inline void SetValue
		(
			LONG lVal // @parm [in] Value of control item
		)
		{
			m_ItemState.Generic.lVal = lVal;	
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetRange(LONG& rlMin, LONG& rlMax) const
		**
		**	@cmember	Get the minimum and maximum values
		**
		*************************************************************************************/
		inline void GetRange
		(
			LONG& rlMin,	// @parm [out] Minimum value
			LONG& rlMax		// @parm [out] Maximum value
		) const
		{
			rlMin = m_cpControlItemDesc->Generic.lMin;
			rlMax = m_cpControlItemDesc->Generic.lMax;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CGenericItem& operator =(const CGenericItem& rGenericItem);
};

/******************************************************************************/
/**	@class CPOVItem |
/**	Derived from CGenericItem represents POV control on device
******************************************************************************/
class CPOVItem : public CGenericItem
{
	public:
		CPOVItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}


		virtual void SetDefaultState()
		{
				m_ItemState.Generic.lVal = -1;
		}
		virtual BOOLEAN IsDefaultState()
		{
			//POV is centered if not within range, which is the default
			LONG lMin, lMax;
			GetRange(lMin, lMax);
			if(m_ItemState.Generic.lVal >  lMax || m_ItemState.Generic.lVal < lMin)
			{
				return TRUE;
			}
			return FALSE;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPOVItem& operator =(const CPOVItem& rPOVItem);
};

/******************************************************************************/
/**	@class CThrottleItem |
/**	Derived from CGenericItem represents Throttle control on device
******************************************************************************/
class CThrottleItem : public CGenericItem
{
	public:
		CThrottleItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CThrottleItem& operator =(const CThrottleItem& rThrottleItem);
};

/******************************************************************************/
/**	@class CRudderItem |
/**	Derived from CGenericItem represents rudder control on device
******************************************************************************/
class CRudderItem : public CGenericItem
{
	public:
		CRudderItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CRudderItem& operator =(const CRudderItem& rRudderItem);
};

/******************************************************************************/
/**	@class CWheelItem |
/**	Derived from CGenericItem represents Wheel control on device
******************************************************************************/
class CWheelItem : public CGenericItem
{
	public:
		CWheelItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc)
		{
			SetDefaultState();
		}
			
		virtual void SetDefaultState()
		{
				LONG lCenter = (m_cpControlItemDesc->Generic.lMin + m_cpControlItemDesc->Generic.lMax)/2;
				m_ItemState.Generic.lVal = lCenter;
				m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			LONG lCenter = (m_cpControlItemDesc->Generic.lMin + m_cpControlItemDesc->Generic.lMax)/2;
			if(m_ItemState.Generic.lVal == lCenter)
			{
				return TRUE;
			}
			return FALSE;
		}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CWheelItem& operator =(const CWheelItem& rWheelItem);
};

/******************************************************************************/
/**	@class CPedalItem |
/**	Derived from CGenericItem represents Pedal control on device
******************************************************************************/
class CPedalItem : public CGenericItem
{
	public:
		CPedalItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc), m_ucPedalsPresentModifierBit(0xFF)
		{
			//Setup m_ucPedalsPresentModifierBit
			InitPedalPresentInfo();
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			if (IsYAxis())
			{
				m_ItemState.Generic.lVal = m_cpControlItemDesc->Generic.lMax;
			}
			else
			{
				m_ItemState.Generic.lVal = (m_cpControlItemDesc->Generic.lMax + m_cpControlItemDesc->Generic.lMin)/2;
			}
			m_ItemState.ulModifiers = 1 << m_ucPedalsPresentModifierBit;
		}

		virtual BOOLEAN IsDefaultState()
		{
			long int lDefault;
			if (IsYAxis())
			{
				lDefault = m_cpControlItemDesc->Generic.lMax;
			}
			else
			{
				lDefault = (m_cpControlItemDesc->Generic.lMax + m_cpControlItemDesc->Generic.lMin)/2;
			}

			if(m_ItemState.Generic.lVal == lDefault)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		void InitPedalPresentInfo();
		inline BOOLEAN ArePedalsRemovable()
		{
			return (0xFF == m_ucPedalsPresentModifierBit) ? FALSE : TRUE;
		}
		inline BOOLEAN ArePedalsPresent()
		{
			return (m_ItemState.ulModifiers & (1 << m_ucPedalsPresentModifierBit)) ? TRUE : FALSE;
		}
		inline BOOLEAN IsYAxis()
		{
			return (HID_USAGE_GENERIC_Y == m_cpControlItemDesc->Pedal.Usage) ? TRUE : FALSE;
		}
		inline BOOLEAN IsRZAxis()
		{
			return (HID_USAGE_GENERIC_RZ == m_cpControlItemDesc->Pedal.Usage) ? TRUE : FALSE;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPedalItem& operator =(const CPedalItem& rPedalItem);
		UCHAR	m_ucPedalsPresentModifierBit;
};

/******************************************************************************/
/**	@class CZoneIndicatorItem |
/**	A zone indicator is a binary hid usage that indicates that an axis
/** on the hardware has moved into a particular zone.
******************************************************************************/
class CZoneIndicatorItem : public virtual CControlItem
{
	public:
		
		/***********************************************************************************
		**
		**	CZoneIndicatorItem::CZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes all buttons up
		**
		*************************************************************************************/
		CZoneIndicatorItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits = 0x00000000;
			m_ItemState.ulModifiers = 0;
		}
		virtual BOOLEAN IsDefaultState()
		{
			if(!m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasXIndicator() const
		**
		**	@cmember	If this zone indicator group has X returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasXIndicator() const
		{
			if( CZoneIndicatorItem::X_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasYIndicator() const
		**
		**	@cmember	If this zone indicator group has Y returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasYIndicator() const
		{
			if( CZoneIndicatorItem::Y_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasZIndicator() const
		**
		**	@cmember	If this zone indicator group has Z returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasZIndicator() const
		{
			if( CZoneIndicatorItem::Z_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetXIndicator() const
		**
		**	@cmember	If the pointer is in the X zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetXIndicator() const
		{
			ASSERT(HasXIndicator());
			if( CZoneIndicatorItem::X_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetYIndicator() const
		**
		**	@cmember	If the pointer is in the Y zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetYIndicator() const
		{
			ASSERT(HasYIndicator());
			if( CZoneIndicatorItem::Y_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetZIndicator() const
		**
		**	@cmember	If the pointer is in the Z zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetZIndicator() const
		{
			ASSERT(HasZIndicator());
			if( CZoneIndicatorItem::Z_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetXIndicator()
		**
		**	@cmember	Sets to indicate X is in the zone
		**
		*************************************************************************************/
		inline void SetXIndicator()
		{
			ASSERT(HasXIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::X_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetYIndicator()
		**
		**	@cmember	Sets to indicate Y is in the zone
		**
		*************************************************************************************/
		inline void SetYIndicator()
		{
			ASSERT(HasYIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::Y_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetZIndicator()
		**
		**	@cmember	Sets to indicate Z is in the zone
		**
		*************************************************************************************/
		inline void SetZIndicator()
		{
			ASSERT(HasZIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::Z_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearXIndicator()
		**
		**	@cmember	Sets to indicate X is not in the zone
		**
		*************************************************************************************/
		inline void ClearXIndicator()
		{
			ASSERT(HasXIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::X_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearYIndicator()
		**
		**	@cmember	Sets to indicate Y is not in the zone
		**
		*************************************************************************************/
		inline void ClearYIndicator()
		{
			ASSERT(HasYIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::Y_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearZIndicator()
		**
		**	@cmember	Sets to indicate Z is not in the zone
		**
		*************************************************************************************/
		inline void ClearZIndicator()
		{
			ASSERT(HasZIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::Z_ZONE;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CZoneIndicatorItem& operator =(const CZoneIndicatorItem& rZoneIndicatorItem);

	public:
		static const ULONG X_ZONE;
		static const ULONG Y_ZONE;
		static const ULONG Z_ZONE;
};

/******************************************************************************/
/**	@class CDualZoneIndicatorItem |
/**	A dual zone indicator is an item that indicate movement into a particular section
/** of a two axis plane.
******************************************************************************/
class CDualZoneIndicatorItem : public virtual CControlItem
{
	public:
		/***********************************************************************************
		**
		**	CDualZoneIndicatorItem::CDualZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes item to default state (center)
		**
		*************************************************************************************/
		CDualZoneIndicatorItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1];
			m_ItemState.ulModifiers = 0;

		}
		virtual BOOLEAN IsDefaultState()
		{
			for (int n = 0; n < 2; n++)
			{
				if (m_ItemState.DualZoneIndicators.rglVal[n] != m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[n])
				{
					return FALSE;
				}
			}
			return TRUE;
		}

		void SetActiveZone(LONG lZone);
		void SetActiveZone(LONG posOne, LONG posTwo)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = posOne;
			m_ItemState.DualZoneIndicators.rglVal[1] = posTwo;
		}

		LONG GetActiveZone();
		LONG GetActiveZone(SHORT sXDeadZone, SHORT sYDeadZone);

        LONG GetNumZones ()
        {
            return m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones;
        }

		BOOLEAN IsXYIndicator()
		{
			return BOOLEAN(m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[0] == HID_USAGE_GENERIC_X);
		}

		BOOLEAN IsRzIndicator()
		{
			return (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[0] == HID_USAGE_GENERIC_RZ);
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		CDualZoneIndicatorItem& operator =(const CDualZoneIndicatorItem& rDualZoneIndicatorItem);
};


/******************************************************************************/
/**	@class CForceMapItem |
/**	Derived from CGenericItem represents the Wheel force feedback control on device
******************************************************************************/
class CForceMapItem : public CGenericItem
{
    public:
        CForceMapItem
            (
            const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
            )	: CGenericItem(cpControlItemDesc)
        {
            SetDefaultState();
        }
    
        virtual void SetDefaultState()
        {
            m_ItemState.ForceMap.bMapYToX = m_cpControlItemDesc->ForceMap.bMapYToX;
            m_ItemState.ForceMap.usRTC    = m_cpControlItemDesc->ForceMap.usRTC;
            m_ItemState.ForceMap.usGain   = m_cpControlItemDesc->ForceMap.usGain;
            m_ItemState.ulModifiers = 0;
        }
    
        virtual BOOLEAN IsDefaultState()
        {
            if (m_ItemState.ForceMap.bMapYToX == m_cpControlItemDesc->ForceMap.bMapYToX  &&
                m_ItemState.ForceMap.usRTC    == m_cpControlItemDesc->ForceMap.usRTC     &&
                m_ItemState.ForceMap.usGain   == m_cpControlItemDesc->ForceMap.usGain)
            {
                return TRUE;
            }
            return FALSE;
        }
        
        void SetMapYtoX (BOOLEAN a_bMapYToX)
        {
            m_ItemState.ForceMap.bMapYToX = a_bMapYToX ? 0x1 : 0x0;
        }
        
        void SetRTC  (USHORT a_usRTC)
        {
            m_ItemState.ForceMap.usRTC    = a_usRTC & 0x7fff;
        }

        void SetGain (USHORT a_usGain)
        {
            m_ItemState.ForceMap.usGain   = a_usGain & 0x7fff;
        }

        BOOLEAN GetMapYToX ()
        {
            return m_ItemState.ForceMap.bMapYToX;
        }
        
        USHORT GetRTC  ()
        {
            return m_ItemState.ForceMap.usRTC;
        }

        USHORT GetGain ()
        {
            return m_ItemState.ForceMap.usGain;
        }
        
		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

    private:
        //
        //	Dissallow use of assignment operator. (Do not define - it will cause a link error if
        //	anyone tries to use it.
        //
        CForceMapItem& operator =(const CForceMapItem& rWheelItem);
};

/******************************************************************************/
/**	@class CProfileSelector |
/**	Derived from CControlItem represents group of buttons on profile selector buttons
******************************************************************************/
class CProfileSelector  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CProfileSelector::CProfileSelector(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes selector to 0
		**
		*************************************************************************************/
		CProfileSelector
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.ProfileSelector.lVal = m_cpControlItemDesc->ProfileSelectors.ulFirstProfile;
		}

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE; // there is no such thing
		}

		inline void GetSelectedProfile
		(
			UCHAR& rucSelectedProfile		// @parm [out] Current selected profile (Slider Location)
		) const
		{
			rucSelectedProfile = UCHAR(m_ItemState.ProfileSelector.lVal);
		}

		inline void SetSelectedProfile
		(
			UCHAR ucSelectedProfile		// @parm [out] Current selected profile (Slider Location)
		)
		{
			m_ItemState.ProfileSelector.lVal = ucSelectedProfile;
		}

		/***********************************************************************************
		**
		**	inline USHORT	CProfileSelectorsItem::GetProfileSelectorMin()
		**
		**	@cmember	Gets the minimum button number for profile selector
		**
		**	@rdesc	Number of the minimum button
		**
		*************************************************************************************/
		inline USHORT GetProfileSelectorMin() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->ProfileSelectors.UsageButtonMin); 
		}

		/***********************************************************************************
		**
		**	inline USHORT CProfileSelectorsItem::GetProfileSelectorMax()
		**
		**	@cmember	Gets the maximum button number for profile selector
		**
		**	@rdesc	Number of the maximum button
		**
		*************************************************************************************/
		inline USHORT GetProfileSelectorMax() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->ProfileSelectors.UsageButtonMax);
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CProfileSelector& operator =(const CProfileSelector& rProfileSelectorItem);
};

/******************************************************************************/
/**	@class CButtonLED |
/**	Derived from CControlItem represents group of LEDs the encircle buttons
******************************************************************************/
class CButtonLED  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CButtonLED::CButtonLED(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes selector to 0
		**
		*************************************************************************************/
		CButtonLED
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			// Nothing to do here really
		}

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE; // there is no such thing
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CButtonLED& operator =(const CButtonLED& rCButtonLED);
};


//NEWDEVICE

#endif __ControlItems_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitemcollection.h ===
#ifndef __ControlItemCollection_h__
#define __ControlItemCollection_h__
//@doc
/*********************************************************************
*
*	@module	ControlItemCollection.h	|
*
*	Declares the ControlItemCollection class and related classes
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CControlItemCollection	|
*	The ControlItemCollection class is a templatized class used for
*	representing the controls on a device.  The depends on the client
*	using the class are non-trivial and therefore the following sections
*	should be read carefully.<nl>
*
*	@topic Items in ControlItemCollection |
*	<c CControlItem> is the base class for all of the items in the collection.
*	X and Y axes on a joystick like device use <c XAxesItem>, DPAD uses
*	<c CDPADItem>, a proportional DPAD (as on Zorro, and also use for Tilt)
*	uses <c CPropDPADItem>, Buttons use the class <c CButtonsItem>, Throttle
*	uses <c CThrottleItem>, a Rudder uses <c CRudderItem>, etc.  All of there
*	class are derived virtually from <c CControlITem>.<nl>
*
*	@topic Custom Base class for <c CControlItem> |
*	The class was designed so that a client may create a custom base class.
*	To declare a collection of <c CMyBaseClass>, derive it *virtually*
*	from CControlItem.  Then derive each of the classes created by your factory
*	from the appropriate control specific derivative and from <c CMyBaseClass>.
*	For example, <c CMyButtonsItems> would be derived from <c CButtonsItems> and
*	<c CMyBaseClass>.  When creating the collection specify <c CMyBaseClass> in
*	template specifier for CControlItemCollection.<nl>
*
*
*********************************************************************/

//
//	Warning 4250 notifies you that some virtual functions are inherited via
//	dominance (See a good C++ text on virtual base classes).  This warning
//	would be generated by client code if they use scheme described above
//	for a custom base class for controls.
//
#pragma warning( disable : 4250 )

#include "ListAsArray.h"
#include "ControlItems.h"

//
//	@struct DEVICE_CONTROLS_DESC | Describes a paritcular device in terms
//	of its VidPid, it CONTROL_ITEM_DESC and it MODIFIER_DESC_TABLE.
//
struct DEVICE_CONTROLS_DESC
{
	ULONG					ulVidPid;				//@field VID in high word and PID in low
	ULONG					ulControlItemCount;		//@field Number of control descriptors
	RAW_CONTROL_ITEM_DESC	*pControlItems;			//@field Array of control descriptors
	MODIFIER_DESC_TABLE		*pModifierDescTable;	//@field Pointer to modifier descriptor table
};
typedef DEVICE_CONTROLS_DESC *PDEVICE_CONTROLS_DESC;

//
// This table is assumed to be linked in.
//
extern DEVICE_CONTROLS_DESC DeviceControlsDescList[]; 

typedef	HRESULT (*PFNGENERICFACTORY)
		(
			USHORT						usType,
			const CONTROL_ITEM_DESC*	cpControlItemDesc,
			PVOID						*ppControlItem
		);

typedef CControlItem *(*PFNGETCONTROLITEM)(PVOID);

typedef void (*PFNGENERICDELETEFUNC)(PVOID pItem);

//
//	@class | Implementation of CControlItemCollection
//
class CControlItemCollectionImpl
{	
	public:
		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, takes preparsed data and a factory to generate classes
		//
		CControlItemCollectionImpl():m_ulMaxXfers(0), m_ulModifiers(0){}

		HRESULT Init(
			ULONG			  ulVidPid,				//@parm [in] Vid in the high word, Pid in the low word
			PFNGENERICFACTORY pfnFactory,			//@parm	[in] pointer to function which acts
													//			on pFactoryHandle
			PFNGENERICDELETEFUNC pfnDeleteFunc		//@parm [in] delete function to used for control items
		);

		//
		//	@method | CControlItemCollection | GetFirst  |
		//	Returns next control item in collection. If *pulCookie=0 on entry , returns first object.
		//	@rdesc TRUE on success, FALSE if no more items in collection
		//
		HRESULT GetNext(
			PVOID *ppControlItem,	//@parm	[out] Next control item in collection
			ULONG& rulCookie		//@parm [in\out] Cookie to continue enumeration
			) const;
		//
		//	@method | CControlItemCollection | GetFromControlItemXfer |
		//	Given a ControlItemXfer gets the corresponding control item from the collection.
		//	@rdesc Pointer to item, or NULL if not found
		PVOID GetFromControlItemXfer(
			const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] report selector to get object for
			);

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength,
			PFNGETCONTROLITEM	GetControlFromPt
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength,
			PFNGETCONTROLITEM	GetControlFromPtr
			) const;

		//
		//	Functions dealing with internal state
		//
		inline ULONG GetMaxXferRequired() const
		{
			return m_ulMaxXfers;
		}
		
		void SetDefaultState( 
			PFNGETCONTROLITEM	GetControlFromPtr
			);

		HRESULT GetState( 
			ULONG& ulXferCount,
			PCONTROL_ITEM_XFER pControlItemXfers,
			PFNGETCONTROLITEM	GetControlFromPtr
		);
		
		HRESULT SetState( 
			ULONG				ulXferCount,
			PCONTROL_ITEM_XFER	pControlItemXfers,
			PFNGETCONTROLITEM	GetControlFromPtr
		);

		void SetStateOverlayMode(
			PFNGETCONTROLITEM	GetControlFromPtr,
			BOOLEAN fEnable
			);
		
		
		inline ULONG GetModifiers() const
		{
			return m_ulModifiers;
		}
		
		inline void SetModifiers(ULONG ulModifiers)
		{
			m_ulModifiers = ulModifiers;
		}

	private:
		CListAsArray		m_ObjectList;
		ULONG				m_ulDeviceIndex;
		ULONG				m_ulModifiers;
		ULONG				m_ulMaxXfers;
};


//	@class	CControlItemCollection	|
//			An instance of this class contains a list of control item objects which represent
//			the controls on the device.  The numbers and types of objects depend
//			not only the configuration of the device (obtained through the VidPid and a lookup table
//			- passed in the c'tor), but also on the CControlItemFactory which pairs
//			each control item with an object.
//	@tcarg class | T | Custom base class for control items to store in collection.

template<class T>
class CControlItemCollection
{
	public:
		typedef HRESULT (*PFNFACTORY)
		(
			USHORT						usType,
			const CONTROL_ITEM_DESC*	cpControlItemDesc,
			T							**ppDeviceUsage							
		);

		typedef void (*PFNDELETEFUNC)(T *pItem);
		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, takes a VidPid and a factory to generate classes
		//
		CControlItemCollection(
			ULONG			ulVidPid,			//@parm [in] Vid in the high word, Pid in the low word
			PFNFACTORY		pfnFactory,			//@parm [in] pointer to factory method for control item objects
			PFNDELETEFUNC	pfnDeleteFunc=NULL	//@parm [in] pointer to function for deleting the objects
		)
		{
			if(!pfnDeleteFunc)
			{
				pfnDeleteFunc = DefaultDeleteFunc;
			}
			//
			// Init implementation
			//
			collectionImpl.Init(
				ulVidPid,
				reinterpret_cast<PFNGENERICFACTORY>(pfnFactory),
				reinterpret_cast<PFNGENERICDELETEFUNC>(pfnDeleteFunc)
			);
		}

		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, which takes no parameters, much call init before using!
		//
		CControlItemCollection() : collectionImpl() {};

		//
		//	@method | CControlItemCollection | Init |
		//	Must call after the default constructor, does the collection initialization
		//
		HRESULT Init(
			ULONG			ulVidPid,			//@parm [in] Vid in the high word, Pid in the low word
			PFNFACTORY		pfnFactory,			//@parm [in] pointer to factory method for control item objects
			PFNDELETEFUNC	pfnDeleteFunc=NULL	//@parm [in] pointer to function for deleting the objects
		)
		{
			if(!pfnDeleteFunc)
			{
				pfnDeleteFunc = DefaultDeleteFunc;
			}
			//
			// Init implementation
			//
			return collectionImpl.Init(
				ulVidPid,
				reinterpret_cast<PFNGENERICFACTORY>(pfnFactory),
				reinterpret_cast<PFNGENERICDELETEFUNC>(pfnDeleteFunc)
			);
		}


		//
		//	@method | CControlItemCollection | GetFirst  |
		//	Returns next control item in the collection. If *pulCookie=0 on entry , returns first object.
		//	@rdesc TRUE on success, FALSE if no more objects in collection
		//
		inline HRESULT GetNext(
			T **ppControlItem,	//@parm	[out] Next control item object in collection
			ULONG& rulCookie	//@parm [in\out] Cookie to continue enumeration
			) const
		{
			//
			//	Defer to implementation
			//
			return collectionImpl.GetNext( reinterpret_cast<PVOID *>(ppControlItem), rulCookie );
		}
	
		//
		//	@method | CControlItemCollection | GetFromControlItemXfer |
		//	Given a ControlItemXfer gets the corresponding control item object from the collection.
		//	@rdesc Pointer to Control Item, or NULL if not found.
		inline T *GetFromControlItemXfer(
			const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] ControlItemXfer to get control item object for
		)
		{
			//
			//	Defer to implementation
			//
			return reinterpret_cast<T *>(collectionImpl.GetFromControlItemXfer(crControlItemXfer));
		};

		static CControlItem *GetControlFromPtr(PVOID pvItem)
		{
			return static_cast<CControlItem *>(reinterpret_cast<T *>(pvItem));
		}

		static void DefaultDeleteFunc(T *pItem)
		{
			delete pItem;
		}

		//
		//	Read\Write to Report
		//
		inline NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
		{
			return collectionImpl.ReadFromReport(
										pHidPPreparsedData,
										pcReport,
										lReportLength,
										&GetControlFromPtr
										);
		}
		inline NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
		{
			return collectionImpl.WriteToReport(
										pHidPPreparsedData,
										pcReport,
										lReportLength,
										&GetControlFromPtr
										);
		}
		
		inline void SetDefaultState()
		{
			collectionImpl.SetDefaultState(&GetControlFromPtr);
		}

		inline ULONG GetMaxXferRequired() const
		{
			return collectionImpl.GetMaxXferRequired();
		}
		
		inline HRESULT GetState( ULONG& ulXferCount, PCONTROL_ITEM_XFER pControlItemXfers)
		{
				return collectionImpl.GetState(
										ulXferCount,
										pControlItemXfers,
										&GetControlFromPtr
										);
		}
		inline HRESULT SetState( ULONG& ulXferCount, PCONTROL_ITEM_XFER pControlItemXfers)
		{
				return collectionImpl.SetState(
										ulXferCount,
										pControlItemXfers,
										&GetControlFromPtr
										);
		}

		inline ULONG GetModifiers() const
		{
				return collectionImpl.GetModifiers();
		}
		
		inline void SetModifiers(ULONG ulModifiers)
		{
			collectionImpl.SetModifiers(ulModifiers);
		}
		
		inline void SetStateOverlayMode(BOOLEAN fEnable)
		{
			collectionImpl.SetStateOverlayMode(&GetControlFromPtr, fEnable);
		}
	private:
		CControlItemCollectionImpl collectionImpl;
};


HRESULT
ControlItemDefaultFactory
(
	USHORT usType,
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CControlItem			**ppControlItem
);

//
//	@class	Default collection where objects in collection have only the
//			the CControlItem class as their base classes.
//
class CControlItemDefaultCollection : public CControlItemCollection<CControlItem>
{
	public:
		CControlItemDefaultCollection(ULONG	ulVidPid)
		: CControlItemCollection<CControlItem>(ulVidPid, &ControlItemDefaultFactory)
		{}
};

#endif //__ControlItemCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- X2 Gaming Project
//
//		Version 4.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@topic	DEBUG.H | Global definitions for debugging output.
//**************************************************************************

#ifndef	CIC_DEBUG_H
#define	CIC_DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

//
// DEBUG output types (NOT LEVELS) - there is a similar
// section of debug.h for gckernel, these need to be in sync
//
#ifndef DBG_ENTRY

#define DBG_ENTRY		0x00000001	//Traceout on entry to function
#define DBG_EXIT		0x00000002	//Traceout on exit from function
#define DBG_WARN		0x00000004	//Traceout signifying a warning (or informational)
#define DBG_TRACE		0x00000008	//Traceout signifying a warning (or informational)
#define DBG_ERROR		0x00000010	//Traceout signifying an error
#define DBG_CRITICAL	0x00000020	//Traceout signifying a critical error
#define DBG_RT_ENTRY	0x00000040	//Traceout on entry to function (TIME CRITICAL CODE)
#define DBG_RT_EXIT		0x00000080	//Traceout on exit from function (TIME CRITICAL CODE)
#define DBG_RT_WARN		0x00000100	//Traceout signifying a warning (or informational) (TIME CRITICAL CODE)

// Combos of above for setting warning levels easily
#define DBG_NOT_RT		0x0000003F	//Traceout all above except RT codes
#define DBG_RT			0x000001C0	//Traceout RT codes
#define DBG_WARN_ERROR	0x00000134	//Traceout warnings and errors including DBG_RT_WARN
#define DBG_ALL			0xFFFFFFFF	//Traceout all codes

#endif


#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#define USE_CIC_DBG_TRACEOUTS
#endif
#endif

#ifdef USE_CIC_DBG_TRACEOUTS

//
//	Declaration for debug module
//

//
//	Must start file with a #define for the DEBUG module
//
//i.e. #define __DEBUG_MODULE_IN_USE__  GCKERNEL_DEBUG_MODULE
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)\
	ULONG __DEBUG_MODULE_IN_USE__ = __x__;
#define SET_MODULE_DEBUG_LEVEL(__x__)\
	__DEBUG_MODULE_IN_USE__ = __x__;


//
//	Conditional debug output procedures
//

#define CIC_DBG_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ENTRY)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_EXIT)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_WARN)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_TRACE_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_TRACE)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_ERROR_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ERROR)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_CRITICAL_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_CRITICAL)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_ENTRY)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_EXIT)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_WARN)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define	CIC_DBG_BREAK()	DbgBreakPoint()

#undef	PAGED_CODE
#define	PAGED_CODE() \
	if (KeGetCurrentIrql() > APC_LEVEL)	\
	{\
		CIC_DBG_CRITICAL_PRINT(("CIC: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
   		ASSERT(FALSE);\
	}
#else		// DBG=0

#define	CIC_DBG_ENTRY_PRINT(__x__)
#define	CIC_DBG_EXIT_PRINT(__x__)
#define CIC_DBG_TRACE_PRINT(__x__)
#define	CIC_DBG_WARN_PRINT(__x__)
#define	CIC_DBG_ERROR_PRINT(__x__)
#define	CIC_DBG_CRITICAL_PRINT(__x__)
#define	CIC_DBG_RT_ENTRY_PRINT(__x__)
#define	CIC_DBG_RT_EXIT_PRINT(__x__)
#define	CIC_DBG_RT_WARN_PRINT(__x__)
#define	CIC_DBG_BREAK()
#undef	PAGED_CODE
#define	PAGED_CODE()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)


#endif	// DBG=?


//===========================================================================
//			End
//===========================================================================

#endif	// CIC_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dumpcommandblock.cpp ===
//When invoked from WDM makefile the debug condition is different
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#undef _NDEBUG
#else
#define _NDEBUG
#endif
#endif

//
//  This entire module is debug only
//
#ifndef _NDEBUG
#define __DEBUG_MODULE_IN_USE__ CIC_DUMPCOMMANDBLOCK_CPP
#include "stdhdrs.h"
#include <stdio.h>
#include "Actions.h"
#include "DumpCommandBlock.h"

//----------------------------------------------------
//  Global variables
//----------------------------------------------------
PFNSTRING_DUMP_FUNC CDumpItem::ms_pfnDumpFunc = NULL;
static PFNSTRING_DUMP_FUNC g_pfnDumpFunc = NULL;
CControlItemCollection<CDumpItem> *g_pDumpCollection = NULL;
static char GlobalTempBuffer[1024];

const	ULONG XDF_Trigger	= 1;
const	ULONG XDF_Event		= 2;

//-----------------------------------------------------------------------------------------
// Interface Functions - Implementation
//-----------------------------------------------------------------------------------------

BOOLEAN DumpCommandBlock(PUCHAR pucBlock, ULONG ulSize)
{
	BOOLEAN fRetVal = DumpRecurse(pucBlock, ulSize, 0);
	DumpString("///////////////End of Dump//////////////////\n");
	return fRetVal;
}

void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc)
{
	g_pfnDumpFunc = pfnDumpFunc;
	CDumpItem::SetDumpFunc(pfnDumpFunc);
}

void InitDumpModule(ULONG ulVidPid)
{
	//Initializing to new VidPid - destroy the existing one
	if(g_pDumpCollection)
	{
		delete g_pDumpCollection;
	}
	g_pDumpCollection = new WDM_NON_PAGED_POOL CControlItemCollection<CDumpItem>(ulVidPid, &DumpItemFactory);
	if(!g_pDumpCollection)
	{
		DumpString("ERROR: Couldn't create Dump Collection, won't be able to give detailed Xfer info.\n");
	}
}

//-----------------------------------------------------------------------------------------
// Internal functions - Implementation
//-----------------------------------------------------------------------------------------
void DumpString(LPSTR lpszDumpString)
{
	if(g_pfnDumpFunc)
	{
		g_pfnDumpFunc(lpszDumpString);
	}
	else
	{
		DCB_TRACE(lpszDumpString);
	}
}


BOOLEAN DumpDirectory(PUCHAR pucBlock, ULONG ulSize)
{
	PCOMMAND_DIRECTORY pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pucBlock);
	
	//	Check the type
	if( eDirectory != pCommandDirectory->CommandHeader.eID )
	{
		sprintf(GlobalTempBuffer, "ERROR: Expecting eDirectory\n");
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	//	Check the size
	if ( ulSize < pCommandDirectory->ulEntireSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation, %d bytes expected, %d allocated.\n", pCommandDirectory->ulEntireSize, ulSize);
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	// Dump the Directory information
	sprintf(GlobalTempBuffer, "///////eDirectory/////////////////////////////////////////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    eID: %x\n",pCommandDirectory->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    ulByteSize: %d\n",pCommandDirectory->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEntireSize: %d\n",pCommandDirectory->ulEntireSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "NumEntries: %d\n",pCommandDirectory->usNumEntries);
	DumpString(GlobalTempBuffer);
	return TRUE;
}


// Just What kind of command is this
BOOLEAN DumpAssignmentTarget(PUCHAR pucBlock, ULONG ulSize)
{
	
	PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET> (pucBlock);
	//	Check the size
	if ( ulSize < pAssignmentTarget->CommandHeader.ulByteSize )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}

	switch( pAssignmentTarget->CommandHeader.eID )
	{
		case eBehaviorAction:
			sprintf(GlobalTempBuffer, "////////////////////////eBehaviorAction////////\n");
			break;
		case eRecordableAction:
			sprintf(GlobalTempBuffer, "////////////////////////eRecordableAction////////\n");
			break;
		default:
			return FALSE;
	}

	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    ulByteSize: %d\n",pAssignmentTarget->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	return DumpTriggerXfer(&pAssignmentTarget->cixAssignment);
}

BOOLEAN DumpTimedMacro(PUCHAR pucBlock, ULONG ulSize)
{
	PTIMED_MACRO pTimedMacro = reinterpret_cast<PTIMED_MACRO>(pucBlock);
	PASSIGNMENT_BLOCK pAssBlock = &pTimedMacro->AssignmentBlock ;
	ULONG ulCurrentEvent = 0;
	PTIMED_EVENT pCurrentEvent = NULL;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Timed Macro////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAssBlock->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAssBlock->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAssBlock->ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulFlags: %x\n",pTimedMacro->ulFlags);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEventCount: %x\n",pTimedMacro->ulEventCount);
	DumpString(GlobalTempBuffer);

	if ( ulSize < pAssBlock->CommandHeader.ulByteSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	while ( pCurrentEvent = pTimedMacro->GetNextEvent(pCurrentEvent, ulCurrentEvent))
	{
		if (!DumpTimedEvent( pCurrentEvent))
			return FALSE;
	}
	return TRUE;
}

BOOLEAN DumpKeyString(PUCHAR pucBlock, ULONG ulSize)
{
	PKEYSTRING_MAP pKeyStringMap = reinterpret_cast<PKEYSTRING_MAP> (pucBlock) ;
	PASSIGNMENT_BLOCK pAssBlock = &pKeyStringMap->AssignmentBlock ;
	ULONG ulEvent = 0;
	PEVENT pEvent = NULL;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Key String/////////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAssBlock->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAssBlock->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAssBlock->ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulFlags: %x\n",pKeyStringMap->ulFlags);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEventCount: %x\n",pKeyStringMap->ulEventCount);
	DumpString(GlobalTempBuffer);

	if ( ulSize < pKeyStringMap->AssignmentBlock.CommandHeader.ulByteSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	while ( pEvent = pKeyStringMap->GetNextEvent(pEvent, ulEvent))
	{
		if (!DumpEvent( pEvent))
			return FALSE;
	}
	return TRUE;
}

BOOLEAN DumpMouseFxAxisMap(PUCHAR pucBlock, ULONG ulSize)
{
	PMOUSE_FX_AXIS_MAP pMouseFxAxisMap = (PMOUSE_FX_AXIS_MAP)pucBlock;
	ASSERT(ulSize == sizeof(MOUSE_FX_AXIS_MAP));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////MouseFxAxisMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pMouseFxAxisMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pMouseFxAxisMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pMouseFxAxisMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	if(pMouseFxAxisMap->fIsX)
	{
		DumpString("X Axis\n");
	}
	else
	{
		DumpString("Y Axis\n");
	}
	sprintf(GlobalTempBuffer, "Model Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulAbsZoneSense    = %d\n", pMouseFxAxisMap->AxisModelParameters.ulAbsZoneSense);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulContZoneMaxRate = %d\n", pMouseFxAxisMap->AxisModelParameters.ulContZoneMaxRate);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulPulseWidth      = %d\n", pMouseFxAxisMap->AxisModelParameters.ulPulseWidth);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulPulsePeriod     = %d\n", pMouseFxAxisMap->AxisModelParameters.ulPulsePeriod);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulInertiaTime     = %d\n", pMouseFxAxisMap->AxisModelParameters.ulInertiaTime);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulAcceleration    = %d\n", pMouseFxAxisMap->AxisModelParameters.ulAcceleration);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "fAccelerate       = %s\n", ((pMouseFxAxisMap->AxisModelParameters.fPulse) ? "T" : "F"));
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "fPulse            = %s\n", ((pMouseFxAxisMap->AxisModelParameters.fPulse) ? "T" : "F"));
	DumpString(GlobalTempBuffer);
	return TRUE;
}

/*
typedef struct tagAXIS_MAP
{
	ASSIGNMENT_BLOCK	AssignmentBlock;	//eAxisMap is the type
	LONG				lCoefficient1024x;	//A mapping coeffiecient times 1024 (should be between -1024 and 1024)
	CONTROL_ITEM_XFER	cixDestinationAxis; //Axis to map to.
} AXIS_MAP, *PAXIS_MAP;
*/


BOOLEAN DumpAxisMap(PUCHAR pucBlock, ULONG ulSize)
{
	PAXIS_MAP pAxisMap = (PAXIS_MAP)pucBlock;
	ASSERT(ulSize == sizeof(AXIS_MAP));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////AxisMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAxisMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAxisMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAxisMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	/*
	if(pMouseFxAxisMap->fIsX)
	{
		DumpString("X Axis\n");
	}
	else
	{
		DumpString("Y Axis\n");
	}
	*/
	sprintf(GlobalTempBuffer, "Model Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "lCoefficient1024x    = %d\n", pAxisMap->lCoefficient1024x);
	DumpString(GlobalTempBuffer);

	if(!DumpEventXfer(&pAxisMap->cixDestinationAxis))
		return FALSE;

	return TRUE;
}

BOOLEAN DumpForceMap(PUCHAR pucBlock, ULONG ulSize)
{
	FORCE_BLOCK* pForceMap = (FORCE_BLOCK*)pucBlock;
	ASSERT(ulSize == sizeof(FORCE_BLOCK));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////ForceMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pForceMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pForceMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n", pForceMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Force Map Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "bMapYToX    = %d\n", pForceMap->bMapYToX);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "usRTC    = %d\n", pForceMap->usRTC);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "usGain    = %d\n", pForceMap->usGain);
	DumpString(GlobalTempBuffer);

	return TRUE;
}

BOOLEAN DumpUnknown(PUCHAR pucBufferLocation, ULONG ulSize)
{
	COMMAND_HEADER* pHeader = (COMMAND_HEADER*)pucBufferLocation;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Unknown Item////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "eID : 0x%X\n", pHeader->eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n", pHeader->ulByteSize);
	DumpString(GlobalTempBuffer);
	return TRUE;
}

BOOLEAN DumpTimedEvent(PTIMED_EVENT pTimedEvent)
{
	PEVENT pEvent = &pTimedEvent->Event;
	sprintf(GlobalTempBuffer,"ulDuration: %d\n",pTimedEvent->ulDuration);
	DumpString(GlobalTempBuffer);
	return DumpEvent(pEvent);
}

BOOLEAN DumpEvent(PEVENT pEvent)
{
	sprintf(GlobalTempBuffer,"ulNumXfers: %d\n",pEvent->ulNumXfers);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer,"Required bytes: %d\n",pEvent->RequiredByteSize( pEvent->ulNumXfers));
	DumpString(GlobalTempBuffer);
	
	ULONG ulXferIndex;
	for(ulXferIndex=0; ulXferIndex < pEvent->ulNumXfers; ulXferIndex++)
	{
		sprintf(GlobalTempBuffer, "Dumping Xfer #%d\n", ulXferIndex);
		DumpString(GlobalTempBuffer);
		if(!DumpEventXfer(&pEvent->rgXfers[ulXferIndex]))
			return FALSE;
	}
	return TRUE;
}

#define SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader)\
	(reinterpret_cast<PCOMMAND_HEADER>\
		( reinterpret_cast<PUCHAR>(pCommandHeader) +\
		reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize )\
	)

#define SKIP_TO_NEXT_COMMAND_DIRECTORY(pCommandDirectory)\
	(reinterpret_cast<PCOMMAND_DIRECTORY>\
		(reinterpret_cast<PUCHAR>(pCommandDirectory) +\
		pCommandDirectory->ulEntireSize)\
	)
	
#define COMMAND_BLOCK_FITS_IN_DIRECTORY(pCommandDirectory, pCommandHeader)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandDirectory) -	reinterpret_cast<PUCHAR>(pCommandHeader)) +\
					reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize\
				)\
		)
#define COMMAND_DIRECTORY_FITS_IN_DIRECTORY(pCommandDirectory, pCommandSubDirectory)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandDirectory) -	reinterpret_cast<PUCHAR>(pCommandHeader)) +\
					pCommandSubDirectory->ulEntireSize\
				)\
		)

BOOLEAN DumpRecurse(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth)
{
	PCOMMAND_DIRECTORY pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pucBlock);
	PCOMMAND_HEADER pCommandHeader;
	PUCHAR pucBufferLocation = pucBlock;

	//	Sanity Check
	if( eDirectory != pCommandDirectory->CommandHeader.eID )
	{
		sprintf(GlobalTempBuffer, "ERROR: Expecting eDirectory, recursion depth = %ld\n", ulDepth);
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	
	//Print out starting address of Directory
	sprintf(GlobalTempBuffer, "Next Directory starts at 0x%0.8x\n", pucBlock);
	DumpString(GlobalTempBuffer);

	//	Dump COMMAND_DIRECTORY info - this will inherently check the size
	if( !DumpDirectory(pucBlock, ulSize) )
		return FALSE;
	
	//	If there are no entries are done
	if( 0 == pCommandDirectory->usNumEntries)
	{
		sprintf(GlobalTempBuffer, "WARNING: Lowest level sub-directory with no blocks\n");
		DumpString(GlobalTempBuffer);
		return TRUE;
	}

	//	Skip Directory header to get to first block
	pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(pCommandDirectory);
	
	//Forget the allocate size (which we now by now is at least
	//as big as the entire size of the directory) and start using the directory size
	ulSize = pCommandDirectory->ulEntireSize;
	// Reduce the size by the size of the header
	ulSize -=  (PUCHAR)pCommandHeader - pucBufferLocation;
	pucBufferLocation = (PUCHAR)pCommandHeader;

	//Ensure that there is at least enough room for COMMAND_HEADER
	if( sizeof(COMMAND_HEADER) > ulSize)
	{
		DumpString("ERROR: Unexpected end of buffer\n");
		return FALSE;
	}
	
	//	If we have a sub-directory, call ourselves recursively, for each sub-directory
	if( eDirectory == pCommandHeader->eID)
	{
		PCOMMAND_DIRECTORY pCurDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandHeader);
		USHORT usDirectoryNum = 1;
		while( usDirectoryNum <= pCommandDirectory->usNumEntries)
		{
			//Call ourselves recursively
			if( !DumpRecurse(pucBufferLocation, ulSize, ulDepth+1) )
				return FALSE;
			//Skip to next directory
			pCurDirectory = SKIP_TO_NEXT_COMMAND_DIRECTORY(pCurDirectory);

			// Reduce the size by the size of the directory just parsed
			ulSize -=  (PUCHAR)pCurDirectory - pucBufferLocation;
			pucBufferLocation = (PUCHAR)pCurDirectory;
			usDirectoryNum++;
		}
		//Nobody failed so return TRUE
		return TRUE;
	}

	//
	//	If we are here, we have reached the bottom of a directory,
	//	to a command we need to dump
	//
	USHORT usEntryNum = 1;
	while( usEntryNum  <= pCommandDirectory->usNumEntries)
	{
		//Ensure that there is at least enough room for COMMAND_HEADER
		if( sizeof(COMMAND_HEADER) > ulSize)
		{
			DumpString("ERROR: Unexpected end of buffer\n");
			return FALSE;
		}
		sprintf(GlobalTempBuffer, "Next Block starts at 0x%0.8x\n", pucBufferLocation);
		DumpString(GlobalTempBuffer);
		//Dump info about block
		switch( pCommandHeader->eID )
		{
			case eBehaviorAction:
			case eRecordableAction:
				if( !DumpAssignmentTarget(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eTimedMacro:
				if( !DumpTimedMacro(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eKeyString:
				if( !DumpKeyString(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eMouseFXAxisMap:
				if( !DumpMouseFxAxisMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eAxisMap:
				if( !DumpAxisMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
#if 1
			case eForceMap:
				if( !DumpForceMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
#endif
			default:
				if ( !DumpUnknown(pucBufferLocation, ulSize) )
					return FALSE;
				break;

		}
		// skip to next block
		pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader);
		ulSize -=  (PUCHAR)pCommandHeader - pucBufferLocation;
		pucBufferLocation = (PUCHAR)pCommandHeader;
		usEntryNum++;
	}
	//we've reached the end of this directory
	return TRUE;
}

BOOLEAN DumpTriggerXfer(PCONTROL_ITEM_XFER pControlItemXfer)
{
	//Is Xfer for a keyboard
	if( NonGameDeviceXfer::IsKeyboardXfer(*pControlItemXfer) )
	{
		sprintf(GlobalTempBuffer, "ERROR: Invalid Trigger. Keyboard data encountered.\n");
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	if(g_pDumpCollection)
	{
		CDumpItem *pDumpItem;
		pDumpItem = g_pDumpCollection->GetFromControlItemXfer(*pControlItemXfer);
		if( !pDumpItem )
		{
			sprintf(GlobalTempBuffer, "ERROR: Xfer packet not supported for device.\n");
			DumpString(GlobalTempBuffer);
			return FALSE;
		}
		pDumpItem->SetItemState(*pControlItemXfer);
		pDumpItem->DumpItemInfo(XDF_Trigger);
	}
	else
	{
		sprintf(GlobalTempBuffer, "WARNING: Dump Module not initialized for device, detailed Xfer info not available.\n");
		DumpString(GlobalTempBuffer);
	}
	return TRUE;
}

BOOLEAN DumpEventXfer(PCONTROL_ITEM_XFER pControlItemXfer)
{
	//Is Xfer for a keyboard
	if( NonGameDeviceXfer::IsKeyboardXfer(*pControlItemXfer) )
	{
		DumpKeyboardData(pControlItemXfer);
		return TRUE;
	}
	if(g_pDumpCollection)
	{
		CDumpItem *pDumpItem;
		pDumpItem = g_pDumpCollection->GetFromControlItemXfer(*pControlItemXfer);
		if( !pDumpItem )
		{
			sprintf(GlobalTempBuffer, "ERROR: Xfer packet not supported for device.\n");
			DumpString(GlobalTempBuffer);
			return FALSE;
		}
		pDumpItem->SetItemState(*pControlItemXfer);
		pDumpItem->DumpItemInfo(XDF_Event);
	}
	else
	{
		sprintf(GlobalTempBuffer, "WARNING: Dump Module not initialized for device, detailed Xfer info not available.\n");
		DumpString(GlobalTempBuffer);
	}
	return TRUE;
}

void CDumpItem::DumpItemInfo(ULONG ulDumpFlags)
{
	DumpString("ERROR: Should never be called!\n");
}

void CAxesDump::DumpItemInfo(ULONG ulDumpFlags)
{
	// Read data
	LONG lValX, lValY;
	GetXY( lValX, lValY);

	if(XDF_Event == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "AXES: X = %d, Y = %d\n", lValX, lValY);
	}
	else if(XDF_Trigger == ulDumpFlags)
	{
		if( lValX )
		{
			sprintf(GlobalTempBuffer, "AXES: Assign to X\n");
		}
		else if (lValY)
		{
			sprintf(GlobalTempBuffer, "AXES: Assign to Y\n");
		}
		else
		{
			sprintf(GlobalTempBuffer, "AXES: Invalid Assignment\n");
		}
	}
	DumpString(GlobalTempBuffer);
}

void CDPADDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetDirection(lDirection);

	sprintf(GlobalTempBuffer, "DPAD: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CPropDPADDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetDirection(lDirection);

	sprintf(GlobalTempBuffer, "DPAD: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CButtonsDump::DumpItemInfo(ULONG ulDumpFlags)
{
	USHORT	usButtonNum;
	ULONG	ulButtonBitArray;
	GetButtons( usButtonNum, ulButtonBitArray );
	if(XDF_Event == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "BUTTONS: BitArray = 0x%0.8x, ButtonNum = %d\n", ulButtonBitArray, (ULONG)usButtonNum);
    }                                                                                                                     
	else if(XDF_Trigger == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "BUTTONS: ButtonNum = %d MODIFIERS = %d\n", (ULONG)usButtonNum, GetNumModifiers());
	}
	DumpString(GlobalTempBuffer);
}

void CPOVDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetValue(lDirection);
	sprintf(GlobalTempBuffer, "POV: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CThrottleDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "THROTTLE: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CRudderDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "RUDDER: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CWheelDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "WHEEL: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CPedalDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "PEDAL: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CZoneIndicatorDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	if( GetXIndicator() )
	{
		DumpString("ZoneIndicator: X is set\n");
	}
	if( GetYIndicator() )
	{
		DumpString("ZoneIndicator: X is set\n");
	}
}

void CDualZoneIndicatorDump::DumpItemInfo(ULONG ulDumpFlags)
{
    UNREFERENCED_PARAMETER(ulDumpFlags);
    static char* s_pszXY = "XY";
    static char* s_pszRz = "Rz";
    char *psz;
    if( IsXYIndicator() )
    {
        psz = s_pszXY;        
    }
    else if( IsRzIndicator() )
    {
        psz = s_pszRz;
    }
    else
        psz = "Unknown Zone";
  	sprintf(GlobalTempBuffer, "DualZoneIndicator (XY:%d/%d)\n", GetActiveZone(), GetNumZones());
    DumpString (GlobalTempBuffer);
}

void CForceMapDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
    CHAR szBuf[0x100];

    sprintf (szBuf, "MapYToX: %s\n", GetMapYToX() ? "ON" : "OFF");
    DumpString (szBuf);

    sprintf (szBuf, "RTC:     %d\n", GetRTC());
    DumpString (szBuf);

    sprintf (szBuf, "Gain:    %d\n", GetGain());
    DumpString (szBuf);
}


HRESULT	DumpItemFactory
(
	USHORT usType,	
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CDumpItem				**ppControlItem
)
{
	HRESULT hr = S_OK;
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppControlItem = new WDM_NON_PAGED_POOL CAxesDump(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CDPADDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CPropDPADDump(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppControlItem= new WDM_NON_PAGED_POOL CWheelDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppControlItem = new WDM_NON_PAGED_POOL CPOVDump(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppControlItem = new WDM_NON_PAGED_POOL CThrottleDump(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppControlItem = new WDM_NON_PAGED_POOL CRudderDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppControlItem = new WDM_NON_PAGED_POOL CPedalDump(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppControlItem = new WDM_NON_PAGED_POOL CButtonsDump(cpControlItemDesc);
			break;
		case ControlItemConst::usZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CZoneIndicatorDump(cpControlItemDesc);
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorDump(cpControlItemDesc);
			break;
		case ControlItemConst::usForceMap:
			*ppControlItem = new WDM_NON_PAGED_POOL CForceMapDump(cpControlItemDesc);
			break;
		default:
			*ppControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}

BOOLEAN DumpKeyboardData(PCONTROL_ITEM_XFER pControlItemXfer)
{
	sprintf(GlobalTempBuffer, "Keyboard.ucModifier = 0x%0.8x\n",  (ULONG)pControlItemXfer->Keyboard.ucModifierByte);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[0] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[0]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[1] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[1]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[2] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[2]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[3] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[3]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[4] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[4]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[5] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[5]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulModifiers = 0x%0.8x\n", pControlItemXfer->ulModifiers);
	DumpString(GlobalTempBuffer);
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\joyinfoexcollection.cpp ===
// @doc
/******************************************************************************
*
* @module JoyInfoExCollection.cpp |
*
* CControlItemJoyInfoExCollectio and related classes implementation file
*
* History<nl>
* ---------------------------------------------------<nl>
* Daniel M. Sangster		Original		2/1/99
*
* (c) 1986-1999 Microsoft Corporation.  All rights reserved.
*
* @topic JOYINFOEX Collection |
* The CControlItemJoyInfoExCollection class, the various CJoyInfoExControlItem
* classes and the ControlItemJoyInfoExFactory taken together implement the JOYINFOEX
* collection.  This collection is designed as a way to convert between
* CONTROL_ITEM_XFERs and JOYINFOEX structures.  A user does this by setting
* the state of the collection with SetState() or SetState2() and reading
* the state of the collection with GetState() or GetState2().
*
* The classes themselves are simple because they rely on CControlItemCollection
* CControlItem, etc. for much of the functionality.  The guts of the conversion
* takes place in the SetItemState() and GetItemState() members of each of the
* control items.  Here, the methods use accessor functions provided by CControlItem
* and related classes to set or get the state to or from the appropriate member
* of the JOYINFOEX structure for that item.  For example, a buttons item would
* set or get data from dwButtons and dwButtonNumber using accessors on CButtonsItem.
******************************************************************************/

#include "stdhdrs.h"
#include "joyinfoexcollection.h"
#include <math.h>

/***********************************************************************************
**
**	HRESULT ControlItemJoyInfoExFactory
**
**	@func	Factory for JoyInfoEx collection
**
**	@rdesc	S_OK if successful, S_FALSE if not supported, E_FAIL for any failure.
**
************************************************************************************/
HRESULT ControlItemJoyInfoExFactory
(
	USHORT usType,									//@parm [in] Type of object to create
	const CONTROL_ITEM_DESC* cpControlItemDesc,		//@parm [in] Item descriptor data
	CJoyInfoExControlItem		**ppJoyInfoExControlItem	//@parm [out] CJoyInfoExControlItem we created
)
{
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExAxesItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPropDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppJoyInfoExControlItem= new WDM_NON_PAGED_POOL CJoyInfoExWheelItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPOVItem(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExThrottleItem(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExRudderItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPedalItem(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExButtonsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usProfileSelectors:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExProfileSelectorsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExDualZoneIndicatorItem(cpControlItemDesc);
			break;
		default:
			*ppJoyInfoExControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppJoyInfoExControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CControlItemJoyInfoExCollection::CControlItemJoyInfoExCollection
// 
// @mfunc The constructor tells the base class what the VidPid and factory
// are for this device and collection.
//
// @rdesc	None
//
CControlItemJoyInfoExCollection::CControlItemJoyInfoExCollection(ULONG ulVidPid) :
	CControlItemCollection<CJoyInfoExControlItem>(ulVidPid, &ControlItemJoyInfoExFactory)
{
}

/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetState2
**
**	@mfunc	Gets the JOYINFOEX representation of the state of each item in the 
** collection and returns it in the caller.
**
**	@rvalue	S_OK	| Success
**	@rvalue	E_OUTOFMEMORY	|	Buffer is not large enough
**	@rvalue	E_INVALIDARG	|	Bad argument
**
*************************************************************************************/
HRESULT CControlItemJoyInfoExCollection::GetState2
(
	JOYINFOEX* pjix
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	pjix->dwSize = sizeof(JOYINFOEX);
	pjix->dwFlags = 0;
	pjix->dwXpos = 0;
	pjix->dwYpos = 0;
	pjix->dwZpos = 0;
	pjix->dwRpos = 0;
	pjix->dwUpos = 0;
	pjix->dwVpos = 0;
	pjix->dwButtons = 0;
	pjix->dwButtonNumber = 0;
	pjix->dwPOV = (DWORD)-1;

	ULONG ulCookie = 0;
	CJoyInfoExControlItem *pControlItem;
	
	hr = GetNext(&pControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem->GetItemState(pjix);
		hr = GetNext(&pControlItem, ulCookie);
	}
	return hr;	
}

/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::SetState2
**
**	@mfunc	Sets the state of each item in the collection from a JOYINFOEX representation.
**
**	@rvalue	S_OK	| Success
**	@rvalue	E_OUTOFMEMORY	|	Buffer is not large enough
**	@rvalue	E_INVALIDARG	|	Bad argument
**
*************************************************************************************/
HRESULT CControlItemJoyInfoExCollection::SetState2
(
	JOYINFOEX* pjix
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	ULONG ulCookie = 0;
	//PVOID pvControlItem = NULL;
	CJoyInfoExControlItem *pControlItem;
	
	hr = GetNext(&pControlItem, ulCookie);
	while(S_OK == hr)
	{
		hr = pControlItem->SetItemState(pjix);
		_ASSERTE(SUCCEEDED(hr));
		hr = GetNext(&pControlItem, ulCookie);
	}
	return hr;	
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExControlItem::CJoyInfoExControlItem
// 
// @mfunc Constructor does nothing
//
// @rdesc	None
//
CJoyInfoExControlItem::CJoyInfoExControlItem()
{
}


const int cnMaxJoyInfoExAxis = 65535;
const int cnMaxJoyInfoExPOV = 35900;


////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExControlItem::CJoyInfoExControlItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExAxesItem::CJoyInfoExAxesItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CAxesItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExAxesItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExAxesItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// get the raw axes data
	LONG lX = 0;
	LONG lY = 0;
	GetXY(lX, lY);

	// scale the data to joyinfoex range
	lX = MulDiv(cnMaxJoyInfoExAxis, lX-lMinX, lMaxX-lMinX);
	lY = MulDiv(cnMaxJoyInfoExAxis, lY-lMinY, lMaxY-lMinY);

	// put result in joyinfoex structure
	pjix->dwXpos = lX;
	pjix->dwYpos = lY;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExAxesItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExAxesItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// scale the data to correct range
	LONG lX = lMinX + MulDiv(lMaxX-lMinX, pjix->dwXpos, cnMaxJoyInfoExAxis);
	LONG lY = lMinY + MulDiv(lMaxY-lMinY, pjix->dwYpos, cnMaxJoyInfoExAxis);

	// set the item data
	SetXY(lX, lY);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::CJoyInfoExDPADItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExDPADItem::CJoyInfoExDPADItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CDPADItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDPADItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// TODO talk to mitch about what the range should be

	// get the raw POV data
	LONG lDirection;
	GetDirection(lDirection);

	// put result in joyinfoex structure
	pjix->dwPOV = lDirection;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDPADItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// TODO talk to mitch about what the range should be
	// put result in joyinfoex structure
	LONG lDirection = pjix->dwPOV;

	// set the raw POV data
	SetDirection(lDirection);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::CJoyInfoExPropDPADItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPropDPADItem::CJoyInfoExPropDPADItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CPropDPADItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPropDPADItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// get the raw axes data
	LONG lX = 0;
	LONG lY = 0;
	GetXY(lX, lY);

	// scale the data to joyinfoex range
	lX = MulDiv(cnMaxJoyInfoExAxis, lX-lMinX, lMaxX-lMinX);
	lY = MulDiv(cnMaxJoyInfoExAxis, lY-lMinY, lMaxY-lMinY);

	// put result in joyinfoex structure
	pjix->dwXpos = lX;
	pjix->dwYpos = lY;

	// get the raw POV data
	LONG lDirection;
	GetDirection(lDirection);

	// put result in joyinfoex structure
	pjix->dwPOV = lDirection;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPropDPADItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// scale the data to correct range
	LONG lX = lMinX + MulDiv(lMaxX-lMinX, pjix->dwXpos, cnMaxJoyInfoExAxis);
	LONG lY = lMinY + MulDiv(lMaxY-lMinY, pjix->dwYpos, cnMaxJoyInfoExAxis);

	// set the item data
	SetXY(lX, lY);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::CJoyInfoExButtonsItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExButtonsItem::CJoyInfoExButtonsItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CButtonsItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExButtonsItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the minimum and maximum button numbers
	USHORT usButtonMin = GetButtonMin();
	USHORT usButtonMax = GetButtonMax();

	// get the button number and bit array
	USHORT usButtonNumber = 0;
	ULONG ulButtonBitArray = 0;
	GetButtons(usButtonNumber, ulButtonBitArray);

	// shift the bit array by bias amount
	ulButtonBitArray = ulButtonBitArray << (usButtonMin-1);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=usButtonMin; usButtonIndex<=usButtonMax; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// handle special case of detecting shift button because
	// shift button is not reflected in the bit array
	ULONG ulShiftButtonBitArray = 0;
	ULONG ulRawShiftButtonBitArray = 0;
	ULONG ulShiftButtonMask = 0;
	GetShiftButtons(ulRawShiftButtonBitArray);
	UINT uShiftButtonCount = GetNumShiftButtons();
	if(uShiftButtonCount > 1)
	{
		for(UINT uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonBitArray |= ((ulRawShiftButtonBitArray >> uShiftButtonIndex) & 0x01) << (usShiftButtonUsage - 1);
		}

		// create a bitmask for this range of shift buttons
		for(uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonMask |= 1 << (usShiftButtonUsage - 1);
		}
	}
	else if(uShiftButtonCount == 1)
	{
		ulShiftButtonMask = 0x00200;
		if(ulRawShiftButtonBitArray != NULL)
			ulShiftButtonBitArray = ulShiftButtonMask;
	}

	// set this section of the bit array into the joyinfoex structure
	ULONG ulMask = ulButtonMask | ulShiftButtonMask;
	pjix->dwButtons |= (pjix->dwButtons & ~ulMask) | ulButtonBitArray | ulShiftButtonBitArray;

	// set the button number of the joyinfoex structure, if set
	pjix->dwButtonNumber = usButtonNumber;

	// TODO: remove this hack when driver is fixed
	if(usButtonNumber != 0)
		pjix->dwButtons |= 1<<(usButtonNumber-1);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExButtonsItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the minimum and maximum button numbers
	USHORT usButtonMin = GetButtonMin();
	USHORT usButtonMax = GetButtonMax();

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=usButtonMin; usButtonIndex<=usButtonMax; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// get the buttons
	ULONG ulButtonBitArray = pjix->dwButtons & ulButtonMask;
	ulButtonBitArray = ulButtonBitArray >> (usButtonMin-1);

	// get the shift buttons
	ULONG ulShiftButtonBitArray = 0;
	UINT uShiftButtonCount = GetNumShiftButtons();
	if(uShiftButtonCount > 1)
	{
		for(UINT uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonBitArray |= ((pjix->dwButtons >> (usShiftButtonUsage - 1)) & 0x01) << uShiftButtonIndex;
		}
	}
	else if(uShiftButtonCount == 1)
	{
		if(pjix->dwButtons & 0x00200)
			ulShiftButtonBitArray = 1;
	}

	// set the shift button data
	SetShiftButtons(ulShiftButtonBitArray);

	// set the button data
	USHORT usButtonNumber = (USHORT)pjix->dwButtonNumber;
	SetButtons(usButtonNumber, ulButtonBitArray);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::CJoyInfoExProfileSelectorsItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExProfileSelectorsItem::CJoyInfoExProfileSelectorsItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CProfileSelector(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExProfileSelectorsItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the min and max button numbers
	UINT uFirstProfileSelectorButton = GetProfileSelectorMin();
	UINT uLastProfileSelectorButton = GetProfileSelectorMax();
	int iProfileSelectorButtonCount = uLastProfileSelectorButton - uFirstProfileSelectorButton + 1;
	// _ASSERTE(iProfileSelectorButtonCount > 0);

	// get the profile that is selected
	UCHAR ucSelectedProfile;
	GetSelectedProfile(ucSelectedProfile);

	// create a bit array corresponding to this 
	ULONG ulButtonBitArray = 1 << (iProfileSelectorButtonCount - ucSelectedProfile - 1);

	// shift the bit array by bias amount
	ulButtonBitArray = ulButtonBitArray << (uFirstProfileSelectorButton-1);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=uFirstProfileSelectorButton; usButtonIndex<=uLastProfileSelectorButton; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// set this section of the bit array into the joyinfoex structure
	pjix->dwButtons = (pjix->dwButtons & ~ulButtonMask) | ulButtonBitArray;

	// set the button number of the joyinfoex structure, if it has not already been set
	if(pjix->dwButtonNumber == 0)
		pjix->dwButtonNumber = ucSelectedProfile + uFirstProfileSelectorButton;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExProfileSelectorsItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the min and max button numbers
	UINT uFirstProfileSelectorButton = GetProfileSelectorMin();
	UINT uLastProfileSelectorButton = GetProfileSelectorMax();
	int iProfileSelectorButtonCount = uLastProfileSelectorButton - uFirstProfileSelectorButton + 1;
	// _ASSERTE(iProfileSelectorButtonCount > 0);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=uFirstProfileSelectorButton; usButtonIndex<=uLastProfileSelectorButton; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// get the buttons
	ULONG ulButtonBitArray = pjix->dwButtons & ulButtonMask;
	ulButtonBitArray = ulButtonBitArray >> (uFirstProfileSelectorButton-1);

	// convert this to an index
	UCHAR ucIndex = 0;
	for(ucIndex=0; ucIndex<=uLastProfileSelectorButton-uFirstProfileSelectorButton; ucIndex++)
	{
		// if low order bit is one, we have found our index
		if((ulButtonBitArray >> ucIndex) & 0x01)
			break;
	}

	// set the shift button data
	UCHAR ucSelectedProfile = iProfileSelectorButtonCount - ucIndex - 1;
	SetSelectedProfile(ucSelectedProfile);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::CJoyInfoExPOVItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPOVItem::CJoyInfoExPOVItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CPOVItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPOVItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the POV range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	if(lVal >= lMin && lVal <= lMax)
		lVal = MulDiv(cnMaxJoyInfoExPOV, lVal-lMin, lMax-lMin);
	else
		lVal = -1;

	// put result in joyinfoex structure
	pjix->dwPOV = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPOVItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the POV range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = 0;
	if(pjix->dwPOV >= 0)
		lVal = lMin + MulDiv(lMax-lMin, pjix->dwPOV, cnMaxJoyInfoExPOV);
	else
		lVal = -1;

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::CJoyInfoExThrottleItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExThrottleItem::CJoyInfoExThrottleItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CThrottleItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExThrottleItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwZpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExThrottleItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to correct range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwZpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::CJoyInfoExRudderItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExRudderItem::CJoyInfoExRudderItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CRudderItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExRudderItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwRpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExRudderItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwRpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::CJoyInfoExWheelItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExWheelItem::CJoyInfoExWheelItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CWheelItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExWheelItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwXpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExWheelItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwXpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::CJoyInfoExPedalItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPedalItem::CJoyInfoExPedalItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CPedalItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPedalItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	if(IsYAxis())
	{
		pjix->dwYpos = lVal;
	}
	else
	{
		pjix->dwRpos = lVal;
	}

	// mark the JOYINFOEX packet if the pedals are not there
	if(!ArePedalsPresent())
		pjix->dwFlags |= JOY_FLAGS_PEDALS_NOT_PRESENT;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPedalItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	DWORD dwPos = 0;
	if(IsYAxis())
	{
		dwPos = pjix->dwYpos;
	}
	else
	{
		dwPos = pjix->dwRpos;
	}
	LONG lVal = lMin + MulDiv(lMax-lMin, dwPos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::CJoyInfoExDualZoneIndicatorItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExDualZoneIndicatorItem::CJoyInfoExDualZoneIndicatorItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CDualZoneIndicatorItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDualZoneIndicatorItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// convert to axes
	UINT uMin = 0;
	UINT uMax = cnMaxJoyInfoExAxis;
	UINT uMid = uMax/2;
	if(IsXYIndicator())
	{
		LONG lActiveZone = GetActiveZone();
		/*
		if ((m_ItemState.DualZoneIndicators.rglVal[0] != 0) || (m_ItemState.DualZoneIndicators.rglVal[1] != 0))
		{
			TCHAR tszDebug[1024];
			wsprintf(tszDebug, "\tlActiveZone = %d\n", lActiveZone);
			OutputDebugString("*****************************************\n");
			OutputDebugString(tszDebug);
		}
		*/
		switch(lActiveZone)
		{
			case 0:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMid;
				break;
			case 1:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMax;
				break;
			case 2:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMax;
				break;
			case 3:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMax;
				break;
			case 4:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMid;
				break;
			case 5:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMin;
				break;
			case 6:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMin;
				break;
			case 7:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMin;
				break;
			case 8:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMid;
				break;
			default:
				_ASSERTE(FALSE);
		}
	}
	else if(IsRzIndicator())
	{
		LONG lActiveZone = GetActiveZone();
		switch(lActiveZone)
		{
			case 0:
				pjix->dwRpos = uMid;
				break;
			case 1:
				pjix->dwRpos = uMin;
				break;
			case 2:
				pjix->dwRpos = uMax;
				break;
			default:
				_ASSERTE(FALSE);
		}
	}
	else
	{
		_ASSERTE(FALSE);
		return E_UNEXPECTED;
	}

	//_RPT0(_CRT_WARN, "*********CJoyInfoExDualZoneIndicatorItem::GetItemState()****************\n");
	//_RPT1(_CRT_WARN, "\tlZone = %d\n", GetActiveZone());
	//_RPT1(_CRT_WARN, "\t====> dwXpos = %d\n", pjix->dwXpos);
	//_RPT1(_CRT_WARN, "\t====> dwYpos = %d\n", pjix->dwYpos);
	//_RPT0(_CRT_WARN, "************************************************************************\n");

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDualZoneIndicatorItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	LONG lZone = 0;
	UINT uMin = 0;
	UINT uMax = cnMaxJoyInfoExAxis;
	UINT uMid = uMax/2;
	if(IsXYIndicator())
	{
		int iXPos = (int)pjix->dwXpos - uMid;
		int iYPos = (int)pjix->dwYpos - uMid;
		if((ULONGLONG)iXPos*iXPos + iYPos*iYPos > (ULONGLONG)(uMid*uMid/4))
		{
			double dAngle = atan2(iYPos, iXPos);
			dAngle = dAngle*180.0/3.14159;
			dAngle += 360.0;
			dAngle = fmod(dAngle, 360.0);

			if(dAngle < -1.0)
				_ASSERTE(FALSE);
			else if(dAngle < 22.5)
				lZone = 4;
			else if(dAngle < 67.5)
				lZone = 3;
			else if(dAngle < 112.5)
				lZone = 2;
			else if(dAngle < 157.5)
				lZone = 1;
			else if(dAngle < 202.5)
				lZone = 8;
			else if(dAngle < 247.5)
				lZone = 7;
			else if(dAngle < 292.5)
				lZone = 6;
			else if(dAngle < 337.5)
				lZone = 5;
			else if(dAngle <= 361.0)
				lZone = 4;
			else
				_ASSERTE(FALSE);
		}
	}
	else if(IsRzIndicator())
	{
		int iRPos = (int)pjix->dwRpos - uMid;
		if(iRPos > (int)uMid/2)
			lZone = 2;
		else if(iRPos < -(int)uMid/2)
			lZone = 1;
	}
	else
	{
		_ASSERTE(FALSE);
		return E_UNEXPECTED;
	}

	//_RPT0(_CRT_WARN, "*********CJoyInfoExDualZoneIndicatorItem::SetItemState()****************\n");
	//_RPT1(_CRT_WARN, "\tdwXpos = %d\n", pjix->dwXpos);
	//_RPT1(_CRT_WARN, "\tdwYpos = %d\n", pjix->dwYpos);
	//_RPT1(_CRT_WARN, "\t====> lZone = %d\n", lZone);
	//_RPT0(_CRT_WARN, "************************************************************************\n");

	// set the raw POV data
	SetActiveZone(lZone);

	// success
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\listasarray.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_LISTASARRAY_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ListAsArray.cpp	|
*
*	Implementation of CListAsArray
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ListAsArray	|
*
**********************************************************************/

CListAsArray::CListAsArray() : 
	m_ulListAllocSize(0),
	m_ulListUsedSize(0),
	m_DefaultPoolType(PagedPool),
	m_pList(NULL),
	m_pfnDeleteFunc(NULL)
	{}

CListAsArray::~CListAsArray()
{
	//
	//	delete array and contents if allocated
	//
	if( m_ulListAllocSize )
	{
		ASSERT( m_ulListUsedSize <= m_ulListAllocSize );
		for(ULONG ulIndex = 0; ulIndex < m_ulListUsedSize; ulIndex++)
		{
			//
			//	If a delete function was set, then use it
			//
			if( m_pfnDeleteFunc )
			{
				m_pfnDeleteFunc( m_pList[ulIndex] );
			}
			//
			//	Otherwise assume that it is OK to use the global delete.
			//
			else
			{
				delete m_pList[ulIndex];
				m_pList[ulIndex] = NULL;
			}
		}

		//
		//	Delete the array itself
		//
		DualMode::DeallocateArray<PVOID>(m_pList);
	}
}

HRESULT	CListAsArray::SetAllocSize(ULONG ulSize, POOL_TYPE PoolType)
{
	m_DefaultPoolType = PoolType;

	//
	//	if the currently allocated size is greater than or less than
	//	requested size return true. (mission accomplished).
	//	DEBUG assert as client probably didn't intend this,
	//	but may have.
	//
	if( m_ulListAllocSize >= ulSize )
	{
		ASSERT(FALSE);
		return S_OK;
	}

	//
	//	Try to allocate memory
	//
	PVOID *pTempList = DualMode::AllocateArray<PVOID>(m_DefaultPoolType, ulSize);

	//
	//	If allocation failed return FALSE, and DEBUG assert
	//
	if( !pTempList )
	{
		ASSERT(pTempList);
		return E_OUTOFMEMORY;
	}

	//
	//	If it was previously allocated move contents of old
	//	array and delete the old one
	//
	if( m_ulListAllocSize )
	{
		ASSERT( m_ulListUsedSize <= m_ulListAllocSize );
		for(ULONG ulIndex = 0; ulIndex < m_ulListUsedSize; ulIndex++)
		{
			pTempList[ulIndex] = m_pList[ulIndex];
		}
		DualMode::DeallocateArray<PVOID>(m_pList);
	}	
	
	//
	//	Store Temp List as new list
	//
	m_pList = pTempList;
	m_ulListAllocSize = ulSize;
	return S_OK;
}

PVOID	CListAsArray::Get(ULONG ulIndex) const
{
	ASSERT( ulIndex < m_ulListUsedSize );
	if(	!(ulIndex < m_ulListUsedSize) )
	{
		return NULL;
	}
	return m_pList[ulIndex];
}

HRESULT	CListAsArray::Add(PVOID pItem)
{
	HRESULT hr;
	//
	//	Check that there is room, if not double allocated size
	//
	if( !(m_ulListUsedSize < m_ulListAllocSize) )
	{
		hr = SetAllocSize(m_ulListAllocSize*2, m_DefaultPoolType);
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	//
	//	Now add item
	//
	m_pList[m_ulListUsedSize++] = pItem;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\keyboardxfer.cpp ===
//	@doc
/**********************************************************************
*
*	@module	KeyboardXfer.cpp	|
*
*	Implements MakeKeyboardXfer
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	KeyboardXfer	|
*			This module implements access function for Keyboard data in
*			CONTROL_ITEM_XFER packets.  At this time, there is only one:
*			<f MakeKeyboardXfer>.
**********************************************************************/
#include "stdhdrs.h"
#include "scancodedefines.h"

//
// Define the Keyboard usages
// Unfortunately, HIDUSAGE.H, included as part of the Win98 and Win2k
// DDK's. contains only a subset of these codes.  Thus we will define them
// all here. With a slight name change.  HID_USAGE_INDEX_ is used
// instead of HID USAGE, which makes sense, since these are really
// an 8 bit index into a 16-bit USAGE with a base of 0.  Notice that the
// entries in HIDUSAGE.H are cast to type USAGE.  For us, we prefer that they
// are naturally UCHARS.  (See discussion on Selectors in HID spec. for more
// info).
//

//  Technically they are all 16 bit usages.  However, all these
// usages are only 8 bits long, and furthermore our CONTROL_ITEM_XFER only
// stores an 8 bit offset from a range of usages starting with zero.
// Thus for our purposes it makes sense to make this byte long.
//
// The HID spec does not provide good identifier names.  I followed the notation in HIDUSAGE.H
// as much as possible.  However, I arbitrarily named many keys after only one of its functions.  For
// example, "Keyboard , and <" is called HID_USAGE_INDEX_KEYBOARD_COMMA.


#define HID_USAGE_INDEX_KEYBOARD_NOEVENT		0x00
#define HID_USAGE_INDEX_KEYBOARD_ROLLOVER		0x01
#define HID_USAGE_INDEX_KEYBOARD_POSTFAIL		0x02
#define HID_USAGE_INDEX_KEYBOARD_UNDEFINED		0x03
		// Letters
#define HID_USAGE_INDEX_KEYBOARD_aA				0x04
#define HID_USAGE_INDEX_KEYBOARD_bB				0x05
#define HID_USAGE_INDEX_KEYBOARD_cC				0x06
#define HID_USAGE_INDEX_KEYBOARD_dD				0x07
#define HID_USAGE_INDEX_KEYBOARD_eE				0x08
#define HID_USAGE_INDEX_KEYBOARD_fF				0x09
#define HID_USAGE_INDEX_KEYBOARD_gG				0x0A
#define HID_USAGE_INDEX_KEYBOARD_hH				0x0B
#define HID_USAGE_INDEX_KEYBOARD_iI				0x0C
#define HID_USAGE_INDEX_KEYBOARD_jJ				0x0D
#define HID_USAGE_INDEX_KEYBOARD_kK				0x0E
#define HID_USAGE_INDEX_KEYBOARD_lL				0x0F
#define HID_USAGE_INDEX_KEYBOARD_mM				0x10
#define HID_USAGE_INDEX_KEYBOARD_nN				0x11
#define HID_USAGE_INDEX_KEYBOARD_oO				0x12
#define HID_USAGE_INDEX_KEYBOARD_pP				0x13
#define HID_USAGE_INDEX_KEYBOARD_qQ				0x14
#define HID_USAGE_INDEX_KEYBOARD_rR				0x15
#define HID_USAGE_INDEX_KEYBOARD_sS				0x16
#define HID_USAGE_INDEX_KEYBOARD_tT				0x17
#define HID_USAGE_INDEX_KEYBOARD_uU				0x18
#define HID_USAGE_INDEX_KEYBOARD_vV				0x19
#define HID_USAGE_INDEX_KEYBOARD_wW				0x1A
#define HID_USAGE_INDEX_KEYBOARD_xX				0x1B
#define HID_USAGE_INDEX_KEYBOARD_yY				0x1C
#define HID_USAGE_INDEX_KEYBOARD_zZ				0x1D
        // Numbers
#define HID_USAGE_INDEX_KEYBOARD_ONE			0x1E
#define HID_USAGE_INDEX_KEYBOARD_TWO			0x1F
#define HID_USAGE_INDEX_KEYBOARD_THREE			0x20
#define HID_USAGE_INDEX_KEYBOARD_FOUR			0x21
#define HID_USAGE_INDEX_KEYBOARD_FIVE			0x22
#define HID_USAGE_INDEX_KEYBOARD_SIX			0x23
#define HID_USAGE_INDEX_KEYBOARD_SEVEN			0x24
#define HID_USAGE_INDEX_KEYBOARD_EIGHT			0x25
#define HID_USAGE_INDEX_KEYBOARD_NINE			0x26
#define HID_USAGE_INDEX_KEYBOARD_ZERO			0x27
		//Editing Keys
#define HID_USAGE_INDEX_KEYBOARD_RETURN			0x28
#define HID_USAGE_INDEX_KEYBOARD_ESCAPE			0x29
#define HID_USAGE_INDEX_KEYBOARD_BACKSPACE		0x2A //HID spec calls this "delete(backspace)", what we later call delete HID calls "delete forward"
#define HID_USAGE_INDEX_KEYBOARD_TAB			0x2B
#define HID_USAGE_INDEX_KEYBOARD_SPACEBAR		0x2C
#define HID_USAGE_INDEX_KEYBOARD_MINUS			0x2D
#define HID_USAGE_INDEX_KEYBOARD_EQUALS			0x2E
#define HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE		0x2F
#define HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE	0x30
#define HID_USAGE_INDEX_KEYBOARD_BACKSLASH		0x31
#define HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE	0x32
#define HID_USAGE_INDEX_KEYBOARD_COLON			0x33
#define HID_USAGE_INDEX_KEYBOARD_QUOTE			0x34
#define HID_USAGE_INDEX_KEYBOARD_TILDE			0x35
#define HID_USAGE_INDEX_KEYBOARD_COMMA			0x36
#define HID_USAGE_INDEX_KEYBOARD_PERIOD			0x37
#define HID_USAGE_INDEX_KEYBOARD_QUESTION		0x38
#define HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK		0x39
        // Funtion keys
#define HID_USAGE_INDEX_KEYBOARD_F1				0x3A
#define HID_USAGE_INDEX_KEYBOARD_F2				0x3B
#define HID_USAGE_INDEX_KEYBOARD_F3				0x3C
#define HID_USAGE_INDEX_KEYBOARD_F4				0x3D
#define HID_USAGE_INDEX_KEYBOARD_F5				0x3E
#define HID_USAGE_INDEX_KEYBOARD_F6				0x3F
#define HID_USAGE_INDEX_KEYBOARD_F7				0x40
#define HID_USAGE_INDEX_KEYBOARD_F8				0x41
#define HID_USAGE_INDEX_KEYBOARD_F9				0x42
#define HID_USAGE_INDEX_KEYBOARD_F10			0x43
#define HID_USAGE_INDEX_KEYBOARD_F11			0x44
#define HID_USAGE_INDEX_KEYBOARD_F12			0x45
		//More Edit Keys
#define HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN	0x46
#define HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK	0x47
#define HID_USAGE_INDEX_KEYBOARD_PAUSE			0x48
#define HID_USAGE_INDEX_KEYBOARD_INSERT			0x49
#define HID_USAGE_INDEX_KEYBOARD_HOME			0x4A
#define HID_USAGE_INDEX_KEYBOARD_PAGE_UP		0x4B
#define HID_USAGE_INDEX_KEYBOARD_DELETE			0x4C	//HID spec, DELETE FORWARD, DELETE is used for backspace
#define HID_USAGE_INDEX_KEYBOARD_END			0x4D
#define HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN		0x4E
#define HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW	0x4F
#define HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW		0x50
#define HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW		0x51
#define HID_USAGE_INDEX_KEYBOARD_UP_ARROW		0x52			
#define HID_USAGE_INDEX_KEYPAD_NUM_LOCK			0x53
#define HID_USAGE_INDEX_KEYPAD_BACKSLASH		0x54
#define HID_USAGE_INDEX_KEYPAD_ASTERICK			0x55
#define HID_USAGE_INDEX_KEYPAD_MINUS			0x56
#define HID_USAGE_INDEX_KEYPAD_PLUS				0x57
#define HID_USAGE_INDEX_KEYPAD_ENTER			0x58
#define HID_USAGE_INDEX_KEYPAD_ONE				0x59
#define HID_USAGE_INDEX_KEYPAD_TWO				0x5A
#define HID_USAGE_INDEX_KEYPAD_THREE			0x5B
#define HID_USAGE_INDEX_KEYPAD_FOUR				0x5C
#define HID_USAGE_INDEX_KEYPAD_FIVE				0x5D
#define HID_USAGE_INDEX_KEYPAD_SIX				0x5E
#define HID_USAGE_INDEX_KEYPAD_SEVEN			0x5F
#define HID_USAGE_INDEX_KEYPAD_EIGHT			0x60
#define HID_USAGE_INDEX_KEYPAD_NINE				0x61
#define HID_USAGE_INDEX_KEYPAD_ZERO				0x62
#define HID_USAGE_INDEX_KEYPAD_DECIMAL			0x63
#define HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH	0x64
#define HID_USAGE_INDEX_KEYBOARD_APPLICATION	0x65	//This is the Windows(R)TM Key
#define HID_USAGE_INDEX_KEYBOARD_POWER			0x66	//Not on standard 101 or 104
#define HID_USAGE_INDEX_KEYPAD_EQUALS			0x67	//Not on standard 101 or 104

//Bunch o' function keys not on supported keyboards
#define HID_USAGE_INDEX_KEYBOARD_F13			0x68
#define HID_USAGE_INDEX_KEYBOARD_F14			0x69
#define HID_USAGE_INDEX_KEYBOARD_F15			0x6A
#define HID_USAGE_INDEX_KEYBOARD_F16			0x6B
#define HID_USAGE_INDEX_KEYBOARD_F17			0x6C
#define HID_USAGE_INDEX_KEYBOARD_F18			0x6D
#define HID_USAGE_INDEX_KEYBOARD_F19			0x6E
#define HID_USAGE_INDEX_KEYBOARD_F20			0x6F
#define HID_USAGE_INDEX_KEYBOARD_F21			0x70
#define HID_USAGE_INDEX_KEYBOARD_F22			0x71
#define HID_USAGE_INDEX_KEYBOARD_F23			0x72
#define HID_USAGE_INDEX_KEYBOARD_F24			0x73

//More unsupported usages
#define HID_USAGE_INDEX_KEYBOARD_EXECUTE		0x74
#define HID_USAGE_INDEX_KEYBOARD_HELP			0x75
#define HID_USAGE_INDEX_KEYBOARD_MENU			0x76
#define HID_USAGE_INDEX_KEYBOARD_SELECT			0x77
#define HID_USAGE_INDEX_KEYBOARD_STOP			0x78
#define HID_USAGE_INDEX_KEYBOARD_AGAIN			0x79
#define HID_USAGE_INDEX_KEYBOARD_UNDO			0x7A
#define HID_USAGE_INDEX_KEYBOARD_CUT			0x7B
#define HID_USAGE_INDEX_KEYBOARD_COPY			0x7C
#define HID_USAGE_INDEX_KEYBOARD_PASTE			0x7D
#define HID_USAGE_INDEX_KEYBOARD_FIND			0x7E
#define HID_USAGE_INDEX_KEYBOARD_MUTE			0x7F
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_UP		0x80
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN	0x81
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS	0x82 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM	0x83 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL	0x84 //sent as a toggle, see HID USAGE Tables spec

//Stuff that we use on foreign keyboards, some needed, some not
#define HID_USAGE_INDEX_KEYPAD_COMMA			0x85 //According to HID usage table 1.1rc3 2/16/99, use for Brazilian keypad "."
#define HID_USAGE_INDEX_KEYPAD_EQUALS_AS400		0x86 //Only As\400, so we don't need to worry.
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1 0x87 //Brazilian forward slash "/", and Japanese backslash slash
#define HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2 0x88 //Picture looks like Hiragana according to Emi
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3 0x89 //Picture looks like Yen
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4 0x8A //Picture looks like Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5 0x8B //Picture looks like Mu-Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6 0x8C
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7 0x8D //Single byte/double byte toggle
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8 0x8E //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9 0x8F //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_LANG1			0x90 //Hangul/English
#define HID_USAGE_INDEX_KEYBOARD_LANG2			0x91 //Hanja conversion key
#define HID_USAGE_INDEX_KEYBOARD_LANG3			0x92 //Katakana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG4			0x93 //Hiragana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG5			0x94 //Defines the Zenkaku/Hankaku key for Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG6			0x95 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG7			0x96 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG8			0x97 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG9			0x98 //reserved for IME


// . . .
// Modifier Keys
#define HID_USAGE_INDEX_KEYBOARD_LCTRL			0xE0
#define HID_USAGE_INDEX_KEYBOARD_LSHFT			0xE1
#define HID_USAGE_INDEX_KEYBOARD_LALT			0xE2
#define HID_USAGE_INDEX_KEYBOARD_LGUI			0xE3
#define HID_USAGE_INDEX_KEYBOARD_RCTRL			0xE4
#define HID_USAGE_INDEX_KEYBOARD_RSHFT			0xE5
#define HID_USAGE_INDEX_KEYBOARD_RALT			0xE6
#define HID_USAGE_INDEX_KEYBOARD_RGUI			0xE7

//
//	The following table has each of our keyboard "USAGES"
//	(see note above on we these are UCHAR's) at the index
//	corresponding to their scan code.  Note there is always
//	a one-to-one correspondence between scan code and USAGE.
//	This table only works for one byte scan codes.  Scan codes
//	beginning with E0 have a second byte.  The next table
//	is used for those.  This table has 83 keys.
//
UCHAR XlateScanCodeToUsageTable[] =
{
/*SCANCODE*/	/*HID USAGE*/
/*0x00*/		HID_USAGE_INDEX_KEYBOARD_NOEVENT, //SCAN CODE ZERO IS UNUSED
/*0x01*/		HID_USAGE_INDEX_KEYBOARD_ESCAPE,
/*0x02*/		HID_USAGE_INDEX_KEYBOARD_ONE,
/*0x03*/		HID_USAGE_INDEX_KEYBOARD_TWO,
/*0x04*/		HID_USAGE_INDEX_KEYBOARD_THREE,
/*0x05*/		HID_USAGE_INDEX_KEYBOARD_FOUR,
/*0x06*/		HID_USAGE_INDEX_KEYBOARD_FIVE,
/*0x07*/		HID_USAGE_INDEX_KEYBOARD_SIX,
/*0x08*/		HID_USAGE_INDEX_KEYBOARD_SEVEN,
/*0x09*/		HID_USAGE_INDEX_KEYBOARD_EIGHT,
/*0x0A*/		HID_USAGE_INDEX_KEYBOARD_NINE,
/*0x0B*/		HID_USAGE_INDEX_KEYBOARD_ZERO,
/*0x0C*/		HID_USAGE_INDEX_KEYBOARD_MINUS,
/*0x0D*/		HID_USAGE_INDEX_KEYBOARD_EQUALS,
/*0x0E*/		HID_USAGE_INDEX_KEYBOARD_BACKSPACE,
/*0x0F*/		HID_USAGE_INDEX_KEYBOARD_TAB,
/*0x10*/		HID_USAGE_INDEX_KEYBOARD_qQ,
/*0x11*/		HID_USAGE_INDEX_KEYBOARD_wW,
/*0x12*/		HID_USAGE_INDEX_KEYBOARD_eE,
/*0x13*/		HID_USAGE_INDEX_KEYBOARD_rR,
/*0x14*/		HID_USAGE_INDEX_KEYBOARD_tT,
/*0x15*/		HID_USAGE_INDEX_KEYBOARD_yY,
/*0x16*/		HID_USAGE_INDEX_KEYBOARD_uU,
/*0x17*/		HID_USAGE_INDEX_KEYBOARD_iI,
/*0x18*/		HID_USAGE_INDEX_KEYBOARD_oO,
/*0x19*/		HID_USAGE_INDEX_KEYBOARD_pP,
/*0x1A*/		HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE,
/*0x1B*/		HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE,
/*0x1C*/		HID_USAGE_INDEX_KEYBOARD_RETURN,
/*0x1D*/		HID_USAGE_INDEX_KEYBOARD_LCTRL,
/*0x1E*/		HID_USAGE_INDEX_KEYBOARD_aA,
/*0x1F*/		HID_USAGE_INDEX_KEYBOARD_sS,
/*0x20*/		HID_USAGE_INDEX_KEYBOARD_dD,
/*0x21*/		HID_USAGE_INDEX_KEYBOARD_fF,
/*0x22*/		HID_USAGE_INDEX_KEYBOARD_gG,
/*0x23*/		HID_USAGE_INDEX_KEYBOARD_hH,
/*0x24*/		HID_USAGE_INDEX_KEYBOARD_jJ,
/*0x25*/		HID_USAGE_INDEX_KEYBOARD_kK,
/*0x26*/		HID_USAGE_INDEX_KEYBOARD_lL,
/*0x27*/		HID_USAGE_INDEX_KEYBOARD_COLON,
/*0x28*/		HID_USAGE_INDEX_KEYBOARD_QUOTE,
/*0x29*/		HID_USAGE_INDEX_KEYBOARD_TILDE,
/*0x2A*/		HID_USAGE_INDEX_KEYBOARD_LSHFT,
/*0x2B*/		HID_USAGE_INDEX_KEYBOARD_BACKSLASH,
/*0x2C*/		HID_USAGE_INDEX_KEYBOARD_zZ,
/*0x2D*/		HID_USAGE_INDEX_KEYBOARD_xX,
/*0x2E*/		HID_USAGE_INDEX_KEYBOARD_cC,
/*0x2F*/		HID_USAGE_INDEX_KEYBOARD_vV,
/*0x30*/		HID_USAGE_INDEX_KEYBOARD_bB,
/*0x31*/		HID_USAGE_INDEX_KEYBOARD_nN,
/*0x32*/		HID_USAGE_INDEX_KEYBOARD_mM,
/*0x33*/		HID_USAGE_INDEX_KEYBOARD_COMMA,
/*0x34*/		HID_USAGE_INDEX_KEYBOARD_PERIOD,
/*0x35*/		HID_USAGE_INDEX_KEYBOARD_QUESTION,
/*0x36*/		HID_USAGE_INDEX_KEYBOARD_RSHFT,
/*0x37*/		HID_USAGE_INDEX_KEYPAD_ASTERICK,  //Print screen, but it always comes with EO (for some reason Mitch had printscreen)
/*0x38*/		HID_USAGE_INDEX_KEYBOARD_LALT,
/*0x39*/		HID_USAGE_INDEX_KEYBOARD_SPACEBAR,
/*0x3A*/		HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK,
/*0x3B*/		HID_USAGE_INDEX_KEYBOARD_F1,
/*0x3C*/		HID_USAGE_INDEX_KEYBOARD_F2,
/*0x3D*/		HID_USAGE_INDEX_KEYBOARD_F3,
/*0x3E*/		HID_USAGE_INDEX_KEYBOARD_F4,
/*0x3F*/		HID_USAGE_INDEX_KEYBOARD_F5,
/*0x40*/		HID_USAGE_INDEX_KEYBOARD_F6,
/*0x41*/		HID_USAGE_INDEX_KEYBOARD_F7,
/*0x42*/		HID_USAGE_INDEX_KEYBOARD_F8,
/*0x43*/		HID_USAGE_INDEX_KEYBOARD_F9,
/*0x44*/		HID_USAGE_INDEX_KEYBOARD_F10,
/*0x45*/		HID_USAGE_INDEX_KEYPAD_NUM_LOCK,
/*0x46*/		HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK,
/*0x47*/		HID_USAGE_INDEX_KEYPAD_SEVEN,			//a.k.a. HOME on Keypad
/*0x48*/		HID_USAGE_INDEX_KEYPAD_EIGHT,			//a.k.a. UP ARROW on Keypad
/*0x49*/		HID_USAGE_INDEX_KEYPAD_NINE,			//a.k.a. PAGE UP on Keypad
/*0x4A*/		HID_USAGE_INDEX_KEYPAD_MINUS,			//a.k.a. GREY - on Keypad
/*0x4B*/		HID_USAGE_INDEX_KEYPAD_FOUR,			//a.k.a. LEFT ARROW on Keypad
/*0x4C*/		HID_USAGE_INDEX_KEYPAD_FIVE,			//a.k.a. CENTER on Keypad
/*0x4D*/		HID_USAGE_INDEX_KEYPAD_SIX,			//a.k.a. RIGHT on Keypad
/*0x4E*/		HID_USAGE_INDEX_KEYPAD_PLUS,			//a.k.a. GREY + on Keypad
/*0x4F*/		HID_USAGE_INDEX_KEYPAD_ONE,			//a.k.a. END on Keypad
/*0x50*/		HID_USAGE_INDEX_KEYPAD_TWO,			//a.k.a. DOWN ARROW on Keypad
/*0x51*/		HID_USAGE_INDEX_KEYPAD_THREE,			//a.k.a. PAGE DOWN on Keypad
/*0x52*/		HID_USAGE_INDEX_KEYPAD_ZERO,			//a.k.a. INSERT on Keypad
/*0x53*/		HID_USAGE_INDEX_KEYPAD_DECIMAL,		//a.k.a. DELETE on Keypad
/*0x54*/		0x00,
/*0x55*/		0x00,
/*0x56*/		HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH,
/*0x57*/		HID_USAGE_INDEX_KEYBOARD_F11,
/*0x58*/		HID_USAGE_INDEX_KEYBOARD_F12,
};


UCHAR XlateScanCodeToUsageTable2[] =
{
/*0x70*/		HID_USAGE_INDEX_KEYBOARD_LANG4,	//Hiragana
/*0x71*/		0x00,
/*0x72*/		0x00,
/*0x73*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1, //Brazilian forward slash
/*0x74*/		0x00,
/*0x75*/		0x00,
/*0x76*/		0x00,
/*0x77*/		0x00,
/*0x78*/		0x00,
/*0x79*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4, //Japanese Henkan
/*0x7A*/		0x00,
/*0x7B*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5, //Japanese Mu-Henkan 
/*0x7C*/		0x00,
/*0x7D*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3, //Japanese Yen
/*0x7E*/		HID_USAGE_INDEX_KEYPAD_COMMA			 //Brazilian Number Pad "."
};

//The keys in this table appear only on extended (101 and 104 key, keyboards).
//These are two byte scan codes, where the first byte is 0xE0
struct EXT_SC_2_USAGE_ENTRY
{
	UCHAR	ucScanCodeLowByte;	//Low Byte of Extended Scan Code (High Byte is 0xE0
	UCHAR	ucHidUsageIndex;	//0 biased index to HID USAGE
};
EXT_SC_2_USAGE_ENTRY XlateExtendedScanCodeToUsageTable[] =
{
	{0x1C,	HID_USAGE_INDEX_KEYPAD_ENTER},
	{0x1D,	HID_USAGE_INDEX_KEYBOARD_RCTRL},
	//0x1E
	//	. . .
	//0x34
	{0x35,	HID_USAGE_INDEX_KEYPAD_BACKSLASH},
	//0x36
	{0x37,	HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN},
	{0x38,	HID_USAGE_INDEX_KEYBOARD_RALT},
	//0x39
	//. . .
	//0x44
	{0x45,	HID_USAGE_INDEX_KEYPAD_NUM_LOCK},
	//0x46
	{0x47,	HID_USAGE_INDEX_KEYBOARD_HOME},
	{0x48,	HID_USAGE_INDEX_KEYBOARD_UP_ARROW},
	{0x49,	HID_USAGE_INDEX_KEYBOARD_PAGE_UP},
	//0x4A
	{0x4B,	HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW},
	//0x4C
	{0x4D,	HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW},
	//0x4E
	{0x4F,	HID_USAGE_INDEX_KEYBOARD_END},
	{0x50,	HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW},
	{0x51,	HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN},
	{0x52,	HID_USAGE_INDEX_KEYBOARD_INSERT},
	{0x53,	HID_USAGE_INDEX_KEYBOARD_DELETE},
	{0x00,	0x00}	//terminates table
};


#define HIGHBYTEi2(__X__) (UCHAR)(__X__>>8)		//Acts on USHORT (2 byte integer)
#define LOWBYTEi2(__X__) (UCHAR)(__X__&0x00FF)	//Acts on USHORT (2 byte integer)

/***********************************************************************************
**
**	void NonGameDeviceXfer::MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, ULONG ulScanCodeCount, const PUSHORT pusScanCodes)
**
**	@mfunc	Converts an array of scancodes into a ControlItemXfer for a keyboard.
**
**	@rdesc	None
**
*************************************************************************************/
void NonGameDeviceXfer::MakeKeyboardXfer
(
	CONTROL_ITEM_XFER& rControlItemXfer,	// @parm [out] caller allocated ControlItemXfer which is initialized by routine
	ULONG ulScanCodeCount,				// @parm [in] Count of Scan codes in Array
	const USHORT* pusScanCodes				// @parm [in] Pointer to array of scan codes
)
{
	
	//Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));

	//This routine only supports up to six scan codes
	ASSERT(ulScanCodeCount <= c_ulMaxXFerKeys);
	
	UCHAR ucUsageIndex;
	ULONG ulKeyArrayIndex = 0;
	
	//Mark as Keyboard CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	
	//Start with no modifier keys down
	rControlItemXfer.Keyboard.ucModifierByte = 0;
	
	//Loop over all scan codes
	for(ULONG ulScanCodeIndex = 0; ulScanCodeIndex < ulScanCodeCount; ulScanCodeIndex++)
	{
		//Check High Byte to determine which table
		if( 0xE0 == HIGHBYTEi2(pusScanCodes[ulScanCodeIndex]) )
		{
			//Use Extended keytable - need a search algorithm rather than direct lookup
			UCHAR ucScanCodeLowByte = LOWBYTEi2(pusScanCodes[ulScanCodeIndex]);
			ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
			//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
			for(ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
			{
				if( XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
				{
					ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
					break;
				}
			}
			ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
		}
		else
		{
			//Use Main Lookup table
			ASSERT( 0x7E >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&
					0x54 != LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&
					0x55 != LOWBYTEi2(pusScanCodes[ulScanCodeIndex])
					);
			if( 0x58 >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) )
			{
				ucUsageIndex = XlateScanCodeToUsageTable[ LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) ];
			}
			//Try lookup table 2
			else if( 
					0x70 <= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&	
					0x7E >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) 
				)
			{
				ucUsageIndex = XlateScanCodeToUsageTable2[ LOWBYTEi2(pusScanCodes[ulScanCodeIndex])-0x70 ];
			}
			else
			{
				ucUsageIndex = 0x00;
			}
		}
		//Check if USAGE is a special one that belongs in modifier byte
		if(0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
		{
			//Set bit in modifier byte
			UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
			rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
		}
		else
		//otherwise add to array of down keys
		{
			rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = ucUsageIndex;
		}
	}//end of loop over scan codes
	
	//Clean up unused spots in rgucKeysDownArray
	while(ulKeyArrayIndex < c_ulMaxXFerKeys)
	{
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = HID_USAGE_INDEX_KEYBOARD_NOEVENT;
	}
}

void NonGameDeviceXfer::MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent)
{
	//This routine only supports up to six scan codes
	ASSERT(rKeyEvent.uCount <= c_ulMaxXFerKeys);

	UCHAR ucUsageIndex;
	ULONG ulKeyArrayIndex = 0;

	//Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));
	
	//Mark as Keyboard CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	
	//Start with no modifier keys down
	rControlItemXfer.Keyboard.ucModifierByte = 0;
	
	//Loop over all scan codes
	for(ULONG ulScanCodeIndex = 0; ulScanCodeIndex < rKeyEvent.uCount; ulScanCodeIndex++)
	{
		WORD wScanCode = rKeyEvent.KeyStrokes[ulScanCodeIndex].wScanCode;

		//Check High Byte to determine which table
		if( 0xE0 == HIGHBYTEi2(wScanCode) )
		{
			//Use Extended keytable - need a search algorithm rather than direct lookup
			UCHAR ucScanCodeLowByte = LOWBYTEi2(wScanCode);
			ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
			//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
			for(ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
			{
				if( XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
				{
					ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
					break;
				}
			}
			ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
		}
		else
		{
			//Use Main Lookup table
			ASSERT( 0x53 >= LOWBYTEi2(wScanCode) || 0x56 == LOWBYTEi2(wScanCode));
			ucUsageIndex = XlateScanCodeToUsageTable[ LOWBYTEi2(wScanCode) ];
		}
		//Check if USAGE is a special one that belongs in modifier byte
		if(0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
		{
			//Set bit in modifier byte
			UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
			rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
		}
		else
		//otherwise add to array of down keys
		{
			rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = ucUsageIndex;
		}
	}//end of loop over scan codes
	
	//Clean up unused spots in rgucKeysDownArray
	while(ulKeyArrayIndex < c_ulMaxXFerKeys)
	{
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = HID_USAGE_INDEX_KEYBOARD_NOEVENT;
	}
}


void NonGameDeviceXfer::AddScanCodeToXfer(CONTROL_ITEM_XFER& rControlItemXfer, WORD wScanCode)
{
	// Is the xfer event a keyboard one?
	_ASSERTE(rControlItemXfer.ulItemIndex == NonGameDeviceXfer::ulKeyboardIndex);
	if (rControlItemXfer.ulItemIndex != NonGameDeviceXfer::ulKeyboardIndex)
	{
		return;
	}

	UCHAR ucUsageIndex;

	//Check High Byte to determine which table
	if (0xE0 == HIGHBYTEi2(wScanCode))
	{
		//Use Extended keytable - need a search algorithm rather than direct lookup
		UCHAR ucScanCodeLowByte = LOWBYTEi2(wScanCode);
		ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
		//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
		for (ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
		{
			if (XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
			{
				ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
				break;
			}
		}
		ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
	}
	else
	{	//Use Main Lookup table
		ASSERT (0x53 >= LOWBYTEi2(wScanCode) || 0x56 == LOWBYTEi2(wScanCode));
		ucUsageIndex = XlateScanCodeToUsageTable[LOWBYTEi2(wScanCode)];
	}

	// Check if USAGE is a special one that belongs in modifier byte
	if (0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
	{	//Set bit in modifier byte
		UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
		rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
	}
	else
	{	//otherwise add to array of down keys
		ULONG ulKeyArrayIndex = 0;
		while (rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex] != HID_USAGE_INDEX_KEYBOARD_NOEVENT)
		{
			if (ulKeyArrayIndex >= c_ulMaxXFerKeys)
			{
				return;		// There is no space left
			}
			ulKeyArrayIndex++;
		}
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex] = ucUsageIndex;
	}
}


USHORT XlateUsageToScanCodeTable[] =
{

/*HID_USAGE_INDEX_KEYBOARD_NOEVENT(0x00)*/
/*HID_USAGE_INDEX_KEYBOARD_ROLLOVER(0x01)*/
/*HID_USAGE_INDEX_KEYBOARD_POSTFAIL(0x02)*/
/*HID_USAGE_INDEX_KEYBOARD_UNDEFINED(0x03)*/
//Due to above four special codes, 4 should be subtracted
//from the usage before lookup
/*HID_USAGE_INDEX_KEYBOARD_aA(0x04)*/				SCANCODE_A,
/*HID_USAGE_INDEX_KEYBOARD_bB(0x05)*/				SCANCODE_B,
/*HID_USAGE_INDEX_KEYBOARD_cC(0x06)*/				SCANCODE_C,
/*HID_USAGE_INDEX_KEYBOARD_dD(0x07)*/				SCANCODE_D,
/*HID_USAGE_INDEX_KEYBOARD_eE(0x08)*/				SCANCODE_E,
/*HID_USAGE_INDEX_KEYBOARD_fF(0x09)*/				SCANCODE_F,
/*HID_USAGE_INDEX_KEYBOARD_gG(0x0A)*/				SCANCODE_G,
/*HID_USAGE_INDEX_KEYBOARD_hH(0x0B)*/				SCANCODE_H,
/*HID_USAGE_INDEX_KEYBOARD_iI(0x0C)*/				SCANCODE_I,
/*HID_USAGE_INDEX_KEYBOARD_jJ(0x0D)*/				SCANCODE_J,
/*HID_USAGE_INDEX_KEYBOARD_kK(0x0E)*/				SCANCODE_K,
/*HID_USAGE_INDEX_KEYBOARD_lL(0x0F)*/				SCANCODE_L,
/*HID_USAGE_INDEX_KEYBOARD_mM(0x10)*/				SCANCODE_M,
/*HID_USAGE_INDEX_KEYBOARD_nN(0x11)*/				SCANCODE_N,
/*HID_USAGE_INDEX_KEYBOARD_oO(0x12)*/				SCANCODE_O,
/*HID_USAGE_INDEX_KEYBOARD_pP(0x13)*/				SCANCODE_P,
/*HID_USAGE_INDEX_KEYBOARD_qQ(0x14)*/				SCANCODE_Q,
/*HID_USAGE_INDEX_KEYBOARD_rR(0x15)*/				SCANCODE_R,
/*HID_USAGE_INDEX_KEYBOARD_sS(0x16)*/				SCANCODE_S,
/*HID_USAGE_INDEX_KEYBOARD_tT(0x17)*/				SCANCODE_T,
/*HID_USAGE_INDEX_KEYBOARD_uU(0x18)*/				SCANCODE_U,
/*HID_USAGE_INDEX_KEYBOARD_vV(0x19)*/				SCANCODE_V,
/*HID_USAGE_INDEX_KEYBOARD_wW(0x1A)*/				SCANCODE_W,
/*HID_USAGE_INDEX_KEYBOARD_xX(0x1B)*/				SCANCODE_X,
/*HID_USAGE_INDEX_KEYBOARD_yY(0x1C)*/				SCANCODE_Y,
/*HID_USAGE_INDEX_KEYBOARD_zZ(0x1D)*/				SCANCODE_Z,
/*HID_USAGE_INDEX_KEYBOARD_ONE(0x1E)*/				SCANCODE_1,
/*HID_USAGE_INDEX_KEYBOARD_TWO(0x1F)*/				SCANCODE_2,
/*HID_USAGE_INDEX_KEYBOARD_THREE(0x20)*/			SCANCODE_3,
/*HID_USAGE_INDEX_KEYBOARD_FOUR(0x21)*/				SCANCODE_4,
/*HID_USAGE_INDEX_KEYBOARD_FIVE(0x22)*/				SCANCODE_5,
/*HID_USAGE_INDEX_KEYBOARD_SIX(0x23)*/				SCANCODE_6,
/*HID_USAGE_INDEX_KEYBOARD_SEVEN(0x24)*/			SCANCODE_7,
/*HID_USAGE_INDEX_KEYBOARD_EIGHT(0x25)*/			SCANCODE_8,
/*HID_USAGE_INDEX_KEYBOARD_NINE(0x26)*/				SCANCODE_9,
/*HID_USAGE_INDEX_KEYBOARD_ZERO(0x27)*/				SCANCODE_0,
/*HID_USAGE_INDEX_KEYBOARD_RETURN(0x28)*/			SCANCODE_RETURN,
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE(0x29)*/			SCANCODE_ESCAPE,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE(0x2A)*/		SCANCODE_BACKSPACE,
/*HID_USAGE_INDEX_KEYBOARD_TAB(0x2B)*/				SCANCODE_TAB,
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR(0x2C)*/			SCANCODE_SPACE,
/*HID_USAGE_INDEX_KEYBOARD_MINUS(0x2D)*/			SCANCODE_MINUS,
/*HID_USAGE_INDEX_KEYBOARD_EQUALS(0x2E)*/			SCANCODE_EQUALS,					
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE(0x2F)*/		SCANCODE_LEFT_BRACKET,		
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE(0x30)*/		SCANCODE_RIGHT_BRACKET,	
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH(0x31)*/		SCANCODE_BACKSLASH,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE(0x32)*/		SCANCODE_BACKSLASH, //NOT SURE, got from hidparse.sys code
/*HID_USAGE_INDEX_KEYBOARD_COLON(0x33)*/			SCANCODE_SEMICOLON,		
/*HID_USAGE_INDEX_KEYBOARD_QUOTE(0x34)*/			SCANCODE_APOSTROPHE,		
/*HID_USAGE_INDEX_KEYBOARD_TILDE(0x35)*/			SCANCODE_TILDE,
/*HID_USAGE_INDEX_KEYBOARD_COMMA(0x36)*/			SCANCODE_COMMA,			
/*HID_USAGE_INDEX_KEYBOARD_PERIOD(0x37)*/			SCANCODE_PERIOD,
/*HID_USAGE_INDEX_KEYBOARD_QUESTION(0x38)*/			SCANCODE_QUESTIONMARK,
/*HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK(0x39)*/		SCANCODE_CAPSLOCK,
/*HID_USAGE_INDEX_KEYBOARD_F1(0x3A)*/				SCANCODE_F1,
/*HID_USAGE_INDEX_KEYBOARD_F2(0x3B)*/				SCANCODE_F2,
/*HID_USAGE_INDEX_KEYBOARD_F3(0x3C)*/				SCANCODE_F3,
/*HID_USAGE_INDEX_KEYBOARD_F4(0x3D)*/				SCANCODE_F4,
/*HID_USAGE_INDEX_KEYBOARD_F5(0x3E)*/				SCANCODE_F5,
/*HID_USAGE_INDEX_KEYBOARD_F6(0x3F)*/				SCANCODE_F6,
/*HID_USAGE_INDEX_KEYBOARD_F7(0x40)*/				SCANCODE_F7,
/*HID_USAGE_INDEX_KEYBOARD_F8(0x41)*/				SCANCODE_F8,
/*HID_USAGE_INDEX_KEYBOARD_F9(0x42)*/				SCANCODE_F9,
/*HID_USAGE_INDEX_KEYBOARD_F10(0x43)*/				SCANCODE_F10,
/*HID_USAGE_INDEX_KEYBOARD_F11(0x44)*/				SCANCODE_F11,
/*HID_USAGE_INDEX_KEYBOARD_F12(0x45)*/				SCANCODE_F12,
/*HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN(0x46)*/		SCANCODE_PRINT_SCREEN,
/*HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK(0x47)*/		SCANCODE_SCROLL_LOCK,
/*HID_USAGE_INDEX_KEYBOARD_PAUSE(0x48)*/			SCANCODE_PAUSE_BREAK,
/*HID_USAGE_INDEX_KEYBOARD_INSERT(0x49)*/			SCANCODE_INSERT,
/*HID_USAGE_INDEX_KEYBOARD_HOME(0x4A)*/				SCANCODE_HOME,	
/*HID_USAGE_INDEX_KEYBOARD_PAGE_UP(0x4B)*/			SCANCODE_PAGE_UP,
/*HID_USAGE_INDEX_KEYBOARD_DELETE(0x4C)*/			SCANCODE_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_END(0x4D)*/				SCANCODE_END,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN(0x4E)*/		SCANCODE_PAGEDOWN,
/*HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW(0x4F)*/		SCANCODE_EAST,
/*HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW(0x50)*/		SCANCODE_WEST,	
/*HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW(0x51)*/		SCANCODE_SOUTH,	
/*HID_USAGE_INDEX_KEYBOARD_UP_ARROW(0x52)*/			SCANCODE_NORTH,
/*HID_USAGE_INDEX_KEYPAD_NUM_LOCK(0x53)*/			SCANCODE_NUMPAD_NUMLOCK,
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH(0x54)*/			SCANCODE_NUMPAD_DIVIDE,	
/*HID_USAGE_INDEX_KEYPAD_ASTERICK(0x55)*/			SCANCODE_NUMPAD_MULTIPLY,
/*HID_USAGE_INDEX_KEYPAD_MINUS(0x56)*/				SCANCODE_NUMPAD_SUBTRACT,
/*HID_USAGE_INDEX_KEYPAD_PLUS(0x57)*/				SCANCODE_NUMPAD_ADD,
/*HID_USAGE_INDEX_KEYPAD_ENTER(0x58)*/				SCANCODE_NUMPAD_ENTER,	
/*HID_USAGE_INDEX_KEYPAD_ONE(0x59)*/				SCANCODE_NUMPAD_1,
/*HID_USAGE_INDEX_KEYPAD_TWO(0x5A)*/				SCANCODE_NUMPAD_2,
/*HID_USAGE_INDEX_KEYPAD_THREE(0x5B)*/				SCANCODE_NUMPAD_3,
/*HID_USAGE_INDEX_KEYPAD_FOUR(0x5C)*/				SCANCODE_NUMPAD_4,
/*HID_USAGE_INDEX_KEYPAD_FIVE(0x5D)*/				SCANCODE_NUMPAD_5,
/*HID_USAGE_INDEX_KEYPAD_SIX(0x5E)*/				SCANCODE_NUMPAD_6,
/*HID_USAGE_INDEX_KEYPAD_SEVEN(0x5F)*/				SCANCODE_NUMPAD_7,
/*HID_USAGE_INDEX_KEYPAD_EIGHT(0x60)*/				SCANCODE_NUMPAD_8,
/*HID_USAGE_INDEX_KEYPAD_NINE(0x61)*/				SCANCODE_NUMPAD_9,
/*HID_USAGE_INDEX_KEYPAD_ZERO(0x62)*/				SCANCODE_NUMPAD_0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL(0x63)*/			SCANCODE_NUMPAD_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH(0x64)*/ SCANCODE_NON_US_BACKSLASH,
/*HID_USAGE_INDEX_KEYBOARD_APPLICATION(0x65)*/		SCANCODE_APPLICATION
/*HID_USAGE_INDEX_KEYBOARD_POWER(0x66)*/			//Not a real key
/*HID_USAGE_INDEX_KEYPAD_EQUALS(0x67)*/				//Not on supported keyboards
};

USHORT XlateUsageToScanCodeTable2[] =
{
/*HID_USAGE_INDEX_KEYPAD_COMMA*/					SCANCODE_BRAZILIAN_PERIOD,
/*HID_USAGE_INDEX_KEYPAD_EQUALS*/					SCANCODE_UNUSED,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1*/			SCANCODE_INTERNATIONAL1,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2*/			SCANCODE_UNUSED,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL3*/			SCANCODE_INTERNATIONAL3,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL4*/			SCANCODE_INTERNATIONAL4,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL5*/			SCANCODE_INTERNATIONAL5
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL6*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL7*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL8*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL9*/			
/*HID_USAGE_INDEX_KEYBOARD_LANG1*/					
/*HID_USAGE_INDEX_KEYBOARD_LANG2*/
/*HID_USAGE_INDEX_KEYBOARD_LANG3*/
/*HID_USAGE_INDEX_KEYBOARD_LANG4*/
/*HID_USAGE_INDEX_KEYBOARD_LANG5*/

};

USHORT XlateUsageModByteToScanCodeTable[] =
{
	/*HID_USAGE_INDEX_KEYBOARD_LCTRL(0xE0)*/	SCANCODE_CTRL_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LSHFT(0xE1)*/	SCANCODE_SHIFT_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LALT(0xE2)*/		SCANCODE_ALT_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LGUI(0xE3)*/		SCANCODE_LEFT_WIN,
	/*HID_USAGE_INDEX_KEYBOARD_RCTRL(0xE4)*/	SCANCODE_CTRL_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RSHFT(0xE5)*/	SCANCODE_SHIFT_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RALT(0xE6)*/		SCANCODE_ALT_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RGUI(0xE7)*/		SCANCODE_RIGHT_WIN
};


/***********************************************************************************
**
**	void NonGameDeviceXfer::ScanCodesFromKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer, ULONG& rulScanCodeCount, PUSHORT pusScanCodes)
**
**	@mfunc	Reads a ControlItemXfer for a keyboard into an array of scan codes.
**
**
*************************************************************************************/
void NonGameDeviceXfer::ScanCodesFromKeyboardXfer
(
	const CONTROL_ITEM_XFER& crControlItemXfer,	// @parm [in] ControlItemXfer to read scan code from
	ULONG& rulScanCodeCount,					// @parm [in\out] Allocated space on entry, count returned on exit
	USHORT* pusScanCodes						// @parm [out] Pointer to array to receive scancode
)
{
	ULONG ulMaxScanCodes;
	ULONG ulIndex;
	ulMaxScanCodes = rulScanCodeCount;
	ASSERT(ulMaxScanCodes > 0);
	if(0==ulMaxScanCodes) return;
	rulScanCodeCount = 0;
	
	//make sure this really contains keyboard data.
	ASSERT( IsKeyboardXfer(crControlItemXfer) );
	if(!IsKeyboardXfer(crControlItemXfer))
			return;
	//Process modifier Byte
	for(ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		ULONG ulMask = (1 << ulIndex);
		if(crControlItemXfer.Keyboard.ucModifierByte & ulMask)
		{
			//lookup scan code
			pusScanCodes[rulScanCodeCount] = XlateUsageModByteToScanCodeTable[ulIndex];
			//move to next free spot in output, return if output is full
			if(ulMaxScanCodes == ++rulScanCodeCount)
				return;
		}
	}
	
	//Process array of up to six keys down first
	for(ulIndex = 0; ulIndex < c_ulMaxXFerKeys; ulIndex++)
	{
		//check main conversion table
		if(
			HID_USAGE_INDEX_KEYBOARD_aA <= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex] &&
			HID_USAGE_INDEX_KEYBOARD_APPLICATION >= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]
		)
		{
			//lookup scan code
			pusScanCodes[rulScanCodeCount] = XlateUsageToScanCodeTable[crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]-4];
			if( SCANCODE_UNUSED == pusScanCodes[rulScanCodeCount]) continue;
		}
		//check secondary table
		else if(
			HID_USAGE_INDEX_KEYPAD_COMMA <= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex] &&
			HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5	>=	crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]
			)
		{
			//lookup scan code in secondary table
			pusScanCodes[rulScanCodeCount] = XlateUsageToScanCodeTable2[crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]-HID_USAGE_INDEX_KEYPAD_COMMA];
			if( SCANCODE_UNUSED == pusScanCodes[rulScanCodeCount]) continue;
		}
		else
		{
			//not a supported key
			continue;
		}
		//move to next free spot in output, return if output is full
		if(ulMaxScanCodes == ++rulScanCodeCount)
			return;
	}
	return;
}

/************** Dealy XFer Functions ***************************/
void NonGameDeviceXfer::MakeDelayXfer(CONTROL_ITEM_XFER& rControlItemXfer, DWORD dwDelay)
{
	// Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));

	// Mark as Delay CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	rControlItemXfer.Delay.dwValue = dwDelay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\joyinfoexcollection.h ===
// @doc
/******************************************************************************
*
* @module JoyInfoExCollection.h |
*
* CControlItemJoyInfoExCollection template class header file
*
* Implements the CControlItemJoyInfoExCollection control item collection class,
* which is used to convert back and forth between JOYINFOEX packets and 
* CONTROL_ITEM_XFER packets.
*
* History<nl>
* ---------------------------------------------------<nl>
* Daniel M. Sangster		Original		2/1/99<nl>
*<nl>
* (c) 1986-1999 Microsoft Corporation.  All rights reserved.<nl>
* <nl>
* 
******************************************************************************/

#ifndef __JoyInfoExCollection_H_
#define __JoyInfoExCollection_H_

#define JOY_FLAGS_PEDALS_NOT_PRESENT	2

/////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExControlItem, which derives virtually from CControlItem, is
// used as the base class for all items in the CControlItemJoyInfoExCollection.
// It has only two pure virtual functions.  GetItemState gets the current state
// of the item into a JOYINFOEX structure.  SetItemState does the opposite.
class CJoyInfoExControlItem : public virtual CControlItem
{
	public:
		CJoyInfoExControlItem();
		
		virtual HRESULT GetItemState(JOYINFOEX* pjix) = 0;
		virtual HRESULT SetItemState(JOYINFOEX* pjix) = 0;
};

///////////////////////////////////////////////////////////////////////////////
// @func ControlItemJoyInfoExFactory is the factory that is required by the
// CControlItemCollection template class to create control items derived from
// CJoyInfoExControlItem.
HRESULT ControlItemJoyInfoExFactory
(
	USHORT usType,
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CJoyInfoExControlItem	**ppControlItem
);

////////////////////////////////////////////////////////////////////////////////////
// @class CControlItemJoyInfoExCollection, which is derived from the template
// class CControlItemCollection, implements a collection of CJoyInfoExControlItems.
// Its two members, GetState2() and SetState2(), will get or set the current
// state of the collection into a JOYINFOEX structure.  Using the GetState()
// and SetState() members of ControlItemCollection, the user can freely convert
// between JOYINFOEX structures and CONTROL_ITEM_XFER structures.
class CControlItemJoyInfoExCollection : public CControlItemCollection<CJoyInfoExControlItem>
{
	public:
		CControlItemJoyInfoExCollection(ULONG ulVidPid);

		HRESULT GetState2(JOYINFOEX* pjix);
		HRESULT SetState2(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExAxesItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CAxesItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExAxesItem : public CJoyInfoExControlItem, public CAxesItem
{
	public:
		CJoyInfoExAxesItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExDPADItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CDPADItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExDPADItem : public CJoyInfoExControlItem, public CDPADItem
{
	public:
		CJoyInfoExDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc);
		
		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPropDPADItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPropDPADItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPropDPADItem : public CJoyInfoExControlItem, public CPropDPADItem
{
	public:
		CJoyInfoExPropDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExButtonsItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CButtonsItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExButtonsItem : public CJoyInfoExControlItem, public CButtonsItem
{
	public:
		CJoyInfoExButtonsItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExProfileSelectorsItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CProfileSelector, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExProfileSelectorsItem : public CJoyInfoExControlItem, public CProfileSelector
{
	public:
		CJoyInfoExProfileSelectorsItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPOVItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPOVItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPOVItem : public CJoyInfoExControlItem, public CPOVItem
{
	public:
		CJoyInfoExPOVItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExThrottleItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CThrottleItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExThrottleItem : public CJoyInfoExControlItem, public CThrottleItem
{
	public:
		CJoyInfoExThrottleItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExRudderItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CRudderItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExRudderItem : public CJoyInfoExControlItem, public CRudderItem
{
	public:
		CJoyInfoExRudderItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExWheelItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CWheelItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExWheelItem : public CJoyInfoExControlItem, public CWheelItem
{
	public:
		CJoyInfoExWheelItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPedalItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPedalItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPedalItem : public CJoyInfoExControlItem, public CPedalItem
{
	public:
		CJoyInfoExPedalItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExDualZoneIndicatorItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CDualZoneIndicatorItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExDualZoneIndicatorItem : public CJoyInfoExControlItem, public CDualZoneIndicatorItem
{
	public:
		CJoyInfoExDualZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\listasarray.h ===
//@doc
#ifndef __ListAsArray_h__
#define __ListAsArray_h__
//	@doc
/**********************************************************************
*
*	@module	ListAsArray.h	|
*
*	Declares class that manages a list of void pointers in terms
*	of a resizable array.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ListAsArray	|
*			For type safety this class really ought to be encapsulated
*			by a template class.  SelectDeleteFunc ought to be used
*			when store objects by a pointer to a  base class that is then
*			cast to void, particularly in mulitple inheretance scenarios
*			as the pointer may not point to the beginning of the block.
*
**********************************************************************/

#include "DualMode.h"
//
//	@class	ListAsArray is used to implement a generic list
//			as an array.  It should compile for kernel or user mode
//
class CListAsArray
{
	public:
		CListAsArray();
		~CListAsArray();
		
		void	SetDeleteFunc( void (*pfnDeleteFunc)(PVOID pItem) )
		{
			m_pfnDeleteFunc = pfnDeleteFunc;
		}
		void	SetDefaultPool( POOL_TYPE PoolType )
		{
			m_DefaultPoolType = PoolType;
		}
		HRESULT	SetAllocSize(ULONG ulSize, POOL_TYPE PoolType = PagedPool);
		inline ULONG	GetItemCount() const { return m_ulListUsedSize; }
		inline ULONG	GetAllocSize() const { return m_ulListAllocSize; }
		PVOID	Get(ULONG ulIndex) const ;
		HRESULT	Add(PVOID pItem);

	private:
		ULONG		m_ulListAllocSize;
		ULONG		m_ulListUsedSize;
		PVOID		*m_pList;
		void		(*m_pfnDeleteFunc)(PVOID pItem);
		POOL_TYPE	m_DefaultPoolType;
};

#endif //__ListAsArray_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\scancodedefines.h ===
#ifndef __SCANCODEDEFINES_H__
#define __SCANCODEDEFINES_H__

// Alphabet
#define SCANCODE_A 0x001E
#define SCANCODE_B 0x0030
#define SCANCODE_C 0x002E
#define SCANCODE_D 0x0020
#define SCANCODE_E 0x0012
#define SCANCODE_F 0x0021
#define SCANCODE_G 0x0022
#define SCANCODE_H 0x0023
#define SCANCODE_I 0x0017
#define SCANCODE_J 0x0024
#define SCANCODE_K 0x0025
#define SCANCODE_L 0x0026
#define SCANCODE_M 0x0032
#define SCANCODE_N 0x0031
#define SCANCODE_O 0x0018
#define SCANCODE_P 0x0019
#define SCANCODE_Q 0x0010
#define SCANCODE_R 0x0013
#define SCANCODE_S 0x001F
#define SCANCODE_T 0x0014
#define SCANCODE_U 0x0016
#define SCANCODE_V 0x002F
#define SCANCODE_W 0x0011
#define SCANCODE_X 0x002D
#define SCANCODE_Y 0x0015
#define SCANCODE_Z 0x002C

// Numbers (non numberpad)
#define SCANCODE_0 0x000B
#define SCANCODE_1 0x0002
#define SCANCODE_2 0x0003
#define SCANCODE_3 0x0004
#define SCANCODE_4 0x0005
#define SCANCODE_5 0x0006
#define SCANCODE_6 0x0007
#define SCANCODE_7 0x0008
#define SCANCODE_8 0x0009
#define SCANCODE_9 0x000A

// Numbers (numberpad)
#define SCANCODE_NUMPAD_0 0x0052
#define SCANCODE_NUMPAD_1 0x004F
#define SCANCODE_NUMPAD_2 0x0050
#define SCANCODE_NUMPAD_3 0x0051
#define SCANCODE_NUMPAD_4 0x004B
#define SCANCODE_NUMPAD_5 0x004C
#define SCANCODE_NUMPAD_6 0x004D
#define SCANCODE_NUMPAD_7 0x0047
#define SCANCODE_NUMPAD_8 0x0048
#define SCANCODE_NUMPAD_9 0x0049

// Numpad non-numbers
#define SCANCODE_NUMPAD_NUMLOCK		0xE045
#define SCANCODE_NUMPAD_DIVIDE		0xE035
#define SCANCODE_NUMPAD_MULTIPLY	0x0037
#define SCANCODE_NUMPAD_SUBTRACT	0x004A
#define SCANCODE_NUMPAD_ADD			0x004E
#define SCANCODE_NUMPAD_ENTER		0xE01C
#define SCANCODE_NUMPAD_DELETE		0x0053

// Function keys
#define SCANCODE_F1		0x003B
#define SCANCODE_F2		0x003C
#define SCANCODE_F3		0x003D
#define SCANCODE_F4		0x003E
#define SCANCODE_F5		0x003F
#define SCANCODE_F6		0x0040
#define SCANCODE_F7		0x0041
#define SCANCODE_F8		0x0042
#define SCANCODE_F9		0x0043
#define SCANCODE_F10	0x0044
#define SCANCODE_F11	0x0057
#define SCANCODE_F12	0x0058

// Direction Arrows
#define SCANCODE_NORTH	0xE048
#define SCANCODE_EAST	0xE04D
#define SCANCODE_SOUTH	0xE050
#define SCANCODE_WEST	0xE04B

// Magic 3
#define SCANCODE_PRINT_SCREEN	0xE037
#define SCANCODE_SCROLL_LOCK	0x0046
#define SCANCODE_PAUSE_BREAK	0x0045  //What should this be?

// Magic 6
#define SCANCODE_INSERT		0xE052
#define SCANCODE_HOME		0xE047
#define SCANCODE_PAGE_UP	0xE049
#define SCANCODE_DELETE		0xE053
#define SCANCODE_END		0xE04F
#define SCANCODE_PAGEDOWN	0xE051

// Modifiers
#define SCANCODE_CTRL_LEFT		0x001D
#define SCANCODE_CTRL_RIGHT		0xE01D
#define SCANCODE_SHIFT_LEFT		0x002A
#define SCANCODE_SHIFT_RIGHT	0x0036
#define SCANCODE_ALT_LEFT		0x0038
#define SCANCODE_ALT_RIGHT		0xE038

// Symbols
#define SCANCODE_PERIOD			0x0034
#define SCANCODE_COMMA			0x0033
#define SCANCODE_LEFT_BRACKET	0x001A
#define SCANCODE_RIGHT_BRACKET	0x001B
#define SCANCODE_EQUALS			0x000D
#define SCANCODE_MINUS			0x000C
#define SCANCODE_SEMICOLON		0x0027
#define SCANCODE_APOSTROPHE		0x0028
#define SCANCODE_TILDE			0x0029
#define SCANCODE_BACKSLASH		0x002B
#define SCANCODE_QUESTIONMARK	0x0035

// Miscellania
#define SCANCODE_SPACE				0x0039
#define SCANCODE_RETURN				0x001C
#define SCANCODE_TAB				0x000F
#define SCANCODE_BACKSPACE			0x000E
#define SCANCODE_CAPSLOCK			0x003A
#define SCANCODE_ESCAPE				0x0001
#define SCANCODE_APPLICATION		0xE05D
#define SCANCODE_LEFT_WIN			0xE05B
#define SCANCODE_RIGHT_WIN			0xE05C
#define SCANCODE_NON_US_BACKSLASH	0x0056

// None english
#define SCANCODE_INTERNATIONAL1		0x0073	//Brazilian forward slash, and Japanese backslash
#define SCANCODE_INTERNATIONAL3		0x007D	//Japanese Yen
#define SCANCODE_INTERNATIONAL4		0x0079	//Japanese Henkan
#define SCANCODE_INTERNATIONAL5		0x007B	//Japanese Mu-Henkan
#define SCANCODE_BRAZILIAN_PERIOD	0x007E	//Brazilian Numpad Period 


#define SCANCODE_UNUSED				0x00FF	//Unused key
#endif	__SCANCODEDEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\stdhdrs.h ===
//	@doc
/**********************************************************************
*
*	@module	stdhdrs.h	|
*
*	Pulls in all the headers needed by most of the modules in the ControlItemCollection library.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*
**********************************************************************/
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
extern "C"	
{
	#include <wdm.h>
	#include <winerror.h>
	#include <Hidpddi.h>
}
#else
#include <windows.h>
#include <crtdbg.h>
extern "C"
{
	#pragma warning( disable : 4201 ) 
	#include "Hidsdi.h"
	#pragma warning( default : 4201 ) 
}

#endif

#include "DualMode.h"

extern "C"
{
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );
}

#include "ListAsArray.h"
#include "ControlItemCollection.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dumpcommandblock.h ===
//When invoked from WDM makefile the debug condition is different
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#undef _NDEBUG
#else
#define _NDEBUG
#endif
#endif

// If not debug the module just makes the three entry points no-ops
#ifdef _NDEBUG
#define CIC_DBG_DumpCommandBlock(_X_)
#define CIC_DBG_SetDumpFunc(_X_)
#define CIC_DBG_InitDumpModule(_X_)
#else
//This module only works in debug mode
#define CIC_DBG_DumpCommandBlock(_X_) DumpCommandBlock _X_
#define CIC_DBG_SetDumpFunc(_X_) SetDumpFunc _X_
#define CIC_DBG_InitDumpModule(_X_) InitDumpModule _X_

#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#define DCB_TRACE(_x_) DbgPrint(_x_)
#else
#define DCB_TRACE(_x_) OutputDebugString(_x_)
#endif

typedef void (*PFNSTRING_DUMP_FUNC)(LPSTR);
//
//	Interface of exported functions
//
void InitDumpModule(ULONG ulVidPid);
void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc);
BOOLEAN DumpCommandBlock(PUCHAR pucBlock, ULONG rulSize);

//
//	Internals - for dumping info from small chuncks.
//
void DumpString(LPSTR lpszDumpString);
BOOLEAN DumpRecurse(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth);
BOOLEAN DumpDirectory(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth);
BOOLEAN DumpAssignmentTarget(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpTimedMacro(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpKeyString(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpMouseFxAxisMap(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpTimedEvent(PTIMED_EVENT pTimedEvent);
BOOLEAN DumpEvent(PEVENT pEvent);
BOOLEAN DumpTriggerXfer(PCONTROL_ITEM_XFER pControlItemXfer);
BOOLEAN DumpEventXfer(PCONTROL_ITEM_XFER pControlItemXfer);
BOOLEAN DumpKeyboardData(PCONTROL_ITEM_XFER pControlItemXfer);

//
//	Dumping Xfers it more complicated and requires a derivative of CControlItemCollection
//

class CDumpItem : public virtual CControlItem
{
	public:
		CDumpItem(){}

		virtual void DumpItemInfo(ULONG ulDumpFlags);

		//
		//	Static functions
		//
		static void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc)
		{
			ms_pfnDumpFunc = pfnDumpFunc;
		}
		static void DumpString(LPSTR lpszDumpString)
		{
			if(NULL == ms_pfnDumpFunc)
			{
				DCB_TRACE(lpszDumpString);
			}
			else
			{
				ms_pfnDumpFunc(lpszDumpString);
			}
		}
	private:
		static PFNSTRING_DUMP_FUNC ms_pfnDumpFunc;
};

class CAxesDump : public CDumpItem, public CAxesItem
{
	public:
		CAxesDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CAxesItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CDPADDump : public CDumpItem, public CDPADItem
{
	public:
		CDPADDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDPADItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
		
};

class CPropDPADDump : public CDumpItem, public CPropDPADItem
{
	public:
		CPropDPADDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPropDPADItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CButtonsDump : public CDumpItem, public CButtonsItem
{
	public:
		CButtonsDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CButtonsItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};
class CPOVDump : public CDumpItem, public CPOVItem
{
	public:
		CPOVDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPOVItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CThrottleDump : public CDumpItem, public CThrottleItem
{
	public:
		CThrottleDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CThrottleItem(cpControlItemDesc)
		{}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CRudderDump : public CDumpItem, public CRudderItem
{
	public:
		CRudderDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CRudderItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};


class CWheelDump : public CDumpItem, public CWheelItem
{
	public:
		CWheelDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CWheelItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CPedalDump : public CDumpItem, public CPedalItem
{
	public:
		CPedalDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPedalItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CZoneIndicatorDump : public CDumpItem, public CZoneIndicatorItem
{
	public:
		CZoneIndicatorDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CZoneIndicatorItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CDualZoneIndicatorDump : public CDumpItem, public CDualZoneIndicatorItem
{
	public:
		CDualZoneIndicatorDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDualZoneIndicatorItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CForceMapDump : public CDumpItem, public CForceMapItem
{
	public:
		CForceMapDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CForceMapItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

//NEWDEVICE
HRESULT	DumpItemFactory
(
	USHORT usType,	
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CDumpItem				**ppControlItem
);

#endif //NOT _NDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\ctrl.c ===
//	@doc
/**********************************************************************
*
*	@module	CTRL.c	|
*
*	Entry points for handling IRPs to the "Control" device object.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CTRL	|
*	The control device object is used for programming GcKernel.
*	The main module, GckShell, delegates IRPs aimed at the control device
*	here.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_CTRL_C

#include <wdm.h>
#include <gckshell.h>
#include "debug.h"

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_CTRL_DriverEntry)
#pragma alloc_text (PAGE, GCK_CTRL_Create)
#pragma alloc_text (PAGE, GCK_CTRL_Close)
#pragma alloc_text (PAGE, GCK_CTRL_Unload)
#endif

//	Allow debug output for this module, and set the intial level
DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Initializing the portions of the driver related to the control device, actually
**			All of this was added to GCK_CTRL_AddDevice, which is called when the first filter
**			device is added.
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
    UNREFERENCED_PARAMETER (puniRegistryPath);
	UNREFERENCED_PARAMETER (pDriverObject);
	
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_DriverEntry\n"));
    
	//
	//	Initialize Globals
	//
	GCK_DBG_TRACE_PRINT(("Initializing CTRL globals\n"));
	Globals.pControlObject = NULL;
	

	GCK_DBG_EXIT_PRINT (("Exiting GCK_CTRL_DriverEntry: STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_AddDevice( IN PDRIVER_OBJECT  pDriverObject )
**
**	@func	Adds a Control Device.  Called from GCK_FLTR_AddDevice when the first
**			Device is added.
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS
GCK_CTRL_AddDevice
(
	IN PDRIVER_OBJECT  pDriverObject
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      pDeviceObject;
	UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
	PGCK_CONTROL_EXT	pControlExt;
        
    PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_AddDevice\n"));
    
	//
    // Create a controlling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //
	RtlInitUnicodeString (&uniNtNameString, GCK_CONTROL_NTNAME);
    NtStatus = IoCreateDevice (
                 pDriverObject,
                 sizeof (GCK_CONTROL_EXT),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &pDeviceObject
                 );

	if(!NT_SUCCESS (NtStatus))
	{
        GCK_DBG_CRITICAL_PRINT (("Couldn't create the device. Status: 0x%0.8x\n", NtStatus));
        return NtStatus ;
    }

    //
    // Create W32 symbolic link name
    //
	GCK_DBG_TRACE_PRINT(("Creating symbolic link\n"));
    RtlInitUnicodeString (&uniWin32NameString, GCK_CONTROL_SYMNAME);
    NtStatus  = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);
    if (!NT_SUCCESS(NtStatus)) 
	{
        GCK_DBG_CRITICAL_PRINT (("Couldn't create the symbolic Status: 0x%0.8x\n", NtStatus));
        IoDeleteDevice (pDeviceObject);
        return NtStatus;
    }
	
	//
	//	Initialize Globals
	//
	GCK_DBG_TRACE_PRINT(("Initializing CTRL globals\n"));
	Globals.pControlObject = pDeviceObject;

	GCK_DBG_TRACE_PRINT(("Initializing Control Device\n"));
	pControlExt = pDeviceObject->DeviceExtension;
	pControlExt->ulGckDevObjType = GCK_DO_TYPE_CONTROL;	//Put our name on this, so we can speak for him later
	pControlExt->lOutstandingIO = 1;		// biassed to 1.  Transition to zero signals Remove event
	Globals.pControlObject->Flags |= DO_BUFFERED_IO;
	Globals.pControlObject->Flags &= ~DO_DEVICE_INITIALIZING;
	
	GCK_DBG_EXIT_PRINT (("Normal exit of GCK_CTRL_AddDevice: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_CTRL_Remove()
**
**	@func	Removes the one and only Control Device.  Called from GCK_FLTR_Remove
**			when all of the Filter devices go away.  This was necessary, as
**			the PnP loader won't unload you if you still have devices around
**			even if they are legacy, and even if it started your driver.
**
**	@rdesc	None
**
*************************************************************************************/
VOID
GCK_CTRL_Remove()
{
	NTSTATUS NtStatus;
	PGCK_CONTROL_EXT	pControlExt;
	UNICODE_STRING      uniWin32NameString;
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Remove\n"));
	if( Globals.pControlObject)
	{
		GCK_DBG_TRACE_PRINT(("Removing Global Control Device\n"));
		
		//BUGBUG
		//BUGBUG  Should be counting outstanding IRPs and blocking here until they
		//BUGBUG  complete, before removing this.
		//BUGBUG

		//Kill the symbolic link we created on open
		RtlInitUnicodeString (&uniWin32NameString, GCK_CONTROL_SYMNAME);
		NtStatus = IoDeleteSymbolicLink(&uniWin32NameString);
		ASSERT( NT_SUCCESS(NtStatus) );
		if( NT_SUCCESS(NtStatus) )
		{
			//Delete the device
			IoDeleteDevice(Globals.pControlObject);
			Globals.pControlObject = NULL;
		}
	}
	GCK_DBG_EXIT_PRINT (("Exiting GCK_CTRL_Remove\n"));
	return;
}


/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE for the control device - Call generated by
**			Win32 API CreateFile or OpenFile.
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	PGCK_CONTROL_EXT	pControlExt;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Create\n"));

	//Cast device extension
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_CONTROL == pControlExt->ulGckDevObjType);
    	
	//free access to control devices
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	
	//Return
	GCK_DBG_EXIT_PRINT(("Exiting GCK_CTRL_Create\n"));	
	return STATUS_SUCCESS;
}	

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE for the control device - Call generated by Win32 API CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	PGCK_CONTROL_EXT	pControlExt;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pFilterDeviceObject;
	PFILE_OBJECT		pFileObject;

	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Close\n"));
	
	//Cast device extension
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
    
	//Get file object from IRP
	pFileObject = IoGetCurrentIrpStackLocation(pIrp)->FileObject;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_CONTROL == pControlExt->ulGckDevObjType);

	//Close Test Mode for any device it was opened for
	//- if it was open by this handle - if it wasn't open this is a no-op
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	pFilterDeviceObject = Globals.pFilterObjectList;
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
	while(pFilterDeviceObject)
	{
		pFilterExt = (PGCK_FILTER_EXT)pFilterDeviceObject->DeviceExtension;
		GCKF_EndTestScheme(pFilterExt, pFileObject);
		ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
		pFilterDeviceObject = pFilterExt->pNextFilterObject;
		ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
	}	

	//free access to control devices
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	//Return
	GCK_DBG_EXIT_PRINT(("Exiting GCK_CTRL_Close.\n"));
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\ctrl_ioctl.c ===
//	@doc
/**********************************************************************
*
*	@module	CTRL_Ioctl.c	|
*
*	Implements basic IOCTL entry points and their handler functions
*	for control device objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CTRL_Ioctl	|
*			Any IOCTL call to the Control Device Object gets
*			filtered through here.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_CTRL_IOCTL_C

#include <WDM.H>
#include <basetyps.h>
#include <initguid.h>
#include "GckShell.h"
#include "debug.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, GCK_CTRL_Ioctl)
#pragma alloc_text (PAGE, GCK_FindDeviceObject)
#pragma alloc_text (PAGE, GCK_FindDeviceObject)
#endif

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@mfunc	Handles all IOCTL's to the control object
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp	// @parm pointer to IRP
)
{
	NTSTATUS			NtStatus = STATUS_SUCCESS;
	PGCK_CONTROL_EXT	pControlExt;
	PIO_STACK_LOCATION	pIrpStack;
	PVOID				pvIoBuffer;
	ULONG				uInLength;
	ULONG				uOutLength;
	ULONG				uIoctl;
	PDEVICE_OBJECT		pFilterHandle;
	PULONG				puHandle;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pCurDeviceObject;
	BOOLEAN				bCompleteRequest = TRUE;
	
	
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Ioctl, pDeviceObject = 0x%0.8x, pIRP = 0x%0.8x\n", pDeviceObject, pIrp));

	//
	//	Get all the inputs we need
	//
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
	uIoctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	uInLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	//
	// Assume we will succeed with no data, we will change if necessary
	// later
	//
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	
	if(IOCTL_GCK_GET_HANDLE == uIoctl)
	{
		//
		// Check buffer size
		//
		if( uOutLength < sizeof(PVOID) )
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			NtStatus = STATUS_BUFFER_TOO_SMALL;
			goto complete_and_return;
		}
		
		//
		// Get handle (device extension) of requested device
		//
		pFilterHandle = GCK_FindDeviceObject( (LPWSTR)pvIoBuffer, uInLength );
		
		//
		// If we couldn't find the handle,
		// it must have been a bad path,
		// so return invalid parameter
		//
		if( NULL == pFilterHandle)
		{
			pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			NtStatus = STATUS_INVALID_PARAMETER;
			goto complete_and_return;	
		}
		
		//
		// copy handle into user buffer
		//
		puHandle = (ULONG *)pvIoBuffer;
		*puHandle = (ULONG)pFilterHandle;
		GCK_DBG_TRACE_PRINT(("Returning 0x%0.8x as handle.\n", *puHandle));
		pIrp->IoStatus.Information = sizeof(ULONG);

		GCKF_ResetKeyboardQueue(pFilterHandle);

		goto complete_and_return;
	}	

//DEBUG only IOCTL to allow changing debug level
#if	(DBG==1)	
	if(IOCTL_GCK_SET_MODULE_DBG_LEVEL == uIoctl)
	{
		ASSERT(uInLength >= sizeof(ULONG)*2);
		//Reusing the name handle which is a misnomer
		puHandle = (ULONG *)pvIoBuffer;
		//first parameter is the module ID, the second is the flags
		SetDebugLevel(puHandle[0], puHandle[1]);
		goto complete_and_return;
	}
#endif
	

	//
	//	If the call is not IOCTL_GCK_GET_HANDLE, we expect the first byte to be the handle
	//
	
	//
	//	Check that the inlength is at least large enough
	//	for a handle PGCK_FILTER_EXT.
	//
	if( uInLength < sizeof(PGCK_FILTER_EXT) )
	{
		pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		NtStatus = STATUS_INVALID_PARAMETER;
		goto complete_and_return;
	}
	
	//
	//	Get the extension, and the DeviceObject itself
	//
	pFilterHandle = *((PDEVICE_OBJECT *)pvIoBuffer);
	GCK_DBG_TRACE_PRINT(("Filter Handle = 0x%0.8x\n", pFilterHandle));
	
	//
	//	Make sure the device object is in our linked list
	//	*** Do not dereference it, until we know it is in the list ***
	//	*** If it is not in the list it may be garbage ***
	pCurDeviceObject = Globals.pFilterObjectList;
	while ( pCurDeviceObject )
	{
		if( pCurDeviceObject == pFilterHandle ) break;
		pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
	}
	if(!pCurDeviceObject)
	{
		GCK_DBG_ERROR_PRINT(("Filter Handle, 0x%0.8x, is not valid\n", pFilterHandle));
		pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		NtStatus = STATUS_INVALID_PARAMETER;
		goto complete_and_return;
	}
	
	//
	// Get the device extension
	//
	pFilterExt = pFilterHandle->DeviceExtension;
	ASSERT(GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
	if( 
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING != pFilterExt->eDeviceState
	)
	{
		GCK_DBG_ERROR_PRINT(("Device is stopped or removed or \n"));
		pIrp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
		NtStatus = STATUS_DEVICE_NOT_CONNECTED;  //Causes ERROR_NOT_READY at Win32 level
		goto complete_and_return;
	}
	//
	// Determine which IOCTL and handle it
	//
	switch(uIoctl)
	{
		case IOCTL_GCK_SEND_COMMAND:
			NtStatus = GCKF_ProcessCommands
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							TRUE
						);
			pIrp->IoStatus.Status = NtStatus;
			break;
		case IOCTL_GCK_SET_INTERNAL_POLLING:
		{
			if( uInLength < sizeof(GCK_SET_INTERNAL_POLLING_DATA) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				GCK_IP_FullTimePoll(pFilterExt, ((PGCK_SET_INTERNAL_POLLING_DATA)pvIoBuffer)->fEnable);
			}
			break;		
		}
		case IOCTL_GCK_ENABLE_TEST_KEYBOARD:
		{
			if( uInLength < sizeof(GCK_ENABLE_TEST_KEYBOARD) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				NtStatus = GCKF_EnableTestKeyboard(pFilterExt, ((PGCK_ENABLE_TEST_KEYBOARD)pvIoBuffer)->fEnable, pIrpStack->FileObject);
			}
			break;		
		}
		case IOCTL_GCK_BEGIN_TEST_SCHEME:
			NtStatus = GCKF_BeginTestScheme
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							pIrpStack->FileObject
						);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_UPDATE_TEST_SCHEME:
			NtStatus = GCKF_UpdateTestScheme
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							pIrpStack->FileObject
						);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_END_TEST_SCHEME:
			NtStatus = GCKF_EndTestScheme(pFilterExt, pIrpStack->FileObject);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_BACKDOOR_POLL:
			if( uInLength < sizeof(GCK_BACKDOOR_POLL_DATA) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				//Polling is asynchronous and the filter will deal with that,
				//It is extremely important that we just return the status returned by the backdoor poll routine,
				//and not complete the IRP
				NtStatus = GCKF_BackdoorPoll(pFilterExt, pIrp, ((PGCK_BACKDOOR_POLL_DATA)pvIoBuffer)->ePollingMode);
				
				//Make sure a poll is pending to the actual hardware
				GCK_IP_OneTimePoll(pFilterExt);
				ASSERT(NT_SUCCESS(NtStatus));
				return NtStatus;
			}
			break;
		case IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE:		// Queue up IOCTL
			NtStatus = GCKF_IncomingForceFeedbackChangeNotificationRequest(pFilterExt, pIrp);
			if (!NT_SUCCESS(NtStatus))
			{	// Failed, IOCTL is completed below
				pIrp->IoStatus.Status = NtStatus;
			}
			else
			{	// Success, IOCTL was queued - don't complete
				bCompleteRequest = FALSE;
			}
			break;
		case IOCTL_GCK_END_FF_NOTIFICATION:			// Complete the Queued FF Ioctls
			NtStatus = pIrp->IoStatus.Status = GCKF_ProcessForceFeedbackChangeNotificationRequests(pFilterExt);
			break;
		case IOCTL_GCK_GET_FF_SCHEME_DATA:
			NtStatus = GCKF_GetForceFeedbackData(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_SET_WORKINGSET:
			NtStatus = GCKF_SetWorkingSet(pFilterExt, ((GCK_SET_WORKINGSET*)pvIoBuffer)->ucWorkingSet);
			break;
		case IOCTL_GCK_QUERY_PROFILESET:
			NtStatus = GCKF_QueryProfileSet(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_LED_BEHAVIOUR:
			NtStatus = GCKF_SetLEDBehaviour(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_TRIGGER:
			if ((uInLength < sizeof(GCK_TRIGGER_OUT)) || (uOutLength < sizeof(ULONG)))
			{
				NtStatus = pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				NtStatus = GCKF_TriggerRequest(pIrp, pFilterExt);
				if (!NT_SUCCESS(NtStatus))
				{	// Failed, IOCTL is completed below
					pIrp->IoStatus.Status = NtStatus;
				}
				else
				{	// Success, IOCTL was queued (or completed) - don't complete here
					bCompleteRequest = FALSE;
				}
			}
			break;
		case IOCTL_GCK_GET_CAPS:
		case IOCTL_GCK_ENABLE_DEVICE:
		default:
			pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
			NtStatus = STATUS_NOT_SUPPORTED;
			GCK_DBG_WARN_PRINT( ("Unknown IOCTL: 0x%0.8x\n", uIoctl) );
	}

complete_and_return:
	if (bCompleteRequest != FALSE)
	{
		// pIrp->IoStatus.Status = NtStatus;	-- This might be nice investigate
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_ControlIoctl(2), Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	PDEVICE_OBJECT GCK_FindDeviceObject(IN PWSTR pwszInterfaceReq, IN ULONG uInLength)
**
**	@mfunc	Given a Win32 HID interface finds the corresponding PDO among the filter devices
**
**	@rdesc	pointer to the PDO on success, NULL if a match is not found
**
*************************************************************************************/
PDEVICE_OBJECT GCK_FindDeviceObject
(
	IN PWSTR pwszInterfaceReq,	// @parm pointer to Win32 interface name
	IN ULONG uInLength			// @parm length of interface string
)
{
	NTSTATUS NtStatus;
	PWSTR pInterfaces;
	ULONG uIndex;
	ULONG uStringLen;
	BOOLEAN fMatchFound;
	PDEVICE_OBJECT pCurDeviceObject;
	ULONG uInWideChars;
		
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_FindDeviceObject, pwszInterfaceReq = %ws, uInLength = %d\n", pwszInterfaceReq, uInLength));
	//
	//	Get length of string including NULL, but don't overrun uInLength
	//
	uIndex = 0;
	uStringLen = 0;
	uInWideChars = uInLength/2;		// uInLength is the number of BYTES not WideChars
	while( uIndex < uInWideChars )
	{
		if( 0 == pwszInterfaceReq[uIndex++]  ) 
		{
			uStringLen = uIndex;
			break;
		}
	}


	//
	//	if the string is not terminated or if it is a NULL string, return NULL for the device.
	//	plus every string starts with "\\.\" plus at least two or more chars
	//
	if( 6 > uStringLen ) return NULL; 
	
	//
	// Walk through all known devices
	//
	pCurDeviceObject = Globals.pFilterObjectList;
	while ( pCurDeviceObject )
	{
		//
		//	Get the interfaces for the PDO
		//
		NtStatus = IoGetDeviceInterfaces(
			(LPGUID)&GUID_CLASS_INPUT,
			FILTER_DEVICE_OBJECT_PDO(pCurDeviceObject),
			0,
			&pInterfaces
			);
		
		//
		//	If we have got the interfaces, then look for match
		//
		if( STATUS_SUCCESS == NtStatus )
		{
				fMatchFound=GCK_MatchReqPathtoInterfaces(pwszInterfaceReq, uStringLen, pInterfaces);
				ExFreePool(pInterfaces);
				if(fMatchFound)
				{
					GCK_DBG_EXIT_PRINT(("Exiting GCK_FindDeviceObject - match found returning 0x%0.8x\n", pCurDeviceObject));
					return pCurDeviceObject;
				}
		}
		
		//
		// Advance to next known device
		//
		pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
	}

	//
	//	If we are here, there is no match
	//
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FindDeviceObject - no match found returning NULL\n"));
	return NULL;
}

#define UPPERCASE(_x_) (((L'a'<=_x_) && (L'z'>=_x_)) ? ((_x_) - (L'a'-L'A')) : _x_)
/***********************************************************************************
**
**	BOOLEAN GCK_MatchReqPathtoInterfaces(IN PWSTR pwszPath, IN ULONG uStringLen, IN PWSTR pmwszInterfaces)
**
**	@mfunc	Determines if a Win32 Path matches any of the Interfaces.  This replaces a match between
**			String and a Multi-String.  The previous was not sufficient (even though the caller tried
**			to compensate.)  The new algorithm is to find the last '\\' in each string before comparing
**			them.  It is still a string against any of a multi-string though.
**
**	@rdesc	TRUE if a match is found, FALSE otherwise
**
*************************************************************************************/
BOOLEAN GCK_MatchReqPathtoInterfaces
(
	IN PWSTR pwszPath,	// @parm String to find match
	IN ULONG uStringLen,	// @parm length of string in WCHARs
	IN PWSTR pmwszInterfaces	// @parm MutliString
)
{
		PWSTR pwszCurInterface;
		PWSTR pwszPathInterface;
		ULONG uCharIndex;
		ULONG uCurIntefaceLen;
		ULONG uDiff;
		
		GCK_DBG_ENTRY_PRINT(("Entering GCK_MatchReqPathtoInterfaces, pwszPath = \'%ws\'\n, uStringLen = %d, pmwszStrings = \'%ws\'", pwszPath, uStringLen, pmwszInterfaces));

		//
		//	Find last '\\' in pwszPath and set pszPathInterface to the next character
		//
		pwszPathInterface = pwszPath;
		uCharIndex = 0;
		while( pwszPathInterface[uCharIndex] && (uCharIndex != uStringLen)) uCharIndex++;	//go to end
		while( uCharIndex && (L'\\' != pwszPathInterface[uCharIndex]) ) uCharIndex--;		//go to last '\\'
		ASSERT(uCharIndex < uStringLen);
		pwszPathInterface += uCharIndex+1;	//skip last '\\'
		
		GCK_DBG_TRACE_PRINT(("Path to compare is %ws\n", pwszPathInterface));

		//
		//	check if the szString matches any of the strings in mszStrings
		//
		pwszCurInterface = pmwszInterfaces;
		
		//
		//	Loop over all strings in pmwszStrings
		//
		do
		{
			//Find last '\\'
			uCharIndex = 0;
			while( pwszCurInterface[uCharIndex]) uCharIndex++;								//go to end
			uCurIntefaceLen = uCharIndex;													//save string length
			while( uCharIndex && (L'\\' != pwszCurInterface[uCharIndex]) ) uCharIndex--;	//go to last '\\'
			pwszCurInterface += uCharIndex+1;
			uCurIntefaceLen -= uCharIndex+1;	//length after we skip some stuff

			GCK_DBG_TRACE_PRINT(("Comparing path with %ws\n", pwszCurInterface));

			//
			// look for differences in each string.
			//
			uCharIndex = 0;
			uDiff = 0;
			do
			{
				//
				//	Check if characters match
				//
				if( UPPERCASE(pwszCurInterface[uCharIndex]) != UPPERCASE(pwszPathInterface[uCharIndex]) )
				{
					uDiff++;	//increment number of differences
					break;		//One difference is enough
				}
			} while( (pwszCurInterface[uCharIndex] != 0) && (pwszCurInterface[uCharIndex++] != '}') );

			//
			//	Check for match
			//
			if( 0 == uDiff )
			{
				GCK_DBG_EXIT_PRINT(("Exiting GCK_MatchReqPathtoInterfaces - match found returning TRUE\n"));
				return TRUE;
			}
						
			//
			// move to the next string in list
			//
			pwszCurInterface += uCurIntefaceLen;
		} while(pwszCurInterface[0] != 0);  //continue while there are more strings

 		//
		// if we fell out we didn't find a match
		//
		GCK_DBG_EXIT_PRINT(("Exiting GCK_MatchReqPathtoInterfaces - no match found returning FALSE\n"));
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filter.h ===
#ifndef __Filter_h__
#define __Filter_h__
//	@doc
/**********************************************************************
*
*	@module	Filter.h	|
*
*	All the definitions needed for the CDeviceFilter object
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	Filter	|
*	This module contains:<nl>
*	<c CInputItem> - Base class for all CXXXXInput derived from the CXXXItems.<nl>
*	<c CAction>	- Base class for all actions.<nl>
*	<c CQueuedAction> - Base class for all actions which can be queued, derived from <c CAction><nl>
*	<c CKeyMixer> - Class which allows multiple devices to share one virtual keyboard.<nl>
*	<c CTimedMacro> - Class for timed macros, derived from <c CQueuedAction><nl>
*	<c CActionQueue> - Class for the action queue.<nl>
*	<c CDeviceFilter> - The class which incorporates the entire filter.<nl>
**********************************************************************/
#include <ControlItemCollection.h>
#include <Actions.h>
#include "GckCritSec.h"
#include "GCKShell.h"

//forward declration
class CKeyMixer;

class CFilterClientServices
{
	public:
		CFilterClientServices() : m_ulRefCount(1){}
		inline ULONG IncRef()
		{
			return m_ulRefCount++;
		}
		inline ULONG DecRef()
		{
			ULONG ulRetVal = --m_ulRefCount;
			if(!ulRetVal)
			{
				delete this;
			}
			return ulRetVal;
		}
		virtual ~CFilterClientServices()
		{
			ASSERT(!m_ulRefCount && "Somebody tried to delete this!  Call DecRef instead!");
		}
		
		//routine to get basic HID information on device
		virtual ULONG				 GetVidPid()=0;
		virtual PHIDP_PREPARSED_DATA GetHidPreparsedData()=0;
		
		//Routine to send device data to
		virtual void				 DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr)=0;
		virtual NTSTATUS			 DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount)=0;
		
		//Gets a time stamp in ms, expected to have ms precision as well.
		virtual ULONG				 GetTimeMs()=0;
				
		//	Routine that sets call back for 	
		virtual void				 SetNextJog(ULONG ulDelayMs)=0;
				
		//	Routines for sending keystrokes (a port for stuffing keyboards is assumed to exist)
		virtual void				PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled)=0;
		virtual NTSTATUS			PlayFromQueue(IRP* pIrp) = 0;
				
		//	Routines for sending mouse data, must create first
		virtual HRESULT				 CreateMouse()=0;
		virtual HRESULT				 CloseMouse()=0;
		virtual HRESULT				 SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR cWheel, BOOLEAN fClutch, BOOLEAN fDampen)=0;
	private:
		ULONG m_ulRefCount;
};

//*****************************************************************************************
//*****************************************************************************************
//************	What actions look like to the CDeviceFilter  ******************************
//*****************************************************************************************

class CAction
{
	public:
		CAction() : m_ucRef(1)
		{
			m_ucActionClass = CAction::DIGITAL_MAP;	//default is DIGITAL_MAP
		}
		virtual ~CAction(){};
		UCHAR GetActionClass() { return m_ucActionClass; }
		
		void IncRef(){ m_ucRef++; };
		void DecRef()
			{
				if(0 == --m_ucRef)
				{
					delete this;
				}
		}
			
		//Used by proportional map and derivatives
		//other types of actions, use do nothing
		virtual void SetValue(LONG /*lValue*/){}
		virtual void SetSourceRange(LONG /*lSourceMax*/, LONG /*lSourceMin*/){}

		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection ) = 0;
		virtual void TriggerReleased(){};
	
		//
		//	Classes of actions (some input items only some types) They also may have
		//	different semantics
		//
		static const UCHAR DIGITAL_MAP;			//cycle, button, key map fit this class
		static const UCHAR PROPORTIONAL_MAP;	//axis swap is this class
		static const UCHAR QUEUED_MACRO;		//timed macros and keystring fit this category
	protected:
		UCHAR m_ucActionClass;
	private:
		UCHAR m_ucRef;
};

class CBehavior
{
	public:
		CBehavior() : m_ucRef(1), m_lMin(-1), m_lMax(-1), m_fIsDigital(FALSE){}
		virtual ~CBehavior(){}
				
		void IncRef(){ m_ucRef++; };
		void DecRef()
			{
				if(0 == --m_ucRef)
				{
					delete this;
				}
		}
		virtual LONG CalculateBehavior(LONG lValue)
		{
			return lValue;
		}
		virtual void Calibrate(LONG lMin, LONG lMax)
		{
			m_lMin = lMin;
			m_lMax = lMax;
		}
		BOOLEAN IsDigital() {return m_fIsDigital;}
	protected:		
		LONG m_lMin;
		LONG m_lMax;
		BOOLEAN m_fIsDigital;
	private:
		UCHAR m_ucRef;

		
};

class CStandardBehavior : public CBehavior
{
	public:	
		CStandardBehavior() : m_pBehaviorCurve(NULL) {}
		~CStandardBehavior() { delete m_pBehaviorCurve;}
		BOOLEAN Init( PBEHAVIOR_CURVE pBehaviorCurve);
		virtual void Calibrate(LONG lMin, LONG lMax);
		virtual LONG CalculateBehavior(LONG lValue);

		CURVE_POINT GetBehaviorPoint(USHORT usPointIndex);
	private:
		PBEHAVIOR_CURVE m_pBehaviorCurve;
};



// forward declaration
class CQueuedAction;

class CActionQueue
{
	public:
		//static const UCHAR OVERLAY_MACROS;
		//static const UCHAR SEQUENCE_MACROS;
		static const ULONG MAXIMUM_JOG_DELAY;
	
		CActionQueue(CFilterClientServices *pFilterClientServices):
			m_pHeadOfQueue(NULL), m_ucFlags(0), m_ulItemsInQueue(0),
			m_pFilterClientServices(pFilterClientServices)
		{
				ASSERT(m_pFilterClientServices);
				m_pFilterClientServices->IncRef();
		}
		~CActionQueue()
		{
			m_pFilterClientServices->DecRef();
		}
		void	Jog();
		BOOLEAN InsertItem(CQueuedAction *pActionToEnqueue);
		void	RemoveItem(CQueuedAction *pActionToDequeue);
		void	NextJog(ULONG ulNextJogDelayMs);
		CQueuedAction* GetHead() const { return m_pHeadOfQueue; }

		void ReleaseTriggers();
	private:
		ULONG					m_ulItemsInQueue;
		ULONG					m_ulNextJogMs;
		CQueuedAction			*m_pHeadOfQueue;
		UCHAR					m_ucFlags;
		CFilterClientServices	*m_pFilterClientServices;
};

class CQueuedAction : public CAction
{
	friend CActionQueue;  //action queue need to be able to
						  //get to the linked list members
	
	public:
		CQueuedAction()
		{
			m_ucActionClass = CAction::QUEUED_MACRO;
		}
		void Init(CActionQueue *pActionQueue)
		{
			m_pActionQueue = pActionQueue;
			m_bActionQueued = FALSE;
		}
		virtual void Jog(ULONG ulTimeStampMs) = 0;
		virtual void Terminate() = 0;
		virtual ULONG GetActionFlags() = 0;
		virtual void ForceBleedThrough() {};		// This is used for axis always bleed through

	protected:
		CQueuedAction	*m_pNextQueuedAction;
		CActionQueue	*m_pActionQueue;
		BOOLEAN			m_bActionQueued;
};


class CTimedMacro : public CQueuedAction
{
	public:
		CTimedMacro() : m_ucProcessFlags(0), m_pKeyMixer(NULL)
		{}
		virtual ~CTimedMacro()
		{
			delete m_pTimedMacroData;
		}

		BOOLEAN Init(PTIMED_MACRO pTimedMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);
		//
		//	Override of CAction
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		virtual void Jog(ULONG ulTimeStampMs);
		virtual void Terminate();
		virtual ULONG GetActionFlags()
		{
			return m_pTimedMacroData->ulFlags;
		}
	private:
		
		//
		//	Pointer to our dynamically allocated memory
		//
		UCHAR							m_ucProcessFlags;
		PTIMED_MACRO					m_pTimedMacroData;
		ULONG							m_ulCurrentEventNumber;
		PTIMED_EVENT					m_pCurrentEvent;
		CControlItemDefaultCollection	*m_pOutputCollection;
		ULONG							m_ulStartTimeMs;
		ULONG							m_ulEventEndTimeMs;
		CKeyMixer						*m_pKeyMixer;

		static const UCHAR TIMED_MACRO_STARTED;
		static const UCHAR TIMED_MACRO_RELEASED;
		static const UCHAR TIMED_MACRO_RETRIGGERED;
		static const UCHAR TIMED_MACRO_FIRST;
		static const UCHAR TIMED_MACRO_COMPLETE;
};

class CKeyString : public CQueuedAction
{
	public:
		CKeyString() : m_ucProcessFlags(0), m_pKeyMixer(NULL)
		{}
		virtual ~CKeyString()
		{
			delete m_pKeyStringData;
		}
		BOOLEAN Init(PKEYSTRING_MAP pKeyStringData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);
		
		//
		//	Override of CAction
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		virtual void Jog(ULONG ulTimeStampMs);
		virtual void Terminate();
		virtual ULONG GetActionFlags()
		{
			return m_pKeyStringData->ulFlags;
		}

	private:
		
		//
		//	Pointer to our dynamically allocated memory
		//
		UCHAR							m_ucProcessFlags;
		PKEYSTRING_MAP					m_pKeyStringData;
		ULONG							m_ulCurrentEventNumber;
		PEVENT							m_pCurrentEvent;
		BOOLEAN							m_fKeysDown;
		CKeyMixer						*m_pKeyMixer;

		
		static const UCHAR KEY_STRING_STARTED;
		static const UCHAR KEY_STRING_RELEASED;
		static const UCHAR KEY_STRING_RETRIGGERED;
		static const UCHAR KEY_STRING_FIRST;
		static const UCHAR KEY_STRING_COMPLETE;
};

class CMapping : public CAction
{
	public:		
		CMapping() : m_pEvent(NULL), m_pKeyMixer(NULL){}
		~CMapping();
		BOOLEAN Init(PEVENT pEvent, CKeyMixer *pKeyMixer);
		
		//Overrides of CAction
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
	private:
		PEVENT		m_pEvent;
		CKeyMixer	*m_pKeyMixer;
};

class CProportionalMap	: public CAction
{
	public:
		CProportionalMap(): m_lValue(0)
		{
			m_ucActionClass = CAction::PROPORTIONAL_MAP;
		}
		virtual void SetValue(LONG lValue){ m_lValue = lValue;}
		virtual void SetSourceRange(LONG lSourceMax, LONG lSourceMin)
		{
			m_lSourceMax = lSourceMax;
			m_lSourceMin = lSourceMin;
			if(0==(m_lSourceMax-m_lSourceMin))
			{
				//We will divide by zero later if this is true
				//so increment m_SourceMax so as not to divide by zero.
				ASSERT(FALSE);
				m_lSourceMax++; 
			}
		}
	protected:
		LONG GetScaledValue(LONG lDestinationMax, LONG lDestinationMin);
		LONG m_lValue;
		LONG m_lSourceMin;
		LONG m_lSourceMax;
};

/*
*	BUGBUG The CAxisMap class in general should be assignable to any axis.
*	BUGBUG The current implementation has two serious limitations:
*	BUGBUG 1) The source and destination axes must have the same range.
*	BUGBUG 2) The source and destination axes must be derived from CGenericItem.
*	BUGBUG This code is suitable for the Pedals on ZepLite, but will break
*	BUGBUG for the Y-Z swap on any of the Joysticks.  The limitation is due to
*	BUGBUG an encapsulation problem.  The output control is a standard colleection  
*	BUGBUG and does not have a custom base class like the input colleciton.  Consequently,
*	BUGBUG there is no general mechanism to set the output of a proportional control.
*	BUGBUG The implementation assumes that the source and destination are of the same type.
*	BUGBUG This could be solved, by breaking the encapsulation in the implementation
*	BUGBUG in this class or by creating a custom output collection, that had appropriate
*	BUGBUG accessors.  Or perhaps a compromise:
*	BUGBUG ** Add a more generalized output set routine, that takes a ControlItemXfer,**
*	BUGBUG ** to identify the axis, and sets the axis based on it.					  **
*	BUGBUG For ZepLite it was not necessary and is therefore not done.
*/
class CAxisMap : public CProportionalMap
{
	public:
		CAxisMap() : m_lCoeff(0), m_lOffset(0){}
		void Init(const AXIS_MAP& AxisMapInfo);
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void SetSourceRange(LONG lSourceMax, LONG lSourceMin);
	private:
		LONG m_lCoeff;
		LONG m_lOffset;
		CONTROL_ITEM_XFER m_TargetXfer;
};
class CInputItem : public virtual CControlItem
{
	public:
		CInputItem() : m_pClientServices(NULL){}
		virtual ~CInputItem(){SetClientServices(NULL);}
		
		void SetClientServices(CFilterClientServices *pClientServices)
		{
			if(m_pClientServices == pClientServices) return;
			if(m_pClientServices)
			{
				m_pClientServices->DecRef();
			}
			if(pClientServices)
			{
				pClientServices->IncRef();
			}
			m_pClientServices = pClientServices;
		}

		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection )=0;
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)=0;
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
		{
			UNREFERENCED_PARAMETER(pTrigger);
			UNREFERENCED_PARAMETER(pBehavior);
			return E_NOTIMPL;
		}
		virtual void ClearAssignments() = 0;

		virtual void PostAssignmentProcessing() {return;}
		virtual void Duplicate(CInputItem& rInputItem) = 0;
	protected:
		CFilterClientServices *m_pClientServices;
};

class CAxesInput : public CInputItem, public CAxesItem
{
	public:
		CAxesInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CAxesItem(cpControlItemDesc), m_pXAssignment(NULL), m_pYAssignment(NULL),
			m_pXBehavior(NULL), m_pYBehavior(NULL)
		{
		}
		~CAxesInput()
		{
			ClearAssignments();
		};
		
	
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		
		//
		//	Two assignments allowed one for X and one for Y
		//
		CAction *m_pXAssignment;
		CAction *m_pYAssignment;
		CBehavior *m_pXBehavior;
		CBehavior *m_pYBehavior;
};

class CDPADInput : public CInputItem, public CDPADItem
{
	public:
		CDPADInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDPADItem(cpControlItemDesc), m_lLastDirection(-1)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CDPADInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
	
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
};

class CPropDPADInput : public CInputItem, public CPropDPADItem
{
	public:
		CPropDPADInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPropDPADItem(cpControlItemDesc), m_lLastDirection(-1),
			m_pXBehavior(NULL), m_pYBehavior(NULL), m_fIsDigital(FALSE)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CPropDPADInput()
		{
			ClearAssignments();
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void PostAssignmentProcessing() 
		{
			SwitchPropDPADMode();
		}
	
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		
		//Helper functions
		void SwitchPropDPADMode();

		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
		CBehavior *m_pXBehavior;
		CBehavior *m_pYBehavior;
		BOOLEAN	m_fIsDigital;
};

class CButtonsInput : public CInputItem, public CButtonsItem
{
	public:
		CButtonsInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CButtonsItem(cpControlItemDesc), m_ulLastButtons(0), m_usLastShift(0)
		{
			m_ulNumAssignments = ( (GetButtonMax() - GetButtonMin()) + 1 ) * ( GetNumShiftButtons() + 1);
			m_ppAssignments = new WDM_NON_PAGED_POOL CAction *[m_ulNumAssignments];
			if(!m_ppAssignments)
			{
				ASSERT(FALSE);
				return;
			}
			for(ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
			{
				m_ppAssignments[ulIndex] = NULL;
			}
		}
		~CButtonsInput()
		{
			ClearAssignments();
			if( m_ppAssignments)
			{
				delete m_ppAssignments;
			}
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

		void GetLowestShiftButton(USHORT& rusLowestShiftButton) const;

		BOOLEAN IsButtonAssigned(ULONG ulButton, ULONG ulModifier) const
		{
			// Compute button
			ULONG ulAssignmentIndex = (ulModifier * (GetButtonMax() - GetButtonMin() + 1)) + (ulButton - GetButtonMin());

			if( (ulAssignmentIndex < m_ulNumAssignments) &&
				(m_ppAssignments != NULL) &&
				(m_ppAssignments[ulAssignmentIndex] != NULL))
			{
				return TRUE;
			}
			return FALSE;
		}
	private:
		ULONG m_ulLastButtons;
		ULONG m_ulNumAssignments;
		USHORT m_usLastShift;
		CAction **m_ppAssignments;
};
typedef CButtonsInput* CButtonsInputPtr;

class CPOVInput : public CInputItem, public CPOVItem
{
	public:
		CPOVInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPOVItem(cpControlItemDesc), m_lLastDirection(-1)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CPOVInput()
		{
			ClearAssignments();
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	
	private:		
		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
};

class CThrottleInput : public CInputItem, public CThrottleItem
{
	public:
		CThrottleInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CThrottleItem(cpControlItemDesc)
		{}
		~CThrottleInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};

class CRudderInput : public CInputItem, public CRudderItem
{
	public:
		CRudderInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CRudderItem(cpControlItemDesc)
		{
		}
		~CRudderInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};


class CWheelInput : public CInputItem, public CWheelItem
{
	public:
		CWheelInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CWheelItem(cpControlItemDesc), m_pBehavior(NULL)
		{
		}
		~CWheelInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		CBehavior *m_pBehavior;
};

class CPedalInput : public CInputItem, public CPedalItem
{
	public:
		CPedalInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPedalItem(cpControlItemDesc), m_pAssignment(NULL)
		{
		}
		~CPedalInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

	private:
		CAction *m_pAssignment;
};

class CZoneIndicatorInput : public CInputItem, public CZoneIndicatorItem
{
	public:
		CZoneIndicatorInput (const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CZoneIndicatorItem(cpControlItemDesc), m_pAssignmentX(NULL),
				m_pAssignmentY(NULL)
		{
		}
		~CZoneIndicatorInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

	private:
		CAction *m_pAssignmentX;			//Zone for X
		CAction *m_pAssignmentY;			//Zone for Y
		//CAction *m_pAssignmentZ;			//Zone for Z - not used
};

class CDualZoneIndicatorInput : public CInputItem, public CDualZoneIndicatorItem
{
	public:
		CDualZoneIndicatorInput(const CONTROL_ITEM_DESC *cpControlItemDesc);

		~CDualZoneIndicatorInput()
		{
			ClearAssignments();
			if (m_ppAssignments)
			{
				delete m_ppAssignments;
				m_ppAssignments = NULL;
			}
		};
		
		//  Filter execution (item maps itself to output)
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
		
		// Filter programmability
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		CAction** m_ppAssignments;	// Assignment for each zone
		CBehavior* m_pBehavior;		// Behaviour (just dead zone stuff)
		LONG m_lNumAssignments;		// Number of assignable zones
		LONG m_lLastZone;			// Last zone we were in
};

class CProfileSelectorInput : public CInputItem, public CProfileSelector
{
	public:
		CProfileSelectorInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CProfileSelector(cpControlItemDesc)
		{
		}

		~CProfileSelectorInput()
		{
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};

class CButtonLEDInput : public CInputItem, public CButtonLED
{
	public:
		CButtonLEDInput(const CONTROL_ITEM_DESC *cpControlItemDesc);
		~CButtonLEDInput();

		void Init(CInputItem* pCorrespondingButtons);
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

		void AssignmentsChanged();
		void SetLEDStates(GCK_LED_BEHAVIOURS ucLEDBehaviour, ULONG ulLEDsAffected, unsigned char ucShiftArray);
		USHORT GetCorrespondingButtonIndex() const { return m_ucCorrespondingButtonItemIndex; }
	private:
		CButtonsInput* m_pCorrespondingButtonsItem;
		UCHAR* m_pLEDSettings;
		USHORT m_usNumberOfButtons;
		UCHAR m_ucCorrespondingButtonItemIndex;
};

HRESULT	__stdcall InputItemFactory(
				USHORT	usType,
				const CONTROL_ITEM_DESC* cpControlItemDesc,
				PVOID *ppControlItem
			);

//
//	@class CKeyMixer | 
//			This class mixes input from multiple instances so that single virtual
//			keyboard can be used to stuff keys.  The theory is that each device filter
//			has a different instance of this class.  The class maintains a linked-list
//			of all its instances via a static variable.  The device filter may call
//			SetState, OverlayState or ClearState to update the keyboard state of the
//			that filter.  PlayGlobalState walks the linked list, mixes the states,
//			compares with the previous global state and if that state has changes (or
//			the fPlayIfNoChange flag is set) plays the new keys over the virtual keyboard.
//			The connection to the virutal keyboard is hooked via a function
//			of type PFNPLAYKEYS, which is passed in the constructor.  The first
//			call sets a global variable.  Subsequent calls assert that the hook is the
//			same.<nl>
//			To the CDeviceFilter object, this class is all it knows about keyboards.

class CKeyMixer
{
	public:	
		CKeyMixer(CFilterClientServices *pFilterClientServices);
		~CKeyMixer();
		void SetState(const CONTROL_ITEM_XFER& crcixNewLocalState);
		void OverlayState(const CONTROL_ITEM_XFER& crcixNewLocalState);
		void ClearState();
		void PlayGlobalState(BOOLEAN fPlayIfNoChange=FALSE);
		void Enable(BOOLEAN fEnable);
		
	private:
		CONTROL_ITEM_XFER	m_cixLocalState;
		BOOLEAN				m_fEnabled;
		//utility functions
		struct MIX_ALGO_PARAM
		{
			CONTROL_ITEM_XFER	*pcixDest;
			ULONG				ulDestCount;
			ULONG				rgulKeyMap[5];
		};
		void InitMixAlgoParam(MIX_ALGO_PARAM *pMixAlgParm, CONTROL_ITEM_XFER *pcixDest);
		void MixAlgorithm(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParam, const CONTROL_ITEM_XFER *pcixSrc);
		inline void CopyKeyMap(ULONG *pulKeyMapDest, ULONG *pulKeyMapSrc)
		{
			for(ULONG ulIndex=0; ulIndex <5; ulIndex++)
			{
				pulKeyMapDest[ulIndex] = pulKeyMapSrc[ulIndex];
			}
		}
		inline BOOLEAN CompareKeyMap(ULONG *pulKeyMapDest, ULONG *pulKeyMapSrc)
		{
			for(ULONG ulIndex=0; ulIndex <5; ulIndex++)
			{
				if( pulKeyMapDest[ulIndex] != pulKeyMapSrc[ulIndex] ) return FALSE;
			}
			return TRUE;
		}
		
		CKeyMixer				*pNextKeyMixer;
		CFilterClientServices	*m_pFilterClientServices;
		static CKeyMixer		*ms_pHeadKeyMixer;
		static ULONG			ms_rgulGlobalKeymap[5];
		static UCHAR			ms_ucLastModifiers;
};

#define MOUSE_AXIS_MAX_IN 1024
#define MOUSE_AXIS_MIN_IN 0
#define MOUSE_AXIS_CENTER_IN 512
//
//	@class CMouseModel | 
//			This class embodies the model for combining various inputs from the
//			device into HID mouse packets.
//			The model must be initialized with a call to SetModelParameters.
//			If this is non-null the parameters are assigned.  If this is null
//			the mouse is returned to an unitialized state.
//
//			Controls may be assigned to the model at any time.  When an assignment
//			is created (or destroy) it should refcount the appropriate interface (Model
//			independent, or model dependent).
//
//			A virtual mouse is created and destroyed as needed based on the model parameters
//			and the ref counts.  A Model Independent refcount greater than zero or the combination
//			of valid model parameters and a model dependent refcount greater than zero requires
//			a virtual mouse.
//
class CMouseModel
{
	public:
		
		//**
		//**	Creation and destruction
		//**
		CMouseModel(CFilterClientServices *pFilterClientServices) : 
			m_pFilterClientServices(pFilterClientServices),
			m_ulRefCount(1), m_pMouseModelData(NULL)
		{
			ASSERT(m_pFilterClientServices);

			m_pFilterClientServices->IncRef();
			CreateDynamicMouseObjects();
		}

		~CMouseModel()
		{
			//Cleanup any dynamic stuff we created
			DestroyDynamicMouseObjects();
			m_pFilterClientServices->DecRef();
			m_pFilterClientServices = NULL;
		}

		//**
		//**  Programmability interface
		//**

		//Model parameters are set from a command
		HRESULT SetXModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters);
		HRESULT SetYModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters);
		
		//Reference counting
		inline ULONG IncRef()
		{
			m_ulRefCount++;
			return m_ulRefCount;
		}

		inline ULONG DecRef()
		{
			m_ulRefCount--;
			if (m_ulRefCount == 0)
			{
				delete this;
				return 0;
			}
			return m_ulRefCount;
		}

		//**
		//** Playback interface
		//**

		//called by device filters MapToOutput, to reset state for a new packet
		void NewPacket(ULONG ulCurrentTime);

		//called by the X and Y assignments one every map to set the current position
		inline void SetX(ULONG ulX) 
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateX.ulPos = ulX;
		}
		inline void SetY(ULONG ulY)
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateY.ulPos = ulY;
		}
		inline void	XZone()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateX.fInZone = TRUE;
		}
		
		inline void	YZone()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateY.fInZone = TRUE;
		}
		//called by appropriate assignments on a map only if activated.
		inline void Clutch()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->fClutchDown = TRUE;
		}
		inline void Dampen()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->fDampenDown = TRUE;
		}
		inline void MouseButton(UCHAR ucButtonNumber)
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->ucButtons |= (1 << ucButtonNumber);
		}
		
		//called by device filters MapToOutput (at end), to send packet to output
		void SendMousePacket();
	
	private:

		//
		//	Creates and destroys virtual mouse, as well as pMouseModelData
		//
		HRESULT	CreateDynamicMouseObjects();
		void	DestroyDynamicMouseObjects();

		//
		//	The following structure block of a data is needed only when the model is in
		//	use.  CMouseModel is instantiated for every device, regardless of whether
		//	an assignment uses the model.  For efficiency, we keep a reference count
		//	on the users that are actually using the mosue, when that becomes positive
		//	we instantiate this data.  When it goes to zero we delete.
		//
		typedef struct MOUSE_AXIS_STATE
		{
			//c'tor
			MOUSE_AXIS_STATE() :
				ulPos(512),
				ulLastPos(512),
				fInZone(FALSE),
				ulZoneEnterLo(MOUSE_AXIS_MIN_IN+1),
				ulZoneEnterHigh(MOUSE_AXIS_MAX_IN-1),
				fInertia(FALSE),
				ulInertiaStopMs(0),
				ulPulseGateStartMs(0) {}
			//Position Info
			ULONG	ulPos;
			ULONG	ulLastPos;
			BOOLEAN	fInZone;
			//HysteresisInfo
			ULONG	ulZoneEnterLo;
			ULONG	ulZoneEnterHigh;
			BOOLEAN	fInertia;
			ULONG	ulInertiaStopMs;
			ULONG	ulPulseGateStartMs;
			ULONG	ulMickeyFraction;		//Mickeys * 1024
		} *PMOUSE_AXIS_STATE;

		typedef struct MOUSE_MODEL_DATA
		{
			//Initdata
			MOUSE_MODEL_DATA() :
				fXModelParametersValid(FALSE),
				fYModelParametersValid(FALSE),
				ulCurrentTime(0),
				ulLastTime(0),
				fClutchDown(FALSE),
				fDampenDown(FALSE),
				ucButtons(UCHAR(-1)),
				ucLastButtons(UCHAR(-1)),
				cWheel(0)
				{}
			//
			//	Setable model parameters
			//
			BOOLEAN					fXModelParametersValid;
			MOUSE_MODEL_PARAMETERS	XModelParameters;
			BOOLEAN					fYModelParametersValid;
			MOUSE_MODEL_PARAMETERS	YModelParameters;
			
			//
			//	Latest state data of the inputs
			//
			ULONG	ulCurrentTime;
			ULONG	ulLastTime;
			BOOLEAN	fClutchDown;
			BOOLEAN	fDampenDown;
			UCHAR	ucButtons;
			CHAR	cWheel;

			// Last Mouse Button State (don't want to repeat for no reason)
			UCHAR	ucLastButtons;
			
			//
			//	Variables maintaining state of axes
			//
			MOUSE_AXIS_STATE StateX;
			MOUSE_AXIS_STATE StateY;

		} *PMOUSE_MODEL_DATA;
		
		//
		//	Data Related to Model State
		//	
		ULONG				m_ulRefCount;
		PMOUSE_MODEL_DATA	m_pMouseModelData;

		//Calculate Axis position
		UCHAR CalculateMickeys(PMOUSE_AXIS_STATE pMouseAxisState, PMOUSE_MODEL_PARAMETERS pModelParameters);

		//
		//	Data Related To Virtual Mouse
		//
		CFilterClientServices *m_pFilterClientServices;
};

class CMultiMacro : public CQueuedAction
{
	public:
		CMultiMacro(CMouseModel *pMouseModel) :
			m_ucProcessFlags(ACTION_FLAG_PREVENT_INTERRUPT),
			m_pKeyMixer(NULL),
			m_pMouseModel(pMouseModel)
			{
				ASSERT(pMouseModel != NULL);
				m_pMouseModel->IncRef();
			};
		~CMultiMacro()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel = NULL;
		};

		BOOLEAN Init(PMULTI_MACRO pMultiMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);

		//
		//	Override of CAction
		//
		virtual void MapToOutput(CControlItemDefaultCollection* pOutputCollection);
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		void Jog(ULONG ulTimeStampMs);
		void Terminate();
		ULONG GetActionFlags() { return m_ucProcessFlags; }
		void ForceBleedThrough();

		void SetCurrentKeysAndMouse();
	private:
		UCHAR			m_ucProcessFlags;
		PMULTI_MACRO	m_pMultiMacroData;
		CKeyMixer*		m_pKeyMixer;
		CMouseModel*	m_pMouseModel;
		ULONG			m_ulCurrentEventNumber;
		EVENT*			m_pCurrentEvent;
		ULONG			m_ulStartTimeMs;
		ULONG			m_ulEndTimeMs;
		BOOLEAN			m_fXferActive;		// Keysdown or MousePressed or Delay Active

		static const UCHAR MULTIMACRO_STARTED;
		static const UCHAR MULTIMACRO_RELEASED;
		static const UCHAR MULTIMACRO_RETRIGGERED;
		static const UCHAR MULTIMACRO_FIRST;
};

class CMouseAxisAssignment : public CProportionalMap
{
	public:
		CMouseAxisAssignment(BOOLEAN fXAxis, CMouseModel *pMouseModel) :
		  m_fXAxis(fXAxis), m_pMouseModel(pMouseModel)
		{
			m_pMouseModel->IncRef();
		}
		~CMouseAxisAssignment()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel = NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		BOOLEAN		m_fXAxis;
		CMouseModel	*m_pMouseModel;
};

class CMouseButton : public CAction
{
	public:
		CMouseButton(UCHAR ucButtonNumber, CMouseModel *pMouseModel):
		  m_ucButtonNumber(ucButtonNumber), m_pMouseModel(pMouseModel)
		  {
			  m_pMouseModel->IncRef();
		  }
		  ~CMouseButton()
		  {
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		  }
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		UCHAR		m_ucButtonNumber;
		CMouseModel	*m_pMouseModel;
};

class CMouseClutch : public CAction
{
	public:
		CMouseClutch(CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
		  }
		~CMouseClutch()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
};

class CMouseDamper : public CAction
{
	public:
		CMouseDamper(CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
		  }
		~CMouseDamper()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
};

class CMouseZoneIndicator : public CAction
{
	public:
		CMouseZoneIndicator(UCHAR ucAxis, /* 0 = X, 1=Y, 2=Z,*/CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
			m_ucAxis=ucAxis;
		  }
		~CMouseZoneIndicator()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
		UCHAR		m_ucAxis;
};

class CDeviceFilter
{
	public:
		CDeviceFilter(CFilterClientServices *pFilterClientServices);
		~CDeviceFilter();
		
		//
		//	Entry point to filter which processes data.
		//	ProcessInput and JogActionQueue, both defer most action
		//	to the Jog routine.
		//
		void IncomingRequest();
		void ProcessInput(PCHAR pcReport, ULONG ulReportLength);
		void JogActionQueue(PCHAR pcReport, ULONG ulReportLength);
		void Jog(PCHAR pcReport, ULONG ulReportLength);
		void OtherFilterBecomingActive();

		//
		//	Program filter(entry point for programming filter)
		//
		HRESULT ActionFactory( PASSIGNMENT_BLOCK pAssignment, CAction **ppAction);
		HRESULT BehaviorFactory(PASSIGNMENT_BLOCK pAssignment, CBehavior **ppBehavior);
		NTSTATUS ProcessCommands(const PCOMMAND_DIRECTORY cpCommandDirectory);
		void UpdateAssignmentBasedItems(BOOLEAN bIgnoreWorking);

		NTSTATUS ProcessKeyboardIrp(IRP* pKeyboardIrp);
		inline void	EnableKeyboard(BOOLEAN fEnable)
		{
			m_KeyMixer.Enable(fEnable);
		}
		inline CFilterClientServices* GetFilterClientServices()
		{
			return m_pFilterClientServices;
		}

		// WorkingSet
		NTSTATUS SetWorkingSet(UCHAR ucWorkingSet);
		void SetActiveSet(UCHAR ucActiveSet) { m_ucActiveInputCollection = ucActiveSet; }
		UCHAR GetWorkingSet() const { return m_ucWorkingInputCollection; }
		UCHAR GetActiveSet() const { return m_ucActiveInputCollection; }
		void CopyToTestFilter(CDeviceFilter& rDeviceFilter);

		// LED functions
		NTSTATUS SetLEDBehaviour(GCK_LED_BEHAVIOUR_OUT* pLEDBehaviourOut);

		// Trigger Functions
		BOOLEAN TriggerRequest(IRP* pIrp);
		void CompleteTriggerRequest(IRP* pIrp, ULONG ulButtonStates);
		void CheckTriggers(PCHAR pcReport, ULONG ulReportLength);
		
		BOOLEAN DidFilterBlockChange() const { return m_bFilterBlockChanged; }
		void ResetFilterChange() { m_bFilterBlockChanged = FALSE; }
		FORCE_BLOCK* GetForceBlock() const { return m_pForceBlock; }
	private:
		BOOLEAN EnsureMouseModelExists();

		CControlItemCollection<CInputItem>* m_rgInputCollections;
		UCHAR m_ucActiveInputCollection;
		UCHAR m_ucWorkingInputCollection;
		UCHAR m_ucNumberOfInputCollections;
		CControlItemDefaultCollection m_OutputCollection;
		CFilterClientServices *m_pFilterClientServices;
		CActionQueue	m_ActionQueue;
		CKeyMixer		m_KeyMixer;
		CMouseModel*	m_pMouseModel;
		CGckMutexHandle m_MutexHandle;
		FORCE_BLOCK*	m_pForceBlock;
		BOOLEAN			m_bFilterBlockChanged;
		BOOLEAN			m_bNeedToUpdateLEDs;
};


#endif //__Filter_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filterhooks.h ===
#ifndef __filterhooks_h__
#define __filterhooks_h__

#include "IrpQueue.h"

struct GCK_FILTER_HOOKS_DATA
{
	CGuardedIrpQueue	IrpQueue;			// @field Queue for Read Irps
	CGuardedIrpQueue	IrpTestQueue;		// @field Queue for Unapplied Change polls
	CGuardedIrpQueue	IrpRawQueue;		// @field Queue for Raw Data polls
	CGuardedIrpQueue	IrpMouseQueue;		// @field Queue for Backdoor Mouse Data polls
	CGuardedIrpQueue	IrpKeyboardQueue;	// @field Queue for Backdoor Keyboard Data polls
	CDeviceFilter		*pFilterObject;		// @field Primary Filter
	CDeviceFilter		*pSecondaryFilter;	// @field Backdoor(unapplied changes) Filter
	FILE_OBJECT			*pTestFileObject;	// @field Pointer to file object which "owns" test mode.
	KTIMER				Timer;				// @field timer object for jogging CDeviceFilter
	KDPC				DPC;				// @field DPC for jogging CDeviceFilter
};
	
class CFilterGcKernelServices : public CFilterClientServices
{
	public:
		CFilterGcKernelServices(PGCK_FILTER_EXT pFilterExt, BOOLEAN fHasVMouse = TRUE) : 
		  m_pFilterExt(pFilterExt), m_pMousePDO(NULL), m_fHasVMouse(fHasVMouse),
		  m_sKeyboardQueueHead(0), m_sKeyboardQueueTail(0)
		  {
			  ::RtlZeroMemory(m_rgXfersWaiting, sizeof(CONTROL_ITEM_XFER) * 5);
		  }
		virtual ~CFilterGcKernelServices();
		virtual ULONG				 GetVidPid();
		virtual PHIDP_PREPARSED_DATA GetHidPreparsedData();
		virtual void				 DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr);
		virtual NTSTATUS			 DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount);
		virtual ULONG				 GetTimeMs();
		virtual void				 SetNextJog(ULONG ulDelayMs);
		virtual void				 PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled);
		virtual NTSTATUS			 PlayFromQueue(IRP* pIrp);
		virtual HRESULT				 CreateMouse();
		virtual HRESULT				 CloseMouse();
		virtual HRESULT				 SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR cWheel, BOOLEAN fClutch, BOOLEAN fDampen);

		void KeyboardQueueClear();

		PGCK_FILTER_EXT GetFilterExtension() const { return m_pFilterExt; }
	private:
		PGCK_FILTER_EXT m_pFilterExt;
		PDEVICE_OBJECT	m_pMousePDO;
		BOOLEAN			m_fHasVMouse;
		short int		m_sKeyboardQueueHead;
		short int		m_sKeyboardQueueTail;

		CONTROL_ITEM_XFER m_rgXfersWaiting[5];
};


#endif //__filterhooks_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- X2 Gaming Project
//
//		Version 4.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@topic	DEBUG.H | Global definitions for debugging output
//**************************************************************************

#ifndef	DEBUG_H
#define	DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

//
// DEBUG output types (NOT LEVELS)
//
#define DBG_ENTRY		0x00000001	//Traceout on entry to function
#define DBG_EXIT		0x00000002	//Traceout on exit from function
#define DBG_WARN		0x00000004	//Traceout signifying a warning (or informational)
#define DBG_TRACE		0x00000008	//Traceout signifying a warning (or informational)
#define DBG_ERROR		0x00000010	//Traceout signifying an error
#define DBG_CRITICAL	0x00000020	//Traceout signifying a critical error
#define DBG_RT_ENTRY	0x00000040	//Traceout on entry to function (TIME CRITICAL CODE)
#define DBG_RT_EXIT		0x00000080	//Traceout on exit from function (TIME CRITICAL CODE)
#define DBG_RT_WARN		0x00000100	//Traceout signifying a warning (or informational) (TIME CRITICAL CODE)


// Combos of above for setting warning levels easily
#define DBG_NOT_RT		0x0000003F	//Traceout all above except RT codes
#define DBG_RT			0x000001C0	//Traceout RT codes
#define DBG_WARN_ERROR	0x00000134	//Traceout warnings and errors including DBG_RT_WARN
#define DBG_ALL			0xFFFFFFFF	//Traceout all codes


#if	 (DBG==1)

//
//	Declaration for debug module
//


//
//	Must start file with a #define for the DEBUG module
//
//i.e. #define __DEBUG_MODULE_IN_USE__  GCKERNEL_DEBUG_MODULE
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)\
	ULONG __DEBUG_MODULE_IN_USE__ = __x__;
#define SET_MODULE_DEBUG_LEVEL(__x__)\
	__DEBUG_MODULE_IN_USE__ = __x__;


//
//	Conditional debug output procedures
//

#define GCK_DBG_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ENTRY)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_EXIT)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_WARN)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_TRACE_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_TRACE)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_ERROR_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ERROR)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_CRITICAL_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_CRITICAL)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_ENTRY)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_EXIT)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_WARN)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define	GCK_DBG_BREAK()	DbgBreakPoint()

#undef	PAGED_CODE
#define	PAGED_CODE() \
	if (KeGetCurrentIrql() > APC_LEVEL)	\
	{\
		GCK_DBG_CRITICAL_PRINT(("GcKernel: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
   		ASSERT(FALSE);\
	}
	//External
	void SetDebugLevel(ULONG ulModuleId, ULONG ulDebugLevel);

#define USING_CASE_FALLTHROUGH_TRACE	ULONG macro_ulTraceoutSentAlready = FALSE;
#define	START_CASE_FALLTHROUGH_TRACE	macro_ulTraceoutSentAlready = FALSE;
#define TRACEOUT_THIS_CASE_ONLY			if(!macro_ulTraceoutSentAlready && (macro_ulTraceoutSentAlready=TRUE) )

#else		// DBG=0

#define	GCK_DBG_ENTRY_PRINT(__x__)
#define	GCK_DBG_EXIT_PRINT(__x__)
#define GCK_DBG_TRACE_PRINT(__x__)
#define	GCK_DBG_WARN_PRINT(__x__)
#define	GCK_DBG_ERROR_PRINT(__x__)
#define	GCK_DBG_CRITICAL_PRINT(__x__)
#define	GCK_DBG_RT_ENTRY_PRINT(__x__)
#define	GCK_DBG_RT_EXIT_PRINT(__x__)
#define	GCK_DBG_RT_WARN_PRINT(__x__)
#define	GCK_DBG_BREAK()
#undef	PAGED_CODE
#define	PAGED_CODE()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)
#define USING_CASE_FALLTHROUGH		
#define	START_CASE_FALLTHROUGH_TRACE
#define TRACEOUT_THIS_CASE_ONLY		

#endif	// DBG=?


//===========================================================================
//			End
//===========================================================================

#endif	// DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filterhooks.cpp ===
//	@doc
/**********************************************************************
*
*	@module	FilterHooks.cpp	|
*
*	Contains the hooks necessary to bridge the gap between the C driver
*	shell and the C++ filter module
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	FilterHooks	|
*	The filter.cpp module in principal can run in USER mode
*	and KERNEL mode.  It does require some system services
*	that are dependent on which mode it is running.  Additionally
*	a C module can call directly into C++ classes.  This module bridges
*	the gap.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FILTERHOOKS_CPP
#define __INCLUDES_FILTER_HOOKS_H__
extern "C"
{
	#include <wdm.h>
	#include "Debug.h"
	#include "GckShell.h"
	#include <winerror.h>
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}
#include "SWVKBD.h"
#include "swvmouse.h"
#include "Filter.h"
#include "FilterHooks.h"

#define GCK_HidP_GetReportID(__ReportPacket__) (*(PCHAR)(__ReportPacket__))
#define GCK_HidP_OutputReportLength 16
#define GCK_PIDReportID_SetEffect 1
#define GCK_PIDReportID_SetGain 13
#define GCK_PIDEffectID_Spring 1

#define GCK_Atilla_Default_FastBlinkTime_On 0x11	// (170 msec)
#define GCK_Atilla_Default_FastBlinkTime_Off 0x11	// (170 msec)

NTSTATUS _stdcall GCKF_InitFilterHooks(PGCK_FILTER_EXT pFilterExt)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_InitFilterHooks, pFilterExt = 0x%0.8x\n", pFilterExt));
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;
	
	pFilterHooks = new WDM_NON_PAGED_POOL GCK_FILTER_HOOKS_DATA;
	if(!pFilterHooks)
	{
		pFilterExt->pFilterHooks=NULL;
		GCK_DBG_ERROR_PRINT(("Not enough memory to create GCK_FILTER_HOOKS_DATA.\n"));
		return STATUS_NO_MEMORY;
	}
	pFilterExt->pFilterHooks=pFilterHooks;

	//
	//	Ensure that a virtual keyboard exists
	//
    if( NULL == Globals.pVirtualKeyboardPdo)
	{
		NtStatus = GCK_VKBD_Create(&Globals.pVirtualKeyboardPdo);
		ASSERT( NT_SUCCESS(NtStatus) );
		if( NT_ERROR(NtStatus) )
		{
			return NtStatus;
		}
	}
	Globals.ulVirtualKeyboardRefCount++;

	//
	// Initialize Timer and DPC for jogging CDeviceFilter
	//
	KeInitializeTimer(&pFilterHooks->Timer);
	KeInitializeDpc(&pFilterHooks->DPC, &GCKF_TimerDPCHandler, reinterpret_cast<PVOID>(pFilterExt));

	//
	//	Create Filter for the primary filter
	//
	CFilterGcKernelServices *pFilterGcKernelServices;
	pFilterGcKernelServices = new WDM_NON_PAGED_POOL CFilterGcKernelServices(pFilterExt);
	if( NULL == pFilterGcKernelServices)
	{
		//Out of memory for pFilterGcKernelServices, don't even attempt a CDeviceFilter
		pFilterHooks->pFilterObject = NULL;
		GCK_DBG_ERROR_PRINT(("Not enough memory to create pFilterGcKernelServices.\n"));
		NtStatus = STATUS_NO_MEMORY;
	}	
	else
	{
		//Try creating a CDeviceFilter
		GCK_DBG_TRACE_PRINT(("Creating Filter Object\n"));
		pFilterHooks->pFilterObject  = new WDM_NON_PAGED_POOL CDeviceFilter(pFilterGcKernelServices);
		
		//succeed or fail, we are done with pFilterGcKernelServices
		pFilterGcKernelServices->DecRef();
		if( NULL == pFilterHooks->pFilterObject)
		{
			GCK_DBG_ERROR_PRINT(("Not enough memory to create filter object.\n"));
			NtStatus = STATUS_NO_MEMORY;
		}
	}
	
	// The device is currently NOT in test mode
	pFilterHooks->pTestFileObject = NULL;
	pFilterHooks->pSecondaryFilter=NULL;
		
	// Initialize IRP Queue
	pFilterHooks->IrpQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
								(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
								 &pFilterExt->RemoveLock
								);
	pFilterHooks->IrpTestQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpRawQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpMouseQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpKeyboardQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	
	GCK_DBG_EXIT_PRINT(("Exiting GCKF_InitFilterHooks, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;	
}

void _stdcall GCKF_DestroyFilterHooks(PGCK_FILTER_EXT pFilterExt)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_DestroyFilterHooks, pFilterExt = 0x%0.8x\n", pFilterExt));
	
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	
	//
	//	Delete filters if there are some
	//
	volatile CDeviceFilter *pTempFilterPointer;
	if(pFilterHooks->pFilterObject)
	{
		pTempFilterPointer = pFilterHooks->pFilterObject;
		pFilterHooks->pFilterObject = NULL;
		delete pTempFilterPointer;
	}
	if(pFilterHooks->pSecondaryFilter)
	{
		pTempFilterPointer = pFilterHooks->pSecondaryFilter;
		pFilterHooks->pSecondaryFilter= NULL;
		delete pTempFilterPointer;
	}

	//
	//	Decrement refcount of Virtual Keyboard users, and close virtual keyboard if necessary
	//
	if( 0 == --Globals.ulVirtualKeyboardRefCount)
	{
		if( NT_SUCCESS( GCK_VKBD_Close( Globals.pVirtualKeyboardPdo ) ) )
		{
			Globals.pVirtualKeyboardPdo = 0;
		}
		else
		{
			ASSERT(FALSE);
		}
	}

	//Destroy IrpQueue (cancelling any Irps that may be in it).
	pFilterHooks->IrpQueue.Destroy();
	pFilterHooks->IrpTestQueue.Destroy();
	pFilterHooks->IrpRawQueue.Destroy();
	pFilterHooks->IrpMouseQueue.Destroy();
	pFilterHooks->IrpKeyboardQueue.Destroy();

	// delete the filter hooks itself
	delete pFilterExt->pFilterHooks;
	pFilterExt->pFilterHooks = NULL;

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_DestroyFilterHooks\n"));
}

NTSTATUS _stdcall GCKF_BeginTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	PCHAR pCommandBuffer,
	ULONG ulBufferSize,
	FILE_OBJECT *pFileObject
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;

	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}

	if(pFilterHooks->pTestFileObject)
	{
		ASSERT( pFilterHooks->pSecondaryFilter);
		//delete is safe even if NULL
		volatile CDeviceFilter *pTempFilter = pFilterHooks->pSecondaryFilter;
		pFilterHooks->pSecondaryFilter = NULL;
		pFilterHooks->pTestFileObject = NULL;
		delete pTempFilter;
	}

	CFilterGcKernelServices *pFilterGcKernelServices;
	pFilterGcKernelServices = new WDM_NON_PAGED_POOL CFilterGcKernelServices(pFilterExt, FALSE);
	if( NULL == pFilterGcKernelServices)
	{
		//Out of memory for pFilterGcKernelServices, don't even attempt a CDeviceFilter
		GCK_DBG_ERROR_PRINT(("Not enough memory to create pFilterGcKernelServices.\n"));
		NtStatus = STATUS_NO_MEMORY;
	}	
	else
	{
		//Try creating a CDeviceFilter
		GCK_DBG_TRACE_PRINT(("Creating Filter Object\n"));
		pFilterHooks->pSecondaryFilter  = new WDM_NON_PAGED_POOL CDeviceFilter(pFilterGcKernelServices);
		
		//succeed or fail, we are done with pFilterGcKernelServices
		pFilterGcKernelServices->DecRef();
		if (pFilterHooks->pSecondaryFilter == NULL)
		{
			GCK_DBG_ERROR_PRINT(("Not enough memory to create filter object.\n"));
			NtStatus = STATUS_NO_MEMORY;
		}
		else
		{
			// Keep track of the active set everytime we change filters
			if (pFilterHooks->pFilterObject)
			{
				pFilterHooks->pFilterObject->OtherFilterBecomingActive();
				pFilterHooks->pFilterObject->CopyToTestFilter(*(pFilterHooks->pSecondaryFilter));
			}
			pFilterHooks->pTestFileObject = pFileObject;
			NtStatus = GCKF_UpdateTestScheme(pFilterExt, pCommandBuffer, ulBufferSize, pFileObject);
		}
	}
	return NtStatus;
}

NTSTATUS _stdcall GCKF_UpdateTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	PCHAR pCommandBuffer,
	ULONG ulBufferSize,
	FILE_OBJECT *pFileObject
)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks;
	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}
	
	//Only the last one to call GCKF_BeginTestScheme can update it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}
	
	ASSERT(pFilterHooks->pSecondaryFilter);

	NTSTATUS NtStatus = GCKF_ProcessCommands(pFilterExt, pCommandBuffer, ulBufferSize, FALSE);
	pFilterHooks->pSecondaryFilter->UpdateAssignmentBasedItems(TRUE);

	return NtStatus;
}

NTSTATUS _stdcall GCKF_EndTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	FILE_OBJECT *pFileObject
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;

	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}
	
	//Only the last one to call GCKF_BeginTestScheme can End it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}

//	volatile CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	pFilterHooks->pSecondaryFilter = NULL;
	pFilterHooks->pTestFileObject = NULL;

	CDeviceFilter* pPrimaryFilter = pFilterHooks->pFilterObject;
	if (pDeviceFilter != NULL)
	{
		// Stop any partially playing items
		pDeviceFilter->OtherFilterBecomingActive();

		if (pPrimaryFilter != NULL)
		{
			// Keep track of the active set everytime we change filters
			pPrimaryFilter->SetActiveSet(pDeviceFilter->GetActiveSet());
			GCKF_OnForceFeedbackChangeNotification(pFilterExt, (void*)pPrimaryFilter->GetForceBlock());
			pPrimaryFilter->UpdateAssignmentBasedItems(TRUE);
		}
		delete pDeviceFilter;
	}
	
	return NtStatus;
}

NTSTATUS _stdcall GCKF_ProcessCommands( IN PGCK_FILTER_EXT pFilterExt, IN PCHAR pCommandBuffer, IN ULONG ulBufferSize, BOOLEAN fPrimaryFilter)
{

	NTSTATUS NtStatus = STATUS_SUCCESS;
	ULONG ulRemainingBuffer = ulBufferSize;
	COMMAND_DIRECTORY *pCommandDirectory;
	COMMAND_DIRECTORY *pNextCommandDirectory;
	ULONG ulDirectorySize;

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if( !pFilterHooks || ! pFilterHooks->pFilterObject )
	{
		return STATUS_NOT_FOUND;
	}

	CDeviceFilter *pDeviceFilter;
	//If there is a secondary filter all commands go to it
	if(!fPrimaryFilter && pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterHooks->pFilterObject;
	}

	pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandBuffer);
	
	//Verify that we are a directory
	ASSERT(eDirectory == pCommandDirectory->CommandHeader.eID);
	if(eDirectory != pCommandDirectory->CommandHeader.eID)
	{
		return STATUS_INVALID_PARAMETER;
	}
	
	//Verify that the total size is as big as input buffer
	ASSERT( ulBufferSize >= pCommandDirectory->ulEntireSize );
	if( ulBufferSize < pCommandDirectory->ulEntireSize )
	{
		return STATUS_INVALID_PARAMETER;
	}

	//
	//	Call the filters ProcessCommands
	//
	NtStatus = pDeviceFilter->ProcessCommands(pCommandDirectory);

	// Update any assignment based items (don't ignore working/active relationship)
	pDeviceFilter->UpdateAssignmentBasedItems(FALSE);

	if (pDeviceFilter->DidFilterBlockChange())	// Did the force block change
	{	// Yes - Reset the flag and Send a Change Notification
		pDeviceFilter->ResetFilterChange();
		if (pDeviceFilter->GetForceBlock() != NULL)
		{
			GCKF_OnForceFeedbackChangeNotification(pFilterExt, (void*)pDeviceFilter->GetForceBlock());
		}
	}

	//
	//	If internal polling is on, we may need to get the ball rolling
	//	I don't really care if this fails
	//
	GCK_IP_OneTimePoll(pFilterExt);

	return NtStatus;
}

unsigned char g_rgbCombinePedalsCmd[170] = {
    0x00, 0x00, 0x00, 0x00, // Dir
    0x0e, 0x00, 0x00, 0x00, // Bytes
    0x02, 0x00,             // Items
    0x9a, 0x00, 0x00, 0x00, // Total

        0x00, 0x00, 0x00, 0x00, // Dir
        0x0e, 0x00, 0x00, 0x00, 
        0x02, 0x00, 
        0x46, 0x00, 0x00, 0x00, 

            0x01, 0x00, 0x01, 0x00, // eRecordableAction
            0x18, 0x00, 0x00, 0x00, 
            0x02, 0x00, 0x00, 0x00, // Accel
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 

            0x0c, 0x00, 0x02, 0x80, // eAxisMap
            0x20, 0x00, 0x00, 0x00, // Bytes
            0xff, 0xff, 0xff, 0xff, // VIDPID
            0x00, 0x02, 0x00, 0x00, // lCoefficient1024x
            0x02, 0x00, 0x00, 0x00, // ulItemIndex - to Y
            0x01, 0x00, 0x00, 0x00, // lValX
            0x00, 0x00, 0x00, 0x00, // lValY
            0x00, 0x00, 0x00, 0x00, // ulModifiers

        0x00, 0x00, 0x00, 0x00, // Dir
        0x0e, 0x00, 0x00, 0x00, 
        0x02, 0x00, 
        0x46, 0x00, 0x00, 0x00, 

            0x01, 0x00, 0x01, 0x00, 
            0x18, 0x00, 0x00, 0x00, 
            0x03, 0x00, 0x00, 0x00, // Brake
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 

            0x0c, 0x00, 0x02, 0x80, // eAxisMap
            0x20, 0x00, 0x00, 0x00, // Bytes
            0xff, 0xff, 0xff, 0xff, // VIDPID
            0x00, 0xfe, 0xff, 0xff, // lCoefficient1024x
            0x02, 0x00, 0x00, 0x00, // ulItemIndex - to Y
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00 

};

void _stdcall GCKF_SetInitialMapping( IN PGCK_FILTER_EXT pFilterExt )
{
    if( ( pFilterExt->HidInfo.HidCollectionInfo.ProductID == 0x001A )
     || ( pFilterExt->HidInfo.HidCollectionInfo.ProductID == 0x0034 ) )
    {
	    GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	    if( pFilterHooks && pFilterHooks->pFilterObject )
	    {
    	    COMMAND_DIRECTORY *pCommandDirectory;
	        
            pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(g_rgbCombinePedalsCmd);
	        
	        //
	        //	Call the filters ProcessCommands
	        //
	        pFilterHooks->pFilterObject->ProcessCommands(pCommandDirectory);
	    }
    }
}

NTSTATUS _stdcall GCKF_IncomingReadRequests(PGCK_FILTER_EXT pFilterExt, PIRP pIrp)
{
	NTSTATUS NtStatus;
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_IncomingReadRequests, pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n", pFilterExt, pIrp));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if(pFilterHooks)
	{
		// Was this a real incoming request or result of one time poll?
		if (pIrp != NULL)
		{	// real incoming request
			NtStatus = pFilterHooks->IrpQueue.Add(pIrp);
		}

		//If there is a secondary filter all commands go to it
		CDeviceFilter *pDeviceFilter;
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
		if (pDeviceFilter != NULL)
		{
			pDeviceFilter->IncomingRequest();
		}
	}
	else
	{
		STATUS_NO_MEMORY;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCKF_IncomingReadRequests, Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

VOID __stdcall GCKF_KickDeviceForData(IN PGCK_FILTER_EXT pFilterExt)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if(pFilterHooks)
	{
		//If there is a secondary filter all commands go to it
		CDeviceFilter *pDeviceFilter = pFilterHooks->pFilterObject;
		// Do device based stuff here
		if ((pDeviceFilter != NULL) && (pDeviceFilter->GetFilterClientServices() != NULL))
		{
			// Kick the device for some data (DI should hopefully be loaded now)
			ULONG ulVidPid = pDeviceFilter->GetFilterClientServices()->GetVidPid();
			if (ulVidPid == 0x045E0033)		// Atilla (Strategic Commander, for you marketing types)
			{	// Need to send down a set blink rate feature
				UCHAR blinkRateFeatureData[] = {
					2,										// Report ID
					GCK_Atilla_Default_FastBlinkTime_On,	// Blink On
					GCK_Atilla_Default_FastBlinkTime_Off	// Blink off
				};
				pDeviceFilter->GetFilterClientServices()->DeviceSetFeature(blinkRateFeatureData, 3);
			}
		}
	}
}

NTSTATUS _stdcall GCKF_IncomingInputReports(PGCK_FILTER_EXT pFilterExt, PCHAR pcReport, IO_STATUS_BLOCK IoStatus)
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_IncomingInputReports, pFilterExt = 0x%0.8x, pcReport = 0x%0.8x, Information = 0x%0.8x, Status = 0x%0.8x\n",
							pFilterExt,
							pcReport,
							IoStatus.Information,
							IoStatus.Status));


	//
	// If there is an error, or there is no filter, or this is a PID report(>1) just short circuit to completing the IRPs
	//
	if( 
		NT_ERROR(IoStatus.Status) || 
		NULL==pFilterExt->pFilterHooks || 
		NULL==pFilterExt->pFilterHooks->pFilterObject ||
		GCK_HidP_GetReportID(pcReport) > 1
	)
	{
		GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_IncomingInputReports by calling GCKF_CompleteReadRequests and returning its value\n"));
		return GCKF_CompleteReadRequests(pFilterExt, pcReport, IoStatus);
	}

	//
	//	Honor requests for Raw Data
	//
	CTempIrpQueue TempIrpQueue;
	pFilterExt->pFilterHooks->IrpRawQueue.RemoveAll(&TempIrpQueue);
		
	PIRP pIrp;
	while(pIrp=TempIrpQueue.Remove())
	{
		//Copy Status
		pIrp->IoStatus = IoStatus;

		//
		//	If latest data is success, copy it to the user buffer
		//
		if( NT_SUCCESS(IoStatus.Status) )
		{
			//
			//	Make get pointer to buffer and make sure IRP has room for report
			//
			PCHAR pcIrpBuffer;
			ASSERT(pIrp->MdlAddress);
			pcIrpBuffer = (PCHAR)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
			if(pcIrpBuffer)
            {
			    ASSERT( pFilterExt->HidInfo.HidPCaps.InputReportByteLength <= MmGetMdlByteCount(pIrp->MdlAddress) );
				
			    //
			    //	Copy data to output buffer
			    //
			    RtlCopyMemory(pcIrpBuffer, (PVOID)pcReport, pIrp->IoStatus.Information);
            }
		}
		
		//
		//	Complete the IRP
		//
		GCK_DBG_RT_WARN_PRINT(("Completing read IRP(0x%0.8x).\n", pIrp));
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	}

	//
	// Send data to the filter
	//
	GCK_DBG_RT_WARN_PRINT(("Calling device filter.\n"));

	//If there is a secondary filter all commands go to it
	CDeviceFilter *pDeviceFilter;
	if(pFilterExt->pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
	}
	pDeviceFilter->ProcessInput(pcReport, IoStatus.Information);
	
	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_IncomingInputReports STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}

NTSTATUS _stdcall GCKF_CompleteReadRequests(PGCK_FILTER_EXT pFilterExt, PCHAR pcReport, IO_STATUS_BLOCK IoStatus)
{
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_CompleteReadRequests, pFilterExt = 0x%0.8x, pcReport = 0x%0.8x, Information = 0x%0.8x, Status = 0x%0.8x\n",
							pFilterExt,
							pcReport,
							IoStatus.Information,
							IoStatus.Status));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_SUCCESS;
	}
	
	//Get all pending Irps out of the guarded queue and into a temporary one
	CTempIrpQueue TempIrpQueue;
	
	//If there is a secondary filter (test mode), we do not honor simple poll requests
	// -- but we do honor reports we don't care about (Report ID > 1)
	if (pFilterHooks->pSecondaryFilter == NULL || GCK_HidP_GetReportID(pcReport) > 1)
	{
		pFilterHooks->IrpQueue.RemoveAll(&TempIrpQueue);
	}

	//Always honor backdoor filter poll requests
	// -- unless we are getting a report we don't care about ( Report ID > 1)
	if (GCK_HidP_GetReportID(pcReport) <= 1)
	{
		pFilterHooks->IrpTestQueue.RemoveAll(&TempIrpQueue);
	}

	//walk temporary list and complete everything
	PIRP pIrp;
	while(pIrp=TempIrpQueue.Remove())
	{
		//Copy Status
		pIrp->IoStatus = IoStatus;

		//
		//	If latest data is success, copy it to the user buffer
		//
		if( NT_SUCCESS(IoStatus.Status) )
		{
			//
			//	Make get pointer to buffer and make sure IRP has room for report
			//
			PCHAR pcIrpBuffer;
			ASSERT(pIrp->MdlAddress);
			pcIrpBuffer = (PCHAR)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
			if(pcIrpBuffer)
            {
			    ASSERT( pFilterExt->HidInfo.HidPCaps.InputReportByteLength <= MmGetMdlByteCount(pIrp->MdlAddress) );
				    
			    //
			    //	Copy data to output buffer
			    //
			    RtlCopyMemory(pcIrpBuffer, (PVOID)pcReport, pIrp->IoStatus.Information);
            }
		}
		
		//
		//	Complete the IRP
		//
		GCK_DBG_RT_WARN_PRINT(("Completing read IRP(0x%0.8x).\n", pIrp));
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	}

	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_CompleteReadRequests - STATUS_SUCCESS\n"));									
	return STATUS_SUCCESS;
}

void _stdcall GCKF_CompleteReadRequestsForFileObject(PGCK_FILTER_EXT pFilterExt, PFILE_OBJECT pFileObject)
{
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_CompleteReadRequestsForFileObject, pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x\n",
							pFilterExt,
							pFileObject));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	ASSERT(pFilterHooks);
	
	//Cancel all the IRPs pending for the given file object
	pFilterHooks->IrpQueue.CancelByFileObject(pFileObject);

	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_CompleteReadRequestsForFileObject\n"));
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_InternalWriteFileComplete(IN PGCK_FILTER_EXT pFilterExt, )
**
**	@func	Creates a Write IRP and sends to next driver
**
*************************************************************************************/
/*
NTSTATUS
GCKF_InternalWriteFileComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext					// [NOTHING YET] Perhaps send an even for signaling
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);

	DbgPrint("Calling Free IRP\n");
	IoFreeIrp(pIrp);
	DbgPrint("Deallocating Write Buffer (0x%08X)\n", pContext);
	if (pContext != NULL)
	{
		 ExFreePool(pContext);
	}

	DbgPrint("Returning Read Complete\n");

	return STATUS_MORE_PROCESSING_REQUIRED;
}
*/

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_InternalWriteFile(IN PGCK_FILTER_EXT pFilterExt, )
**
**	@func	Creates a Write IRP and sends to next driver
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_InternalWriteFile
(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Device Extension of Filter Device
	unsigned char* pWriteData,		//@parm [IN] Block of Data to write to device
	ULONG ulLength					//@parm [IN] Length of data block to write
)
{
	ASSERT((ulLength < 1024) && (ulLength > 0));	// Don't want to be allocating too much (or 0)

	NTSTATUS statusReturn = STATUS_INSUFFICIENT_RESOURCES;

	// Allocate non paged data for the IRP
	unsigned char* pNonPagedWriteData = (unsigned char*)EX_ALLOCATE_POOL(NonPagedPool, sizeof(unsigned char) * ulLength);
	if (pNonPagedWriteData != NULL)
	{
		::RtlCopyMemory((void*)pNonPagedWriteData, (const void*)pWriteData, ulLength);

		// Set up event for IRP
		KEVENT keventIrpComplete;
		::KeInitializeEvent(&keventIrpComplete, NotificationEvent, FALSE);

		// Build the IRP
		LARGE_INTEGER lgiBufferOffset;
		lgiBufferOffset.QuadPart = 0;
		IO_STATUS_BLOCK ioStatusBlock;
		IRP* pWriteIrp = IoBuildSynchronousFsdRequest(	IRP_MJ_WRITE, pFilterExt->pTopOfStack,
														pNonPagedWriteData, ulLength, &lgiBufferOffset,
														&keventIrpComplete, &ioStatusBlock);

		// Was the build succesfull
		if (pWriteIrp != NULL)
		{
			// Call the lower driver with the IRP
			statusReturn = IoCallDriver(pFilterExt->pTopOfStack, pWriteIrp);
			if (statusReturn == STATUS_PENDING)
			{
				KeWaitForSingleObject(&keventIrpComplete, Executive, KernelMode, FALSE, 0);
				statusReturn = ioStatusBlock.Status;
			}
		}
		ExFreePool(pNonPagedWriteData);
	}

	return statusReturn;
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_IncomingForceFeedbackChangeNotificationRequest(IN PGCK_FILTER_EXT pFilterExt, PIRP pIrp)
**
**	@func	Adds IOCTL to Force Feedback Notify On Change Queue
**			If the Queue does not exist it is created here (most devices do not need one)
**
**	@rdesc	STATUS_NO_MEMORY - If Queue could not be created
**			or return of IrpQueue->Add(...)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_IncomingForceFeedbackChangeNotificationRequest
(
	IN PGCK_FILTER_EXT pFilterExt,		//@parm [IN] Device Extension of Filter Device
	IN PIRP pIrp						//@parm [IN] The IRP to be queued
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_IncomingForceFeedbackChangeNotificationRequest, pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n", pFilterExt, pIrp));

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue == NULL)	// Has it been created before
	{	// Wasn't created - Create it
		pFFNotificationQueue = new WDM_NON_PAGED_POOL CGuardedIrpQueue;
		if (pFFNotificationQueue == NULL)	// Able to create
		{	// Wasn't able to create, return low memory error
			GCK_DBG_ERROR_PRINT(("Unable to allocate Force-Feedback change notification Queue"));
			return STATUS_NO_MEMORY;
		}
		pFilterExt->pvForceIoctlQueue = (void*)pFFNotificationQueue;
		pFFNotificationQueue->Init(0, (CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock, &pFilterExt->RemoveLock);
	}

	// Add item to Queue
	NTSTATUS NtStatus = pFFNotificationQueue->Add(pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_IncomingForceFeedbackChangeNotificationRequest, Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_ProcessForceFeedbackChangeNotificationRequests(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	Completes all IOCTLs on the Force-Feedback notification Queue
**			Doesn't delete the Queue (assumes it might be reused)
**
**	@rdesc	STATUS_SUCCESS (always)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_ProcessForceFeedbackChangeNotificationRequests
(
	IN PGCK_FILTER_EXT pFilterExt		//@parm [IN] Device Extension of Filter Device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_ProcessForceFeedbackChangeNotificationRequests, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue != NULL)	// Is there even a Queue
	{	// Exists, complete the IOCTLs
		CTempIrpQueue tempIrpQueue;
		pFFNotificationQueue->RemoveAll(&tempIrpQueue);

		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			// Set status
			pIrp->IoStatus.Status = STATUS_SUCCESS;

			// Get memory location and NULL it
			void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
			if (pvUserData != NULL)
			{
				pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
				RtlZeroMemory(pvUserData, sizeof(FORCE_BLOCK));
			}

			//	Complete the IRP
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		}
	}

	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	void _stdcall  GCKF_OnForceFeedbackChangeNotification(IN PGCK_FILTER_EXT pFilterExt, const IN FORCE_BLOCK* pForceBlock)
**
**	@func	Completes all IOCTLs on the Force-Feedback notification Queue
**			Doesn't delete the Queue (assumes it might be reused)
**
*************************************************************************************/
void _stdcall GCKF_OnForceFeedbackChangeNotification
(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Device Extension of Filter Device
	const void* pForceBlock			//@parm [IN] Block of Data to send back to device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_ProcessForceFeedbackChangeNotificationRequests, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Did we get sent a valid force block
	if (pForceBlock == NULL)
	{
		return;
	}

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue != NULL)	// Is there even a Queue
	{	// Exists, complete the IOCTLs
		CTempIrpQueue tempIrpQueue;
		pFFNotificationQueue->RemoveAll(&tempIrpQueue);
			
		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
			if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(FORCE_BLOCK))
			{
				void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
				if (pvUserData != NULL)
				{
					pIrp->IoStatus.Status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
					::RtlCopyMemory(pvUserData, pForceBlock, sizeof(FORCE_BLOCK));
				}
				else
				{
					pIrp->IoStatus.Status = STATUS_NO_MEMORY;
				}
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			}

			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		}
	}


	// Send a modification of the spring to the wheel
	// 1. Allocate an array of max output size
	unsigned char pbOutReport[GCK_HidP_OutputReportLength];

	// 2. Zero out array
	RtlZeroMemory((void*)pbOutReport, GCK_HidP_OutputReportLength);

	// 3. Set the proper report ID
	pbOutReport[0] = GCK_PIDReportID_SetEffect;

	// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
	pbOutReport[1] = GCK_PIDEffectID_Spring;		// Effect Block Index (ID)
	unsigned short usRTC = ((FORCE_BLOCK*)pForceBlock)->usRTC;		// 0 - 10K
	usRTC /= 100;									// 0 - 100
	usRTC *= 255;									// 0 - 25500
	usRTC /= 100;									// 0 - 255
	if (usRTC > 255)
	{
		usRTC = 255;
	}
	pbOutReport[9] = unsigned char(usRTC);		// Effect Gain - Only item the RTC Spring will look at

	// Now that the firmware has change for Godzilla it looks at bunches o stuff
	pbOutReport[7] = 1;  //sample period
	pbOutReport[11] =132;  //direction-axis + FW only force polar flag
	pbOutReport[13] = 255; //Y - direction

	// 5. Send the report down
	GCKF_InternalWriteFile(pFilterExt, pbOutReport, GCK_HidP_OutputReportLength);

	// Send the change for the gain

	// 1. Rezero the memory
	RtlZeroMemory((void*)pbOutReport, GCK_HidP_OutputReportLength);

	// 2. Set the proper report ID
	pbOutReport[0] = GCK_PIDReportID_SetGain;

	// 3. Figure and set the gain
	unsigned short usGain = ((FORCE_BLOCK*)pForceBlock)->usGain;	// 0 - 10K
	usGain /= 100;	// 0 - 100
	usGain *= 255;	// 0 - 25500
	usGain /= 100;	// 0 - 255
	if (usGain > 255)
	{
		usGain = 255;
	}
	pbOutReport[1] = unsigned char(usGain);

	// 4. Send the gain report down
	GCKF_InternalWriteFile(pFilterExt, pbOutReport, GCK_HidP_OutputReportLength);

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_ProcessForceFeedbackChangeNotificationRequests\n"));
}

/***********************************************************************************
**
**	NTSTAUS _stdcall  GCKF_GetForceFeedbackData(IN PIRP pIrp, IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	
**
**	@rdesc	STATUS_SUCCESS (always)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_GetForceFeedbackData
(
	IN PIRP pIrp,					//@parm [IN, OUT] The IRP (output block is stored in the IRP)
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Device Extension of Filter Device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_GetForceFeedbackData, pFilterExt = 0x%0.8x\n", pFilterExt));

	GCK_FILTER_HOOKS_DATA* pFilterHooks=pFilterExt->pFilterHooks;

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	if (pFilterExt->pFilterHooks != NULL)
	{
		if (pFilterExt->pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
		}
	}

	// Get the Force Block from the filter and place it in the Proper place of the return IRP
	if (pDeviceFilter != NULL)
	{
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(FORCE_BLOCK))
		{
			void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
			if (pvUserData != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
				if (pDeviceFilter->GetForceBlock() != NULL)
				{
					::RtlCopyMemory(pvUserData, pDeviceFilter->GetForceBlock(), sizeof(FORCE_BLOCK));
				}
				else
				{
					::RtlZeroMemory(pvUserData, sizeof(FORCE_BLOCK));
				}
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_GetForceFeedbackData, Status =  0x%0.8x.\n", pIrp->IoStatus.Status));
	return pIrp->IoStatus.Status;
}



VOID _stdcall
GCKF_TimerDPCHandler(
    IN PKDPC,
    IN PVOID DeferredContext,
    IN PVOID,
    IN PVOID
    )
{
	PGCK_FILTER_EXT pFilterExt = reinterpret_cast<PGCK_FILTER_EXT>(DeferredContext);
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	ASSERT(pFilterHooks);
	if( 
		(NULL == pFilterHooks) ||
		(NULL == pFilterHooks->pFilterObject)
	) return;
	
	//If there is a secondary filter all commands go to it
	CDeviceFilter *pDeviceFilter;
	if(pFilterExt->pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterHooks->pFilterObject;
	}
	pDeviceFilter->JogActionQueue
				(
					reinterpret_cast<PCHAR>(pFilterExt->pucLastReport),
					pFilterExt->HidInfo.HidPCaps.InputReportByteLength
				);
}


NTSTATUS _stdcall	GCKF_EnableTestKeyboard
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fEnable,
	IN PFILE_OBJECT pFileObject
)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	
	if(!pFilterHooks)
	{
		return STATUS_DELETE_PENDING;
	}

	//Only the last one to call GCKF_BeginTestScheme can update it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}

	CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	if(pDeviceFilter)
	{
		pDeviceFilter->EnableKeyboard(fEnable);
		return STATUS_SUCCESS;
	}
	//really shouldn't get here
	ASSERT(FALSE);
	return STATUS_UNSUCCESSFUL;
}

NTSTATUS _stdcall GCKF_SetWorkingSet(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Pointer to device extention
	IN UCHAR ucWorkingSet			//@parm [IN] Working set to set to
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_SetWorkingSet, pFilterExt = 0x%0.8x  working set: %d\n", pFilterExt, ucWorkingSet));

	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

	// Find the active filter
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	CDeviceFilter *pDeviceFilter = NULL;

	// Place the working set in both filters
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter != NULL)
		{
			ntStatus = pFilterHooks->pSecondaryFilter->SetWorkingSet(ucWorkingSet);
		}
		if (pFilterHooks->pFilterObject != NULL)
		{
			ntStatus = pFilterHooks->pFilterObject->SetWorkingSet(ucWorkingSet);
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_SetWorkingSet, Status =  0x%0.8x.\n", ntStatus));
	return ntStatus;
}

NTSTATUS _stdcall GCKF_QueryProfileSet
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_QueryProfileSet, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
	}

	// Place data in the proper place of the return IRP
	if (pDeviceFilter != NULL)
	{
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(GCK_QUERY_PROFILESET))
		{
			GCK_QUERY_PROFILESET* pProfileSetData = (GCK_QUERY_PROFILESET*)(pIrp->AssociatedIrp.SystemBuffer);
			if (pProfileSetData != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(GCK_QUERY_PROFILESET);
				pProfileSetData->ucActiveProfile = pDeviceFilter->GetActiveSet();
//				DbgPrint("pProfileSetData->ucActiveProfile: %d\n", pProfileSetData->ucActiveProfile);
				pProfileSetData->ucWorkingSet = pDeviceFilter->GetWorkingSet();
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_QueryProfileSet, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

NTSTATUS _stdcall GCKF_SetLEDBehaviour
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_SetLEDBehaviour, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
	}

	if (pDeviceFilter != NULL)
	{
		// Send the Data to the device
		GCK_LED_BEHAVIOUR_OUT* pLEDBehaviour = (GCK_LED_BEHAVIOUR_OUT*)(pIrp->AssociatedIrp.SystemBuffer);
		pDeviceFilter->SetLEDBehaviour(pLEDBehaviour);

		// Retreive the information from the device
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(GCK_LED_BEHAVIOUR_IN))
		{
			GCK_LED_BEHAVIOUR_IN* pLEDStates = (GCK_LED_BEHAVIOUR_IN*)(pIrp->AssociatedIrp.SystemBuffer);
			if (pLEDStates != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(GCK_QUERY_PROFILESET);
				pLEDStates->ulLEDsOn = 0x02;
				pLEDStates->ulLEDsBlinking = 0x01;
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_SetLEDBehaviour, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

NTSTATUS _stdcall GCKF_TriggerRequest
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_TriggerRequest, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper active device filter
	CDeviceFilter *pDeviceFilter = NULL;
	if (pFilterExt != NULL)
	{
		if (pFilterExt->pFilterHooks != NULL)
		{
			if (pFilterExt->pFilterHooks->pSecondaryFilter)
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
			}
			else
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
			}
		}
	}
	if (pDeviceFilter != NULL)
	{
		if (pDeviceFilter->TriggerRequest(pIrp) == TRUE)	// We need to Queue it
		{
			CGuardedIrpQueue* pTriggerNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvTriggerIoctlQueue);
			if (pTriggerNotificationQueue == NULL)		// Hasn't yet been created
			{	// So create it
				pTriggerNotificationQueue = new WDM_NON_PAGED_POOL CGuardedIrpQueue;
				if (pTriggerNotificationQueue == NULL)	// Were we able to create
				{	// Wasn't able to create, return low memory error
					GCK_DBG_ERROR_PRINT(("Unable to allocate Trigger notification Queue"));
					pIrp->IoStatus.Status = STATUS_NO_MEMORY;
				}
				else		// Successfully created, initialize
				{
					pFilterExt->pvTriggerIoctlQueue = (void*)pTriggerNotificationQueue;
					pTriggerNotificationQueue->Init(0, (CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock, &pFilterExt->RemoveLock);
				}
			}
			if (pTriggerNotificationQueue != NULL)
			{
				pIrp->IoStatus.Status = pTriggerNotificationQueue->Add(pIrp);
			}
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_TriggerRequest, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

void _stdcall GCKF_ResetKeyboardQueue
(
	DEVICE_OBJECT* pFilterHandle	//@parm [IN] Pointer to Device Extension
)
{
	if (pFilterHandle == NULL)
	{
		return;
	}

	PGCK_FILTER_EXT pFilterExt = (PGCK_FILTER_EXT)(pFilterHandle->DeviceExtension);
	if (pFilterExt != NULL)
	{
		// Find the proper active device filter
		CDeviceFilter *pDeviceFilter = NULL;
		if (pFilterExt->pFilterHooks != NULL)
		{
			if (pFilterExt->pFilterHooks->pSecondaryFilter)
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
			}
			else
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
			}
		}
		if (pDeviceFilter != NULL)
		{
			((CFilterGcKernelServices*)pDeviceFilter->GetFilterClientServices())->KeyboardQueueClear();
		}
	}
}

CFilterGcKernelServices::~CFilterGcKernelServices()
{
	if(m_pMousePDO)
	{
		PDEVICE_OBJECT pTemp = m_pMousePDO;
		m_pMousePDO = NULL;
		GCK_VMOU_Close(pTemp);
	}
}

ULONG CFilterGcKernelServices::GetVidPid()
{
	//BUGBUG The fact that one can get the VendorID and ProductID
	//BUGBUG from the HIDP_COLLECTION_INFO structure is not documented in the
	//BUGBUG DDK, I found this out by reading hid.dll code!  I know of no
	//BUGBUG documented way to get this info in kernel mode, so I use it anyway.
	ULONG ulVidPid = m_pFilterExt->HidInfo.HidCollectionInfo.VendorID;
	ulVidPid = (ulVidPid << 16) +  m_pFilterExt->HidInfo.HidCollectionInfo.ProductID;
	return ulVidPid;
}

PHIDP_PREPARSED_DATA CFilterGcKernelServices::GetHidPreparsedData()
{
	return m_pFilterExt->HidInfo.pHIDPPreparsedData;
}

void CFilterGcKernelServices::DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr)
{
	IO_STATUS_BLOCK IoStatus;
	IoStatus.Information = ulByteCount;
	IoStatus.Status = hr & ~FACILITY_NT_BIT;  //This reverses HRESULT_FROM_NT()
	GCKF_CompleteReadRequests(m_pFilterExt, pcReport, IoStatus);
}

NTSTATUS DeviceSetFeatureComplete(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID pvContext)
{
	UNREFERENCED_PARAMETER(pvContext);
	UNREFERENCED_PARAMETER(pDeviceObject);

	// We did it all, we clean it all up. Nothing to return, no one waits on this one
	delete[] pIrp->AssociatedIrp.SystemBuffer;
	pIrp->AssociatedIrp.SystemBuffer = NULL;
	delete[] pIrp->UserIosb;
	pIrp->UserIosb = NULL;
	IoFreeIrp(pIrp);

	// Important! Or else system will try to free it and remove it from lists where it is not!
	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS CFilterGcKernelServices::DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount)
{
	
	ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

	if ((m_pFilterExt == NULL) || (m_pFilterExt->InternalPoll.pInternalFileObject == NULL))
	{
		return STATUS_DEVICE_NOT_READY;		// Actually it is the driver that isn't ready
	}

	PIRP pIrp = IoAllocateIrp(m_pFilterExt->pPDO->StackSize, FALSE);
	if (pIrp == NULL)
	{
		return STATUS_NO_MEMORY;
	}


	pIrp->Flags = IRP_BUFFERED_IO;
	pIrp->RequestorMode = KernelMode;
	pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
	pIrp->AssociatedIrp.SystemBuffer = new WDM_NON_PAGED_POOL UCHAR[ulByteCount];
	if (pIrp->AssociatedIrp.SystemBuffer == NULL)
	{
		IoFreeIrp(pIrp);
		return STATUS_NO_MEMORY;
	}
	::RtlCopyMemory((void*)(pIrp->AssociatedIrp.SystemBuffer), pvBuffer, ulByteCount);
	pIrp->UserIosb = (IO_STATUS_BLOCK*)(new WDM_NON_PAGED_POOL UCHAR[sizeof(IO_STATUS_BLOCK)]);
	if (pIrp->UserIosb == NULL)
	{
		delete[] pIrp->AssociatedIrp.SystemBuffer;
		pIrp->AssociatedIrp.SystemBuffer = NULL;
		IoFreeIrp(pIrp);
		return STATUS_NO_MEMORY;
	}
	::RtlZeroMemory((void*)(pIrp->UserIosb), sizeof(IO_STATUS_BLOCK));

	PIO_STACK_LOCATION pIoStackLocation = IoGetNextIrpStackLocation(pIrp);
	pIoStackLocation->DeviceObject = NULL; // m_pFilterExt->pTopOfStack;
	pIoStackLocation->FileObject = m_pFilterExt->InternalPoll.pInternalFileObject;
	pIoStackLocation->MajorFunction = IRP_MJ_DEVICE_CONTROL;
	pIoStackLocation->MinorFunction = 0;
	pIoStackLocation->Flags = 0;
	pIoStackLocation->Parameters.DeviceIoControl.OutputBufferLength = 0;
	pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength = ulByteCount;
	pIoStackLocation->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_SET_FEATURE;
	pIoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

	IoSetCompletionRoutine(pIrp, DeviceSetFeatureComplete, 0, TRUE, TRUE, TRUE);

/*
	IO_STATUS_BLOCK	IoStatus;
	KEVENT			CompletionEvent;
	KeInitializeEvent(&CompletionEvent, NotificationEvent, FALSE);
	// Create IRP
	PIRP pIrp = IoBuildDeviceIoControlRequest(
				IOCTL_HID_SET_FEATURE,
				m_pFilterExt->pTopOfStack,
				pvBuffer,
				ulByteCount,
				NULL,
				0,
				FALSE,
				&CompletionEvent,
				&IoStatus
				);
	if(!pIrp)
	{
		return STATUS_NO_MEMORY;
	}

	//Stamp with Internal Poll's file object
	PIO_STACK_LOCATION pIrpStack = IoGetNextIrpStackLocation(pIrp);
	pIrpStack->FileObject = m_pFilterExt->InternalPoll.pInternalFileObject;
	if(!pIrpStack->FileObject)
	{
		return STATUS_UNSUCCESSFUL;
	}
*/

	NTSTATUS NtStatus = IoCallDriver(m_pFilterExt->pTopOfStack, pIrp);
/*
	if( STATUS_PENDING == NtStatus )
	{
		NtStatus = KeWaitForSingleObject( &CompletionEvent, Executive, KernelMode, FALSE, NULL);
		if(NT_SUCCESS(NtStatus))
		{
			NtStatus = IoStatus.Status;
		}
	}
*/

	return NtStatus;
}

ULONG CFilterGcKernelServices::GetTimeMs()
{
	LARGE_INTEGER lgiDelayTime;
	KeQuerySystemTime(&lgiDelayTime);
	lgiDelayTime.QuadPart /= 10*1000;	// Convert to milliseconds
	return lgiDelayTime.LowPart;		// Most significant part doesn't matter
}

void CFilterGcKernelServices::SetNextJog(ULONG ulDelayMs)
{
	if( ulDelayMs > 1000000) return;
	LARGE_INTEGER lgiDelayTime;
	lgiDelayTime.QuadPart=(__int64)-10000*(__int64)ulDelayMs;
	KeSetTimer(&m_pFilterExt->pFilterHooks->Timer, lgiDelayTime,& m_pFilterExt->pFilterHooks->DPC);
}

NTSTATUS CFilterGcKernelServices::PlayFromQueue(IRP* pIrp)
{
	// Get the output buffer
	ASSERT(pIrp->MdlAddress);
	CONTROL_ITEM_XFER* pKeyboardOutputBuffer = (CONTROL_ITEM_XFER*)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
	if(pKeyboardOutputBuffer)
    {

	    // Are there any items on the Queue
	    if (m_rgXfersWaiting[m_sKeyboardQueueHead].ulItemIndex != NonGameDeviceXfer::ulKeyboardIndex)
	    {
		    return STATUS_PENDING;	// No more waiting items
	    }
		    
	    // Copy the queued XFER into the out packet
	    ::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));

	    // Update the Queue
	    ::RtlZeroMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
	    m_sKeyboardQueueHead++;
	    if (m_sKeyboardQueueHead >= 5)
	    {
		    m_sKeyboardQueueHead = 0;
	    }
    }

	// Complete the IRP
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = sizeof(CONTROL_ITEM_XFER);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);

	return TRUE;
}

void CFilterGcKernelServices::PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled)
{
	NTSTATUS NtSuccess;

	// Add it to the queue of waiting XFers
	::RtlCopyMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueTail), (const void*)(&crcixState), sizeof(CONTROL_ITEM_XFER));
	m_sKeyboardQueueTail++;
	if (m_sKeyboardQueueTail >= 5)
	{
		m_sKeyboardQueueTail = 0;
	}

	// Complete any Queued keyboard IRPS
	CTempIrpQueue TempIrpQueue;
	PIRP pIrp;
	m_pFilterExt->pFilterHooks->IrpKeyboardQueue.RemoveAll(&TempIrpQueue);
	BOOLEAN wasSent = FALSE;
	while(pIrp = TempIrpQueue.Remove())
	{
		wasSent = TRUE;

		// Get the output buffer
		ASSERT(pIrp->MdlAddress);
		CONTROL_ITEM_XFER* pKeyboardOutputBuffer = (CONTROL_ITEM_XFER*)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
		if(pKeyboardOutputBuffer)
        {
		
		    // Copy the local report packet into the out packet
    //		::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(&crcixState), sizeof(CONTROL_ITEM_XFER));
		    // Copy the queued XFER into the out packet
		    ::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
        }

		// Complete the IRP
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(CONTROL_ITEM_XFER);
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);

	}

	if (wasSent || fEnabled)
	{
		// Update the Queue
		::RtlZeroMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
		m_sKeyboardQueueHead++;
		if (m_sKeyboardQueueHead >= 5)
		{
			m_sKeyboardQueueHead = 0;
		}
	}

	// Don't bother going on if the keyboard is not enabled
	if (fEnabled == FALSE)
	{
		return;
	}

	//Don't try sending if we haven't got a virtual keyboard
	if(NULL == Globals.pVirtualKeyboardPdo)
	{
		ASSERT(FALSE);
		return;
	}
	
	//Copy info to a report packet
	GCK_VKBD_REPORT_PACKET ReportPacket;
	ReportPacket.ucModifierByte = crcixState.Keyboard.ucModifierByte;
	for(ULONG ulIndex=0; ulIndex < 6; ulIndex++)
	{
		ReportPacket.rgucUsageIndex[ulIndex] = crcixState.Keyboard.rgucKeysDown[ulIndex];
	}

	//Send the report packet
	NtSuccess = GCK_VKBD_SendReportPacket(Globals.pVirtualKeyboardPdo, &ReportPacket);
	ASSERT( NT_SUCCESS(NtSuccess) );
}

HRESULT	CFilterGcKernelServices::CreateMouse()
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	if(m_fHasVMouse && !m_pMousePDO)
	{
		NtStatus = GCK_VMOU_Create(&m_pMousePDO);
	}
	return HRESULT_FROM_NT(NtStatus);
}

HRESULT	CFilterGcKernelServices::CloseMouse()
{
	if(m_fHasVMouse && m_pMousePDO)
	{
		PDEVICE_OBJECT pTemp = m_pMousePDO;
		m_pMousePDO = NULL;
		GCK_VMOU_Close(pTemp);
	}
	return S_OK;
}

HRESULT	CFilterGcKernelServices::SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR /*cWheel*/, BOOLEAN fClutch, BOOLEAN fDampen)
{
	
	//if there are backdoor requests pending for mouse data, satisfy them
	CTempIrpQueue TempIrpQueue;
	PIRP pIrp;
	m_pFilterExt->pFilterHooks->IrpMouseQueue.RemoveAll(&TempIrpQueue);
	while(pIrp = TempIrpQueue.Remove())
	{
		//
		//	Make get pointer to buffer and make sure IRP has room for report
		//
		PGCK_MOUSE_OUTPUT pMouseOutputBuffer;
		ASSERT(pIrp->MdlAddress);
		pMouseOutputBuffer = (PGCK_MOUSE_OUTPUT)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
		if(pMouseOutputBuffer)
        {
		
		    //
		    //	Copy data to output buffer
		    //
		    pMouseOutputBuffer->cXMickeys = (char)dx;
		    pMouseOutputBuffer->cYMickeys = (char)dy;
		    pMouseOutputBuffer->cButtons = (char)ucButtons;
		    pMouseOutputBuffer->fDampen = fDampen;
		    pMouseOutputBuffer->fClutch = fClutch;
        }
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(GCK_MOUSE_OUTPUT);
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);
	}
	
	if(!m_fHasVMouse)
	{
		return S_OK;
	}
	if(!m_pMousePDO)
	{
		ASSERT(FALSE && "No Virtual Mouse to send data to");
		return HRESULT_FROM_WIN32(ERROR_NOT_READY);
	}

	GCK_VMOU_REPORT_PACKET MouseReport;
	NTSTATUS NtStatus;
	MouseReport.ucButtons = ucButtons;
	MouseReport.ucDeltaX = dx;
	MouseReport.ucDeltaY = dy;
	
	//MouseReport.cWheel = cWheel;
	NtStatus = GCK_VMOU_SendReportPacket(m_pMousePDO, &MouseReport);

	return HRESULT_FROM_NT(NtStatus);
}

void CFilterGcKernelServices::KeyboardQueueClear()
{
	// Update the Queue
	::RtlZeroMemory((void*)(m_rgXfersWaiting), sizeof(CONTROL_ITEM_XFER) * 5);
	m_sKeyboardQueueHead = 0;
	m_sKeyboardQueueTail = 0;
}


NTSTATUS _stdcall
GCKF_BackdoorPoll(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp,
	IN GCK_POLLING_MODES ePollingMode
	)
{
	NTSTATUS NtStatus;
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_BackdoorPoll(pFilterExt = 0x%0.8x, pIrp = 0x%0.8x, ePollingMode = %d\n", pFilterExt, pIrp, ePollingMode));
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	// Count IRP
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
	
	if(pFilterHooks)
	{
		ASSERT(pIrp->MdlAddress);
		if(pIrp->MdlAddress)
		{
			if ((ePollingMode == GCK_POLLING_MODE_RAW) || (ePollingMode == GCK_POLLING_MODE_FILTERED))
			{
				//If there is a secondary filter all commands go to it
				CDeviceFilter *pDeviceFilter;
				if (pFilterHooks->pSecondaryFilter)
				{
					pDeviceFilter = pFilterHooks->pSecondaryFilter;
				}
				else
				{
					pDeviceFilter = pFilterHooks->pFilterObject;
				}
				if (pDeviceFilter != NULL)
				{
					pDeviceFilter->IncomingRequest();
				}
			}

			if(GCK_POLLING_MODE_RAW == ePollingMode)
			{
				NtStatus = pFilterHooks->IrpRawQueue.Add(pIrp);

				GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(1), Status =  0x%0.8x.\n", NtStatus));
				return NtStatus;
			}
			else if(GCK_POLLING_MODE_MOUSE == ePollingMode)
			{
				if( sizeof(GCK_MOUSE_OUTPUT) > MmGetMdlByteCount(pIrp->MdlAddress) )
				{
					NtStatus = STATUS_BUFFER_TOO_SMALL;
				}
				else
				{
					NtStatus = pFilterHooks->IrpMouseQueue.Add(pIrp);
					GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(MOUSE), Status =  0x%0.8x.\n", NtStatus));
					return NtStatus;
				}
			}
			else if (GCK_POLLING_MODE_KEYBOARD == ePollingMode)
			{
				if( sizeof(CONTROL_ITEM_XFER) > MmGetMdlByteCount(pIrp->MdlAddress) )
				{
					NtStatus = STATUS_BUFFER_TOO_SMALL;
				}
				else
				{
					if (pFilterHooks->pSecondaryFilter)
					{
						NtStatus = (pFilterHooks->pSecondaryFilter->ProcessKeyboardIrp(pIrp));
						if (NtStatus != STATUS_PENDING)
						{
							return NtStatus;
						}
					}
					NtStatus = pFilterHooks->IrpKeyboardQueue.Add(pIrp);
					GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(KEYBOARD), Status =  0x%0.8x.\n", NtStatus));
					return NtStatus;
				}
			}
			else
			{
				NtStatus = pFilterHooks->IrpTestQueue.Add(pIrp);
				GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(OTHER), Status =  0x%0.8x.\n", NtStatus));
				return NtStatus;
			}
		}
		else
		{
			NtStatus = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		NtStatus = STATUS_UNSUCCESSFUL;
	}
	pIrp->IoStatus.Status = NtStatus;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(2), Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filter.cpp ===
//	@doc
/**********************************************************************
*
*	@module	filter.cpp	|
*
*	Implementation of CDeviceFilter and related classes, including
*	the CXXXInput class for the CControlItems dervied from CInputItem.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	filter	|
*	The CDeviceFilter class basically uses two CControlItemCollection
*	classes to implement the filter.  One is based off of CControlItems
*	derived from CInputItem which contains symantics for assigning and
*	playing actions, as well as implementing behaviors.
*	The output colleciton is a CControlItemDefaultCollection.
*	Additionally there is a CActionQueue for holding in-process macros.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FILTER_CPP

extern "C"
{
	#include <wdm.h>
	#include <winerror.h>
	#include <hidsdi.h>
	#include <hidusage.h>
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}
#include "filter.h"
#include "filterhooks.h"

//------------------------------------------------------
// CAction constant static members that need to be initialized
//------------------------------------------------------
const	UCHAR CAction::DIGITAL_MAP		= 0x01;	
const	UCHAR CAction::PROPORTIONAL_MAP	= 0x02;	
const	UCHAR CAction::QUEUED_MACRO		= 0x03;	

// Force a bleed through, regardless of what other macro says (always also allows bleed through)
const ULONG ACTION_FLAG_FORCE_BLEED	= (0x00000008 | ACTION_FLAG_BLEED_THROUGH);

//-------------------------------------------------------------------
//	Implementation of CStandardBehavior
//-------------------------------------------------------------------
BOOLEAN CStandardBehavior::Init( PBEHAVIOR_CURVE pBehaviorCurve)
{
	GCK_DBG_ENTRY_PRINT(("Entering CBehavior::Init, pBehaviorCurve = 0x%0.8x\n", pBehaviorCurve));
	
	//	Allocate memory for Behavior Curve
	m_pBehaviorCurve = reinterpret_cast<PBEHAVIOR_CURVE>(new WDM_NON_PAGED_POOL PCHAR[pBehaviorCurve->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pBehaviorCurve)
	{
		GCK_DBG_ERROR_PRINT(("Exiting CStandardBehavior::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pBehaviorCurve, pBehaviorCurve , pBehaviorCurve->AssignmentBlock.CommandHeader.ulByteSize);
	
	//
	// Set is digital flag of base class
	//
	m_fIsDigital = pBehaviorCurve->fDigital;
	
	return TRUE;
}

void CStandardBehavior::Calibrate(LONG lMin, LONG lMax)
{
	// Call base class
	CBehavior::Calibrate(lMin, lMax);
	long lValue;
	long lSourceRange = m_lMax - m_lMin;

	//Calibrate points in assignment
	for (int i = 0; i < m_pBehaviorCurve->usPointCount; i++)
	{
		//calibrate x
		lValue = m_pBehaviorCurve->rgPoints[i].sX;
		lValue = (lValue * lSourceRange)/(LONG)m_pBehaviorCurve->ulRange + lMin;
		m_pBehaviorCurve->rgPoints[i].sX = (short)lValue;

		//calibrate y
		lValue = m_pBehaviorCurve->rgPoints[i].sY;
		lValue = (lValue * lSourceRange)/(LONG)m_pBehaviorCurve->ulRange + lMin;
		m_pBehaviorCurve->rgPoints[i].sY = (short)lValue;
	}
}

#define FIXED_POINT_SHIFT 16
LONG CStandardBehavior::CalculateBehavior(LONG lValue)
{
	//	find node to use
	for (int i = 0; i < m_pBehaviorCurve->usPointCount; i++)
	{
		if (lValue < m_pBehaviorCurve->rgPoints[i].sX)  break;
	}

	//look for extremes
	//the sensitivity does not always start and end at min/max
	if(i==0)
	{ //min sensitivity
		return (long)m_pBehaviorCurve->rgPoints[i].sY;
	}
	if(i==m_pBehaviorCurve->usPointCount)
	{	//max sensitivity
		i--;
		return (long)m_pBehaviorCurve->rgPoints[i].sY;
	}

	//	Go back to previous curve node
	i--;

	// calculate the slope at this section
	long ldeltax = m_pBehaviorCurve->rgPoints[i+1].sX - m_pBehaviorCurve->rgPoints[i].sX;
	long lSlope = m_pBehaviorCurve->rgPoints[i+1].sY - m_pBehaviorCurve->rgPoints[i].sY;

	lSlope <<=	FIXED_POINT_SHIFT;
	ASSERT(ldeltax != 0);
	lSlope /= ldeltax;
	
	//Now normalize value to node
	lValue -= m_pBehaviorCurve->rgPoints[i].sX;

	//Slope value from node and normalize
	lValue *= lSlope;
	lValue >>= FIXED_POINT_SHIFT;

	//Transform curve value from node
	lValue += m_pBehaviorCurve->rgPoints[i].sY;

	//scale it back to the interface and send it back
	return lValue;
}
#undef FIXED_POINT_SHIFT

CURVE_POINT CStandardBehavior::GetBehaviorPoint(USHORT usPointIndex)
{
	if (usPointIndex < m_pBehaviorCurve->usPointCount)
	{
		return m_pBehaviorCurve->rgPoints[usPointIndex];
	}
	CURVE_POINT cp = { 0, 0 };
	return cp;
}

//------------------------------------------------------------------------------
//	Implementation of CTimedMacro
//------------------------------------------------------------------------------
const	UCHAR CTimedMacro::TIMED_MACRO_STARTED		= 0x01;
const	UCHAR CTimedMacro::TIMED_MACRO_RELEASED		= 0x02;
const	UCHAR CTimedMacro::TIMED_MACRO_RETRIGGERED	= 0x04;
const	UCHAR CTimedMacro::TIMED_MACRO_FIRST		= 0x08;
const	UCHAR CTimedMacro::TIMED_MACRO_COMPLETE		= 0x10;

BOOLEAN CTimedMacro::Init(PTIMED_MACRO pTimedMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Init, pTimedMacroData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
						pTimedMacroData,
						pActionQueue,
						pKeyMixer));
	//
	//	Allocate memory for TimedMacroData
	//
	m_pTimedMacroData = reinterpret_cast<PTIMED_MACRO>(new WDM_NON_PAGED_POOL PCHAR[pTimedMacroData->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pTimedMacroData )
	{
		GCK_DBG_ERROR_PRINT(("Exiting CTimedMacro::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pTimedMacroData, pTimedMacroData, pTimedMacroData->AssignmentBlock.CommandHeader.ulByteSize);

	//
	//	Walk events and ensure duration is less than limit
	//
	ULONG		 ulEventNumber=1;
	PTIMED_EVENT pCurEvent = m_pTimedMacroData->GetEvent(ulEventNumber);
	while(pCurEvent)
	{
		ASSERT(pCurEvent->ulDuration < 10000);  //UI has a limit of ten seconds, so assert if greater
		//Ensure that event will not last forever
		if( pCurEvent->ulDuration >= CActionQueue::MAXIMUM_JOG_DELAY-1)
		{
			pCurEvent->ulDuration = CActionQueue::MAXIMUM_JOG_DELAY-2;
		}
		pCurEvent = m_pTimedMacroData->GetNextEvent(pCurEvent, ulEventNumber);
	};


	//
	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	//
	CQueuedAction::Init(pActionQueue);

	//
	//	Remember where the pKeyMixer is 
	//
	m_pKeyMixer = pKeyMixer;

	//
	//	Make sure we start from the beginning
	//
	m_ulCurrentEventNumber = 0;
	
	GCK_DBG_EXIT_PRINT(("Exiting CTimedMacro::Init - Success.\n"));
	return TRUE;
}

void CTimedMacro::TriggerReleased()
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering CTimedMacro::TriggerReleased\n"));
	
	if(CTimedMacro::TIMED_MACRO_COMPLETE &	m_ucProcessFlags)
	{
		m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
	}
	else
	{
		m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_RELEASED;
	}
}
void CTimedMacro::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::MapToOutput, pOutputCollection\n", pOutputCollection));
	//
	//	If we are currently processing a macro (the macro even be complete, however it will be
	//	marked as started until the user lets up on the trigger (unless auto-repeat is set)
	//
	if(CTimedMacro::TIMED_MACRO_STARTED & m_ucProcessFlags)
	{
		//
		//	If this is a retrigger, than mark as such
		//
		if(CTimedMacro::TIMED_MACRO_RELEASED & m_ucProcessFlags)
		{
			// Clear release flag and set retriggered flag
			m_ucProcessFlags &= ~CTimedMacro::TIMED_MACRO_RELEASED;
			m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_RETRIGGERED;
		}
		//
		//	We are in the queue so there is nothing more to do
		//
		return;
	}
	
	
	//
	//	Place ourselvs in the queue (queue may refuse us)
	//
	if(m_pActionQueue->InsertItem(this))
	{

		//
		//	We are not processing, so we should start it, and queue it
		//
		m_ucProcessFlags = CTimedMacro::TIMED_MACRO_STARTED | CTimedMacro::TIMED_MACRO_FIRST;

		//
		//	Remember who our output is
		//
		m_pOutputCollection = pOutputCollection;
	}
	

	return;
}

void CTimedMacro::Jog( ULONG ulTimeStampMs )
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Jog, ulTimeStampMs = 0x%0.8x\n", ulTimeStampMs));
	//
	//	If first check set the first time
	//
	if(CTimedMacro::TIMED_MACRO_FIRST & m_ucProcessFlags)
	{	
		m_ucProcessFlags &= ~CTimedMacro::TIMED_MACRO_FIRST;
		m_ulStartTimeMs = ulTimeStampMs;
		m_ulEventEndTimeMs = 0;
		m_ulCurrentEventNumber=0;
		m_pCurrentEvent=NULL;
	}

	//
	//	If macro is complete just return (the call to Released() will cleanup)
	//
	if(CTimedMacro::TIMED_MACRO_COMPLETE & m_ucProcessFlags)
	{
		return;
	}

	//
	// If it time to go one to next event
	//
	if( ulTimeStampMs >= m_ulEventEndTimeMs)
	{
		//
		//	If so then do it
		//
		m_pCurrentEvent = m_pTimedMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);

		//
		//	check to see if we are done
		//
		if(!m_pCurrentEvent)
		{
			//
			//	If the user has already released the trigger then pull ourselves out of queue and cleanup.
			//
			if(m_ucProcessFlags & CTimedMacro::TIMED_MACRO_RELEASED)
			{
				m_ucProcessFlags = 0;
				m_pActionQueue->RemoveItem(this);
				return;
			}

			//
			//	If the event is auto-repeat, then reset the event
			//
			if( ACTION_FLAG_AUTO_REPEAT & m_pTimedMacroData->ulFlags)
			{
				m_ucProcessFlags = TIMED_MACRO_STARTED;
				m_ulStartTimeMs = ulTimeStampMs;
				m_ulEventEndTimeMs = 0;
				m_ulCurrentEventNumber=0;
				m_pCurrentEvent=NULL;
				m_pCurrentEvent = m_pTimedMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
			}
			else
			{
				//
				//	Otherwise we mark the macro has complete, but leave it
				//	as started so that we won't retrigger until it released
				m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_COMPLETE;
				m_pActionQueue->RemoveItem(this);
				return;
			}
		}	//end of "if last event is over"
		
		//
		//	If we have successfully moved on to the next event,
		//  we need to figure out when this event should be up
		//
		m_ulEventEndTimeMs = ulTimeStampMs + m_pCurrentEvent->ulDuration;

	}	//end of "if need to advance to next event"

	// The following lines were there to prevent non-Macro info from
	// bleeding-through if ACTION_FLAG_BLEED_THROUGH is not set.
	// Turns out this is contrary to spec.
	//if( !(ACTION_FLAG_BLEED_THROUGH & GetActionFlags()))
	//{
	//	m_pOutputCollection->SetDefaultState();
	//}
	
	//
	//	Drive outputs with event.
	//
	m_pOutputCollection->SetState(m_pCurrentEvent->Event.ulNumXfers, m_pCurrentEvent->Event.rgXfers);
	

	//
	//	Find Keyboard Xfers in Event and overlay them
	//
	for(ULONG ulIndex = 0; ulIndex < m_pCurrentEvent->Event.ulNumXfers; ulIndex++)
	{
		if( NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->Event.rgXfers[ulIndex]) )
		{
			m_pKeyMixer->OverlayState(m_pCurrentEvent->Event.rgXfers[ulIndex]);
			break;
		}
	}
	
	//
	//	Make a suggestion to the queue when to call us back.
	//
	if( m_ulEventEndTimeMs >= ulTimeStampMs )
	{
		m_pActionQueue->NextJog( m_ulEventEndTimeMs - ulTimeStampMs );
	}
	else
	{
		m_pActionQueue->NextJog( 0 ); //0 means minimum callback time
	}
	
	return;
}

void CTimedMacro::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Terminate\n"));

	if(CTimedMacro::TIMED_MACRO_RELEASED & m_ucProcessFlags)
	{
		//
		//	Mark as ready to requeue
		//
		m_ucProcessFlags = 0;
	}
	else
	{
		//
		//	Mark as complete
		//
		m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_COMPLETE;
	}

	//
	// We never remove ourselves from the queue after a terminate,
	// this happens automatically
	//
}

//------------------------------------------------------------------------------
//	Implementation of CKeyString
//------------------------------------------------------------------------------
const	UCHAR CKeyString::KEY_STRING_STARTED		= 0x01;
const	UCHAR CKeyString::KEY_STRING_RELEASED		= 0x02;
const	UCHAR CKeyString::KEY_STRING_RETRIGGERED	= 0x04;
const	UCHAR CKeyString::KEY_STRING_FIRST			= 0x08;
const	UCHAR CKeyString::KEY_STRING_COMPLETE		= 0x10;

BOOLEAN CKeyString::Init(PKEYSTRING_MAP pKeyStringData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Init, pKeyStringData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
		pKeyStringData,
		pActionQueue,
		pKeyMixer));
	//
	//	Allocate memory for KeyStringData
	//
	m_pKeyStringData = reinterpret_cast<PKEYSTRING_MAP>(new WDM_NON_PAGED_POOL PCHAR[pKeyStringData->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pKeyStringData )
	{
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pKeyStringData, pKeyStringData, pKeyStringData->AssignmentBlock.CommandHeader.ulByteSize);

	//
	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	//
	CQueuedAction::Init(pActionQueue);

	//
	//	Remember where the pKeyMixer is 
	//
	m_pKeyMixer = pKeyMixer;

	//
	//	Make sure we start from the beginning
	//
	m_ulCurrentEventNumber = 0;

	return TRUE;
};

void CKeyString::TriggerReleased()
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::TriggerReleased\n"));
	if(CKeyString::KEY_STRING_COMPLETE & m_ucProcessFlags)
	{
		GCK_DBG_TRACE_PRINT(("Trigger released, resetting m_ucProcessFlags\n"));
		m_ucProcessFlags = 0;
	}
	else
	{
		m_ucProcessFlags |= CKeyString::KEY_STRING_RELEASED;
		GCK_DBG_TRACE_PRINT(("Trigger released, marking m_ucProcessFlags = 0x%0.8x\n", m_ucProcessFlags));
	}
}

void CKeyString::MapToOutput( CControlItemDefaultCollection *)
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::MapToOutput\n"));
	//
	//	If we are currently processing a macro (the macro even be complete, however it will be
	//	marked as started until the user lets up on the trigger (unless auto-repeat is set)
	//
	if(CKeyString::KEY_STRING_STARTED & m_ucProcessFlags)
	{
		//
		//	If this is a retrigger, than mark as such
		//
		if(CKeyString::KEY_STRING_RELEASED & m_ucProcessFlags)
		{
			GCK_DBG_TRACE_PRINT(("Retriggering keystring macro\n"));
			// Clear release flag and set retriggered flag
			m_ucProcessFlags &= ~CKeyString::KEY_STRING_RELEASED;
			m_ucProcessFlags |= CKeyString::KEY_STRING_RETRIGGERED;
		}
		//
		//	We are in the queue so there is nothing more to do
		//
		return;
	}
	
	
	//
	//	Place ourselves in the queue (queue may refuse us)
	//
	if(m_pActionQueue->InsertItem(this))
	{

		//
		//	We are not processing, so we should start it, and queue it
		//
		GCK_DBG_TRACE_PRINT(("Starting keystring macro\n"));
		m_ucProcessFlags = CKeyString::KEY_STRING_STARTED | CKeyString::KEY_STRING_FIRST;
	}

	return;
}

void CKeyString::Jog( ULONG )
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Jog\n"));
	
	//BUG	We noticed some synchronization issues.
	//BUG	It is possible that we entered this routine.
	//BUG	The proper solution is a spin lock, but this
	//BUG	needs to be carefully considered.  If this
	//BUG	is still here in a month we are in trouble.
	if( !(CKeyString::KEY_STRING_STARTED &	m_ucProcessFlags) )
	{
		return;
	}
	
	//
	//	If first check set the first time
	//
	if(CKeyString::KEY_STRING_FIRST & m_ucProcessFlags)
	{	
		m_ucProcessFlags &= ~CKeyString::KEY_STRING_FIRST;
		m_ulCurrentEventNumber=0;
		m_pCurrentEvent=NULL;
		m_fKeysDown = FALSE;
		//Get first event
		m_pCurrentEvent = m_pKeyStringData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		if(!m_pCurrentEvent)
		{
			//This really shouldn't happen
			ASSERT(FALSE);
			//Just get us out of the queue, if we have no events
			m_ucProcessFlags = 0;
			m_pActionQueue->RemoveItem(this);
		}
	}

	//
	//	If macro is complete just return (the call to Released() will cleanup)
	//
	if(CKeyString::KEY_STRING_COMPLETE & m_ucProcessFlags)
	{
		return;
	}

	// If keys are not down put them down
	if(!m_fKeysDown)
	{
		ASSERT(1 == m_pCurrentEvent->ulNumXfers);
		ASSERT( NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->rgXfers[0]) );
		m_pKeyMixer->OverlayState(m_pCurrentEvent->rgXfers[0]);
		m_fKeysDown = TRUE; 
	}
	else
	//Bring Keys up and advance event
	{
		//Not mapping anything brings them up
		m_fKeysDown = FALSE;
		//Go on to next event
		m_pCurrentEvent = m_pKeyStringData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		//Process macro end, if there are no more events
		if(!m_pCurrentEvent)
		{
			//
			//	If the user has already released the trigger then pull ourselves out of queue and cleanup.
			//
			if(m_ucProcessFlags & CKeyString::KEY_STRING_RELEASED)
			{
				GCK_DBG_TRACE_PRINT(("Macro complete, and user released button\n"));
				m_ucProcessFlags = 0;
				m_pActionQueue->RemoveItem(this);
				return;
			}

			//
			//	If the event is auto-repeat, then reset the event
			//
			if( ACTION_FLAG_AUTO_REPEAT & m_pKeyStringData->ulFlags)
			{
				GCK_DBG_TRACE_PRINT(("Auto repeat and user still holding button, restart it.\n"));
				m_ucProcessFlags = CKeyString::KEY_STRING_STARTED | CKeyString::KEY_STRING_FIRST;
				m_ulCurrentEventNumber=0;
				m_pCurrentEvent=NULL;
				m_pActionQueue->NextJog( 250 );
				return;
			}

			//
			//	Otherwise we mark the macro has complete, but leave it
			//	as started so that we won't retrigger until it released
			m_ucProcessFlags |= CKeyString::KEY_STRING_COMPLETE;
			GCK_DBG_TRACE_PRINT(("Should be started and complete, m_ucProcessFlags = 0x%0.8x.\n", m_ucProcessFlags));
			m_pActionQueue->RemoveItem(this);
			return;
		}	//end of "if last event is over"
	}

	//
	//	Suggestion to queue to call us back in 10 ms
	//
	m_pActionQueue->NextJog( 10 );
	return;
}

void CKeyString::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Terminate\n"));	
	if(CKeyString::KEY_STRING_RELEASED & m_ucProcessFlags)
	{
		//
		//	Mark as ready to requeue
		//
		m_ucProcessFlags = 0;
	}
	else
	{
		//
		//	Mark as complete
		//
		m_ucProcessFlags |= CKeyString::KEY_STRING_COMPLETE;
	}

	//
	// We never remove ourselves from the queue after a terminate,
	// this happens automatically
	//
}

//------------------------------------------------------------------------------------
//  Implementation of CMultiMacro
//------------------------------------------------------------------------------------
const	UCHAR CMultiMacro::MULTIMACRO_STARTED		= 0x10;
const	UCHAR CMultiMacro::MULTIMACRO_RELEASED		= 0x20;
const	UCHAR CMultiMacro::MULTIMACRO_RETRIGGERED	= 0x40;
const	UCHAR CMultiMacro::MULTIMACRO_FIRST			= 0x80;

BOOLEAN CMultiMacro::Init(PMULTI_MACRO pMultiMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Init, pMultiMacroData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
						pMultiMacroData,
						pActionQueue,
						pKeyMixer));

	//	Allocate memory for MultiMacroData
	m_pMultiMacroData = reinterpret_cast<PMULTI_MACRO>(new WDM_NON_PAGED_POOL PCHAR[pMultiMacroData->AssignmentBlock.CommandHeader.ulByteSize]);
	if(m_pMultiMacroData == NULL)
	{
		GCK_DBG_ERROR_PRINT(("Exiting CMultiMacro::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//	Copy over multi macro information to newly allocated buffer
	RtlCopyMemory(m_pMultiMacroData, pMultiMacroData, pMultiMacroData->AssignmentBlock.CommandHeader.ulByteSize);

	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	CQueuedAction::Init(pActionQueue);

	//	Remember where the pKeyMixer is 
	m_pKeyMixer = pKeyMixer;

	// Check the delay sizes (and adjust if nessacary)
	m_ulCurrentEventNumber = 0;
	m_pCurrentEvent = NULL;
	while ((m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber)) != NULL)
	{	// Is there a delay xfer (always first)
		if (NonGameDeviceXfer::IsDelayXfer(m_pCurrentEvent->rgXfers[0]) == TRUE)
		{
			if (m_pCurrentEvent->rgXfers[0].Delay.dwValue > 5000)		// 5 seconds max (change if more required)
			{
				m_pCurrentEvent->rgXfers[0].Delay.dwValue = 5000;
				ASSERT(FALSE);		// Really should not get one out of range (it is not nice)
			}
		}
	}

	//	Make sure we start back from the beginning
	m_ulCurrentEventNumber = 0;
	m_pCurrentEvent = NULL;

	// No delays active yet
	m_ulStartTimeMs = 0;
	m_ulEndTimeMs = 0;

	// Nothing currently active
	m_fXferActive = FALSE;
	
	GCK_DBG_EXIT_PRINT(("Exiting CMultiMacro::Init - Success.\n"));
	return TRUE;
}

void CMultiMacro::ForceBleedThrough()
{
	m_ucProcessFlags |= ACTION_FLAG_FORCE_BLEED;
}

void CMultiMacro::SetCurrentKeysAndMouse()
{
	for (ULONG ulXFerIndex = 0; ulXFerIndex < m_pCurrentEvent->ulNumXfers; ulXFerIndex++)
	{
		if (NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->rgXfers[ulXFerIndex]) == TRUE)
		{
			m_pKeyMixer->OverlayState(m_pCurrentEvent->rgXfers[ulXFerIndex]);
			m_fXferActive = TRUE;
		}
		else if (NonGameDeviceXfer::IsMouseXfer(m_pCurrentEvent->rgXfers[ulXFerIndex]) == TRUE)
		{
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x01)
			{
				m_pMouseModel->MouseButton(0);
			}
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x02)
			{
				m_pMouseModel->MouseButton(1);
			}
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x04)
			{
				m_pMouseModel->MouseButton(2);
			}
			m_fXferActive = TRUE;
		}
		else
		{
			ASSERT(FALSE);		// Unknown XFer Type (or embedded delay)
		}
	}
}

void CMultiMacro::Jog(ULONG ulTimeStampMs)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Jog\n"));
//	DbgPrint("Entering CMultiMacro::Jog: 0x%08X\n", this);

	// Have we even been started?
	if ((MULTIMACRO_STARTED & m_ucProcessFlags) == 0)
	{	// Nope, nothing to do
//		DbgPrint("Not started (ignore): 0x%08X\n", this);
		return;
	}
	
	// Is this the first time (just started or restarted)
	if (MULTIMACRO_FIRST & m_ucProcessFlags)
	{	
//		DbgPrint("MultiMacro (Re)started: 0x%08X\n", this);
		m_ucProcessFlags &= ~MULTIMACRO_FIRST;	// No longer the first time
		m_fXferActive = FALSE;	// Since we are fresh nothing has happened yet

		// Get the first event
		m_ulCurrentEventNumber = 0;
		m_pCurrentEvent = NULL;
		m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		if (m_pCurrentEvent == NULL)
		{	// No events, pretty lame MultiMap (shouldn't happen - just finish quickly)
			ASSERT(FALSE);
			if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
			{
				m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
			}
			else
			{
				m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
			}
			m_pActionQueue->RemoveItem(this);
		}
	}

	// We do not have an active Xfer (no mouse buttons down, no keys down, not in middle of delay)
	if (m_fXferActive == FALSE)
	{	// This code only assumes one XFER, keyboard, need to look at! (??)
		if (NonGameDeviceXfer::IsDelayXfer(m_pCurrentEvent->rgXfers[0]) == TRUE)
		{
			m_ulStartTimeMs = ulTimeStampMs;	// Now
			m_ulEndTimeMs = ulTimeStampMs + m_pCurrentEvent->rgXfers[0].Delay.dwValue;	// Later
			m_fXferActive =	TRUE;
		}
		else
		{
			SetCurrentKeysAndMouse();
		}
	}
	else	// Some sort of MultiMap xfer is active
	{
		BOOLEAN fFinishedDelay = FALSE;
		// Check for an active delay
		if (m_ulStartTimeMs != 0)
		{	// There is an active delay
			if (m_ulEndTimeMs <= ulTimeStampMs)
			{	// And it timed out
				m_fXferActive = FALSE;
				m_ulStartTimeMs = 0;
				m_ulEndTimeMs = 0;
				fFinishedDelay = TRUE;
//				DbgPrint("fFinishedDelay = TRUE: 0x%08X\n", this);
			}
		}
		else	// No delay is active (keys and mouse will be redowned)
		{
			m_fXferActive = FALSE;
		}

		// Do we need to look at the next xfer (did we finish up the previous)
		if (m_fXferActive == FALSE)
		{
			// Go on to next event
			EVENT* pPreviousEvent = m_pCurrentEvent;
			ULONG ulLastEventNumber = m_ulCurrentEventNumber;
			m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);

			// We want to repeat the last event if the macro wasn't released (and it wasn't a delay)
			if ((m_pCurrentEvent == NULL) && ((m_ucProcessFlags & MULTIMACRO_RELEASED) == 0) && (fFinishedDelay == FALSE))
			{	// Go back to the last event (and update based on it)
				m_pCurrentEvent = pPreviousEvent;
				m_ulCurrentEventNumber = ulLastEventNumber;
				SetCurrentKeysAndMouse();	// Want to play the last event again (avoid keyup/mouseup during switchback)
			}
			else if (m_pCurrentEvent == NULL)
			{	// Process macro end (the button has been released and we are out of events, or last was delay)
				//	Pull ourselves out of queue and cleanup.
				GCK_DBG_TRACE_PRINT(("Macro complete, and user released button (or last item was delay)\n"));
//				DbgPrint("Macro complete, and user released button : 0x%08X\n", this);
				if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
				{
					m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
				}
				else
				{
					m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
				}
				m_pActionQueue->RemoveItem(this);
				return;
			}	// endif - Out of events and button released (or last was a delay)
		}	// endif - Current event was finished
	}	// endif - keys down

	//	Suggestion to queue to call us back in 10 ms
	m_pActionQueue->NextJog(10);
	return;
}

void CMultiMacro::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Terminate\n"));

	ASSERT(FALSE);			// These are all prevent interrupt (or allow bleed through)!
}

void CMultiMacro::MapToOutput(CControlItemDefaultCollection*)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::MapToOutput\n"));

	//	Is it started? This is true till user released trigger.
	if(MULTIMACRO_STARTED & m_ucProcessFlags)
	{
		// Are we really queued
		if (m_bActionQueued == FALSE)
		{	// Liar we are not started (someone forgot to take us off the queue, hey it happens, deal with it)
			m_ucProcessFlags &= ~MULTIMACRO_STARTED;
		}
		else
		{
			//	Retrigger? - Meaning are still in queue and button is repressed.
			if (MULTIMACRO_RELEASED & m_ucProcessFlags)
			{	// Clear release flag and set retriggered flag (we are already in queue, don't readd)
				GCK_DBG_TRACE_PRINT(("(Re)triggering multi-macro\n"));
				m_ucProcessFlags &= ~MULTIMACRO_RELEASED;
				m_ucProcessFlags |= MULTIMACRO_RETRIGGERED;
			}
			return;
		}
	}
	
	
	//	Place ourselves in the queue (queue may refuse us)
	if (m_pActionQueue->InsertItem(this))
	{	//	We are not processing, so we should start it, and queue it
		GCK_DBG_TRACE_PRINT(("Starting multi-macro\n"));
		if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
		{
			m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
		}
		else
		{
			m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
		}
		m_ucProcessFlags |= MULTIMACRO_STARTED | MULTIMACRO_FIRST;
	}

	return;
}

void CMultiMacro::TriggerReleased()
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::TriggerReleased\n"));

	m_ucProcessFlags |= MULTIMACRO_RELEASED;
	GCK_DBG_TRACE_PRINT(("CMultiMacro Trigger released, marking m_ucProcessFlags = 0x%0.8x\n", m_ucProcessFlags));
}


//------------------------------------------------------------------------------------
//  Implementation of CMapping
//------------------------------------------------------------------------------------
CMapping::~CMapping()
{
	delete m_pEvent;
}

BOOLEAN CMapping::Init(PEVENT pEvent, CKeyMixer *pKeyMixer)
{
	//Initialize Event
	ULONG ulEventSize = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	m_pEvent = (PEVENT) new WDM_NON_PAGED_POOL UCHAR[ulEventSize];
	if(!m_pEvent)
		return FALSE;
	memcpy((PVOID)m_pEvent, (PVOID)pEvent, ulEventSize);

	//Initialize pointer to key mixer
	m_pKeyMixer = pKeyMixer;

	return TRUE;
}
		
void CMapping::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{

	//
	//	Drive outputs with event  (this is not quite right as we need to overlay items)
	//  Two suggestions, one add a flag to SetItemState or create a new function
	//
	pOutputCollection->SetState(m_pEvent->ulNumXfers, m_pEvent->rgXfers);

	//
	//	Find Keyboard Xfers in Event and overlay them
	//
	for(ULONG ulIndex = 0; ulIndex < m_pEvent->ulNumXfers; ulIndex++)
	{
		if( NonGameDeviceXfer::IsKeyboardXfer(m_pEvent->rgXfers[ulIndex]) )
		{
			m_pKeyMixer->OverlayState(m_pEvent->rgXfers[ulIndex]);
			break;
		}
	}
}
//------------------------------------------------------------------------------------
//  Implementation of Proportional Map
//------------------------------------------------------------------------------------
LONG CProportionalMap::GetScaledValue(LONG lDestinationMax, LONG lDestinationMin)
{
	//Below comments explain these asserts, which check that values fit in 16-bits
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|lDestinationMax)) || (0xFFFF8000 == (0xFFFF8000&lDestinationMax)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|lDestinationMin)) || (0xFFFF8000 == (0xFFFF8000&lDestinationMin)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|m_lSourceMax)) || (0xFFFF8000 == (0xFFFF8000&m_lSourceMax)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|m_lSourceMin)) || (0xFFFF8000 == (0xFFFF8000&m_lSourceMin)) );
	
	/*
	*	This code is probably overkill for the application, as existing devices
	*	have a maximum precision of 10 bits, and the mouse processing code uses 16
	*	so 32 bit intermediates are safe.  The code commented out will handle the general case,
	*	which requires 64 bit intermediates, but will run slower.
	*	Below this code, there is an uncommented version with 32-bit intermeidates assuming the ranges
	*	fit in 16 bit. It should run much more quickly on 32-bit platforms.
	*
	*
	*
	*	// If either the source or destination ranges uses nearly all of the
	*	// capacity of a 32-bit number, we will not be able to do this
	*	// transformation with 32-bit intermediates. Therefore we use
	*	// 64-bit intermediates throughout and cast back before returning.
	*	__int64 i64SourceRange = static_cast<__int64>(m_lSourceMax) - static_cast<__int64>(lSourceMin);
	*	__int64 i64DestinationRange = static_cast<__int64>(lDestinationMax) - static_cast<__int64>(lDestinationMin);
	*	__int64 i64Result;
	*	
	*	i64Result = static_cast<__int64>(m_lValue) - static_cast<__int64>(lSourceMin);
	*	i64Result = (i64Result * i64DestinationRange)/i64SourceRange;
	*	i64Result += static_cast<__int64>(lDestinationMin);
		
	*	//Now that the data is safely within the destination range (which is 32-bit),
	*	//we can cast back to 32-bit and return
	*	return static_cast<LONG>(i64Result);
	*/

	//32 bit intermediate version of scaling - assume that all the ranges are 16-bit
	LONG lSourceRange = m_lSourceMax - m_lSourceMin;                                                                                                                                               
	LONG lDestinationRange = lDestinationMax-lDestinationMin;
	return ((m_lValue - m_lSourceMin) * lDestinationRange)/lSourceRange + lDestinationMin;
}

//------------------------------------------------------------------------------------
// Implementation of CAxisMap
//------------------------------------------------------------------------------------
/***********************************************************************************
**
**	void CAxisMap::Init(LONG lCoeff, CControlItemDefaultCollection *pOutputCollection)
**
**	@mfunc	CAxisMap Initializes scaling information.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
**	@comm Called by the CDeviceFilter::ActionFactory, Stores info we need to process
**			 later, Calculations are completed on SetSourceRange which is called by
**			 by the assignee immediately upon assignment.
**
*************************************************************************************/
void CAxisMap::Init(const AXIS_MAP& AxisMapInfo)
{
	//Store the coefdicient unadulterated for now
	m_lCoeff = AxisMapInfo.lCoefficient1024x;
	//Copy the destination axis CIX
	m_TargetXfer = AxisMapInfo.cixDestinationAxis;
}
void CAxisMap::SetSourceRange(LONG lSourceMax, LONG lSourceMin)
{
	//Call base class
	CProportionalMap::SetSourceRange(lSourceMax, lSourceMin);

	if(m_lCoeff > 0)
	{
		m_lOffset = -m_lCoeff*lSourceMin/1024;	
	}
	else
	{
		m_lOffset = -(m_lCoeff*lSourceMax - 1023)/1024;
	}
}
void CAxisMap::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CControlItem *pOutputItem = pOutputCollection->GetFromControlItemXfer(m_TargetXfer);
	ASSERT(pOutputItem);
	if(pOutputItem)
	{
		CONTROL_ITEM_XFER cixOutputState;
		pOutputItem->GetItemState(cixOutputState);
		cixOutputState.Generic.lVal += ((m_lValue * m_lCoeff) / 1024) + m_lOffset;
		pOutputItem->SetItemState(cixOutputState);
	}
	return;
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseAxisAssignment
//------------------------------------------------------------------------------------
void CMouseAxisAssignment::MapToOutput(CControlItemDefaultCollection *)
{
	ULONG ulValue = static_cast<ULONG>(GetScaledValue(0, 1023));
	if(m_fXAxis)
	{
		m_pMouseModel->SetX(ulValue);
	}
	else
	{
		m_pMouseModel->SetY(ulValue);
	}
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseButton
//------------------------------------------------------------------------------------
void CMouseButton::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->MouseButton(m_ucButtonNumber);
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseClutch
//------------------------------------------------------------------------------------
void CMouseClutch::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->Clutch();
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseDamper
//------------------------------------------------------------------------------------
void CMouseDamper::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->Dampen();
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseZoneIndicator
//------------------------------------------------------------------------------------
void CMouseZoneIndicator::MapToOutput(CControlItemDefaultCollection *)
{
	if(0==m_ucAxis)	m_pMouseModel->XZone();
	if(1==m_ucAxis)	m_pMouseModel->YZone();
}

//------------------------------------------------------------------------------------
//  Implementation of Input Items
//------------------------------------------------------------------------------------

HRESULT InputItemFactory(
				USHORT	usType,
				const CONTROL_ITEM_DESC* cpControlItemDesc,
				CInputItem **ppInputItem
				)
{
	GCK_DBG_ENTRY_PRINT(("Entering InputItemFactory(0x%0.4x, 0x%0.8x, 0x%0.8x\n",
						usType,
						cpControlItemDesc,
						ppInputItem));
	
	HRESULT hr = S_OK;

	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppInputItem = new WDM_NON_PAGED_POOL CAxesInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CAxesInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usDPAD:
			*ppInputItem = new WDM_NON_PAGED_POOL CDPADInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CDPADInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPropDPAD:
			*ppInputItem = new WDM_NON_PAGED_POOL CPropDPADInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPropDPADInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usWheel:
			*ppInputItem= new WDM_NON_PAGED_POOL CWheelInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CWheelInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPOV:
			*ppInputItem = new WDM_NON_PAGED_POOL CPOVInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPOVInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usThrottle:
			*ppInputItem = new WDM_NON_PAGED_POOL CThrottleInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CThrottleInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usRudder:
			*ppInputItem = new WDM_NON_PAGED_POOL CRudderInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CRudderInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPedal:
			*ppInputItem = new WDM_NON_PAGED_POOL CPedalInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPedalInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usButton:
			*ppInputItem = new WDM_NON_PAGED_POOL CButtonsInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CButtonsInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppInputItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CDualZoneIndicatorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usZoneIndicator:
			*ppInputItem = new WDM_NON_PAGED_POOL CZoneIndicatorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CZoneIndicatorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usProfileSelectors:
			*ppInputItem = new WDM_NON_PAGED_POOL CProfileSelectorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CProfileSelectorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usButtonLED:
		{
			*ppInputItem = new WDM_NON_PAGED_POOL CButtonLEDInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CButtonLEDInput = 0x%0.8x\n", *ppInputItem));
			break;
		}
		default:
			*ppInputItem = NULL;
	}
	if(!*ppInputItem)
	{
		GCK_DBG_WARN_PRINT(("Did not create an item\n"));
		return E_FAIL;
	}
	GCK_DBG_EXIT_PRINT(("Exiting InputItemFactory with S_OK"));
	return S_OK;
}

//------------------------------------------------------------------------------
//	Implementation of CActionQueue
//------------------------------------------------------------------------------
//const UCHAR CActionQueue::OVERLAY_MACROS = 0x01;
//const UCHAR CActionQueue::SEQUENCE_MACROS = 0x02;
const ULONG CActionQueue::MAXIMUM_JOG_DELAY = 1000001; //over one million is infinite

void CActionQueue::Jog()
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::Jog\n"));
	//
	//	Initialize next jog time
	//
	m_ulNextJogMs = CActionQueue::MAXIMUM_JOG_DELAY;

	//
	//	Get CurrentTimeStamp
	//
	ULONG ulCurrentTimeMs = m_pFilterClientServices->GetTimeMs();

	CQueuedAction *pNextAction = m_pHeadOfQueue;
	while(pNextAction)
	{	
		pNextAction->Jog(ulCurrentTimeMs);
		/* NOT SUPPORTED AT THIS TIME
		if(CActionQueue::SEQUENCE_MACROS&m_ucFlags)
		{
			//
			//	If the macros are seuquenced we only process the first one
			//
			break;
		}*/
		pNextAction = pNextAction->m_pNextQueuedAction;
	}

	//
	//	SetTimer to call us back
	//
	GCK_DBG_TRACE_PRINT(("SettingNextJog for %d milliseconds.\n", m_ulNextJogMs));
	m_pFilterClientServices->SetNextJog(m_ulNextJogMs);
}

BOOLEAN CActionQueue::InsertItem(CQueuedAction *pActionToEnqueue)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::InsertItem, pActionToEnqueue = 0x%0.8x\n", pActionToEnqueue));
	
	//
	ULONG ulIncomingFlags = pActionToEnqueue->GetActionFlags();
	BOOLEAN fRefuseIncoming = FALSE;
	CQueuedAction *pCurrentItem;
	CQueuedAction *pPreviousItem;

	// Walk through the queue to see if this item is allowed (unless it forces itself!)
	if ((m_pHeadOfQueue) && ((ulIncomingFlags & ACTION_FLAG_FORCE_BLEED) == 0))
	{
		pPreviousItem = NULL;
		pCurrentItem = m_pHeadOfQueue;
		while(pCurrentItem)
		{
			ULONG ulCurrentFlags = pCurrentItem->GetActionFlags();

			// If the current forces bleed-through, the incoming has no choice
			if ((ulCurrentFlags & ACTION_FLAG_FORCE_BLEED) == 0)
			{	// Not a forced bleed through - check
				//If they don't both allow bleed-through, then bump or refuse
				if(!(ulIncomingFlags & ulCurrentFlags & ACTION_FLAG_BLEED_THROUGH))
				{
					//if current Item is ACTION_FLAG_PREVENT_INTERRUPT, then refuse
					if(ulCurrentFlags & ACTION_FLAG_PREVENT_INTERRUPT)
					{
						fRefuseIncoming = TRUE;
					}
					else
					//Bump the one that is in there
					{
						if(pPreviousItem)
						{
							pPreviousItem->m_pNextQueuedAction = pCurrentItem->m_pNextQueuedAction;
						}
						else
						{
							m_pHeadOfQueue = pCurrentItem->m_pNextQueuedAction;
						}
						//terminate current item
						pCurrentItem->Terminate();
						pCurrentItem->DecRef();
						//reset for next iteration
						pCurrentItem = pCurrentItem->m_pNextQueuedAction;
						continue;
					}
				}
			}
			//set for next iteration
			pPreviousItem = pCurrentItem;
			pCurrentItem = pCurrentItem->m_pNextQueuedAction;
		}
	}

	//If any of the matches refused the item (provided they had a choice), refuse it.
	if (fRefuseIncoming)
	{
		return FALSE;
	}
	
	//Prepare action for enqeueing at end.
	pActionToEnqueue->IncRef();
	pActionToEnqueue->m_bActionQueued = TRUE;
	pActionToEnqueue->m_pNextQueuedAction=NULL;

	// If the queue is empty then make new item the head
	if(NULL == m_pHeadOfQueue)
	{
		m_pHeadOfQueue = pActionToEnqueue;
	}
	else
	//	walk until end of queue and insert there
	{
		CQueuedAction *pNextAction = m_pHeadOfQueue;
		while(pNextAction->m_pNextQueuedAction)
		{
			pNextAction = pNextAction->m_pNextQueuedAction;
		}
		//	Insert at end
		pNextAction->m_pNextQueuedAction = pActionToEnqueue;
	}
	return TRUE;
}


void CActionQueue::RemoveItem(CQueuedAction *pActionToDequeue)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::RemoveItem, pActionToDequeue = 0x%0.8x\n", pActionToDequeue));
	//
	//	until we find the item
	//
	CQueuedAction *pPrevAction = NULL;
	CQueuedAction *pNextAction = m_pHeadOfQueue;
	while(pNextAction != pActionToDequeue)
	{
		pPrevAction = pNextAction;
		pNextAction = pNextAction->m_pNextQueuedAction;
	}
	//
	//	Found it now remove it
	//
	if( !pPrevAction )
	{
		m_pHeadOfQueue=pNextAction->m_pNextQueuedAction;
	}
	else
	{
		pPrevAction->m_pNextQueuedAction = pNextAction->m_pNextQueuedAction;
	}
	//
	//	Dereference it
	//
	pActionToDequeue->m_bActionQueued = FALSE;
	pActionToDequeue->DecRef();
}

void CActionQueue::NextJog(ULONG ulNextJogDelayMs)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::NextJog, ulNextJogDelayMs = %d\n", ulNextJogDelayMs));
	if(ulNextJogDelayMs < m_ulNextJogMs) m_ulNextJogMs = ulNextJogDelayMs;
}

void CActionQueue::ReleaseTriggers()
{
	CQueuedAction* pNextQueuedAction = m_pHeadOfQueue;
	while (pNextQueuedAction != NULL)
	{
		pNextQueuedAction->TriggerReleased();
		pNextQueuedAction = pNextQueuedAction->m_pNextQueuedAction;
	}
}

//------------------------------------------------------------------------------
//	Implementation of CAxesInput
//------------------------------------------------------------------------------
void CAxesInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	GCK_DBG_ENTRY_PRINT(("Entering CAxesInput::MapToOutput, pOutputCollection = 0x%0.8x\n", pOutputCollection));

	LONG lMungedVal;
	
	//
	//	Get the item we need to set
	//
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	CONTROL_ITEM_XFER OutputState;

	if(m_pXAssignment)
	{
		m_pXAssignment->SetValue(m_ItemState.Axes.lValX);
		m_pXAssignment->MapToOutput(pOutputCollection);
	}
	else if( pControlItem )
	{
		pControlItem->GetItemState(OutputState);
		if(m_pXBehavior)
		{
			lMungedVal = m_pXBehavior->CalculateBehavior(m_ItemState.Axes.lValX);
		}
		else
		{
			lMungedVal = m_ItemState.Axes.lValX;
		}
		OutputState.Axes.lValX = lMungedVal;
		pControlItem->SetItemState(OutputState);
	}
	if(m_pYAssignment)
	{	
		m_pYAssignment->SetValue(m_ItemState.Axes.lValY);
		m_pYAssignment->MapToOutput(pOutputCollection);
	}
	else if( pControlItem )
	{
		pControlItem->GetItemState(OutputState);
		if(m_pYBehavior)
		{
			lMungedVal = m_pYBehavior->CalculateBehavior(m_ItemState.Axes.lValY);
		}
		else
		{
			lMungedVal = m_ItemState.Axes.lValY;
		}
		OutputState.Axes.lValY = lMungedVal;
		pControlItem->SetItemState(OutputState);
	}
	return;
}

HRESULT CAxesInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	//
	//	Look at the action type
	//
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::PROPORTIONAL_MAP == pAction->GetActionClass())
	)
	{
		LONG lXMax, lYMax, lXMin, lYMin;
		GetXYRange(lXMin, lXMax, lYMin, lYMax);
		//
		//	Assign to proper axis
		//
		if(pTrigger->Axes.lValX)
		{
			if(m_pXAssignment)
			{
				m_pXAssignment->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
				pAction->SetSourceRange(lXMax, lXMin);
			}
			m_pXAssignment = pAction;
			
			hr = S_OK;
		}
		else if(pTrigger->Axes.lValY)
		{
			if(m_pYAssignment)
			{
				m_pYAssignment->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
				pAction->SetSourceRange(lYMax, lYMin);
			}
			m_pYAssignment = pAction;
			hr = S_OK;
		}
	}
	return hr;
}

HRESULT CAxesInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	HRESULT hr = E_INVALIDARG;
	LONG lMinX, lMaxX, lMinY, lMaxY;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);
	
	//
	//	Assign to proper axis
	//
	if(pTrigger->Axes.lValX)
	{
		if(m_pXBehavior)
		{
			m_pXBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinX,lMaxX);
		}
		m_pXBehavior = pBehavior;
		hr = S_OK;
	}
	else if(pTrigger->Axes.lValY)
	{
		if(m_pYBehavior)
		{
			m_pYBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinY,lMaxY);
		}
		m_pYBehavior = pBehavior;
		hr = S_OK;
	}
	return hr;
}

void CAxesInput::ClearAssignments()
{
	if(m_pXAssignment)
	{
		m_pXAssignment->DecRef();
		m_pXAssignment = NULL;
	}
	if(m_pYAssignment)
	{
		m_pYAssignment->DecRef();
		m_pYAssignment = NULL;
	}
	if(m_pXBehavior)
	{
		m_pXBehavior->DecRef();
		m_pXBehavior = NULL;
	}
	if(m_pYBehavior)
	{
		m_pYBehavior->DecRef();
		m_pYBehavior = NULL;
	}
}

void CAxesInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CAxesInput* pAxesInput = (CAxesInput*)(&rInputItem);
		if(m_pXAssignment)
		{
			m_pXAssignment->IncRef();
			pAxesInput->m_pXAssignment = m_pXAssignment;
		}
		if(m_pYAssignment)
		{
			m_pYAssignment->IncRef();
			pAxesInput->m_pYAssignment = m_pYAssignment;
		}
		if(m_pXBehavior)
		{
			m_pXBehavior->IncRef();
			pAxesInput->m_pXBehavior = m_pXBehavior;
		}
		if(m_pYBehavior)
		{
			m_pYBehavior->IncRef();
			pAxesInput->m_pYBehavior = m_pYBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CDPADInput
//------------------------------------------------------------------------------
void CDPADInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	LONG lDirection;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	GetDirection(lDirection);

	if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
	{
		m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
	}
	m_lLastDirection = lDirection;

	if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
	{
		m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
	}
	
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}

	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CDPADInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetDirection(lDirection);
		m_ItemState = CurrentState;

		//Make sure we have a valid direction
		if(-1 == lDirection)
		{
			return E_INVALIDARG;
		}
		//
		//	Release old assignment if any
		//
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}

	return hr;
}

void CDPADInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
}

void CDPADInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CDPADInput* pDPADInput = (CDPADInput*)(&rInputItem);
		for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pDPADInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CPropDPADInput
//------------------------------------------------------------------------------
void CPropDPADInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;
	
	if( IsDigitalMode() )
	{
		LONG lDirection;
		GetDirection(lDirection);

		if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
		{
			m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
		}
		m_lLastDirection = lDirection;

		if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
		{
			SetDirection(-1); //Center - the macro will overide this
			m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
		}
	}
	else
	{
		LONG lMungedVal;
		if(m_pXBehavior)
		{
			m_ItemState.Axes.lValX = m_pXBehavior->CalculateBehavior(m_ItemState.Axes.lValX);
		}
		if(m_pYBehavior)
		{
			m_ItemState.Axes.lValY = m_pYBehavior->CalculateBehavior(m_ItemState.Axes.lValY);
		}
	}
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CPropDPADInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetDirection(lDirection);
		m_ItemState = CurrentState;

		//Make sure we have a valid direction
		if(-1 == lDirection)
		{
			return E_INVALIDARG;
		}

		//	Release old assignment if any
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		
		//Increment ref count on new assignment (unless it is an unassign)
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}
	return hr;
}

HRESULT CPropDPADInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	HRESULT hr = E_INVALIDARG;
	LONG lMinX, lMaxX, lMinY, lMaxY;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);
	
	if(NULL == pBehavior)
	{
		m_fIsDigital = FALSE;
	}
	else {
		//
		//	Check if the assignment is to set it digital
		//	if so the rest of the assignment is garbage
		//	and we will throw it away
		//
		m_fIsDigital = pBehavior->IsDigital();
		if(m_fIsDigital)
		{
			//Don't worry, no need to DecRef, we would have to IncRef if we wanted to keep it.
			pBehavior=NULL;
		}
	}

	//
	//	Assign to proper axis
	//
	if(pTrigger->PropDPAD.lValX)
	{
		if(m_pXBehavior)
		{
			m_pXBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinX,lMaxX);
		}
		m_pXBehavior = pBehavior;
		hr = S_OK;
	}
	else if(pTrigger->PropDPAD.lValY)
	{
		if(m_pYBehavior)
		{
			m_pYBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinY,lMaxY);
		}
		m_pYBehavior = pBehavior;
		hr = S_OK;
	}
	return hr;
}

void CPropDPADInput::SwitchPropDPADMode()
{
	//
	//	Feature two switch the mode is always two bytes long,
	//	one for ReportId, the other for the data which is just a bit
	//
	UCHAR rgucReport[2];
	if( GetModeSwitchFeaturePacket(m_fIsDigital, rgucReport, m_pClientServices->GetHidPreparsedData()) )
	{
		m_pClientServices->DeviceSetFeature(rgucReport, 2);
	}
}

void CPropDPADInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
	
	//
	//	Now clear behaviors
	//
	if(m_pXBehavior)
	{
		m_pXBehavior->DecRef();
		m_pXBehavior = NULL;
	}
	if(m_pYBehavior)
	{
		m_pYBehavior->DecRef();
		m_pYBehavior = NULL;
	}
}

void CPropDPADInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CPropDPADInput* pPropDPADInput = (CPropDPADInput*)(&rInputItem);
		for (ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pPropDPADInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
		if (m_pXBehavior)
		{
			m_pXBehavior->IncRef();
			pPropDPADInput->m_pXBehavior = m_pXBehavior;
		}
		if (m_pYBehavior)
		{
			m_pYBehavior->IncRef();
			pPropDPADInput->m_pYBehavior = m_pYBehavior;
		}
		
		pPropDPADInput->m_fIsDigital = m_fIsDigital;
	}
}


//------------------------------------------------------------------------------
//	Implementation of CButtonsInput
//------------------------------------------------------------------------------

void CButtonsInput::GetLowestShiftButton(USHORT& rusLowestShiftButton) const
{
	if (m_cpControlItemDesc->pModifierDescTable == NULL)
	{
		rusLowestShiftButton = 0;
		return;
	}

	ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
	ULONG ulShiftStates = m_ItemState.ulModifiers & ulMask;
	rusLowestShiftButton = 0;
	while (ulShiftStates != 0)
	{
		rusLowestShiftButton++;
		if (ulShiftStates & 0x00000001)
		{
			break;
		}
		ulShiftStates >>= 1;
	}
}

void CButtonsInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	ULONG ulNumButtons = (GetButtonMax()-GetButtonMin())+1;
	ULONG ulButtonBits;
	USHORT usLowestShift;
	USHORT usButtonNum;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	GetLowestShiftButton(usLowestShift);
	
	GetButtons(usButtonNum, ulButtonBits);
/*	if ((ulButtonBits == 0) && (usLowestShift != 0) && (usLowestShift == m_usLastShift))
	{
		ulButtonBits = m_ulLastButtons;
	}
	else if ((usLowestShift == 0) && (ulButtonBits != 0) && (ulButtonBits == m_ulLastButtons))
*/	if ((usLowestShift == 0) && (ulButtonBits != 0) && (ulButtonBits == m_ulLastButtons))
	{
		usLowestShift = m_usLastShift;
	}

	ULONG ulBaseIndex = usLowestShift * ulNumButtons;
	ULONG ulLastBaseIndex = m_usLastShift * ulNumButtons;
	m_ulLastButtons = ulButtonBits;
	
	ULONG ulMask = 1;
	for( ULONG ulButtonsIndex = 0; ulButtonsIndex < ulNumButtons; ulButtonsIndex++)
	{
		
		// Release assignments that are not down in this shift-state
		if ((m_usLastShift != usLowestShift) || ((ulMask & ulButtonBits) == 0))
		{
			ASSERT((ulLastBaseIndex + ulButtonsIndex) < m_ulNumAssignments);
//			DbgPrint("Releasing(%d)\n", ulLastBaseIndex + ulButtonsIndex);
			if (m_ppAssignments[ulLastBaseIndex + ulButtonsIndex])
			{
				m_ppAssignments[ulLastBaseIndex + ulButtonsIndex]->TriggerReleased();
			}
		}

		//	Drive outputs that are down
		if (ulMask & ulButtonBits)
		{
			ASSERT((ulBaseIndex + ulButtonsIndex) < m_ulNumAssignments);
//			DbgPrint("Playing(%d)\n", ulBaseIndex + ulButtonsIndex);
			if (m_ppAssignments[ulBaseIndex + ulButtonsIndex])	// Only if there is an assignment in this shift-state
			{
				
				GCK_DBG_TRACE_PRINT(("About to trigger macro on index %d group.\n", ulBaseIndex+ulButtonsIndex));
				m_ppAssignments[ulBaseIndex + ulButtonsIndex]->MapToOutput(pOutputCollection);
				ulButtonBits = ulButtonBits & (~ulMask);	// Assigned buttons are cleared out of packet
				GCK_DBG_TRACE_PRINT(("Masking Trigger, ulMask = 0x%0.8x, ulButtonBits(new) = 0x%0.8x \n", ulMask, ulButtonBits));
			}
		}

		ulMask <<= 1;
	}
	
	m_usLastShift = usLowestShift;

	//
	//  Adjust bits based on assignments
	//
	SetButtons(0, ulButtonBits);

	//
	//	Set output
	//
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}
HRESULT CButtonsInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;

	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		//ensure that we initialized
		if(!m_ppAssignments)
		{
			return E_OUTOFMEMORY;
		}
		// Extract Shift State and Button number from trigger
		CONTROL_ITEM_XFER CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		USHORT	usButtonNumber;
		ULONG	ulBogus;
		USHORT	usLowestShift = 0;

		GetButtons(usButtonNumber, ulBogus);
		GetLowestShiftButton(usLowestShift);

		m_ItemState = CurrentState;

		//validate existance of specified button
		if(
			(usButtonNumber < GetButtonMin()) ||
			(usButtonNumber > GetButtonMax()) ||
			(usLowestShift >> GetNumShiftButtons())
		)
		{
			GCK_DBG_ERROR_PRINT(("usButtonNumber(%d) < GetButtonMin()(%d)\n", usButtonNumber, GetButtonMin()));
			GCK_DBG_ERROR_PRINT(("usButtonNumber(%d) > GetButtonMax()(%d)\n", usButtonNumber, GetButtonMax()));
			GCK_DBG_ERROR_PRINT(("usLowestShift(0x%0.8x) >> GetNumShiftButtons()(0x%0.8x) = 0x%0.8x\n",
				usLowestShift, GetNumShiftButtons(), (usLowestShift >> GetNumShiftButtons()) ));
			ASSERT(FALSE && "Faulty assignment was out of range.");
			return hr;
		}
		
		//	Code assumes shifts are used as combos
		ULONG ulAssignIndex = ((GetButtonMax()-GetButtonMin())+1)*usLowestShift + usButtonNumber - GetButtonMin();

		//If there was an assignment, unassign
		if( m_ppAssignments[ulAssignIndex] )
		{
			m_ppAssignments[ulAssignIndex]->DecRef();
		}
		
		//If there is really an assignment increment its ref count
		if(pAction)
		{
			pAction->IncRef();
		}
		GCK_DBG_TRACE_PRINT(("CButtonsInput::AssignAction, new assignment for index %d, pAction = 0x%0.8x\n", ulAssignIndex, pAction));
		m_ppAssignments[ulAssignIndex] = pAction;

		hr = S_OK;
	}
	return hr;
}

void CButtonsInput::ClearAssignments()
{
	if(m_ppAssignments)
	{
		for(ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
		{
			if( m_ppAssignments[ulIndex] )
			{
				m_ppAssignments[ulIndex]->DecRef();
				m_ppAssignments[ulIndex] = NULL;
			}
		}
	}
}

void CButtonsInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CButtonsInput* pButtonsInput = (CButtonsInput*)(&rInputItem);
		pButtonsInput->m_ulNumAssignments = m_ulNumAssignments;
		if (m_ppAssignments)
		{
			for (ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
			{
				if (m_ppAssignments[ulIndex])
				{
					m_ppAssignments[ulIndex]->IncRef();
					pButtonsInput->m_ppAssignments[ulIndex] = m_ppAssignments[ulIndex];
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CThrottleInput
//------------------------------------------------------------------------------
void CThrottleInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}
HRESULT CThrottleInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CThrottleInput::ClearAssignments()
{
}

void CThrottleInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CPOVInput
//------------------------------------------------------------------------------
void CPOVInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	LONG lDirection;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;
	GetValue(lDirection);
	
	//Out of range values are centered as per HID spec.  We use -1 throughout.
	if( (7 < lDirection) || (0 > lDirection) )
	{
		lDirection = -1;
	}
	//If POV has changed direction (other than from center) release macro.
	if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
	{
		m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
	}
	m_lLastDirection = lDirection;

	//If direction is other than centered, and assigned, play assignment
	if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
	{
		//Center POV (macro may override this.)
		SetValue(-1); 
		//PlayMacro -will put itself in queue
		m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
	}
	
	
	//	Copy state of POV over to output
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CPOVInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetValue(lDirection);
		m_ItemState = CurrentState;

		if( (7 < lDirection) || (0 > lDirection) )
		{
			ASSERT(FALSE && "Assignment was out of range!");
			return hr;
		}

		//
		//	Release old assignment if any
		//
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}

	return hr;
}

void CPOVInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
}

void CPOVInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CPOVInput* pPOVInput = (CPOVInput*)(&rInputItem);
		for (ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pPOVInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CWheelInput
//------------------------------------------------------------------------------
void CWheelInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		CONTROL_ITEM_XFER OutputState;
		//If there is an output, drive it
		if( pControlItem )
		{
			//Get the current state of the output.
			pControlItem->GetItemState(OutputState);
			//If we have a behavior use it
			if(m_pBehavior)
			{
				OutputState.Wheel.lVal = 
					m_pBehavior->CalculateBehavior(m_ItemState.Wheel.lVal);
			}
			//If no behavior do a straight map
			else
			{
				OutputState.Wheel.lVal = m_ItemState.Wheel.lVal;
			}
			//drive the output
			pControlItem->SetItemState(OutputState);
		}
}
HRESULT CWheelInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

HRESULT CWheelInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	//We do not care about the details of pTrigger
	UNREFERENCED_PARAMETER(pTrigger); 
	if(m_pBehavior)
	{
		m_pBehavior->DecRef();
	}
	if(pBehavior)
	{
		pBehavior->IncRef();
		LONG lMin,lMax;
		GetRange(lMin, lMax);
		pBehavior->Calibrate(lMin,lMax);
	}
	m_pBehavior = pBehavior;
	return S_OK;
}

void CWheelInput::ClearAssignments()
{
	if(m_pBehavior)
	{
		m_pBehavior->DecRef();
		m_pBehavior = NULL;
	}
}

void CWheelInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CWheelInput* pWheelInput = (CWheelInput*)(&rInputItem);
		if (m_pBehavior)
		{
			m_pBehavior->IncRef();
			pWheelInput->m_pBehavior = m_pBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CPedalInput
//------------------------------------------------------------------------------
void CPedalInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem != NULL )
	{
		if(m_pAssignment)
		{
			m_pAssignment->SetValue(m_ItemState.Pedal.lVal);
			m_pAssignment->MapToOutput(pOutputCollection);
		}
		else
		{
			pControlItem->SetItemState(m_ItemState);
		}
	}
}

HRESULT CPedalInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);

	HRESULT hr = E_INVALIDARG;
	//
	//	Look at the action type
	//
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::PROPORTIONAL_MAP == pAction->GetActionClass())
	)
	{
		LONG lMax, lMin;
		GetRange(lMin, lMax);
		
		if(m_pAssignment)
		{
			m_pAssignment->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
			pAction->SetSourceRange(lMax, lMin);
		}
		m_pAssignment = pAction;
		hr = S_OK;
	}
	return hr;
}

void CPedalInput::ClearAssignments()
{
	if(m_pAssignment)
	{
		m_pAssignment->DecRef();
		m_pAssignment = NULL;
	}
}

void CPedalInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CPedalInput* pPedalInput = (CPedalInput*)(&pPedalInput);
		if (m_pAssignment)
		{
			m_pAssignment->IncRef();
			pPedalInput->m_pAssignment = m_pAssignment;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CRudderInput
//------------------------------------------------------------------------------
void CRudderInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem != NULL )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}
HRESULT CRudderInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CRudderInput::ClearAssignments()
{
}

void CRudderInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CZoneIndicatorInput
//------------------------------------------------------------------------------
void CZoneIndicatorInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		
		#if (DBG==1)
		if( GetXIndicator() )
		{
			GCK_DBG_TRACE_PRINT(("Zulu X axis in zone.\n"));
		}
		if( GetYIndicator() )
		{
			GCK_DBG_TRACE_PRINT(("Zulu Y axis in zone.\n"));
		}
		#endif

		if( m_pAssignmentX && GetXIndicator() )
		{
			m_pAssignmentX->MapToOutput(pOutputCollection);
		}
		if( m_pAssignmentY && GetYIndicator() )
		{
			m_pAssignmentY->MapToOutput(pOutputCollection);
		}


		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}

HRESULT CZoneIndicatorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr=E_INVALIDARG;
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) 
	)
	{
		if(pTrigger->ZoneIndicators.ulZoneIndicatorBits & CZoneIndicatorItem::X_ZONE)
		{
			if(m_pAssignmentX)
			{
				m_pAssignmentX->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
			}
			m_pAssignmentX = pAction;
			hr=S_OK;
		}
		else if(pTrigger->ZoneIndicators.ulZoneIndicatorBits & CZoneIndicatorItem::Y_ZONE)
		{
			if(m_pAssignmentY)
			{
				m_pAssignmentY->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
			}
			m_pAssignmentY = pAction;
			hr=S_OK;
		}
	}
	return hr;
}

void CZoneIndicatorInput::ClearAssignments()
{
	if(m_pAssignmentX)
	{
		m_pAssignmentX->DecRef();
		m_pAssignmentX = NULL;
	}
	if(m_pAssignmentY)
	{
		m_pAssignmentY->DecRef();
		m_pAssignmentY = NULL;
	}
}

void CZoneIndicatorInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CZoneIndicatorInput* pZoneIndicatorInput = (CZoneIndicatorInput*)&rInputItem;
		if (m_pAssignmentX)
		{
			m_pAssignmentX->IncRef();
			pZoneIndicatorInput->m_pAssignmentX = m_pAssignmentX;
		}
		if (m_pAssignmentY)
		{
			m_pAssignmentY->IncRef();
			pZoneIndicatorInput->m_pAssignmentY = m_pAssignmentY;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CDualZoneIndicatorInput
//------------------------------------------------------------------------------
CDualZoneIndicatorInput::CDualZoneIndicatorInput
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		//@parm [IN] Pointer to Item Description from table
) :	CDualZoneIndicatorItem(cpControlItemDesc),
	m_ppAssignments(NULL),
	m_pBehavior(NULL),
	m_lLastZone(-1)
{
	m_lNumAssignments = cpControlItemDesc->DualZoneIndicators.lNumberOfZones;
	m_ppAssignments = new WDM_NON_PAGED_POOL CAction *[m_lNumAssignments];
	if(!m_ppAssignments)
	{
		ASSERT(FALSE);
		return;
	}

	for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
	{
		m_ppAssignments[lIndex] = NULL;
	}
}

void CDualZoneIndicatorInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	// Find zone (use behaviour if appropriate)
	LONG lNewZone = LONG(-1);
	if (m_pBehavior != NULL)
	{
		CURVE_POINT curvePoint = ((CStandardBehavior*)m_pBehavior)->GetBehaviorPoint(0);
		if ((curvePoint.sX == 0) || (curvePoint.sY == 0))
		{
			lNewZone = GetActiveZone() - 1;		// Use defaults either one being 0 will get stuck
		}
		else
		{
	//		DbgPrint("curvePoint.sX (%d), curvePoint.sY (%d)\n", curvePoint.sX, curvePoint.sY);
			lNewZone = GetActiveZone(curvePoint.sX, curvePoint.sY) - 1;
		}
	}
	else
	{
		lNewZone = GetActiveZone() - 1;
	}
	
	//	Are we in a new zone?
	if (lNewZone != m_lLastZone)
	{
		// Start the new one (if valid)
		if ((lNewZone >= 0) && (lNewZone < m_lNumAssignments))
		{
			if (m_ppAssignments[lNewZone])
			{
				m_ppAssignments[lNewZone]->MapToOutput(pOutputCollection);
				GCK_DBG_TRACE_PRINT(("About to trigger macro on index %d.\n", lNewZone));
			}
		}

		// End the last one (if valid)
		if ((m_lLastZone >= 0) && (m_lLastZone < m_lNumAssignments))
		{
			if (m_ppAssignments[m_lLastZone])
			{
				m_ppAssignments[m_lLastZone]->TriggerReleased();
			}
		}

		// Update previous zone to current
		m_lLastZone = lNewZone;
	}

	
	//	Set output
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if (pControlItem)
	{
		pControlItem->SetItemState(m_ItemState);
	}

	// Restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CDualZoneIndicatorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	// Ensure that we initialized
	if (!m_ppAssignments)
	{
		return E_OUTOFMEMORY;
	}

	// Extract Zone from trigger
	CONTROL_ITEM_XFER CurrentState = m_ItemState;
	m_ItemState = *pTrigger;
	LONG lZoneNumber = GetActiveZone() - 1;
	m_ItemState = CurrentState;

	//validate existance of specified button
	if (lZoneNumber < 0 || lZoneNumber >= m_lNumAssignments)
	{
		GCK_DBG_ERROR_PRINT(("lCurrentZone(%d) out of range (1 - %d\n", lZoneNumber+1, m_lNumAssignments));
		ASSERT(FALSE && "Faulty assignment was out of range.");
		return E_INVALIDARG;
	}
	
	// Was there an assignment
	if (m_ppAssignments[lZoneNumber])
	{	// Yes - Unassign old
		m_ppAssignments[lZoneNumber]->DecRef();
	}
	
	// Are we setting in a new assignment
	if (pAction)
	{	// Yes - increment ref count
		pAction->IncRef();
		if (pAction->GetActionClass() == CAction::QUEUED_MACRO)
		{
			CQueuedAction* pQueuedAction = (CQueuedAction*)pAction;
			pQueuedAction->ForceBleedThrough();
		}
	}
	GCK_DBG_TRACE_PRINT(("CDualZoneIndicatorInput::AssignAction, new assignment for index %d, pAction = 0x%0.8x\n", lZoneNumber, pAction));
	m_ppAssignments[lZoneNumber] = pAction;

	return S_OK;
}

HRESULT CDualZoneIndicatorInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	UNREFERENCED_PARAMETER(pTrigger);

	if (m_pBehavior != NULL)
	{
		m_pBehavior->DecRef();
	}
	if (pBehavior != NULL)
	{
		pBehavior->IncRef();
	}
	m_pBehavior = pBehavior;

	return S_OK;
}

void CDualZoneIndicatorInput::ClearAssignments()
{
	if (m_ppAssignments)
	{
		for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
		{
			if (m_ppAssignments[lIndex] )
			{
				m_ppAssignments[lIndex]->DecRef();
				m_ppAssignments[lIndex] = NULL;
			}
		}
	}
	if (m_pBehavior != NULL)
	{
		m_pBehavior->DecRef();
		m_pBehavior = NULL;
	}
}

void CDualZoneIndicatorInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CDualZoneIndicatorInput* pDualZoneIndicatorInput = (CDualZoneIndicatorInput*)&rInputItem;
		if (m_ppAssignments)
		{
			for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
			{
				if (m_ppAssignments[lIndex] )
				{
					m_ppAssignments[lIndex]->IncRef();
					pDualZoneIndicatorInput->m_ppAssignments[lIndex] = m_ppAssignments[lIndex];
				}
			}
		}
		if (m_pBehavior != NULL)
		{
			m_pBehavior->IncRef();
			pDualZoneIndicatorInput->m_pBehavior = m_pBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CProfileSelectorInput
//------------------------------------------------------------------------------
HRESULT CProfileSelectorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CProfileSelectorInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	UNREFERENCED_PARAMETER(pOutputCollection);
	// Nothing to do, we don't want to report this data up.
}

void CProfileSelectorInput::ClearAssignments()
{
}

void CProfileSelectorInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CButtonLEDInput
//------------------------------------------------------------------------------
CButtonLEDInput::CButtonLEDInput
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		//@parm [IN] Description for this item
) : CButtonLED(cpControlItemDesc),
	m_pCorrespondingButtonsItem(NULL),
	m_pLEDSettings(NULL),
	m_usNumberOfButtons(0)
{
	m_ucCorrespondingButtonItemIndex = cpControlItemDesc->ButtonLEDs.ucCorrespondingButtonItem;
}

CButtonLEDInput::~CButtonLEDInput()
{
	m_pCorrespondingButtonsItem = NULL;
	if (m_pLEDSettings != NULL)
	{
		delete[] m_pLEDSettings;
		m_pLEDSettings = NULL;
	}
	m_usNumberOfButtons = 0;
};

void CButtonLEDInput::Init(CInputItem* pCorrespondingButtons)
{
	m_pCorrespondingButtonsItem = (CButtonsInput*)pCorrespondingButtons;
	if (m_pCorrespondingButtonsItem != NULL)
	{
		ASSERT(m_pCorrespondingButtonsItem->GetType() == ControlItemConst::usButton);

//		m_usNumberOfButtons = m_pCorrespondingButtonsItem->GetButtonMax() - m_pCorrespondingButtonsItem->GetButtonMin() + 1;
		m_usNumberOfButtons = 0xC;
		ULONG ulNumShift = m_pCorrespondingButtonsItem->GetNumShiftButtons() + 1;
		ULONG ulNumBytes = ((m_usNumberOfButtons * ulNumShift * 2) + 7) / 8;
		m_pLEDSettings = new WDM_NON_PAGED_POOL UCHAR[ulNumBytes];
		if (m_pLEDSettings != NULL)
		{
			RtlZeroMemory(reinterpret_cast<PVOID>(m_pLEDSettings), ulNumBytes);	// Zero is default state
		}
	}
}

HRESULT CButtonLEDInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CButtonLEDInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	UNREFERENCED_PARAMETER(pOutputCollection);
}

void CButtonLEDInput::SetLEDStates
(
	GCK_LED_BEHAVIOURS ucLEDBehaviour,	//@parm [IN] State change for affected LEDs
	ULONG ulLEDsAffected,				//@parm [IN] LEDs affected by change
	unsigned char ucShiftArray			//@parm [IN] Shift states to change
)
{
	if (m_pLEDSettings != NULL)
	{
		// Cycle through the shift states
		ULONG ulNumShift = m_pCorrespondingButtonsItem->GetNumShiftButtons() + 1;
		for (ULONG ulShiftIndex = 0; ulShiftIndex < ulNumShift; ulShiftIndex++)
		{
			// Are we interested in this shift state?
			if ((ucShiftArray & (1 << ulShiftIndex)) != 0)
			{
				USHORT usShiftBase = USHORT(ulShiftIndex * m_usNumberOfButtons);
				// Cycle through the buttons
				for (USHORT usButtonIndex = 0; usButtonIndex < m_usNumberOfButtons; usButtonIndex++)
				{
					USHORT usTrueIndex = usShiftBase + usButtonIndex;
					if ((ulLEDsAffected & (1 << usButtonIndex)) != 0)
					{
						USHORT usByte = usTrueIndex/4;
						USHORT usBitPos = (usTrueIndex % 4) * 2;
						m_pLEDSettings[usByte] &= ~(0x0003 << usBitPos);
						m_pLEDSettings[usByte] |= (ucLEDBehaviour & 0x0003) << usBitPos;
					}
				}
			}
		}
	}
}


void CButtonLEDInput::AssignmentsChanged()
{
	UCHAR featureData[3];
	featureData[0] = 1;		// Report ID;
	featureData[1] = 0;		// LEDs 4 - 1 off
	featureData[2] = 0;		// LEDs 7 - 5 off

	if (m_pCorrespondingButtonsItem != NULL)
	{
		USHORT usLowestShift = 0;
		m_pCorrespondingButtonsItem->GetLowestShiftButton(usLowestShift);
		USHORT usShiftBase = usLowestShift * m_usNumberOfButtons;

		for (USHORT usButtonIndex = 0; usButtonIndex < m_usNumberOfButtons; usButtonIndex++)
		{
			// Hack for Atilla
			if ((usButtonIndex > 5) && (usButtonIndex < 0xB))
			{
				continue;	// These buttons are not really there
			}

			USHORT usByte = (usButtonIndex + usShiftBase)/4;
			USHORT usBitPos = ((usButtonIndex + usShiftBase) % 4) * 2;
			UCHAR ucLEDBehaviour = (m_pLEDSettings[usByte] & (0x0003 << usBitPos)) >> usBitPos;

			// Value settings
			UCHAR ucValueSettings = 0;
			switch (ucLEDBehaviour)
			{
				case GCK_LED_BEHAVIOUR_DEFAULT:
				{
					if (usButtonIndex <= 0x05)	// Hack for Atilla
					{
						if (m_pCorrespondingButtonsItem->IsButtonAssigned(usButtonIndex + m_pCorrespondingButtonsItem->GetButtonMin(), usLowestShift))
						{
							ucValueSettings = 0x01;
						}
					}
					break;
				}
				case GCK_LED_BEHAVIOUR_ON:
				{
					ucValueSettings = 0x01;
					break;
				}
				case GCK_LED_BEHAVIOUR_OFF:
				{
					break;
				}
				case GCK_LED_BEHAVIOUR_BLINK:
				{
					ucValueSettings = 0x02;
					break;
				}
				
			}

			// Hack for Atilla
			if (usButtonIndex < 4)
			{
				featureData[1] |= (ucValueSettings << (usButtonIndex * 2));
			}
			else
			{
				USHORT usNewButton = usButtonIndex - 4;
				if (usNewButton > 5)
				{
					usNewButton -= 5;
				}
				featureData[2] |= (ucValueSettings << (usNewButton * 2));
			}
		}
	}

	NTSTATUS NtStatus = m_pClientServices->DeviceSetFeature(featureData, 3);
}

void CButtonLEDInput::ClearAssignments()
{
}

void CButtonLEDInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CKeyMixer
//------------------------------------------------------------------------------
#define KEYBOARD_NO_EVENT 0
#define KEYBOARD_ERROR_ROLLOVER 1
#define MAX_KEYSTROKES 6


CKeyMixer *CKeyMixer::ms_pHeadKeyMixer = NULL;
ULONG CKeyMixer::ms_rgulGlobalKeymap[5] = {0};
UCHAR CKeyMixer::ms_ucLastModifiers = 0;

CKeyMixer::CKeyMixer(CFilterClientServices *pFilterClientServices):
		  m_pFilterClientServices(pFilterClientServices), m_fEnabled(TRUE)
{
	//Ensure that we did not get passed a null pointer
	ASSERT(m_pFilterClientServices);
	m_pFilterClientServices->IncRef();
	//
	// Add this instance to head of linked list
	// Note that this works even if the list was empty.
	//
	pNextKeyMixer = ms_pHeadKeyMixer;
	ms_pHeadKeyMixer = this;
	
	//Mark All keys up
	ClearState();
}

CKeyMixer::~CKeyMixer()
{
	//check if we are the, easy to remove ourselves
	if(this == ms_pHeadKeyMixer)
	{
		ms_pHeadKeyMixer = pNextKeyMixer;
	}
	else
	//find us in list and remove ourselves
	{
		CKeyMixer *pPrevKeyMixer = ms_pHeadKeyMixer;
		while(pPrevKeyMixer->pNextKeyMixer)
		{
			if(this == pPrevKeyMixer->pNextKeyMixer)
			{
				pPrevKeyMixer->pNextKeyMixer = pNextKeyMixer;
				break;
			}
			pPrevKeyMixer = pPrevKeyMixer->pNextKeyMixer;
		}
	}
	m_pFilterClientServices->DecRef();
	m_pFilterClientServices=NULL;
}

void CKeyMixer::SetState(const CONTROL_ITEM_XFER& crcixNewLocalState)
{
//	if(!m_fEnabled) return;
	m_cixLocalState = crcixNewLocalState;
}

void CKeyMixer::OverlayState(const CONTROL_ITEM_XFER& crcixNewLocalState)
{
//	if(!m_fEnabled) return;
	//Mix New LocalState with existing local state
	CONTROL_ITEM_XFER cixTemp;
	MIX_ALGO_PARAM MixAlgoParam;
	
	//Save previous local state
	cixTemp = m_cixLocalState;
	
	//Init MixAlgoParam - and attach m_cixLocalState as the mix destination
	//This inherently wipes m_cixLocalState, which is why we saved its
	//previous state.
	InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);

	//Mix in Previous State
	MixAlgorithm(&MixAlgoParam, &cixTemp);

	//Mix in New Local State
	MixAlgorithm(&MixAlgoParam, &crcixNewLocalState);

	return;
}

void CKeyMixer::ClearState()
{
//	if(!m_fEnabled) return;
	//This does a little more than it needs to, but it saves code duplication
	MIX_ALGO_PARAM MixAlgoParam;
	InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);
}

void CKeyMixer::PlayGlobalState(BOOLEAN fPlayIfNoChange)
{
//	if(!m_fEnabled) return;
	CONTROL_ITEM_XFER cixNewGlobalState;
	MIX_ALGO_PARAM MixAlgoParam;
	
	//Init MixAlgoParam - and attach cixNewGlobalState as the mix destination
	InitMixAlgoParam(&MixAlgoParam, &cixNewGlobalState);
	
	//Walk list of all Local states and mix in to new global state
	CKeyMixer *pCurrentKeyMixer;
	for(pCurrentKeyMixer = ms_pHeadKeyMixer; NULL!=pCurrentKeyMixer; pCurrentKeyMixer = pCurrentKeyMixer->pNextKeyMixer)
	{
		MixAlgorithm(&MixAlgoParam, &pCurrentKeyMixer->m_cixLocalState);
	}

	//If global state has changed, or if fPlayIfNoChange is TRUE, play change
	if  (fPlayIfNoChange ||
		!CompareKeyMap(MixAlgoParam.rgulKeyMap, ms_rgulGlobalKeymap) ||
		ms_ucLastModifiers != cixNewGlobalState.Keyboard.ucModifierByte
	)
	{
		m_pFilterClientServices->PlayKeys(cixNewGlobalState, m_fEnabled);
	}
	
	//set Global State to New Global State
	CopyKeyMap(ms_rgulGlobalKeymap, MixAlgoParam.rgulKeyMap);
	ms_ucLastModifiers = cixNewGlobalState.Keyboard.ucModifierByte;
}

void CKeyMixer::Enable(BOOLEAN fEnable)
{
	//set enabled state
	m_fEnabled = fEnable;
	//if disabling, bring all keys up
	if(!m_fEnabled)
	{
		MIX_ALGO_PARAM MixAlgoParam;
		InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);
	}
}
void CKeyMixer::InitMixAlgoParam(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParm, CONTROL_ITEM_XFER *pcixDest)
{
	//Mark no keys set
	pMixAlgParm->ulDestCount=0;
	//Clear KeyMap
	pMixAlgParm->rgulKeyMap[0]=0;
	pMixAlgParm->rgulKeyMap[1]=0;
	pMixAlgParm->rgulKeyMap[2]=0;
	pMixAlgParm->rgulKeyMap[3]=0;
	pMixAlgParm->rgulKeyMap[4]=0;

	//Init desitination as pristine
	pMixAlgParm->pcixDest = pcixDest;

	//Mark as keyboard Xfer
	pMixAlgParm->pcixDest->ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	//Clear Modifiers
	pMixAlgParm->pcixDest->Keyboard.ucModifierByte = 0;
	//Clear down keys
	for(ULONG ulIndex = 0; ulIndex < 6; ulIndex++)
	{
		pMixAlgParm->pcixDest->Keyboard.rgucKeysDown[ulIndex] = 0;
	}
}

void CKeyMixer::MixAlgorithm(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParam, const CONTROL_ITEM_XFER *pcixSrc)
{
	UCHAR ucMapBit;
	UCHAR ucMapByte;

	//OR in modifier Bytes
	pMixAlgParam->pcixDest->Keyboard.ucModifierByte |= pcixSrc->Keyboard.ucModifierByte;
	
	//loop over all possible keys in source
	for(ULONG ulIndex=0; ulIndex < MAX_KEYSTROKES; ulIndex++)
	{
		//Skip non-entries
		if( KEYBOARD_NO_EVENT == pcixSrc->Keyboard.rgucKeysDown[ulIndex])
		{
			continue;
		}
		//Compute byte, bit, and mask for keymap
		ucMapByte = pcixSrc->Keyboard.rgucKeysDown[ulIndex]/32;
		ucMapBit = pcixSrc->Keyboard.rgucKeysDown[ulIndex]%32;
		//If not already in keymap add to destination
		if( !(pMixAlgParam->rgulKeyMap[ucMapByte]&(1<<ucMapBit)) )
		{
			//ensure we don't overflow
			if(pMixAlgParam->ulDestCount<MAX_KEYSTROKES)
			{
				pMixAlgParam->pcixDest->Keyboard.rgucKeysDown[pMixAlgParam->ulDestCount++] =
					pcixSrc->Keyboard.rgucKeysDown[ulIndex];
			}
		}
		//Add to key map
		pMixAlgParam->rgulKeyMap[ucMapByte] |= (1<<ucMapBit);
	}
}
#undef KEYBOARD_NO_EVENT //0
#undef KEYBOARD_ERROR_ROLLOVER //1


//------------------------------------------------------------------------------
//	Implementation of CMouseModel
//------------------------------------------------------------------------------
HRESULT CMouseModel::SetXModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters)
{
	//Set the model parameters
	if(pModelParameters)
	{
		ASSERT(m_pMouseModelData);
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
		if(0==pModelParameters->ulInertiaTime)
		{
			//Help us avoid a divide by zero error later.
			pModelParameters->ulInertiaTime = 1;
		}
		m_pMouseModelData->XModelParameters = *pModelParameters;
		m_pMouseModelData->fXModelParametersValid = TRUE;
		GCK_DBG_TRACE_PRINT(("New X Model Parameters are:\n\
AbsZoneSense = %d,\nContZoneMaxRate = %d,\nfPulse = %s,\nPulseWidth = %d,\nPulsePeriod = %d,\nfAcceration = %s,\n\nulAcceleration = %d,\nInertiaTime = %d\n",
m_pMouseModelData->XModelParameters.ulAbsZoneSense,
m_pMouseModelData->XModelParameters.ulContZoneMaxRate,
(m_pMouseModelData->XModelParameters.fPulse ? "TRUE" : "FALSE"),	
m_pMouseModelData->XModelParameters.ulPulseWidth,
m_pMouseModelData->XModelParameters.ulPulsePeriod,		
(m_pMouseModelData->XModelParameters.fAccelerate ? "TRUE" : "FALSE"),
m_pMouseModelData->XModelParameters.ulAcceleration,
m_pMouseModelData->XModelParameters.ulInertiaTime));		
	}
	//Clear the model parameters
	else
	{
		ASSERT(FALSE); //should no longer happen
		m_pMouseModelData->fXModelParametersValid = FALSE;
	}
	return S_OK;
}

HRESULT CMouseModel::SetYModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters)
{
	//Set the model parameters
	if(pModelParameters)
	{
		ASSERT(m_pMouseModelData);
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
		if(0==pModelParameters->ulInertiaTime)
		{
			//Help us avoid a divide by zero error later.
			pModelParameters->ulInertiaTime = 1;
		}
		m_pMouseModelData->YModelParameters = *pModelParameters;
		m_pMouseModelData->fYModelParametersValid = TRUE;
		GCK_DBG_TRACE_PRINT(("New Y Model Parameters are:\n\
AbsZoneSense = %d,\nContZoneMaxRate = %d,\nfPulse = %s,\nPulseWidth = %d,\nPulsePeriod = %d,\nfAcceration = %s,\n\nulAcceleration = %d,\nInertiaTime = %d\n",
m_pMouseModelData->YModelParameters.ulAbsZoneSense,
m_pMouseModelData->YModelParameters.ulContZoneMaxRate,
(m_pMouseModelData->YModelParameters.fPulse ? "TRUE" : "FALSE"),	
m_pMouseModelData->YModelParameters.ulPulseWidth,
m_pMouseModelData->YModelParameters.ulPulsePeriod,		
(m_pMouseModelData->YModelParameters.fAccelerate ? "TRUE" : "FALSE"),
m_pMouseModelData->YModelParameters.ulAcceleration,
m_pMouseModelData->YModelParameters.ulInertiaTime));		
	}
	//Clear the model parameters
	else
	{
		ASSERT(FALSE); //should no longer happen
		m_pMouseModelData->fYModelParametersValid = FALSE;
	}
	return S_OK;
}

HRESULT CMouseModel::CreateDynamicMouseObjects()
{
	//Create the mouse model data, if not exist
	if(!m_pMouseModelData)
	{
		m_pMouseModelData = new WDM_NON_PAGED_POOL MOUSE_MODEL_DATA;
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
	}

	//Create the virutal mouse, (safe if it already exists)
	return m_pFilterClientServices->CreateMouse();
}

void CMouseModel::DestroyDynamicMouseObjects()
{
	//Destroy the mouse model data if exists
	if(m_pMouseModelData)
	{
		delete m_pMouseModelData;
		m_pMouseModelData = NULL;
	}

	//Destroy virtual mouse (safe if it doesn't exist)
	HRESULT hr = m_pFilterClientServices->CloseMouse();
	ASSERT( SUCCEEDED(hr) );
}
		
//called by device filters MapToOutput, to reset state for a new packet
void CMouseModel::NewPacket(ULONG ulCurrentTime)
{
	//This is called by CDeviceFilter, which doesn't know if there
	//are mouse assignments, in this case we ignore the call.
	if(!m_pMouseModelData) return;
	//set time of new poll
	m_pMouseModelData->ulLastTime = m_pMouseModelData->ulCurrentTime;
	m_pMouseModelData->ulCurrentTime=ulCurrentTime;
	//reset momentaries
	m_pMouseModelData->fClutchDown = FALSE;
	m_pMouseModelData->fDampenDown = FALSE;
	m_pMouseModelData->ucButtons = 0x00;
	m_pMouseModelData->StateX.fInZone = FALSE;
	m_pMouseModelData->StateY.fInZone = FALSE;
	//store last values for axes
	m_pMouseModelData->StateX.ulLastPos = m_pMouseModelData->StateX.ulPos;
	m_pMouseModelData->StateY.ulLastPos = m_pMouseModelData->StateY.ulPos;
}

//
//	called by device filters MapToOutput (at end), to send packet to output
//
void CMouseModel::SendMousePacket()
{
	//This is called by CDeviceFilter, which doesn't know if there
	//are mouse assignments, in this case we ignore the call.
	if(!m_pMouseModelData) return;

	UCHAR ucDeltaX = 0;
	UCHAR ucDeltaY = 0;
	
	//If there are mouse model parameters, and the clutch is not on
	//process the axes
	if(
		(m_pMouseModelData->fXModelParametersValid) &&
		(!m_pMouseModelData->fClutchDown)
		)
	{
		//Process X axis
		ucDeltaX = CalculateMickeys(
										&m_pMouseModelData->StateX,
										&m_pMouseModelData->XModelParameters
									);

		//Left and right are opposite on mouse and joysticl
		ucDeltaX = UCHAR(-(CHAR)ucDeltaX);

		//Process Y axis
		ucDeltaY = CalculateMickeys(
										&m_pMouseModelData->StateY,
										&m_pMouseModelData->YModelParameters
									);
	}

	// Do we really want to send
	if ((m_pMouseModelData->ucLastButtons != m_pMouseModelData->ucButtons) || (ucDeltaX != 0) || (ucDeltaY != 0))
	{
		ASSERT(m_pMouseModelData->ucButtons != UCHAR(-1));	// Someone forgot NewPacket call

		m_pFilterClientServices->SendMouseData(
									ucDeltaX,
									ucDeltaY,
									m_pMouseModelData->ucButtons,
									m_pMouseModelData->cWheel,
									m_pMouseModelData->fClutchDown,
									m_pMouseModelData->fDampenDown);

		m_pMouseModelData->ucLastButtons = m_pMouseModelData->ucButtons;
	}
}


UCHAR
CMouseModel::CalculateMickeys
(
	PMOUSE_AXIS_STATE pMouseAxisState,
	PMOUSE_MODEL_PARAMETERS pModelParameters
)
{
	//Calculate for continuous zone
	if(pMouseAxisState->fInZone)
	{
		//Set Jog
		m_pFilterClientServices->SetNextJog(10); //call back in 35 ms
			
		//Reset inertia, so when we leave zone it is max
		pMouseAxisState->fInertia = TRUE;
		pMouseAxisState->ulInertiaStopMs = m_pMouseModelData->ulCurrentTime + pModelParameters->ulInertiaTime;

		//If pulsing is on update gate info
		if(pModelParameters->fPulse)
		{
			//Update Pulse Start Time
			if( 
				(pMouseAxisState->ulPulseGateStartMs + pModelParameters->ulPulsePeriod) <
				m_pMouseModelData->ulCurrentTime
			)
			{
				pMouseAxisState->ulPulseGateStartMs = m_pMouseModelData->ulCurrentTime;
			}
			//Return 0 if in an off period
			if( 
				(pMouseAxisState->ulPulseGateStartMs + pModelParameters->ulPulseWidth) <
				m_pMouseModelData->ulCurrentTime
			)
			{
				return (UCHAR)0; //No movement the gate is off
			}
		}	//end of update zone information
		
		//Are we in high zone?
		//Yes, HighZone
		if(pMouseAxisState->ulPos > MOUSE_AXIS_CENTER_IN)
		{
			//Update Zone entry point
			if(pMouseAxisState->ulPos < pMouseAxisState->ulZoneEnterHigh)
			{
				 pMouseAxisState->ulZoneEnterHigh = pMouseAxisState->ulPos;
			}

			//Calculate Instantaneous Rate (Mickeys/1024 ms)
			ULONG ulRate = (
								(pMouseAxisState->ulPos - pMouseAxisState->ulZoneEnterHigh) * 
								pModelParameters->ulContZoneMaxRate
							) /	(MOUSE_AXIS_MAX_IN - pMouseAxisState->ulZoneEnterHigh);

			//Calculate Mickeys to send * 1024
			ULONG ulMickeys = ulRate * (m_pMouseModelData->ulCurrentTime - m_pMouseModelData->ulLastTime);
			ulMickeys += pMouseAxisState->ulMickeyFraction;

			//Save fraction in parts per 1024
			pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;
			
			//Return number of mickeys to send now (divide by 1024)
			return (UCHAR)(ulMickeys >> 10);
		} else
		//No, Low Zone
		{
			//Update Zone entry point
			if(pMouseAxisState->ulPos > pMouseAxisState->ulZoneEnterLo)
			{
				 pMouseAxisState->ulZoneEnterLo = pMouseAxisState->ulPos;
			}

			//Calculate Instantaneous Rate (Mickeys/1024 ms)
			ULONG ulRate = (
								(pMouseAxisState->ulZoneEnterLo - pMouseAxisState->ulPos) * 
								pModelParameters->ulContZoneMaxRate
							) /	(pMouseAxisState->ulZoneEnterLo - MOUSE_AXIS_MIN_IN);

			//Calculate Mickeys to send * 1024
			ULONG ulMickeys = ulRate * (m_pMouseModelData->ulCurrentTime - m_pMouseModelData->ulLastTime);
			ulMickeys += pMouseAxisState->ulMickeyFraction;

			//Save fraction in parts per 1024
			pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;
			
			//Return number of mickeys to send now (divide by 1024)
			return (UCHAR)(-(LONG)(ulMickeys >> 10));
		}
	}

	//If we are here, we are not in the continuous zone

	//Calculate Mickeys
	BOOLEAN fNegative = FALSE;
	ULONG ulMickeys;
	
	if( pMouseAxisState->ulPos > pMouseAxisState->ulLastPos)
	{
		ulMickeys = pMouseAxisState->ulPos - pMouseAxisState->ulLastPos;
	}
	else
	{
		fNegative = TRUE;
		ulMickeys = pMouseAxisState->ulLastPos - pMouseAxisState->ulPos;
	}
	
	ULONG ulEffSense = pModelParameters->ulAbsZoneSense; 
	//Apply damper
	if(m_pMouseModelData->fDampenDown)
	{
		ulEffSense >>= 2; //divide by four
	}

	//Apply Sensitivity (we divide by 1024, a sensitivity of one is really 1024)
	ulMickeys *= ulEffSense;

	//Apply Inertia
	if( pMouseAxisState->fInertia)
	{
		if(m_pMouseModelData->ulCurrentTime > pMouseAxisState->ulInertiaStopMs)
		{
			pMouseAxisState->fInertia = FALSE;
		}
		else
		{
			ULONG ulInertialBits = 
				(
					10*(pMouseAxisState->ulInertiaStopMs - m_pMouseModelData->ulCurrentTime)
				)/pModelParameters->ulInertiaTime;
			ulMickeys >>= ulInertialBits;
		}
	}

	//Apply Acceleration
	if(pModelParameters->fAccelerate)
	{
		//ulAcceleration is a number between 1 and 3
		ulMickeys += (ulMickeys*(LONG)pModelParameters->ulAcceleration)/3;
	}
	
	//Add in fractional mickeys
	ulMickeys += pMouseAxisState->ulMickeyFraction;

	//Save fraction in parts per 1024
	pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;

	ulMickeys >>= 10;
	if(fNegative)
	{
		return (UCHAR)(-(LONG)ulMickeys);
	}
	else
		return (UCHAR)(ulMickeys);
}

//------------------------------------------------------------------------------
//	Implementation of CDeviceFilter
//------------------------------------------------------------------------------
CDeviceFilter::CDeviceFilter(CFilterClientServices *pFilterClientServices) :
	m_ucActiveInputCollection(0),
	m_ucWorkingInputCollection(0),
	m_ucNumberOfInputCollections(0),
	m_OutputCollection(pFilterClientServices->GetVidPid()),
	m_ActionQueue(pFilterClientServices),
	m_KeyMixer(pFilterClientServices),
	m_pMouseModel(NULL),
	m_pFilterClientServices(pFilterClientServices),
	m_pForceBlock(NULL),
	m_bFilterBlockChanged(FALSE),
	m_bNeedToUpdateLEDs(FALSE)
{
	GCK_DBG_ENTRY_PRINT(("CDeviceFilter::CDeviceFilter(pFilterClientServices(0x%0.8x)\n)",
						pFilterClientServices));
	m_pFilterClientServices->IncRef();

	short int collectionCount = 0;	// Get this actual number from the table

	// Walk through device control description list till vidpid found or 0
	USHORT usDeviceIndex = 0;
	ULONG ulVidPid = pFilterClientServices->GetVidPid();
	while ((DeviceControlsDescList[usDeviceIndex].ulVidPid != 0) &&
			(DeviceControlsDescList[usDeviceIndex].ulVidPid != ulVidPid))
	{
		usDeviceIndex++;
	}
	if (DeviceControlsDescList[usDeviceIndex].ulVidPid == ulVidPid)	// Device not found otherwise?
	{
		for (ULONG ulItemIndex = 0; ulItemIndex < DeviceControlsDescList[usDeviceIndex].ulControlItemCount; ulItemIndex++)
		{
			CONTROL_ITEM_DESC* pControlItemDesc = (CONTROL_ITEM_DESC*)(DeviceControlsDescList[usDeviceIndex].pControlItems + ulItemIndex);
			if (pControlItemDesc->usType == ControlItemConst::usProfileSelectors)
			{
				// This is purposly 1 off
				collectionCount = (pControlItemDesc->ProfileSelectors.UsageButtonMax - pControlItemDesc->ProfileSelectors.UsageButtonMin);
				ASSERT( (collectionCount > 0) && (collectionCount < 10) );	// Check table for errors!!
				break;		// We only support one group of selectors!
			}
		}
	}
	m_ucNumberOfInputCollections =  collectionCount + 1;		// Fix up by 1

	m_rgInputCollections = new WDM_NON_PAGED_POOL CControlItemCollection<CInputItem>[m_ucNumberOfInputCollections];

	// Init, then set the client services function in each input collection (init the LED collections)
	for (short int collectionIndex = 0; collectionIndex < m_ucNumberOfInputCollections; collectionIndex++)
	{
		m_rgInputCollections[collectionIndex].Init(pFilterClientServices->GetVidPid(), &InputItemFactory);

		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while( S_OK == m_rgInputCollections[collectionIndex].GetNext(&pInputItem, ulCookie) )
		{
			pInputItem->SetClientServices(m_pFilterClientServices);
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				CButtonLEDInput* pButtonLEDInput = (CButtonLEDInput*)pInputItem;
				ULONG ulCorrespondingButtonIndex = pButtonLEDInput->GetCorrespondingButtonIndex();
				CInputItem* pCorrespondingButtons = NULL;
				m_rgInputCollections[collectionIndex].GetNext(&pCorrespondingButtons, ulCorrespondingButtonIndex);
				pButtonLEDInput->Init(pCorrespondingButtons);
			}
		}
	}

	m_OutputCollection.SetStateOverlayMode(TRUE);
}

CDeviceFilter::~CDeviceFilter()
{
	{	// Make sure all keys are up!
		CGckCritSection HoldCriticalSection(&m_MutexHandle);
		m_KeyMixer.ClearState();			// All keys up
		m_KeyMixer.PlayGlobalState();		// play it!
	}

	// Get rid of the florkin (thanks for the word Loyal) mouse model
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->DecRef();
		m_pMouseModel = NULL;
	}

	// Deallocate force block
	if (m_pForceBlock != NULL)
	{
		delete m_pForceBlock;
		m_pForceBlock = NULL;
	}
	m_pFilterClientServices->DecRef();

	// Deallocate input collections
	if (m_rgInputCollections != NULL)
	{
		delete[] m_rgInputCollections;
		m_rgInputCollections = NULL;
	}
}

/***********************************************************************************
**
**	BOOLEAN CDeviceFilter::EnsureMouseModelExists()
**
**	@func	We are required to have a mouse model
**
**
**	@rdesc	TRUE if we have one or were able to create one, FALSE if there is still no model
**
*************************************************************************************/
BOOLEAN CDeviceFilter::EnsureMouseModelExists()
{
	if (m_pMouseModel == NULL)
	{
		m_pMouseModel = new WDM_NON_PAGED_POOL CMouseModel(m_pFilterClientServices);
		if (m_pMouseModel == NULL)
		{
			return FALSE;
		}
	}

	return TRUE;
}

/***********************************************************************************
**
**	NTSTATUS CDeviceFilter::SetWorkingSet(UCHAR ucWorkingSet)
**
**	@func	Set the current set to work with (for IOCTL_GCK_SEND_COMMAND usage)
**
**
**	@rdesc	STATUS_SUCCESS or STATUS_INVALID_PARAMETER if working-set is out of range
**
*************************************************************************************/
NTSTATUS CDeviceFilter::SetWorkingSet(UCHAR ucWorkingSet)
{
	if (ucWorkingSet < m_ucNumberOfInputCollections)
	{
		m_ucWorkingInputCollection = ucWorkingSet;
		return STATUS_SUCCESS;
	}

	return STATUS_INVALID_PARAMETER;
}

void CDeviceFilter::CopyToTestFilter(CDeviceFilter& rDeviceFilter)
{
	ASSERT(rDeviceFilter.m_ucNumberOfInputCollections == m_ucNumberOfInputCollections);

	// Give it our mouse model (it's Macros will have it, so should it)
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->IncRef();
	}
	if (rDeviceFilter.m_pMouseModel != NULL)
	{
		rDeviceFilter.m_pMouseModel->DecRef();
	}
	rDeviceFilter.m_pMouseModel = m_pMouseModel;

	if (rDeviceFilter.m_ucNumberOfInputCollections == m_ucNumberOfInputCollections)
	{
		for (UCHAR ucCollection = 0; ucCollection < m_ucNumberOfInputCollections; ucCollection++)
		{
			ULONG ulCookie = 0;
			ULONG ulCookieTest = 0;
			CInputItem *pInputItem = NULL;
			CInputItem *pInputItemTest = NULL;
			while (S_OK == m_rgInputCollections[ucCollection].GetNext(&pInputItem, ulCookie))
			{
				rDeviceFilter.m_rgInputCollections[ucCollection].GetNext(&pInputItemTest, ulCookieTest);
				ASSERT(pInputItemTest != NULL);
				if (pInputItemTest != NULL)
				{
					pInputItem->Duplicate(*pInputItemTest);
				}
			}
		}
	}

	rDeviceFilter.m_ucActiveInputCollection = m_ucActiveInputCollection;
	rDeviceFilter.m_ucWorkingInputCollection = m_ucWorkingInputCollection;
}

NTSTATUS CDeviceFilter::SetLEDBehaviour(GCK_LED_BEHAVIOUR_OUT* pLEDBehaviourOut)
{
	if (pLEDBehaviourOut != NULL)
	{
		// Find the LED items
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while (S_OK == m_rgInputCollections[m_ucWorkingInputCollection].GetNext(&pInputItem, ulCookie))
		{
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				((CButtonLEDInput*)pInputItem)->SetLEDStates( pLEDBehaviourOut->ucLEDBehaviour,
															pLEDBehaviourOut->ulLEDsAffected,
															pLEDBehaviourOut->ucShiftArray);

				UpdateAssignmentBasedItems(FALSE);
				return STATUS_SUCCESS;
			}
		}

		return STATUS_INVALID_PARAMETER;	// Not a valid IOCTL for this device?
	}

	return STATUS_INVALID_PARAMETER;
}


// We use this for sending data down at PASSIVE IRQL
void CDeviceFilter::IncomingRequest()
{
	if (m_bNeedToUpdateLEDs)
	{
		m_bNeedToUpdateLEDs = FALSE;
		UpdateAssignmentBasedItems(TRUE);
	}
}

void CDeviceFilter::ProcessInput
(
	PCHAR pcReport,
	ULONG ulReportLength
)
{
	GCK_DBG_RT_ENTRY_PRINT(("CDeviceFilter::ProcessInput(0x%0.8x, 0x%0.8x\n)",
				pcReport,
				ulReportLength));

	//	This function is protected by a critical section.
	CGckCritSection HoldCriticalSection(&m_MutexHandle);

	// Get the old shift state before reading the new one it
	USHORT usOldLowShift = 0;
	ULONG ulModifiers = m_rgInputCollections[m_ucActiveInputCollection].GetModifiers();
	while (ulModifiers != 0)
	{
		usOldLowShift++;
		if (ulModifiers & 0x00000001)
		{
			break;
		}
		ulModifiers >>= 1;
	}

	//	Read the inputs
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::ProcessInput - reading report into inputs\n"));

	m_rgInputCollections[m_ucActiveInputCollection].ReadFromReport(
														m_pFilterClientServices->GetHidPreparsedData(),
														pcReport,
														ulReportLength
													);

	// Check the current buttons, has the shift state changed?
	USHORT usNewLowShift = 0;
	ulModifiers = m_rgInputCollections[m_ucActiveInputCollection].GetModifiers();
	while (ulModifiers != 0)
	{
		usNewLowShift++;
		if (ulModifiers & 0x00000001)
		{
			break;
		}
		ulModifiers >>= 1;
	}

	if (usNewLowShift != usOldLowShift)
	{
		m_bNeedToUpdateLEDs = TRUE;
	}

	// Should we even bother checking the data for a profile selector (right now this is also indicitive of usButtonLED
	if (m_ucNumberOfInputCollections > 1)
	{
		// Iterate through the items looking for profile selector
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		CProfileSelectorInput* pProfileSelector = NULL;
		while((pProfileSelector == NULL) && (m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) == S_OK))
		{
			if (pInputItem->GetType() == ControlItemConst::usProfileSelectors)
			{
				pProfileSelector = (CProfileSelectorInput*)pInputItem;
			}
		}

		if (pProfileSelector != NULL)
		{
			UCHAR ucSelectedProfile = 0;
			pProfileSelector->GetSelectedProfile(ucSelectedProfile);
			if (ucSelectedProfile >= m_ucNumberOfInputCollections)
			{
				ASSERT(ucSelectedProfile >= m_ucNumberOfInputCollections);
			}
			else if (ucSelectedProfile != m_ucActiveInputCollection)
			{
				// Tell all items in the action Queue they are free (which was from the previous profile collection)
				m_ActionQueue.ReleaseTriggers();

				// Update to the new current
				m_ucActiveInputCollection = ucSelectedProfile;

				// Need to reparse the report
				m_rgInputCollections[m_ucActiveInputCollection].ReadFromReport(
																	m_pFilterClientServices->GetHidPreparsedData(),
																	pcReport,
																	ulReportLength
																);
				// Need to update the active-set items
				m_bNeedToUpdateLEDs = TRUE;
			}
		}
	}

	// Possibly Trigger triggered
	CheckTriggers(pcReport, ulReportLength);
	
	//	Call Jog Routine
	Jog(pcReport, ulReportLength);
	
	GCK_DBG_EXIT_PRINT(("Exiting CDeviceFilter::ProcessInput\n"));
}

void CDeviceFilter::CheckTriggers(PCHAR pcReport, ULONG ulReportLength)
{
	PGCK_FILTER_EXT pFilterExtension = ((CFilterGcKernelServices*)m_pFilterClientServices)->GetFilterExtension();
	if ((pFilterExtension != NULL) && (pFilterExtension->pvTriggerIoctlQueue != NULL))
	{
		CGuardedIrpQueue* pTriggerQueue = (CGuardedIrpQueue*)(pFilterExtension->pvTriggerIoctlQueue);
		CTempIrpQueue tempIrpQueue;
		pTriggerQueue->RemoveAll(&tempIrpQueue);

		USAGE pUsages[15];
		ULONG ulNumUsages = 15;
		NTSTATUS NtStatus = HidP_GetButtons(HidP_Input, HID_USAGE_PAGE_BUTTON, 0, pUsages, &ulNumUsages,
				m_pFilterClientServices->GetHidPreparsedData(), pcReport, ulReportLength);
		ASSERT(NtStatus != HIDP_STATUS_BUFFER_TOO_SMALL);	// 15 should be plenty

		// Set up a mask with values from array
		ULONG ulButtonBitArray = 0x0;
		for (ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			ulButtonBitArray |= (1 << (pUsages[ulIndex]-1));
		}

		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			// No need to check, irp fields are checked when item is placed on Queue
			PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
			GCK_TRIGGER_OUT* pTriggerOut = (GCK_TRIGGER_OUT*)(pIrp->AssociatedIrp.SystemBuffer);

			// No need to check the type for support, checked on entry

			// Check for requested down buttons (we only support button triggering right now)
			if (pTriggerOut->ucTriggerSubType == TRIGGER_ON_BUTTON_DOWN)
			{

				if ((ulButtonBitArray & pTriggerOut->ulTriggerInfo1) != 0)
				{	// One of the desired buttons has been pressed
					CompleteTriggerRequest(pIrp, ulButtonBitArray);
				}
				else
				{	// Button down wasn't triggered
					pTriggerQueue->Add(pIrp);
				}
			}
			else if ((ulButtonBitArray & pTriggerOut->ulTriggerInfo1) != pTriggerOut->ulTriggerInfo1)
			{	// One of the desired buttons is not down
				CompleteTriggerRequest(pIrp, ulButtonBitArray);
			}
			else
			{	// Item wasn't triggered, put back in queue
				pTriggerQueue->Add(pIrp);
			}
		}		
	}
}

void CDeviceFilter::JogActionQueue
(
	PCHAR pcReport,
	ULONG ulReportLength
)
{
	GCK_DBG_RT_ENTRY_PRINT(("CDeviceFilter::JogActionQueue(0x%0.8x, 0x%0.8x\n)",
				pcReport,
				ulReportLength));

	//	This function is protected by a critical section.
	CGckCritSection HoldCriticalSection(&m_MutexHandle);

	//	Call Jog Routine
	Jog(pcReport, ulReportLength);
	
	GCK_DBG_EXIT_PRINT(("Exiting CDeviceFilter::JogActionQueue\n"));
}

void CDeviceFilter::Jog(PCHAR pcReport, ULONG ulReportLength)
{
	//
	//  1.  Clear the outputs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - clearing outputs\n"));
	m_OutputCollection.SetDefaultState();

	//
	//	2. Clear KeyMixer
	//
	m_KeyMixer.ClearState();

	//
	//	3.	Clear Mouse Frame
	//
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->NewPacket( m_pFilterClientServices->GetTimeMs() );

	}

	//
	//	4.	Process inputs
	//
	ULONG ulCookie = 0;
	CInputItem *pInputItem = NULL;
	while( S_OK == m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) )
	{
		pInputItem->MapToOutput(&m_OutputCollection);
	}
	//Copy over the modifiers
	m_OutputCollection.SetModifiers(m_rgInputCollections[m_ucActiveInputCollection].GetModifiers());

	//
	//	5.	Process action queue
	//
	m_ActionQueue.Jog();

	//
	//	6.	Write outputs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - writing outputs\n"));
	RtlZeroMemory( reinterpret_cast<PVOID>(pcReport), ulReportLength);	//zero report first
	m_OutputCollection.WriteToReport(m_pFilterClientServices->GetHidPreparsedData(),
									pcReport,
									ulReportLength);
	//
	//	7.	Call hook to complete pending IRP_MJ_READ IRPs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - Sending out data\n"));
	m_pFilterClientServices->DeviceDataOut(pcReport, ulReportLength, S_OK);
	
	//
	//	8.	Play Keyboard state, if is has changed
	//
	m_KeyMixer.PlayGlobalState();

	//	9.	Play Mouse state, if it has changed
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->SendMousePacket();
	}

	GCK_DBG_EXIT_PRINT(("CDeviceFilter::Jog\n"));
}

/***********************************************************************************
**
**	NTSTATUS CDeviceFilter::OtherFilterBecomingActive()
**
**	@func	We are going in the background.
**			Make sure all Queued items are released (removed from Queue)
**
*************************************************************************************/
void CDeviceFilter::OtherFilterBecomingActive()
{
	//  1.  Clear the outputs
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::OtherFilterBecomingActive - clearing outputs\n"));
//	DbgPrint("CDeviceFilter::OtherFilterBecomingActive - clearing outputs: 0x%08X\n", this);
	m_OutputCollection.SetDefaultState();

	//	2. Clear KeyMixer
	m_KeyMixer.ClearState();

	//	3.	Clear Mouse Frame
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->NewPacket(m_pFilterClientServices->GetTimeMs());
	}

	//	4. Clear out the Action Queue
	for (;;)
	{
		CQueuedAction* pQueuedAction = m_ActionQueue.GetHead();
		if (pQueuedAction == NULL)
		{
			break;
		}
		pQueuedAction->TriggerReleased();			// Is this needed?
		m_ActionQueue.RemoveItem(pQueuedAction);
	}

	//	5.	Play Keyboard state, if is has changed
	m_KeyMixer.PlayGlobalState();

	//	6.	Play Mouse state, if it has changed
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->SendMousePacket();
	}
}

#define SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader)\
	(reinterpret_cast<PCOMMAND_HEADER>\
		( reinterpret_cast<PUCHAR>(pCommandHeader) +\
		reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize )\
	)

#define SKIP_TO_NEXT_COMMAND_DIRECTORY(pCommandDirectory)\
	(reinterpret_cast<PCOMMAND_DIRECTORY>\
		(reinterpret_cast<PUCHAR>(pCommandDirectory) +\
		pCommandDirectory->ulEntireSize)\
	)
	
#define COMMAND_BLOCK_FITS_IN_DIRECTORY(pCommandDirectory, pCommandHeader)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandHeader) - reinterpret_cast<PUCHAR>(pCommandDirectory)) +\
					reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize\
				)\
		)
#define COMMAND_DIRECTORY_FITS_IN_DIRECTORY(pCommandDirectory, pCommandSubDirectory)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandSubDirectory) - reinterpret_cast<PUCHAR>(pCommandDirectory)) +\
					pCommandSubDirectory->ulEntireSize\
				)\
		)

NTSTATUS CDeviceFilter::ProcessCommands(const PCOMMAND_DIRECTORY cpCommandDirectory)
{
	HRESULT hr = S_OK;

	//
	//	DEBUG Sanity Checks
	//
	ASSERT( eDirectory == cpCommandDirectory->CommandHeader.eID );
	
	//
	//	IF there are no blocks in the directory this is a no-op,
	//	but probably not intended
	//
	ASSERT(	1 <= cpCommandDirectory->usNumEntries );
	if( 1 > cpCommandDirectory->usNumEntries )
	{
		return S_FALSE;		//We know that this is not NTSTATUS code,
							//But it won't fail anything, yet it is not quite success.
	}

	//
	//	Skip Directory header to get to first block
	//
	PCOMMAND_HEADER pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(cpCommandDirectory);
	
	//
	//	If we have a sub-directory, call ourselves recursively, for each sub-directory
	//
	if( eDirectory == pCommandHeader->eID)
	{
		PCOMMAND_DIRECTORY pCurDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandHeader);
		NTSTATUS NtWorstCaseStatus = STATUS_SUCCESS;
		NTSTATUS NtStatus;
		USHORT usDirectoryNum = 1;
		while( usDirectoryNum <= cpCommandDirectory->usNumEntries)
		{
			//Sanity check that data structure is valid
			ASSERT( COMMAND_DIRECTORY_FITS_IN_DIRECTORY(cpCommandDirectory, pCurDirectory) );
			if( !COMMAND_DIRECTORY_FITS_IN_DIRECTORY(cpCommandDirectory, pCurDirectory) )
			{
				return STATUS_INVALID_PARAMETER;
			}
			//Call ourselves recursively
			NtStatus = CDeviceFilter::ProcessCommands(pCurDirectory);
			if( NT_ERROR(NtStatus) )
			{
				NtWorstCaseStatus = NtStatus;
			}
			//Skip to next directory
			pCurDirectory = SKIP_TO_NEXT_COMMAND_DIRECTORY(pCurDirectory);
			usDirectoryNum++;
		}
		//If one or more commands in the block failed, return an error.
		return NtWorstCaseStatus;
	}

	//
	//	If we are here, we have reached the bottom of a directory,
	//	to a command we need to process (or not if we don't support it)
	//
	switch( CommandType(pCommandHeader->eID) )
	{
		case COMMAND_TYPE_ASSIGNMENT_TARGET:
		{
			switch(pCommandHeader->eID)
			{
				case eRecordableAction:
				{
					//
					//	Get the input item that needs this assignment.
					//
					CInputItem *pInputItem;
					const PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET>(pCommandHeader);
					pInputItem = m_rgInputCollections[m_ucWorkingInputCollection].GetFromControlItemXfer(pAssignmentTarget->cixAssignment);
					
					if( pInputItem )
					{
						CAction *pAction = NULL;
						//
						//	If there is an assignment block, get the assignment
						//	otherwise the command was sent to kill an existing assignment.
						//
						if(cpCommandDirectory->usNumEntries > 1)
						{
							//
							//	Get Assignment block
							//
							PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

							//
							//	Sanity Check Assignment block
							//
							ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
							
							//
							//	Make sure this really is an Assignment block
							//
							ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

							//

							//	Create Action
							//
							hr = ActionFactory(pAssignment, &pAction);
						}
						if( SUCCEEDED(hr) )
						{
							//This block needs protection by a critical section
							CGckCritSection HoldCriticalSection(&m_MutexHandle);
							//	Assign to trigger, pAction == NULL this is an unassignment
							hr = pInputItem->AssignAction(&pAssignmentTarget->cixAssignment, pAction);
							//We may not have an action
							if(pAction)
							{
								pAction->DecRef();
							}
						}
					}
					break;
				}
				case eBehaviorAction:
				{
					//
					//	Get the input item that needs this assignment.
					//
					CInputItem *pInputItem;
					const PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET>(pCommandHeader);
					pInputItem = m_rgInputCollections[m_ucWorkingInputCollection].GetFromControlItemXfer(pAssignmentTarget->cixAssignment);
					if( pInputItem )
					{
					
						CBehavior *pBehavior = NULL;
						//
						//	If there is an assignment block, get the assignment
						//	otherwise the command was sent to kill an existing assignment.
						//
						if(cpCommandDirectory->usNumEntries > 1)
						{
							//
							//	Get Assignment block
							//
							PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

							//
							//	Sanity Check Assignment block
							//
							ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
								
							//
							//	Make sure this really is an Assignment block
							//
							ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

							//
							//	Create Behavior
							//
							hr = BehaviorFactory(pAssignment, &pBehavior);
						}
						if( SUCCEEDED(hr) )
						{
							//This block needs protection by a critical section
							CGckCritSection HoldCriticalSection(&m_MutexHandle);
							//	Assign to trigger, pAction == NULL this is an unassignment
							hr = pInputItem->AssignBehavior(&pAssignmentTarget->cixAssignment, pBehavior);
							//We may not have an action
							if(pBehavior)
							{
								pBehavior->DecRef();
							}
						}
						if( SUCCEEDED(hr) )
						{
							pInputItem->PostAssignmentProcessing();
						}
					}
					break;
				}
				case eFeedbackAction:
				{
					//
					//	Get Assignment block
					//
					PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

					//
					//	Sanity Check Assignment block
					//
					ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
						
					//
					//	Make sure this really is an Assignment block
					//
					ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

					//
					//	Create Behavior
					//

					if (pAssignment->CommandHeader.eID == eForceMap)
					{
						if (pAssignment->CommandHeader.ulByteSize != sizeof(FORCE_BLOCK))
						{
							ASSERT(FALSE);
							return E_INVALIDARG;
						}
						if (m_pForceBlock == NULL)
						{
							m_bFilterBlockChanged = TRUE;
						}
						else if (::RtlCompareMemory(m_pForceBlock, (const void*)pAssignment, sizeof(FORCE_BLOCK)) != sizeof(FORCE_BLOCK))
						{
							m_bFilterBlockChanged = TRUE;
							delete m_pForceBlock;
							m_pForceBlock = NULL;
						}
						if (m_bFilterBlockChanged)
						{
							m_pForceBlock = new WDM_NON_PAGED_POOL FORCE_BLOCK;
							::RtlCopyMemory((void*)m_pForceBlock, pAssignment, sizeof(FORCE_BLOCK));
						}
						hr = S_OK;
					}
					else
					{
						hr = E_NOTIMPL;
					}
					break;
				}
			}
			return hr;
		}

		case COMMAND_TYPE_FEEDBACK:
		{
			ASSERT(FALSE);
			return E_NOTIMPL;
		}

		case COMMAND_TYPE_QUEUE:
			return E_NOTIMPL;
		case COMMAND_TYPE_GENERAL:
			/*
			* Mouse parameters are no longer sent as a general command
			* because it was too difficult for the client
			switch(pCommandHeader->eID)
			{
				case eMouseFXModel:
				{
					//This block needs protection by a critical section
					CGckCritSection HoldCriticalSection(&m_MutexHandle);
					PMOUSE_FX_MODEL pMouseModelData = reinterpret_cast<PMOUSE_FX_MODEL>(pCommandHeader);
					if(pMouseModelData->fAssign)
					{
						m_MouseModel.SetModelParameters( &pMouseModelData->Parameters );
					}
					else
					{
						m_MouseModel.SetModelParameters( NULL );
					}
					return S_OK;
				}
			}
			*/
			return E_NOTIMPL;
	}
	return E_NOTIMPL;
}

void CDeviceFilter::UpdateAssignmentBasedItems(BOOLEAN bIgnoreWorking)
{
	// Right now the only assignment based items are the Button LEDs.
	// When this changes make the AssignmentsChanged item virtual and just call it for all

	// Only bother if the Working-Set is the Active set
	if ((bIgnoreWorking == TRUE) || (m_ucWorkingInputCollection == m_ucActiveInputCollection))
	{
		// Iterate through the items looking for usButtonLEDs
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while(m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) == S_OK)
		{
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				((CButtonLEDInput*)pInputItem)->AssignmentsChanged();
			}
		}
	}
}

// Returns weather or not to Queue irp
BOOLEAN CDeviceFilter::TriggerRequest(IRP* pIrp)
{
	GCK_TRIGGER_OUT* pTriggerOut = (GCK_TRIGGER_OUT*)(pIrp->AssociatedIrp.SystemBuffer);

	// Check the type for support (we only support button right now)
	if (pTriggerOut->ucTriggerType != GCK_TRIGGER_BUTTON)
	{
		pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
		CompleteTriggerRequest(pIrp, 0);
		return FALSE;		// Do not queue
	}

	// Do they want the data back immediatly (this doesn't quite work!!!!!!!)
	if (pTriggerOut->ucTriggerSubType == TRIGGER_BUTTON_IMMEDIATE)
	{
		CompleteTriggerRequest(pIrp, 0);
		return FALSE;		// Not not queue
	}

	return TRUE;			// Queue the sucka
}

void CDeviceFilter::CompleteTriggerRequest(IRP* pIrp, ULONG ulButtonStates)
{
	void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;

	// Check all the pointers (just assume button request right now)
	if (pvUserData == NULL)
	{
		pIrp->IoStatus.Status = STATUS_NO_MEMORY;
	}
	else
	{	// Valid pointers all around, get button data
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(ULONG);

		ULONG* puLong = PULONG(pvUserData);
		*puLong = ulButtonStates;
	}

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

NTSTATUS CDeviceFilter::ProcessKeyboardIrp(IRP* pKeyboardIrp)
{
	if (m_pFilterClientServices == NULL)
	{
		return STATUS_PENDING;
	}
	return m_pFilterClientServices->PlayFromQueue(pKeyboardIrp);
}


HRESULT CDeviceFilter::ActionFactory(PASSIGNMENT_BLOCK pAssignment, CAction **ppAction)
{
	GCK_DBG_ENTRY_PRINT(("Entering CDeviceFilterActionFactory, pAssignment = 0x%0.8x\n", pAssignment));

	*ppAction = NULL;
	switch( pAssignment->CommandHeader.eID )
	{
		case	eTimedMacro:
		{
			CTimedMacro *pTimedMacro = new WDM_NON_PAGED_POOL CTimedMacro;
			if( pTimedMacro && pTimedMacro->Init(reinterpret_cast<PTIMED_MACRO>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pTimedMacro;
				GCK_DBG_TRACE_PRINT(("*ppAction = pTimedMacro(0x%0.8x)\n", pTimedMacro));
				return S_OK;
			}
			return E_OUTOFMEMORY;
		}
		case	eKeyString:
		{
			CKeyString *pKeyString = new WDM_NON_PAGED_POOL CKeyString;
			if( pKeyString && pKeyString->Init(reinterpret_cast<PKEYSTRING_MAP>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pKeyString;
				GCK_DBG_TRACE_PRINT(("*ppAction = pKeyString(0x%0.8x)\n", pKeyString));
				return S_OK;
			}
			//else
			delete pKeyString;
			return E_OUTOFMEMORY;
		}
		//Button map and key map have identical implementation using CMapping
		case	eButtonMap:
		case	eKeyMap:
		{
			CMapping *pMapping = new WDM_NON_PAGED_POOL CMapping;
			if( pMapping && pMapping->Init(&(reinterpret_cast<PKEY_MAP>(pAssignment)->Event), &m_KeyMixer) )
			{
				*ppAction = pMapping;
				GCK_DBG_TRACE_PRINT(("*ppAction = pMapping(0x%0.8x)\n", pMapping));
				return S_OK;
			}
			//else
			delete pMapping;
			return E_OUTOFMEMORY;
		}
		case	eCycleMap:
			return E_NOTIMPL;
		case	eAxisMap:
		{
			CAxisMap *pAxisMap = new WDM_NON_PAGED_POOL CAxisMap;
			if(pAxisMap)
			{
				pAxisMap->Init( *reinterpret_cast<PAXIS_MAP>(pAssignment));
				*ppAction = pAxisMap;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseButtonMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}
			UCHAR ucButtonNum = reinterpret_cast<PMOUSE_BUTTON_MAP>(pAssignment)->ucButtonNumber;
			CMouseButton *pMouseButton = new WDM_NON_PAGED_POOL CMouseButton(ucButtonNum, m_pMouseModel);
			if(pMouseButton)
			{
				*ppAction = pMouseButton;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXAxisMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			BOOLEAN fXAxis = reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->fIsX;
			CMouseAxisAssignment *pMouseAxis;
			pMouseAxis= new WDM_NON_PAGED_POOL CMouseAxisAssignment(fXAxis, m_pMouseModel);
			if(pMouseAxis)
			{
				//Set Model parameters
				if(fXAxis)
				{
					m_pMouseModel->SetXModelParameters( &(reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->AxisModelParameters));
				}
				else
				{
					m_pMouseModel->SetYModelParameters( &(reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->AxisModelParameters));
				}
				*ppAction = pMouseAxis;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXClutchMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMouseClutch *pMouseClutch = new WDM_NON_PAGED_POOL CMouseClutch(m_pMouseModel);
			if(pMouseClutch)
			{
				*ppAction = pMouseClutch;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXDampenMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMouseDamper *pMouseDamper = new WDM_NON_PAGED_POOL CMouseDamper(m_pMouseModel);
			if(pMouseDamper)
			{
				*ppAction = pMouseDamper;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXZoneIndicator:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			UCHAR ucAxis = reinterpret_cast<PMOUSE_FX_ZONE_INDICATOR>(pAssignment)->ucAxis;
			CMouseZoneIndicator *pMouseZone;
			pMouseZone	= new WDM_NON_PAGED_POOL CMouseZoneIndicator(ucAxis, m_pMouseModel);
			if(pMouseZone)
			{
				*ppAction = pMouseZone;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case eMultiMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMultiMacro *pMultiMacro = new WDM_NON_PAGED_POOL CMultiMacro(m_pMouseModel);
			if (pMultiMacro  && pMultiMacro->Init(reinterpret_cast<PMULTI_MACRO>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pMultiMacro;
				GCK_DBG_TRACE_PRINT(("*ppAction = pMultiMacro(0x%0.8x)\n", pMultiMacro));
				return S_OK;
			}
			{
				return E_OUTOFMEMORY;
			}
		}
	}
	return E_NOTIMPL;
}


HRESULT CDeviceFilter::BehaviorFactory(PASSIGNMENT_BLOCK pAssignment, CBehavior **ppBehavior)
{
	GCK_DBG_ENTRY_PRINT(("Entering CDeviceFilterBehaviorFactory, pAssignment = 0x%0.8x\n", pAssignment));
	*ppBehavior = NULL;
	switch( pAssignment->CommandHeader.eID )
	{
		case eStandardBehaviorCurve:
		{
			CStandardBehavior *pStandardBehavior = new WDM_NON_PAGED_POOL CStandardBehavior;
			if( pStandardBehavior && pStandardBehavior->Init(reinterpret_cast<PBEHAVIOR_CURVE>(pAssignment)))
			{
				*ppBehavior = pStandardBehavior;
				GCK_DBG_TRACE_PRINT(("*ppBehavior = pStandardBehavior(0x%0.8x)\n", pStandardBehavior));
				return S_OK;
			}
			return E_OUTOFMEMORY;
		}
	}
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckextrn.h ===
#ifndef __GckExtrn_h__
#define __GckExtrn_h__
//	@doc
/**********************************************************************
*
*	@module	GckExtrn.h	|
*
*	External Definitions needed to open and communicate with the driver.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckExtrn	|
*	IOCTL definitions and the name of the Control Object to be used in CreateFile.
*
**********************************************************************/

/********************************************
*	Driver (and Symbolic Link) Names		*
*********************************************/
#define GCK_CONTROL_NTNAME  L"\\Device\\MS_GCKERNEL"
#define GCK_CONTROL_SYMNAME L"\\DosDevices\\MS_GCKERNEL"
#define GCK_CONTROL_W32Name "\\\\.\\MS_GCKERNEL"

/****************************************
*		IOCTL definitions				*
*****************************************/
#define GCK_IOCTL_CODE(_x_) CTL_CODE(                         \
					        FILE_DEVICE_UNKNOWN,              \
						    (0x0800 | _x_),                   \
                            METHOD_BUFFERED,                  \
                            FILE_ANY_ACCESS                   \
                            )
#define GCK_IOCTL_DIRECT_CODE(_x_)	CTL_CODE(				\
									FILE_DEVICE_UNKNOWN,	\
									(0x0800 | _x_),			\
									METHOD_OUT_DIRECT,		\
									FILE_ANY_ACCESS			\
									)


#define IOCTL_GCK_GET_HANDLE					GCK_IOCTL_CODE(0x0001)
#define IOCTL_GCK_GET_CAPS						GCK_IOCTL_CODE(0x0002)
#define IOCTL_GCK_SEND_COMMAND					GCK_IOCTL_CODE(0x0003)
#define IOCTL_GCK_BACKDOOR_POLL					GCK_IOCTL_DIRECT_CODE(0x0004)
#define IOCTL_GCK_BEGIN_TEST_SCHEME				GCK_IOCTL_CODE(0x0005)
#define IOCTL_GCK_UPDATE_TEST_SCHEME			GCK_IOCTL_CODE(0x0006)
#define IOCTL_GCK_END_TEST_SCHEME				GCK_IOCTL_CODE(0x0007)
#define IOCTL_GCK_ENABLE_DEVICE					GCK_IOCTL_CODE(0x0008)
#define IOCTL_GCK_SET_INTERNAL_POLLING			GCK_IOCTL_CODE(0x0009)
#define IOCTL_GCK_ENABLE_TEST_KEYBOARD			GCK_IOCTL_CODE(0x000A)
#define IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE		GCK_IOCTL_CODE(0x000B)
#define IOCTL_GCK_END_FF_NOTIFICATION			GCK_IOCTL_CODE(0x000C)
#define IOCTL_GCK_GET_FF_SCHEME_DATA			GCK_IOCTL_CODE(0x000D)
#define IOCTL_GCK_SET_WORKINGSET				GCK_IOCTL_CODE(0x000E)
#define IOCTL_GCK_QUERY_PROFILESET				GCK_IOCTL_CODE(0x000F)
#define IOCTL_GCK_LED_BEHAVIOUR					GCK_IOCTL_CODE(0x0010)
#define IOCTL_GCK_TRIGGER						GCK_IOCTL_CODE(0x0011)
#define IOCTL_GCK_ENABLE_KEYHOOK				GCK_IOCTL_CODE(0x0012)
#define IOCTL_GCK_DISABLE_KEYHOOK				GCK_IOCTL_CODE(0x0013)
#define IOCTL_GCK_GET_KEYHOOK_DATA				GCK_IOCTL_CODE(0x0014)

/**********************************************************
*	Structures passed in IOCTLs							  *
**********************************************************/

typedef enum
{
	GCK_POLLING_MODE_RAW		= 0x00000001,
	GCK_POLLING_MODE_FILTERED	= 0x00000002,
	GCK_POLLING_MODE_MOUSE		= 0x00000004,
	GCK_POLLING_MODE_KEYBOARD	= 0x00000008,
} GCK_POLLING_MODES;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Input structure for IOCTL_GCK_SET_INTERNAL_POLLING
//
typedef struct tagGCK_SET_INTERNAL_POLLING_DATA
{
	ULONG	ulHandle;	//@field Handle returned from IOCTL_GCK_GET_HANDLE
	BOOLEAN fEnable;	//@field TRUE to turn continous internal polling on, FALSE to turn it off
} GCK_SET_INTERNAL_POLLING_DATA, *PGCK_SET_INTERNAL_POLLING_DATA;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Input structure for IOCTL_GCK_BACKDOOR_POLL
//
typedef struct tagGCK_BACKDOOR_POLL_DATA
{
	ULONG			  ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_POLLING_MODES ePollingMode;	//@field TRUE for a raw poll, FALSE for filtered data (unapplied changes are active)
} GCK_BACKDOOR_POLL_DATA, *PGCK_BACKDOOR_POLL_DATA;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Output structure for IOCTL_GCK_BACKDOOR_POLL
//										if the GCK_POLLING_MODE_MOUSE was used.
//
typedef struct tagGCK_MOUSE_OUTPUT
{
	char	cXMickeys;
	char	cYMickeys;
	char	cButtons;
	char	fDampen:1;
	char	fClutch:1;
} GCK_MOUSE_OUTPUT, *PGCK_MOUSE_OUTPUT;

typedef struct tagGCK_ENABLE_TEST_KEYBOARD
{
	ULONG	ulHandle;	//@field Handle returned from IOCTL_GCK_GET_HANDLE
	BOOLEAN fEnable;	//@field TRUE for a keyboard data, FALSE for none
} GCK_ENABLE_TEST_KEYBOARD, *PGCK_ENABLE_TEST_KEYBOARD;

//
// @struct GCK_SET_WORKINGSET | Output structure for IOCTL_GCK_SET_WORKINGSET
//
typedef struct tagGCK_SET_WORKINGSET
{
	ULONG			ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	unsigned char	ucWorkingSet;	//@field 0 based working set for future IOCTLs
} GCK_SET_WORKINGSET, *PGCK_SET_WORKINGSET;

//
// @struct GCK_QUERY_PROFILESET | Input structure from IOCTL_GCK_QUERY_PROFILESET
//
typedef struct tagGCK_QUERY_PROFILESET
{
	unsigned char	ucActiveProfile;	//@field 0 active profile, determined by slider position
	unsigned char	ucWorkingSet;		//@field 0 based working profile from previous call to GCK_IOCTL_SETWORKINGSET
} GCK_QUERY_PROFILESET, *PGCK_QUERY_PROFILESET;


// LED behaviour enums (non combinable!)
typedef enum
{
	GCK_LED_BEHAVIOUR_DEFAULT	= 0x00,
	GCK_LED_BEHAVIOUR_ON		= 0x01,
	GCK_LED_BEHAVIOUR_OFF		= 0x02,
	GCK_LED_BEHAVIOUR_BLINK		= 0x03
} GCK_LED_BEHAVIOURS;

//
// @struct GCK_LED_BEHAVIOUR_OUT | Output structure to IOCTL_GCK_LED_BEHAVIOUR
//
typedef struct tagGCK_LED_BEHAVIOUR_OUT
{
	ULONG				ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_LED_BEHAVIOURS	ucLEDBehaviour;	//@field New behaviour of the LEDs
	ULONG				ulLEDsAffected;	//@field Bit mask of effected LEDs
	unsigned char		ucShiftArray;	//@field Modifier state of affected LEDs
	unsigned char		ucBlinkRate;	//@field Blink rate of entire device (0 to leave unchanged)
} GCK_LED_BEHAVIOUR_OUT, *PGCK_LED_BEHAVIOUR_OUT;

//
// @struct GCK_LED_BEHAVIOUR_IN | Input structure from IOCTL_GCK_LED_BEHAVIOUR
//			This is a list of LEDs for the requested modifier state. If more than one modifier
//		is requested, only the lowest modifier state will report. Also not this is not the
//		actual state of the LEDs, but what would be the state if the requested modifier were pressed.
//
typedef struct tagGCK_LED_BEHAVIOUR_IN
{
	ULONG	ulLEDsOn;		//@field Bit mask LEDs in the on state (does not include blinking)
	ULONG	ulLEDsBlinking;	//@field Bit mask of LEDs that are blinking (not reported as on)
} GCK_LED_BEHAVIOUR_IN, *PGCK_LED_BEHAVIOUR_IN;


// Trigger Type enums (non combinable!)
typedef enum
{
	GCK_TRIGGER_BUTTON			= 0x00,
	GCK_TRIGGER_AXIS			= 0x01,		// Not currently availible
} GCK_TRIGGER_TYPES;

// Trigger SubType enums (non combinable!)
typedef enum
{
	TRIGGER_BUTTON_IMMEDIATE			= 0x00,
	TRIGGER_ON_BUTTON_DOWN				= 0x01,
	TRIGGER_ON_BUTTON_UP				= 0x02,
} GCK_TRIGGER_SUBTYPES;

//
// @struct GCK_TRIGGER_OUT | Output structure to IOCTL_GCK_TRIGGER
//			This IOCTL hangs untill the trigger happens (except for TRIGGER_IMMEDIATE)
//
typedef struct tagGCK_TRIGGER_OUT
{
	ULONG					ulHandle;			//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_TRIGGER_TYPES		ucTriggerType;		//@field Type of trigger
	GCK_TRIGGER_SUBTYPES	ucTriggerSubType;	//@field Subtype of trigger
	ULONG					ulTriggerInfo1;		//@field Information for triggering (type dependant)
	ULONG					ulTriggerInfo2;		//@field Secondary info for triggering (type dependant)
} GCK_TRIGGER_OUT, *PGCK_TRIGGER_OUT;


/********************************************************
*	IOCTL's available in debug builds of the driver		*
*********************************************************/
#define	IOCTL_GCK_SET_MODULE_DBG_LEVEL	GCK_IOCTL_CODE(0x1000)


/********************************************************
*	Module IDs for setting DEBUG levels					*
*********************************************************/
#define MODULE_GCK_CTRL_C			0x0001
#define MODULE_GCK_CTRL_IOCTL_C		0x0002
#define MODULE_GCK_FILTER_CPP		0x0004
#define MODULE_GCK_FILTERHOOKS_CPP	0x0005
#define MODULE_GCK_FLTR_C			0x0006
#define MODULE_GCK_FLTR_PNP_C		0x0007
#define MODULE_GCK_GCKSHELL_C		0x0008
#define MODULE_GCK_REMLOCK_C		0x0009
#define MODULE_GCK_SWVB_PNP_C		0x000A
#define MODULE_GCK_SWVBENUM_C		0x000B
#define MODULE_GCK_SWVKBD_C			0x000C

#define MODULE_CIC_ACTIONS_CPP					0x1000
#define MODULE_CIC_CONTROLITEMCOLLECTION_CPP	0x1001
#define MODULE_CIC_CONTROLITEM_CPP				0x1002
#define MODULE_CIC_DEVICEDESCRIPTIONS_CPP		0x1003
#define MODULE_CIC_DUALMODE_CPP					0x1004
//#define MODULE_CIC_DUMPCOMMANDBLOCK_CPP			0x1005
#define MODULE_CIC_LISTASARRAY_CPP				0x1006

#endif	//__GckExtrn_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckcritsec.h ===
//	@doc
/**********************************************************************
*
*	@module	GckCritSec	|
*
*	Implementation of CGckCritSection
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	filter	|
*	CGckCritSection	provides mutex/critical section support for CDeviceFilter
*	it is abstracted into this class for easier porting to USER mode.
*
*	CGckMutexHandle is used to hold the mutex that is held during a critical section.
*	The kernel mode version uses critical section.
*
**********************************************************************/
#ifndef __GckCritSec_h__
#define __GckCritSec_h__


#ifdef COMPILE_FOR_WDM_KERNEL_MODE
//
//	The kernel mode version of these classes
//
class CGckMutexHandle
{
	public:
		friend class CGckCritSection;
		friend class CGckMutex;
		CGckMutexHandle()
		{
			KeInitializeSpinLock(&m_SpinLock);
		}
	private:
		KSPIN_LOCK	m_SpinLock;
};

class CGckCritSection
{
	public:
		CGckCritSection(CGckMutexHandle *pMutexHandle):
			m_pMutexHandle(pMutexHandle)
		{
			KeAcquireSpinLock(&m_pMutexHandle->m_SpinLock, &m_OldIrql);
		}
		~CGckCritSection()
		{
			KeReleaseSpinLock(&m_pMutexHandle->m_SpinLock, m_OldIrql);
		}
	private:
		CGckMutexHandle *m_pMutexHandle;
		KIRQL m_OldIrql;
};
#endif

//
//	Place USER mode definitions here. (protecting with #ifdef of course).
//


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\fltr.c ===
//	@doc
/**********************************************************************
*
*	@module	FLTR.c	|
*
*	Implementation of basic IRP handlers for Filter Device Objects
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	FLTR	|
*	The non-Power and PnP IRP handler routines are handled in this module
*	for all Device Objects created as filters for the raw HID-Pdos.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FLTR_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_FLTR_DriverEntry)
#pragma alloc_text (PAGE, GCK_FLTR_Create)
#pragma alloc_text (PAGE, GCK_FLTR_Close)
#pragma alloc_text (PAGE, GCK_FLTR_Ioctl)
#pragma alloc_text (PAGE, GCK_FLTR_Unload)
#endif
/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Initializing the portions of the driver related to the filter devices.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_FLTR_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{	
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(puniRegistryPath);
	//
	//	Initialize Globals related to filter devices
	//
	GCK_DBG_TRACE_PRINT(("Initializing globals\n"));
	Globals.ulFilteredDeviceCount = 0;
	Globals.pFilterObjectList = NULL;
	Globals.pSWVB_FilterExt=NULL;				// Nobody owns the virtual bus yet.
	Globals.pVirtualKeyboardPdo = NULL;		// No keyboard object
	Globals.ulVirtualKeyboardRefCount = 0;	// No keyboard users
	ExInitializeFastMutex(&Globals.FilterObjectListFMutex);
	return	STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE for filter devices
**			- Called generated by Win32 API CreateFile or OpenFile
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
    
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pCurDeviceObject;
	PIO_STACK_LOCATION	pIrpStack;
	KEVENT				SyncEvent;
	USHORT				usShareAccess;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT (("Entering GCK_FLTR\n"));
	
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
    
	//
    // Increment IRP count, ASAP, note we couldn't do this until now, as we
    // knew not whether the device extension was really a GCK_FILTER_EXT
	//
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
    
	//	Make sure we are not in the process of going away
	if( 
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING != pFilterExt->eDeviceState
	)
	{
        GCK_DBG_WARN_PRINT(("Create while remove pending\n"));
		NtStatus = STATUS_DELETE_PENDING;
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	} 
	else // process this
	{
        GCK_DBG_TRACE_PRINT(("GCK_Create calling lower driver\n"));
		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

		//
		//We lie to hidclass about the desired share access,
		//because it doesn't know not to count us.
		//Notice below that we restore this before passing to our
		//internal poll routines, so that we can track it there.
		//
		usShareAccess=pIrpStack->Parameters.Create.ShareAccess;
		pIrpStack->Parameters.Create.ShareAccess = FILE_READ_DATA|FILE_WRITE_DATA;

		//This is our internal poll trying to create a file object, just call down
		if(	pFilterExt->InternalPoll.InternalCreateThread == KeGetCurrentThread())
		{
			IoSkipCurrentIrpStackLocation(pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
		}
		//This is a request from above, capture on the way up
		else
		{
			GCK_IP_AddFileObject(
				pFilterExt,
				pIrpStack->FileObject,
				pIrpStack->Parameters.Create.ShareAccess,
				pIrpStack->Parameters.Create.SecurityContext->DesiredAccess
				);

			GCKF_KickDeviceForData(pFilterExt);

			// Call create synchronously
			KeInitializeEvent(&SyncEvent, SynchronizationEvent,	FALSE);
       		IoCopyCurrentIrpStackLocationToNext(pIrp);
			IoSetCompletionRoutine(
				pIrp,
				GCK_FLTR_CreateComplete,
				(PVOID)&SyncEvent,
				TRUE,
				TRUE,
				TRUE
			);
			IoCallDriver (pFilterExt->pTopOfStack, pIrp);
			KeWaitForSingleObject(&SyncEvent, Executive, KernelMode, FALSE, NULL);
			NtStatus = pIrp->IoStatus.Status;
       		// If create succeeded, we need to remember the FileObject
			GCK_IP_ConfirmFileObject(pFilterExt, pIrpStack->FileObject, (BOOLEAN)(NT_SUCCESS(pIrp->IoStatus.Status) ? TRUE : FALSE) );
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// This was misssing!!!
		}
    }

    //
	//	We are done with this IRP, so decrement the outstanding count
	//	and signal remove if this was the last outstanding IRP
	//
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

    GCK_DBG_EXIT_PRINT(("Exiting GCK_Create(2). Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_CreateComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, IN PVOID pContext)
**
**	@mfunc	Completion Routine for IRP_MJ_CREATE
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_FLTR_CreateComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext
)
{
	PKEVENT pSyncEvent;
	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pSyncEvent = (PKEVENT) pContext;
	KeSetEvent(pSyncEvent, IO_NO_INCREMENT, FALSE);
		
	//Done with this IRP, never need to see it again
	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE for filter device objects - Call generated by Win32 API CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT (("GCK_Close, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
    
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
    
	//
    // Increment IRP count, ASAP, note we couldn't do this until now, as we
    // knew not whether the device extension was really a GCK_FILTER_EXT
	//
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	//cleanup pending IO and our tracking of the FileObject -
	//however not applicable if it is our internal polling open, that is being close
	if(pIrpStack->FileObject != pFilterExt->InternalPoll.pInternalFileObject)
	{
		//Complete pending I\O on FileObject
		if(
			GCK_STATE_STARTED == pFilterExt->eDeviceState ||
			GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState
		)
		{
			//There is no pending I\O if the device is not started yet
			GCKF_CompleteReadRequestsForFileObject(pFilterExt, pIrpStack->FileObject);
		}
		//forget file object
		GCK_IP_RemoveFileObject(pFilterExt, pIrpStack->FileObject);
	}
	//send the Irp along
	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pIrp);

		
	// Decrement outstanding IO and signal if went to zero
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_Close(2). Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Read (IN PDEVICE_OBJECT pDeviceObject,	IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_READ for filter device objects - Generated by Win32 ReadFile
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Read 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Target of IRP
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS            NtStatus;
	LARGE_INTEGER       lgiWaitTime;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PIO_STACK_LOCATION	pPrivateIrpStack;
	PVOID				pvIrpBuffer;
	PFILE_OBJECT		pIrpsFileObject;
	static	int			iEnterCount=0;
	unsigned int i=0;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_Read. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

    //cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
	
	//	Increment IRP count while we handle this one
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
    
	//	If we have been removed, we shouldn't be getting read IRPs
	if(
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING  != pFilterExt->eDeviceState
	)
	{
		GCK_DBG_WARN_PRINT(( "GCK_Read called with delete pending\n"));
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//	Decrement outstanding IRP count, and signal if it want to zero
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	} 
	else 
	{
		//
		//	Send Reqeust to filter, the filterhooks module is responsible
		//	for all the necessary Asynchronous IRP handling steps, we just
		//	return status pending.
		//
		NtStatus = GCKF_IncomingReadRequests(pFilterExt, pIrp);

		//	Poll the lower driver, if one is not yet pending.
		GCK_IP_OneTimePoll(pFilterExt);
	}
	
	GCK_DBG_RT_EXIT_PRINT(("Exiting GCK_Read(2). Status: 0x%0.8x\n", NtStatus)); 
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@mfunc	Handles all IOCTLs for the filter devices - this is just a straight pass through
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
	PGCK_FILTER_EXT		pFilterExt;
	NTSTATUS			NtStatus;

	PAGED_CODE ();
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_Ioctl, pDeviceObject = 0x%0.8x, pIRP = 0x%0.8x\n", pDeviceObject, pIrp));
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

    //
	// If we have been removed we need to refuse this IRP
	//
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
		GCK_DBG_TRACE_PRINT(("GCK_FLTR_Ioctl called while delete pending\n"));
		ASSERT(FALSE);
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else 
	{
	    // Send the IRP on unchanged.
	    IoSkipCurrentIrpStackLocation (pIrp);
        NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
    }

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_Ioctl, Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckshell.c ===
//	@doc
/**********************************************************************
*
*	@module	GckShell.c	|
*
*	Basic driver entry points for GcKernel.sys
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckShell	|
*	Contains the most basic driver entry points (that any NT\WDM driver
*	would have) for GcKernel.sys.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_GCKSHELL_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"
#include "vmmid.h"

#ifdef BUILD_98
extern void* KeyBoardHook(void);
#endif

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, GCK_Create)
#pragma alloc_text (PAGE, GCK_Close)
#pragma alloc_text (PAGE, GCK_Unload)
#endif

//
//	Allow debug output for this moduel, and set the intial level
//
DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//
//	Instance the global variables
//
GCK_GLOBALS Globals;
ULONG	ulWaitTime = 30;

#ifdef BUILD_98

#pragma data_seg("_LDATA", "LCODE")
LONG g_lHookRefCount = 0;
ULONG g_rgdwKeyEvents[50] = { 0 };
ULONG g_pPreviousKeyhook = 0;
UCHAR g_ucWriteIndex = 0;
UCHAR g_ucReadIndex = 0;
#pragma data_seg()

#pragma code_seg("_LTEXT", "LCODE")
#endif BUILD_98

void KeyHookC(ULONG dwScanCode)
{
#ifdef BUILD_98
	g_rgdwKeyEvents[g_ucWriteIndex++] = dwScanCode;
	if (g_ucWriteIndex >= 50)
	{
		g_ucWriteIndex = 0;
	}
#else !BUILD_98
    UNREFERENCED_PARAMETER (dwScanCode);
#endif BUILD_98
}

#ifdef BUILD_98
//-----------------------------------------------------------------------------
// InitHook - Sets up the keyboard hook
//-----------------------------------------------------------------------------
BOOLEAN HookKeyboard(void)
{
	volatile ULONG dwHook = (ULONG)KeyBoardHook;

	RtlZeroMemory((void*)g_rgdwKeyEvents, sizeof(ULONG) * 50);
	g_ucWriteIndex = 0;
	g_ucReadIndex = 0;
//	GetVxDServiceOrdinal eax, VKD_Filter_Keyboard_Input
	__asm mov eax, __VKD_Filter_Keyboard_Input

	__asm mov   esi, dwHook
	VxDCall(__Hook_Device_Service)
	__asm jc initfail
	__asm mov [g_pPreviousKeyhook], esi		// Since we are using C we can't use the funky callback
	return TRUE;
initfail:
	return FALSE;
};
#pragma code_seg()


void UnHookKeyboard()
{
	volatile ULONG dwHook = (ULONG)KeyBoardHook;

	// GetVxDServiceOrdinal eax, VKD_Filter_Keyboard_Input
	__asm mov eax, __VKD_Filter_Keyboard_Input
	__asm mov   esi, dwHook
	VxDCall(__Unhook_Device_Service)
	__asm clc
}
#endif BUILD_98

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Standard DriverEntry routine
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	int i;
                
    UNREFERENCED_PARAMETER (puniRegistryPath);
	
	PAGED_CODE();
	GCK_DBG_CRITICAL_PRINT(("Built %s at %s\n", __DATE__, __TIME__));    
	GCK_DBG_CRITICAL_PRINT(("Entering DriverEntry, pDriverObject = 0x%0.8x, puniRegistryPath = %s\n", pDriverObject, puniRegistryPath));
    
	//	Allow Control Device module to initialize itself
	NtStatus = GCK_CTRL_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow Filter Device module to initialize itself
	NtStatus = GCK_FLTR_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow SideWinder Virtual Bus module to initialize itself
	NtStatus = GCK_SWVB_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow SideWinder Virtual Keyboard module to initialize itself
	NtStatus = GCK_VKBD_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Hook all IRPs so we can pass them on.
	GCK_DBG_TRACE_PRINT(("Filling out entry point structure\n"));
	for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION;	i++)
	{
        pDriverObject->MajorFunction[i] = GCK_Pass;
    }

	// Initialize any shared global data
#ifdef BUILD_98
	g_lHookRefCount = 0;
#endif
	
	//	Define entries for IRPs we expect to handle
	pDriverObject->MajorFunction[IRP_MJ_CREATE]         = GCK_Create;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = GCK_Close;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = GCK_Read;
    pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = 
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = GCK_Ioctl;
    pDriverObject->MajorFunction[IRP_MJ_PNP]            = GCK_PnP;
    pDriverObject->MajorFunction[IRP_MJ_POWER]          = GCK_Power;
    pDriverObject->DriverExtension->AddDevice           = GCK_FLTR_AddDevice;	//only the filter has an add device
    pDriverObject->DriverUnload                         = GCK_Unload;
	
	GCK_DBG_EXIT_PRINT (("Normal exit of DriverEntry: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_Unload(IN PDRIVER_OBJECT pDriverObject )
**
**	@func	Called to unload driver, delete Control Device here
**
*************************************************************************************/
VOID GCK_Unload
(
	IN PDRIVER_OBJECT pDriverObject		// @parm Driver Object for our driver
)
{
    PAGED_CODE ();

    GCK_DBG_ENTRY_PRINT(("Entering GCK_Unload, pDriverObject = 0x%0.8x\n", pDriverObject));
	
	UNREFERENCED_PARAMETER(pDriverObject);

	GCK_SWVB_UnLoad();

	//
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
	ASSERT (NULL == pDriverObject->DeviceObject);
	ASSERT (NULL == Globals.pControlObject);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_Unload\n"));
	return;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE - Generated by Win32 CreateFile or OpenFile
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for context of IRP
	IN PIRP pIrp						// @parm pointer to IRP
)
{
    
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT (("GCK_Create, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	KdPrint(("GCK_Create, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				KdPrint((" -- GCK_DO_TYPE_CONTROL\n"));
				NtStatus = GCK_CTRL_Create(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_FILTER:
				KdPrint((" -- GCK_DO_TYPE_FILTER\n"));
				NtStatus = GCK_FLTR_Create(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				KdPrint((" -- GCK_DO_TYPE_SWVB\n"));
				NtStatus = GCK_SWVB_Create(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Create. Status: 0x%0.8x\n", NtStatus));
    KdPrint(("Exiting GCK_Create. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE - Generated by Win32 CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer DeviceObject for context
	IN PIRP pIrp						// @parm pointer to IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT (("GCK_Close, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
    
	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = GCK_CTRL_Close(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Close(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Close(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_Close. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Read (IN PDEVICE_OBJECT pDeviceObject,	IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_READ - Generated by Win32 ReadFile
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Read 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_Read. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get read on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Read(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Read(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Read. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_Power. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get power on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Power(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Power(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Power. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_PnP (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PnP
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_PnP. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get PnP on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				pIrp->IoStatus.Status = NtStatus;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_PnP(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_PnP(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_PnP. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_IOCTL and IRP_MJ_INTERNAL_IOCTL
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
   	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
	ULONG		uIoctl;

	PIO_STACK_LOCATION	pIrpStack;

		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_Ioctl. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
	uIoctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	if (uIoctl == IOCTL_GCK_ENABLE_KEYHOOK)
	{	// Special case IOCTL, device independant
#ifdef BUILD_WIN2K
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		if (InterlockedIncrement(&g_lHookRefCount) == 1)
		{	// Not already hooked
			HookKeyboard();
		}
		pIrp->IoStatus.Status = STATUS_SUCCESS;
#endif BUILD_WIN2K
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	if (uIoctl == IOCTL_GCK_DISABLE_KEYHOOK)
	{	// Special case also device independant
#ifdef BUILD_WIN2K
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		if (InterlockedDecrement(&g_lHookRefCount) < 1)
		{	// Last hooker is going away
			UnHookKeyboard();
			g_lHookRefCount = 0;
		}
		pIrp->IoStatus.Status = STATUS_SUCCESS;
#endif BUILD_WIN2K
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	if (uIoctl == IOCTL_GCK_GET_KEYHOOK_DATA)
	{
#ifdef BUILD_WIN2K
		NtStatus = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		ULONG uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		if (uOutLength < sizeof(ULONG))
		{
			NtStatus = STATUS_BUFFER_TOO_SMALL;
		}
		else
		{
			ULONG* pulIoBuffer = (ULONG*)(pIrp->AssociatedIrp.SystemBuffer);
			*pulIoBuffer = 0;
			pIrp->IoStatus.Information = sizeof(ULONG);
			NtStatus = STATUS_SUCCESS;

			if (g_lHookRefCount > 0)
			{	// There is a hook
				if (g_ucWriteIndex != g_ucReadIndex)
				{	// We have data in the Queue
					*pulIoBuffer = g_rgdwKeyEvents[g_ucReadIndex++];
					if (g_ucReadIndex >= 50)
					{
						g_ucReadIndex = 0;
					}
				}
			}
		}
#endif BUILD_WIN2K
		pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return NtStatus;
	}

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = GCK_CTRL_Ioctl(pDeviceObject, pIrp);	
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Ioctl(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Ioctl(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Ioctl. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Pass (  IN PDEVICE_OBJECT pDeviceObject,  IN PIRP pIrp )
**
**	@func	Passes on unhandled IRPs to lower drivers DEBUG version trace out info
**			Cannot be pageable since we have no idea what IRPs we're getting.
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS GCK_Pass ( 
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp	// @parm IRP to pass on
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
	PGCK_FILTER_EXT pFilterExt;

	//	Debug version want IRP stack for traceouts.
	#if	(DBG==1)	
	PIO_STACK_LOCATION	pIrpStack;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	#endif

	GCK_DBG_ENTRY_PRINT(("Entering GCK_Pass. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	GCK_DBG_TRACE_PRINT(
		(
			"GCK_Pass called with Irp MajorFunction = 0x%0.8x, MinorFunction = 0x%0.8x\n",
			pIrpStack->MajorFunction, pIrpStack->MinorFunction)
		);
	
	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_FILTER:
				GCK_DBG_TRACE_PRINT(( "Passing IRP to lower driver\n"));
				pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
		case	GCK_DO_TYPE_CONTROL:
		case	GCK_DO_TYPE_SWVB:
				//	No one to pass to, so return default status
				NtStatus = pIrp->IoStatus.Status;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
				pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	};

	//return
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Pass. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\fltr_pnp.cpp ===
//	@doc
/**********************************************************************
*
*	@module	FLTR_PNP.C	|
*
*	Implementation of PnP and Power IRP handlers for Filter Device
*	Objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	PNP	|
*	Power, Start, Stop, Remove Handlers.  Shell like functionality
*	only.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FLTR_PNP_C
extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );
	DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL) );
}
#include "SWVBENUM.h"




//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, GCK_FLTR_Power)
#pragma alloc_text (PAGE, GCK_FLTR_AddDevice)
#pragma alloc_text (PAGE, GCK_FLTR_PnP)
#pragma alloc_text (PAGE, GCK_FLTR_StartDevice)
#pragma alloc_text (PAGE, GCK_FLTR_StopDevice)
#pragma alloc_text (PAGE, GCK_GetHidInformation)
#pragma alloc_text (PAGE, GCK_CleanHidInformation)
#endif

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER for Filter Device Objects
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_Power. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension;
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

    // If we have been removed we need to refuse this IRP
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
        
		GCK_DBG_TRACE_PRINT(("GCK_Power called while delete pending\n"));
				
		//Fill in IO_STATUS_BLOCK with failure
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		
		// Tell system that we are ready for another power IRP
		PoStartNextPowerIrp(pIrp);

		//Complete IRP with failure
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else //Pass it down to next driver
	{
       
		GCK_DBG_TRACE_PRINT(("Sending Power IRP down to next driver\n"));
		
		//	Tell system we are ready for the next power IRP
        PoStartNextPowerIrp (pIrp);
		        
        // NOTE!!! PoCallDriver NOT IoCallDriver.
		IoSkipCurrentIrpStackLocation (pIrp);
        NtStatus =  PoCallDriver (pFilterExt->pTopOfStack, pIrp);
    }

	//	Decrement outstanding IRP count, and signal if it want to zero
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_Power. Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPhysicalDeviceObject)
**
**	@func	Handles AddDevice calls from PnP system, create filter device and
**			attach to top of stack.  Note this is a direct entry, as control, and SWVB
**			have not this function and it is a good thing too, as we would have little
**			idea of what to Add.
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_AddDevice
(
	IN PDRIVER_OBJECT pDriverObject,			// @parm Driver object to create filter device for
	IN PDEVICE_OBJECT pPhysicalDeviceObject		// @parm PDO for device to create
)
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          pDeviceObject = NULL;
	PGCK_FILTER_EXT			pFilterExt = NULL;
    
    PAGED_CODE ();
    GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_AddDevice, pDriverObject = 0x%0.8x, pPDO = 0x%0.8x\n", pDriverObject, pPhysicalDeviceObject));

	//
	//	If there is not a Global Control Device create one
	//	(The global control object is for programming the filter.  When the
	//	first filter device is created, we create one.  When the last filter
	//	device is removed, we remove it.)
	//
	if(!Globals.pControlObject)
	{
		GCK_CTRL_AddDevice( pDriverObject );
	}

	    
	//
    // Create a filter device object.
    //
	GCK_DBG_TRACE_PRINT(("Creating Filter Device\n"));
    NtStatus = IoCreateDevice (pDriverObject,
                             sizeof (GCK_FILTER_EXT),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &pDeviceObject);

    if (!NT_SUCCESS (NtStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
		GCK_DBG_CRITICAL_PRINT(("Failed to create filter device object\n"));
		GCK_DBG_EXIT_PRINT(("Exiting AddDevice(1) Status: 0x%0.8x\n", NtStatus));
        return NtStatus;
    }

    //
    // Initialize the the device extension.
    //
	GCK_DBG_TRACE_PRINT(("Initializing Filter's Device Extension\n"));
	pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension; //Get pointer to extension
	pFilterExt->ulGckDevObjType = GCK_DO_TYPE_FILTER;	//Put our name on this, so we can speak for it later
	pFilterExt->eDeviceState = GCK_STATE_STOPPED;	//Device starts out stopped
	pFilterExt->pPDO	 = pPhysicalDeviceObject;	//Remember our PDO
	pFilterExt->pTopOfStack = NULL;					//We are not attached to stack yet
	GCK_InitRemoveLock(&pFilterExt->RemoveLock, "Filter PnP");	//Initialize Remove Lock
	pFilterExt->pvForceIoctlQueue = NULL;	// There is no Queue unless force requests come in
	pFilterExt->pvTriggerIoctlQueue = NULL;	// There is no Queue unless trigger requests come in

	// !!!!!! Need to clean up the above Queues

	//we use the same IO method as hidclass.sys, which DO_DIRECT_IO
	pDeviceObject->StackSize = pPhysicalDeviceObject->StackSize + 1;
	pDeviceObject->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    GCK_DBG_TRACE_PRINT(("FDO flags set to %x\n", pDeviceObject->Flags));
    

    //
	// Add new Device Object to List of Objects
	//
	GCK_DBG_TRACE_PRINT(("Adding new filter device object to global linked list\n"));
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	//Add item to head as it is fastest place to add
	pFilterExt->pNextFilterObject=Globals.pFilterObjectList;
	Globals.pFilterObjectList = pDeviceObject;	//Add the whole object not just the extension
	Globals.ulFilteredDeviceCount++;			//Increment count of filtered devices
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);

	//
	//	Make sure the internal POLL is ready for open and close
	//
	GCK_IP_AddDevice(pFilterExt);

	//
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
	GCK_DBG_TRACE_PRINT(("Attaching to top of device stack\n"));
    pFilterExt->pTopOfStack = IoAttachDeviceToDeviceStack (pDeviceObject, pPhysicalDeviceObject);
    
	//
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != pFilterExt->pTopOfStack);
	GCK_DBG_TRACE_PRINT(( "pTopOfStack = 0x%0.8x", pFilterExt->pTopOfStack ));

	//
	//	Assure that the Virtual Bus has a Device Object to sit on.
	//	To fix bug 1018, which would also have other implications, this is moved to start device
	//	to start device
	//
	//if( !Globals.pSWVB_FilterExt )
	//{
	//	Globals.pSWVB_FilterExt = pFilterExt;
	//	NtStatus = GCK_SWVB_SetBusDOs(pDeviceObject, pPhysicalDeviceObject);
	//	//At this point GCK_SWVB_SetBusDOs only returns STATUS_SUCCESS, it should return void
	//	ASSERT( STATUS_SUCCESS == NtStatus); 
	//}

	GCK_DBG_EXIT_PRINT(("Exiting AddDevice(2) Status: STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PNP for Filter Devices, dispatchs
**			IRPs for Control Devices or Virtual Devices elsewhere.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		*ppPrevDeviceObjectPtr;
	PDEVICE_OBJECT		pCurDeviceObject;
	//PGCK_FILTER_EXT		pCurFilterExt;
	BOOLEAN				fRemovedFromList;
	BOOLEAN				fFoundOne;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_PnP. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));	
	
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	// Just an extra sanity check - before accessing extension
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);

	//Increment Remove Lock while handling this IRP
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

    //
	// If we have been removed we need to refuse this IRP, this should
	// never happen with PnP IRPs
	//
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
		GCK_DBG_TRACE_PRINT(("GCK_FLTR_PnP called while delete pending\n"));
		ASSERT(FALSE);
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else // we need to handle it
	{
		
		switch (pIrpStack->MinorFunction) {

			case IRP_MN_CANCEL_STOP_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_STOP_DEVICE - Fall through to IRP_MN_START_DEVICE\n"));
				ASSERT(GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState);
				pFilterExt->eDeviceState = GCK_STATE_STARTED;
			case IRP_MN_CANCEL_REMOVE_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_REMOVE_DEVICE - Fall through to IRP_MN_START_DEVICE\n"));
			case IRP_MN_START_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_START_DEVICE\n"));
				
				// The device is starting. Lower level drivers need to start first
				IoCopyCurrentIrpStackLocationToNext (pIrp);
				KeInitializeEvent(&pFilterExt->StartEvent, NotificationEvent, FALSE);
				
				//	Set Completion routine to signal when done
				IoSetCompletionRoutine (
					pIrp,
					GCK_FLTR_PnPComplete,
					pFilterExt,
					TRUE,
					TRUE,
					TRUE
					);

				//	Send down the IRP
				GCK_DBG_TRACE_PRINT(("Calling lower driver\n"));        
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

				//	Wait for it to complete
				if (STATUS_PENDING == NtStatus)
				{
					KeWaitForSingleObject(
						&pFilterExt->StartEvent,	// waiting for Completion of Start
						Executive,					// Waiting for reason of a driver
						KernelMode,					// Waiting in kernel mode
						FALSE,						// No alert
						NULL						// No timeout
						);
				}

				// Remember the status of the lower driver
				NtStatus = pIrp->IoStatus.Status;

				//In the case of a cancel stop, the lower driver may not support it.
				//we still need to restart
				if(NT_SUCCESS (NtStatus) || STATUS_NOT_SUPPORTED==NtStatus)
				{
					//
					// As we are successfully now back from lower driver
					// our start device can do work.
					//
					NtStatus = GCK_FLTR_StartDevice (pDeviceObject, pIrp);
				}

		        //
				// We must now complete the IRP, since we stopped it in the
				// completetion routine with MORE_PROCESSING_REQUIRED.
				//
				if (!NT_SUCCESS (NtStatus))
				{
					if (pIrpStack->MinorFunction == IRP_MN_CANCEL_REMOVE_DEVICE)
					{
						NtStatus = STATUS_SUCCESS;		// Not allow to fail this!
					}
				}
				pIrp->IoStatus.Status = NtStatus;
				pIrp->IoStatus.Information = 0;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
			case IRP_MN_QUERY_STOP_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_STOP_DEVICE\n"));
				ASSERT( GCK_STATE_STARTED == pFilterExt->eDeviceState);
				pFilterExt->eDeviceState = GCK_STATE_STOP_PENDING;
				//Close Handle to driver beneath
				NtStatus = GCK_IP_CloseFileObject(pFilterExt);
                if( NT_SUCCESS (NtStatus) )
                {
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
				    IoSkipCurrentIrpStackLocation (pIrp);
				    NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
                }
                else
                {
                    pIrp->IoStatus.Status = NtStatus;
				    pIrp->IoStatus.Information = 0;
				    IoCompleteRequest (pIrp, IO_NO_INCREMENT);
                }
				break;
			case IRP_MN_QUERY_REMOVE_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_REMOVE_DEVICE - Fall through to IRP_MN_STOP_DEVICE\n"));
			case IRP_MN_SURPRISE_REMOVAL:
				GCK_DBG_TRACE_PRINT(("IRP_MN_SURPRISE_REMOVAL - Fall through to IRP_MN_STOP_DEVICE\n"));
			case IRP_MN_STOP_DEVICE:
				
				GCK_DBG_TRACE_PRINT(("IRP_MN_STOP_DEVICE\n"));
				
				//	Do whatever processing is required
				GCK_FLTR_StopDevice (pFilterExt, TRUE);

				// We don't need a completion routine so fire and forget.
				GCK_DBG_TRACE_PRINT(("Calling lower driver\n"));
                pIrp->IoStatus.Status = STATUS_SUCCESS;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
			
			case IRP_MN_REMOVE_DEVICE:

				GCK_DBG_TRACE_PRINT(("IRP_MN_REMOVE_DEVICE\n"));
				//@todo All the code in this case, should be moved to a separate function
				// Note! we might receive a remove WITHOUT first receiving a stop.
				if(
					GCK_STATE_STARTED == pFilterExt->eDeviceState ||
					GCK_STATE_STOP_PENDING  == pFilterExt->eDeviceState
				)
				{
					// Stop the device without touching the hardware.
					GCK_FLTR_StopDevice(pFilterExt, FALSE);
				}

				//
				// We will no longer receive requests for this device as it has been
				// removed.  (Note some code below, depends on this flag being updated.)
				//
				pFilterExt->eDeviceState = GCK_STATE_REMOVED;

				// Send on the remove IRP
                // Set the Status before sending the IRP onwards
                pIrp->IoStatus.Status = STATUS_SUCCESS;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

				// Undo our increment upon entry to this routine
				GCK_DecRemoveLock(&pFilterExt->RemoveLock);
				
				// Undo the bias  Wait for count to go to zero, forever.
				GCK_DecRemoveLockAndWait(&pFilterExt->RemoveLock, NULL);

				//
				// Now that we are sure that outstanding IRPs are done,
				// we remove ourselves from the drivers global list of devices
				//
				GCK_DBG_TRACE_PRINT(("Removing from global linked list.\n"));
				
				//	Acquire mutext to touch global list
				ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
				
				//	Remove device from linked list of device that we handle
				ppPrevDeviceObjectPtr = &Globals.pFilterObjectList;
				pCurDeviceObject = Globals.pFilterObjectList;
				fRemovedFromList = FALSE;
				while( pCurDeviceObject )
				{
					if( pCurDeviceObject == pDeviceObject )
					{
						// Remove us from list
						*ppPrevDeviceObjectPtr = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
						fRemovedFromList = TRUE;
						break;
					}
					else
					{
						//skip to the next object
						ppPrevDeviceObjectPtr = PTR_NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
						pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
					}
				}
				ASSERT(fRemovedFromList);
				if(fRemovedFromList)
				{
					Globals.ulFilteredDeviceCount--;	//Decrement count of filtered devices
				}
				
				//Set fFoundOne TRUE if there are any device left
				fFoundOne = Globals.ulFilteredDeviceCount ? TRUE : FALSE;
				
				//	Release mutex to touch global list
				ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
				
				//If there are no more devices left, cleanup Global Control Device
				//Verify that Virtual Bus has deleted any straggling Device Objects
				if(!fFoundOne)
				{
					GCK_CTRL_Remove();
				}

				GCK_DBG_TRACE_PRINT(("Detaching and Deleting DeviceObject.\n"));
				IoDetachDevice (pFilterExt->pTopOfStack);	//Detach from top of stack
				IoDeleteDevice (pDeviceObject);				//Delete ourselves

				// Must succeed this 
				GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnP(1) with status 0x%08x\n", NtStatus));
                ASSERT( NT_SUCCESS( NtStatus ) );
				return NtStatus;
			case IRP_MN_QUERY_DEVICE_RELATIONS:
				
				//
				//	We may be the platform for the virtual bus, if we are
				//	we need to call GCK_SWVB_BusRelations
				//
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_DEVICE_RELATIONS\n"));
				if(
					(BusRelations == pIrpStack->Parameters.QueryDeviceRelations.Type) &&
					(pFilterExt == Globals.pSWVB_FilterExt)
				)
				{
						NtStatus = GCK_SWVB_HandleBusRelations(&pIrp->IoStatus);
				
						//	If an error occured, stop it here and send it back;
						if( NT_ERROR(NtStatus) )
						{
							GCK_DBG_CRITICAL_PRINT(("GCK_SWVB_BusRelations returned 0x%0.8x, completing the IRP\n", NtStatus));
							IoCompleteRequest (pIrp, IO_NO_INCREMENT);
							break;
						}

				}
				//	Pass it along
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
			
			case IRP_MN_QUERY_INTERFACE:
			case IRP_MN_QUERY_CAPABILITIES:
			case IRP_MN_QUERY_RESOURCES:
			case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
			case IRP_MN_READ_CONFIG:
			case IRP_MN_WRITE_CONFIG:
			case IRP_MN_EJECT:
			case IRP_MN_SET_LOCK:
			case IRP_MN_QUERY_ID:
			case IRP_MN_QUERY_PNP_DEVICE_STATE:
			default:
				// All of these just pass on
				GCK_DBG_TRACE_PRINT(("Irp Minor Code 0x%0.8x: Calling lower driver.\n", pIrpStack->MinorFunction));
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
		}
	}
	
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnP(2) with Status, 0x%0.8x\n", NtStatus));        
    return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_PnPComplete (IN PDEVICE_OBJECT pDeviceObject,  IN PIRP pIrp, IN PVOID pContext)
**
**	@func	Completion for IRP_MJ_PNP\IR_MN_START_DEVICE for Filter Devices
**			Used mainly for start device.  Since it may be called at IRQL = LEVEL_DISPATCH
**			cannot be pageable!
**	@rdesc	STATUS_MORE_PROCESSING_REQUIRED
**
*************************************************************************************/
NTSTATUS GCK_FLTR_PnPComplete 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DeviceObject as our context
	IN PIRP pIrp,						// @parm IRP to complete
	IN PVOID pContext					// @parm Not used
)
{
    
    PGCK_FILTER_EXT		pFilterExt;
    NTSTATUS			NtStatus = STATUS_SUCCESS;

	//
	//	Current stack location is needed for DEBUG assertion only
	//
	#if (DBG==1)
	PIO_STACK_LOCATION	pIrpStack;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	#endif

	GCK_DBG_ENTRY_PRINT((
		"Entering GCK_FLTR_PnPComplete. pDO = 0x%0.8x, pIrp = 0x%0.8x, pContext = 0x%0.8x\n",
		pDeviceObject,
		pIrp,
		pContext
		));	

    UNREFERENCED_PARAMETER (pDeviceObject);

	if (pIrp->PendingReturned)
	{
        IoMarkIrpPending( pIrp );
    }

	
    pFilterExt = (PGCK_FILTER_EXT) pContext;
	KeSetEvent (&pFilterExt->StartEvent, 0, FALSE);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnPComplete with STATUS_MORE_PROCESSING_REQUIRED\n"));
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_StartDevice (IN PGCK_FILTER_EXT pFilterExt,  IN PIRP pIrp)
**
**	@func	On IRP_MN_START_DEVICE attaches filter module, creates
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_StartDevice 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to device object
	IN PIRP pIrp	// @parm IRP to handle
)
{
    NTSTATUS NtStatus;
	LARGE_INTEGER	lgiBufferOffset;
	UNREFERENCED_PARAMETER (pIrp);

	PAGED_CODE ();

	PGCK_FILTER_EXT		pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	GCK_DBG_ENTRY_PRINT((
		"Entering GCK_StartDevice. pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n",
		pFilterExt,
		pIrp
		));	

	//
	//	We shouldn't get a start on a removed device
	//
	ASSERT(GCK_STATE_REMOVED != pFilterExt->eDeviceState);
    
	//
	//	We shouldn't try to start a device that is already started
	//
    if (
		 GCK_STATE_STARTED == pFilterExt->eDeviceState || 
		 GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState
	)
	{
		GCK_DBG_WARN_PRINT(( "Two IRP_MN_START_DEVICE recieved.\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StartDevice(1) with STATUS_SUCCESS\n"));
        return STATUS_SUCCESS;
    }

	//
	//	Put the virtual bus on top of us if it is not already
	//
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	if( !Globals.pSWVB_FilterExt )
	{
		Globals.pSWVB_FilterExt = pFilterExt;
		NtStatus = GCK_SWVB_SetBusDOs(pDeviceObject, pFilterExt->pPDO);
		ASSERT( STATUS_SUCCESS == NtStatus); 
	}
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);

	//
	//	Collect basic info about the device
	//
	NtStatus = GCK_GetHidInformation(pFilterExt);

	//
	//	Initialize filter hooks
	//
	if( NT_SUCCESS(NtStatus) )
	{	// We can't initialize if we don't have hid info (vidpid!)
		GCKF_InitFilterHooks(pFilterExt);
	}
	
	//	Allocate a Buffer for last known poll of the device
	if( NT_SUCCESS(NtStatus) )
	{
			pFilterExt->pucLastReport = (PUCHAR)	EX_ALLOCATE_POOL
													( NonPagedPool,
													pFilterExt->HidInfo.HidPCaps.InputReportByteLength );
			if(!pFilterExt->pucLastReport)
			{
				GCK_DBG_CRITICAL_PRINT(("Failed to allocate Report Buffer for last known report\n"));
				NtStatus = STATUS_INSUFFICIENT_RESOURCES;
			}
	}

	// Initialize last known status for very first IRP
	if( NT_SUCCESS(NtStatus) )
	{
		pFilterExt->ioLastReportStatus.Information = (ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;
		pFilterExt->ioLastReportStatus.Status =  STATUS_SUCCESS;
	}
	
	if ( NT_SUCCESS(NtStatus) )
	{	
		//Initialize InternalPoll module
		NtStatus = GCK_IP_Init(pFilterExt);
	}
	
	//	Mark device as Started
	if ( NT_SUCCESS(NtStatus) )
	{
		//mark for full time polling, but understand
		//that it won't start yet.
		GCK_IP_FullTimePoll(pFilterExt, TRUE);
		pFilterExt->eDeviceState = GCK_STATE_STARTED;

        //  Set device specific initial mapping in case 
        //  the value add is not running
        GCKF_SetInitialMapping( pFilterExt );
	}
	else //	we failed somewhere, clean up to mark as started
	{
		GCK_DBG_TRACE_PRINT(("Cleaning up in event of failure\n"));
	
		//Cleanup internal polling module
		GCK_IP_Cleanup(pFilterExt);

		//	No need to check if buffer was created, if it was we succeeded
		if(pFilterExt->pucLastReport)
		{
			ExFreePool(pFilterExt->pucLastReport);
			pFilterExt->pucLastReport = NULL;
		}
	
		//	Call CleanHidInformation to free anything allocated
		//	and zero it out
		GCK_CleanHidInformation( pFilterExt );
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StartDevice(2) with Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_StopDevice (IN PGCK_FILTER_EXT	pFilterExt, IN BOOLEAN	fTouchTheHardware)
**
**	@func	Cancel outstanding IRPs and frees private Ping-Pong IRP
**
*************************************************************************************/
VOID GCK_FLTR_StopDevice 
(
	IN PGCK_FILTER_EXT	pFilterExt,	// @parm Device Extension
	IN BOOLEAN	fTouchTheHardware	// @parm TRUE if hardware can be touched
									//	- unused we never touch hardware
)
{
	BOOLEAN fCanceled;

	UNREFERENCED_PARAMETER(fTouchTheHardware);
	
	
	GCK_DBG_ENTRY_PRINT(("Entry GCK_FLTR_StopDevice, pFilterExt = 0x%0.8x\n", pFilterExt));
	
	PAGED_CODE ();
	
	ASSERT(GCK_STATE_STOPPED != pFilterExt->eDeviceState);
	if(GCK_STATE_STOPPED == pFilterExt->eDeviceState) return;

	//stop internal polling
	GCK_IP_FullTimePoll(pFilterExt, FALSE);

	//	Mark device as stopped
	pFilterExt->eDeviceState = GCK_STATE_STOPPED;

	//Cleanup internal polling module
	GCK_IP_Cleanup(pFilterExt);


		if (pFilterExt->pFilterHooks!=NULL) GCKF_DestroyFilterHooks(pFilterExt);

	//Acquire mutex to access list of filter objects
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	if( Globals.pSWVB_FilterExt == pFilterExt)
	{
		
		
		//Walk linked list of Filter Device Objects, looking for one that is not stopped
		BOOLEAN fFoundOne = FALSE;
		PDEVICE_OBJECT pCurDeviceObject = Globals.pFilterObjectList;
		PGCK_FILTER_EXT pCurFilterExt;
		NTSTATUS NtStatus;
		while( pCurDeviceObject )
		{
			pCurFilterExt = (PGCK_FILTER_EXT)pCurDeviceObject->DeviceExtension;
			if( 
				GCK_STATE_STARTED == pCurFilterExt->eDeviceState ||
				GCK_STATE_STOP_PENDING == pCurFilterExt->eDeviceState
			)
			{
				NtStatus = GCK_SWVB_SetBusDOs(pCurDeviceObject, pCurFilterExt->pPDO);
				ASSERT( NT_SUCCESS(NtStatus) );
				if( NT_SUCCESS(NtStatus) )
				{
					fFoundOne = TRUE;
					Globals.pSWVB_FilterExt = pCurFilterExt;
					break;
				}
			}
			//skip to the next object
			pCurDeviceObject = pCurFilterExt->pNextFilterObject;
		}
		if( !fFoundOne )
		{
			//Didn't find a place to hang the bus so move it nowhere
			NtStatus = GCK_SWVB_SetBusDOs(NULL, NULL);
			ASSERT( NT_SUCCESS(NtStatus) );
			Globals.pSWVB_FilterExt = NULL;	
		}
	}
	//Release mutex to access list of filter objects
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);


	//
	//	Free any structures relating to device (if needed)
	//	
	if(pFilterExt->pucLastReport)
	{
		ExFreePool(pFilterExt->pucLastReport);
		pFilterExt->pucLastReport = NULL;
	}
	GCK_CleanHidInformation( pFilterExt );
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StopDevice\n"));
}


/***********************************************************************************
**
**	NTSTATUS GCK_GetHidInformation(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	Does IOCTL_HID_GET_COLLECTION_INFORMATION to fill in
**			GCK_HID_DEVICE_INFO in DeviceExtension
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_GetHidInformation
(
	IN PGCK_FILTER_EXT	pFilterExt	// @parm Device Extension for filter
)
{

    NTSTATUS            NtStatus = STATUS_SUCCESS;
    KEVENT              HidCompletionEvent;
    PIRP				pHidIrp;
	IO_STATUS_BLOCK		ioStatus;

    PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT(( "Entering GCK_GetHidInformation. pFilterExt = 0x%0.8x\n",	pFilterExt));	

        
	//
    // Initialize Event for synchronous call to device
    //
    KeInitializeEvent(&HidCompletionEvent, NotificationEvent, FALSE);

    //**
    //**	IOCTL_HID_GET_COLLECTION_INFORMATION
    //**

	//
	//	Setup IRP
	//
    pHidIrp = 
		IoBuildDeviceIoControlRequest(
			IOCTL_HID_GET_COLLECTION_INFORMATION,
			pFilterExt->pTopOfStack,
			NULL,
			0,
			&pFilterExt->HidInfo.HidCollectionInfo,
			sizeof (HID_COLLECTION_INFORMATION),
			FALSE, /* EXTERNAL */
			&HidCompletionEvent,
			&ioStatus
			);
	if( NULL == pHidIrp)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_INFORMATION\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(1) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Call Driver
	//
    NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pHidIrp);
	GCK_DBG_TRACE_PRINT(("IoCallDriver returned 0x%0.8x\n", NtStatus));
    
	//
	// Wait for IRP to complete
	//
	if (STATUS_PENDING == NtStatus)
	{
		GCK_DBG_TRACE_PRINT(("Waiting for IOCTL_HID_GET_COLLECTION_INFORMATION to complete\n"));
		NtStatus = KeWaitForSingleObject(
                       &HidCompletionEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL
					   );
	}
	if( NT_ERROR( NtStatus) )
	{
		GCK_DBG_CRITICAL_PRINT(("Failed IRP for IOCTL_HID_GET_COLLECTION_INFORMATION\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(2) returning 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	//**
	//**	Get HID_PREPARSED_DATA
	//**
	
	//
	//	Allocate space for HIDP_PREPARSED_DATA, and zero memory
	//
	pFilterExt->HidInfo.pHIDPPreparsedData =
		(PHIDP_PREPARSED_DATA) 
		EX_ALLOCATE_POOL(
				NonPagedPool,
				pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize
				);
	if( !pFilterExt->HidInfo.pHIDPPreparsedData )
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(3) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlZeroMemory(
		pFilterExt->HidInfo.pHIDPPreparsedData,
		pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize
		);

	//
	//	Clear Synchronization Event
	//
	KeClearEvent(&HidCompletionEvent);

	//
	//	Setup IRP
	//
	pHidIrp = 
		IoBuildDeviceIoControlRequest(
			IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
			pFilterExt->pTopOfStack,
			NULL,
			0,
			pFilterExt->HidInfo.pHIDPPreparsedData,
			pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize,
			FALSE, /* EXTERNAL */
			&HidCompletionEvent,
			&ioStatus
			);
	if( NULL == pHidIrp)
	{
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(4) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	
    // Call Driver
	NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pHidIrp);
	GCK_DBG_TRACE_PRINT(("IoCallDriver returned 0x%0.8x\n", NtStatus));
    
	//
	// Wait for IRP to complete
	//
	if (STATUS_PENDING == NtStatus)
	{
		GCK_DBG_TRACE_PRINT(("Waiting for IOCTL_HID_GET_COLLECTION_DESCRIPTOR to complete\n"));
		NtStatus = KeWaitForSingleObject(
                       &HidCompletionEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL
					   );
	}

	if( NT_ERROR( NtStatus) )
	{
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
		GCK_DBG_CRITICAL_PRINT(("Failed IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(5) returning 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	
	//**
	//**	Get HIDP_CAPS structure
	//**

	NtStatus = HidP_GetCaps(pFilterExt->HidInfo.pHIDPPreparsedData, &pFilterExt->HidInfo.HidPCaps); 
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(6). Status = 0x%0.8x\n",	NtStatus));	
    return NtStatus;
}
		
/***********************************************************************************
**
**	VOID GCK_CleanHidInformation( IN PGCK_FILTER_EXT	pFilterExt)
**
**	@func Cleans up GCK_HID_INFORMATION in device extension
**
*************************************************************************************/
VOID GCK_CleanHidInformation(
	IN PGCK_FILTER_EXT	pFilterExt	// @parm Device Extension
)
{
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CleanHidInformation\n"));	

	//
	//	Free preparsed data, if necessary
	//
	if(pFilterExt->HidInfo.pHIDPPreparsedData)
	{
		GCK_DBG_TRACE_PRINT(("Freeing pHIDPPreparsedData\n"));	
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
	}

	//
	//	Zero out all of the Hid Info
	//
	RtlZeroMemory(
		(PVOID)&pFilterExt->HidInfo,
		sizeof(GCK_HID_DEVICE_INFO)
	);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_CleanHidInformation\n"));
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckshell.h ===
#ifndef __GckShell_h__
#define __GckShell_h__
//	@doc
/**********************************************************************
*
*	@module	GckShell.h	|
*
*	Header file for GcKernel.sys WDM shell structure
*
*	History
*	----------------------------------------------------------------------
*	Mitchell S. Dernis	Original (Adopted from Hid2Gdp by Michael Hooning)
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckShell	|
*	Declaration of all structures, and functions in GcKernel that make up
*	the shell of the driver.  This excludes the Filter Module (and in the future)
*	any mixer modules.
**********************************************************************/

#include "GckExtrn.h"	//	Pull in any stuff that also needs to be available externally.
#include "RemLock.h"	//	Pull in header for RemoveLock utility functions

//	We use some structures from hidclass.h
#include <hidclass.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <hidusage.h>

//	A little more rigorous than our normal build
#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

//-----------------------------------------------------------------------------
//	The below constants distinguish between the three types of Device Objects
//	used throughout GcKernel. 0xABCD in the high word is used as a signature 
//	in DEBUG builds just to verify that the type was initialized.
//-----------------------------------------------------------------------------
#define GCK_DO_TYPE_CONTROL	0xABCD0001
#define GCK_DO_TYPE_FILTER	0xABCD0002
#define GCK_DO_TYPE_SWVB	0xABCD0003

//------------------------------------------------------------------------------
// Enumeration to keep track of device state, rather than fStarted and fRemoved
// flags
//------------------------------------------------------------------------------
typedef enum _tagGCK_DEVICE_STATE
{
	GCK_STATE_STARTED=0,
	//GCK_STATE_SURPRISE_REMOVED, //Currently not used, same as GCK_STATE_STOPPED
	GCK_STATE_STOP_PENDING,
	GCK_STATE_STOPPED,
	//GCK_STATE_REMOVE_PENDING,	//Currently not used, same as GCK_STATE_STOPPED
	GCK_STATE_REMOVED
} GCK_DEVICE_STATE;

//------------------------------------------------------------------------------
// Microsoft's vendor ID is fixed for all products.  The following constant
// is defined for use in GcKernel
//------------------------------------------------------------------------------
#define MICROSOFT_VENDOR_ID 0x045E
//------------------------------------------------------------------------------
// Declaration of Various structures
//------------------------------------------------------------------------------

//
//	@struct GCK_CONTROL_EXT	| Device Extension for our control device
//
typedef struct _tagGCK_CONTROL_EXT
{
	ULONG	ulGckDevObjType;	// @field Type of GcKernel device object.
    LONG	lOutstandingIO;		// @field 1 biased count of reasons why we shouldn't unload
} GCK_CONTROL_EXT, *PGCK_CONTROL_EXT;

//
//	@struct GCK_HID_Device_INFO | sub-structure that holds HID info about device
//
typedef struct _tagGCK_HID_DEVICE_INFO
{
	HID_COLLECTION_INFORMATION	HidCollectionInfo;	// @field HID_COLLECTION_INFO reported by device
	PHIDP_PREPARSED_DATA		pHIDPPreparsedData;	// @field pointer to HID_PREPARSED_DATA reported by device
	HIDP_CAPS					HidPCaps;			// @field HID_CAPS structure for device
} GCK_HID_DEVICE_INFO, *PGCK_HID_DEVICE_INFO;

//
//	@struct GCK_FILE_OPEN_ITEM | Status of open file handles.
//
typedef struct tagGCK_FILE_OPEN_ITEM
{
	BOOLEAN				fReadPending;					// @field TRUE if read is pending to driver
	BOOLEAN				fConfirmed;						// @field TRUE means that the lower driver has already completed the open
	ULONG				ulAccess;						// @field represents permissions this was opened with
	USHORT				usSharing;						// @field represents sharing under which this was opened
	FILE_OBJECT			*pFileObject;					// @field Pointer to file object which this status describes
	struct tagGCK_FILE_OPEN_ITEM	*pNextOpenItem;		// @field Next structure in Linked List
} GCK_FILE_OPEN_ITEM, *PGCK_FILE_OPEN_ITEM;

typedef struct _SHARE_STATUS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    //ULONG Deleters;	//We are driver without delete symantics
    ULONG SharedRead;
    ULONG SharedWrite;
    //ULONG SharedDelete; //We are driver without delete symantics
} SHARE_STATUS, *PSHARE_STATUS;

//
//	@struct GCK_INTERNAL_POLL | Information needed for the iternal polling routines
//
typedef struct tagGCK_INTERNAL_POLL
{
	KSPIN_LOCK			InternalPollLock;			// @field SpinLock to serialize access to this structue (not all items require it)
	FILE_OBJECT			*pInternalFileObject;		// @field Pointer to File Object that was created for internal polls
	PGCK_FILE_OPEN_ITEM	pFirstOpenItem;				// @field Head of linked list of GCK_FILE_OPEN_ITEMs for open files
	SHARE_STATUS		ShareStatus;				// @field Keeps track of file sharing.
//	BOOLEAN				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
	LONG				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
    PIRP				pPrivateIrp;				// @field IRP we reuse to send Read IRPs to lower driver
    PUCHAR				pucReportBuffer;			// @field Buffer for getting Report with pPrivateIrp
	ULONG				ulInternalPollRef;			// @field Reference to internal polls
	PKTHREAD			InternalCreateThread;		// @field Used to figure out if a create is for the internal file object
	BOOLEAN				fReady;
} GCK_INTERNAL_POLL, *PGCK_INTERNAL_POLL;

typedef struct _tagGCK_INTERLOCKED_QUEUE
{
	KSPIN_LOCK SpinLock;
	LIST_ENTRY ListHead;
} GCK_INTERLOCKED_QUEUE, *PGCK_INTERLOCKED_QUEUE;

// Declare structure for filterhooks stuff
struct GCK_FILTER_HOOKS_DATA;


//
//	@struct GCK_FILTER_EXT | Device Extension for device objects which act as filters
//
typedef struct _tagGCK_FILTER_EXT
{
	ULONG			ulGckDevObjType;	// @field Type of GcKernel device object.
	GCK_DEVICE_STATE eDeviceState;		// @field Keeps track of device state
    PDEVICE_OBJECT	pPDO;				// @field PDO to which this filter is attached
    PDEVICE_OBJECT	pTopOfStack;		// @field Top of the device stack just
										// beneath this filter device object
    KEVENT			StartEvent;			// @field Event to notify when lower driver completed start IRP.
    GCK_REMOVE_LOCK RemoveLock;			// @field Custom Remove Lock
	PUCHAR			pucLastReport;		// @field Last report read
	IO_STATUS_BLOCK	ioLastReportStatus;	// @field Status block for Last report read
	struct GCK_FILTER_HOOKS_DATA *pFilterHooks;// @field pointer to all the thinks needed in filter hooks
	PDEVICE_OBJECT	pNextFilterObject;	// @field point to next filter device object in global list
	GCK_HID_DEVICE_INFO HidInfo;		// @field sub-structure with pertinent HID info
	PVOID			pvFilterObject;		// @field pointer to CDeviceFilter, but this is C module so use PVOID
	PVOID			pvSecondaryFilter;	// @field pointer to CDeviceFilter, but this is C module so use PVOID
	PVOID			pvForceIoctlQueue;	// @field pointer to CGuardedIrpQueue for waiting IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE (use PVOID since C)
	PVOID			pvTriggerIoctlQueue;// @field pointer to CGuardedIrpQueue for waiting IOCTL_GCK_TRIGGER (use PVOID since C)
	GCK_INTERNAL_POLL InternalPoll;		// @field Structure for Internal Polling module.
} GCK_FILTER_EXT, *PGCK_FILTER_EXT;

//
//	@struct GCK_GLOBALS	| Hold a few global variables for the driver
//
typedef struct _tagGCK_GLOBALS
{
    PDEVICE_OBJECT  pControlObject;			//@field pointer to the one and only control object
	ULONG			ulFilteredDeviceCount;	//@field count of device objects for filtering devices
	PDEVICE_OBJECT	pFilterObjectList;		//@field head of linked list for all the devices we are filtering
	FAST_MUTEX		FilterObjectListFMutex;	//@field fast mutex for synchronizing access to filter object list
	PGCK_FILTER_EXT	pSWVB_FilterExt;		//@field Device Extension of Filter Device which acts as SideWinder Virtual Bus
	PDEVICE_OBJECT	pVirtualKeyboardPdo;	//@field PDO for virtual Keyboard
	ULONG			ulVirtualKeyboardRefCount;	//@field RefCount of virual Keyboard users
} GCK_GLOBALS;

//
// @devnote One instance of GCK_GLOBALS exists(in GckShell.c) and is called "Globals"
//
extern GCK_GLOBALS Globals;


/*****************************************************************************
** Declaration of Driver Entry Points
******************************************************************************/
//
// General Entry Points - In GckShell.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_Read (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Power (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Pass (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

//
//	For Control Devices - In CTRL.c
//
NTSTATUS
GCK_CTRL_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_CTRL_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_CTRL_AddDevice
(
	IN PDRIVER_OBJECT  pDriverObject
);

VOID
GCK_CTRL_Remove();

NTSTATUS
GCK_CTRL_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_CTRL_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

//
//	For Control Devices - In CTRL_Ioctl.c
//

NTSTATUS
GCK_CTRL_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

//
//	For Filter Devices - In FLTR.c
//
NTSTATUS
GCK_FLTR_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_FLTR_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_FLTR_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Read
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_FLTR_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

//
//	In FLTR_PnP.c
//
NTSTATUS
GCK_FLTR_Power (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_AddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

//
//	In SWVBENUM.c
//
NTSTATUS
GCK_SWVB_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_SWVB_UnLoad();


NTSTATUS
GCK_SWVB_PnP
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Power
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Create
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Close
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Read
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Ioctl
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

//
//	In SWVKBD.c
//
NTSTATUS
GCK_VKBD_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

/*****************************************************************************
** End of declaration of Driver Entry Points
******************************************************************************/

/*****************************************************************************
** Declaration of Non-Entry Driver routines
******************************************************************************/
//
// In FLTR.c
//

NTSTATUS
GCK_FLTR_CreateComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext
);

//
// In PnP.c
//
NTSTATUS
GCK_FLTR_PnPComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
GCK_FLTR_StartDevice (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP				pIrp
    );

VOID
GCK_FLTR_StopDevice (
    IN PGCK_FILTER_EXT	pFilterExt,
    IN BOOLEAN			fTouchTheHardware
    );

NTSTATUS
GCK_GetHidInformation
(
	IN PGCK_FILTER_EXT	pFilterExt
);

VOID 
GCK_CleanHidInformation(
	IN PGCK_FILTER_EXT	pFilterExt
);

//
// In IoCtl.c
//
NTSTATUS
GCK_CTRL_Ioctl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Ioctl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

PDEVICE_OBJECT
GCK_FindDeviceObject( 
	IN PWSTR pwszInterfaceReq,
	IN ULONG uInLength
	);

BOOLEAN GCK_MatchReqPathtoInterfaces
(
	IN PWSTR pwszPath,
	IN ULONG uStringLen,
	IN PWSTR pmwszInterfaces
);

//
// In FilterHooks.cpp
//


NTSTATUS _stdcall
GCKF_InitFilterHooks(
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_DestroyFilterHooks(
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall 
GCKF_ProcessCommands(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN BOOLEAN fPrimaryFilter
	);

void _stdcall 
GCKF_SetInitialMapping(
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_IncomingReadRequests(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp
	);

VOID __stdcall
GCKF_KickDeviceForData(
	IN PGCK_FILTER_EXT pFilterExt
	);

VOID _stdcall
GCKF_CancelPendingRead(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
	);

NTSTATUS _stdcall
GCKF_IncomingInputReports(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pcReport,
	IN IO_STATUS_BLOCK IoStatus
	);

NTSTATUS _stdcall
GCKF_CompleteReadRequests(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pcReport,
	IN IO_STATUS_BLOCK IoStatus
	);

void _stdcall
GCKF_CompleteReadRequestsForFileObject(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
	);

NTSTATUS _stdcall
GCKF_IncomingForceFeedbackChangeNotificationRequest(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp
	);

NTSTATUS _stdcall
GCKF_ProcessForceFeedbackChangeNotificationRequests(
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_OnForceFeedbackChangeNotification(
	IN PGCK_FILTER_EXT pFilterExt,
	const IN /*FORCE_BLOCK*/void* pForceBlock
	);
	
NTSTATUS _stdcall
GCKF_GetForceFeedbackData(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_SetWorkingSet(
	IN PGCK_FILTER_EXT pFilterExt,
	UCHAR ucWorkingSet
	);

NTSTATUS _stdcall
GCKF_QueryProfileSet(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_SetLEDBehaviour(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_TriggerRequest(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_SetNextJog(
	IN PVOID pvFilterContext,
	IN ULONG ulJogDelay
	);

ULONG _stdcall
GCKF_GetTimeStampMs();

VOID _stdcall
GCKF_TimerDPCHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS _stdcall
GCKF_EnableTestKeyboard(
	IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fEnable,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS _stdcall
GCKF_BeginTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_UpdateTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_EndTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_BackdoorPoll(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp,
	IN GCK_POLLING_MODES ePollingMode
	);

void _stdcall
GCKF_ResetKeyboardQueue(
	DEVICE_OBJECT* pFilterHandle
	);

//
// In InternalPoll.c
//
NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN USHORT		usDesiredShareAccess,
	IN ULONG		ulDesiredAccess
);

NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_ConfirmFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN BOOLEAN	fConfirm
);

BOOLEAN
GCK_IP_CheckSharing
(
	IN SHARE_STATUS ShareStatus,
	IN USHORT usDesireShareAccess,
	IN ULONG ulDesiredAccess
);

BOOLEAN
GCK_IP_AddSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
);

BOOLEAN
GCK_IP_RemoveSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
);


NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
);

NTSTATUS
GCK_IP_ReadComplete
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
);

void
GCK_IP_AddDevice(PGCK_FILTER_EXT pFilterExt);

NTSTATUS
GCK_IP_Init
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
);

NTSTATUS
GCK_IP_CloseFileObject
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);
/*****************************************************************************
** End of declaration of Non-Entry Driver routines
******************************************************************************/

/*****************************************************************************
** Macros used internally  - to access filed from the device extension
**							directly from the pDeviceObject
******************************************************************************/
#define NEXT_FILTER_DEVICE_OBJECT(__pDO__)\
		( ((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pNextFilterObject )
#define PTR_NEXT_FILTER_DEVICE_OBJECT(__pDO__)\
		( &((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pNextFilterObject )
#define FILTER_DEVICE_OBJECT_PDO(__pDO__)\
		( ((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pPDO )
#define THREAD_SAFE_DEC_REF(__pFoo__, __TYPE__)\
	__TYPE__ *__pTempPointer__ = __pFoo__;\
	__pFoo__ = NULL;\
	__pTempPointer__->DecRef();

/*****************************************************************************
** End of macros used internally
******************************************************************************/

/*****************************************************************************
**	Macro for allocating memory - debug version uses ExAllocatePoolTag
******************************************************************************/
#if (DBG==1)


// For serious debugging
/*
#define EX_ALLOCATE_POOL(__PoolType__,__Size__)	MyAllocation(__PoolType__,__Size__, '_KCG', __FILE__, __LINE__)
PVOID MyAllocation(
       IN POOL_TYPE PoolType,
       IN ULONG NumberOfBytes,
       IN ULONG Tag,
	   IN LPSTR File,
	   IN ULONG Line
       )
{
	DbgPrint("GcKernel: ");
	DbgPrint("Memory allocation in %s, line %d\n", File, Line);
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}
*/
//For lighter weight debugging
#define EX_ALLOCATE_POOL(__PoolType__,__Size__)	ExAllocatePoolWithTag(__PoolType__,__Size__,'_KCG')


#else
#define EX_ALLOCATE_POOL(__PoolType__,__Size__) ExAllocatePool(__PoolType__,__Size__)
#endif

#endif // __GckShell_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\internalpoll.c ===
//	@doc
/**********************************************************************
*
*	@module	InternalPolling.c	|
*
*	Implementation of routines for internal polling
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1999 Microsoft Corporation. All right reserved.
*
*	@topic	Internal Polling	|
*			All polling to get data is via this internal polling mechanism.
*			However, for security and access checks, the first poll from
*			a new file handle is sent straight down, and comes up via
*			different completion.  To keep track of this we keep a linked
*			list of GCK_FILE_OPEN_ITEMs representing each of the FILE_OBJECTS
*			that we need.<nl>
*			To Poll internally we need to have a valid FILE_OBJECT otherwise
*			hidclass.sys will reject the poll request.  This is done
*			via GCK_IP_CreateFileObject which internally calls IoGetDeviceObjectPointer.
*			Somewhat unfortunately, this takes circular path through, so is not
*			really distinguishable from opens done up top.  (Ken Ray tells me that
*			this is guaranteed to be synchronous, so we can compare thread IDs and
*			figure out that a given open is from our driver, but this code is written
*			assuming that we don't really need to distinguish.)
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_INTERNALPOLL_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_AddFileObject(IN PGCK_FILTER_EXT pFilterExt, IN PFILE_OBJECT pFileObject)
**
**	@func	Called to add a GCK_FILE_OPEN_ITEM entry corresponding to pFileObject to
**			our list of file handles that we know about.  Allocate and initializes the structure.
**
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL if pFileObject is not found.
**
*************************************************************************************/
NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN USHORT		usDesiredShareAccess,
	IN ULONG		ulDesiredAccess
)
{
	PGCK_FILE_OPEN_ITEM pNewFileOpenItem;
	KIRQL			 	OldIrql;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_IP_AddFileObject pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x\n", pFilterExt, pFileObject));
	
	//We need a spin lock to access this list
	KeAcquireSpinLock(&pFilterExt->InternalPoll.InternalPollLock, &OldIrql);

	//Check for sharing violation
	if( !GCK_IP_CheckSharing(pFilterExt->InternalPoll.ShareStatus, usDesiredShareAccess, ulDesiredAccess) )
	{
		KeReleaseSpinLock(&pFilterExt->InternalPoll.InternalPollLock, OldIrql);
		GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject: Sharing Violation\n"));
		return STATUS_SHARING_VIOLATION;
	}

	//Allocate Space for NewFileOpenItem;
	pNewFileOpenItem = (PGCK_FILE_OPEN_ITEM)EX_ALLOCATE_POOL(NonPagedPool, sizeof(GCK_FILE_OPEN_ITEM));
	if(!pNewFileOpenItem)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate space for GCK_FILE_OPEN_ITEM\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject(1) STATUS_NO_MEMORY\n"));
		return STATUS_NO_MEMORY;
	}
	
	//Initialize FileOpenItem
	pNewFileOpenItem->fReadPending = FALSE;
	pNewFileOpenItem->pFileObject = pFileObject;
	pNewFileOpenItem->pNextOpenItem = NULL;
	pNewFileOpenItem->ulAccess = ulDesiredAccess;
	pNewFileOpenItem->usSharing = usDesiredShareAccess;
	pNewFileOpenItem->fConfirmed = FALSE;

	//Add New Item to head of list
	pNewFileOpenItem->pNextOpenItem = pFilterExt->InternalPoll.pFirstOpenItem;
	pFilterExt->InternalPoll.pFirstOpenItem = pNewFileOpenItem;
	
	//Update SHARE_ACCESS
	GCK_IP_AddSharing(&pFilterExt->InternalPoll.ShareStatus, usDesiredShareAccess, ulDesiredAccess);

	//Release Spinlock
	KeReleaseSpinLock(&pFilterExt->InternalPoll.InternalPollLock, OldIrql);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject(2) STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}


/***********************************************************************************
**
**	NTSTATUS	GCK_IP_RemoveFileObject(IN PGCK_FILTER_EXT pFilterExt, IN PFILE_OBJECT pFileObject)
**
**	@func	Called to remove a GCK_FILE_OPEN_ITEM entry corresponding to pFileObject from
**			our list of file handles that we know about.  Deallocates structure.
**
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL if pFileObject is not found.
**
*************************************************************************************/
NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
)
{
	//Remove is just a negative confirmation
	return GCK_IP_ConfirmFileObject(pFilterExt, pFileObject, FALSE);
}

NTSTATUS
GCK_IP_ConfirmFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN BOOLEAN	fConfirm
)
{
	//Find FileOpenItem and remove it.
	PGCK_FILE_OPEN_ITEM pCurrentFileItem = pFilterExt->InternalPoll.pFirstOpenItem; 
	PGCK_FILE_OPEN_ITEM pPreviousFileItem = NULL; 

	GCK_DBG_ENTRY_PRINT(("Entering GCK_IP_ConfirmFileObject pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x, fConfirm = %d\n", pFilterExt, pFileObject, fConfirm));
	
	while(pCurrentFileItem)
	{
		//Check for File Object Match
		if(pCurrentFileItem->pFileObject == pFileObject)
		{
			//If this is a confirmation, flag
			if( fConfirm )
			{
				pCurrentFileItem->fConfirmed = TRUE;
			}
			//Otherwise, it is a negative confirmation, and we must remove it
			else
			{
				//Remove from list
				if( NULL == pPreviousFileItem)
				{
					pFilterExt->InternalPoll.pFirstOpenItem = pCurrentFileItem->pNextOpenItem;
				}
				else
				{
					pPreviousFileItem->pNextOpenItem = pCurrentFileItem->pNextOpenItem;
				}
				//Decrement number of open file objects
				GCK_IP_RemoveSharing(&pFilterExt->InternalPoll.ShareStatus, pCurrentFileItem->usSharing, pCurrentFileItem->ulAccess);

				//Free memory allocate for FileOpenItem
				ExFreePool(pCurrentFileItem);
			}
			//Return Successfully
			GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_RemoveFileObject(1) STATUS_SUCCESS\n"));
			return STATUS_SUCCESS;
		}
		pPreviousFileItem = pCurrentFileItem;
		pCurrentFileItem = pCurrentFileItem->pNextOpenItem;
	}
	//If we are here the file object is not in our list.  Either it was never added
	//or is was removed
	ASSERT(FALSE);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_ConfirmFileObject(2) STATUS_UNSUCCESSFUL\n"));
	return STATUS_UNSUCCESSFUL;
}

BOOLEAN
GCK_IP_CheckSharing
(
	IN SHARE_STATUS ShareStatus,
	IN USHORT usDesiredShareAccess,
	IN ULONG ulDesiredAccess
)
{
	//Check that no-one has exclusive access to the desire access
	if(
		( (ulDesiredAccess & FILE_WRITE_DATA) && (ShareStatus.SharedWrite < ShareStatus.OpenCount) ) ||
		( (ulDesiredAccess & FILE_READ_DATA) && (ShareStatus.SharedRead < ShareStatus.OpenCount) )
	)
	{
		return FALSE;
	}
	
	//Check that not requesting exclusive access, if already open
	if(
		( !(usDesiredShareAccess & FILE_SHARE_READ) && ShareStatus.Readers) ||
		( !(usDesiredShareAccess & FILE_SHARE_WRITE) && ShareStatus.Writers) ||
		(!usDesiredShareAccess && ShareStatus.OpenCount)
	)
	{
		return FALSE;
	}

	//This would be approved
	return TRUE;
}

BOOLEAN
GCK_IP_AddSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
)
{
	//We assume this was checked before requested
	ASSERT(GCK_IP_CheckSharing(*pShareStatus, usDesiredShareAccess, ulDesiredAccess));
	pShareStatus->OpenCount++;
	if(usDesiredShareAccess & FILE_SHARE_READ) pShareStatus->SharedRead++;
	if(usDesiredShareAccess & FILE_SHARE_WRITE) pShareStatus->SharedWrite++;
	if(ulDesiredAccess & FILE_WRITE_DATA) pShareStatus->Writers++;
	if(ulDesiredAccess & FILE_READ_DATA) pShareStatus->Readers++;
	return TRUE;
}

BOOLEAN
GCK_IP_RemoveSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
)
{
	pShareStatus->OpenCount--;
	if(usDesiredShareAccess & FILE_SHARE_READ) pShareStatus->SharedRead--;
	if(usDesiredShareAccess & FILE_SHARE_WRITE) pShareStatus->SharedWrite--;
	if(ulDesiredAccess & FILE_WRITE_DATA) pShareStatus->Writers--;
	if(ulDesiredAccess & FILE_READ_DATA) pShareStatus->Readers--;
	return TRUE;
}

typedef struct _GCK_INTERNEL_WorkItemExtension
{
	WORK_QUEUE_ITEM WorkItem;
	PGCK_FILTER_EXT pFilterExt;
} GCK_INTERNEL_WorkItemExtension;

VOID GCK_IP_WorkItem
(
	IN PVOID pvContext
)
{
	GCK_INTERNEL_WorkItemExtension* pWIExtension = (GCK_INTERNEL_WorkItemExtension*)pvContext;

 	if (pWIExtension != NULL)
	{
		GCKF_IncomingReadRequests(pWIExtension->pFilterExt, NULL);
		ExFreePool(pWIExtension);
	}
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_OneTimePoll(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	If a private poll is not pending, it forces one.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt 
)
{
	PIO_STACK_LOCATION pPrivateIrpStack;
	GCK_INTERNEL_WorkItemExtension* pWIExtension;
		
	//
	//	Create a polling FileObject if necessary
	//
	if(!pFilterExt->InternalPoll.fReady)
	{
		NTSTATUS NtStatus;
		if(GCK_STATE_STARTED == pFilterExt->eDeviceState)
		{
			pFilterExt->InternalPoll.InternalCreateThread=KeGetCurrentThread();
			NtStatus = GCK_IP_CreateFileObject( &pFilterExt->InternalPoll.pInternalFileObject, pFilterExt->pPDO);
			pFilterExt->InternalPoll.InternalCreateThread=NULL;
			if( NT_SUCCESS(NtStatus) )
			{
				pFilterExt->InternalPoll.fReady = TRUE;
			}
			else
			{
				return STATUS_DEVICE_NOT_CONNECTED;
			}
		}
		else
		{
			return STATUS_DEVICE_NOT_CONNECTED;
		}
	}

	//	If an read IRP is not pending, post one
/*	if( pFilterExt->InternalPoll.fReadPending )
	{
		//If an IRP is pending, we're done
		return STATUS_SUCCESS;
	}

  // Mark a read pending
	pFilterExt->InternalPoll.fReadPending = TRUE;
*/	if (InterlockedExchange(&pFilterExt->InternalPoll.fReadPending, TRUE) == TRUE)
	{
		return STATUS_SUCCESS;
	}


	//Otherwise Post an IRP
	GCK_DBG_RT_WARN_PRINT(("No IRP Pending, posting one.\n"));
	

	// Give a change for the LEDs to update (we fake an incoming request)
	pWIExtension = 	(GCK_INTERNEL_WorkItemExtension*)(EX_ALLOCATE_POOL(NonPagedPool, sizeof(GCK_INTERNEL_WorkItemExtension)));
	if (pWIExtension != NULL)
	{
		pWIExtension->pFilterExt = pFilterExt;
		ExInitializeWorkItem(&pWIExtension->WorkItem, GCK_IP_WorkItem, (void*)(pWIExtension));

		// Need to callback at IRQL PASSIVE_LEVEL
		ExQueueWorkItem(&pWIExtension->WorkItem, DelayedWorkQueue);
		pWIExtension = NULL;	// Will be deleted by the work item routine
	}
	
	//Setup the file object for out internal IRP
	GCK_DBG_RT_WARN_PRINT(("Copying File object.\n"));
	pPrivateIrpStack = IoGetNextIrpStackLocation(pFilterExt->InternalPoll.pPrivateIrp);
	pPrivateIrpStack->FileObject = pFilterExt->InternalPoll.pInternalFileObject;
	
	// Reset status
	pFilterExt->InternalPoll.pPrivateIrp->IoStatus.Information = 0;
	pFilterExt->InternalPoll.pPrivateIrp->IoStatus.Status = STATUS_SUCCESS;

	// Reset the ByteOffset, Length
	pPrivateIrpStack->Parameters.Read.ByteOffset.QuadPart = 0;
	pPrivateIrpStack->Parameters.Read.Key = 0;
	pPrivateIrpStack->Parameters.Read.Length =
	(ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;

	// Set Completion routine to process poll after it is complete.
	GCK_DBG_RT_WARN_PRINT(("Setting completion routine.\n"));
	ASSERT(pFilterExt->InternalPoll.pPrivateIrp);

	IoSetCompletionRoutine(
		pFilterExt->InternalPoll.pPrivateIrp,
		GCK_IP_ReadComplete,
		(PVOID)pFilterExt,
		TRUE,
		TRUE,
		TRUE
	);
				
	// We are about to generate another IRP so increment outstanding IO count 
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

	// Send IRP down to driver
	GCK_DBG_RT_WARN_PRINT(("Calling down to next driver.\n"));
	return IoCallDriver (pFilterExt->pTopOfStack, pFilterExt->InternalPoll.pPrivateIrp);
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_FullTimePoll(IN PGCK_FILTER_EXT pFilterExt, IN BOOLEAN fStart)
**
**	@func	Turns FullTime internal polling on or off.  Actually changes a refcount.
**			When the refcount goes to zero, polling is off, otherwise it is on.  Calls
**			GCK_IP_OneTimePoll which may be necessary to get ball rolling.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
)
{
	//Change number of requests for continuous background polling.
	if(fStart)
	{
		pFilterExt->InternalPoll.ulInternalPollRef++;
		ASSERT( 0!= pFilterExt->InternalPoll.ulInternalPollRef);
		//There is no thread, the completion routine recycles the IRP
		//and polls again if pFilterExt->InternalPoll.ulInternalPollRef > 0
		//we need to hit GCK_IP_OneTimePoll just to get the ball rolling though.
		if(GCK_STATE_STARTED == pFilterExt->eDeviceState )
		{
			return GCK_IP_OneTimePoll(pFilterExt);
		}
		return STATUS_SUCCESS;
	}
	
	//We need to decrment the refcount.
	ASSERT( 0 != pFilterExt->InternalPoll.ulInternalPollRef);
	if(0 != pFilterExt->InternalPoll.ulInternalPollRef)
	{
		pFilterExt->InternalPoll.ulInternalPollRef--;
	}
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_ReadComplete (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, IN PVOID pContext)
**
**	@func	When a Private IRP is completed handles processing the data.  Also
**			important is that it repolls internall if pFilterExt->InternalPoll.ulInternalPollRef
**			is greater than zero.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_ReadComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
 )
{	
	PGCK_FILTER_EXT		pFilterExt;
	PVOID				pvReportBuffer;
	
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_ReadComplete. pDO = 0x%0.8x, pIrp = 0x%0.8x, pContext = 0x%0.8x\n", pDeviceObject, pIrp, pContext));

	// Cast context to device extension
	pFilterExt = (PGCK_FILTER_EXT) pContext;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);

	//	Get Pointer to data
	ASSERT(pIrp);

	pvReportBuffer = GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
	if(pvReportBuffer)
    {
	    //	Tell filter we have new data
	    GCKF_IncomingInputReports(pFilterExt, pvReportBuffer, pIrp->IoStatus);
    }
	    
	//**
	//**	At this point we are done with the IRP
	//**	Need not complete it, it will be recycled.
	//**
	
	//	Decrement outstanding IRP count
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	//	Read is no longer pending
	pFilterExt->InternalPoll.fReadPending = FALSE;
	
	//If the InternalPollRef is greater than zero,
	//we need to be polling ourselves continuously
    //but don't carry on if some catestrophic failure 
    //occured which lead to a MDL mapping failure
	if( pvReportBuffer
     && (pFilterExt->InternalPoll.ulInternalPollRef) )
	{
		GCK_IP_OneTimePoll(pFilterExt);
	}

	//We don't want any cleanup to happen
	return STATUS_MORE_PROCESSING_REQUIRED;
}

void GCK_IP_AddDevice(PGCK_FILTER_EXT pFilterExt)
{
	KeInitializeSpinLock(&pFilterExt->InternalPoll.InternalPollLock);
	pFilterExt->InternalPoll.ShareStatus.OpenCount = 0;
	pFilterExt->InternalPoll.ShareStatus.Readers = 0;
	pFilterExt->InternalPoll.ShareStatus.Writers = 0;
	pFilterExt->InternalPoll.ShareStatus.SharedRead = 0;
	pFilterExt->InternalPoll.ShareStatus.SharedWrite = 0;
	pFilterExt->InternalPoll.fReadPending = FALSE;
	pFilterExt->InternalPoll.ulInternalPollRef = 0;
	pFilterExt->InternalPoll.pFirstOpenItem = NULL;
	pFilterExt->InternalPoll.fReady = FALSE;
}
/***********************************************************************************
**
**	NTSTATUS GCK_IP_Init (IN OUT PGCK_FILTER_EXT pFilterExt);
**
**	@func	As part of the initialization that occurs at the end of Start device on
**			a filtered device, the filter must be prepared for internal polling.
**			All data polling is internal. (IRP_MJ_READ are sent down directly once
**			so that hidclass.sys can perform its security check, but the data from
**			that poll is discarded.)  Initialize InternalPoll Data in Device Extension
**			including creating a pInternalFileObject, a pPrivateIRP and an associtated
**			Buffer.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_Init
(
	IN OUT PGCK_FILTER_EXT pFilterExt
)
{
	//NTSTATUS NtStatus;
	LARGE_INTEGER lgiBufferOffset;

	//Initialize the Internal Poll Structure
	pFilterExt->InternalPoll.pInternalFileObject = NULL;
	pFilterExt->InternalPoll.pPrivateIrp = NULL;
	pFilterExt->InternalPoll.pucReportBuffer = NULL;

	//	Allocate a Buffer for the private IRP_MJ_READ
	pFilterExt->InternalPoll.pucReportBuffer = (PUCHAR)	EX_ALLOCATE_POOL
											( NonPagedPool,
											  pFilterExt->HidInfo.HidPCaps.InputReportByteLength );
	if(!pFilterExt->InternalPoll.pucReportBuffer)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate Report Buffer for private IRPs\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	
	//  Allocate private recyclable IRPs for internal polling
	lgiBufferOffset.QuadPart = 0;
	pFilterExt->InternalPoll.pPrivateIrp = 	IoBuildAsynchronousFsdRequest 
											(
												IRP_MJ_READ,
												pFilterExt->pTopOfStack,
												pFilterExt->InternalPoll.pucReportBuffer,
												(ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength,
												&lgiBufferOffset,
												NULL
											);

	if(!pFilterExt->InternalPoll.pPrivateIrp)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate private Ping-Pong IRP\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
		
	// Initialize status for very first IRP
	pFilterExt->ioLastReportStatus.Information = (ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;
	pFilterExt->ioLastReportStatus.Status =  STATUS_SUCCESS;

	/**
	**	Cannot do this here since build 2006 or so,
	**	so defer until the first time we need it.
	**
	**
	** //Open ourselves with a file object
	** pFilterExt->InternalPoll.InternalCreateThread=KeGetCurrentThread();
	** NtStatus = GCK_IP_CreateFileObject( &pFilterExt->InternalPoll.pInternalFileObject, pFilterExt->pTopOfStack);
	** pFilterExt->InternalPoll.InternalCreateThread=NULL;
	** if( NT_SUCCESS(NtStatus) )
	** {
	**	pFilterExt->InternalPoll.fReady = TRUE;
	** } 
	**/
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_Cleanup (IN OUT PGCK_FILTER_EXT pFilterExt);
**
**	@func	Reverses Init, cancels outstanding internal polls, release pFileObject for
**			internal polls, release private IRP and buffer.  Does not release open file handles
**
**	@rdesc	STATUS_SUCCESS, STATUS_UNSUCCESSFUL if we could not cancel a pending poll
**
*************************************************************************************/
NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	if( pFilterExt->InternalPoll.fReady)
	{
		NtStatus = GCK_IP_CloseFileObject(pFilterExt);
	}
	if(NT_SUCCESS(NtStatus))
	{
		//Cleanup private IRP - and buffer, safely they may never had been allocated
		if(pFilterExt->InternalPoll.pPrivateIrp)
		{
			IoFreeIrp(pFilterExt->InternalPoll.pPrivateIrp);
			pFilterExt->InternalPoll.pPrivateIrp = NULL;
		}
		if(pFilterExt->InternalPoll.pucReportBuffer)
		{
			ExFreePool(pFilterExt->InternalPoll.pucReportBuffer);
			pFilterExt->InternalPoll.pucReportBuffer = NULL;
		}
	}	
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_CreateFileObject (OUT PFILE_OBJECT *ppFileObject, IN PDEVICE_OBJECT pPDO);
**
**	@func	Calls IoGetDeviceObjectPointer, even though we already attached to the
**			and have a pointer to the device object, the caller wants to create a
**			new file object for internal calls down the stack that may require one.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
)
{
	NTSTATUS NtStatus;
	ULONG ulBufferLength = 0;
	PVOID pPDONameBuffer = NULL;
	UNICODE_STRING	uniPDOName;
	PDEVICE_OBJECT	pDeviceObject;

	//Get the size required for the PDO Name Buffer
	NtStatus = IoGetDeviceProperty(
					pPDO,
					DevicePropertyPhysicalDeviceObjectName,
					ulBufferLength,
					pPDONameBuffer,
					&ulBufferLength
					);
	ASSERT(STATUS_BUFFER_TOO_SMALL==NtStatus);

	//Allocate space
	pPDONameBuffer = EX_ALLOCATE_POOL(NonPagedPool, ulBufferLength);
	if(!pPDONameBuffer)
	{
		return STATUS_NO_MEMORY;
	}

	//Get PDO Name
	NtStatus = IoGetDeviceProperty(
					pPDO,
					DevicePropertyPhysicalDeviceObjectName,
					ulBufferLength,
					pPDONameBuffer,
					&ulBufferLength
					);
	ASSERT(NT_SUCCESS(NtStatus));
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//Make PDO Name into UNICODE string
	RtlInitUnicodeString(&uniPDOName, pPDONameBuffer);

	//Call IoGetDeviceObjectPointer to create a FILE_OBJECT
	NtStatus = IoGetDeviceObjectPointer(
					&uniPDOName,
					FILE_READ_DATA,
					ppFileObject,
					&pDeviceObject
					);
	ASSERT(NT_SUCCESS(NtStatus));

	//Release the space for Name
	ExFreePool(pPDONameBuffer);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_CloseFileObject (OUT PFILE_OBJECT *ppFileObject, IN PDEVICE_OBJECT pPDO);
**
**	@func	Stops outstanding IO to hidclass.sys and closes handle
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL
**
*************************************************************************************/
NTSTATUS
GCK_IP_CloseFileObject
(
	IN OUT PGCK_FILTER_EXT pFilterExt	
)
{
	NTSTATUS NtStatus;
	BOOLEAN fResult = TRUE;
	
	//Turn off internal polling
	pFilterExt->InternalPoll.fReady = FALSE;
	
	//Cancel pending internal polls
	if(pFilterExt->InternalPoll.fReadPending)
	{
		ASSERT(pFilterExt->InternalPoll.pPrivateIrp);
		fResult = IoCancelIrp(pFilterExt->InternalPoll.pPrivateIrp);
	}

	if(!fResult)
	{
		return STATUS_UNSUCCESSFUL;
	}
	
	//***
	//***If we are here, there are no pending polls, and there shall be no pending polls.
	//***

	//Release internal file object - if it had been created successfully
	if(pFilterExt->InternalPoll.pInternalFileObject)
	{
		ObDereferenceObject((PVOID)pFilterExt->InternalPoll.pInternalFileObject);
		pFilterExt->InternalPoll.pInternalFileObject=NULL;
	}

	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GcKernel.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\purecall.c ===
//
//	purecall.c - required for using virtual functions in driver on win98.
//				 not required for NT5, but does no harm.
//				 basically this function must be defined.
#include <wdm.h>
#include "debug.h"
int _cdecl _purecall( void )
{
    ASSERT(FALSE && "Attempt to call pure virtual function!");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\remlock.h ===
#ifndef __REMLOCK_H__
#define __REMLOCK_H__
//	@doc
/**********************************************************************
*
*	@module	RemLock.h	|
*
*	Definitions for managing GCK_REMOVE_LOCKs
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	RemLock	|
*			The structure and four functions greatly
*			simplify keep track of outstanding IO. 
*	@xref	Remlock.cpp
*
**********************************************************************/
typedef struct tagGCK_REMOVE_LOCK
{
	LONG	lRemoveLock;
	KEVENT	RemoveLockEvent;
	PCHAR	pcInstanceID;
} GCK_REMOVE_LOCK, *PGCK_REMOVE_LOCK;

#if (DBG==1)
#define GCK_InitRemoveLock(__x__, __y__) GCK_InitRemoveLockChecked(__x__,__y__)
void GCK_InitRemoveLockChecked(PGCK_REMOVE_LOCK pRemoveLock, PCHAR pcInstanceID);
#else
#define GCK_InitRemoveLock(__x__, __y__) GCK_InitRemoveLockFree(__x__)
void GCK_InitRemoveLockFree(PGCK_REMOVE_LOCK pRemoveLock);
#endif




void GCK_IncRemoveLock(PGCK_REMOVE_LOCK pRemoveLock);
void GCK_DecRemoveLock(PGCK_REMOVE_LOCK pRemoveLock);
NTSTATUS GCK_DecRemoveLockAndWait(PGCK_REMOVE_LOCK pRemoveLock, PLARGE_INTEGER plgiTimeOut);
PVOID GCK_GetSystemAddressForMdlSafe(PMDL MdlAddress);

#endif //__REMLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\remlock.c ===
//	@doc
/**********************************************************************
*
*	@module	RemLock.c	|
*
*	Implements Remove Lock utilities for keeping track of the driver.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	RemLock	|
*			This module was written to make the numerous increments and
*			and decrements of Outstanding IO easier to manage.
*			An increment and a decrment (even the final one), is reduced
*			to a one line function everywhere.  Furthermore, this module
*			can have traceouts turned on independently just for testing
*			this aspect of the driver.<nl>
*			This is similar to the IoAcquireRemoveLock, except that
*			to the best of my knowledge is not available on Win98.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_REMLOCK_C

#include <wdm.h>
#include "debug.h"
#include "RemLock.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));

#if (DBG==1)
void GCK_InitRemoveLockChecked(PGCK_REMOVE_LOCK pRemoveLock, PCHAR pcInstanceID)
{
	pRemoveLock->pcInstanceID = pcInstanceID;
	GCK_DBG_TRACE_PRINT(("Initializing remove lock \'%s\' to one.\n", pRemoveLock->pcInstanceID));
	pRemoveLock->lRemoveLock = 1;
	KeInitializeEvent(&pRemoveLock->RemoveLockEvent, SynchronizationEvent, FALSE);
}
#else
void GCK_InitRemoveLockFree(PGCK_REMOVE_LOCK pRemoveLock)
{
	pRemoveLock->lRemoveLock = 1;
	KeInitializeEvent(&pRemoveLock->RemoveLockEvent, SynchronizationEvent, FALSE);
}
#endif

void GCK_IncRemoveLock(PGCK_REMOVE_LOCK pRemoveLock)
{
	LONG lNewCount = InterlockedIncrement(&pRemoveLock->lRemoveLock);
	GCK_DBG_TRACE_PRINT(("\'%s\', Incremented Remove Lock to %d.\n", pRemoveLock->pcInstanceID, lNewCount));
}

void GCK_DecRemoveLock(PGCK_REMOVE_LOCK pRemoveLock)
{
	LONG lNewCount = InterlockedDecrement(&pRemoveLock->lRemoveLock);
	if (0 >= lNewCount)
	{
		GCK_DBG_TRACE_PRINT(("\'%s\', Last IRP completed.\n", pRemoveLock->pcInstanceID));
		KeSetEvent (&pRemoveLock->RemoveLockEvent, IO_NO_INCREMENT, FALSE);
	}
	GCK_DBG_TRACE_PRINT(("\'%s\', Decremented Remove Lock to %d\n", pRemoveLock->pcInstanceID, lNewCount));

}

NTSTATUS GCK_DecRemoveLockAndWait(PGCK_REMOVE_LOCK pRemoveLock, PLARGE_INTEGER plgiWaitTime)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	LONG lNewCount = InterlockedDecrement(&pRemoveLock->lRemoveLock);
	if (0 < lNewCount)
	{
		GCK_DBG_TRACE_PRINT(("\'%s\', Decremented Remove Lock to %d, waiting for final unlock.\n",
							 pRemoveLock->pcInstanceID,
							 lNewCount));
		NtStatus = KeWaitForSingleObject (
					&pRemoveLock->RemoveLockEvent,
					Executive,
					KernelMode,
					FALSE,
					plgiWaitTime
					);
	}

	#if (DBG==1)
	if(STATUS_SUCCESS == NtStatus)
	{
		GCK_DBG_EXIT_PRINT(("\'%s\', GCK_DecRemoveLockAndWait exiting - Remove Lock went to zero.\n", pRemoveLock->pcInstanceID));
	}
	else
	{
		GCK_DBG_CRITICAL_PRINT(("\'%s\', Remove Lock is still %d, should be zero.\n", pRemoveLock->lRemoveLock));
		GCK_DBG_EXIT_PRINT(("\'%s\', GCK_DecRemoveLockAndWait exiting - timed out.\n", pRemoveLock->pcInstanceID));
	}
	#endif
	return NtStatus;
}

/*
 *  Avoid bugchecks by requesting a failable mapping.
 *  Error check that was added to calling functions is limited to 
 *  only avoiding partying on a NULL pointer.  Correct functioning 
 *  is not expected.
 */
PVOID GCK_GetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (~MDL_MAPPING_CAN_FAIL);
    }
    else {
		GCK_DBG_CRITICAL_PRINT(("MdlAddress passed into GetSystemAddress is NULL\n"));
    }
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\irpqueue.h ===
#ifndef __IrpQueue_h__
#define __IrpQueue_h__

extern "C"
{
	#include <wdm.h>
}

class CTempIrpQueue
{
		friend class CGuardedIrpQueue;
	public:
		CTempIrpQueue()
		{
			InitializeListHead(&m_QueueHead);
			m_fLIFO = FALSE;
		}
		~CTempIrpQueue()
		{
			ASSERT(IsListEmpty(&m_QueueHead));
		}
		PIRP Remove();
	
	private:
		LIST_ENTRY	m_QueueHead;
		BOOLEAN		m_fLIFO;
};

class CGuardedIrpQueue
{
	public:
		friend void _stdcall DriverCancel(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
		friend class CShareIrpQueueSpinLock;
		typedef void (_stdcall*PFN_DEC_IRP_COUNT)(PVOID pvContext);
		//c'tor's and d'tors are often not called in drivers, either
		//because the instance is global, or because they are a part of a
		//larger structure (such as a DeviceExtension) which is allocated as
		//an unstructured block of memory, so we insist that they do nothing.
		//call Init and Destroy instead. (A more systematic approach to C++
		//in a driver could solve this problem).
		CGuardedIrpQueue(){}
		~CGuardedIrpQueue(){}
		void Init(int iFlags, PFN_DEC_IRP_COUNT pfnDecIrpCount, PVOID pvContext);
		void Destroy(NTSTATUS NtStatus=STATUS_DELETE_PENDING);
		NTSTATUS Add(PIRP pIrp);
		PIRP Remove();
		PIRP RemoveByPointer(PIRP pIrp);
		ULONG RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue);
		ULONG RemoveAll(CTempIrpQueue *pTempIrpQueue);
		void CancelIrp(PIRP pIrp);
		void CancelByFileObject(PFILE_OBJECT pFileObject);
		void CancelAll(NTSTATUS NtStatus = STATUS_CANCELLED);
		
		//Flags for constructor
		static const int CANCEL_IRPS_ON_DELETE;	//= 0x00000001;
		static const int PRESERVE_QUEUE_ORDER;	//= 0x00000002;
		static const int LIFO_QUEUE_ORDER;		//= 0x00000004;

	private:
		//The real cancel routine
		void CancelRoutine(PIRP pIrp);
		//Implementation sans spin locks
		NTSTATUS AddImpl(PIRP pIrp, KIRQL OldIrql);
		PIRP RemoveImpl();
		PIRP RemoveByPointerImpl(PIRP pIrp);
		ULONG RemoveByFileObjectImpl(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue);
		ULONG RemoveAllImpl(CTempIrpQueue *pTempIrpQueue);
		
		
		LIST_ENTRY			m_QueueHead;
		KSPIN_LOCK			m_QueueLock;
		int					m_iFlags;
		PFN_DEC_IRP_COUNT	m_pfnDecIrpCount;
		PVOID				m_pvContext;
};


//
//
//	@class CShareIrpQueueSpinLock | Allows sharing of SpinLock from CGuardedIrpQueue
//
//	@topic Using CShareIrpQueueSpinLock |
//			** Should only be instantiated on the stack.
//			** A single instance should be used by only one thread. i.e. no static instances
//			** Inside a single function, do not CGuardedIrpQueue's accessor, rather
//			** use the interface provided by CShareIrpQueueSpinLock
//
class CShareIrpQueueSpinLock
{
	public:
		CShareIrpQueueSpinLock(CGuardedIrpQueue *pIrpQueue) : 
			m_pIrpQueue(pIrpQueue),
			m_fIsHeld(FALSE)
			#if (DBG==1)
			,m_debug_ThreadContext(KeGetCurrentThread())
			#endif
			{}
		~CShareIrpQueueSpinLock()
		{
			ASSERT(!m_fIsHeld && "You must release (or AddAndRelease) the spin lock before this instance goes of scope!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack" );
		}
		//Functions to access mutex
		void Acquire()
		{
			ASSERT(!m_fIsHeld &&  "An attempt to acquire a spin lock twice in the same thread!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld = TRUE;
			KeAcquireSpinLock(&m_pIrpQueue->m_QueueLock, &m_OldIrql);
		}
		void Release()
		{
			ASSERT(m_fIsHeld &&  "An attempt to release a spin lock that had not been acquired, (reminder: AddAndRelease also Releases)!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld = FALSE;
			KeReleaseSpinLock(&m_pIrpQueue->m_QueueLock, m_OldIrql);
		}
		//Functions to access IrpQueue
		NTSTATUS AddAndRelease(PIRP pIrp)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld=FALSE;
			return m_pIrpQueue->AddImpl(pIrp, m_OldIrql);
		}
		PIRP Remove()
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveImpl();
		}
		PIRP RemoveByPointer(PIRP pIrp)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveByPointerImpl(pIrp);
		}
		ULONG RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveByFileObjectImpl(pFileObject,pTempIrpQueue);
		}
		ULONG RemoveAll(CTempIrpQueue *pTempIrpQueue)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveAllImpl(pTempIrpQueue);
		}
	private:
		CGuardedIrpQueue *m_pIrpQueue;
		BOOLEAN			  m_fIsHeld;
		KIRQL			  m_OldIrql;
		#if (DBG==1)
		PKTHREAD		  m_debug_ThreadContext;
		#endif
};
#endif //__IrpQueue_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\irpqueue.cpp ===
#include <IrpQueue.h>
#include <winerror.h>	// For S_OK, S_FALSE, and E_UNEXPECTED

#pragma optimize("w",off)
#pragma optimize("a",off)
const int CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE	= 0x00000001;
const int CGuardedIrpQueue::PRESERVE_QUEUE_ORDER	= 0x00000002;
const int CGuardedIrpQueue::LIFO_QUEUE_ORDER		= 0x00000004;

PIRP CTempIrpQueue::Remove()
{
	
	PIRP pIrp = NULL;
	if(!IsListEmpty(&m_QueueHead))
	{
		PLIST_ENTRY pListEntry;
		if(m_fLIFO)
		{
			pListEntry = RemoveTailList(&m_QueueHead);
		}
		else
		{
			pListEntry = RemoveHeadList(&m_QueueHead);
		}
		
		//	Get the IRP from the ListEntry in the IRP
		pIrp = (PIRP)CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
	}
	return pIrp;
}

void _stdcall DriverCancel(PDEVICE_OBJECT, PIRP pIrp)
{
	CGuardedIrpQueue *pGuardedIrpQueue;
	pGuardedIrpQueue = reinterpret_cast<CGuardedIrpQueue *>(pIrp->Tail.Overlay.DriverContext[3]);
	pGuardedIrpQueue->CancelIrp(pIrp);
}

void CGuardedIrpQueue::Init(int iFlags, PFN_DEC_IRP_COUNT pfnDecIrpCount, PVOID pvContext)
{
	m_iFlags = iFlags;
	m_pfnDecIrpCount = pfnDecIrpCount;
	m_pvContext = pvContext;
	InitializeListHead(&m_QueueHead);
	KeInitializeSpinLock(&m_QueueLock);
}

void CGuardedIrpQueue::Destroy(NTSTATUS NtStatus)
{
	if(m_iFlags & CANCEL_IRPS_ON_DELETE)
	{
		CancelAll(NtStatus);
	}
	ASSERT(IsListEmpty(&m_QueueHead));
}

NTSTATUS CGuardedIrpQueue::Add(PIRP pIrp)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	return AddImpl(pIrp, OldIrql);
}
PIRP CGuardedIrpQueue::Remove()
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	PIRP pIrp = RemoveImpl();
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return pIrp;
}
PIRP CGuardedIrpQueue::RemoveByPointer(PIRP pIrp)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	pIrp = RemoveByPointerImpl(pIrp);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return pIrp;
}
ULONG CGuardedIrpQueue::RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	ULONG ulReturn = RemoveByFileObjectImpl(pFileObject, pTempIrpQueue);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return ulReturn;
}
ULONG CGuardedIrpQueue::RemoveAll(CTempIrpQueue *pTempIrpQueue)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	ULONG ulReturn = RemoveAllImpl(pTempIrpQueue);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return ulReturn;
}

NTSTATUS CGuardedIrpQueue::AddImpl(PIRP pIrp, KIRQL	OldIrql)
{
	
	BOOLEAN fCancelHere = FALSE;
	
	//	Mark incoming IRP pending
	IoMarkIrpPending(pIrp);

	//  mark IRP in DriverContext so that we can find this instance of the queue
	//	in the cancel routine
	pIrp->Tail.Overlay.DriverContext[3] = reinterpret_cast<PVOID>(this);

	//	Set our cancel routine
	IoSetCancelRoutine(pIrp, DriverCancel);

	//If the IRP was cancelled before it got to us, don't queue it, mark
	//it to cancel after we release the lock (a few lines down)
	if(pIrp->Cancel)
	{
		IoSetCancelRoutine(pIrp, NULL);
		fCancelHere = TRUE;
	}
	else
	//Queue IRP unless it was marked to cancel
	{
		//	Insert Item in Queue (items always added at the tail)
		InsertTailList(&m_QueueHead, &pIrp->Tail.Overlay.ListEntry);
	}
	
	//Release spin lock
	KeReleaseSpinLock(&m_QueueLock, OldIrql);

	//If it had been marked for cancel, do it here
	if(fCancelHere)
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
		return STATUS_CANCELLED;
	}
	
	//	return Pending as we have queued the IRP
	return STATUS_PENDING;
}

PIRP CGuardedIrpQueue::RemoveImpl()
{
	KIRQL		OldIrql;
	PIRP		pReturnIrp = NULL;
	PLIST_ENTRY	pListEntry;

	//	Skip getting the IRP and all, if queue is empty
	if(!IsListEmpty(&m_QueueHead))
	{
		//Remove head or tail depending on LIFO or FIFO (we always add to the tail)
		if(m_iFlags & LIFO_QUEUE_ORDER)
		{
			pListEntry = RemoveTailList(&m_QueueHead);
		}
		else
		{
			pListEntry = RemoveHeadList(&m_QueueHead);
		}
		
		//	Get the IRP from the ListEntry in the IRP
		pReturnIrp = (PIRP)CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

		// Unset the cancel routine
		IoSetCancelRoutine(pReturnIrp, NULL);
	}

	//	Return the IRP, or NULL if there weren't any
	return pReturnIrp;
}

PIRP CGuardedIrpQueue::RemoveByPointerImpl(PIRP pIrp)
{

	PIRP		pFoundIrp = NULL;
	PIRP		pCurrentIrp;
	PLIST_ENTRY	pCurrentListEntry;
	PLIST_ENTRY	pQueueFirstItem = NULL;

	//	Pop IRPs off the queue and put them back until we find it
	if( !IsListEmpty(&m_QueueHead) )
	{
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pQueueFirstItem = pCurrentListEntry;
		do{
			//Get the IRP from the entry
			pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
			
			//Check for match
			if(pCurrentIrp == pIrp)
			{
				
				ASSERT(!pFoundIrp); //serious error, means IRP was in queue twice
				pFoundIrp = pCurrentIrp;

				//clear the cancel routine (do it here, as we still have the spin lock)
				IoSetCancelRoutine(pFoundIrp, NULL);
						
				// If we need to preserve the queue order,
				// keep removing and adding until we are through the list once
				if( m_iFlags & PRESERVE_QUEUE_ORDER )
				{
					//If the list is now empty we are done
					if(IsListEmpty(&m_QueueHead))
					{
						break;
					}
					
					//	The found entry is not going, back in the list
					//	so if it was first, it no longer is.
					if(pQueueFirstItem == pCurrentListEntry)
					{
						pQueueFirstItem = NULL;
					}

					//Get the next IRP
					pCurrentListEntry = RemoveHeadList(&m_QueueHead);
					pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
					ASSERT(pFoundIrp != pCurrentIrp); //serious error, means IRP was in queue twice
				
					//If the first item is NULL (four line up), this new entry is it
					if(!pQueueFirstItem)
					{
						pQueueFirstItem = pCurrentListEntry;
					}
				}
				//If the order does not need to be preserved, we are done
				else
				{
					break;
				}
			}
			
			//This next item cannot be a match, if it was we
			//have moved on to the next one already

			//	Put the IRP back in the queue
			InsertTailList(&m_QueueHead, pCurrentListEntry);
			
			//	Get the next item (no need to check if list is empty,
			//	we just put an item in
			pCurrentListEntry = RemoveHeadList(&m_QueueHead);

			//check if done
			if (pCurrentListEntry == pQueueFirstItem)
			{
				//put it back, if we are done.
				InsertHeadList(&m_QueueHead, pCurrentListEntry);
				//Mark as NULL, so that we do not iterate again
				pCurrentListEntry = NULL;
			}
			
		} while (pCurrentListEntry);
	}

	//Return the IRP we found, or NULL if it was not in the Queue
	return pFoundIrp;
}

ULONG CGuardedIrpQueue::RemoveByFileObjectImpl(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
{

	PIRP				pCurrentIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PLIST_ENTRY			pCurrentListEntry;
	PLIST_ENTRY			pQueueFirstItem = NULL;
	PLIST_ENTRY			pTempQueueListEntry;
	ULONG				ulMatchCount=0;
	
	//Get the list entry from the temp queue
	pTempQueueListEntry = &pTempIrpQueue->m_QueueHead;
	pTempIrpQueue->m_fLIFO = m_iFlags & LIFO_QUEUE_ORDER;

	//	Pop IRPs off the queue and put them back until we find it
	if( !IsListEmpty(&m_QueueHead) )
	{
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pQueueFirstItem = pCurrentListEntry;
		do{

			//Get the IRP from the entry
			pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
			
			//Get the Stack Location
			pIrpStack = IoGetCurrentIrpStackLocation(pCurrentIrp);
	
			//Check for matching file object
			if(pIrpStack->FileObject == pFileObject)
			{
				//Increment match count
				ulMatchCount++;

				//clear the cancel routine
				IoSetCancelRoutine(pCurrentIrp, NULL);
				
				//Move it over to the simple queue
				InsertTailList(pTempQueueListEntry, pCurrentListEntry);
				
				//If the list is empty we are done
				if( IsListEmpty(&m_QueueHead) )
				{
					break;
				}
				//If it was the first item in the list, it is no longer
				if(pQueueFirstItem == pCurrentListEntry)
				{
					pQueueFirstItem = NULL;
				}
	
				//setup for next iteration
				pCurrentListEntry = RemoveHeadList(&m_QueueHead);
								
				//If it was the first item in the list, it is no longer
				if(!pQueueFirstItem)
				{
					pQueueFirstItem = pCurrentListEntry;
				}
			}
			else
			{
				//	Put the IRP back in the queue
				InsertTailList(&m_QueueHead, pCurrentListEntry);
				
				//	Get the next item (no need to check if list is empty,
				//	we just put an item in)
				pCurrentListEntry = RemoveHeadList(&m_QueueHead);

				//check if done
				if (pCurrentListEntry == pQueueFirstItem)
				{
					//put it back, if we are done.
					InsertHeadList(&m_QueueHead, pCurrentListEntry);
					//Mark as NULL, so that we do not iterate again
					pCurrentListEntry = NULL;
				}
			}
		} while (pCurrentListEntry);
	}

	//Return the IRP we found, or NULL if it was not in the Queue
	return ulMatchCount;
}

ULONG CGuardedIrpQueue::RemoveAllImpl(CTempIrpQueue *pTempIrpQueue)
{
	PLIST_ENTRY			pCurrentListEntry;
	PIRP				pCurrentIrp;
	PLIST_ENTRY			pTempQueueListEntry;
	ULONG				ulCount=0;
	
	//Get a pointer to the simple queue's list entry
	pTempQueueListEntry = &pTempIrpQueue->m_QueueHead;
	pTempIrpQueue->m_fLIFO = m_iFlags & LIFO_QUEUE_ORDER;
	
	//Move all the items
	while(!IsListEmpty(&m_QueueHead))
	{
		ulCount++;
		//Get next IRP
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
		
		//Clear the cancel routine
		IoSetCancelRoutine(pCurrentIrp, NULL);

		//Move to other list
		InsertTailList(pTempQueueListEntry, pCurrentListEntry);
	}

	//return count
	return ulCount;
}

void CGuardedIrpQueue::CancelIrp(PIRP pIrp)
{
	PIRP pFoundIrp = RemoveByPointer(pIrp);
	
	//Release the cancel lock
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	//If the IRP was found cancel it and decrement IRP count
	if(pFoundIrp)
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}

void CGuardedIrpQueue::CancelByFileObject(PFILE_OBJECT pFileObject)
{
	
	CTempIrpQueue TempIrpQueue;
	PIRP pFoundIrp;

	//Get all the IRP's to cancel
	RemoveByFileObject(pFileObject, &TempIrpQueue);
			
	//If the IRP was found cancel it and decrement IRP count
	while(pFoundIrp = TempIrpQueue.Remove())
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}

void CGuardedIrpQueue::CancelAll(NTSTATUS NtStatus)
{
	CTempIrpQueue TempIrpQueue;
	PIRP pFoundIrp;

	//Get all the IRP's to cancel
	RemoveAll(&TempIrpQueue);
			
	//If the IRP was found cancel it and decrement IRP count
	while(pFoundIrp = TempIrpQueue.Remove())
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\internalpoll.h ===
//
//	@struct GCK_FILE_OPEN_ITEM | Status of open file handles.
//
typedef struct tagGCK_FILE_OPEN_ITEM
{
	BOOLEAN				fReadPending;					// @field TRUE if read is pending to driver
	BOOLEAN				fConfirmed;						// @field TRUE means that the lower driver has already completed the open
	ULONG				ulAccess;						// @field represents permissions this was opened with
	USHORT				usSharing;						// @field represents sharing under which this was opened
	FILE_OBJECT			*pFileObject;					// @field Pointer to file object which this status describes
	struct tagGCK_FILE_OPEN_ITEM	*pNextOpenItem;		// @field Next structure in Linked List
} GCK_FILE_OPEN_ITEM, *PGCK_FILE_OPEN_ITEM;

typedef struct _SHARE_STATUS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    //ULONG Deleters;	//We are driver without delete symantics
    ULONG SharedRead;
    ULONG SharedWrite;
    //ULONG SharedDelete; //We are driver without delete symantics
} SHARE_STATUS, *PSHARE_STATUS;

//
//	@struct GCK_INTERNAL_POLL | Information needed for the iternal polling routines
//
typedef struct tagGCK_INTERNAL_POLL
{
	KSPIN_LOCK			InternalPollLock;			// @field SpinLock to serialize access to this structue (not all items require it)
	FILE_OBJECT			*pInternalFileObject;		// @field Pointer to File Object that was created for internal polls
	PGCK_FILE_OPEN_ITEM	pFirstOpenItem;				// @field Head of linked list of GCK_FILE_OPEN_ITEMs for open files
	SHARE_STATUS		ShareStatus;				// @field Keeps track of file sharing.
//	BOOLEAN				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
	LONG				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
    PIRP				pPrivateIrp;				// @field IRP we reuse to send Read IRPs to lower driver
    PUCHAR				pucReportBuffer;			// @field Buffer for getting Report with pPrivateIrp
	ULONG				ulInternalPollRef;			// @field Reference to internal polls
	PKTHREAD			InternalCreateThread;		// @field Used to figure out if a create is for the internal file object
	BOOLEAN				fReady;						// @field TRUE whenever the internal polling module is good to go.
} GCK_INTERNAL_POLL, *PGCK_INTERNAL_POLL;


NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_ApproveReadIrp
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP
);

NTSTAUTS
GCK_IP_ReadApprovalComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );
);

NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt, 
);

NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
);

NTSTATUS
GCK_IP_ReadComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );


NTSTATUS
GCK_IP_Init
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\setdebuglevel.c ===
#include <wdm.h>
#include "gckshell.h"
#include "debug.h"

#if (DBG==1)

extern ULONG GCK_CTRL_C;
extern ULONG GCK_CTRL_IOCTL_C;
extern ULONG GCK_FILTER_CPP;
extern ULONG GCK_FILTERHOOKS_CPP;
extern ULONG GCK_FLTR_C;
extern ULONG GCK_FLTR_PNP_C;
extern ULONG GCK_GCKSHELL_C;
extern ULONG GCK_REMLOCK_C;
extern ULONG GCK_SWVB_PNP_C;
extern ULONG GCK_SWVBENUM_C;
extern ULONG GCK_SWVKBD_C;
extern ULONG CIC_ACTIONS_CPP;
extern ULONG CIC_CONTROLITEMCOLLECTION_CPP;
extern ULONG CIC_CONTROLITEM_CPP;
extern ULONG CIC_DEVICEDESCRIPTIONS_CPP;
extern ULONG CIC_DUALMODE_CPP;
//extern ULONG CIC_DUMPCOMMANDBLOCK_CPP;
extern ULONG CIC_LISTASARRAY_CPP;


void SetDebugLevel(ULONG ulModuleId, ULONG ulDebugLevel)
{
	switch(ulModuleId)
	{
		case MODULE_GCK_CTRL_C:
			GCK_CTRL_C = ulDebugLevel;
			break;
		case MODULE_GCK_CTRL_IOCTL_C:
			GCK_CTRL_IOCTL_C = ulDebugLevel;
			break;
		case MODULE_GCK_FILTER_CPP:
			GCK_FILTER_CPP = ulDebugLevel;
			break;
		case MODULE_GCK_FILTERHOOKS_CPP:
			GCK_FILTERHOOKS_CPP = ulDebugLevel;
			break;
		case MODULE_GCK_FLTR_C:
			GCK_FLTR_C = ulDebugLevel;
			break;
		case MODULE_GCK_FLTR_PNP_C:
			GCK_FLTR_PNP_C = ulDebugLevel;
			break;
		case MODULE_GCK_GCKSHELL_C:
			GCK_GCKSHELL_C = ulDebugLevel;
			break;
		case MODULE_GCK_REMLOCK_C:
			GCK_REMLOCK_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVB_PNP_C:
			GCK_SWVB_PNP_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVBENUM_C:
			GCK_SWVBENUM_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVKBD_C:
			GCK_SWVKBD_C = ulDebugLevel;
			break;
		case MODULE_CIC_ACTIONS_CPP:
			CIC_ACTIONS_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_CONTROLITEMCOLLECTION_CPP:
			CIC_CONTROLITEMCOLLECTION_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_CONTROLITEM_CPP:
			CIC_CONTROLITEM_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_DEVICEDESCRIPTIONS_CPP:
			CIC_DEVICEDESCRIPTIONS_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_DUALMODE_CPP:
			CIC_DUALMODE_CPP = ulDebugLevel;
			break;
//		case MODULE_CIC_DUMPCOMMANDBLOCK_CPP:
//			CIC_DUMPCOMMANDBLOCK_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_LISTASARRAY_CPP:
			CIC_LISTASARRAY_CPP = ulDebugLevel;
			break;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvbenum.h ===
//	@doc
/**********************************************************************
*
*	@module	SWVBENUM.h	|
*
*	Header file for SideWinde Virtual Bus Enumerator
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@xref SWBENUM.C
*
**********************************************************************/

//---------------------------------------------------------------------
//	Structures required for Virtual Bus
//---------------------------------------------------------------------

//
//	@struct SWVB_GLOBALS |
//	Global variables belonging to the Virtual Bus
//	Basic info, such as the PDO and FDO of the bus itself,
//	which is really a HID PDO, and a filter (not function) Device 
//	Object which is letting us use it also as a Bus FDO.
//
typedef struct tagSWVB_GLOBALS
{
	PDEVICE_OBJECT		pBusFdo;						//@field Pointer to Fdo to use as BUS
	PDEVICE_OBJECT		pBusPdo;						//@field Pointer to Pdo to use as BUS
	ULONG				ulDeviceRelationsAllocCount;	//@field Allocated count for device relations
	PDEVICE_RELATIONS	pDeviceRelations;				//@field Device Relations holds PDOs on bus
	ULONG				ulDeviceNumber;					//@field Used to name devices
}	SWVB_GLOBALS, *PSWVB_GLOBALS;

//
//	@struct SWVB_DEVICE_SERVICE_TABLE |
//	Service table that Virtual Device Module
//	gives to Virtual Bus on the <f SWVB_Expose>
//	call.  The PnP entries are only if the Virtual
//	Device needs additional processing for these.  Particularly,
//	remove if anything in the Virtual Device part of the extension
//	is dynamically allocated.  The usual malarkey is handled by the
//	SWVBENUM code.
//
typedef struct tagSWVB_DEVICE_SERVICE_TABLE
{
	PDRIVER_DISPATCH pfnCreate;		//@field Entry point IRP_MJ_CREATE
	PDRIVER_DISPATCH pfnClose;		//@field Entry point IRP_MJ_CLOSE
	PDRIVER_DISPATCH pfnRead;		//@field Entry point IRP_MJ_READ
	PDRIVER_DISPATCH pfnWrite;		//@field Entry point IRP_MJ_WRITE
	PDRIVER_DISPATCH pfnIoctl;		//@field Entry point IRP_MJ_IOCTL
	PDRIVER_DISPATCH pfnStart;		//@field Entry point IRP_MJ_PNP\IRP_MN_START
	PDRIVER_DISPATCH pfnStop;		//@field Entry point IRP_MJ_PNP\IRP_MN_STOP
	PDRIVER_DISPATCH pfnRemove;		//@field Entry point IRP_MJ_PNP\IRP_MN_REMOVE
}	SWVB_DEVICE_SERVICE_TABLE, *PSWVB_DEVICE_SERVICE_TABLE;

typedef NTSTATUS (*PFN_GCK_INIT_DEVICE)(PDEVICE_OBJECT pDeviceObject, ULONG ulInitContext);

//
//	@struct SWVB_EXPOSE_DATA |
//	Data that must be passed on calls to <f GCK_SWVB_Expose>
//
typedef struct tagSWVB_EXPOSE_DATA
{
	ULONG						ulDeviceExtensionSize;	// @field [in] Size of extension needed by virtual device
	PSWVB_DEVICE_SERVICE_TABLE	pServiceTable;			// @field [in] Pointer to service table of virtual device
	PWCHAR						pmwszDeviceId;			// @field [in] HardwareID for new device, without enumerator name
	PFN_GCK_INIT_DEVICE			pfnInitDevice;			// @field [in] Callback to initialize new Device Object
	ULONG						ulInitContext;			// @field [in] COntext for pfnInitDevice
	ULONG						ulInstanceNumber;		// @field [in] Instance Number of new device
} SWVB_EXPOSE_DATA, *PSWVB_EXPOSE_DATA;

//
//	@struct SWVB_PDO_EXT |
//	Device Extensions for PDOs created by the SWVB
//	Appended to this extension is the device extension
//	size requested by the virtual device module
//	in the <f SWVB_Expose> call.
typedef struct tagSWVB_PDO_EXT
{
	ULONG	ulGckDevObjType;					// @field Type of GcKernel device object.
	BOOLEAN fStarted;							// @field Marks that Virtual Device is started
	BOOLEAN	fRemoved;							// @field Marks that Virtual Device is removed
	BOOLEAN	fAttached;							// @field The device is attached as long as we say it is.
	PSWVB_DEVICE_SERVICE_TABLE	pServiceTable;	// @field Service Table for virtual device
	GCK_REMOVE_LOCK RemoveLock;					// @field Custom Remove Lock
	PWCHAR	pmwszHardwareID;					// @field HardwareID of device
	ULONG	ulInstanceNumber;					// @field Instance number
	ULONG	ulOpenCount;						// @field Count of open handles
}SWVB_PDO_EXT,	*PSWVB_PDO_EXT;

//
//	Accessor for instance number of PSWVB_PDO_EXT
//
inline ULONG GCK_SWVB_GetInstanceNumber(PDEVICE_OBJECT pDeviceObject)
{
	PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pDeviceObject->DeviceExtension;
	ASSERT(GCK_DO_TYPE_SWVB ==	pPdoExt->ulGckDevObjType);
	return pPdoExt->ulInstanceNumber;
}

//---------------------------------------------------------------------------
// Error Codes specific to SWVB
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//	Macros
//---------------------------------------------------------------------------

//
//	@func PVOID | SWVB_GetVirtualDeviceExtension |
//		  Accesses Device Extension of PDO exposed on the SWVB.
//	@rdesc Returns pointer to Virtual Device Part of DeviceExtension	  
//	@parm PDEVICE_OBJECT | [in] pDeviceObject |
//		  Pointer to DeviceObject to get extension from.
//	@comm Implemented as MACRO.
//		   		
#define GCK_SWVB_GetVirtualDeviceExtension(__pDeviceObject__) \
		(\
			(PVOID)\
			(\
				(PCHAR)\
				( (__pDeviceObject__)->DeviceExtension )\
				+ sizeof(SWVB_PDO_EXT)\
			)\
		)

//---------------------------------------------------------------------------
//	#define strings
//---------------------------------------------------------------------------
#define SWVB_DEVICE_NAME_BASE	L"\\Device\\SideWinderVirtualDevicePdo_000"
#define SWVB_DEVICE_NAME_TMPLT	L"\\Device\\SideWinderVirtualDevicePdo_%0.3x"
#define SWVB_BUS_ID				L"SWVBENUM\\"
#define SWVB_HARDWARE_ID_TMPLT	L"SWVBENUM\\%s"
#define SWVB_INSTANCE_EXT		L"_000"
#define SWVB_INSTANCE_ID_TMPLT	L"%s_%0.3d"

//---------------------------------------------------------------------------
//  General entry points defined in GckShell.h
//---------------------------------------------------------------------------
#ifndef __gckshell_h__
#include "gckshell.h"
#endif

//---------------------------------------------------------------------------
// Function declarations - autodoc comments in .c file
//---------------------------------------------------------------------------
extern "C"
{
NTSTATUS
GCK_SWVB_SetBusDOs
(
	IN PDEVICE_OBJECT pBusFdo,
	IN PDEVICE_OBJECT pBusPdo
);

NTSTATUS
GCK_SWVB_HandleBusRelations
(
	IN OUT PIO_STATUS_BLOCK		pIoStatus
);
		
NTSTATUS
GCK_SWVB_Expose
(
	IN PSWVB_EXPOSE_DATA pSwvbExposeData
);

NTSTATUS
GCK_SWVB_Remove
(
	IN PDEVICE_OBJECT	pPdo
);

ULONG
MultiSzWByteLength
(
	PWCHAR pmwszBuffer
);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvmouse.cpp ===
//	@doc
/*******************************************************************
*
*	@module	SWVMOUSE.cpp	|
*
*	Implementation of the SideWinder Virtual Mouse
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1999 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	This module implements the SideWinder Virtual Mouse
*	which is used to report Joystick Axes as mouse axes.
*	Also is used for stuffing mouse clicks.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVMOUSE_C

extern "C" {
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include "hidtoken.h"
	#include "hidusage.h"
	#include "hidport.h"
	#include "remlock.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}

#include "SWVBENUM.h"
#include "SWVMOUSE.h"
#include <stdio.h>

//PDRIVER_OBJECT	g_pDriverObject;

//
//	These keep track of the next instance number
//	g_ulInstanceBits is a bit field.  A device holds an instance number
//	by setting a bit, and clearing when it is destroyed.  This only works
//	for the first 32 devices (i.e. 99.99% of the time).  The 33rd device
//	goes into the overflow.  Instance numbers in the overflow are not recovered.
//	With 33 devices plugged in, plugging and unplugging the 33rd device will cause
//	the instances of devices in the registry to profilerate.  No real harm is done,
//	it is just ugly, but this is a highly unlikely scenario.
//
static ULONG g_ulInstanceBits;
static ULONG g_ulInstanceOverflow;
//---------------------------------------------------------------------
// Tables that define device characteristics and/or entry points
//---------------------------------------------------------------------

// Service table used by Virtual Bus Module to call into Virtual Mouse
SWVB_DEVICE_SERVICE_TABLE	VMouServiceTable =
							{
								GCK_VMOU_CreateProc,
								GCK_VMOU_CloseProc,
								GCK_VMOU_ReadProc,
								GCK_VMOU_WriteProc,
								GCK_VMOU_IoctlProc,
								GCK_VMOU_StartProc,
								GCK_VMOU_StopProc,
								GCK_VMOU_RemoveProc
							};

// Constants describing device
#define	VMOU_VERSION			0x0100
#define	VMOU_COUNTRY			0x0000
#define	VMOU_DESCRIPTOR_COUNT	0x0001
#define VMOU_PRODUCT_ID			0x00FB	//BUGBUGBUG I made this up, I need to request through Rob Walker
										//BUGBUGBUG to permanently allocate one for this purpose.
	
//
//	This is pretty much copied from the HID spec Version 1 (Need to change if adding wheel support)
//
static UCHAR VMOU_ReportDescriptor[] =
				{
					0x05,0x01, //Usage Page (Generic Desktop)
					0x09,0x02, //Usage (Mouse)
					0xA1,0x01, //Collection (Application)
					0x09,0x01, //	Usage (Pointer)
					0xA1,0x00, //	Collection (Physical)
					0x05,0x09, //		Usage Page (Buttons)
					0x19,0x01, //		Usage Minimum (01)
					0x29,0x03, //		Usage Maximum (03)
					0x15,0x00, //		Logical Minimum (0)
					0x25,0x01, //		Logical Maximum (1)
					0x95,0x03, //		Report Count (3)
					0x75,0x01, //		Report Size (1)
					0x81,0x02, //		Input (Data, Variable, Absolute) - 3 button bits
					0x95,0x01, //		Report Count(1)
					0x75,0x05, //		Report Size (5)
					0x81,0x01, //		Input (Const) - 5 bit padding
					0x05,0x01, //		Usage Page (Generic Desktop)
					0x09,0x30, //		Usage(X)
					0x09,0x31, //		Usage(Y)
					0x15,0x81, //		Logical Minimum (-127)
					0x25,0x7F, //		Logical Maximum (127)
					0x75,0x08, //		Report Size (8)
					0x95,0x02, //		Report Count (2)
					0x81,0x06, //		Input (Data, Variable, Relative) - 2 Positions (X & Y)
					0xC0,	   //	End Collection
					0xC0	   //End Collection
				};

				
static	HID_DESCRIPTOR	VMOU_DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							VMOU_VERSION,
							VMOU_COUNTRY,
							VMOU_DESCRIPTOR_COUNT,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(VMOU_ReportDescriptor)}
							};


/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING pRegistryPath)
**
**	@func	Stows the Driver Object for later
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,	//@parm Driver Object
    IN PUNICODE_STRING pRegistryPath	//@parm Registry path for this driver
    )
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_DriverEntry\n"));
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pRegistryPath);
//	g_pDriverObject = pDriverObject;
	g_ulInstanceBits = 0x0;
	g_ulInstanceOverflow = 32; //For 33 and more devices
	return STATUS_SUCCESS;
}
	
/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_Create(OUT PDEVICE_OBJECT *ppDeviceObject)
**
**	@func	Creates a new Virtual Mouse
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject //@parm [out] Device Object of new virtual keyboard
)
{	
	NTSTATUS	NtStatus;
	SWVB_EXPOSE_DATA	SwvbExposeData;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Create *ppDeviceObject = 0x%0.8x\n", *ppDeviceObject));
	
	//Fill out SWVB_EXPOSE_DATA structure
	SwvbExposeData.pmwszDeviceId=L"SideWinderVirtualMouse\0\0";
	SwvbExposeData.pServiceTable = &VMouServiceTable ;
	SwvbExposeData.ulDeviceExtensionSize = sizeof(GCK_VMOU_EXT);
	SwvbExposeData.ulInitContext = (ULONG)ppDeviceObject;
	SwvbExposeData.pfnInitDevice = &GCK_VMOU_Init;

	//Get the instance ID
	ULONG ulBitMask;
	ULONG ulIndex;
	for(ulIndex = 0, ulBitMask = 1; ulIndex < 32; ulBitMask <<= 1, ulIndex++)
	{
		if(ulBitMask & ~g_ulInstanceBits)
		{
			g_ulInstanceBits |= ulBitMask;
			SwvbExposeData.ulInstanceNumber	= ulIndex;
			break;
		}
	}
	if(32 == ulIndex) 
	{
		SwvbExposeData.ulInstanceNumber = g_ulInstanceOverflow++;
	}
		
	//Call virtual bus to expose virtual mouse
	NtStatus=GCK_SWVB_Expose(&SwvbExposeData);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_Init(	IN PDEVICE_OBJECT pDeviceObject, IN ULONG ulInitContext)
**
**	@func	Callback for Initializing new device object.  The ulInitContext
**			is a pointer to a pointer to a device object, so that we can pass
**			the pointer to the device object back to the caller of create.
**	@rdesc	STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
)
{
	PGCK_VMOU_EXT pDevExt;
	PDEVICE_OBJECT *ppSaveDeviceObject;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Init pDeviceObject = 0x%0.8x\n", pDeviceObject));

	//Create sent us a pointer to a PDEVICE_OBJECT in which to return the new device object
	ppSaveDeviceObject = (PDEVICE_OBJECT *)ulInitContext;
	*ppSaveDeviceObject = pDeviceObject;
	
	//Get out part of the device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	//Mark device as stopped
	pDevExt->ucDeviceState= VMOU_STATE_STOPPED;
	
	//Mark the circular buffer as empty
	pDevExt->usReportBufferPos=0;
	pDevExt->usReportBufferCount=0;
	
	//Initialize locks
	GCK_InitRemoveLock(&pDevExt->RemoveLock, "SWVMOU_LOCK");

	//Initialize IrpQueue
	pDevExt->IrpQueue.Init(	CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE |
							CGuardedIrpQueue::PRESERVE_QUEUE_ORDER,
							(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
							&pDevExt->RemoveLock);

	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_Close(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Closes the virtual mouse (removes it!)
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Close
(
	IN PDEVICE_OBJECT pDeviceObject
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Close pDeviceObject = 0x%0.8x\n", pDeviceObject));
	
	//Tell the virtual bus to kill us
	return GCK_SWVB_Remove(pDeviceObject);
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_SendReportPacket(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Stuff a report into the circular buffer, and completes
**			an IRP if one is pending.
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VMOU_REPORT_PACKET pReportPacket
)
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_SendReportPacket pDeviceObject = 0x%0.8x, pReportPacket = 0x%0.8x\n", pDeviceObject, pReportPacket));

	USHORT usBufferIndex;
	PGCK_VMOU_EXT pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	//
	//	Step 1. Stuff new packet into buffer
	//

	// Acquire Lock to work with buffer 
	IrpQueueWithSharedSpinLock.Acquire();
		

	//Find position in buffer to stuff at
	usBufferIndex = (pDevExt->usReportBufferPos + pDevExt->usReportBufferCount)%GCK_VMOU_STATE_BUFFER_SIZE;

	//Copy data
	pDevExt->rgReportBuffer[usBufferIndex] = *pReportPacket;
	
	//increment buffer count
	if(pDevExt->usReportBufferCount < GCK_VMOU_STATE_BUFFER_SIZE)
	{
		pDevExt->usReportBufferCount++;
	}
	else
	{
		//This assertion means buffer overflow
		GCK_DBG_TRACE_PRINT(("Virtual Mouse buffer overflow\n"));
		pDevExt->usReportBufferPos++;
	}
	
	
	//
	//	Step 2. Get Irp if there is one
	//
	PIRP pPendingIrp = IrpQueueWithSharedSpinLock.Remove();

	if(pPendingIrp)
	{
		//	Copy the data
		RtlCopyMemory(
			pPendingIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VMOU_REPORT_PACKET)
			);
	
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VMOU_STATE_BUFFER_SIZE;
		}
	}
	
	//We are done with the buffer spin lock
	IrpQueueWithSharedSpinLock.Release();
	
	if(pPendingIrp)
	{
		//  Fill out IRP status
		pPendingIrp->IoStatus.Information = sizeof(GCK_VMOU_REPORT_PACKET);
		pPendingIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pPendingIrp, IO_NO_INCREMENT);
		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}

	//All done
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_ReadReport(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	If there is data in the mouse buffer, completes the IRP
**			Otherwise, queues it, and set the idle timer.
**
**	@rdesc	STATUS_SUCCESS if read, STATUS_PENDING if waiting.
**
*************************************************************************************/
NTSTATUS 
GCK_VMOU_ReadReport
(
 IN PDEVICE_OBJECT pDeviceObject, 
 IN PIRP pIrp
)
{
	PGCK_VMOU_EXT pDevExt;
	PIO_STACK_LOCATION pIrpStack;
	KIRQL OldIrql;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_ReadReport pDeviceObject = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	
	//
	// Validate buffer size, because we do this the first time we see the IRP
	// we never need to worry about checking it again.
	//
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(GCK_VMOU_REPORT_PACKET))
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	//Make an IRP queue accessor to share spin lock
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	// Count the IRP we are working on
	GCK_IncRemoveLock(&pDevExt->RemoveLock);
	
	// Acquire Lock to work with mouse buffer and Irp Queue
	IrpQueueWithSharedSpinLock.Acquire();

	// If there is data, complete the IRP
	if( pDevExt->usReportBufferCount)
	{
		//	Copy the data
		RtlCopyMemory(
			pIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VMOU_REPORT_PACKET)
			);
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VMOU_STATE_BUFFER_SIZE;
		}
		
		//We are done with the buffer spin lock
		IrpQueueWithSharedSpinLock.Release();

		//  Fill out IRP status
		pIrp->IoStatus.Information = sizeof(GCK_VMOU_REPORT_PACKET);
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}
	else 
	// There is no data, so queue the IRP.
	{
		return IrpQueueWithSharedSpinLock.AddAndRelease(pIrp);
	}

	//We completed the IRP and all is fine
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_CloseProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CLOSE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	//We don't control open and close, so just succeed
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_CloseProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_CreateProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CREATE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_CreateProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_CreateProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_IoctlProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_INTERNAL_IOCTL and IRP_MJ_IOCTL requests sent from SWVB.
**			Trivial IRPs are handle here, others are delegated.
**
**	@rdesc	STATUS_SUCCESS, and various errors
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_IoctlProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	NTSTATUS NtStatus;
	PIO_STACK_LOCATION pIrpStack;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_IoctlProc\n"));
	
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrpStack->Parameters.DeviceIoControl.IoControlCode;
		
	// We complete everything, so the various cases
	// fill out status and information, and we complete
	// the IRP at the bottom.
	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_GET_PHYSICAL_DESCRIPTOR:
			pIrp->IoStatus.Information = 0;
			NtStatus =STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_ACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_DEACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			NtStatus = GCK_VMOU_GetDeviceAttributes(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			NtStatus = GCK_VMOU_GetDeviceDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			NtStatus = GCK_VMOU_GetReportDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_STRING:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;  //Should we support this?
			break;
		case IOCTL_HID_READ_REPORT:
			//	Read report will complete the IRP, or queue as it sees fit, just delegate
			return GCK_VMOU_ReadReport(pDeviceObject, pIrp);
		case IOCTL_HID_SET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_WRITE_REPORT:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		default:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
	}
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_ReadProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_READ request sent from SWVB.  We don't support this.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_ReadProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_ReadProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_StartProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_START_DEVICE request sent from SWVB.
**			Just mark that we are started.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_StartProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_StartProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as started
	pDevExt->ucDeviceState = VMOU_STATE_STARTED;

	// PnP IRPs are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_StopProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_STOP_DEVICE request sent from SWVB.
**			Just mark that we are stopped.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_StopProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_StopProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as stopped
	pDevExt->ucDeviceState = VMOU_STATE_STOPPED;

	// Cancel all I\O
	pDevExt->IrpQueue.CancelAll(STATUS_DELETE_PENDING);


	// PnP IRP are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_RemoveProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE request sent from SWVB.
**			Wait for all outstanding IO to complete before succeeding.  We don't
**			delete our device object that is up to SWVB.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_RemoveProc\n"));

	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	// Mark as Removed
	pDevExt->ucDeviceState = VMOU_STATE_REMOVED;

	//Destroy Irp Queue
	pDevExt->IrpQueue.Destroy();


	//Clear Instance Bits
	ULONG ulInstance = GCK_SWVB_GetInstanceNumber(pDeviceObject);
	if(ulInstance < 32)
	{
		g_ulInstanceBits &= ~(1 << ulInstance);
	}

	// Remove the BIAS on the RemoveLock and wait for it to go to zero (forever)
	return GCK_DecRemoveLockAndWait(&pDevExt->RemoveLock, NULL);
	
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_WriteProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_WRITE, which we don't support.  With HIDSWVD.SYS
**			as the functional driver this should never get called.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_WriteProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_WriteProc\n"));
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetDeviceDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Device Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Device Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetDeviceDescriptor\n"));
	// Check buffer size
	if(ulBufferLength < sizeof(VMOU_DeviceDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VMOU_DeviceDescriptor, sizeof(VMOU_DeviceDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VMOU_DeviceDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetReportDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_REPORT_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetReportDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Report Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Report Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetReportDescriptor\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(VMOU_ReportDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VMOU_ReportDescriptor, sizeof(VMOU_ReportDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VMOU_ReportDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetDeviceAttributes(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_ATTRIBUTES. The data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Attributes
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Attributes Copied
)
{
	PHID_DEVICE_ATTRIBUTES	pDeviceAttributes = (PHID_DEVICE_ATTRIBUTES)pvUserBuffer;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetDeviceAttributes\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(HID_DEVICE_ATTRIBUTES))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Fill out attributes structures
	pDeviceAttributes->Size = sizeof(HID_DEVICE_ATTRIBUTES);
	pDeviceAttributes->VendorID = MICROSOFT_VENDOR_ID;
	pDeviceAttributes->ProductID = VMOU_PRODUCT_ID;
	pDeviceAttributes->VersionNumber = VMOU_VERSION;
	// Record number of bytes copied
	*pulBytesCopied = sizeof(HID_DEVICE_ATTRIBUTES);
	// Return Success
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvkbd.h ===
//	@doc
/**********************************************************************
*
*	@module	SWVKBD.h	|
*
*	Declarations related to SideWinder Virtual Keyboard.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	The SideWinder Virtual Keyboard is designed to sit atop the SideWinder
*	Virtual Bus.  It is a HID device, and relies on the loading of a dummy
*	HID driver.<nl>
*
**********************************************************************/

#include "irpqueue.h"

//----------------------------------------------------------------------------------
// Virtual Keyboard structures
//----------------------------------------------------------------------------------
#define GCK_VKBD_MAX_KEYSTROKES 0x06 //HID spec. says this can be six at most.
									 //Comments in HIDPARSE code suggest that the OS
									 //supports up to fourteen.
#define GCK_VKBD_STATE_BUFFER_SIZE 0x20 //Size of circular buffer for holding on to
										//key presses.

//----------------------------------------------------------------------------------
// Device States - an alternative to five different flags
//----------------------------------------------------------------------------------
#define VKBD_STATE_STARTED			0x01
#define VKBD_STATE_STOPPED			0x02
#define VKBD_STATE_REMOVED			0x03

//
// @struct GCK_VKBD_REPORT_PACKET | 
//	The report format of the virtual keyboard. Any changes here must be
//	reflected in the report descriptor and vice-versa.		
typedef struct tagGCK_VKBD_REPORT_PACKET
{
	UCHAR	ucModifierByte;								//@field Modifier Byte
	UCHAR	rgucUsageIndex[GCK_VKBD_MAX_KEYSTROKES];	//@field List of keys that down
} GCK_VKBD_REPORT_PACKET, *PGCK_VKBD_REPORT_PACKET;

//
// @struct GCK_VKBD_EXT	|	
//	
typedef struct tagGCK_VKBD_EXT
{
	UCHAR					ucDeviceState;								//@field State of device(Started, Stopped, Removed)
	USHORT					usReportBufferCount;						//@field Count of packets in buffer
	USHORT					usReportBufferPos;							//@field Next Packet in buffer
	GCK_VKBD_REPORT_PACKET	rgReportBuffer[GCK_VKBD_STATE_BUFFER_SIZE]; //@field Buffer of pendind reports
	CGuardedIrpQueue		IrpQueue;									//@field Irp queue;
	GCK_REMOVE_LOCK			RemoveLock;									//@field RemoveLock for Outstanding IO
} GCK_VKBD_EXT, *PGCK_VKBD_EXT;

//----------------------------------------------------------------------------------
//	API for using the Virtual Keyboard
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject
);

NTSTATUS
GCK_VKBD_Close
(
	IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS
GCK_VKBD_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VKBD_REPORT_PACKET pReportPacket
);


//----------------------------------------------------------------------------------
// Driver Initialization
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
// Device Initialization
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
);

//----------------------------------------------------------------------------------
//	Entry points to handle IRPs from the Virtual Bus
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 PIRP pIrp
);

NTSTATUS
GCK_VKBD_CreateProc
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS
GCK_VKBD_IoctlProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_ReadProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_StartProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_StopProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 IN PIRP pIrp
);

NTSTATUS
GCK_VKBD_WriteProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

//------------------------------------------------------------------
// Ioctl sub-function handlers
//------------------------------------------------------------------
NTSTATUS
GCK_VKBD_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_GetReportDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_ReadReport
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_WriteToFakeLEDs
(
	IN PIRP pIrp	
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvmouse.h ===
#ifndef __swvmouse_h__
#define __swvmouse_h__
//	@doc
/**********************************************************************
*
*	@module	SWVMOUSE.H |
*
*	Declarations related to SideWinder Virtual Keyboard.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVMOUSE	|
*	The SideWinder Virtual Mouse is designed to sit atop the SideWinder
*	Virtual Bus.  It is a HID device, and relies on the loading of a dummy
*	HID driver.<nl>
*
**********************************************************************/

#include "irpqueue.h"

//----------------------------------------------------------------------------------
// Virtual Mouse structures
//----------------------------------------------------------------------------------
#define GCK_VMOU_MAX_KEYSTROKES 0x06 //HID spec. says this can be six at most.
									 //Comments in HIDPARSE code suggest that the OS
									 //supports up to fourteen.
#define GCK_VMOU_STATE_BUFFER_SIZE 0x20 //Size of circular buffer for holding on to
										//key presses.

//----------------------------------------------------------------------------------
// Device States - an alternative to five different flags
//----------------------------------------------------------------------------------
#define VMOU_STATE_STARTED			0x01
#define VMOU_STATE_STOPPED			0x02
#define VMOU_STATE_REMOVED			0x03

//
// @struct GCK_VMOU_REPORT_PACKET | 
//	The report format of the virtual keyboard. Any changes here must be
//	reflected in the report descriptor and vice-versa.		
typedef struct tagGCK_VMOU_REPORT_PACKET
{
	UCHAR	ucButtons;	//@field Button Byte (3 lsb are used)
	UCHAR	ucDeltaX;	//@field Delta X
	UCHAR	ucDeltaY;	//@field Delta Y
} GCK_VMOU_REPORT_PACKET, *PGCK_VMOU_REPORT_PACKET;

//
// @struct GCK_VMOU_EXT	|	
//	
typedef struct tagGCK_VMOU_EXT
{
	UCHAR					ucDeviceState;								//@field State of device(Started, Stopped, Removed)
	USHORT					usReportBufferCount;						//@field Count of packets in buffer
	USHORT					usReportBufferPos;							//@field Next Packet in buffer
	GCK_VMOU_REPORT_PACKET	rgReportBuffer[GCK_VMOU_STATE_BUFFER_SIZE]; //@field Buffer of pendind reports
	CGuardedIrpQueue		IrpQueue;									//@field Irp queue;
	GCK_REMOVE_LOCK			RemoveLock;									//@field Custom Remove Lock
} GCK_VMOU_EXT, *PGCK_VMOU_EXT;

//----------------------------------------------------------------------------------
//	API for using the Virtual Keyboard
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject
);

NTSTATUS
GCK_VMOU_Close
(
	IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS
GCK_VMOU_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VMOU_REPORT_PACKET pReportPacket
);


//----------------------------------------------------------------------------------
// Driver Initialization
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
// Device Initialization
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
);

//----------------------------------------------------------------------------------
//	Entry points to handle IRPs from the Virtual Bus
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 PIRP pIrp
);

NTSTATUS
GCK_VMOU_CreateProc
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS
GCK_VMOU_IoctlProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_ReadProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_StartProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_StopProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 IN PIRP pIrp
);

NTSTATUS
GCK_VMOU_WriteProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

//------------------------------------------------------------------
// Ioctl sub-function handlers
//------------------------------------------------------------------
NTSTATUS
GCK_VMOU_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_GetReportDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_ReadReport
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

VOID
GCK_VMOU_CancelReadReportIrp
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

#endif //__swvmouse_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvbenum.cpp ===
//	@doc
/**********************************************************************
*
*	@module	SWVBENUM.cpp |
*
*	SideWinder Virtual Bus Enumerator
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*	@index SideWinder Virtual Bus | SWVBENUM
*
*	@topic	SWVBENUM |
*	This module implements the SideWinder Virtual Bus.
*	The bus is nothing more than attaching this code on top of
*	a FilterDO of a raw HID PDO, for the purpose of adding DevNodes
*	for a virtual keyboard, virtual mouse, and the future virtual
*	mixed devices.  All of these devices are expected to be HID
*	devices.<nl>
*
*	The function driver for these devices the SWVBHID.sys (SideWinder
*	Virtual Bus - HID).  This driver is a HID mini-driver, however
*	all IRPs are simply passed down to their PDO's, i.e. this
*	code.<nl>
*	
*	The code in this module is independent of the functionality
*	of the virtual devices.  Basically all Power and PnP IRPs
*	are handled here.  All IRP_MJ_READ, IRP_MJ_WRITE,
*	IRP_MJ_INTERNAL_IOCTL, and IRP_MJ_IOCTL entries are delegated
*	via service table provided in the expose call to this module
*	and stored in the device extension to a code module
*	in this driver representing the device.<nl>
*	
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVBENUM_C

extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include <stdio.h>
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));
}
#include "SWVBENUM.h"

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_SWVB_DriverEntry)
#endif

// @globalv	Globals for SWVB module
SWVB_GLOBALS	SwvbGlobals;

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_DriverEntry
**
**	@func	Initializes SWVB module.  In particular the globals.
**
**	@rdesc	Returns STATUS_SUCCESS always.
**
**	@comm	Called by DriverEntry of main filter.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm DriverObject for module
	IN PUNICODE_STRING puniRegistryPath	// @parm Registry Path
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_DriverEntry\n"));
	
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(puniRegistryPath);
	SwvbGlobals.pBusFdo=NULL;
	SwvbGlobals.pBusPdo=NULL;
	SwvbGlobals.pDeviceRelations=NULL;
	SwvbGlobals.ulDeviceRelationsAllocCount=0;
	SwvbGlobals.ulDeviceNumber=0;
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_DriverEntry\n"));
	return STATUS_SUCCESS;
}

VOID
GCK_SWVB_UnLoad()
{
	if(SwvbGlobals.pDeviceRelations)
	{
		ExFreePool(SwvbGlobals.pDeviceRelations);
		SwvbGlobals.pDeviceRelations = NULL;
	}
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_SetBusDOs
**
**	@func	Sets the Device Object (PDO and FDO), to use as the base of the
**			SideWinder Virtual Bus.
**
**	@rdesc	S_OK on success
**
**	@comm	A real device is needed on the system in order to
**			support the	virtual device.  When the first such device is detected,
**			this function is called to set the filter device object of that
**			device to be the Fdo of the SWVB, and its Pdo to be the Pdo of the bus.
**			If that device object is removed, this function can be called to move
**			the SWVB unto another physical device, or it can be called with NULL
**			for both arguments to remove the SWVB.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_SetBusDOs
(
	IN PDEVICE_OBJECT pBusFdo,	// @parm [in] Pointer to Fdo (Filter Device Object - actually)
	IN PDEVICE_OBJECT pBusPdo	// @parm [in] Pointer to Pdo
)
{
	PDEVICE_OBJECT pOldBusFdo;
	PDEVICE_OBJECT pOldBusPdo;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_SetBusDOs\n"));
	
	// Save old Bus DO info
	pOldBusFdo = SwvbGlobals.pBusFdo;
	pOldBusPdo = SwvbGlobals.pBusPdo;

	// Update Bus DO info
	SwvbGlobals.pBusFdo = pBusFdo;
	SwvbGlobals.pBusPdo = pBusPdo;

	// Invalidate the old and the new pBusPdo's - iff
	// (they exist && there is at least one device on the bus)
	// This will fire up the PnP system and cause it to re-detect
	// everything.

	if(SwvbGlobals.pDeviceRelations && SwvbGlobals.pDeviceRelations->Count)
	{
		if(pOldBusPdo)
		{
			IoInvalidateDeviceRelations(pOldBusPdo, BusRelations);
		}
		if(SwvbGlobals.pBusPdo)
		{
			IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
		}
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_SetBusDOs\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_HandleBusRelations
**
**	@func	Handles queries for the BusRelations on behalf of the filter device object,
**			which the SWVB is sitting on.  Basically all we need do is copy over
**			over our device relations, being cognizant that someone may layer on top
**			of us and possibly has added stuff already.
**	@rdesc	Same as in the IoStatus and appropriate to return.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_HandleBusRelations
(
	IN OUT PIO_STATUS_BLOCK	pIoStatus // @parm [out] IoStatus block is filled out by this routine. 
)
{
	ULONG				ulTotalCount;
	PDEVICE_RELATIONS	pExistingRelations;
	PDEVICE_RELATIONS	pDeviceRelations;
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_HandleBusRelations. pIoStatus = 0x%0.8x\n", pIoStatus));	

	// Copy the count of what we know about
	ulTotalCount = SwvbGlobals.pDeviceRelations->Count;

	GCK_DBG_TRACE_PRINT(("We have %d PDOs\n", ulTotalCount));
	
	// Read existing relations
	pExistingRelations = (PDEVICE_RELATIONS)pIoStatus->Information;
	
	// Add the count that someone on top of us may have added.
	if( NULL != pExistingRelations)
	{
		GCK_DBG_TRACE_PRINT(("There were %d existing bus relations.\n", pExistingRelations->Count));
		ulTotalCount += pExistingRelations->Count;
	}
		
	//	Allocate new relations structure
	pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, (sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT) * (ulTotalCount-1)) );
		
	//	Abort if allocation failed
	if(!pDeviceRelations)
	{
		pIoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
		GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_BusRelations(1): STATUS_INSUFFICIENT_RESOURCES\n"));
		return	STATUS_INSUFFICIENT_RESOURCES;
	}

	pDeviceRelations->Count = 0;
		
	//	Copy pExistingRelations (from above us perhaps) if there are any.
	if( pExistingRelations )
	{
		for( pDeviceRelations->Count = 0; pDeviceRelations->Count < pExistingRelations->Count; pDeviceRelations->Count++)
		{	
			GCK_DBG_TRACE_PRINT(("Exiting relation (PDO = 0x%0.8x)\n", pExistingRelations->Objects[pDeviceRelations->Count]));
			pDeviceRelations->Objects[pDeviceRelations->Count] = pExistingRelations->Objects[pDeviceRelations->Count];
		}
		ExFreePool(pExistingRelations);
	}

	//	Add the relations that we know about	
	if(SwvbGlobals.pDeviceRelations)
	{
		ULONG ulIndex;
		for(ulIndex=0; ulIndex < SwvbGlobals.pDeviceRelations->Count; ulIndex++, pDeviceRelations->Count++)
		{	
			GCK_DBG_TRACE_PRINT(("Our relation (PDO = 0x%0.8x)\n", SwvbGlobals.pDeviceRelations->Objects[ulIndex]));
			pDeviceRelations->Objects[pDeviceRelations->Count] = SwvbGlobals.pDeviceRelations->Objects[ulIndex];
			// Reference these guys as you add them
			ObReferenceObject(pDeviceRelations->Objects[pDeviceRelations->Count]);
		}
		//minor sanity check
		ASSERT(pDeviceRelations->Count == ulTotalCount);
	}

	// Fill out the IoStatus block
	pIoStatus->Information = (ULONG)pDeviceRelations;
	pIoStatus->Status = STATUS_SUCCESS;

	//Get outta here
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_BusRelations(2): STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Expose
**
**	@func	Exposes a new virtual device
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@comm	Expose is called to add a new virtual device to the system.<nl>
**			The new device object is not returned, rather the InitDevice function
**			passed in pSwvbExposeData is called when it is time to initialize the
**			new device, the caller also must cache the device during that call
**			so that it can remove it later.
**
**	@xref	SWVB_EXPOSE_DATA
*************************************************************************************/
NTSTATUS
GCK_SWVB_Expose
(
	IN PSWVB_EXPOSE_DATA pSwvbExposeData // @parm all the data needed to expose a PDO
)
{
	NTSTATUS			NtStatus;
	UNICODE_STRING		uniPdoNameString;
	PWCHAR				pcwPdoName;
	PDEVICE_OBJECT		pVdPdo;
	PSWVB_PDO_EXT		pSwvbPdoExt;
	ULONG				ulTotalExtensionSize;
	ULONG				ulHardwareIDLength;
		
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Expose. pSwvbExposeData = 0x%0.8x\n", pSwvbExposeData));

	//Calculate the needed extension size
	ulTotalExtensionSize = sizeof(SWVB_PDO_EXT) + pSwvbExposeData->ulDeviceExtensionSize;

	//	Create a name for the Pdo
	pcwPdoName = (PWCHAR)EX_ALLOCATE_POOL(PagedPool, sizeof(SWVB_DEVICE_NAME_BASE));
	if( !pcwPdoName )
	{
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(1) ERROR:Failed to allocate PDO Name\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	swprintf(pcwPdoName, SWVB_DEVICE_NAME_TMPLT, SwvbGlobals.ulDeviceNumber++);
	RtlInitUnicodeString(&uniPdoNameString, pcwPdoName);
	
	//	Create the PDO
	NtStatus = IoCreateDevice(
		SwvbGlobals.pBusFdo->DriverObject,
		ulTotalExtensionSize,
		&uniPdoNameString,
		FILE_DEVICE_UNKNOWN,
		0,
		FALSE,
		&pVdPdo 
		);

	//Done with the name
	ExFreePool(pcwPdoName);
	if( !NT_SUCCESS(NtStatus) )
	{
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(2) ERROR:Failed to Create PDO, NtStatus = 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	
	//	Ensure that we will be able to remember this new Pdo.
	if(!SwvbGlobals.pDeviceRelations)
	{
		//
		// Three PDO's is pretty cheap and will suffice most of the time, avoiding reallocation.
		// We hard code this here, as this is not really a parameter that you need to change.
		// If we run over 3 than it will reallocate as needed anyway. - The device relations
		// already as room for 1 device object so we just need to add the size of 2 pointers
		// to get to three.
		//
		ULONG ulSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*2;
		SwvbGlobals.pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, ulSize);
		if(!SwvbGlobals.pDeviceRelations)
		{
			IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
			GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(3): Failed to allocate SwvbGlobals.pDeviceRelations\n"));
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		SwvbGlobals.pDeviceRelations->Count = 0;
		SwvbGlobals.ulDeviceRelationsAllocCount = 3;  //we made space for three
	}
	
	// If the DEVICE_RELATIONS structure is not large enough, grow it.
	if(SwvbGlobals.pDeviceRelations->Count == SwvbGlobals.ulDeviceRelationsAllocCount)
	{
		ULONG ulNewAllocCount;
		ULONG ulNewAllocSize;
		ULONG ulOldAllocSize;
		PDEVICE_RELATIONS pTempDeviceRelations;
		ulNewAllocCount = SwvbGlobals.ulDeviceRelationsAllocCount*2;
		ulNewAllocSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*(ulNewAllocCount-1);
		ulOldAllocSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*(SwvbGlobals.ulDeviceRelationsAllocCount-1);
		pTempDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, ulNewAllocSize);
		//Make sure that allocation worked
		if(!pTempDeviceRelations)
		{
			IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
			GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(4): Failed to grow SwvbGlobals.pDeviceRelations\n"));
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		//Copy all data
		RtlCopyMemory(pTempDeviceRelations, SwvbGlobals.pDeviceRelations, ulOldAllocSize);
		//Update info
		SwvbGlobals.ulDeviceRelationsAllocCount = ulNewAllocCount;
		SwvbGlobals.pDeviceRelations = pTempDeviceRelations;
		/*
		*	BUGBUG: Memory Leak.  After RC replace above line with the following
		*
		*	PDEVICE_RELATIONS pTemp2 = SwvbGlobals.pDeviceRelations;
		*	SwvbGlobals.pDeviceRelations = pTempDeviceRelations;
		*	ExFreePool(pTemp2);
		*
		*/
	}
	
	// Reference the newly created pdo
	ObReferenceObject(pVdPdo);

	// Initialize the device extention
	pSwvbPdoExt = (PSWVB_PDO_EXT)pVdPdo->DeviceExtension;
	pSwvbPdoExt->ulGckDevObjType = GCK_DO_TYPE_SWVB;
	pSwvbPdoExt->fAttached=TRUE;
	pSwvbPdoExt->fStarted=FALSE;
	pSwvbPdoExt->fRemoved = FALSE;
	pSwvbPdoExt->pServiceTable = pSwvbExposeData->pServiceTable;
	pSwvbPdoExt->ulInstanceNumber = pSwvbExposeData->ulInstanceNumber;
	pSwvbPdoExt->ulOpenCount = 0;
	GCK_InitRemoveLock(&pSwvbPdoExt->RemoveLock, "Virtual Device");

	// Copy the HardwareID
	ulHardwareIDLength = MultiSzWByteLength(pSwvbExposeData->pmwszDeviceId);
	pSwvbPdoExt->pmwszHardwareID = (PWCHAR)EX_ALLOCATE_POOL( NonPagedPool, ulHardwareIDLength);
	if(!pSwvbPdoExt->pmwszHardwareID)
	{
		ObDereferenceObject(pVdPdo);
		IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(5): Failed to allocate space for HardwareId\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyMemory( pSwvbPdoExt->pmwszHardwareID, pSwvbExposeData->pmwszDeviceId, ulHardwareIDLength);


		
	//** CAVEAT From here to end of function must succeed! We
	//** CAVEAT	have no way of telling the virtual device 
	//** CAVEAT that afterall, we decided not to expose that PDO it
	//** CAVEAT it has already initialized!
	// Allow virtual device code to init its part of the extension
	pSwvbExposeData->pfnInitDevice(pVdPdo, pSwvbExposeData->ulInitContext);
	
	//mark end of initialization in the device object
	pVdPdo->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pVdPdo->Flags &= ~DO_DEVICE_INITIALIZING;

	//Sanity check of code a few steps ago.
	ASSERT(SwvbGlobals.pDeviceRelations->Count < SwvbGlobals.ulDeviceRelationsAllocCount);
	
	//Add our Pdo to the list
	SwvbGlobals.pDeviceRelations->Objects[SwvbGlobals.pDeviceRelations->Count++] = pVdPdo;

	//
	//	Invalidate Device Relations - will pique some interest in what we have done here
	//	Verify that we have a bus if not we are OK, when the bus is set everything will work,
	//	but we assert becuase we really want to force the client code to add the bus before the device.
	//
	ASSERT(	SwvbGlobals.pBusFdo );
	ASSERT(	SwvbGlobals.pBusPdo );
	if( SwvbGlobals.pBusFdo && SwvbGlobals.pBusPdo)
	{
		IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Expose(5): Success\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Remove
**	
**	@func	Removes a virtual device from the system.  Actually we just mark it
**			for removal and tell PnP to reenumerate.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@comm	The Pdo should be one that was sent to pfnInitDevice when <f GCK_SWVB_Expose>
**			was called.<nl>
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Remove
(
	IN PDEVICE_OBJECT	pPdo	// @parm Pdo to remove
)
{
	ULONG ulMatchIndex = 0xFFFFFFFF;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Remove: pPdo = 0x%0.8x\n", pPdo));
	
	// Find and Remove Pdo from SwvbGlobals.pDeviceRelations
	if(SwvbGlobals.pDeviceRelations)
	{
		ULONG ulIndex;
		for(ulIndex = 0; ulIndex < SwvbGlobals.pDeviceRelations->Count; ulIndex++)
		{
			if(SwvbGlobals.pDeviceRelations->Objects[ulIndex] == pPdo)
			{
				ulMatchIndex = ulIndex;
				break;
			}
		}
	}

	//if we found a match remove it from it
	if(0xFFFFFFFF == ulMatchIndex)
	{
		//No one should ever try to remove a device that is not in the list
		ASSERT(FALSE);
		GCK_DBG_EXIT_PRINT(("Error GCK_SWVB_Remove: Attempt to remove non-existant device!\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//Copy last PDO over this one and dec count, works even if we are last
	SwvbGlobals.pDeviceRelations->Objects[ulMatchIndex]
		= SwvbGlobals.pDeviceRelations->Objects[--(SwvbGlobals.pDeviceRelations->Count)];
	
	//
	// Mark device as unattached so when PnP says to remove it, we
	// do remove it and clean up everything, rather than hanging on
	// to it and waiting for more querying IRPs
	((PSWVB_PDO_EXT)pPdo->DeviceExtension)->fAttached =FALSE;

	//
	//	If it has been removed already, we need to delete, because the PnP system already
	//	doesn't know about, and we just detattached, so once we leave this routine, we don't
	//	know about it.  So Delete now, or it sticks to us.  Then we go to remove ourselves
	//	we will notice that we still have some Device Objects in our pockets(pDriverObject device object list),
	//	and we will wonder where they came from, and what type they are?  So delete them now!
	//
	if(TRUE == ((PSWVB_PDO_EXT)pPdo->DeviceExtension)->fRemoved)
	{
		PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pPdo->DeviceExtension;
		NTSTATUS NtStatus;
		// Give virtual device a chance at the IRP
		if(pPdoExt->pServiceTable->pfnRemove)
		{
			NtStatus = pPdoExt->pServiceTable->pfnRemove(pPdo, NULL);
		}

		// failure to succeed is pretty darn serious
		if(!NT_SUCCESS(NtStatus))
		{
			ASSERT(FALSE);
			GCK_DBG_CRITICAL_PRINT(("Virtual Device had the gall to fail remove!\n"));
		}
		
		// free memory for storing the HardwareID
		ASSERT(pPdoExt->pmwszHardwareID);
		ExFreePool(pPdoExt->pmwszHardwareID);

		GCK_DBG_TRACE_PRINT(("Detattached device has already been removed by PnP, so clean it up.\n"));
		if( 0 == ((PSWVB_PDO_EXT)pPdo->DeviceExtension)->ulOpenCount )
		{
			ObDereferenceObject(pPdo);
			IoDeleteDevice(pPdo);
		}
	}

	// Invalidate the BUS relations so that PnP will renumerate the bus.
	// Of course since we rely on others, it is possible that we temporarily
	// don't have a Bus, in which case we skip this step.
	//
	// If we don't have DO for the Bus we shouldn't lose any sleep on two accounts:
	// 1. It is possible that all the real devices have been yanked from the system, in which case
	//		PnP will start removing everyone below the node that was yanked, starting at the bottom.
	//		That means virtual devices have been removed as far as PnP is concerned and our remove
	//		routine for those devices has been called.  However, until all the underlying real devices
	//		get removed by PnP (which is later), they don't relealize it is time to tell us to get rid of the
	//		virtual devices.  No big woop.  We will delete the devices when they tell us.  If the virtual
	//		device is shared among real devices (like a virtual keyboard), they will tell us when the last
	//		one is removed.  This scenario is infact the normal way things happen when the last device is pulled,
	//		or when the system is powered down.
	// 2. It is possible that the filter drivers have temporarily decided to pull our bus.  In this case,
	//		everything will be fine and dandy when we get a new bus to sit on, as we will Invalidate Bus relations
	//		at that time.
	if(SwvbGlobals.pBusPdo)
	{
		IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
	}
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Remove: Success\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	ULONG MultiSzWByteLength(PWCHAR pmwszBuffer);
**
**	@func	Calculates the length in bytes of a Wide Multi String,
**			including terminating characters.  Multi-sz is terminated by two NULLs
**			in a row.
**
**	@rdesc	Size in characters, including terminating characters.
**
*************************************************************************************/
ULONG
MultiSzWByteLength
(
	PWCHAR pmwszBuffer	// @parm Pointer to UNICODE multi-string
)
{
	PWCHAR pmwszStart = pmwszBuffer;
	do
	{
		while(*pmwszBuffer++);
	}while(*pmwszBuffer++);
	return (ULONG)((PCHAR)pmwszBuffer -(PCHAR)pmwszStart);
}


/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Create
**	
**	@func	Handles IRP_MJ_CREATE for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Create
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Create\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnCreate(pDeviceObject, pIrp);
	if( NT_SUCCESS(NtStatus) )
	{
		pPdoExt->ulOpenCount++;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Create, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Close
**	
**	@func	Handles IRP_MJ_CLOSE for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Close
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Close\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnClose(pDeviceObject, pIrp);
	//if successfully closed, decrement count
	if( NT_SUCCESS(NtStatus) )
	{
		if(0==--pPdoExt->ulOpenCount)
		{
			//if the device is removed, we need to delete it.
			if(pPdoExt->fRemoved)
			{
				ObDereferenceObject(pDeviceObject);
				IoDeleteDevice(pDeviceObject);
			}
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Close, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Read
**	
**	@func	Handles IRP_MJ_READ for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Read
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Reade\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnRead(pDeviceObject, pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Read, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Ioctl
**	
**	@func	Handles IRP_MJ_IOCTL and IRP_MJ_INTERNAL_IOCTL for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Ioctl
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Ioctl\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//if device is stopped, complete here, less work for virtual devices
	if(	
		(pPdoExt->fRemoved) ||
		(!pPdoExt->fStarted)
		)
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_DELETE_PENDING;
	}

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnIoctl(pDeviceObject, pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Ioctl, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvb_pnp.cpp ===
//	@doc
/**********************************************************************
*
*	@module	SWVB_PnP.cpp	|
*
*	Power and PnP handlers for SWVB Virtual Devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVB_PnP	|
*			Power and PnP IRPs are handled here as if for a PDO
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVB_PNP_C

extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));
}
#include "SWVBENUM.h"
#include <stdio.h>



/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PNP for Virtual Devices.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_SWVB_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS				NtStatus;
	PIO_STACK_LOCATION		pIrpStack;
	PSWVB_PDO_EXT			pPdoExt;
	PDEVICE_CAPABILITIES	pDeviceCapabilities;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_PnP\n"));	
	
	//
	//	By default we will not change the status
	//
	NtStatus = pIrp->IoStatus.Status;

	//
	//	PDO Device Extension
	//
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	ASSERT( GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	GCK_IncRemoveLock(&pPdoExt->RemoveLock);

    //
	//	Handle by Minor IRP code
	//
	switch (pIrpStack->MinorFunction) {

		case IRP_MN_START_DEVICE:

			GCK_DBG_TRACE_PRINT(("IRP_MN_START_DEVICE\n"));
		    
			pPdoExt->fStarted = TRUE;
			pPdoExt->fRemoved = FALSE;
			
			//Give virtual device a chance at the IRP
			if(pPdoExt->pServiceTable->pfnStart)
			{
				NtStatus = pPdoExt->pServiceTable->pfnStart(pDeviceObject, pIrp);
			}
			else
			{
				NtStatus = STATUS_SUCCESS;
			}
			break;

		case IRP_MN_STOP_DEVICE:
			
			GCK_DBG_TRACE_PRINT(("IRP_MN_STOP_DEVICE\n"));
			pPdoExt->fStarted = FALSE;
			
			//Give virtual device a chance at the IRP
			if(pPdoExt->pServiceTable->pfnStop)
			{
				NtStatus = pPdoExt->pServiceTable->pfnStop(pDeviceObject, pIrp);
			}
			else
			{
				NtStatus = STATUS_SUCCESS;
			}
			break;

		case IRP_MN_REMOVE_DEVICE:

			GCK_DBG_TRACE_PRINT(("IRP_MN_REMOVE_DEVICE\n"));
			
			//We are not setup to handle remove twice.
			if(pPdoExt->fRemoved)
			{
				pIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP STATUS_NO_SUCH_DEVICE on remove\n"));
				return STATUS_NO_SUCH_DEVICE;
			}
			

			//Sometimes we get a remove without a stop, so do the stop stuff if necessary
			if(pPdoExt->fStarted)
			{
				pPdoExt->fStarted = FALSE;
				//Give virtual device a chance at the IRP
				if(pPdoExt->pServiceTable->pfnStop)
				{
					NtStatus = pPdoExt->pServiceTable->pfnStop(pDeviceObject, pIrp);
				}
			}

			// We will no longer receive requests for this device as it has been removed.
			pPdoExt->fRemoved = TRUE;

			// Undo our increment upon entry to this routine
			GCK_DecRemoveLock(&pPdoExt->RemoveLock);

			//We may have ordered this removal, or the PnP system
			//may just be rearranging things for us.  If we ordered it,
			//we need to cleanup, and give the virtual device a chance
			//to cleanup.  If the PnP system is rearranging things we nod
			//back, sure it is removed, and pretty much ignore it.
			if(!pPdoExt->fAttached)
			{
				// Give virtual device a chance at the IRP
				if(pPdoExt->pServiceTable->pfnRemove)
				{
					NtStatus = pPdoExt->pServiceTable->pfnRemove(pDeviceObject, pIrp);
				}
				// failure to succeed is pretty darn serious
				if(!NT_SUCCESS(NtStatus))
				{
					ASSERT(FALSE);				/** ?? **/
					GCK_DBG_CRITICAL_PRINT(("Virtual Device had the gall to fail remove!\n"));
					return NtStatus;
				}
				
				// free memory for storing the HardwareID
				ASSERT(pPdoExt->pmwszHardwareID);
				ExFreePool(pPdoExt->pmwszHardwareID);

				//
				// Undo the bias Irp count so it can go to zero
				// if this does not take it to zero, we have to wait
				// until it goes to zero, forever.
				//
        		GCK_DecRemoveLockAndWait(&pPdoExt->RemoveLock, NULL);
				
				// Delete this device, if the open count is zero
				if( 0 == pPdoExt->ulOpenCount )
				{
					ObDereferenceObject(pDeviceObject);
					IoDeleteDevice(pDeviceObject);
				}
			}
			
			// Must succeed this 
		    pIrp->IoStatus.Status = STATUS_SUCCESS;
		    IoCompleteRequest (pIrp, IO_NO_INCREMENT);
			GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP succeeding remove\n"));
			return STATUS_SUCCESS;

		case IRP_MN_QUERY_DEVICE_RELATIONS:

			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_DEVICE_RELATIONS: Type = %d\n",
				pIrpStack->Parameters.QueryDeviceRelations.Type));
			
			//	TargetDeviceRelation just wants to know who the PDO is, and it
			//	is us so we handle it.
			if (TargetDeviceRelation == pIrpStack->Parameters.QueryDeviceRelations.Type)
			{
				PDEVICE_RELATIONS pDeviceRelations;
				GCK_DBG_TRACE_PRINT(("TargetDeviceRelations\n"));
				pDeviceRelations = (PDEVICE_RELATIONS) pIrp->IoStatus.Information; 
				if (!pDeviceRelations)
				{
					pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(PagedPool, sizeof(DEVICE_RELATIONS));
					if (!pDeviceRelations) {
						GCK_DBG_ERROR_PRINT(("Couldn' allocate DEVICE_RELATIONS for TargetDevice!!\n"));
						NtStatus = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}
				}
			    else if (pDeviceRelations->Count != 0)
				{
					ULONG	uIndex;
					
					// Nobody but the PDO should be setting this value!
					ASSERT(pDeviceRelations->Count == 0);
					
					//
					// Deref any objects that were previously in the list
					// This code copied out of some system code (gameenum perhaps)
					// Seems like this code should not be necessary, but what the
					// hell? It does no harm.
					for( uIndex= 0; uIndex< pDeviceRelations->Count; uIndex++)
					{
						ObDereferenceObject(pDeviceRelations->Objects[uIndex]);
						pDeviceRelations->Objects[uIndex] = NULL;
					}
				}
				pDeviceRelations->Count = 1;
				pDeviceRelations->Objects[0] = pDeviceObject;
				ObReferenceObject(pDeviceObject);
				NtStatus = STATUS_SUCCESS;
				pIrp->IoStatus.Information = (ULONG) pDeviceRelations;
				break;
			}
			//
			//	Fall through
			//
			NtStatus = pIrp->IoStatus.Status;
			break;
		case IRP_MN_QUERY_CAPABILITIES:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_CAPABILITIES\n"));
			
			// Get the packet.
			 pDeviceCapabilities=pIrpStack->Parameters.DeviceCapabilities.Capabilities;

			// Set the capabilities.
			pDeviceCapabilities->Version = 1;
			pDeviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

			// BUG	If we get a virtual keystroke it would be nice
			// BUG	to shut off the screen saver.  Not sure if this
			// BUG  is related or not.
			pDeviceCapabilities->SystemWake = PowerSystemUnspecified;
			pDeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

			// We have no latencies
			pDeviceCapabilities->D1Latency = 0;
			pDeviceCapabilities->D2Latency = 0;
			pDeviceCapabilities->D3Latency = 0;

			// No locking or ejection
			pDeviceCapabilities->LockSupported = FALSE;
			pDeviceCapabilities->EjectSupported = FALSE;

			// Device can be physically removed.
			// Technically there is no physical device to remove, but this bus
			// driver can yank the PDO from the PlugPlay system, whenever
			// the last joystick goes away.
			pDeviceCapabilities->Removable = TRUE;
			pDeviceCapabilities->SurpriseRemovalOK = TRUE;
			
			//This will force HIDSwvd.sys to be loaded
			pDeviceCapabilities->RawDeviceOK = FALSE;
			
			//Should surpress most UI
			pDeviceCapabilities->SilentInstall = TRUE;
			

			// not Docking device
			pDeviceCapabilities->DockDevice = FALSE;

			//We want to avoid having PnP attach some extra info.
			//So impose that only one bus can be on the system at a time.
			pDeviceCapabilities->UniqueID = TRUE;

			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_QUERY_ID:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_ID\n"));
			//
			//	Handle by type of ID requested
			//
			switch (pIrpStack->Parameters.QueryId.IdType)
			{
				case BusQueryDeviceID:
					// this can be the same as the hardware ids (which requires a multi
					// sz) ... we are just allocating more than enough memory
				case BusQueryHardwareIDs:
				{
					ULONG ulLength;
					ULONG ulTotalLength;
					PWCHAR	pmwszBuffer;
					// return a multi WCHAR (null terminated) string (null terminated)
					// array for use in matching hardare ids in inf files;
					ulLength = MultiSzWByteLength(pPdoExt->pmwszHardwareID);
					ulTotalLength = ulLength + sizeof(SWVB_BUS_ID);
					
					pmwszBuffer = (PWCHAR)EX_ALLOCATE_POOL(PagedPool, ulTotalLength);
					if (pmwszBuffer)
					{
						RtlCopyMemory (pmwszBuffer, SWVB_BUS_ID, sizeof(SWVB_BUS_ID));
						//The sizeof(WCHAR) is so that we chomp over the terminating UNICODE_NULL.
						RtlCopyMemory ( (PCHAR)pmwszBuffer + sizeof(SWVB_BUS_ID) - sizeof(WCHAR), pPdoExt->pmwszHardwareID, ulLength);
                		NtStatus = STATUS_SUCCESS;
					}
					else
					{
							NtStatus = STATUS_INSUFFICIENT_RESOURCES;
					}
					GCK_DBG_TRACE_PRINT(("First HardwareIDs is %ws\n", pmwszBuffer));
					pIrp->IoStatus.Information = (ULONG) pmwszBuffer;
					break;
				}
				case BusQueryInstanceID:
				{
					//
					ULONG ulLength;
					PWCHAR	pmwszBuffer;
					
					ulLength = MultiSzWByteLength(pPdoExt->pmwszHardwareID) + sizeof(SWVB_INSTANCE_EXT);

					pmwszBuffer = (PWCHAR)EX_ALLOCATE_POOL (PagedPool, ulLength);
					if (pmwszBuffer)
					{
						swprintf(pmwszBuffer, SWVB_INSTANCE_ID_TMPLT, pPdoExt->pmwszHardwareID, pPdoExt->ulInstanceNumber);
                		NtStatus = STATUS_SUCCESS;
					}
					else
					{
						NtStatus = STATUS_INSUFFICIENT_RESOURCES;
					}
					GCK_DBG_TRACE_PRINT(("Instance ID is %ws\n", pmwszBuffer));
					pIrp->IoStatus.Information = (ULONG) pmwszBuffer;

					break;
				}
				case BusQueryCompatibleIDs:
					pIrp->IoStatus.Information = 0;
					NtStatus = STATUS_NOT_SUPPORTED;
					break;
			}
			break;
		case IRP_MN_QUERY_PNP_DEVICE_STATE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_PNP_DEVICE_STATE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_SURPRISE_REMOVAL:
			GCK_DBG_TRACE_PRINT(("IRP_MN_SURPRISE_REMOVAL\n"));
			// BUGBUG we may need to know that this happened in the future
			NtStatus = STATUS_SUCCESS;
			break;
		//
		//	These are just completed with success
		//
		case IRP_MN_QUERY_REMOVE_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_REMOVE_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_CANCEL_REMOVE_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_REMOVE_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_QUERY_STOP_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_STOP_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_CANCEL_STOP_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_STOP_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		//
		//	These are just completed with their default status.
		//
		case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));
			break;
		case IRP_MN_READ_CONFIG:
			GCK_DBG_TRACE_PRINT(("IRP_MN_READ_CONFIG\n"));
			break;
		case IRP_MN_WRITE_CONFIG:
			GCK_DBG_TRACE_PRINT(("IRP_MN_WRITE_CONFIG\n"));
			break;
		case IRP_MN_EJECT:
			GCK_DBG_TRACE_PRINT(("IRP_MN_EJECT\n"));
			break;
		case IRP_MN_SET_LOCK:
			GCK_DBG_TRACE_PRINT(("IRP_MN_SET_LOCK\n"));
			break;
		case IRP_MN_QUERY_INTERFACE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_INTERFACE\n"));
			break;
		default:
			GCK_DBG_TRACE_PRINT(("Unknown IRP_MJ_PNP minor function = 0x%x\n", pIrpStack->MinorFunction));
	}
	
	//
	//	We are a PDO, there is no-one beneath us, we cannot send IRP's down.
	//	So we complete with the status set in the above switch/case,
	//	if not change there, the default is to preserve the status as
	//	NtStatus = pIrp->IoStatus.Status is done prior to entering the
	//	switch/case
	//
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	GCK_DecRemoveLock(&pPdoExt->RemoveLock);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP with Status, 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Power(IN PDEVICE_OBJECT pDeviceObject, IN OUT PIRP pIrp)
**
**	@func	Handles Power IRPs for Virtual Devices.  We only have virtual
**			devices so we support any power IRP.  Just succeed, sure we handle
**			that power level.  In the future, we may wish to keep track of what
**			state we are in, so we can wake the system, etc.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_SWVB_Power
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object IRP is sent to
	IN OUT PIRP pIrp					// @parm IRP to process
)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION pIrpStack;
	PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pDeviceObject->DeviceExtension;
	ASSERT( GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);	

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Power\n"));	
   
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	GCK_IncRemoveLock(&pPdoExt->RemoveLock);

    switch (pIrpStack->MinorFunction){
		case IRP_MN_SET_POWER:
			switch (pIrpStack->Parameters.Power.Type) {
				case SystemPowerState:
					NtStatus = STATUS_SUCCESS;
					break;
				case DevicePowerState:
					NtStatus = STATUS_SUCCESS;
					break;
				default:
					NtStatus = pIrp->IoStatus.Status;
			}
			break;
        case IRP_MN_WAIT_WAKE:
			//We just return STATUS_NOT_SUPPORTED as we do not support
			//waking the system.
			NtStatus = STATUS_NOT_SUPPORTED;
            break;
		case IRP_MN_POWER_SEQUENCE:
			ASSERT(FALSE);  //Shouldn't happen
			NtStatus = pIrp->IoStatus.Status;
			break;
		case IRP_MN_QUERY_POWER:
			NtStatus = STATUS_SUCCESS;
			break;
		default:
			NtStatus = pIrp->IoStatus.Status;
			break;
	}

	//we are done so signal that we are ready for next one
	PoStartNextPowerIrp(pIrp);
	ASSERT(NtStatus != STATUS_UNSUCCESSFUL);
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	
	GCK_DecRemoveLock(&pPdoExt->RemoveLock);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_Power with Status, 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvkbd.cpp ===
//	@doc
/*******************************************************************
*
*	@module	SWVKBD.cpp	|
*
*	Implementation of the SideWinder Virtual Keyboard
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	This module implements the SideWinder Virtual Keyboard
*	which is used to stuff keystrokes from Kernel Mode.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVKBD_C

//#pragma message (DDK_LIB_PATH)
extern "C" {
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include "hidtoken.h"
	#include "hidusage.h"
	#include "hidport.h"
	#include "remlock.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}

#include "SWVBENUM.h"
#include "SWVKBD.h"
#include <stdio.h>


// PDRIVER_OBJECT g_pDriverObject;

//
//	These keep track of the next instance number
//	g_ulInstanceBits is a bit field.  A device holds an instance number
//	by setting a bit, and clearing when it is destroyed.  This only works
//	for the first 32 devices (i.e. 99.99% of the time).  The 33rd device
//	goes into the overflow.  Instance numbers in the overflow are not recovered.
//	With 33 devices plugged in, plugging and unplugging the 33rd device will cause
//	the instances of devices in the registry to profilerate.  No real harm is done,
//	it is just ugly, but this is a highly unlikely scenario.
//
static ULONG			g_ulInstanceBits;
static ULONG			g_ulInstanceOverflow;

//---------------------------------------------------------------------
// Tables that define device characteristics and/or entry points
//---------------------------------------------------------------------

// Service table used by Virtual Bus Module to call into Virtual Keyboard
SWVB_DEVICE_SERVICE_TABLE	VKbdServiceTable =
							{
								&GCK_VKBD_CreateProc,
								&GCK_VKBD_CloseProc,
								&GCK_VKBD_ReadProc,
								&GCK_VKBD_WriteProc,
								&GCK_VKBD_IoctlProc,
								&GCK_VKBD_StartProc,
								&GCK_VKBD_StopProc,
								&GCK_VKBD_RemoveProc
							};
// Constants describing device
#define	VKBD_VERSION			0x0100
#define	VKBD_COUNTRY			0x0000
#define	VKBD_DESCRIPTOR_COUNT	0x0001
#define VKBD_PRODUCT_ID			0x00FA	//BUGBUGBUG I made this up, I need to request through Rob Walker
										//BUGBUGBUG to permanently allocate one for this purpose.
	
//
//	This is more or less copied from the HID spec Version 1 - Final, except that
//	we left off the reserved byte and the LED's , why should a virtual keyboard
//  need to have virtual LED's.  I can conceive of a real one without them.
//
static UCHAR VKBD_ReportDescriptor[] =
				{
					0x05,0x01, //Usage Page (Generic Desktop)
					0x09,0x06, //Usage (Keyboard)
					0xA1,0x01, //Collection (Application)
					0x05,0x07, //Usage Page (Key Codes)
					0x19,0xE0, //Usage Minimum (224) - from Left Control
					0x29,0xE7, //Usage Maximum (231) - to Right GUI
					0x15,0x00, //Logical Minimum (0)
					0x25,0x01, //Logical Maximum (1)
					0x75,0x01, //Report Size (1)
					0x95,0x08, //Report Count (8)
					0x81,0x02, //Input (Data, Variable, Absolute) - Modifier Byte
					0x95,0x05, //Report Count(5)
					0x75,0x01, //Report Size (1)
					0x05,0x08, //Usage Page (LEDs)
					0x19,0x01, //Usage Minimum (1)
					0x29,0x05, //Usage Maximum (5)
					0x91,0x02, //Output (Data, Vartiable, Absolute) - LED Indicator lights
					0x95,0x01, //Report Count(1)
					0x75,0x03, //Report Size (3)
					0x91,0x01, //Output (Constant) - Padding for LED output report, to bring it up to a byte.
					0x75,0x08, //Report Size (8)
					0x95, GCK_VKBD_MAX_KEYSTROKES, //Report Count (GCK_VKBD_MAX_KEYSTROKES) 
					0x15,0x00, //Logical Minimum (0)
					0x25,0xFF, //Logical Maximum (1)
					0x05,0x07, //Usage Page (Key Codes)
					0x19,0x00, //Usage Minimum (0) - from '1'				   ???
					0x29,0xFF, //Usage Maximum (255) -  ???
					0x81,0x00, //Input (Data, Array) - Key arrays
					0xC0	   //End Collection
				};

				
static	HID_DESCRIPTOR	VKBD_DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							VKBD_VERSION,
							VKBD_COUNTRY,
							VKBD_DESCRIPTOR_COUNT,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(VKBD_ReportDescriptor)}
							};

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING pRegistryPath)
**
**	@func	Stows the Driver Object for later
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,	//@parm Driver Object
    IN PUNICODE_STRING pRegistryPath	//@parm Registry path for this driver
    )
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_DriverEntry\n"));
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pRegistryPath);
//	g_pDriverObject = pDriverObject;
	g_ulInstanceBits = 0x0;
	g_ulInstanceOverflow = 32; //For 33 and more devices
	return STATUS_SUCCESS;
}
	
/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_Create(OUT PDEVICE_OBJECT *ppDeviceObject)
**
**	@func	Creates a new Virtual Keyboard
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject //@parm [out] Device Object of new virtual keyboard
)
{
	
	NTSTATUS	NtStatus;
	SWVB_EXPOSE_DATA	SwvbExposeData;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Create *ppDeviceObject = 0x%0.8x\n", *ppDeviceObject));
	
	//Fill out SWVB_EXPOSE_DATA structure
	SwvbExposeData.pmwszDeviceId=L"SideWinderVirtualKeyboard\0\0";
	SwvbExposeData.pServiceTable = &VKbdServiceTable;
	SwvbExposeData.ulDeviceExtensionSize = sizeof(GCK_VKBD_EXT);
	SwvbExposeData.ulInitContext = (ULONG)ppDeviceObject;
	SwvbExposeData.pfnInitDevice = &GCK_VKBD_Init;
	
	//Get the instance ID
	ULONG ulBitMask;
	ULONG ulIndex;
	for(ulIndex = 0, ulBitMask = 1; ulIndex < 32; ulBitMask <<= 1, ulIndex++)
	{
		if(ulBitMask & ~g_ulInstanceBits)
		{
			g_ulInstanceBits |= ulBitMask;
			SwvbExposeData.ulInstanceNumber	= ulIndex;
			break;
		}
	}
	if(32 == ulIndex)
	{
		SwvbExposeData.ulInstanceNumber = g_ulInstanceOverflow++;
	}

	//Call virtual bus to expose virtual keyboard
	NtStatus=GCK_SWVB_Expose(&SwvbExposeData);
	
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_Init(	IN PDEVICE_OBJECT pDeviceObject, IN ULONG ulInitContext)
**
**	@func	Callback for Initializing new device object.  The ulInitContext
**			is a pointer to a pointer to a device object, so that we can pass
**			the pointer to the device object back to the caller of create.
**	@rdesc	STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
)
{
	PGCK_VKBD_EXT pDevExt;
	PDEVICE_OBJECT *ppSaveDeviceObject;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Init pDeviceObject = 0x%0.8x\n", pDeviceObject));

	//Create sent us a pointer to a PDEVICE_OBJECT in which to return the new device object
	ppSaveDeviceObject = (PDEVICE_OBJECT *)ulInitContext;
	*ppSaveDeviceObject = pDeviceObject;
	
	//Get out part of the device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	//Mark device as stopped
	pDevExt->ucDeviceState= VKBD_STATE_STOPPED;
	
	//Mark the circular buffer as empty
	pDevExt->usReportBufferPos=0;
	pDevExt->usReportBufferCount=0;

	//Initialize locks
	GCK_InitRemoveLock(&pDevExt->RemoveLock, "SWVKBD_LOCK");

	//Initialize IrpQueue
	pDevExt->IrpQueue.Init(	CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE |
							CGuardedIrpQueue::PRESERVE_QUEUE_ORDER,
							(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
							&pDevExt->RemoveLock);


	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_Close(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Closes the virtual keyboard (removes it!)
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Close
(
	IN PDEVICE_OBJECT pDeviceObject
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Close pDeviceObject = 0x%0.8x\n", pDeviceObject));
	//Tell the virtual bus to kill us
	return GCK_SWVB_Remove(pDeviceObject);
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_SendReportPacket(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Stuff a report into the circular buffer, and completes
**			an IRP if one is pending.
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VKBD_REPORT_PACKET pReportPacket
)
{
	
	
	USHORT usBufferIndex;
	PGCK_VKBD_EXT pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	//
	//	Step 1. Stuff new packet into buffer
	//

	// Acquire Lock to work with buffer 
	IrpQueueWithSharedSpinLock.Acquire();
		

	//Find position in buffer to stuff at
	usBufferIndex = (pDevExt->usReportBufferPos + pDevExt->usReportBufferCount)%GCK_VKBD_STATE_BUFFER_SIZE;

	//Copy data
	pDevExt->rgReportBuffer[usBufferIndex] = *pReportPacket;
	
	//increment buffer count
	if(pDevExt->usReportBufferCount < GCK_VKBD_STATE_BUFFER_SIZE)
	{
		pDevExt->usReportBufferCount++;
	}
	else
	{
		//This assertion means buffer overflow
		ASSERT(FALSE);
		pDevExt->usReportBufferPos++;
	}
	
	
	//
	//	Step 2. Get Irp if there is one
	//
	PIRP pPendingIrp = IrpQueueWithSharedSpinLock.Remove();

	if(pPendingIrp)
	{
		//	Copy the data
		RtlCopyMemory(
			pPendingIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VKBD_REPORT_PACKET)
			);
	
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VKBD_STATE_BUFFER_SIZE;
		}
	}
	
	//We are done with the buffer spin lock
	IrpQueueWithSharedSpinLock.Release();
	
	if(pPendingIrp)
	{
		//  Fill out IRP status
		pPendingIrp->IoStatus.Information = sizeof(GCK_VKBD_REPORT_PACKET);
		pPendingIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pPendingIrp, IO_NO_INCREMENT);
		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}

	//All done
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_ReadReport(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	If there is data in the keyboard buffer, completes the IRP
**			Otherwise, queues it, and set the idle timer.
**
**	@rdesc	STATUS_SUCCESS if read, STATUS_PENDING if waiting.
**
*************************************************************************************/
NTSTATUS 
GCK_VKBD_ReadReport
(
 IN PDEVICE_OBJECT pDeviceObject, 
 IN PIRP pIrp
)
{

	PGCK_VKBD_EXT pDevExt;
	PIO_STACK_LOCATION pIrpStack;
	KIRQL OldIrql;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VKBD_ReadReport pDeviceObject = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	
	//
	// Validate buffer size, because we do this the first time we see the IRP
	// we never need to worry about checking it again.
	//
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(GCK_VKBD_REPORT_PACKET))
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	//Make an IRP queue accessor to share spin lock
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	// Count the IRP we are working on
	GCK_IncRemoveLock(&pDevExt->RemoveLock);
	
	// Acquire Lock to work with mouse buffer and Irp Queue
	IrpQueueWithSharedSpinLock.Acquire();

	// If there is data, complete the IRP
	if( pDevExt->usReportBufferCount)
	{
		//	Copy the data
		RtlCopyMemory(
			pIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VKBD_REPORT_PACKET)
			);
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VKBD_STATE_BUFFER_SIZE;
		}
		
		//We are done with the buffer spin lock
		IrpQueueWithSharedSpinLock.Release();

		//  Fill out IRP status
		pIrp->IoStatus.Information = sizeof(GCK_VKBD_REPORT_PACKET);
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}
	else 
	// There is no data, so queue the IRP.
	{
		return IrpQueueWithSharedSpinLock.AddAndRelease(pIrp);
	}

	//We completed the IRP and all is fine
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_WriteToFakeLEDs(IN PIRP pIrp)
**
**	@func	In the context of any device object (hence not input parameter),
**			this function handle IOCTL_HID_WRITE_REPORT.  The only output
**			that virtual keyboards support is report ID 0 (the LED indicators)
**			and one byte of data is expected.	We verify this set the
**			IoStatus.Information and return the correct error code.  The IOCTL
**			dispatch set IoStatus.Status and completes the IRP.
**
**	@rdesc	STATUS_SUCCESS if OK, STATUS_INVALID_DEVICE_REQUEST if not Report ID 0
**			STATUS_INVALID_PARAMETER if the buffer is the wrong size.
**
*************************************************************************************/
NTSTATUS GCK_VKBD_WriteToFakeLEDs
(
	IN PIRP pIrp	// @parm [in/out] IRP for IOCTL_HID_WRITE_REPORT
)
{
	HID_XFER_PACKET	*pHidXferPacket;

	//We haven't copied anything yet
	pIrp->IoStatus.Information = 0;

	//	Cast UserBuffer to an XferPacket (this is what it is supposed to be.
	//	We don't verify the IOCTL code, because a good and trusted friend (GCK_VKBD_Ioctl)
	//	sent this IRP here, and is inefficient, not to mention painful, to check again.
	pHidXferPacket = (PHID_XFER_PACKET)pIrp->UserBuffer;

	//Verify Report ID
	if(0 /* Report ID of LED report */ != pHidXferPacket->reportId)
	{
		return STATUS_INVALID_DEVICE_REQUEST;
	}
	
	//Verify Repot Buffer Length
	if(1 /*1 byte - size of LED report*/ != pHidXferPacket->reportBufferLen)
	{
		return STATUS_INVALID_PARAMETER;
	}
	
	//Report that we received the one byte and set the virtual LED's accordingly
	pIrp->IoStatus.Information = 1;
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_CloseProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CLOSE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	//We don't control open and close, so just succeed
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_CloseProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_CreateProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CREATE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_CreateProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_CreateProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_IoctlProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_INTERNAL_IOCTL and IRP_MJ_IOCTL requests sent from SWVB.
**			Trivial IRPs are handle here, others are delegated.
**
**	@rdesc	STATUS_SUCCESS, and various errors
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_IoctlProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	NTSTATUS NtStatus;
	PIO_STACK_LOCATION pIrpStack;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VKBD_IoctlProc\n"));
	
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrpStack->Parameters.DeviceIoControl.IoControlCode;
		
	// We complete everything, so the various cases
	// fill out status and information, and we complete
	// the IRP at the bottom.
	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_GET_PHYSICAL_DESCRIPTOR:
			pIrp->IoStatus.Information = 0;
			NtStatus =STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_ACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_DEACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			NtStatus = GCK_VKBD_GetDeviceAttributes(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			NtStatus = GCK_VKBD_GetDeviceDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			NtStatus = GCK_VKBD_GetReportDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_STRING:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;  //Should we support this?
			break;
		case IOCTL_HID_READ_REPORT:
			//	Read report will complete the IRP, or queue as it sees fit, just delegate
			return GCK_VKBD_ReadReport(pDeviceObject, pIrp);
		case IOCTL_HID_SET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_WRITE_REPORT:
			//
			//	Fake LED's are the only output we support.  The routine verifies that
			//	this is what is being written to, and that the buffer size is correct
			//	If this is true, the routine will mark IoStatus.Information to say that
			//	got the new state and return STATUS_SUCCESS.  Otherwise, it will return
			//	STATUS_INVALID_DEVICE_REQUEST
			//
			NtStatus = GCK_VKBD_WriteToFakeLEDs(pIrp);
			break;
		default:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
	}
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_ReadProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_READ request sent from SWVB.  We don't support this.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_ReadProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_ReadProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_StartProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_START_DEVICE request sent from SWVB.
**			Just mark that we are started.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_StartProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_StartProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as started
	pDevExt->ucDeviceState = VKBD_STATE_STARTED;

	// PnP IRPs are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_StopProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_STOP_DEVICE request sent from SWVB.
**			Just mark that we are stopped.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_StopProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_StopProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as stopped
	pDevExt->ucDeviceState = VKBD_STATE_STOPPED;
	
	// Cancel all I\O
	pDevExt->IrpQueue.CancelAll(STATUS_DELETE_PENDING);

	// PnP IRP are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_RemoveProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE request sent from SWVB.
**			Wait for all outstanding IO to complete before succeeding.  We don't
**			delete our device object that is up to SWVB.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_RemoveProc\n"));

	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	// Mark as Removed
	pDevExt->ucDeviceState = VKBD_STATE_REMOVED;
	
	//Clear Instance Bits
	ULONG ulInstance = GCK_SWVB_GetInstanceNumber(pDeviceObject);
	if(ulInstance < 32)
	{
		g_ulInstanceBits &= ~(1 << ulInstance);
	}

	// Remove the BIAS on the RemoveLock and wait for it to go to zero (forever)
	return GCK_DecRemoveLockAndWait(&pDevExt->RemoveLock, NULL);
	
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_WriteProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_WRITE, which we don't support.  With HIDSWVD.SYS
**			as the functional driver this should never get called.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_WriteProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_WriteProc\n"));
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetDeviceDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Device Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Device Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetDeviceDescriptor\n"));
	// Check buffer size
	if(ulBufferLength < sizeof(VKBD_DeviceDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VKBD_DeviceDescriptor, sizeof(VKBD_DeviceDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VKBD_DeviceDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetReportDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_REPORT_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetReportDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Report Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Report Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetReportDescriptor\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(VKBD_ReportDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VKBD_ReportDescriptor, sizeof(VKBD_ReportDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VKBD_ReportDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetDeviceAttributes(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_ATTRIBUTES. The data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Attributes
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Attributes Copied
)
{
	PHID_DEVICE_ATTRIBUTES	pDeviceAttributes = (PHID_DEVICE_ATTRIBUTES)pvUserBuffer;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetDeviceAttributes\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(HID_DEVICE_ATTRIBUTES))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Fill out attributes structures
	pDeviceAttributes->Size = sizeof(HID_DEVICE_ATTRIBUTES);
	pDeviceAttributes->VendorID = MICROSOFT_VENDOR_ID;
	pDeviceAttributes->ProductID = VKBD_PRODUCT_ID;
	pDeviceAttributes->VersionNumber = VKBD_VERSION;
	// Record number of bytes copied
	*pulBytesCopied = sizeof(HID_DEVICE_ATTRIBUTES);
	// Return Success
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\vmmid.h ===
#ifndef	__VMMID_H__
#define	__VMMID_H__

// VMM Items we are interested in, the whole table is just to big to define
#define	__Hook_Device_Service 0x00010090
#define	__Unhook_Device_Service 0x0001011C

// Define the VKD service table (not so big, whole thing)
#define VKD_DEVICE_ID	    0x0000D
enum VKD_SERVICES {
    VKD_dummy = (VKD_DEVICE_ID << 16) - 1,
	__VKD_Get_Version,
	__VKD_Define_Hot_Key,
	__VKD_Remove_Hot_Key,
	__VKD_Local_Enable_Hot_Key,
	__VKD_Local_Disable_Hot_Key,
	__VKD_Reflect_Hot_Key,
	__VKD_Cancel_Hot_Key_State,
	__VKD_Force_Keys,
	__VKD_Get_Kbd_Owner,
	__VKD_Define_Paste_Mode,
	__VKD_Start_Paste,
	__VKD_Cancel_Paste,
	__VKD_Get_Msg_Key,
	__VKD_Peek_Msg_Key,
	__VKD_Flush_Msg_Key_Queue,
	//
	// The following services are new for Windows 4.0.
	//
	__VKD_Enable_Keyboard,
	__VKD_Disable_Keyboard,
	__VKD_Get_Shift_State,
	__VKD_Filter_Keyboard_Input,
	__VKD_Put_Byte,
	__VKD_Set_Shift_State,
	//
	// New for Windows 98 (VKD version 0300h)
	//
	__VKD_Send_Data,
	__VKD_Set_LEDs,
	__VKD_Set_Key_Rate,
	//VKD_Service VKD_Get_Key_Rate
    Num_VKD_Services
};

#define VxDCall(service)	\
	__asm _emit 0xcd \
	__asm _emit 0x20 \
	__asm _emit ((service) & 0xff) \
	__asm _emit (((service) >> 8) & 0xff) \
	__asm _emit (((service) >> 16) & 0xff) \
	__asm _emit (((service) >> 24) & 0xff)

#endif	__VMMID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\hidswvd.sys\hidswvd.h ===
//	@doc
/**********************************************************************
*
*	@module	HIDSWVD.h	|
*
*	Definitions and Declarations for Dummy Hid-Mini driver for virtual devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	HIDSWVD	|
*	The SideWinder Virtual Bus (SWVB) that is created by GcKernel needs a dummy
*	driver in order to expose HID devices.  The difficulty is that HIDCLASS
*	really does require a separate layer for these device objects.
*	This driver fits the bill.  It does absolutely nothing, except pass IRPs down
*	to the SWVB module in GcKernel which handles everything.
**********************************************************************/


// @struct HIDSWVB_EXTENSION | Minimum HID device extension.
typedef struct tagHIDSWVB_EXTENSION
{
	ULONG ulReserved;		// @field a Placeholder as extension needs non-zero size
} HIDSWVB_EXTENSION, *PHIDSWVB_EXTENSION;


//---------------------------------------------------------------------------
// Function prototypes
//---------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS
HIDSWVD_PassThrough(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
HIDSWVD_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );
NTSTATUS
HIDSWVD_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
	);

VOID
HIDSWVD_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

//-------------------------------------------------------------------------------
// Debug macros
//-------------------------------------------------------------------------------
#if (DBG==1)
#define HIDSWVD_DBG_PRINT(__x__)\
	{\
		DbgPrint("HIDSWVD: ");\
		DbgPrint __x__;\
	}
#else
#define HIDSWVD_DBG_PRINT(__x__)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\gckernel.h ===
//**************************************************************************
//
//		GCKERNEL.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		Global includes and definitions for GcKernel driver interface
//
//**************************************************************************

#ifndef	_GCKERNEL_H
#define	_GCKERNEL_H

#ifndef	RC_INVOKED
#include	<profile.h>
#endif

//---------------------------------------------------------------------------
//			Version Information
//---------------------------------------------------------------------------

#define	GCKERNEL_Major				0x03
#define	GCKERNEL_Minor				0x00
#define	GCKERNEL_Build				0x00
#define	GCKERNEL_Version_Rc		GCKERNEL_Major,GCKERNEL_Minor,0,GCKERNEL_Build
#define	GCKERNEL_Version_Int		((GCKERNEL_Build << 16)+(GCKERNEL_Major << 8)+(GCKERNEL_Minor))
#define	GCKERNEL_Company_Str		"Microsoft Corporation\0"
#define	GCKERNEL_Version_Str		"3.00.00\0"
#define	GCKERNEL_Product_Str		"Game Device Profiler Kernel Driver\0"
#define	GCKERNEL_Copyright_Str	"Copyright  Microsoft Corporation, 1998\0"
#ifdef	_NTDDK_
#define	GCKERNEL_Filename_Str	"Gckernel.Sys\0"
#else
#define	GCKERNEL_Filename_Str	"Gckernel.Vxd\0"
#endif

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	GCKERNEL_DEVICE_ID			0xE1
#define	MAX_ACTIVE_DEVICES 			4						// maximum active devices
#define	MAX_ACTIVE_PROFILES			4						// maximum active profiles

#define GCKNOTIFY_MACROINPROGRESS	1
#define GCKNOTIFY_IDLE				2

#ifdef	WIN_NT
#define	GCKERNEL_DEVICE_NAME			TEXT("\\Device\\GcKernel")
#define	GCKERNEL_DEVICE_NAME_U			 L"\\Device\\GcKernel"
#define	GCKERNEL_SYMBOLIC_NAME		TEXT("\\DosDevices\\GcKernel")
#define	GCKERNEL_SYMBOLIC_NAME_U		 L"\\DosDevices\\GcKernel"
#endif	// WIN_NT

#endif	// _GCKERNEL_H

//===========================================================================
//			End
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\hidswvd.sys\hidswvd.c ===
//	@doc
/**********************************************************************
*
*	@module	HIDSWVD.c	|
*
*	Implementation of the SideWinder Virtual Device Hid Mini-Driver
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	An overview is provided in HIDSWVD.H
*
*	@xref HIDSWVD
*
**********************************************************************/
#include <WDM.H>
#include <HIDPORT.H>
#include "HIDSWVD.H"

//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, HIDSWVD_Power)
#pragma alloc_text (PAGE, HIDSWVD_AddDevice)
#pragma alloc_text (PAGE, HIDSWVD_Unload)
#endif

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING puniRegistryPath)
**
**	@func	Initializes driver, by setting up serivces and registering with HIDCLASS.SYS
**
**	@rdesc	Returns value from HidRegisterMinidriver call.
**
*************************************************************************************/
NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT  pDriverObject, 	// @parm Driver Object from Loader
	IN PUNICODE_STRING puniRegistryPath	// @parm Registry Path for this Driver
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION HidMinidriverRegistration;
	
	PAGED_CODE();
	
	//This suffice as out entry trace out for DriverEntry, and tell everyone when we were built
	HIDSWVD_DBG_PRINT(("Built %s at %s\n", __DATE__, __TIME__));    
	
    //Setup Entry Table
	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HIDSWVD_PassThrough;
    pDriverObject->MajorFunction[IRP_MJ_PNP]                     = HIDSWVD_PassThrough;
	pDriverObject->MajorFunction[IRP_MJ_POWER]                   = HIDSWVD_Power;
	pDriverObject->DriverExtension->AddDevice                    = HIDSWVD_AddDevice;
    pDriverObject->DriverUnload                                  = HIDSWVD_Unload;

    
    // Setup registration structure for HIDCLASS.SYS module
    HidMinidriverRegistration.Revision              = HID_REVISION;
    HidMinidriverRegistration.DriverObject          = pDriverObject;
    HidMinidriverRegistration.RegistryPath          = puniRegistryPath;
    HidMinidriverRegistration.DeviceExtensionSize   = sizeof(HIDSWVB_EXTENSION);

    // SideWinder Virtual Devices are not polled.
    HidMinidriverRegistration.DevicesArePolled      = FALSE;

    //Register with HIDCLASS.SYS
	NtStatus = HidRegisterMinidriver(&HidMinidriverRegistration);

	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS HIDSWVD_PassThrough(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes IRPs down to SWVB module in GcKernel.
**
**	@rdesc	Value returned by IoCallDriver to GcKernel
**
*************************************************************************************/
NTSTATUS
HIDSWVD_PassThrough(
    IN PDEVICE_OBJECT pDeviceObject,	//@parm Device Object to pass down
    IN PIRP pIrp						//@parm IRP to pass down
    )
{
	//***
	//***	NO TRACEOUT HERE IT WOULD GET CALLED TOO FREQUENTLY
	//***

	//Get the top of stack from the HIDCLASS part of the device extension (this is documented).
	PDEVICE_OBJECT pTopOfStack = ((PHID_DEVICE_EXTENSION)pDeviceObject->DeviceExtension)->NextDeviceObject;
	//Call down to SWVB in GcKernel
	IoSkipCurrentIrpStackLocation (pIrp);
    return IoCallDriver (pTopOfStack, pIrp);
}

/***********************************************************************************
**
**	HIDSWVD_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pDeviceObject)		
**
**	@func	Does nothing, we need to have an AddDevice to be PnP compliant, but we have nothing
**			to do.
**	@rdesc	Returnes STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
HIDSWVD_AddDevice(
    IN PDRIVER_OBJECT pDriverObject,	//@parm Driver Object (for our reference)
    IN PDEVICE_OBJECT pDeviceObject		//@parm Device Object (already created by HIDCLASS.SYS)
    )
{
	PAGED_CODE();
    UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pDeviceObject);
	HIDSWVD_DBG_PRINT(("Device Object 0x%0.8x was added to pDriverObject 0x%0.8x\n", pDeviceObject, pDriverObject));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS HIDSWVD_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS HIDSWVD_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PDEVICE_OBJECT pTopOfStack = ((PHID_DEVICE_EXTENSION)pDeviceObject->DeviceExtension)->NextDeviceObject;

	PAGED_CODE ();

	//	Tell system we are ready for the next power IRP
    PoStartNextPowerIrp (pIrp);		        
    
	// NOTE!!! PoCallDriver NOT IoCallDriver.
	//Get the top of stack from the HIDCLASS part of the device extension (this is documented).
		
	IoSkipCurrentIrpStackLocation (pIrp);
    return  PoCallDriver (pTopOfStack, pIrp);
}

/***********************************************************************************
**
**	HIDSWVD_Unload(IN PDRIVER_OBJECT pDriverObject)
**
**	@func	Does nothing, but we will never be unloaded if we don't
**			return something.
**	@rdesc	None
**
*************************************************************************************/
VOID
HIDSWVD_Unload(
    IN PDRIVER_OBJECT pDriverObject	//@parm DriverObject - in case we store some globals in there.
    )
{
	UNREFERENCED_PARAMETER(pDriverObject);
	
	PAGED_CODE();

	HIDSWVD_DBG_PRINT(("Unloading\n"));    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\gckernel.inc ===
;**************************************************************************
;
;	GCKERNEL.H -- Xena Gaming Project
;
;	Version 3.XX
;
;	Copyright (c) 1998 Microsoft Corporation. All rights reserved.
;
;	Global includes and definitions for GcKernel driver interface
;
;**************************************************************************

GCKERNEL_DEVICE_ID 	EQU 0E1h	; make sure this is same as GCKERNEL.H

Begin_Service_Table	GCKERNEL
End_Service_Table	GCKERNEL

GCKernel_GetVersion 	EQU 70000001h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\ieevents.h ===
#ifndef __IEEVENTS_H_
#define __IEEVENTS_H_

#define	IE_KEY_MAXSTROKES				3

typedef	struct
{
	WORD				wVirtKey;
	WORD				wScanCode;
	BYTE				bFlags;	
}	IE_KEYSTROKE, *PIE_KEYSTROKE;

typedef	struct
{
	UINT				uCount;
	IE_KEYSTROKE	KeyStrokes[IE_KEY_MAXSTROKES];
}	IE_KEYEVENT,  *PIE_KEYEVENT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\profile.h ===
/****************************************************************************
*
*	File				:	PROFILE.H
*
*	Description		:	GDP Profile definition file.
*
*	Author			:	Jeffrey A. Davis. et. al.
*
*	Creation Date	:	You name it.
*
*	(c) 1986-1997 Microsoft Corporation.	All rights reserved.
*
****************************************************************************/

#ifndef _PROFILE_H
#define _PROFILE_H

#pragma pack(push, default_alignment)
#pragma pack(1)

#ifndef DWORD
#define DWORD unsigned long
#endif
#ifndef WORD
#define WORD unsigned short
#endif

#ifndef UINT
#define UINT unsigned int
#endif

#ifndef MAX_PATH
#define MAX_PATH (260)
#endif

#define ATLAS_DATAFORMAT_MAJ_VERSION	148
#define ATLAS_DATAFORMAT_MIN_VERSION	4
#define DATAFORMAT_MAJ_VERSION		3
#define DATAFORMAT_MIN_VERSION		0
#define DATAFORMAT_SIGNATURE			("SideWinder")
#define DATAFORMAT_SIGNATURE_LENGTH	10

#define GDP_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler"
#define PROPPAGE_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler\\Devices\\"
#define PROFILES_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler\\Profiles"
#define DEVICES_REGSTR PROPPAGE_REGSTR

// Device IDs
#define GDP_DEVNUM_JOLT						1
#define GDP_DEVNUM_FLASH					2
#define GDP_DEVNUM_JUNO						3
#define GDP_DEVNUM_MIDAS					4
#define GDP_DEVNUM_SHAZAM					5
#define GDP_DEVNUM_CLEO  					6

// GCKERNEL.VXD IOCTLs
#define	IOCTL_SET_PROFILE_ACTIVE		1
#define	IOCTL_SET_PROFILE_INACTIVE		2
#define	IOCTL_SUSPEND_PROFILE			3
#define	IOCTL_RESUME_PROFILE				4
#define	IOCTL_GETRAWPACKET				10		// debug only test hook
#define	IOCTL_SET_SENSE_CURVES			11		// debug only test hook

// OLD GDP 1.0 devive id definitions
#define SWGAMEPAD_PROFILER_BASE_ID		1
#define SW3DPRO_PROFILER_BASE_ID			5

typedef enum	{NO_DEVICE=-1, GAMEPAD=0, JOYSTICK, MOUSE, KEYBOARD}	DEVICETYPE;

#define MAX_PROPERTY_PAGES					04
#define MAX_PROFILE_NAME					MAX_PATH
#define MAX_DEVICE_NAME						64
#define MAX_MACRO_NAME						64
#define MAX_MACRO_EVENTS					32
#define MAX_BUTTON_MACROS					20
#define MAX_POV_MACROS						8
#define MAX_DPAD_MACROS						8
#define MAX_MACROS							(MAX_BUTTON_MACROS + MAX_POV_MACROS + MAX_DPAD_MACROS)
#define MAX_SCANCODES						03
#define MAX_ATLAS_MACROS					20

// Atlas SETTINGS Individual Flags
#define ATLAS_SETTINGS_EMULATE_CHPRO			0x01
#define ATLAS_SETTINGS_EMULATE_THRUSTMASTER	0x02
#define ATLAS_SETTINGS_SENSE_HIGH				0x04
#define ATLAS_SETTINGS_SENSE_MEDIUM				0x08
#define ATLAS_SETTINGS_SENSE_LOW					0x10
#define ATLAS_SETTINGS_AXISSWAP_TWIST			0x20
#define ATLAS_SETTINGS_AXISSWAP_LEFTRIGHT		0x40

// SETTINGS Group Flags
#define	ATLAS_SETTINGS_EMULATE_GROUP	(ATLAS_SETTINGS_EMULATE_CHPRO|ATLAS_SETTINGS_EMULATE_THRUSTMASTER)
#define	ATLAS_SETTINGS_SENSE_GROUP		(ATLAS_SETTINGS_SENSE_HIGH|ATLAS_SETTINGS_SENSE_MEDIUM|ATLAS_SETTINGS_SENSE_LOW)
#define	ATLAS_SETTINGS_AXISSWAP_GROUP	(ATLAS_SETTINGS_AXISSWAP_TWIST|ATLAS_SETTINGS_AXISSWAP_LEFTRIGHT)

// Xena SETTINGS flags
#define SETTINGS_EMULATION_GROUP		0x00000003
#define SETTINGS_EMULATION_CHPRO		0x00000001
#define SETTINGS_EMULATION_THRUSTMASTER	0x00000002
#define SETTINGS_AXIS_SWAP_GROUP		0x0000000C
#define SETTINGS_AXIS_SWAP_TWIST		0x00000004
#define SETTINGS_AXIS_SWAP_LEFT_RIGHT		0x00000008
#define SETTINGS_PEDAL_GROUP			0x00000030
#define SETTINGS_PEDAL_COMBINED		0x00000010
#define SETTINGS_PEDAL_SEPARATE		0x00000020
#define SETTINGS_X_DEAD_ZONE			0x00000040
#define SETTINGS_X_RANGE_OF_MOTION		0x00000080
#define SETTINGS_Y_DEAD_ZONE			0x00000100
#define SETTINGS_Y_RANGE_OF_MOTION		0x00000200
#define SETTINGS_Z_DEAD_ZONE			0x00000400
#define SETTINGS_Z_RANGE_OF_MOTION		0x00000800
#define SETTINGS_R_DEAD_ZONE			0x00001000
#define SETTINGS_R_RANGE_OF_MOTION		0x00002000
#define SETTINGS_U_DEAD_ZONE			0x00004000
#define SETTINGS_U_RANGE_OF_MOTION		0x00008000
#define SETTINGS_V_DEAD_ZONE			0x00010000
#define SETTINGS_V_RANGE_OF_MOTION		0x00020000

// MACRO types
#define BUTTON_MACRO	0
#define	POV_MACRO		1
#define DPAD_MACRO		2

// MACROEVENT Flags
#define MACROFLAG_KEYSONLY			0x00000001
#define MACROFLAG_HASDPADDATA		0x00000002

// PROFILE FLAGS
#define PROFILEFLAG_HAS_SETTINGS	0x00000001	
#define PROFILEFLAG_HAS_POVMACROS	0x00000002
#define PROFILEFLAG_HAS_DPADMACROS	0x00000004

typedef struct tagPROFENTRY
{
	char	szName[MAX_PROFILE_NAME];	// full path name.
	GUID	DevCLSID;						// device clsid.
	int	iActive;							// Bit field Active state
												// where: LSB = Device inst. 1
												//			 MSB = Device inst. 32	
}PROFENTRY;

typedef struct tagATLASPROFENTRY
{
	char	szName[MAX_PROFILE_NAME];	// full path name.
	int	iDevNumber;						// device number (GDP_DEVNUM_XXXX)
	int	iActive;							// Bit field Active state
												// where: LSB = Device inst. 1
												//			 MSB = Device inst. 32	
}ATLASPROFENTRY;


typedef struct tagSETTING
{
	DWORD	dwSettingsFlag;
	DWORD	dwXDeadZone;			// 0 to 1023
	DWORD	dwXRangeOfMotion;		// 0 to 1023
	DWORD	dwYDeadZone;			// 0 to 1023
	DWORD	dwYRangeOfMotion;		// 0 to 1023
	DWORD	dwZDeadZone;			// 0 to 1023
	DWORD	dwZRangeOfMotion;		// 0 to 1023
	DWORD	dwRDeadZone;			// 0 to 1023
	DWORD	dwRRangeOfMotion;		// 0 to 1023
	DWORD	dwUDeadZone;			// 0 to 1023
	DWORD	dwURangeOfMotion;		// 0 to 1023
	DWORD	dwVDeadZone;			// 0 to 1023
	DWORD	dwVRangeOfMotion;		// 0 to 1023
} SETTING, *PSETTING;

typedef struct tagATLAS_SETTING
{
	DWORD	dwSettingsFlag;
} ATLAS_SETTING, *PATLAS_SETTING;

typedef struct tagDEVICE_DATA
{
	WORD		wX;
	WORD		wY;
	WORD		wButtons;
	WORD		wPOV;
}	DEVICE_DATA,*PDEVICE_DATA;

typedef struct tagMACROEVENT
{
	DWORD			dwDuration;
	char			nKeyCodes;
	WORD			scanCode[MAX_SCANCODES];
	DEVICE_DATA		deviceData;
}	MACROEVENT,	*PMACROEVENT;

typedef struct tagATLAS_DEVICE_DATA
{
	WORD		wX;
	WORD		wY;
	WORD		wButtons;
}	ATLAS_DEVICE_DATA,*PATLAS_DEVICE_DATA;

typedef struct tagATLAS_MACROEVENT
{
	DWORD	dwDuration;
	char	nKeyCodes;
	WORD	scanCode[MAX_SCANCODES];
	ATLAS_DEVICE_DATA	deviceData;
}	ATLAS_MACROEVENT,	*PATLAS_MACROEVENT;

typedef struct tagMACRO
{
	char	name[MAX_MACRO_NAME];
	DWORD	macroTrigger;
	int		nEvents;
	DWORD	flags;
	MACROEVENT	event[MAX_MACRO_EVENTS];
}	MACRO,		*PMACRO;

typedef struct tagATLAS_MACRO
{
	char	name[MAX_MACRO_NAME];
	DWORD	macroTrigger;
	int		nEvents;
	DWORD	flags;
	ATLAS_MACROEVENT	event[MAX_MACRO_EVENTS];
}	ATLAS_MACRO,	*PATLAS_MACRO;


typedef struct tagPROFILEVERINFO
{
   DWORD dwMajorVersion;	// Data format major version.	     
	DWORD dwMinorVersion;   // Data format minor version.	       
	char	szSignature[10];	// "SideWinder"
} PROFILEVERINFO; 

typedef struct tagPROFILE_HEADER
{
	int				iSize;		// size of PROFILE
	PROFILEVERINFO	vi;				
	GUID				clsid;
}	PROFILE_HEADER;



typedef struct _VERSIONINFO
{
	DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion;     
	DWORD dwMinorVersion;     
	DWORD dwBuildNumber; 
    DWORD dwPlatformId;     
	char  szCSDVersion[128]; 
} VERSIONINFO; 

typedef struct tagATLAS_PROFILE_HEADER
{
	int				iSize;		// size of PROFILE
	VERSIONINFO		vi;				
	GUID				clsid;
}	ATLAS_PROFILE_HEADER;

//#ifdef _XENA

typedef struct tagPROFILE	
{
	PROFILE_HEADER header;
	DWORD	dwFlags;							
	SETTING	Settings;								
	DWORD	dwReserved1;						
	DWORD	dwReserved2;
	UINT	nMacros;

	UINT	nButtonMacros;								
	DWORD	dwButtonUsageArray;	
//	union tagBtn
//	{
		UINT	iButtonMacros;
//		MACRO*  aButtonMacro;
//	};

	UINT	nPOVMacros;								
	DWORD	dwPOVUsageArray;					
//	union tagPOV
//	{
		UINT	iPOVMacros;
//		MACRO*	aPOVMacro;
//	};

	UINT	nDPadMacros;
	DWORD	dwDPadUsageArray;
//	union tagDpad
//	{
		UINT	iDPadMacros;
//		MACRO*	aDPadMacro;
//	};

	MACRO macro[1];
}	PROFILE,	*PPROFILE;

typedef	struct tagACTIVE_PROFILE
{
	int		nUnitId;								
	PROFILE	Profile;								
	MACRO		btnMacros[MAX_BUTTON_MACROS-1];
	MACRO		povMacros[MAX_POV_MACROS];
	MACRO		dpadMacros[MAX_DPAD_MACROS];
}	ACTIVE_PROFILE, *PACTIVE_PROFILE;

typedef struct	tagATLAS_PROFILE
{
	UINT		uDeviceNumber;					//	see GDP_DEVNUM 
	DWORD		dwFlags;							// see PROFILE FLags
	int			nMacros;							// number of MACROs
	DWORD		dwMacroUsageArray;			// Macro Usage Bit Array.
	ATLAS_MACRO		Macros[MAX_ATLAS_MACROS];	// List of MACROs
	ATLAS_SETTING	Settings;						// SETTINGS
	DWORD		dwReserved1;					// future expansion
	DWORD		dwReserved2;
}	ATLAS_PROFILE,	*PATLAS_PROFILE;

typedef	struct tagACTIVE_ATLAS_PROFILE
{
	int		 nUnitId;								// instance of device
	ATLAS_PROFILE	Profile;						// profile for instance
}	ACTIVE_ATLAS_PROFILE, *PACTIVE_ATLAS_PROFILE;


//#endif // _XENA

#pragma pack(pop, default_alignment)

#endif	//	_PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\msgamio.h ===
//**************************************************************************
//
//		MSGAMIO.H -- Xena Gaming Project
//
//		Version 2.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	MSGAMIO.H | Global includes and definitions for gameport driver interface
//**************************************************************************

#ifndef	__MSGAMIO_H__
#define	__MSGAMIO_H__

#ifdef	SAITEK
#define	MSGAMIO_NAME				"SAIIO"
#else
#define	MSGAMIO_NAME				"MSGAMIO"
#endif

//---------------------------------------------------------------------------
//			Version Information
//---------------------------------------------------------------------------

#define	MSGAMIO_Major				0x02
#define	MSGAMIO_Minor				0x00
#define	MSGAMIO_Build				0x00
#define	MSGAMIO_Version_Rc		MSGAMIO_Major,MSGAMIO_Minor,0,MSGAMIO_Build
#define	MSGAMIO_Version_Int		((MSGAMIO_Build << 16)+(MSGAMIO_Major << 8)+(MSGAMIO_Minor))
#define	MSGAMIO_Version_Str		"2.00.00\0"
#define	MSGAMIO_Copyright_Str	"Copyright  Microsoft Corporation, 1998\0"

#ifdef	SAITEK
#define	MSGAMIO_Company_Str		"SaiTek Corporation\0"
#define	MSGAMIO_Product_Str		"SaiTek Gameport Driver Interface\0"
#ifdef	WIN_NT
#define	MSGAMIO_Filename_Str		"Saiio.Sys\0"
#else
#define	MSGAMIO_Filename_Str		"Saiio.Vxd\0"
#endif
#else
#define	MSGAMIO_Company_Str		"Microsoft Corporation\0"
#define	MSGAMIO_Product_Str		"SideWinder Gameport Driver Interface\0"
#ifdef	WIN_NT
#define	MSGAMIO_Filename_Str		"Msgamio.Sys\0"
#else
#define	MSGAMIO_Filename_Str		"Msgamio.Vxd\0"
#endif
#endif

//**************************************************************************
#ifndef	RC_INVOKED												// Skip Rest of File
//**************************************************************************

//---------------------------------------------------------------------------
//			Global Limits
//---------------------------------------------------------------------------

#define	MAX_MSGAMIO_SERVERS			4
#define	MAX_MSGAMIO_CLIENTS			16

//---------------------------------------------------------------------------
//			Transaction Types
//---------------------------------------------------------------------------

typedef enum
{												// @enum MSGAMIO_TRANSACTIONS | Device transaction types
	MSGAMIO_TRANSACT_NONE,				// @emem No transaction type
	MSGAMIO_TRANSACT_RESET,				// @emem Reset transaction type
	MSGAMIO_TRANSACT_DATA,				// @emem Data transaction type
	MSGAMIO_TRANSACT_ID,	  				// @emem Id transaction type
	MSGAMIO_TRANSACT_STATUS,			// @emem Status transaction type
	MSGAMIO_TRANSACT_SPEED,				// @emem Speed transaction type
	MSGAMIO_TRANSACT_GODIGITAL,		// @emem GoDigital transaction type
	MSGAMIO_TRANSACT_GOANALOG			// @emem GoAnalog transaction type
} 	MSGAMIO_TRANSACTION;

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

#ifndef	STDCALL
#define	STDCALL		_stdcall
#endif

//---------------------------------------------------------------------------
//			GUIDs
//---------------------------------------------------------------------------


#ifndef	GUID_DEFINED
#define	GUID_DEFINED

typedef struct
{
#pragma pack (1)
	unsigned	long	Data1;
	unsigned	short	Data2;
	unsigned	short	Data3;
	unsigned	char	Data4[8];
#pragma pack()
}	GUID, *PGUID;

#else

typedef	GUID	*PGUID;

#endif	//	GUID_DEFINED

__inline BOOLEAN STDCALL IsGUIDEqual (PGUID pGuid1, PGUID pGuid2)
{
	ULONG		i	=	sizeof(GUID);
	PUCHAR	p1 =	(PUCHAR)pGuid1;
	PUCHAR	p2 =	(PUCHAR)pGuid2;

	while (i--)
		if (*p1++ != *p2++)
			return (FALSE);
	return (TRUE);
}

//---------------------------------------------------------------------------
//			Server GUIDs
//---------------------------------------------------------------------------

#ifdef	SAITEK
#define	MSGAMIO_MSGAME_GUID		\
			{0xcaca0c60,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#define	MSGAMIO_GCKERNEL_GUID	\
			{0xcaca0c61,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#else
#define	MSGAMIO_MSGAME_GUID		\
			{0xb9292380,0x628a,0x11d1,0xaa,0xa5,0x04,0x76,0xa6,0x00,0x00,0x00}
#define	MSGAMIO_GCKERNEL_GUID	\
			{0x95e69580,0x97d5,0x11d1,0x99,0x6f,0x00,0xa0,0x24,0xbe,0xbf,0xf5}
#endif

//---------------------------------------------------------------------------
//			Client GUIDs
//---------------------------------------------------------------------------

#define	MSGAMIO_MIDAS_GUID	\
			{0x12D41A36,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_JUNO_GUID		\
			{0xC948CE81,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_JOLT_GUID		\
			{0xC948CE82,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_SHAZAM_GUID	\
			{0xC948CE83,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_FLASH_GUID	\
			{0xC948CE84,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_TILT_GUID		\
			{0xC948CE86,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_TILTUSB_GUID		\
			{0xC948CE89,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_APOLLO_GUID	\
			{0xC948CE88,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#ifdef	SAITEK
#define	MSGAMIO_LEDZEP_GUID	\
			{0xcaca0c62,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#else
#define	MSGAMIO_LEDZEP_GUID	\
			{0xC948CE87,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}
#endif

//---------------------------------------------------------------------------
//			Macros
//---------------------------------------------------------------------------

#ifndef	STILL_TO_DO
#define	STD0(txt)			#txt
#define	STD1(txt)			STD0(txt)
#define	STILL_TO_DO(txt)	message("\nSTILL TO DO: "__FILE__"("STD1(__LINE__)"): "#txt"\n")
#endif

//---------------------------------------------------------------------------
//			Control Codes
//---------------------------------------------------------------------------

#define	IOCTL_INTERNAL_MSGAMIO_BASE	0xB00

#define	IOCTL_INTERNAL_MSGAMIO_UNLOAD \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+0,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_CONNECT_SERVER \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+1,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_DISCONNECT_SERVER \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+2,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_CONNECT_CLIENT \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+3,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_DISCONNECT_CLIENT \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+4,METHOD_NEITHER,FILE_ANY_ACCESS)

//---------------------------------------------------------------------------
//			Structures
//---------------------------------------------------------------------------

typedef	struct
{	// @struct DRIVERSERVICES | Device services table

	// @field ULONG | Size | Size of structure
	ULONG	Size;

	// @field GUID | Server | Server GUID
	GUID	Server;

	// @field VOID (*Connect)(ConnectInfo) | ConnectInfo | Connection service procedure
	VOID	(STDCALL *Connect)(PVOID ConnectInfo);

	// @field VOID (*Disconnect)(ConnectInfo) | ConnectInfo | Disconnection service procedure
	VOID	(STDCALL *Disconnect)(PVOID ConnectInfo);

	// @field VOID (*Transact)(PacketInfo) | PacketInfo | Transaction hook procedure
	VOID	(STDCALL *Transact)(PVOID PacketInfo);

	// @field VOID (*Packet)(PacketData) | PacketData | Packet hook procedure
	VOID	(STDCALL *Packet)(PVOID PacketData);

	// @field NTSTATUS (*ForceReset)(VOID) | None | Reset force feedback device
	NTSTATUS	(STDCALL *ForceReset)(VOID);

	// @field NTSTATUS (*ForceId)(IdString) | IdString | Gets force feedback id string
	NTSTATUS	(STDCALL *ForceId)(PVOID IdString);

	// @field NTSTATUS (*ForceStatus)(Status) | Status | Gets raw force feedback status
	NTSTATUS	(STDCALL *ForceStatus)(PVOID Status);
	
	// @field NTSTATUS (*ForceAckNak)(AckNak) | AckNak | Gets force feedback ack nak
	NTSTATUS	(STDCALL *ForceAckNak)(PUCHAR AckNak);

	// @field NTSTATUS (*ForceNakAck)(NakAck) | NakAck | Gets force feedback nak ack
	NTSTATUS	(STDCALL *ForceNakAck)(PUCHAR NakAck);

	// @field NTSTATUS (*ForceSync)(Sync) | Sync | Reads byte from gameport to sync
	NTSTATUS	(STDCALL *ForceSync)(PUCHAR Sync);

	// @field ULONG (*Register)(Device, UnitId) | Device, UnitId | Registers device with Gckernel
	ULONG	(STDCALL *Register)(PGUID Device, ULONG UnitId);

	// @field VOID	(*Unregister) (Handle) | Handle | Unregisters device with Gckernel
	VOID	(STDCALL *Unregister) (ULONG Handle);

	// @field VOID	(*Notify) (Handle, DevInfo, PollData) | Handle, DevInfo, PollData | Sends packet for Gckernel processing
	VOID	(STDCALL *Notify) (ULONG Handle, PVOID DevInfo, PVOID PollData);

}	MSGAMIO_CONNECTION, *PMSGAMIO_CONNECTION;

//---------------------------------------------------------------------------
//		Global Procedures
//---------------------------------------------------------------------------

// @func		NTSTATUS | MSGAMIO_DoConnection | Calls MSGAMIO internal control interface
//	@parm		ULONG						|	ControlCode	|	IO control code
//	@parm		PMSGAMIO_CONNECTION	|	ConnectInfo	|	Connection structure
// @rdesc	Returns NT status code
//	@comm		Inline function

//---------------------------------------------------------------------------
//		Private Procedures
//---------------------------------------------------------------------------

NTSTATUS	STDCALL MSGAMIO_DoConnection (ULONG ControlCode, PMSGAMIO_CONNECTION InputBuffer);

//===========================================================================
//			WDM Interface
//===========================================================================

#ifdef	_NTDDK_

#ifdef	SAITEK
#define	MSGAMIO_DEVICE_NAME			TEXT("\\Device\\Saiio")
#define	MSGAMIO_DEVICE_NAME_U			 L"\\Device\\Saiio"
#define	MSGAMIO_SYMBOLIC_NAME		TEXT("\\DosDevices\\Saiio")
#define	MSGAMIO_SYMBOLIC_NAME_U			 L"\\DosDevices\\Saiio"
#else
#define	MSGAMIO_DEVICE_NAME			TEXT("\\Device\\MsGamio")
#define	MSGAMIO_DEVICE_NAME_U			 L"\\Device\\MsGamio"
#define	MSGAMIO_SYMBOLIC_NAME		TEXT("\\DosDevices\\MsGamio")
#define	MSGAMIO_SYMBOLIC_NAME_U			 L"\\DosDevices\\MsGamio"
#endif

//---------------------------------------------------------------------------
__inline NTSTATUS STDCALL MSGAMIO_Connection (ULONG ControlCode, PMSGAMIO_CONNECTION ConnectInfo)
//---------------------------------------------------------------------------
	{
	NTSTATUS				ntStatus;
	PIRP					pIrp;
	KEVENT				Event;
	PFILE_OBJECT		FileObject;
	PDEVICE_OBJECT		DeviceObject;
	UNICODE_STRING		ObjectName;
	IO_STATUS_BLOCK	IoStatus;

	//
	//	Validate parameters
	//

	ASSERT (ConnectInfo);
	ASSERT (KeGetCurrentIrql()<=DISPATCH_LEVEL);

	//
	//	Retrieve the driver device object
	//

	RtlInitUnicodeString (&ObjectName, MSGAMIO_DEVICE_NAME_U);
	ntStatus = IoGetDeviceObjectPointer (&ObjectName, FILE_ALL_ACCESS, &FileObject, &DeviceObject);
	if (!NT_SUCCESS(ntStatus))
		{
		KdPrint (("%s_Connection: IoGetDeviceObjectPointer (%ws) failed, status = 0x%X", MSGAMIO_NAME, ObjectName.Buffer, ntStatus));
		return (ntStatus);
		}
	
	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (ControlCode, DeviceObject, ConnectInfo, sizeof (MSGAMIO_CONNECTION), NULL, 0, TRUE, &Event, &IoStatus);
					
	//
	//	Call MsGamIo synchronously
	//

	KdPrint (("%s_Connection: Calling %s (%lu)\n", MSGAMIO_NAME, MSGAMIO_NAME, ControlCode));
	ntStatus = IoCallDriver (DeviceObject, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	//
	//	Check asynchronous status
	//

	if (!NT_SUCCESS (ntStatus))
		KdPrint (("%s_Connection: %s (%lu) failed, Status = %X\n", MSGAMIO_NAME, MSGAMIO_NAME, ControlCode, ntStatus));

	//
	//	Free file object associated with device
	//

	ObDereferenceObject (FileObject);

	//
	//	Return status
	//

	return (ntStatus);
	}

#endif

//===========================================================================
//			VXD Definitions
//===========================================================================

#ifndef	_NTDDK_

#ifdef	SAITEK
#define 	MSGAMIO_DEVICE_ID				0x11EF
#else
#define 	MSGAMIO_DEVICE_ID				0x1EF
#endif

#pragma	warning (disable:4003)
			Begin_Service_Table			(MSGAMIO)
			Declare_Service				(MSGAMIO_Service, LOCAL)
			End_Service_Table				(MSGAMIO)
#pragma	warning (default:4003)

//---------------------------------------------------------------------------
__inline NTSTATUS STDCALL MSGAMIO_Connection (ULONG ControlCode, PMSGAMIO_CONNECTION ConnectInfo)
//---------------------------------------------------------------------------
	{
	NTSTATUS	ntStatus = STATUS_INVALID_DEVICE_REQUEST;

	//
	//	First check if Vxd present
	//

	if (ConnectInfo)
		{
		_asm	stc
		_asm	xor	eax, eax
		_asm	xor	ebx, ebx
		VxDCall (MSGAMIO_Service);
		_asm	{
				jc		Failure
				_asm	mov [ntStatus], eax
				Failure:
				}
		}

	if (!NT_SUCCESS(ntStatus))
		KdPrint (("%s_Connection Failed to Find %s", MSGAMIO_NAME, MSGAMIO_Filename_Str));

	//
	//	Then call for service
	//

	if (NT_SUCCESS(ntStatus))
		{
		_asm	mov	eax, ControlCode
		_asm	mov	ebx, ConnectInfo
		VxDCall (MSGAMIO_Service);
		_asm	mov [ntStatus], eax
		if (!NT_SUCCESS(ntStatus))
			KdPrint (("%s_Connection Failed Service Call %ld", MSGAMIO_NAME, ControlCode));
		}

	//
	//	Return status
	//

	return (ntStatus);
	}

#endif	// _NTDDK_

//**************************************************************************
#endif	//	RC_INVOKED											// Skip Rest of File
//**************************************************************************

#endif	// __MSGAMIO_H__

//===========================================================================
//			End
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\inc\swforce.h ===
//**************************************************************************
//
//		SWFORCE.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	SWFORCE.H | Global includes and definitions for force feedback driver interface
//**************************************************************************

#ifndef	__SWFORCE_H__
#define	__SWFORCE_H__

#ifdef	SAITEK
#define	SWFORCE_NAME				"SAIFORCE"
#else
#define	SWFORCE_NAME				"SWFORCE"
#endif

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

typedef	struct
{
#pragma pack(1)
	ULONG	cBytes;
	LONG	dwXVel;
	LONG	dwYVel;
	LONG	dwXAccel;
	LONG	dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
#pragma pack()
}	JOYCHANNELSTATUS,	*PJOYCHANNELSTATUS;

typedef struct
{
#pragma pack(1)
	ULONG	cBytes;	
	ULONG	dwProductID;
	ULONG	dwFWVersion;
#pragma pack()
} PRODUCT_ID, *PPRODUCT_ID;

//---------------------------------------------------------------------------
//			IOCTLs
//---------------------------------------------------------------------------

#define IOCTL_GET_VERSION	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_GET_VERSION
// lpvInBuffer			= NULL
// cbInBuffer			= 0
// lpvOutBuffer		= PULONG (HIWORD = Ver. high, LoWord - Ver. Low)
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETSTATUS	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETSTATUS
// lpvInBuffer			= PJOYCHANNELSTATUS
// cbInBuffer			= sizeof(JOYCHANNELSTATUS)
// lpvOutBuffer		= PJOYCHANNELSTATUS
// cbOutBuffer			= sizeof(JOYCHANNELSTATUS)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETID	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETID
// lpvInBuffer			= PPRODUCT_ID
// cbInBuffer			= sizeof(PRODUCT_ID)
// lpvOutBuffer		= PPRODUCT_ID
// cbOutBuffer			= sizeof(PRODUCT_ID)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETACKNACK	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETACKNAK
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETSYNC	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETSYNC
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETNACKACK	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETNACKACK
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_SETPORT		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_SETPORT
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_SENDDATA	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_SENDDATA
// lpvInBuffer			= PUCHAR
// cbInBuffer			= Bytes to send
// lpvOutBuffer		= PUCHAR
// cbOutBuffer			= Bytes to send
// lpcbBytesReturned	= Bytes sent

#define IOCTL_SWFORCE_RESET	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_RESET
// lpvInBuffer			= NULL
// cbInBuffer			= 0
// lpvOutBuffer		= LPDWORD
// cbOutBuffer			= sizeof(DWORD)
// lpcbBytesReturned	= Bytes returned based on result

#endif	//__SWFORCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	DEBUG.H | Global includes and definitions for debugging output
//**************************************************************************

#ifndef	DEBUG_H
#define	DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

typedef enum
{												// @enum DBG_LEVEL | Debug verbosity levels
	DBG_CRITICAL,							// @emem Critical debug output
	DBG_SEVERE,								// @emem Severe debug output
	DBG_CONTROL,							// @emem Control debug output (default)
	DBG_INFORM,								// @emem Inform debug output
	DBG_VERBOSE								// @emem Verbose debug output
}	DBG_LEVEL;

//
//	Default output verbosity level
//

#define	DBG_DEFAULT				DBG_CONTROL

//
//	Conditional debug output procedures
//

// jacklin - Windows bug 321472. Disabling debug output even for chk build
#if		(DBG==1 && defined(I_WANT_DEBUG_OUTPUT_AND_BREAK_BVT))

#define	MsGameLevel(x)				DEBUG_Level (x)
#define	MsGamePrint(x)				DEBUG_Print x
#define	MsGameBreak()				DbgBreakPoint ()
#undef	PAGED_CODE
#define	PAGED_CODE() \
    		if (KeGetCurrentIrql() > APC_LEVEL)	\
				{\
         	MsGamePrint((DBG_CRITICAL,"%s: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n",MSGAME_NAME,KeGetCurrentIrql(),__FILE__,__LINE__));\
				ASSERT(FALSE); \
				}

#else		// DBG=0

#define	MsGameLevel(x)
#define	MsGamePrint(x)
#define	MsGameBreak()
#undef	PAGED_CODE
#define	PAGED_CODE()

#endif	// DBG=?

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

DBG_LEVEL
DEBUG_Level (
	IN		DBG_LEVEL uLevel
	);

VOID
DEBUG_Print (
	IN		DBG_LEVEL uLevel,
	IN		PCSZ szMessage,
	IN		...
	);

//===========================================================================
//			End
//===========================================================================

#endif	// DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\device.c ===
//**************************************************************************
//
//		DEVICE.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	DEVICE.C | Routines to support device class calls
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, DEVICE_DriverEntry)
#endif

//---------------------------------------------------------------------------
//			Device Delcarations
//---------------------------------------------------------------------------

			#ifndef	SAITEK
			DECLARE_DEVICE(Midas);
			DECLARE_DEVICE(Juno);
			DECLARE_DEVICE(Jolt);
			DECLARE_DEVICE(GamePad);
			DECLARE_DEVICE(Tilt);
			#endif
			DECLARE_DEVICE(LedZep);

static	PDEVICEINFO		MiniDrivers[]	=	{
														#ifndef	SAITEK
														INSTANCE_DEVICE(Midas), //default
														INSTANCE_DEVICE(Juno),
														INSTANCE_DEVICE(Jolt),
														INSTANCE_DEVICE(GamePad),
														INSTANCE_DEVICE(Tilt),
														#endif
														INSTANCE_DEVICE(LedZep)
											};

//---------------------------------------------------------------------------
//			Private	Data
//---------------------------------------------------------------------------

static	BOOLEAN		DeviceDetected								=	FALSE;
static	ULONG			DetectAttempts								=	0;
static	ULONG			LastDetectTime								=	0;
static	KIRQL			SpinLockIrql								=	PASSIVE_LEVEL;
static	KSPIN_LOCK	DevSpinLock									=	{0};
static	ULONG			SuccessPackets[MAX_DEVICE_UNITS]		=	{0,0,0,0};
static	ULONG			PollingAttempts[MAX_DEVICE_UNITS]	=	{0,0,0,0};

//---------------------------------------------------------------------------
//			Public Data
//---------------------------------------------------------------------------

public	ULONG			POV_Values[]		=	{
														JOY_POVCENTERED,
														JOY_POVFORWARD,
														JOY_POVFORWARD+4500,
														JOY_POVRIGHT,
														JOY_POVRIGHT+4500,
														JOY_POVBACKWARD,
														JOY_POVBACKWARD+4500,
														JOY_POVLEFT,
														JOY_POVLEFT+4500
														};

public	ULONG			PollingInterval	=	POLLING_INTERVAL;

//---------------------------------------------------------------------------
//			Private	Procedures
//---------------------------------------------------------------------------

static	VOID		DEVICE_AcquireDevice (VOID);
static	VOID		DEVICE_ReleaseDevice (VOID);
static	NTSTATUS	DEVICE_HotPlugDevice (PGAMEPORT PortInfo);
static	NTSTATUS	DEVICE_RemoveSiblings (PGAMEPORT PortInfo);
static	BOOLEAN	DEVICE_DetectClocks (PGAMEPORT PortInfo, ULONG TimeOut);
static	BOOLEAN	DEVICE_QuickDetect (PGAMEPORT PortInfo);
static	NTSTATUS	DEVICE_DetectDevices (PGAMEPORT PortInfo);

//---------------------------------------------------------------------------
// @func		Acquires exclusive access to gameport (mutex)
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	DEVICE_AcquireDevice (VOID)
{
	KeAcquireSpinLock (&DevSpinLock, &SpinLockIrql);
}

//---------------------------------------------------------------------------
// @func		Releases exclusive access to gameport (mutex)
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	DEVICE_ReleaseDevice (VOID)
{
	KeReleaseSpinLock (&DevSpinLock, SpinLockIrql);
}

//---------------------------------------------------------------------------
// @func		Detects hot-plugging of gamepad devices
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_SIBLING_REMOVED			| An device has been removed
//	@flag		STATUS_SIBLING_ADDED				| An device has been added
//	@flag		STATUS_SUCCESS						| Everything is fine
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_HotPlugDevice (PGAMEPORT PortInfo)
{
	ULONG			UnitId;
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_HotPlugDevice Enter\n"));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo || !DevInfo->NumDevices)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_HotPlugDevice Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Get UnitId for tracking by device
	//

	UnitId = GET_DEVICE_UNIT(PortInfo);

	//
	//	Check if number devices has changed
	//

   if (((DevInfo->DeviceCount+DevInfo->DevicePending) != DevInfo->NumDevices) && (SuccessPackets[UnitId]++ > HOT_PLUG_PACKETS))
	   {
      SuccessPackets[UnitId] = 0;
		if ((DevInfo->DeviceCount+DevInfo->DevicePending) > DevInfo->NumDevices)
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_HotPlugDevice Removing Sibling\n", MSGAME_NAME));
			//
			//	Decrement pending count to avoid removing twice
			//
			InterlockedDecrement (&DevInfo->DevicePending);
			return (STATUS_SIBLING_REMOVED);
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_HotPlugDevice Adding Sibling\n", MSGAME_NAME));
			//
			//	Increment pending count to avoid adding twice
			//
			InterlockedIncrement (&DevInfo->DevicePending);
			return (STATUS_SIBLING_ADDED);
			}
   	}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_HotPlugDevice Exit\n", MSGAME_NAME));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Removes sibling lists if possible
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_SIBLING_REMOVED			| An device has been removed
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_RemoveSiblings (PGAMEPORT PortInfo)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_RemoveSiblings Enter\n"));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_RemoveSiblings Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Zero number of devices
	//

	DevInfo->NumDevices = 1;

	//
	//	Check if more than one device
	//

   if ((DevInfo->DeviceCount+DevInfo->DevicePending) > 1)
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_RemoveSiblings Removing Sibling\n", MSGAME_NAME));
		//
		//	Decrement pending count to avoid removing twice
		//
		InterlockedDecrement (&DevInfo->DevicePending);
		return (STATUS_SIBLING_REMOVED);
		}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_RemoveSiblings Exit\n", MSGAME_NAME));
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Detect digital gameport clocks
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | TimeOut | Loops to try for clocks
// @rdesc	Returns true if clocks detected, false otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN  DEVICE_DetectClocks (PGAMEPORT PortInfo, ULONG TimeOut)
{
	BOOLEAN	Result = FALSE;

	_asm
		{
		;StartLoop:
			xor	ebx, ebx
			mov	edx, PortInfo
			mov	ecx, TimeOut

			push	0								; write byte to gameport
			push	edx
			call	PORTIO_Write

			push	edx							; read byte from gameport
			call	PORTIO_Read
			mov	ah, al

		ClockLoop:
			push	edx							; read byte from gameport
			call	PORTIO_Read
			xor	al, ah
			test	al, CLOCK_BIT_MASK
			je		NextLoop

		;FoundClock:
			inc	ebx
			cmp	ebx, QUICK_DETECT_CLOCKS
			jb		NextLoop
			mov	Result, TRUE
			jmp	ExitLoop

		NextLoop:
			loop	ClockLoop

		ExitLoop:
			nop
		}

	return (Result);
}
	
//---------------------------------------------------------------------------
// @func		Detects whether digital device is connected
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns true if clocks detected, false otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN  DEVICE_QuickDetect (PGAMEPORT PortInfo)
{
	ULONG				i;
	ULONG				TimeOut;
	DETECT_ORDER	DetectOrder;

	TimeOut = TIMER_CalibratePort (PortInfo, QUICK_DETECT_TIME);

	if (DEVICE_DetectClocks (PortInfo, TimeOut))
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Found Digital Clocks!\n", MSGAME_NAME));
		return (TRUE);
		}

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Trying Analog Devices\n", MSGAME_NAME));
	for (DetectOrder = DETECT_FIRST; DetectOrder <= DETECT_LAST; DetectOrder++)
   	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
			if (MiniDrivers[i]->DetectOrder == DetectOrder)
				if (MiniDrivers[i]->IsAnalog)
   		   	if (MiniDrivers[i]->Services->ConnectDevice (PortInfo) == STATUS_SUCCESS)
						{
						MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Found Analog Device!\n", MSGAME_NAME));
						return (TRUE);
						}

	MsGamePrint ((DBG_SEVERE, "%s: DEVICE_QuickDetect Failed to Find Digital Device!\n", MSGAME_NAME));
	return (FALSE);	
}

//---------------------------------------------------------------------------
// @func		Detects which device type is connected
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_DEVICE_CHANGED			| The device has changed
//	@flag		STATUS_SUCCESS						| Everything is fine
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_DetectDevices (PGAMEPORT PortInfo)
{
	ULONG				i, j;
	PDEVICEINFO		DevInfo;
	DETECT_ORDER	DetectOrder;

	//
	//	This an initial redetect or system startup device
	//

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_DetectDevices Enter\n", MSGAME_NAME));

	//
	//	Skip if we've already detected a new device removed this one
	//

	if (GET_DEVICE_DETECTED (PortInfo))
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Device Already Detected!\n", MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if we're trying too hard
	//

   if (DetectAttempts++ > MAX_DETECT_ATTEMPTS)
   	{
		if (TIMER_GetTickCount () < (LastDetectTime + MAX_DETECT_INTERVAL))
   	 	return (STATUS_DEVICE_NOT_CONNECTED);
		LastDetectTime = TIMER_GetTickCount();
   	}

	//
	//	Calibrate timer each try
	//

   TIMER_Calibrate ();

	//
	//	Calibrate port timeouts
	//

	PORTIO_CalibrateTimeOut (PortInfo);

	//
	//	Perform quick detection in case none attached
	//

	if (DEVICE_QuickDetect (PortInfo))
		{
		for (DetectOrder = DETECT_FIRST; DetectOrder <= DETECT_LAST; DetectOrder++)
   		for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
				if (MiniDrivers[i]->DetectOrder == DetectOrder)
   		   	if (MiniDrivers[i]->Services->ConnectDevice (PortInfo) == STATUS_SUCCESS)
						{
						MsGamePrint ((DBG_CONTROL, "%s: %s Connected OK\n", MSGAME_NAME, MiniDrivers[i]->DeviceName));
						DeviceDetected			= TRUE;
						DetectAttempts			= 0;
						PollingAttempts[0]	= 0;
						if (!DevInfo)
							{
							//
							//	Assign device type
							//
							SET_DEVICE_INFO (PortInfo, MiniDrivers[i]);
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Setting Device\n", MSGAME_NAME));
							return (STATUS_SUCCESS);
							}
						else if (DevInfo != MiniDrivers[i])
							{
							//
							//	Change device type
							//
							SET_DEVICE_DETECTED (PortInfo, MiniDrivers[i]);
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Changing Device\n", MSGAME_NAME));
							return (STATUS_DEVICE_CHANGED);
							}
						else
							{
							//
							//	Same device found
							//
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Same Device Found\n", MSGAME_NAME));
							return (STATUS_SUCCESS);
							}
						}
		}

	//
	//	Mark device not detected
	//

	DeviceDetected = FALSE;

	//
	//	Return status
	//

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Failed\n", MSGAME_NAME));
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Calcuates and returns is data is odd parity
//	@parm		PVOID | Data | Pointer to raw data
//	@parm		ULONG | Size | Size of raw data buffer
// @rdesc	True if oded parity, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	DEVICE_IsOddParity (PVOID Data, ULONG Count)
{
	LONG	Result =	ERROR_SUCCESS;
	LONG	Parity;

	__asm
		{
			push	edi
			push	esi

			mov	esi, Data
			mov	ecx, Count
			xor	eax, eax
			
		IsOddLoop:

			xor	al, [esi]
			inc	esi
			loop	IsOddLoop

			xor	al, ah
			jpo	IsOddComplete

			mov	Parity, eax
			mov	Result, ERROR_PARITYBITS

		IsOddComplete:

			pop	esi
			pop	edi
		}

	if (Result == ERROR_PARITYBITS)
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_IsOddParity - Parity bits failed %ld\n", MSGAME_NAME, Parity));

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device layer
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_DriverEntry (VOID)
{
	ULONG		i;
	NTSTATUS	ntStatus;

	KeInitializeSpinLock (&DevSpinLock);

  	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
		{
		//
		//	Call Mini-DriverEntry
		//
		ntStatus = MiniDrivers[i]->Services->DriverEntry ();
		if (NT_ERROR(ntStatus))
			{
			//
			//	Abort driver loading
			//
			MsGamePrint ((DBG_SEVERE, "%s: DEVICE_DriverEntry: %s Failed Driver Entry\n", MSGAME_NAME, MiniDrivers[i]->DeviceName));
			break;
			}
		}

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Detects gameport IO collisions
//	@parm		PPACKETINFO | DataPacket | Device packet info struct
// @rdesc	Returns True for collision, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	DEVICE_IsCollision (PPACKETINFO DataPacket)
{
	if ((DataPacket->TimeStamp + PollingInterval) > TIMER_GetTickCount ())
		return (TRUE);

	return (PORTIO_IsClockActive (&DataPacket->PortInfo, DataPacket->ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Copies and returns HID device descriptor for a device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Descriptor | Output buffer for descriptor
//	@parm		ULONG | MaxSize | Size of buffer for descriptor
//	@parm		PULONG | Copied | Bytes copied to buffer for descriptor
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetDeviceDescriptor (PGAMEPORT PortInfo, PUCHAR Descriptor, ULONG MaxSize, PULONG Copied)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetDeviceDescriptor Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Zero returned size first
	//
	
	*Copied = 0;

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetDeviceDescriptor Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Check output buffer size
	//

	if (MaxSize < sizeof (HID_DESCRIPTOR))
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetDeviceDescriptor - Buffer too small = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Copy descriptor to output buffer
	//

	memcpy (Descriptor, DevInfo->DevDescriptor, sizeof (HID_DESCRIPTOR));

	//
	//	Return number bytes copied
	//

	*Copied = sizeof (HID_DESCRIPTOR);

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Copies and returns HID report descriptor for a device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Descriptor | Output buffer for descriptor
//	@parm		ULONG | MaxSize | Size of buffer for descriptor
//	@parm		PULONG | Copied | Bytes copied to buffer for descriptor
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetReportDescriptor (PGAMEPORT PortInfo, PUCHAR Descriptor, ULONG MaxSize, PULONG Copied)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetReportDescriptor Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Zero returned size first
	//
	
	*Copied = 0;

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetReportDescriptor Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Check output buffer size
	//

	if (MaxSize < DevInfo->RptDescSize)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetReportDescriptor Buffer too small = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Copy descriptor to output buffer
	//

	memcpy (Descriptor, DevInfo->RptDescriptor, DevInfo->RptDescSize);

	//
	//	Return number bytes copied
	//

	*Copied = DevInfo->RptDescSize;

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_StartDevice (PGAMEPORT PortInfo, PWCHAR HardwareId)
{
	ULONG			i, UnitId, Default = 0;
	PGAMEPORT	p, *Device;
	PDEVICEINFO	DevInfo = NULL;

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Called For %ws\n", MSGAME_NAME, HardwareId));

	//
	//	Try requested device based on HardwareId
	//

	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
		if (MSGAME_CompareHardwareIds (HardwareId, MiniDrivers[i]->HardwareId))
			{
			Default = i;
	   	if (NT_SUCCESS(MiniDrivers[i]->Services->ConnectDevice (PortInfo)))
				DevInfo = MiniDrivers[i];
			break;
			}

	//
	//	If requested device fails, do a detect
	//

	if (!DevInfo)
		{
		DEVICE_DetectDevices (PortInfo);
		DevInfo = GET_DEVICE_INFO (PortInfo);
		}

	//
	//	If	detect fails, force the requested device
	//

	if (!DevInfo)
		{
		DevInfo = MiniDrivers[Default];
	   DevInfo->NumDevices++;
		}

	//
	//	Make sure these are set at this point
	//

	ASSERT(DevInfo);
	SET_DEVICE_INFO(PortInfo, DevInfo);

	//
	//	Add device and allocate unit id
	//

	DEVICE_AcquireDevice ();
	UnitId = 0;
	Device = &DevInfo->Siblings;
	while (p = *Device)
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Reassigning UnitId From %lu to %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p), UnitId));
		SET_DEVICE_UNIT(p, UnitId++);
		Device = &GET_DEVICE_SIBLING(p);
		}
	*Device = PortInfo;
	SET_DEVICE_UNIT(PortInfo, UnitId);
	SET_DEVICE_SIBLING(PortInfo, NULL);
	SET_DEVICE_ID(PortInfo, DevInfo->DeviceId);
	DEVICE_ReleaseDevice ();

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Assigned UnitId = %lu\n", MSGAME_NAME, UnitId));

	//
	//	Increment device count
	//

   InterlockedIncrement (&DevInfo->DeviceCount);
	if (DevInfo->DevicePending)
		InterlockedDecrement (&DevInfo->DevicePending);

	//
	//	Call the mini-driver to process
	//

	DevInfo->Services->StartDevice (PortInfo);

	//
	//	Return success always
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Read Report IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Public function <en->
//				Performs hot-plugging on success or does device detection if no
//				device selected or error.
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_ReadReport (PGAMEPORT PortInfo, PUCHAR Report, ULONG MaxSize, PULONG Copied)
{
	NTSTATUS			ntStatus;
	PDEVICEINFO		DevInfo;
	DEVICE_PACKET	Packet;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_ReadReport Enter\n", MSGAME_NAME));

	//
	//	Initialize packet members
	//

	memset (&Packet, 0, sizeof (Packet));
	Packet.id = GET_DEVICE_UNIT (PortInfo);

	//
	//	Check output buffer
	//

	if (MaxSize < sizeof (DEVICE_PACKET))
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_ReadReport Bad Buffer Size = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Skip if device changed
	//

	if (GET_DEVICE_DETECTED (PortInfo))
		{
		MsGamePrint ((DBG_INFORM, "%s: DEVICE_ReadReport Device In Process of Being Changed!\n", MSGAME_NAME));
		ntStatus = STATUS_DEVICE_BUSY;
		goto DEVICE_ReadReport_Exit;
		}

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo || !DeviceDetected)
	{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_ReadReport Called With No Device!\n", MSGAME_NAME));
		SuccessPackets[0] = 0;
		ntStatus = DEVICE_DetectDevices (PortInfo);
		if (!NT_SUCCESS (ntStatus))
			goto DEVICE_ReadReport_Exit;

		//
		//	Get pointer to new device
		//
		DevInfo = GET_DEVICE_INFO(PortInfo);

		goto DEVICE_ReadReport_Exit;
	}

	//
	//	Call the mini-driver to process
	//

	ntStatus = DevInfo->Services->ReadReport (PortInfo, &Packet);

	//
	//	Process returned status
	//

	if (NT_SUCCESS (ntStatus))
		{
		//
		//	Check for hot-plugging
		//

		ntStatus = DEVICE_HotPlugDevice (PortInfo);
		PollingAttempts[Packet.id] = 0;
		goto DEVICE_ReadReport_Exit;
		}
	else if (ntStatus == STATUS_DEVICE_BUSY)
		{
		//
		//	Access to port denied
		//

		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_ReadReport Device Busy\n", MSGAME_NAME));
        goto DEVICE_ReadReport_Exit;
		}
	else
		{
		//
		//	Force success if just transitory
		//

		if	((++PollingAttempts[Packet.id] <= MAX_POLLING_ATTEMPTS) && DeviceDetected)
			{
			MsGamePrint ((DBG_CRITICAL, "%s: DEVICE_ReadReport Force Success\n", MSGAME_NAME));
			ntStatus = STATUS_SUCCESS;
			}
		else if ((PollingAttempts[Packet.id] % MAX_POLLING_ATTEMPTS) == 0)
			{
			MsGamePrint ((DBG_CRITICAL, "%s: DEVICE_ReadReport Failed %lu In a Row\n", MSGAME_NAME, PollingAttempts[Packet.id]));

			//
			//	Try and see what's out there
			//

			ntStatus = DEVICE_DetectDevices (PortInfo);

			//
			//	If nothing found, destroy any siblings
			//

			if (NT_ERROR(ntStatus))
				ntStatus = DEVICE_RemoveSiblings (PortInfo);
			}
		else
			{
			//
			//	Just bounce this request
			//

			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			}

		//
		//	Clear sucessful packet counts
		//

		SuccessPackets[Packet.id] = 0;
		}

	//---------------------
	DEVICE_ReadReport_Exit:
	//---------------------

    if( ntStatus == STATUS_DEVICE_BUSY) 
    {
        ntStatus = STATUS_SUCCESS;
    }

	//
	//	Return packet data always
	//

	memcpy (Report, &Packet, sizeof (Packet));
	if (NT_SUCCESS(ntStatus))
	{
		*Copied += sizeof (Packet);
	}
	else
		*Copied = 0x0;
	//
	//	Return status code
	//

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	ULONG			UnitId;
	PGAMEPORT	p, *Device;
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_StopDevice Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_StopDevice Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Received for %s[%lu]\n", MSGAME_NAME, DevInfo->DeviceName, GET_DEVICE_UNIT(PortInfo)));

	//
	//	Remove sibling and reallocate unit ids
	//

	DEVICE_AcquireDevice ();
	UnitId = 0;
	Device = &DevInfo->Siblings;
	while (p = *Device)
		{
		if (p == PortInfo)
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Unlinking UnitId = %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p)));
			*Device = GET_DEVICE_SIBLING(p);
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Reassigning UnitId From %lu to %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p), UnitId));
			SET_DEVICE_UNIT(p, UnitId++);
			}
		Device = &GET_DEVICE_SIBLING(p);
		}
	DEVICE_ReleaseDevice ();

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Released UnitId = %lu\n", MSGAME_NAME, GET_DEVICE_UNIT (PortInfo)));

	//
	//	Decrement device count
	//

   InterlockedDecrement (&DevInfo->DeviceCount);
	if (DevInfo->DevicePending)
		InterlockedIncrement (&DevInfo->DevicePending);

	//
	//	Call the mini-driver to process
	//

	return (DevInfo->Services->StopDevice (PortInfo, TouchHardware));
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Get Feature IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID feature report id
//	@parm		PUCHAR | ReportBuffer | Output buffer for report
//	@parm		ULONG | ReportSize | Size of buffer for report
//	@parm		PULONG | Returned | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetFeature Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetFeature Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Skip if features not supported
	//

	if (!DevInfo->Services->GetFeature)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetFeature Called With No Mini-Driver Support!\n", MSGAME_NAME));
		return (STATUS_INVALID_DEVICE_REQUEST);
		}

	//
	//	Call the mini-driver to process
	//

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetFeature For ReportId = %lu\n", MSGAME_NAME, (ULONG)ReportId));
	return (DevInfo->Services->GetFeature (PortInfo, ReportId, ReportBuffer, ReportSize, Returned));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\device.h ===
//**************************************************************************
//
//		DEVICE.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	DEVICE.H | Global includes and definitions for device interface
//**************************************************************************

#ifndef	__DEVICE_H__
#define	__DEVICE_H__

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	MAX_DEVICE_UNITS				4

#define	MAX_DETECT_ATTEMPTS			5
#define	MAX_POLLING_ATTEMPTS			5
#define	MAX_CONNECT_ATTEMPTS			2
#define	MAX_DEVICE_NAME				64
#define	HOT_PLUG_PACKETS				2
#define	MAX_DETECT_INTERVAL			2000

#define	QUICK_DETECT_TIME				1000
#define	QUICK_DETECT_CLOCKS			8

#define	IMODE_DIGITAL_STD     		0
#define	IMODE_DIGITAL_ENH     		4
#define	IMODE_ANALOG          		8
#define	IMODE_NONE             		-1

#define	FLAG_WAIT_FOR_CLOCK			1
#define	FLAG_START_CLOCK_LOW			2
#define	FLAG_START_CLOCK_HIGH		4

#define	INTERRUPT_AFTER_PACKET		1
#define	INTERRUPT_DURING_PACKET		2

#define	TIMEOUT              		300
#define	MAX_XA_TIMEOUT					1600
#define	POLLING_INTERVAL				10

#define	INTXA_BIT_MASK          	0x01
#define	CLOCK_BIT_MASK          	0x10
#define	DATA0_BIT_MASK          	0x20
#define	DATA1_BIT_MASK          	0x40
#define	DATA2_BIT_MASK          	0x80
#define	AXIS_ONLY_BIT_MASK      	0x0f
#define	XA_BIT_MASK             	0x01
#define	YA_BIT_MASK             	0x02
#define	XB_BIT_MASK             	0x04
#define	YB_BIT_MASK             	0x08
#define	XAXIS_BIT_MASK          	0x01
#define	YAXIS_BIT_MASK          	0x02

#define	STATUS_GATE_MASK				0x90

//
//	Packet Speed Masks
//

#define	GAME_SPEED_66K					0
#define	GAME_SPEED_83K					1
#define	GAME_SPEED_100K				2
#define	GAME_SPEED_125K				3

#define	GAME_SPEED_RANGE				4
#define	GAME_SPEED_BITS				3

//
//	Wheel Speed Masks
//

#define	WHEEL_SPEED_48K				0
#define	WHEEL_SPEED_66K				1
#define	WHEEL_SPEED_98K				2

#define	WHEEL_SPEED_RANGE				3
#define	WHEEL_SPEED_BITS				3

//
//	Internal error codes
//

#define	ERROR_SUCCESS					 0
#define	ERROR_HANDSHAKING				-1
#define	ERROR_LOWCLOCKSTART			-2
#define	ERROR_HIGHCLOCKSTART			-3
#define	ERROR_CLOCKFALLING			-4
#define	ERROR_CLOCKRISING				-5
#define	ERROR_ERRORBITS				-6
#define	ERROR_PARITYBITS				-7
#define	ERROR_EXTRACLOCKS				-8
#define	ERROR_PHASEBITS				-9
#define	ERROR_CHECKSUM					-10
#define	ERROR_XA_TIMEOUT				-11
#define	ERROR_CLOCKOVERFLOW			-12

//
//	Packet status codes
//

#define	STATUS_SIBLING_ADDED			((NTSTATUS)0x40050001L)
#define	STATUS_SIBLING_REMOVED		((NTSTATUS)0x40050002L)
#define	STATUS_DEVICE_CHANGED		((NTSTATUS)0x40050003L)

//
//	GAMEENUM_OEM_DATA Constants
//

#define	OEM_DEVICE_INFO				0
#define	OEM_DEVICE_UNIT				1
#define	OEM_DEVICE_SIBLING			2
#define	OEM_DEVICE_ID					3
#define	OEM_DEVICE_DETECTED			4
#define	OEM_DEVICE_OBJECT				5

//
//	Device Packet Constants
//

#define	JOY_RETURNX						0x00000001
#define	JOY_RETURNY						0x00000002
#define	JOY_RETURNZ						0x00000004
#define	JOY_RETURNR						0x00000008
#define	JOY_RETURNU						0x00000010
#define	JOY_RETURNV						0x00000020
#define	JOY_RETURNPOV					0x00000040
#define	JOY_RETURNBUTTONS				0x00000080
#define	JOY_RETURNRAWDATA				0x00000100
#define	JOY_RETURNPOVCTS				0x00000200
#define	JOY_RETURNCENTERED			0x00000400
#define	JOY_USEDEADZONE				0x00000800
#define	JOY_RETURNALL					(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
												 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
												 JOY_RETURNPOV | JOY_RETURNBUTTONS)

#define	JOY_POVCENTERED				(USHORT)-1
#define	JOY_POVFORWARD					0
#define	JOY_POVRIGHT					9000
#define	JOY_POVBACKWARD				18000
#define	JOY_POVLEFT						27000

//
//	HID Force Feature Identifiers
//

#define	HIDP_REPORT_ID_1				0x85

#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

typedef enum
{													// @enum DETECT_ORDER | Device detection order
	DETECT_FIRST,								// @emem Highest priority devices
	DETECT_NORMAL,								// @emem Default priority devices
	DETECT_LAST									// @emem Lowest priority devices
} 	DETECT_ORDER;

//---------------------------------------------------------------------------
//			Structures
//---------------------------------------------------------------------------

typedef struct
{													// @struct DEVICE_PACKET | Game device packet
	ULONG       id;							// @field Device unit id
	ULONG       do_other;					//	@field Packet flags
	ULONG       dwX;							// @field X position
	ULONG       dwY;							// @field Y position
	ULONG       dwZ;							// @field Z position
	ULONG       dwR;							// @field Rudder position
	ULONG       dwU;							// @field U position
	ULONG       dwV;							// @field Z position
	ULONG       dwPOV;						// @field Point of view state
	ULONG       dwButtons;					// @field Button states
	ULONG       dwButtonNumber;			// @field Current button number pressed
}	DEVICE_PACKET, *PDEVICE_PACKET;

typedef struct
{														// @struct PACKETINFO | Packet acquistion data
	ULONG						Size;					// @field Size of structure
	PCHAR						DeviceName;			// @field Device name string
	MSGAME_TRANSACTION	Transaction;		// @field Transaction type
	ULONG						Mode;					// @field Digital mode indicator
	LONG						Speed;				// @field Transmission speed indicator
	LONG						LastError;			// @field Last internal error result
	GAMEPORT					PortInfo;			// @field Gameport parameters
	ULONG						Acquisition;		// @field Packet acquisition mode
	ULONG						NumPackets;			// @field Number packets received
	ULONG 					TimeStamp;			// @field Last packet time in milliseconds
	ULONG 					ClocksSampled;		// @field Number of clocks encountered
	ULONG						B4Transitions;		// @field Number of Button 4 transitions
	ULONG						StartTimeout;		// @field Packet start timeout, calibrated
	ULONG						HighLowTimeout;	// @field Packet high-low timeout, calibrated
	ULONG 					LowHighTimeout;	// @field Packet low-high timeout, calibrated
	ULONG						InterruptDelay;	// @field Packet interruptdelay, calibrated
	ULONG 					ClockDutyCycle;	// @field Packet clock duty cycle, calibrated
	ULONG 					Attempts;			// @field Packet attempt count
	ULONG 					Failures;			// @field Packet failure count
	ULONG						DataSize;			// @field Size of packet data buffer
	PVOID						Data;					// @field Packet data buffer pointer
}	PACKETINFO, *PPACKETINFO;

typedef struct
{													// @struct DEVICE_VALUES | Device registry data
	ULONG			PacketStartTimeout;		// @field Packet start timeout in microseconds
	ULONG 		PacketHighLowTimeout;	// Packet high-low timeout in microseconds
	ULONG 		PacketLowHighTimeout;	// @field Packet low-high timeout in microseconds
	ULONG			IdStartTimeout;			// @field IDstring start timeout in microseconds
	ULONG 		IdHighLowTimeout;			// @field IDstring high-low timeout in microseconds
	ULONG 		IdLowHighTimeout;			// @field IDstring low-high timeout in microseconds
	ULONG			InterruptDelay;			// @field Interrupt delay timeout in microseconds
	ULONG			MaxClockDutyCycle;		// @field Clock duty cycle timeout in microseconds
	ULONG			StatusStartTimeout;		// @field Status start timeout in microseconds
	ULONG 		StatusHighLowTimeout;	// @field Status high-low timeout in microseconds
	ULONG 		StatusLowHighTimeout;	// @field Status low-high timeout in microseconds
	ULONG 		StatusGateTimeout;		// @field Status gate timeout in microseconds
}	DEVICE_VALUES, *PDEVICE_VALUES;

typedef struct
{	// @struct DRIVERSERVICES | Device services table
	// @field NTSTATUS (*DriverEntry)(VOID) | ConnectDevice | ConnectDevice service procedure
	NTSTATUS (*DriverEntry)(VOID);
	// @field NTSTATUS (*ConnectDevice)(PortInfo) | ConnectDevice | ConnectDevice service procedure
	NTSTATUS (*ConnectDevice)(PGAMEPORT PortInfo);
	// @field NTSTATUS (*StartDevice)(PortInfo) | StartDevice | StartDevice service procedure
	NTSTATUS (*StartDevice)(PGAMEPORT PortInfo);
	// @field NTSTATUS (*ReadReport)(PortInfo, Report) | ReadReport | ReadReport service procedure
	NTSTATUS (*ReadReport)(PGAMEPORT PortInfo, PDEVICE_PACKET Report);
	// @field NTSTATUS (*StopDevice)(PGAMEPORT PortInfo) | StopDevice | StopDevice service procedure
	NTSTATUS (*StopDevice)(PGAMEPORT PortInfo, BOOLEAN TouchHardware);
	// @field NTSTATUS (*GetFeature)(PGAMEPORT PortInfo ...) | GetFeature | GetFeature service procedure
	NTSTATUS (*GetFeature)(PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);
}	DRIVERSERVICES, *PDRIVERSERVICES;

typedef struct
{													// @struct DEVICEINFO | Game device object
	PDRIVERSERVICES	Services;			// @field Pointer to service table
	PGAMEPORT			Siblings;			// @field Sibling device list
	PHID_DESCRIPTOR	DevDescriptor;		// @field Pointer to device descriptor
	PUCHAR				RptDescriptor;		// @field Pointer to report descriptor
	ULONG					RptDescSize;		// @field Size of report descriptor
	ULONG					NumDevices;			// @field Number of devices detected
	ULONG					DeviceCount;		// @field Number of devices started
	LONG					DevicePending;		//	@field Number devices pending
	PCHAR					DeviceName;			// @field Device name string
	DETECT_ORDER		DetectOrder;		// @field Detection priority
	BOOLEAN				IsAnalog;			// @field Analog device flag
	USHORT				DeviceId;			//	@field Hid device identifier
	PWCHAR				HardwareId;			// @field Pnp hardware identifier
}	DEVICEINFO, *PDEVICEINFO;

//---------------------------------------------------------------------------
//			Macros
//---------------------------------------------------------------------------

#define	DECLARE_DEVICE(x)				extern DEVICEINFO	x##Info
#define	INSTANCE_DEVICE(x)			&x##Info

#define	GET_DEVICE_INFO(p)			((PDEVICEINFO)((p)->OemData[OEM_DEVICE_INFO]))
#define	SET_DEVICE_INFO(p,x)			((p)->OemData[OEM_DEVICE_INFO]=(ULONG)x)

#define	GET_DEVICE_UNIT(p)			((ULONG)((p)->OemData[OEM_DEVICE_UNIT]))
#define	SET_DEVICE_UNIT(p,x)			((p)->OemData[OEM_DEVICE_UNIT]=(ULONG)x)

#define	GET_DEVICE_SIBLING(p)  		((PGAMEPORT)((p)->OemData[OEM_DEVICE_SIBLING]))
#define	SET_DEVICE_SIBLING(p,x)		((p)->OemData[OEM_DEVICE_SIBLING]=(ULONG)x)

#define	GET_DEVICE_ID(p)				((USHORT)((p)->OemData[OEM_DEVICE_ID]))
#define	SET_DEVICE_ID(p,x)			((p)->OemData[OEM_DEVICE_ID]=(USHORT)x)

#define	GET_DEVICE_DETECTED(p)  	((PDEVICEINFO)((p)->OemData[OEM_DEVICE_DETECTED]))
#define	SET_DEVICE_DETECTED(p,x)	((p)->OemData[OEM_DEVICE_DETECTED]=(ULONG)x)

#define	GET_DEVICE_OBJECT(p)  		((PDEVICE_OBJECT)((p)->OemData[OEM_DEVICE_OBJECT]))
#define	SET_DEVICE_OBJECT(p,x)		((p)->OemData[OEM_DEVICE_OBJECT]=(ULONG)x)

//---------------------------------------------------------------------------
//			Public Data
//---------------------------------------------------------------------------

extern	ULONG		POV_Values[];
extern	ULONG		PollingInterval;

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

BOOLEAN
DEVICE_IsOddParity (
	IN		PVOID			Data,
	IN		ULONG			Count
	);

BOOLEAN
DEVICE_IsCollision (
	IN		PPACKETINFO	DataPacket
	);

NTSTATUS
DEVICE_DriverEntry (VOID);

NTSTATUS
DEVICE_GetDeviceDescriptor (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Descriptor,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_GetReportDescriptor (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Descriptor,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_StartDevice (
	IN		PGAMEPORT	PortInfo,
	IN		PWCHAR		HardwareId
	);

NTSTATUS
DEVICE_ReadReport (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Report,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_StopDevice (
	IN		PGAMEPORT	PortInfo,
	IN		BOOLEAN		TouchHardware
	);

NTSTATUS
DEVICE_GetFeature (
	IN		PGAMEPORT		PortInfo,
	IN		HID_REPORT_ID	ReportId,
	OUT	PVOID				ReportBuffer,
	IN		ULONG				ReportSize,
	OUT	PULONG			Returned
	);

//===========================================================================
//			End
//===========================================================================
#endif	__DEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\hotplug.c ===
//**************************************************************************
//
//		HOTPLUG.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	HOTPLUG.C | Routines to support GameEnum hot-plugging
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//			Private	Procedures
//---------------------------------------------------------------------------

static	VOID	MSGAME_CreateDeviceItem (PGAME_WORK_ITEM WorkItem);
static	VOID	MSGAME_RemoveDeviceItem (PGAME_WORK_ITEM WorkItem);

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PGAME_WORK_ITEM | WorkItem | Pointer to add work item
// @rdesc	None
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	MSGAME_CreateDeviceItem (PGAME_WORK_ITEM	WorkItem)
{
	PIRP								pIrp;
	KEVENT							Event;
	NTSTATUS							ntStatus;
	PDEVICEINFO						DevInfo;
	PDEVICE_EXTENSION				DevExt;
	IO_STATUS_BLOCK				IoStatus;
	GAMEENUM_EXPOSE_SIBLING		ExposeSibling;

	MsGamePrint ((DBG_INFORM, "%s: %s_ExposeSiblingItem Enter\n", MSGAME_NAME, MSGAME_NAME));
	
	//
	// Get a pointer to the device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (WorkItem->DeviceObject);

	//
	//	Initialize expose sibling structure
	//

	memset (&ExposeSibling, 0, sizeof (ExposeSibling));
	ExposeSibling.Size = sizeof (GAMEENUM_EXPOSE_SIBLING);

	//
	//	Are we changing device or adding a sibling?
	//

	DevInfo = GET_DEVICE_DETECTED(&WorkItem->PortInfo);
	if (!DevInfo)
		DevInfo = GET_DEVICE_INFO(&WorkItem->PortInfo);
	else ExposeSibling.HardwareIDs = DevInfo->HardwareId;

	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate Internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_EXPOSE_SIBLING,
					DevExt->TopOfStack,
					&ExposeSibling,
					sizeof (GAMEENUM_EXPOSE_SIBLING),
					&ExposeSibling,
					sizeof (GAMEENUM_EXPOSE_SIBLING),
					TRUE,
					&Event,
					&IoStatus);
					
	//
	//	Call GameEnum synchronously
	//

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Expose Device at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));
	ntStatus = IoCallDriver (DevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS (ntStatus))
		MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Expose Device, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Free work item memory
	//

	ExFreePool (WorkItem);

	//
	//	Decrement IRP count holding driver in memory
	//

	if (!InterlockedDecrement (&DevExt->IrpCount))
		KeSetEvent (&DevExt->RemoveEvent, 0, FALSE);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to remove a device from the chain
//	@parm		PGAME_WORK_ITEM | WorkItem | Pointer to add work item
// @rdesc	None
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	MSGAME_RemoveDeviceItem (PGAME_WORK_ITEM WorkItem)
{
	PIRP								pIrp;
	KEVENT							Event;
	NTSTATUS							ntStatus;
	PDEVICE_EXTENSION				DevExt;
	IO_STATUS_BLOCK				IoStatus;

	MsGamePrint ((DBG_INFORM, "%s: %s_RemoveDeviceItem Enter\n", MSGAME_NAME, MSGAME_NAME));
	
	//
	// Get a pointer to the device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (WorkItem->DeviceObject);

	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate Internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_REMOVE_SELF,
					DevExt->TopOfStack,
					NULL,
					0,
					NULL,
					0,
					TRUE,
					&Event,
					&IoStatus);

	//
	//	Call GameEnum synchronously
	//

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Remove Self at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));
	ntStatus = IoCallDriver (DevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS (ntStatus))
		MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Remove Self, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Free work item memory
	//

	ExFreePool (WorkItem);

	//
	//	Decrement IRP count holding driver in memory
	//

	if (!InterlockedDecrement (&DevExt->IrpCount))
		KeSetEvent (&DevExt->RemoveEvent, 0, FALSE);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_CreateDevice (PDEVICE_OBJECT DeviceObject)
{
	PGAME_WORK_ITEM	WorkItem;
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_INFORM, "%s: %s_ExposeSibling Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Allocate work item memory
	//

	WorkItem = ExAllocatePool (NonPagedPool, sizeof (GAME_WORK_ITEM));
	if (!WorkItem)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ExposeSibling Failed to Allocate Work Item\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_INSUFFICIENT_RESOURCES);
		}

	//
	//	Increment IRP count to hold driver in memory
	//

	InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Initialize work item memory
	//

	ExInitializeWorkItem (&WorkItem->QueueItem, (PWORKER_THREAD_ROUTINE)MSGAME_CreateDeviceItem, WorkItem);
	WorkItem->DeviceObject	= DeviceObject;
	WorkItem->PortInfo		= DevExt->PortInfo;

	//
	//	Queue the work item
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_ExposeSibling Queueing %s_ExposeSiblingItem\n", MSGAME_NAME, MSGAME_NAME, MSGAME_NAME));
	ExQueueWorkItem (&WorkItem->QueueItem, DelayedWorkQueue);

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to remove a device from the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_RemoveDevice (PDEVICE_OBJECT DeviceObject)
{
	PDEVICEINFO			DevInfo;
	PGAME_WORK_ITEM	WorkItem;
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_INFORM, "%s: %s_RemoveDevice Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Get device information
	//

	DevInfo = GET_DEVICE_INFO(&DevExt->PortInfo);

	//
	//	Skip if device already removed
	//

	if (DevExt->Removing || DevExt->Surprised || DevExt->Removed)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_RemoveDevice attempted to destroy removed device\n", MSGAME_NAME, MSGAME_NAME));
		InterlockedIncrement (&DevInfo->DevicePending);
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Allocate work item memory
	//

	WorkItem = ExAllocatePool (NonPagedPool, sizeof (GAME_WORK_ITEM));
	if (!WorkItem)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_RemoveDevice Failed to Allocate Work Item\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_INSUFFICIENT_RESOURCES);
		}

	//
	//	Increment IRP count to hold driver in memory
	//

	InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Mark device as being removed
	//

	DevExt->Removing = TRUE;

	//
	//	Initialize work item memory
	//

	ExInitializeWorkItem (&WorkItem->QueueItem, (PWORKER_THREAD_ROUTINE)MSGAME_RemoveDeviceItem, WorkItem);
	WorkItem->DeviceObject	= DevExt->Self;
	WorkItem->PortInfo		= DevExt->PortInfo;

	//
	//	Queue the work item
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_RemoveDevice Queueing %s_RemoveDeviceItem\n", MSGAME_NAME, MSGAME_NAME, MSGAME_NAME));
	ExQueueWorkItem (&WorkItem->QueueItem, DelayedWorkQueue);

	//
	//	Return status
	//

	return (STATUS_DEVICE_NOT_READY);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_ChangeDevice (PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Change Device\n", MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Increment IRP count to hold driver in memory
	//

	// InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Remove old device first
	//

	MSGAME_RemoveDevice (DeviceObject);

	//
	//	Create new device second
	//

	MSGAME_CreateDevice (DeviceObject);

	//
	//	Return status
	//

	return (STATUS_DEVICE_NOT_READY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\debug.c ===
//**************************************************************************
//
//		DEBUG.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	DEBUG.C | Supports debugging output (DBG builds only)
//**************************************************************************

#if (DBG==1)														// skip rest of file

//---------------------------------------------------------------------------
//			Include Files
//---------------------------------------------------------------------------

#include	"msgame.h"
#include	<stdio.h>
#include	<stdarg.h>

//---------------------------------------------------------------------------
//			Private Data
//---------------------------------------------------------------------------

DBG_LEVEL	DebugLevel = DBG_DEFAULT;

//---------------------------------------------------------------------------
// @func		Set conditional debug level
// @parm		DBG_LEVEL | uLevel | New debug output priority
// @rdesc	Old debug output priority
//	@comm		Public function available on DBG builds only
//---------------------------------------------------------------------------

DBG_LEVEL	DEBUG_Level (DBG_LEVEL uLevel)
{
	EXCHANGE(uLevel, DebugLevel);
	return (uLevel);
};

//---------------------------------------------------------------------------
// @func		Writes conditional debug output
// @parm		DBG_LEVEL | uLevel | Debug output priority
// @parm		PCSZ | szMessage | Formating string
// @parmvar	One or more variable arguments
// @rdesc	None
//	@comm		Public function available on DBG builds only
//---------------------------------------------------------------------------

VOID	DEBUG_Print (DBG_LEVEL uLevel, PCSZ szMessage, ...)
{
	va_list	ap;
	va_start (ap, szMessage);

	if (uLevel <= DebugLevel)
		{
		CHAR	szBuffer[256];

		_vsnprintf (szBuffer, sizeof (szBuffer), szMessage, ap);
		DbgPrint (szBuffer);
		}

	va_end (ap);
}

//===========================================================================
//			End
//===========================================================================
#endif	//	DBG=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\makefile.inc ===
!IFDEF	SAITEK
saigame.dbg: $(CPU)\$(DDKBUILDENV)\saigame.sys
   rebase -b 0x10000 -x $(CPU)\$(DDKBUILDENV) $(CPU)\$(DDKBUILDENV)\saigame.sys
!ELSE
msgame.dbg: $(CPU)\$(DDKBUILDENV)\msgame.sys
   rebase -b 0x10000 -x $(CPU)\$(DDKBUILDENV) $(CPU)\$(DDKBUILDENV)\msgame.sys
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\ioctl.c ===
//**************************************************************************
//
//		IOCTL.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	IOCTL.C | Routines to support internal ioctl queries
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (PAGE, MSGAME_GetDeviceDescriptor)
#pragma	alloc_text (PAGE, MSGAME_GetReportDescriptor)
#pragma	alloc_text (PAGE, MSGAME_GetAttributes)
#endif

//---------------------------------------------------------------------------
// @func		Process the Control IRPs sent to this device
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_Internal_Ioctl (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	MsGamePrint ((DBG_VERBOSE, "%s: %s_Internal_Ioctl Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to current location in pIrp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Increment IRP count to hold driver removes
	//

	InterlockedIncrement (&pDevExt->IrpCount);

	//
	//	Check if we've been removed and bounce request
	//

	if (pDevExt->Removed)
		{
		//
		// Someone sent us another IRP after removed
		//

		MsGamePrint ((DBG_SEVERE, "%s: internal Irp after device removed\n", MSGAME_NAME));
		ASSERT (FALSE);

		if (!InterlockedDecrement (&pDevExt->IrpCount))
			KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Process HID internal IO request
	//

	switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
		{
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_DEVICE_DESCRIPTOR\n", MSGAME_NAME));
			ntStatus = MSGAME_GetDeviceDescriptor (DeviceObject, pIrp);
			break;

		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_REPORT_DESCRIPTOR\n", MSGAME_NAME));
			ntStatus = MSGAME_GetReportDescriptor (DeviceObject, pIrp);
			break;

		case IOCTL_HID_READ_REPORT:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_READ_REPORT\n", MSGAME_NAME));
			ntStatus = MSGAME_ReadReport (DeviceObject, pIrp);
			break;

		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_DEVICE_ATTRIBUTES\n", MSGAME_NAME));
			ntStatus = MSGAME_GetAttributes (DeviceObject, pIrp);
			break;

		case IOCTL_HID_ACTIVATE_DEVICE:
		case IOCTL_HID_DEACTIVATE_DEVICE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_(DE)ACTIVATE_DEVICE\n", MSGAME_NAME));
			ntStatus = STATUS_SUCCESS;
			break;

		case	IOCTL_HID_GET_FEATURE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_FEATURE\n", MSGAME_NAME));
			ntStatus = MSGAME_GetFeature (DeviceObject, pIrp);
			break;

		case	IOCTL_HID_SET_FEATURE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_SET_FEATURE\n", MSGAME_NAME));
			ntStatus = STATUS_NOT_SUPPORTED;
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "%s: Unknown or unsupported IOCTL (%x)\n", MSGAME_NAME,
							 pIrpStack->Parameters.DeviceIoControl.IoControlCode));
			ntStatus = STATUS_NOT_SUPPORTED;
			break;
		}

	//
	// Set real return status in pIrp
	//

	pIrp->IoStatus.Status = ntStatus;

	//
	// Complete Irp
	//

	IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	//
	//	Decrement IRP count for device removes
	//

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: %s_Internal_Ioctl Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Processes the HID getdevice descriptor IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetDeviceDescriptor (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetDeviceDescriptor Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get device descriptor into HIDCLASS buffer
	//

	ntStatus	=	DEVICE_GetDeviceDescriptor (
						&pDevExt->PortInfo,
						pIrp->UserBuffer,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetDeviceDescriptor Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get report descriptor IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetReportDescriptor (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;
	NTSTATUS					ntStatus;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetReportDescriptor Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get report descriptor into HIDCLASS buffer
	//

	ntStatus	=	DEVICE_GetReportDescriptor (
						&pDevExt->PortInfo,
						pIrp->UserBuffer,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetReportDescriptor Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get attributes IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetAttributes (PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS						ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION			pDevExt;
	PIO_STACK_LOCATION		irpStack;
	PHID_DEVICE_ATTRIBUTES	pDevAtt;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetAttributes Entry\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	irpStack = IoGetCurrentIrpStackLocation (Irp);

	//
	// Get a pointer to the device extension
	//

	pDevExt 	= GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
	pDevAtt	= (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

	ASSERT(sizeof(HID_DEVICE_ATTRIBUTES) == irpStack->Parameters.DeviceIoControl.OutputBufferLength);

	//
	//	Fill in HID device attributes
	//

	pDevAtt->Size				= sizeof (HID_DEVICE_ATTRIBUTES);
	pDevAtt->VendorID			= MSGAME_VENDOR_ID;
	pDevAtt->ProductID		= GET_DEVICE_ID(&pDevExt->PortInfo);
	pDevAtt->VersionNumber	= MSGAME_VERSION_NUMBER;

	//
	// Report how many bytes were copied
	//

	Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetAttributes Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get device features IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetFeature (PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	irpStack;
	PHID_XFER_PACKET		Packet;
	PUCHAR					Report;

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Entry\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	irpStack = IoGetCurrentIrpStackLocation (Irp);

	//
	// Get a pointer to the device extension
	//

	pDevExt 	= GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

	//
	//	Get pointer to feature packet
	//

	Packet = (PHID_XFER_PACKET)Irp->UserBuffer;

	//
	//	Test packet size in case version error
	//

	ASSERT (irpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(HID_XFER_PACKET));

	//
	//	Setup return values (return HidReportId even on errors)
	//

	Report = Packet->reportBuffer;
	*(PHID_REPORT_ID)Report++ = (HID_REPORT_ID)Packet->reportId;
	Irp->IoStatus.Information = sizeof (HID_REPORT_ID);

	//
	//	Check if device has been removed
	//

	if (pDevExt->Removed || pDevExt->Surprised)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetFeature On Removed Device!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Check if device being removed
	//
	
	if (pDevExt->Removing)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetFeature On Device Pending Removal!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Call mini-driver to process
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Report Id = %lu\n", MSGAME_NAME, MSGAME_NAME, Packet->reportId));
	ntStatus = DEVICE_GetFeature (&pDevExt->PortInfo,
											Packet->reportId,
											Report,
											Packet->reportBufferLen,
											&Irp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID read report IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_ReadReport (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_PENDING;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;
	PIO_STACK_LOCATION	nextStack;
	KIRQL						OldIrql;
	PUCHAR 					Report;

	MsGamePrint ((DBG_VERBOSE, "%s: %s_ReadReport Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the device extension.
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get stack location
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	//	Setup return values (return HidReportId even on errors)
	//

	Report = pIrp->UserBuffer;
	if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength > sizeof (DEVICE_PACKET))
		{
		*(PHID_REPORT_ID)Report++ = (HID_REPORT_ID)MSGAME_INPUT_JOYINFOEX;
		pIrp->IoStatus.Information = sizeof (HID_REPORT_ID);
		}
	else pIrp->IoStatus.Information = 0;

	//
	//	Check if device has been removed
	//

	if (pDevExt->Removed || pDevExt->Surprised)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ReadReport On Removed Device!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Check if device being removed
	//
	
	if (pDevExt->Removing)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ReadReport On Device Pending Removal!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Poll the device layer
	//

	ntStatus	=	DEVICE_ReadReport (
						&pDevExt->PortInfo,
						Report,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Check status for device changes
	//

	switch (ntStatus)
		{
		case	STATUS_SIBLING_ADDED:
			//
			//	Tell GameEnum to Create a Device
			//
			ntStatus = MSGAME_CreateDevice (DeviceObject);
			break;

		case	STATUS_SIBLING_REMOVED:
			//
			//	Tell GameEnum to Remove a Device
			//
			ntStatus = MSGAME_RemoveDevice (DeviceObject);
			break;

		case	STATUS_DEVICE_CHANGED:
			//
			//	Tell GameEnum to Create a New Device
			//
			ntStatus = MSGAME_ChangeDevice (DeviceObject);
			break;
		}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: %s_ReadReport Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\msgame.c ===
//**************************************************************************
//
//      MSGAME.C -- Xena Gaming Project
//
//      Version 3.XX
//
//      Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//      @doc
//      @module MSGAME.C | Human Input Device (HID) gameport driver
//**************************************************************************

#include    "msgame.h"

//---------------------------------------------------------------------------
//  Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef  ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (INIT, MSGAME_ReadRegistry)
#pragma alloc_text (PAGE, MSGAME_CreateClose)
#pragma alloc_text (PAGE, MSGAME_SystemControl)
#pragma alloc_text (PAGE, MSGAME_AddDevice)
#endif

//---------------------------------------------------------------------------
//      Private Data
//---------------------------------------------------------------------------

static  UNICODE_STRING      RegistryPath;

//---------------------------------------------------------------------------
// @func        Main driver entry point
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
//  @parm       PUNICODE_STRING | registryPath | Registry path for this device
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    DriverEntry (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath)
{
    NTSTATUS                                ntStatus;
    RTL_QUERY_REGISTRY_TABLE        Parameters[2];
    HID_MINIDRIVER_REGISTRATION HidMinidriverRegistration;

    MsGamePrint ((DBG_CRITICAL, "%s: Built %s at %s\n", MSGAME_NAME, __DATE__, __TIME__));
    MsGamePrint ((DBG_INFORM,   "%s: DriverEntry Enter\n", MSGAME_NAME));

    //
    //  Fill in driver dispatch table
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                      =   MSGAME_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                       =   MSGAME_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]     =   MSGAME_Internal_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                         =   MSGAME_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                       =   MSGAME_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]              =   MSGAME_SystemControl;
    DriverObject->DriverUnload                                      =   MSGAME_Unload;
    DriverObject->DriverExtension->AddDevice                        =   MSGAME_AddDevice;

    //
    // Register driver with Hid.Sys
    //

    HidMinidriverRegistration.Revision                  = HID_REVISION;
    HidMinidriverRegistration.DriverObject              = DriverObject;
    HidMinidriverRegistration.RegistryPath              = registryPath;
    HidMinidriverRegistration.DeviceExtensionSize   = sizeof (DEVICE_EXTENSION);
    HidMinidriverRegistration.DevicesArePolled      = TRUE;
    MsGamePrint ((DBG_CONTROL, "%s: Registering with HID.SYS\n", MSGAME_NAME));
    ntStatus = HidRegisterMinidriver (&HidMinidriverRegistration);
    
    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    if (NT_SUCCESS(ntStatus))
        {
        RtlInitUnicodeString (&RegistryPath, NULL);
        RegistryPath.Length = registryPath->Length + sizeof(UNICODE_NULL);
        RegistryPath.MaximumLength = RegistryPath.Length;
        RegistryPath.Buffer = ExAllocatePool (PagedPool, RegistryPath.Length);
        RtlZeroMemory (RegistryPath.Buffer, RegistryPath.Length);
        RtlMoveMemory (RegistryPath.Buffer, registryPath->Buffer, registryPath->Length);
        }

    //
    //  Read any driver specific registry values
    //

    if (NT_SUCCESS(ntStatus))
        {
        RtlZeroMemory (Parameters, sizeof(Parameters));
        Parameters[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
        Parameters[0].Name              = L"PollingInterval";
        Parameters[0].EntryContext  = &PollingInterval;
        Parameters[0].DefaultType       = REG_DWORD;
        Parameters[0].DefaultData       = &PollingInterval;
        Parameters[0].DefaultLength = sizeof(ULONG);
        if (!NT_SUCCESS(RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, RegistryPath.Buffer, Parameters, NULL, NULL)))
            {
            MsGamePrint((DBG_INFORM,"%s: %s_DriverEntry RtlQueryRegistryValues failed\n", MSGAME_NAME, MSGAME_NAME));
            RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, RegistryPath.Buffer, L"PollingInterval", REG_DWORD, &PollingInterval, sizeof (ULONG));
            }
        MsGamePrint((DBG_CONTROL,"%s: Polling interval will be %lu milliseconds\n", MSGAME_NAME, PollingInterval));
        }

    //
    //  Initialize portio layer on entry
    //

    if (NT_SUCCESS(ntStatus))
        ntStatus = PORTIO_DriverEntry ();

    //
    //  Initialize device layer on entry
    //

    if (NT_SUCCESS(ntStatus))
        ntStatus = DEVICE_DriverEntry ();

    // 
    // Return driver status
    //

    MsGamePrint ((DBG_INFORM, "%s: DriverEntry Exit = %x\n", MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Process the Create and Close IRPs
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
//  @parm       PIRP | pIrp | Pointer to IO request packet
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_CreateClose (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_CreateClose Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    // Get pointer to current location in Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Process Create or Close function call
    //

    switch (IrpStack->MajorFunction)
        {
        case IRP_MJ_CREATE:
            MsGamePrint ((DBG_VERBOSE, "%s: IRP_MJ_CREATE\n", MSGAME_NAME));
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            MsGamePrint ((DBG_VERBOSE, "%s: IRP_MJ_CLOSE\n", MSGAME_NAME));
            Irp->IoStatus.Information = 0;
            break;

        default:
            MsGamePrint ((DBG_SEVERE, "%s:  Invalid CreateClose Parameter\n", MSGAME_NAME));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
        }

    //
    // Save Status for return and complete Irp
    //

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    MsGamePrint ((DBG_INFORM, "%s:  %s_CreateClose Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Process the WMI system control IRPs
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
//  @parm       PIRP | pIrp | Pointer to IO request packet
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_SystemControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_SystemControl Enter\n", MSGAME_NAME, MSGAME_NAME));

    IoSkipCurrentIrpStackLocation (Irp);

    ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
    
    MsGamePrint ((DBG_INFORM, "%s:  %s_SystemControl Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Processes the Pnp Add Device call
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_AddDevice (IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS                ntStatus    = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_AddDevice Entry\n", MSGAME_NAME, MSGAME_NAME));

    //
    // Initialize the device extension
    //

    pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);
    memset(pDevExt, 0, sizeof(DEVICE_EXTENSION));

    pDevExt->Driver     =   DriverObject;
    pDevExt->Self           =   DeviceObject;
    pDevExt->IrpCount   =   1;
    pDevExt->Started        =   FALSE;
    pDevExt->Removed        =   FALSE;
    pDevExt->Surprised  =   FALSE;
    pDevExt->Removing       =   FALSE;
    pDevExt->TopOfStack =   NULL;
    KeInitializeEvent (&pDevExt->StartEvent, NotificationEvent, FALSE);
    KeInitializeEvent (&pDevExt->RemoveEvent, SynchronizationEvent, FALSE);

    //
    //  Clear device initialization flags
    //
    
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Attach our functional driver to the device stack. The return value of
    // IoAttachDeviceToDeviceStack is the top of the attachment chain. This
    // is where all the IRPs should be routed.
    //

    pDevExt->TopOfStack = GET_NEXT_DEVICE_OBJECT(DeviceObject);

    //
    // If this attachment fails then top of stack will be null. Failure
    // for attachment is an indication of a broken plug play system.
    //

    ASSERT (pDevExt->TopOfStack);

    //
    //  Return status
    //

    MsGamePrint ((DBG_INFORM, "%s: %s_AddDevice Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Processes the driver unload call
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

VOID    MSGAME_Unload (IN PDRIVER_OBJECT DriverObject)
{
    PAGED_CODE();

    MsGamePrint ((DBG_INFORM, "%s: %s_Unload Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    // All the device objects should be gone
    //

    ASSERT (!DriverObject->DeviceObject);

    //
    // Free the unicode strings.
    //

    ExFreePool (RegistryPath.Buffer);

    MsGamePrint ((DBG_CONTROL, "%s: %s_Unload Exit\n", MSGAME_NAME, MSGAME_NAME));
}

//---------------------------------------------------------------------------
// @func        Reads registry data for a named device
//  @parm       PCHAR | DeviceName | Device name string
//  @parm       PDEVICE_VALUES | DeviceValues | Device values structure to fill
// @rdesc   Returns nothing
//  @comm       Public function
//---------------------------------------------------------------------------

VOID    MSGAME_ReadRegistry (PCHAR DeviceName, PDEVICE_VALUES DeviceValues)
{
    #define PARAMS_PLUS_ONE 13

    NTSTATUS                            ntStatus;
    ANSI_STRING                     AnsiName;
    UNICODE_STRING                  UnicodeName;
    UNICODE_STRING                  ParametersPath;
    PRTL_QUERY_REGISTRY_TABLE   Parameters;

    MsGamePrint((DBG_INFORM,"%s: %s_ReadRegistry Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    //  Initialize local variables
    //

    RtlInitAnsiString       (&AnsiName, DeviceName);
    RtlInitUnicodeString    (&UnicodeName, NULL);
    RtlInitUnicodeString    (&ParametersPath, NULL);

    Parameters = ExAllocatePool (PagedPool, sizeof(RTL_QUERY_REGISTRY_TABLE) * PARAMS_PLUS_ONE);

    if (!Parameters)
        {
        MsGamePrint((DBG_CRITICAL, "%s: %s_ReadRegistry couldn't allocate Rtl query table for %ws\n", MSGAME_NAME, MSGAME_NAME, RegistryPath.Buffer));
        goto ReadRegistryExit;
        }

    RtlZeroMemory (Parameters, sizeof(RTL_QUERY_REGISTRY_TABLE) * PARAMS_PLUS_ONE);

    //
    // Form a path to this driver's Parameters subkey.
    //

    ParametersPath.MaximumLength    = RegistryPath.Length + MAX_DEVICE_NAME;
    ParametersPath.Buffer           = ExAllocatePool (PagedPool, ParametersPath.MaximumLength);

    if (!ParametersPath.Buffer)
        {
        MsGamePrint((DBG_CRITICAL, "%s: %s_ReadRegistry couldn't allocate path string for %ws\n", MSGAME_NAME, MSGAME_NAME, RegistryPath.Buffer));
        goto ReadRegistryExit;
        }

    //
    // Form the Parameters path.
    //

    RtlZeroMemory (ParametersPath.Buffer, ParametersPath.MaximumLength);
    RtlAppendUnicodeToString (&ParametersPath, RegistryPath.Buffer);
    RtlAppendUnicodeToString (&ParametersPath, L"\\");

    RtlAnsiStringToUnicodeString (&UnicodeName, &AnsiName, TRUE);
    RtlAppendUnicodeStringToString (&ParametersPath, &UnicodeName);
    RtlFreeUnicodeString (&UnicodeName);

    MsGamePrint((DBG_VERBOSE, "%s: %s_ReadRegistry path is %ws\n", MSGAME_NAME, MSGAME_NAME, ParametersPath.Buffer));

    //
    // Gather all device information from the registry.
    //

    Parameters[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[0].Name              = L"PacketStartTimeout";
    Parameters[0].EntryContext  = &DeviceValues->PacketStartTimeout;
    Parameters[0].DefaultType       = REG_DWORD;
    Parameters[0].DefaultData       = &DeviceValues->PacketStartTimeout;
    Parameters[0].DefaultLength = sizeof(ULONG);
 
    Parameters[1].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[1].Name              = L"PacketLowHighTimeout";
    Parameters[1].EntryContext  = &DeviceValues->PacketLowHighTimeout;
    Parameters[1].DefaultType       = REG_DWORD;
    Parameters[1].DefaultData       = &DeviceValues->PacketLowHighTimeout;
    Parameters[1].DefaultLength = sizeof(ULONG);

    Parameters[2].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[2].Name              = L"PacketHighLowTimeout";
    Parameters[2].EntryContext  = &DeviceValues->PacketHighLowTimeout;
    Parameters[2].DefaultType       = REG_DWORD;
    Parameters[2].DefaultData       = &DeviceValues->PacketHighLowTimeout;
    Parameters[2].DefaultLength = sizeof(ULONG);

    Parameters[3].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[3].Name              = L"IdStartTimeout";
    Parameters[3].EntryContext  = &DeviceValues->IdStartTimeout;
    Parameters[3].DefaultType       = REG_DWORD;
    Parameters[3].DefaultData       = &DeviceValues->IdStartTimeout;
    Parameters[3].DefaultLength = sizeof(ULONG);

    Parameters[4].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[4].Name              = L"IdLowHighTimeout";
    Parameters[4].EntryContext  = &DeviceValues->IdLowHighTimeout;
    Parameters[4].DefaultType       = REG_DWORD;
    Parameters[4].DefaultData       = &DeviceValues->IdLowHighTimeout;
    Parameters[4].DefaultLength = sizeof(ULONG);

    Parameters[5].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[5].Name              = L"IdHighLowTimeout";
    Parameters[5].EntryContext  = &DeviceValues->IdHighLowTimeout;
    Parameters[5].DefaultType       = REG_DWORD;
    Parameters[5].DefaultData       = &DeviceValues->IdHighLowTimeout;
    Parameters[5].DefaultLength = sizeof(ULONG);

    Parameters[6].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[6].Name              = L"InterruptDelay";
    Parameters[6].EntryContext  = &DeviceValues->InterruptDelay;
    Parameters[6].DefaultType       = REG_DWORD;
    Parameters[6].DefaultData       = &DeviceValues->InterruptDelay;
    Parameters[6].DefaultLength = sizeof(ULONG);

    Parameters[7].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[7].Name              = L"MaxClockDutyCycle";
    Parameters[7].EntryContext  = &DeviceValues->MaxClockDutyCycle;
    Parameters[7].DefaultType       = REG_DWORD;
    Parameters[7].DefaultData       = &DeviceValues->MaxClockDutyCycle;
    Parameters[7].DefaultLength = sizeof(ULONG);

    Parameters[8].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[8].Name              = L"StatusStartTimeout";
    Parameters[8].EntryContext  = &DeviceValues->StatusStartTimeout;
    Parameters[8].DefaultType       = REG_DWORD;
    Parameters[8].DefaultData       = &DeviceValues->StatusStartTimeout;
    Parameters[8].DefaultLength = sizeof(ULONG);

    Parameters[9].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[9].Name              = L"StatusLowHighTimeout";
    Parameters[9].EntryContext  = &DeviceValues->StatusLowHighTimeout;
    Parameters[9].DefaultType       = REG_DWORD;
    Parameters[9].DefaultData       = &DeviceValues->StatusLowHighTimeout;
    Parameters[9].DefaultLength = sizeof(ULONG);

    Parameters[10].Flags                = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[10].Name             = L"StatusHighLowTimeout";
    Parameters[10].EntryContext     = &DeviceValues->StatusHighLowTimeout;
    Parameters[10].DefaultType      = REG_DWORD;
    Parameters[10].DefaultData      = &DeviceValues->StatusHighLowTimeout;
    Parameters[10].DefaultLength    = sizeof(ULONG);

    Parameters[11].Flags                = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[11].Name             = L"StatusGateTimeout";
    Parameters[11].EntryContext     = &DeviceValues->StatusGateTimeout;
    Parameters[11].DefaultType      = REG_DWORD;
    Parameters[11].DefaultData      = &DeviceValues->StatusGateTimeout;
    Parameters[11].DefaultLength    = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, Parameters, NULL, NULL);

    if (!NT_SUCCESS(ntStatus))
        {
        MsGamePrint((DBG_INFORM,"%s: %s_ReadRegistry RtlQueryRegistryValues failed with 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
        //
        //  Create registry entries as needed
        //
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketStartTimeout", REG_DWORD, &DeviceValues->PacketStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketLowHighTimeout", REG_DWORD, &DeviceValues->PacketLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketHighLowTimeout", REG_DWORD, &DeviceValues->PacketHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdStartTimeout", REG_DWORD, &DeviceValues->IdStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdLowHighTimeout", REG_DWORD, &DeviceValues->IdLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdHighLowTimeout", REG_DWORD, &DeviceValues->IdHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"InterruptDelay", REG_DWORD, &DeviceValues->InterruptDelay, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"MaxClockDutyCycle", REG_DWORD, &DeviceValues->MaxClockDutyCycle, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusStartTimeout", REG_DWORD, &DeviceValues->StatusStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusLowHighTimeout", REG_DWORD, &DeviceValues->StatusLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusHighLowTimeout", REG_DWORD, &DeviceValues->StatusHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusGateTimeout", REG_DWORD, &DeviceValues->StatusGateTimeout, sizeof (ULONG));
        }

    //  -----------------
        ReadRegistryExit:
    //  -----------------

    if (ParametersPath.Buffer)
        ExFreePool(ParametersPath.Buffer);

    if (Parameters)
        ExFreePool(Parameters);

    #undef  PARAMS_PLUS_ONE
}

//---------------------------------------------------------------------------
// @func        Posts a transaction to hooking driver
//  @parm       PPACKETINFO | PacketInfo | Device packet info struct
// @rdesc   None
//  @comm       Public function
//---------------------------------------------------------------------------

VOID  MSGAME_PostTransaction (PPACKETINFO PacketInfo)
{
    //
    //  Not Implemented
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\portio.h ===
//**************************************************************************
//
//		PORTIO.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	PORTIO.H | Global includes and definitions for port I/O functions
//**************************************************************************

#ifndef	__PORTIO_H__
#define	__PORTIO_H__

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

NTSTATUS
PORTIO_DriverEntry (VOID);

VOID
PORTIO_MaskInterrupts (VOID);

VOID
PORTIO_UnMaskInterrupts (VOID);

BOOLEAN
PORTIO_AcquirePort (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_ReleasePort (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_CalibrateTimeOut (
	IN		PGAMEPORT	PortInfo
	);

UCHAR
PORTIO_Read (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_Write (
	IN		PGAMEPORT	PortInfo,
	IN		UCHAR 		Value
	);

BOOLEAN
PORTIO_GetAckNak (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			Timeout,
	OUT	PUCHAR		AckNak
	);

BOOLEAN
PORTIO_GetNakAck (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			Timeout,
	OUT	PUCHAR		NakAck
	);

BOOLEAN
PORTIO_IsClockActive (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitClockInActive (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitClockLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitClockHigh (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitDataLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitXA_HighLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitForIdle (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitForStatusGate (
	IN		PGAMEPORT	PortInfo,
	IN		UCHAR			Mask,
	IN		ULONG			Timeout
	);

BOOLEAN
PORTIO_WaitForHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitForIdleHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_PulseAndWaitForHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle,
	IN		ULONG			Pulses
	);

BOOLEAN
PORTIO_PulseAndWaitForIdleHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle,
	IN		ULONG			Pulses
	);

//===========================================================================
//			End
//===========================================================================
#endif	__PORTIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\msgame.h ===
//**************************************************************************
//
//      MSGAME.H -- Xena Gaming Project
//
//      Version 3.XX
//
//      Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//      @doc
//      @header MSGAME.H | Global includes and definitions for gameport driver.
//**************************************************************************

#ifndef __MSGAME_H__
#define __MSGAME_H__

#ifdef  SAITEK
#define MSGAME_NAME     "SAIGAME"
#else
#define MSGAME_NAME     "MSGAME"
#endif

//---------------------------------------------------------------------------
//          Public Include Files
//---------------------------------------------------------------------------

#include    <wdm.h>
#include    <hidclass.h>
#include    <hidusage.h>
#include    <hidtoken.h>
#include    <hidport.h>
#include    <gameport.h>

//---------------------------------------------------------------------------
//          Types
//---------------------------------------------------------------------------

//  @type GAMEPORT | Retyped to avoid long function declarations
typedef GAMEENUM_PORT_PARAMETERS      GAMEPORT;
typedef GAMEENUM_PORT_PARAMETERS    *PGAMEPORT;

typedef struct
{                                               // @struct GAME_WORK_ITEM | Game change structure
    WORK_QUEUE_ITEM QueueItem;      // @field Work queue item for passive callback
    PDEVICE_OBJECT      DeviceObject;   // @field Device object for subsequent change
    GAMEPORT                PortInfo;       // @field Game port parameters
}   GAME_WORK_ITEM, *PGAME_WORK_ITEM;

//  @type HID_REPORT_ID | Retyped for portability and readability
typedef UCHAR                                 HID_REPORT_ID;    
typedef UCHAR                               *PHID_REPORT_ID;    

//---------------------------------------------------------------------------
//          Transaction Types
//---------------------------------------------------------------------------

typedef enum
{                                           // @enum MSGAME_TRANSACTION | Device transaction types
    MSGAME_TRANSACT_NONE,           // @emem No transaction type
    MSGAME_TRANSACT_RESET,          // @emem Reset transaction type
    MSGAME_TRANSACT_DATA,           // @emem Data transaction type
    MSGAME_TRANSACT_ID,             // @emem Id transaction type
    MSGAME_TRANSACT_STATUS,         // @emem Status transaction type
    MSGAME_TRANSACT_SPEED,          // @emem Speed transaction type
    MSGAME_TRANSACT_GODIGITAL,      // @emem GoDigital transaction type
    MSGAME_TRANSACT_GOANALOG        // @emem GoAnalog transaction type
}   MSGAME_TRANSACTION;

//---------------------------------------------------------------------------
//          Local Include Files
//---------------------------------------------------------------------------

#include    "debug.h"
#include    "device.h"
#include    "timer.h"
#include    "portio.h"

#define public

//---------------------------------------------------------------------------
//          Definitions
//---------------------------------------------------------------------------

#ifdef  SAITEK
#define MSGAME_VENDOR_ID                ((USHORT)'SA')
#else
#define MSGAME_VENDOR_ID                ((USHORT)0x045E)
#endif

#define MSGAME_VERSION_NUMBER       ((USHORT)3)

#define MSGAME_HID_VERSION          0x0100
#define MSGAME_HID_COUNTRY          0x0000
#define MSGAME_HID_DESCRIPTORS      0x0001

#define MSGAME_AUTODETECT_ID            L"Gameport\\SideWinderGameController\0\0"

//---------------------------------------------------------------------------
//          Structures
//---------------------------------------------------------------------------

typedef struct
{                                           // @struct DEVICE_EXTENSION | Device extension data
    PDRIVER_OBJECT Driver;          // @field A back pointer to the actual DriverObject
    PDEVICE_OBJECT  Self;               // @field A back pointer to the actual DeviceObject
    LONG                IrpCount;       // @field 1 biased count of why object sticks around
    BOOLEAN         Started;            // @field This device has been started
    BOOLEAN         Removed;            // @field This device has been removed
    BOOLEAN        Surprised;       // @field This device has been surprise removed
    BOOLEAN        Removing;        // @field This device is being removed
    PDEVICE_OBJECT  TopOfStack;     // @field The top of the device stack beneath this device
    GAMEPORT            PortInfo;       // @field Game resource info structure filled by GameEnumerator
    KEVENT          StartEvent;     // @field An event to sync the start IRP.
    KEVENT          RemoveEvent;    // @field An event to synch outstandIO to zero
}   DEVICE_EXTENSION,   *PDEVICE_EXTENSION;

//---------------------------------------------------------------------------
//          Macros
//---------------------------------------------------------------------------

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) \
    ((PDEVICE_EXTENSION)(((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

#define STD0(txt)           #txt
#define STD1(txt)           STD0(txt)
#define STILL_TO_DO(txt)    message("\nSTILL TO DO: "__FILE__"("STD1(__LINE__)"): "#txt"\n")

#define ARRAY_SIZE(a)       (sizeof(a)/sizeof(a[0]))

#define EXCHANGE(x,y)       ((x)^=(y)^=(x)^=(y))

#define TOUPPER(x)          ((x>='a'&&x<='z')?x-'a'+'A':x)

//---------------------------------------------------------------------------
//          Procedures
//---------------------------------------------------------------------------

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING     registryPath
    );

NTSTATUS
MSGAME_CreateClose (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_SystemControl (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_AddDevice (
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    );

VOID
MSGAME_Unload (
    IN  PDRIVER_OBJECT          DriverObject
    );

VOID
MSGAME_ReadRegistry (
    PCHAR                           DeviceName,
    PDEVICE_VALUES              DeviceValues
    );

NTSTATUS
MSGAME_Internal_Ioctl (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetDeviceDescriptor (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetReportDescriptor (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetAttributes (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        Irp
    );

NTSTATUS
MSGAME_GetFeature (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        Irp
    );

NTSTATUS
MSGAME_ReadReport (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

PWCHAR
MSGAME_GetHardwareId (
    IN  PDEVICE_OBJECT          DeviceObject
    );

BOOLEAN
MSGAME_CompareHardwareIds (
    IN  PWCHAR                  HardwareId,
    IN  PWCHAR                  DeviceId
    );

VOID
MSGAME_FreeHardwareId (
    IN  PWCHAR                  HardwareId
    );

NTSTATUS
MSGAME_PnP (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_PnPComplete (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp,
    IN  PVOID                       Context
    );

NTSTATUS
MSGAME_StartDevice (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  PIRP                        pIrp
    );

VOID
MSGAME_StopDevice (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  BOOLEAN                 TouchTheHardware
    );

NTSTATUS
MSGAME_Power (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetResources (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetResourcesComplete (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp,
    IN  PVOID                       Context
    );

VOID 
MSGAME_PostTransaction (
    IN      PPACKETINFO         PacketInfo
    );

NTSTATUS
MSGAME_CreateDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
MSGAME_RemoveDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
MSGAME_ChangeDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

//===========================================================================
//          End
//===========================================================================
#endif  // __MSGAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\portio.c ===
//**************************************************************************
//
//		PORTIO.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	PORTIO.C | Gameport Input/Output Routines
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, PORTIO_DriverEntry)
#endif

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	ULONG			PortTimeOut		=	ONE_MILLI_SEC;
static	KIRQL			MaskedIrql		=	PASSIVE_LEVEL;
static	KIRQL			SpinLockIrql	=	PASSIVE_LEVEL;
static	KSPIN_LOCK	IoSpinLock		=	{0};

//---------------------------------------------------------------------------
// @func		Driver entry point for portio layer
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	PORTIO_DriverEntry (VOID)
{
	KeInitializeSpinLock (&IoSpinLock);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Masks system interrupts for access to gameport
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_MaskInterrupts (VOID)
{
	KeRaiseIrql (PROFILE_LEVEL, &MaskedIrql);
}

//---------------------------------------------------------------------------
// @func		Unmasks system interrupts for access to gameport
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_UnMaskInterrupts (VOID)
{
	KeLowerIrql (MaskedIrql);
}

//---------------------------------------------------------------------------
// @func		Acquires exclusive access to gameport (mutex)
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns true if successful
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_AcquirePort (PGAMEPORT PortInfo)
{
	if (PortInfo->AcquirePort (PortInfo->PortContext) != STATUS_SUCCESS)
		return (FALSE);
	KeAcquireSpinLock (&IoSpinLock, &SpinLockIrql);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Releases exclusive access to gameport (mutex)
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_ReleasePort (PGAMEPORT PortInfo)
{
	KeReleaseSpinLock (&IoSpinLock, SpinLockIrql);
	PortInfo->ReleasePort (PortInfo->PortContext);
}

//---------------------------------------------------------------------------
// @func		Calculates port timeout value
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID PORTIO_CalibrateTimeOut (PGAMEPORT PortInfo)
{
	PortTimeOut = TIMER_CalibratePort (PortInfo, ONE_MILLI_SEC);
}

//---------------------------------------------------------------------------
// @func		Reads byte from IO port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns byte from port
//	@comm		Public function
//---------------------------------------------------------------------------
#if _MSC_FULL_VER <= 13008829
#pragma optimize("y", off)
#endif
UCHAR PORTIO_Read (PGAMEPORT PortInfo)
{
	UCHAR	Value;

	__asm	pushad
	Value = PortInfo->ReadAccessor (PortInfo->GameContext);
	__asm	popad
	return (Value);
}

//---------------------------------------------------------------------------
// @func		Write byte To IO port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		UCHAR | Value | Value to write
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID PORTIO_Write (PGAMEPORT PortInfo, UCHAR Value)
{
	__asm	pushad
	PortInfo->WriteAccessor (PortInfo->GameContext, Value);
	__asm	popad
}
#if _MSC_FULL_VER <= 13008829
#pragma optimize("", on)
#endif
//---------------------------------------------------------------------------
// @func		Get AckNak (buttons) from gameport
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Timeout | Calibrated status gate timeout
//	@parm		PUCHAR | AckNak | Pointer to AckNak buffer
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_GetAckNak (PGAMEPORT PortInfo, ULONG Timeout, PUCHAR AckNak)
{
	if (!PORTIO_WaitForStatusGate (PortInfo, CLOCK_BIT_MASK, Timeout))
		return (FALSE);

	TIMER_DelayMicroSecs (10);

	*AckNak = PORTIO_Read (PortInfo);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Get NakAck (buttons) from gameport
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Timeout | Calibrated status gate timeout
//	@parm		PUCHAR | NakAck | Pointer to NakAck buffer
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_GetNakAck (PGAMEPORT PortInfo, ULONG Timeout, PUCHAR NakAck)
{
	if (!PORTIO_WaitForStatusGate (PortInfo, STATUS_GATE_MASK, Timeout))
		return (FALSE);

	TIMER_DelayMicroSecs (10);

	*NakAck = PORTIO_Read (PortInfo);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Determines whether gameport clock is active
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_IsClockActive (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	UCHAR	Value;

	Value = PORTIO_Read (PortInfo);
	do if ((PORTIO_Read (PortInfo) ^ Value) & CLOCK_BIT_MASK)
		return (TRUE);
	while (--DutyCycle);

	return (FALSE);
}
	
//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes inactive
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockInActive (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	ULONG	TimeOut = PortTimeOut;

	do	if (!PORTIO_IsClockActive (PortInfo, DutyCycle))
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockInActive)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & CLOCK_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockLow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes high
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockHigh (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & CLOCK_BIT_MASK))
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockHigh)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport data2 line goes low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitDataLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & DATA2_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitDataLow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA line goes high to low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitXA_HighLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	if ((PORTIO_Read (PortInfo) & INTXA_BIT_MASK) == 0)
		{
		MsGamePrint ((DBG_SEVERE, "PORTIO: Initial (WaitXA_HighLow) Was Low\n"));
		return (FALSE);
		}

	do	if ((PORTIO_Read (PortInfo) & INTXA_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitXALow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA and clock lines go low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForIdle (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & (INTXA_BIT_MASK|CLOCK_BIT_MASK)) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitForIdle)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA and clock lines go low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @parm		UCHAR | Mask | Button mask to wait on
//	@parm		ULONG | Timeout | Calibrated status gate timeout
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForStatusGate (PGAMEPORT PortInfo, UCHAR Mask, ULONG Timeout)
{
	do	if ((PORTIO_Read (PortInfo) & STATUS_GATE_MASK) == Mask)
		return (TRUE);
	while (--Timeout);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitForStatusGate)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits for gameport XA low, clock inactive and then clock low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForHandshake (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	return
		(
		PORTIO_WaitXA_HighLow (PortInfo) 					&&
		PORTIO_WaitClockInActive (PortInfo, DutyCycle)	&&
		PORTIO_WaitClockLow (PortInfo)
		);
}

//---------------------------------------------------------------------------
// @func		Waits for gameport XA low, clock inactive and then clock low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForIdleHandshake (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	ULONG	TimeOut = PortTimeOut;

	if (!PORTIO_WaitClockHigh (PortInfo))
		return (FALSE);

	if (!PORTIO_WaitForIdle (PortInfo))
		return (FALSE);

	do	if (!PORTIO_IsClockActive (PortInfo, DutyCycle))
		return (TRUE);
	while (--TimeOut);

	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Pulses port and the waits for gameport handshake
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
//	@parm		ULONG | Pulses | Number of pulses to perform
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_PulseAndWaitForHandshake (PGAMEPORT PortInfo, ULONG DutyCycle, ULONG Pulses)
{
	while (Pulses--)
		{
		PORTIO_Write (PortInfo, 0);
		if (!PORTIO_WaitForHandshake (PortInfo, DutyCycle))
			return (FALSE);
		}
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Pulses port and the waits for gameport idle handshake
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
//	@parm		ULONG | Pulses | Number of pulses to perform
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_PulseAndWaitForIdleHandshake (PGAMEPORT PortInfo, ULONG DutyCycle, ULONG Pulses)
{
	while (Pulses--)
		{
		PORTIO_Write (PortInfo, 0);
		if (!PORTIO_WaitForIdleHandshake (PortInfo, DutyCycle))
			return (FALSE);
		}
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\pnp.c ===
//**************************************************************************
//
//		PNP.C -- Xena Gaming Project
//
//		This module contains PnP Start, Stop, Remove, Power dispatch routines
//		and the IRP cancel routine.
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	PNP.C | Supports PnP Start, Stop, Remove, Power dispatch routines
//		and the IRP cancel routine.
//**************************************************************************

#include	<msgame.h>

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (PAGE, MSGAME_Power)
#pragma	alloc_text (PAGE, MSGAME_PnP)
#pragma	alloc_text (PAGE, MSGAME_StopDevice)
#pragma	alloc_text (PAGE, MSGAME_GetResources)
#endif

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	PVOID		CurrentGameContext	=	NULL;

//---------------------------------------------------------------------------
// @func		The plug and play dispatch routines.
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	LONG						i;
	NTSTATUS					ntStatus;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_PnP Enter\n", MSGAME_NAME, MSGAME_NAME));

	pDevExt	 = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);
	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	InterlockedIncrement (&pDevExt->IrpCount);

	if (pDevExt->Removed)
		{
		//
		// Someone sent us another plug and play IRP after removed
		//

		MsGamePrint ((DBG_SEVERE, "%s: PnP Irp after device removed\n", MSGAME_NAME));
		ASSERT (FALSE);

		if (!InterlockedDecrement (&pDevExt->IrpCount))
			KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return (STATUS_DELETE_PENDING);
		}

	switch (pIrpStack->MinorFunction)
		{
		case IRP_MN_START_DEVICE:
			//
			// We cannot touch the device (send it any non-Pnp Irps) until a
			// start device has been passed down to the lower drivers.
			//

			IoCopyCurrentIrpStackLocationToNext (pIrp);
			IoSetCompletionRoutine (pIrp, MSGAME_PnPComplete, pDevExt, TRUE, TRUE, TRUE);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			if (ntStatus == STATUS_PENDING)
				KeWaitForSingleObject (
					&pDevExt->StartEvent,
					Executive, 	// Waiting for reason of a driver
					KernelMode, // Waiting in kernel mode
					FALSE,		// No allert
					NULL);		// No timeout

			if (NT_SUCCESS (ntStatus))
				{
				//
				// As we are now back from our start device we can do work.
				//
				ntStatus = MSGAME_StartDevice (pDevExt, pIrp);
				}

			//
			//	Return Status
			//

			pIrp->IoStatus.Information = 0;
			pIrp->IoStatus.Status = ntStatus;
			IoCompleteRequest (pIrp, IO_NO_INCREMENT);
			break;

		case IRP_MN_STOP_DEVICE:
			//
			// After the start IRP has been sent to the lower driver object, the bus may
			// NOT send any more IRPS down ``touch'' until another START has occured.
			// Whatever access is required must be done before Irp passed on.
			//

			MSGAME_StopDevice (pDevExt, TRUE);

			//
			// We don't need a completion routine so fire and forget.
			// Set the current stack location to the next stack location and
			// call the next device object.
			//

			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;

		case IRP_MN_SURPRISE_REMOVAL:
			//
			//	We have been unexpectedly removed by the user. Stop the device,
			//	set status to SUCCESS and call next stack location with this IRP.
			//

			if (!pDevExt->Surprised && pDevExt->Started)
				MSGAME_StopDevice (pDevExt, TRUE);

			pDevExt->Surprised = TRUE;

			//
			// We don't want a completion routine so fire and forget.
			// Set the current stack location to the next location and
			// call the next device after setting status to success.
			//

			pIrp->IoStatus.Information	= 0;
			pIrp->IoStatus.Status		= STATUS_SUCCESS;
			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;

		case IRP_MN_REMOVE_DEVICE:
			//
			// The PlugPlay system has dictacted the removal of this device. We
			// have no choice but to detach and delete the device object.
			// (If we wanted to express an interest in preventing this removal,
			// we should have filtered the query remove and query stop routines.)
			// Note: we might receive a remove WITHOUT first receiving a stop.

			if (pDevExt->Started)
				{
				//
				// Stop the device without touching the hardware.
				//
				MSGAME_StopDevice (pDevExt, FALSE);
				}

			pDevExt->Removed = TRUE;

			//
			// Send on the remove IRP
			//

			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);

			//
			//	Must double-decrement because we start at One
			//
						
			i = InterlockedDecrement (&pDevExt->IrpCount);
			ASSERT(i>0);

			if (InterlockedDecrement (&pDevExt->IrpCount) > 0)
				KeWaitForSingleObject (&pDevExt->RemoveEvent, Executive, KernelMode, FALSE, NULL);

			//
			//	Return success
			//

			return (STATUS_SUCCESS);

		default:
			//
			// Here the filter driver might modify the behavior of these IRPS
			// Please see PlugPlay documentation for use of these IRPs.
			//
			IoSkipCurrentIrpStackLocation (pIrp);
			MsGamePrint ((DBG_INFORM, "%s_PnP calling next driver with minor function %ld at IRQL %ld\n", MSGAME_NAME, pIrpStack->MinorFunction, KeGetCurrentIrql()));
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;
		}

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	MsGamePrint ((DBG_INFORM, "%s: %s_PnP exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Completion routine for Pnp start device
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@parm		PVOID | Context | Pointer to device context
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_PnPComplete (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp, IN PVOID Context)
{
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_EXTENSION		pDevExt;
	NTSTATUS					ntStatus = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER (DeviceObject);

	MsGamePrint ((DBG_INFORM, "%s: %s_PnPComplete enter\n", MSGAME_NAME, MSGAME_NAME));

	pDevExt = (PDEVICE_EXTENSION) Context;
	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	switch (pIrpStack->MajorFunction)
		{
		case IRP_MJ_PNP:
			switch (pIrpStack->MinorFunction)
				{
				case IRP_MN_START_DEVICE:
					KeSetEvent (&pDevExt->StartEvent, 0, FALSE);

					//
					// Take IRP back so we can continue using it during the IRP_MN_START_DEVICE
					// dispatch routine. We will have to call IoCompleteRequest there.
					//
					return (STATUS_MORE_PROCESSING_REQUIRED);

				default:
					break;
				}
			break;

		default:
			break;
		}

	MsGamePrint ((DBG_INFORM, "%s: %s_PnPComplete Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		PnP start device IRP handler
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_StartDevice (IN PDEVICE_EXTENSION pDevExt, IN PIRP pIrp)
{
	PWCHAR			HardwareId;
	NTSTATUS			ntStatus;
	PDEVICEINFO		DevInfo;
	PDEVICE_OBJECT	RemoveObject;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_StartDevice Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// The PlugPlay system should not have started a removed device!
	//

	ASSERT (!pDevExt->Removed);

	if (pDevExt->Started)
		return (STATUS_SUCCESS);

	//
	// Acquire resources we need for this device
	//

	ntStatus = MSGAME_GetResources (pDevExt, pIrp);
	if (!NT_SUCCESS(ntStatus))
		return (ntStatus);

	//
	//	Dump debug OEM Data fields
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[0] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[0]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[1] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[1]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[2] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[2]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[3] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[3]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[4] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[4]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[5] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[5]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[6] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[6]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[7] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[7]));

	//
	//	Make sure we are only on one gameport
	//

	if (CurrentGameContext && (CurrentGameContext != pDevExt->PortInfo.GameContext))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_StartDevice Cannot Load on Multiple Gameports: 0x%X and 0x%X\n",\
						 CurrentGameContext, pDevExt->PortInfo.GameContext, MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DEVICE_CONFIGURATION_ERROR);
		}
	CurrentGameContext = pDevExt->PortInfo.GameContext;

	//
	//	Get the HardwareId for this Start request
	//

	HardwareId = MSGAME_GetHardwareId (pDevExt->Self);
	if (!HardwareId)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId Failed\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DEVICE_CONFIGURATION_ERROR);
		}

	//
	//	Initialize OEM Data
	//
	
	SET_DEVICE_OBJECT(&pDevExt->PortInfo, pDevExt->Self);

	//
	//	Now start the low level device
	//

	ntStatus = DEVICE_StartDevice (&pDevExt->PortInfo, HardwareId);
		
	//
	//	Free HardwareId right away
	//

	MSGAME_FreeHardwareId (HardwareId);

	//
	//	Check if low-level start device failed
	//

	if (NT_ERROR(ntStatus))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_StartDevice Failed\n", MSGAME_NAME, MSGAME_NAME));
		return (ntStatus);
		}

	//
	// Everything is fine so let's say device has started
	//

	pDevExt->Started = TRUE;

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_StartDevice Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		PnP start device IRP handler
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		BOOLEAN | TouchTheHardware | Flag to send non PnP Irps to device
// @rdesc	Returns NT status code
//	@comm		Public function <en->
//				The PlugPlay system has dictacted the removal of this device.
//				We have no choise but to detach and delete the device object.
//				(If we wanted to express and interest in preventing this removal,
//				we should have filtered the query remove and query stop routines.)
//				Note! we might receive a remove WITHOUT first receiving a stop
//---------------------------------------------------------------------------

VOID	MSGAME_StopDevice (IN PDEVICE_EXTENSION pDevExt, IN BOOLEAN TouchTheHardware)
{
	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_StopDevice enter \n", MSGAME_NAME, MSGAME_NAME));

	//
	// The PlugPlay system should not have started a removed device!
	//

	ASSERT (!pDevExt->Removed);
	if (!pDevExt->Started)
		return;

	//
	//	Now stop the low level device
	//

	DEVICE_StopDevice (&pDevExt->PortInfo, TouchTheHardware);

	//
	// Everything is fine so let's say device has stopped
	//

	pDevExt->Started = FALSE;

	MsGamePrint ((DBG_INFORM, "%s: %s_StopDevice exit \n", MSGAME_NAME, MSGAME_NAME));
}

//---------------------------------------------------------------------------
// @func		Power dispatch routine.
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	PDEVICE_EXTENSION	pDevExt;
	NTSTATUS				ntStatus;
	PIO_STACK_LOCATION pIrpStack;

	PAGED_CODE ();

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);
	MsGamePrint ((DBG_CONTROL, "%s: %s_Power Enter  MN_Function %x type %x State %x\n", MSGAME_NAME, MSGAME_NAME,pIrpStack->MinorFunction,pIrpStack->Parameters.Power.Type,pIrpStack->Parameters.Power.State));

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// This IRP was sent to the filter driver. Since we do not know what
	// to do with the IRP, we should pass it on along down the stack.
	//

	InterlockedIncrement (&pDevExt->IrpCount);

	if (pDevExt->Removed)
		{
		ntStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = ntStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		}
	else
		{
		//Is System trying to wake up device
		if ((2 == (pIrpStack->MinorFunction)) && (1 == (pIrpStack->Parameters.Power.Type)) &&( 1 == (pIrpStack->Parameters.Power.State.SystemState)))
		{
			// Clear DeviceDetected to force reset and redetect
			SET_DEVICE_INFO(&(pDevExt->PortInfo),0);
			MsGamePrint ((DBG_CONTROL, "%s: %s_Power Resetting Device Detected\n", MSGAME_NAME, MSGAME_NAME));


		}
		//
		// Power IRPS come synchronously; drivers must call
		// PoStartNextPowerIrp, when they are ready for the next power irp.
		// This can be called here, or in the completetion routine.
		//
		PoStartNextPowerIrp (pIrp);

		//
		// PoCallDriver NOT IoCallDriver.
		//
		IoSkipCurrentIrpStackLocation (pIrp);
		ntStatus =	PoCallDriver (pDevExt->TopOfStack, pIrp);
		}

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	MsGamePrint ((DBG_INFORM, "%s: %s_Power Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to request gameport parameters
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetResources (IN PDEVICE_EXTENSION pDevExt, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	KEVENT					IoctlCompleteEvent;
	IO_STATUS_BLOCK		IoStatus;
	PIO_STACK_LOCATION	pIrpStack, nextStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetResources Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Issue a synchronous request to get the resources info from GameEnum
	//

	KeInitializeEvent (&IoctlCompleteEvent, NotificationEvent, FALSE);

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);
	nextStack = IoGetNextIrpStackLocation (pIrp);
	ASSERT (nextStack);

	//
	// Pass the Portinfo buffer of the DeviceExtension
	//

	pDevExt->PortInfo.Size = sizeof (GAMEPORT);

	nextStack->MajorFunction											= IRP_MJ_INTERNAL_DEVICE_CONTROL;
	nextStack->Parameters.DeviceIoControl.IoControlCode		= IOCTL_GAMEENUM_PORT_PARAMETERS;
	nextStack->Parameters.DeviceIoControl.InputBufferLength	= sizeof (GAMEPORT);
	nextStack->Parameters.DeviceIoControl.OutputBufferLength	= sizeof (GAMEPORT);
	pIrp->UserBuffer														= &pDevExt->PortInfo;

	IoSetCompletionRoutine (pIrp, MSGAME_GetResourcesComplete, &IoctlCompleteEvent, TRUE, TRUE, TRUE);

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Get Resources at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));

	ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&IoctlCompleteEvent, Suspended, KernelMode, FALSE, NULL);

	if (NT_SUCCESS(ntStatus))
		MsGamePrint ((DBG_VERBOSE, "%s: %s_GetResources Port Obtained = 0x%lX\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.GameContext));
	else MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Provide Resources, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Return Status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetResources Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (pIrp->IoStatus.Status);
}

//---------------------------------------------------------------------------
// @func		Completion routine for GameEnum get reosources driver call
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@parm		PVOID | Context | Pointer to device context
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetResourcesComplete (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp, IN PVOID Context)
{
	UNREFERENCED_PARAMETER (DeviceObject);

	KeSetEvent ((PKEVENT)Context, 0, FALSE);

	if (pIrp->PendingReturned)
		IoMarkIrpPending (pIrp);

	return (STATUS_MORE_PROCESSING_REQUIRED);
}

//---------------------------------------------------------------------------
// @func		Gets HardwareId string for device object (assumes caller frees)
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Pointer to allocated memory containing string
//	@comm		Public function
//---------------------------------------------------------------------------

PWCHAR MSGAME_GetHardwareId (IN PDEVICE_OBJECT DeviceObject)
{
	LONG					BufferLength	=	0;
	PWCHAR 				Buffer			=	NULL;
	NTSTATUS				ntStatus;
	PDEVICE_OBJECT		pPDO;

	MsGamePrint ((DBG_INFORM, "%s: %s_GetHardwareId\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Walk to end of stack and get pointer to PDO
	//

	pPDO = DeviceObject;
	while (GET_NEXT_DEVICE_OBJECT(pPDO))
		pPDO = GET_NEXT_DEVICE_OBJECT(pPDO);

	//
	//	Get Buffer length
	//

	ntStatus = IoGetDeviceProperty(
						pPDO,
						DevicePropertyHardwareID,
						BufferLength,
						Buffer,
						&BufferLength);

	ASSERT(ntStatus==STATUS_BUFFER_TOO_SMALL);

	//
	//	Allocate room for HardwareID
	//

	Buffer = ExAllocatePool(PagedPool, BufferLength);
	if	(!Buffer)
		{
		//
		//	If we cannot get the memory to try this, then just say it is a no match
		//
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId failed ExAllocate\n", MSGAME_NAME, MSGAME_NAME));
		return (NULL);
		}

	//
	//	Now get the data
	//

	ntStatus = IoGetDeviceProperty(
						pPDO,
						DevicePropertyHardwareID,
						BufferLength,
						Buffer,
						&BufferLength);

	//
	//	On error, free memory and return NULL
	//

	if (!NT_SUCCESS(ntStatus))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId couldn't get id from PDO\n", MSGAME_NAME, MSGAME_NAME));
		ExFreePool(Buffer);
		return (NULL);
		}

	//
	//	Return buffer containing hardware Id - must be freed by caller
	//

	return (Buffer);
}

//---------------------------------------------------------------------------
// @func		Compares HardwareId strings
//	@parm		PWCHAR | HardwareId | Pointer to object hardware id
//	@parm		PWCHAR | DeviceId | Pointer to device's hardware id
// @rdesc	True if strings are the same, false if different
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN MSGAME_CompareHardwareIds (IN PWCHAR HardwareId, IN PWCHAR DeviceId)
{
	MsGamePrint ((DBG_INFORM, "%s: %s_CompareHardwareIds\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Peform runtime parameter checks
	//

	if (!HardwareId || !DeviceId)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_CompareHardwareIds - Bogus Strings\n", MSGAME_NAME, MSGAME_NAME));
		return (FALSE);
		}

	//
	//	Perform char-by-char string compare
	//

	while (*HardwareId && *DeviceId)
		{
		if (TOUPPER(*HardwareId) != TOUPPER(*DeviceId))
			return (FALSE);
		HardwareId++;
		DeviceId++;
		}

	//
	//	Return success
	//

	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Frees HardwareId allocated from MSGAME_GetHardwareId
//	@parm		PWCHAR | HardwareId | Pointer to hardware id to free
// @rdesc	None
//	@comm		Public function
//---------------------------------------------------------------------------

VOID MSGAME_FreeHardwareId (IN PWCHAR HardwareId)
{
	MsGamePrint ((DBG_INFORM, "%s: %s_FreeHardwareId\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Free memory pool
	//

	if (HardwareId)
		ExFreePool(HardwareId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dff.c ===
//**************************************************************************
//
//		SW3DFF.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DFF.C | Gameport mini-driver for Sidewinder Pro Force Feedback
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"
#include	"swforce.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DFF"
#define	DEVICE_PID					0x0006
#define	HARDWARE_ID					L"Gameport\\SideWinderForceFeedbackPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		(9+1)
#define	GAME_PACKET_AXIS			4

#define	GAME_B0_B7_BYTE			0					// Packet[0] bits
#define	GAME_B0_B7_BITS			0xff

#define	GAME_B8_BYTE				1					// Packet[1] bits
#define	GAME_B8_BITS				0x01
#define	GAME_X0_X6_BYTE			1
#define	GAME_X0_X6_BITS			0xfe

#define	GAME_X7_X9_BYTE			2					// Packet[2] bits
#define	GAME_X7_X9_BITS			0x07
#define	GAME_Y0_Y4_BYTE			2
#define	GAME_Y0_Y4_BITS			0xf8

#define	GAME_Y5_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y5_Y9_BITS			0x1f
#define	GAME_T0_T2_BYTE			3
#define	GAME_T0_T2_BITS			0xe0

#define	GAME_T3_T6_BYTE			4					// Packet[4] bits
#define	GAME_T3_T6_BITS			0x0f
#define	GAME_R0_R3_BYTE			4
#define	GAME_R0_R3_BITS			0xf0

#define	GAME_R4_R5_BYTE			5					// Packet[5] bits
#define	GAME_R4_R5_BITS			0x3
#define	GAME_H0_H3_BYTE			5
#define	GAME_H0_H3_BITS			0x3c
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x40
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x80

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x8000

//
//	ID Constants
//

#define	GAME_PRODUCT_ID			6
#define	GAME_ID_CLOCKS				8

//
//	Status Constants
//

#define	STATUS_CLOCK_COMPLETE	0x2000

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50
#define	STATUS_START_TIMEOUT		500
#define	STATUS_LOWHIGH_TIMEOUT	75
#define	STATUS_HIGHLOW_TIMEOUT	150
#define	STATUS_GATE_TIMEOUT		3000

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x7f
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//
//	Throttle Smoothing
//

#define THROTTLE_JITTER_TIMEOUT	100				// in milliseconds
#define THROTTLE_QUEUE_SIZE		4

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DFF_ID | Sidwinder Pro FF Id String
#pragma pack(1)
	ULONG		ProductId:16;			// @field Device identifier
	ULONG		Version:7;				// @field Firmware version
	ULONG		OddParity:1;			// @field Packet parity
	ULONG		Unused:8;				// @field Unused
#pragma pack()
}	SW3DFF_ID, *PSW3DFF_ID;

typedef	struct
{											// @struct SW3DFF_STATUS | Sidwinder Pro FF Status
#pragma pack(1)
	UCHAR		xVelocity;				// @field X axis velocity
	UCHAR		yVelocity;				// @field Y axis velocity
	UCHAR		xAccel;					// @field X axis acceleration
	UCHAR		yAccel;					// @field Y axis acceleration
	USHORT	Status;					// @field Status word (bit fields)
#pragma pack()
}	SW3DFF_STATUS, *PSW3DFF_STATUS;

typedef struct
{											// @struct THROTTLE_QUEUE | Sidwinder Pro FF Throttle
   ULONG		dwZ;						// @field Z axis position
   ULONG		TimeStamp;				// @field timestamp for entry
}	THROTTLE_QUEUE, *PTHROTTLE_QUEUE;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DFF_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DFF_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DFF_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DFF_GetId (PPACKETINFO IdPacket);

static	BOOLEAN	SW3DFF_ReadStatus (PPACKETINFO StatusPacket);
static	BOOLEAN	SW3DFF_GetStatus (PPACKETINFO StatusPacket);

static	NTSTATUS	SW3DFF_ReadData (PPACKETINFO DataPacket);
static	VOID		SW3DFF_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DFF_AdjustThrottle (PDEVICE_PACKET Report);

static	NTSTATUS	SW3DFF_ForceReset (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_ForceId (PGAMEPORT PortInfo, PVOID IdString);
static	NTSTATUS	SW3DFF_ForceStatus (PGAMEPORT PortInfo, PVOID Status);
static	NTSTATUS	SW3DFF_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak);
static	NTSTATUS	SW3DFF_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck);
static	NTSTATUS	SW3DFF_ForceSync (PGAMEPORT PortInfo, PULONG Sync);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DFF_DriverEntry (VOID);
static	NTSTATUS	SW3DFF_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DFF_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);
static	NTSTATUS	SW3DFF_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DFF_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	
	//---------------------------------------------------------------------------
	// JOYINFOEX
	//---------------------------------------------------------------------------

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	HIDP_REPORT_ID_1,				MSGAME_INPUT_JOYINFOEX,

	//	id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//	dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (127)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (127)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)
	
	//	dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//---------------------------------------------------------------------------
	// GetID
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETID,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x00,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwProductID
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x01,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwFWVersion
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x02,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetStatus
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSTATUS,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x03,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwXVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x04,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x05,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwXAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x06,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x07,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwEffect
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x08,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwDeviceStatus
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x09,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetAckNak
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETACKNAK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0A,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	//	GetNakAck
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETNAKACK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0B,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetSync
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSYNC,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0C,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//---------------------------------------------------------------------------
	// DoReset
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_RESET,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0D,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x03,									//	FEATURE (Cnst,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetVersion
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETVERSION,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0E,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	HIDP_MAIN_ENDCOLLECTION												//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{
							0,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SW3DFF_ID	RawId	=
							{
							0
							};

//
//	Raw Status Buffer
//

static	SW3DFF_STATUS	RawStatus =
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							STATUS_START_TIMEOUT,
							STATUS_HIGHLOW_TIMEOUT,
							STATUS_LOWHIGH_TIMEOUT,
							STATUS_GATE_TIMEOUT
							};

static	ULONG			StatusGateTimeout;

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Status Packet Info
//

static	PACKETINFO	StatusInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawStatus),		// Size of raw status buffer
							&RawStatus					// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DFF_DriverEntry,		// DriverEntry
							SW3DFF_ConnectDevice,  	// ConnectDevice
							SW3DFF_StartDevice,	  	//	StartDevice
							SW3DFF_ReadReport,		// ReadReport
							SW3DFF_StopDevice,		// StopDevice
							SW3DFF_GetFeature			// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{
							GAME_B0_B7_BITS,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS|GAME_B8_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};

//
//	Rotation Filter Table
//

static	UCHAR			RotationFilter[EXTENTS_R_MAX+1] =
							{
						    0, 1, 3, 4, 5, 6, 8, 9,10,12,13,14,15,17,18,19,
						   20,22,23,24,26,27,28,29,31,32,32,32,32,32,32,32,
						   32,32,32,32,32,32,32,33,34,36,37,38,39,41,42,43,
						   44,46,47,48,49,50,52,53,54,55,57,58,59,60,62,63
							};

//
//	Throttle Queue
//

static	THROTTLE_QUEUE	ThrottleQueue [THROTTLE_QUEUE_SIZE] =
							{
   						{0x40,0},
   						{0x40,0},
   						{0x40,0},
   						{0x40,0}
							};

//
//	Reset Flag
//

static	BOOLEAN		ResetComplete = FALSE;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	JoltInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_FIRST,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DFF: SW3DFF_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	StatusInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.ClockDutyCycle = %ld\n", StatusInfo.ClockDutyCycle));
	StatusInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.StartTimeout = %ld\n", StatusInfo.StartTimeout));
	StatusInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.LowHighTimeout=%ld\n", StatusInfo.LowHighTimeout));
	StatusInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.HighLowTimeout=%ld\n", StatusInfo.HighLowTimeout));
	StatusGateTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusGateTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusGateTimeout=%ld\n", StatusGateTimeout));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (PORTIO_PulseAndWaitForIdleHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		PORTIO_Write (PortInfo, 0);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (!Result)
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ResetDevice - PulseAndWaitForIdleHandshake failed\n"));

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ReadId (PPACKETINFO IdPacket)
{
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, IdInfo.ClockDutyCycle, 2))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:

			mov	ah, al
			shr	al, 5
			shrd	esi, eax,3
			dec	ebx
			jne	ID_ClockCheck
			shr	esi, 8						; only 24 bits

		; ID_Success:

			mov	IdInfo.B4Transitions, edi
			mov	eax, ERROR_SUCCESS
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DFF_ReadId - SUCCEEDED, Data=%ld\n", Data));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@LowClockStart, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@HighClockStart, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@ClockFalling, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@ClockRising, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN		Result;
	PSW3DFF_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetId enter\n"));

	IdPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SW3DFF_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DFF_ID)IdPacket->Data;
		if ((Pnp->ProductId != GAME_PRODUCT_ID) || !DEVICE_IsOddParity (Pnp, sizeof(SW3DFF_ID)))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetId - Id did not match or parity error\n"));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ReadData (PPACKETINFO DataPacket)
{
	LONG			Result;
	LONG			Clks		= 1L;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.
			
			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 16
			mov	word ptr [esi+4], di

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	DataInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or  	al, al
			mov	eax, ERROR_SUCCESS
			je		Enh_Complete

			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->TimeStamp	=	TIMER_GetTickCount ();
	DataPacket->LastError	=	Result;
	DataPacket->Transaction	=	MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_EXTRACLOCKS:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - Extra Clocks, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (DataPacket);

	if (Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 7;
	Report->dwX  |= (Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS) >> 1;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y5_Y9_BYTE] & GAME_Y5_Y9_BITS;
	Report->dwY <<= 5;
	Report->dwY  |= (Data[GAME_Y0_Y4_BYTE] & GAME_Y0_Y4_BITS) >> 3;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R4_R5_BYTE] & GAME_R4_R5_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= (Data[GAME_R0_R3_BYTE] & GAME_R0_R3_BITS) >> 4;
	// Rotation filter
	Report->dwR = RotationFilter[Report->dwR];

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T3_T6_BYTE] & GAME_T3_T6_BITS;
	Report->dwZ <<= 3;
	Report->dwZ  |= (Data[GAME_T0_T2_BYTE] & GAME_T0_T2_BITS) >> 5;

	//
	//	Process Buttons
	//

	B1 = ~Data[GAME_B0_B7_BYTE] & GAME_B0_B7_BITS;
	B2 = ~Data[GAME_B8_BYTE] & GAME_B8_BITS;
	B2 <<= 9;	// Move button nine to ten (shift key)
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>2];
}

//---------------------------------------------------------------------------
// @func		Filters throttle packet information
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_AdjustThrottle (PDEVICE_PACKET Report)
{
   ULONG	i;
   ULONG	TimeStamp;
   ULONG	zTotal;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_AdjustThrottle enter\n"));

	zTotal		=	0;
   TimeStamp	=	TIMER_GetTickCount ();
	
	//
   // If current sample past que window then repopulate queue with current sample and time stamp
	//

	if ((ThrottleQueue[THROTTLE_QUEUE_SIZE-1].TimeStamp+THROTTLE_JITTER_TIMEOUT) < TimeStamp)
	   {
      for (i = 0; i < THROTTLE_QUEUE_SIZE; i++)
   	   {
         ThrottleQueue[i].dwZ		= Report->dwZ;
         ThrottleQueue[i].TimeStamp	= TimeStamp;
      	}
      return;
   	}

	//
   // Move the whole queue down by one
	//

   memcpy (ThrottleQueue, &ThrottleQueue[1], sizeof(THROTTLE_QUEUE)*(THROTTLE_QUEUE_SIZE-1));

	//
   // Place new que member into last position
	//

   ThrottleQueue[THROTTLE_QUEUE_SIZE-1].dwZ			= Report->dwZ;
   ThrottleQueue[THROTTLE_QUEUE_SIZE-1].TimeStamp	= TimeStamp;

	//
   // Now average all que positions
	//

   for (i = 0; i < THROTTLE_QUEUE_SIZE; i++)
      zTotal += ThrottleQueue[i].dwZ;

 	Report->dwZ = zTotal / THROTTLE_QUEUE_SIZE;
}

//---------------------------------------------------------------------------
// @func		Reads and validates device status
//	@parm		PPACKETINFO | StatusPacket | Status Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_GetStatus (PPACKETINFO StatusPacket)
{
	BOOLEAN			Result;
	PSW3DFF_STATUS	Status;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus Enter\n"));

	StatusPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SW3DFF_ReadStatus (StatusPacket);

	if (Result)
		{
		Status = (PSW3DFF_STATUS)StatusPacket->Data;
		if (!DEVICE_IsOddParity (Status, sizeof(SW3DFF_STATUS)))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetStatus - Parity error\n"));
			Result = FALSE;
			}
		else
			{
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - X Velocity = %ld\n", (long)Status->xVelocity));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Y Velocity = %ld\n", (long)Status->yVelocity));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - X Accel = %ld\n", 	 (long)Status->xAccel));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Y Accel = %ld\n", 	 (long)Status->xAccel));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Status = 0x%X\n", 	 (long)Status->Status));
			}
		}

	if (!Result)
		StatusPacket->Failures++;

	if (PORTIO_IsClockActive (&StatusPacket->PortInfo, StatusInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads status packet from gameport
//	@parm		PPACKETINFO | StatusPacket| Status packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ReadStatus (PPACKETINFO StatusPacket)
{
	USHORT		Status[3];
	LONG			Clks		=	1L;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &StatusPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadStatus enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	StatusPacket->ClocksSampled = 0;
	StatusPacket->B4Transitions = 0;

	if (!PORTIO_WaitDataLow (PortInfo))
		goto ReadStatusExit;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, StatusInfo.ClockDutyCycle, 1))
		goto ReadStatusExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, StatusInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, StatusInfo.StartTimeout

		Stat_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Stat_ClockStartState_1		; N: jump
			loop	Stat_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Stat_CollectData				; Y: jump
			loop	Stat_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Stat_ClockStartRise

		;Stat_ClockStartFall:

			mov	ecx, StatusInfo.HighLowTimeout

		Stat_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Stat_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartRise:

			mov	ecx, StatusInfo.LowHighTimeout

		Stat_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Stat_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Stat_Complete					; Time out error.

		Stat_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Stat_MidPacket					; Y: jump.
			test	ebx, STATUS_CLOCK_COMPLETE	; Q: is packet complete ?
			jnz	Stat_Success					; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Stat_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

		Stat_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 22
			and	edi, 3ffh
			mov	word ptr [esi+4], di

			mov	ax, [esi]
			mov	Status, ax
			mov	ax, [esi+2]
			mov	Status+2, ax
			mov	ax, [esi+4]
			mov	Status+4, ax
			mov	eax, ERROR_SUCCESS

		Stat_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadStatusExit:
	//	----------------

	for (StatusPacket->ClocksSampled = 0; Clks >> (StatusPacket->ClocksSampled+1); StatusPacket->ClocksSampled++);
	StatusPacket->TimeStamp 	=	TIMER_GetTickCount ();
	StatusPacket->LastError 	=	Result;
	StatusPacket->LastError		=	Result;
	StatusPacket->Transaction	=	MSGAME_TRANSACT_STATUS;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadStatus - SUCCEEDED, Data=0x%X%X%X,Clk=%ld\n", (ULONG)Status[2],(ULONG)Status[1],(ULONG)Status[0],Clks));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@LowClockStart\n"));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@HighClockStart\n"));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;
		}
	#endif

	MSGAME_PostTransaction (StatusPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Force feedback reset service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceReset (PGAMEPORT PortInfo)
{
	if (!SW3DFF_ResetDevice (PortInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Id | Id output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceId (PGAMEPORT PortInfo, PVOID Id)
{
	PPRODUCT_ID pProduct	= (PPRODUCT_ID)Id;
	PSW3DFF_ID	pSw3dff	= (PSW3DFF_ID)&RawId;

	if (!SW3DFF_ReadId (&IdInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pProduct->cBytes			=	sizeof (PRODUCT_ID);
	pProduct->dwProductID	=	pSw3dff->ProductId;
	pProduct->dwFWVersion	=	pSw3dff->Version;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Status | Status output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceStatus (PGAMEPORT PortInfo, PVOID Status)
{
	PJOYCHANNELSTATUS	pChannel	= (PJOYCHANNELSTATUS)Status;
	PSW3DFF_STATUS		pSw3dff	= (PSW3DFF_STATUS)&RawStatus;

	if (!SW3DFF_ReadStatus (&StatusInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pChannel->cBytes				=	sizeof (JOYCHANNELSTATUS);
	pChannel->dwXVel				=	pSw3dff->xVelocity;
	pChannel->dwYVel				=	pSw3dff->yVelocity;
	pChannel->dwXAccel			=	pSw3dff->xAccel;
	pChannel->dwYAccel			=	pSw3dff->yAccel;
	pChannel->dwEffect			=	0;
	pChannel->dwDeviceStatus	=	pSw3dff->Status & 0x3ff;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback acknak service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | AckNak | AckNak
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak)
{
	if (!PORTIO_GetAckNak (PortInfo, StatusGateTimeout, (PUCHAR)AckNak))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback NakAck service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck)
{
	if (!PORTIO_GetNakAck (PortInfo, StatusGateTimeout, (PUCHAR)NakAck))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback sync service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceSync (PGAMEPORT PortInfo, PULONG Sync)
{
	*Sync = PORTIO_Read (PortInfo);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DFF: SW3DFF_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = StatusInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SW3DFF_Calibrate (PortInfo);

	//
	// SW3DFF Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 2. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DFF: DeviceConnectProc getting ID string\n"));
		if (!SW3DFF_GetId (&IdInfo))
			continue;

		//
		// 3. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		
		//
		// 4. Reset device (tri-state midi so we don't get unintended forces)
		//

		if (!ResetComplete)
			{
			MsGamePrint ((DBG_CONTROL, "SW3DFF_ConnectDevice - resetting device\n"));
			if (!SW3DFF_ResetDevice (&DataInfo.PortInfo))
				continue;
			}

		//
		// 5. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 6. Mark device found and return
		//

		JoltInfo.NumDevices	=	1;
		ResetComplete			=	TRUE;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	JoltInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DFF_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DFF_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && DEVICE_IsOddParity (DataInfo.Data, GAME_PACKET_SIZE))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadReport - Invalid packet or parity error\n"));
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DFF_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DFF_ProcessData (ValidData, Report);

	//
	//	Adjust Throttle jitter
	//

	if (NT_SUCCESS(ntStatus))
		SW3DFF_AdjustThrottle (Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DFF_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DFF_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Get Feature requests
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID Feature Id
//	@parm		PVOID | ReportBuffer | Output buffer pointer
//	@parm		ULONG | ReportSize | Output buffer size
//	@parm		PULONG | Returned | Bytes returned pointer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	NTSTATUS	ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature enter\n"));

	//
	//	Handle feature codes
	//

	switch (ReportId)
		{
		case	MSGAME_INPUT_JOYINFOEX:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature JoyInfoEx\n"));
			if (ReportSize < sizeof (DEVICE_PACKET)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature JoyInfoEx Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ReadReport (PortInfo, ReportBuffer);
				*Returned += sizeof (DEVICE_PACKET);
				}
			break;

		case	MSGAME_FEATURE_GETID:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetId\n"));
			if (ReportSize < sizeof(PRODUCT_ID)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetId Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceId (PortInfo, ReportBuffer);
				*Returned += sizeof(PRODUCT_ID);
				}
			break;

		case	MSGAME_FEATURE_GETSTATUS:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetStatus\n"));
			if	(ReportSize < sizeof(JOYCHANNELSTATUS)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetStatus Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceStatus (PortInfo, ReportBuffer);
				*Returned += sizeof(JOYCHANNELSTATUS);
				}
			break;

		case	MSGAME_FEATURE_GETACKNAK:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetAckNak\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetAckNak Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceAckNak (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETNAKACK:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetNakAck\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetNakAck Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceNakAck (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETSYNC:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetSync\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetSync Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceSync (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_RESET:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature Reset\n"));
			if	(ReportSize < sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature Reset Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceReset (PortInfo);
				}
			break;

		case	MSGAME_FEATURE_GETVERSION:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetVersion\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetVersion Bad Buffer Size = %lu\n", ReportSize));
				}
         else
	         {
            *((PULONG)ReportBuffer)	= 0x20000;
			   *Returned += sizeof(ULONG);
   	      }
         break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature Invalid ReportId = %lu\n", ReportId));
			ntStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

	return (ntStatus);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dtilt.c ===
//**************************************************************************
//
//		SW3DTILT.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DTILT.C | Gameport mini-driver for Sidewinder Pro Tilt
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DTILT"
#define	DEVICE_PID					0x000d
#define	HARDWARE_ID					L"Gameport\\SideWinderFreestylePro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		10
#define	GAME_PACKET_AXIS			3

#define	GAME_X0_X7_BYTE			0					// Packet[0] bits
#define	GAME_X0_X7_BITS			0xff

#define	GAME_X8_X9_BYTE			1					// Packet[1] bits
#define	GAME_X8_X9_BITS			0x03
#define	GAME_B0_B5_BYTE			1
#define	GAME_B0_B5_BITS			0xfc

#define	GAME_Y0_Y7_BYTE			2					// Packet[2] bits
#define	GAME_Y0_Y7_BITS			0xff

#define	GAME_Y8_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y8_Y9_BITS			0x03
#define	GAME_B6_B7_BYTE			3
#define	GAME_B6_B7_BITS			0x0c
#define	GAME_H0_H3_BYTE			3
#define	GAME_H0_H3_BITS			0xf0

#define	GAME_T0_T5_BYTE			4					// Packet[4] bits
#define	GAME_T0_T5_BITS			0x3f
#define	GAME_B8_B9_BYTE			4
#define	GAME_B8_B9_BITS			0xC0

#define	GAME_B10_BYTE				5					// Packet[5] bits
#define	GAME_B10_BITS				0x01
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x02
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x04

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x4000

//
//	ID Constants
//

#define	GAME_ID_LOW					0x0d
#define	GAME_ID_HIGH				0x00
#define	GAME_ID_CLOCKS				40

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DTILT_ID | Sidwinder Pro Tilt Id String
#pragma pack(1)
	UCHAR		Status;					// @field Device status byte
	UCHAR		IdLow;					// @field Device identifier (low byte)
	UCHAR		IdHigh;					// @field Device identifier (high byte)
	USHORT	Version;					// @field Firmware version
#pragma pack()
}	SW3DTILT_ID, *PSW3DTILT_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DTILT_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DTILT_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DTILT_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DTILT_GetId (PPACKETINFO IdPacket);

static	LONG		SW3DTILT_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DTILT_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SW3DTILT_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_ValidateData (PUCHAR Packet);
static	VOID		SW3DTILT_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DTILT_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DTILT_DriverEntry (VOID);
static	NTSTATUS	SW3DTILT_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DTILT_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DTILT_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DTILT_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DTILT_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	// id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	// dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwR
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9f, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	// dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{		// no buttons; x, y and t centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS),
							GAME_Y0_Y7_BITS,
							((GAME_Y8_Y9_BITS>>1)&GAME_Y8_Y9_BITS),
							((GAME_T0_T5_BITS>>1)&GAME_T0_T5_BITS),
							0
							};
//
//	Raw Id Buffer
//

static	SW3DTILT_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DTILT_DriverEntry,		// DriverEntry
							SW3DTILT_ConnectDevice,		// ConnectDevice
							SW3DTILT_StartDevice,		//	StartDevice
							SW3DTILT_ReadReport,			// ReadReport
							SW3DTILT_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{		// no buttons; x, y and r centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS) | GAME_B0_B5_BITS,
							GAME_Y0_Y7_BITS,
							((GAME_Y8_Y9_BITS>>1)&GAME_Y8_Y9_BITS) | GAME_B6_B7_BITS,
							((GAME_T0_T5_BITS>>1)&GAME_T0_T5_BITS) | GAME_B8_B9_BITS,
							GAME_B10_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//
//	Parity problem Fix
//

static	ULONG			LastGoodButtons	=	0;
static	ULONG			PreviousButtons	=	0;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	TiltInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DTILT: SW3DTILT_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode  = IdInfo.Mode  = IMODE_DIGITAL_STD;
	DataInfo.Speed = IdInfo.Speed = GAME_SPEED_66K;

	if (PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DTILT_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	0x2002;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, IdInfo.ClockDutyCycle, 1))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, Clks					; BH,BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bh								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop
			dec 	bl
			je		ID_Success

			push	esi
			mov	esi, IdInfo.Data
			pop	dword ptr [esi]
			mov	bh, 8
			jmp	ID_ClockCheck

		ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 3
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			shr	esi, 24
			mov	ebx, esi
			mov	[edx+4], bl
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0
			mov	[edx+4], byte ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	switch (Clks & 0xFF)
		{
		case	0:
			IdPacket->ClocksSampled = 40;
			break;

		case	1:
			IdPacket->ClocksSampled = 32 + (8-(Clks>>8));
			break;

		case	2:
			IdPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@LowClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@HighClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN			Result;
	PSW3DTILT_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DTILT_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DTILT_ID)IdPacket->Data;
		if ((Pnp->IdLow == GAME_ID_LOW) && (Pnp->IdHigh == GAME_ID_HIGH) && ((Pnp->Status&0x7F) == 0))
			{
			//
			// Do AZTECH test here
			//
			if(IdPacket->B4Transitions >= 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DTILT_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DTILT_GetId - 1 Wide Only type card detected\n"));
				SW3DTILT_ResetDevice (&IdPacket->PortInfo);
				TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_GetId - Id did not match or status error = %ld\n", (ULONG)(Pnp->Status&0x7F)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DTILT_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_DecrementDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	ebx, 8						; BL = # of clocks to receive.
			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Data						; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockRise				; N: jump

		;DD_ClockFall:

			mov	ecx, DataInfo.HighLowTimeout

		DD_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		DD_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	DD_Complete					; Time out error.

		DD_ClockRise:

			mov	ecx, DataInfo.LowHighTimeout

		DD_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	DD_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	DD_Complete					; Time out error.

		DD_Data:

			shr	al, 6							; put data into carry
			rcr	ah, 1							; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	DD_ClockCheck				; if != 0 then loop

		;DD_Success:

			xchg	al, ah
			dec	al								; decrement returned speed
			and	eax, GAME_SPEED_BITS

			cmp	eax, GAME_SPEED_RANGE
			jb		DD_Complete
			dec	al

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "SW3DTILT_DecrementDevice - SUCCEEDED, Speed=%ld\n", Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_SetDeviceSpeed enter\n"));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < GAME_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SW3DTILT_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice failed on %ld attempt\n", (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "SW3DTILT_SetDeviceSpeed failed after %ld attempts\n", (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi


			lea	edx, DataInfo.PortInfo	; load gameport adddress

			mov	esi, DataInfo.Data
			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		Std_ClockStartState_1
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_ClockStartState_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	CollectData					; Y: jump
			loop	Std_ClockStartState_1	; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		;Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 11						; set bit counter = 32+11=43.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 43;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (11-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			lea	edx, DataInfo.PortInfo		; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is	 ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 19
			mov	word ptr [esi+4], di
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DTILT_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DTILT_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ValidateData (PUCHAR RawData)
{
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ValidateData enter\n"));

	if (RawData[GAME_ERR_BYTE] & GAME_ERR_BITS)
		Result = ERROR_ERRORBITS;
	else if ((RawId.Version >= 0x99) && !DEVICE_IsOddParity (RawData, GAME_PACKET_SIZE))
		Result = ERROR_PARITYBITS;
	else Result = ERROR_SUCCESS;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_ERRORBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ValidateData - Error bits non-zero\n"));
			break;

		case	ERROR_PARITYBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ValidateData - Parity bits failed\n"));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2, B3, B4;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X8_X9_BYTE] & GAME_X8_X9_BITS;
	Report->dwX <<= 8;
	Report->dwX  |= Data[GAME_X0_X7_BYTE] & GAME_X0_X7_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y8_Y9_BYTE] & GAME_Y8_Y9_BITS;
	Report->dwY <<= 8;
	Report->dwY  |= Data[GAME_Y0_Y7_BYTE] & GAME_Y0_Y7_BITS;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T0_T5_BYTE] & GAME_T0_T5_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B0_B5_BYTE] & GAME_B0_B5_BITS) >> 2;
	B2 = (~Data[GAME_B6_B7_BYTE] & GAME_B6_B7_BITS) >> 2;
	B3 = (~Data[GAME_B8_B9_BYTE] & GAME_B8_B9_BITS) >> 6;
	//	Swap Buttons 8 and 9
	B3 = ((B3&1)<<1)|((B3&2)>>1);
	B4 = (~Data[GAME_B10_BYTE] & GAME_B10_BITS);

	Report->dwButtons = (B1 | B2<<6 | B3<<8 | B4<<10) & ((1L << GAME_PACKET_BUTTONS) - 1);

	//
	//	Fix parity problem with consecutive buttons
	//

	if (Report->dwButtons != PreviousButtons)
		PreviousButtons = Report->dwButtons;
	else LastGoodButtons = Report->dwButtons;
	Report->dwButtons = LastGoodButtons;

	//
	//	Convert button states to number
	//

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>4];
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ProcessDataError enter\n"));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > GAME_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ProcessDataError - average error = %ld\n", Average));
		SW3DTILT_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < GAME_SPEED_125K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ProcessDataError - average error = %ld\n", Average));
		SW3DTILT_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DTILT: SW3DTILT_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Read and convert registry timing values
	//

  	SW3DTILT_Calibrate (PortInfo);

	//
	// SW3DTILT Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ConnectDevice - resetting device\n"));
		SW3DTILT_ResetDevice (&DataInfo.PortInfo);

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 3. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT: DeviceConnectProc getting ID string\n"));

		if (!SW3DTILT_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 5. Copy mode from SW3DTILT_GetId result
		//

		DataInfo.Mode = IdInfo.Mode;

		//
		// 6. Set speed to 125k for starters
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT: DeviceConnectProc setting device speed\n"));
		SW3DTILT_SetDeviceSpeed (&DataInfo.PortInfo, GAME_SPEED_125K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		TiltInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	TiltInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DTILT_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DTILT_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SW3DTILT_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadReport - invalid packet\n"));
		SW3DTILT_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DTILT_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DTILT_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DTILT_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dpro2.c ===
//**************************************************************************
//
//		SW3DPRO2.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DPRO2.C | Gameport mini-driver for Sidewinder Pro 2
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DPRO2"
#define	DEVICE_PID					0x0017
#define	HARDWARE_ID					L"Gameport\\SideWinderPrecisionPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		(9+1)
#define	GAME_PACKET_AXIS			4

#define	GAME_B0_B7_BYTE			0					// Packet[0] bits
#define	GAME_B0_B7_BITS			0xff

#define	GAME_B8_BYTE				1					// Packet[1] bits
#define	GAME_B8_BITS				0x01
#define	GAME_X0_X6_BYTE			1
#define	GAME_X0_X6_BITS			0xfe

#define	GAME_X7_X9_BYTE			2					// Packet[2] bits
#define	GAME_X7_X9_BITS			0x07
#define	GAME_Y0_Y4_BYTE			2
#define	GAME_Y0_Y4_BITS			0xf8

#define	GAME_Y5_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y5_Y9_BITS			0x1f
#define	GAME_T0_T2_BYTE			3
#define	GAME_T0_T2_BITS			0xe0

#define	GAME_T3_T6_BYTE			4					// Packet[4] bits
#define	GAME_T3_T6_BITS			0x0f
#define	GAME_R0_R3_BYTE			4
#define	GAME_R0_R3_BITS			0xf0

#define	GAME_R4_R5_BYTE			5					// Packet[5] bits
#define	GAME_R4_R5_BITS			0x3
#define	GAME_H0_H3_BYTE			5
#define	GAME_H0_H3_BITS			0x3c
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x40
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x80

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x8000

//
//	ID Constants
//

#define	GAME_ID_LOW					8
#define	GAME_ID_HIGH				0
#define	GAME_ID_CLOCKS				32

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x7f
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DPRO2_ID | Sidwinder Pro2 Id String
#pragma pack(1)
	UCHAR		Status;					// @field Device status byte
	UCHAR		IdLow;					// @field Device identifier (low byte)
	UCHAR		IdHigh;					// @field Device identifier (high byte)
	USHORT	Version;					// @field Firmware version
#pragma pack()
}	SW3DPRO2_ID, *PSW3DPRO2_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DPRO2_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO2_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO2_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DPRO2_GetId (PPACKETINFO IdPacket);

static	LONG		SW3DPRO2_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO2_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SW3DPRO2_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_ValidateData (PUCHAR Packet);
static	VOID		SW3DPRO2_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DPRO2_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DPRO2_DriverEntry (VOID);
static	NTSTATUS	SW3DPRO2_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO2_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO2_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DPRO2_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DPRO2_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	// dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (127)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (127)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	// dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	// dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{
							0,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SW3DPRO2_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DPRO2_DriverEntry,		// DriverEntry
							SW3DPRO2_ConnectDevice,		// ConnectDevice
							SW3DPRO2_StartDevice,		//	StartDevice
							SW3DPRO2_ReadReport,			// ReadReport
							SW3DPRO2_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//

static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{
							GAME_B0_B7_BITS,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS|GAME_B8_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	JunoInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO2: SW3DPRO2_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode  = IdInfo.Mode  = IMODE_DIGITAL_STD;
	DataInfo.Speed = IdInfo.Speed = GAME_SPEED_66K;

	if (PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, IdInfo.ClockDutyCycle, 1))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop

		; ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 3
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@LowClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@HighClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN			Result;
	PSW3DPRO2_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DPRO2_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DPRO2_ID)IdPacket->Data;
		if ((Pnp->IdLow == GAME_ID_LOW) && (Pnp->IdHigh == GAME_ID_HIGH) && ((Pnp->Status&0x7F) == 0))
			{
			//
			// Do AZTECH test here
			//
			if(IdPacket->B4Transitions >= 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DPRO2_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DPRO2_GetId - 1 Wide Only type card detected\n"));
				SW3DPRO2_ResetDevice (&IdPacket->PortInfo);
				TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_GetId - Id did not match or status error = %ld\n", (ULONG)(Pnp->Status&0x7F)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DPRO2_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_DecrementDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	ebx, 8						; BL = no of clocks to receive.
			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Data						; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockRise				; N: jump

		;DD_ClockFall:

			mov	ecx, DataInfo.HighLowTimeout

		DD_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		DD_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	DD_Complete					; Time out error.

		DD_ClockRise:

			mov	ecx, DataInfo.LowHighTimeout

		DD_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	DD_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	DD_Complete					; Time out error.

		DD_Data:

			shr	al, 6							; put data into carry
			rcr	ah, 1							; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	DD_ClockCheck				; if != 0 then loop

		;DD_Success:

			xchg	al, ah
			dec	al								; decrement returned speed
			and	eax, GAME_SPEED_BITS

			cmp	eax, GAME_SPEED_RANGE
			jb		DD_Complete
			dec	al

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "SW3DPRO2_DecrementDevice - SUCCEEDED, Speed=%ld\n", Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_SetDeviceSpeed enter\n"));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < GAME_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SW3DPRO2_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice failed on %ld attempt\n", (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "SW3DPRO2_SetDeviceSpeed failed after %ld attempts\n", (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi


			lea	edx, DataInfo.PortInfo	; load gameport adddress

			mov	esi, DataInfo.Data
			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		Std_ClockStartState_1
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_ClockStartState_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	CollectData					; Y: jump
			loop	Std_ClockStartState_1	; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		;Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 16						; set bit counter = 32+16=48.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 48;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (16-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			lea	edx, DataInfo.PortInfo		; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 16
			mov	word ptr [esi+4], di
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DPRO2_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DPRO2_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ValidateData (PUCHAR RawData)
{
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ValidateData enter\n"));

	if (RawData[GAME_ERR_BYTE] & GAME_ERR_BITS)
		Result = ERROR_ERRORBITS;
	else if (!DEVICE_IsOddParity (RawData, GAME_PACKET_SIZE))
		Result = ERROR_PARITYBITS;
	else Result = ERROR_SUCCESS;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_ERRORBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ValidateData - Error bits non-zero\n"));
			break;

		case	ERROR_PARITYBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ValidateData - Parity bits failed\n"));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 7;
	Report->dwX  |= (Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS) >> 1;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y5_Y9_BYTE] & GAME_Y5_Y9_BITS;
	Report->dwY <<= 5;
	Report->dwY  |= (Data[GAME_Y0_Y4_BYTE] & GAME_Y0_Y4_BITS) >> 3;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R4_R5_BYTE] & GAME_R4_R5_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= (Data[GAME_R0_R3_BYTE] & GAME_R0_R3_BITS) >> 4;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T3_T6_BYTE] & GAME_T3_T6_BITS;
	Report->dwZ <<= 3;
	Report->dwZ  |= (Data[GAME_T0_T2_BYTE] & GAME_T0_T2_BITS) >> 5;

	//
	//	Process Buttons
	//

	B1 = ~Data[GAME_B0_B7_BYTE] & GAME_B0_B7_BITS;
	B2 = ~Data[GAME_B8_BYTE] & GAME_B8_BITS;
	B2 <<= 9;	// Move button nine to ten (shift key)
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>2];
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ProcessDataError enter\n"));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > GAME_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ProcessDataError - average error = %ld\n", Average));
		SW3DPRO2_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < GAME_SPEED_125K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ProcessDataError - average error = %ld\n", Average));
		SW3DPRO2_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO2: SW3DPRO2_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Read and convert registry timing values
	//

  	SW3DPRO2_Calibrate (PortInfo);

	//
	// SW3DPRO2 Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ConnectDevice - resetting device\n"));
		SW3DPRO2_ResetDevice (&DataInfo.PortInfo);

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 3. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2: DeviceConnectProc getting ID string\n"));

		if (!SW3DPRO2_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 5. Copy mode from SW3DPRO2_GetId result
		//

		DataInfo.Mode = IdInfo.Mode;

		//
		// 6. Set speed to 125k for starters
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2: DeviceConnectProc setting device speed\n"));
		SW3DPRO2_SetDeviceSpeed (&DataInfo.PortInfo, GAME_SPEED_125K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		JunoInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	JunoInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DPRO2_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DPRO2_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SW3DPRO2_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadReport - Invalid packet\n"));
		SW3DPRO2_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DPRO2_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO2_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO2_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dpro.c ===
//**************************************************************************
//
//		SW3DPRO.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DPRO.C | Gameport mini-driver for Sidewinder Pro
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DPRO"
#define	DEVICE_PID					0x0f1f
#define	HARDWARE_ID					L"Gameport\\SideWinder3DPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			8
#define	GAME_PACKET_BUTTONS		8
#define	GAME_PACKET_AXIS			4

#define	GAME_PHASE_BYTE			0						// Packet[0] bits
#define	GAME_PHASE_BIT				0x80
#define	GAME_H3_BYTE				0
#define	GAME_H3_BITS				0x40
#define	GAME_X7_X9_BYTE			0
#define	GAME_X7_X9_BITS			0x38
#define	GAME_Y7_Y9_BYTE			0
#define	GAME_Y7_Y9_BITS			0x07

#define	GAME_B0_B6_BYTE			1						// Packet[1] bits
#define	GAME_B0_B6_BITS			0x7f

#define	GAME_X0_X6_BYTE			2						// Packet[2] bits
#define	GAME_X0_X6_BITS			0x7f

#define	GAME_Y0_Y6_BYTE			3						// Packet[3] bits
#define	GAME_Y0_Y6_BITS			0x7f

#define	GAME_B7_BYTE				4						// Packet[4] bits
#define	GAME_B7_BITS				0x40
#define	TM_MODE_BYTE				4
#define	TM_MODE_BITS				0x20
#define	GAME_R7_R8_BYTE			4
#define	GAME_R7_R8_BITS			0x18
#define	GAME_T7_T9_BYTE			4
#define	GAME_T7_T9_BITS			0x07

#define	GAME_R0_R6_BYTE			5						// Packet[5] bits
#define	GAME_R0_R6_BITS			0x7f

#define	GAME_T0_T6_BYTE			6						// Packet[6] bits
#define	GAME_T0_T6_BITS			0x7f

#define	GAME_H0_H2_BYTE			7						// Packet[7] bits
#define	GAME_H0_H2_BITS			0x70
#define	GAME_C0_C3_BYTE			7
#define	GAME_C0_C3_BITS			0x0f

#define	ENH_CLOCK_MIDPACKET		0x00000400
#define	ENH_CLOCK_COMPLETE		0x00200000

//
//	Id Definitions
//

#define	GAME_ID_CLOCKS				32
#define	GAME_ID_STRING				"(\1\x24P"

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	 75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	PACKET_INTERRUPT_DELAY	 30
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		 75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		 50

#define	GODIGITAL_ATTEMPTS		10
#define	RECALIBRATE_FAIL_COUNT	(GODIGITAL_ATTEMPTS/2)

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0xff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0xff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0xff
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DPRO_ID | Sidwinder Pro Id String
#pragma pack(1)
	UCHAR		EnumId[3];				// @field Enumerated Id
	UCHAR		EisaId[8];				// @field Eisa bus Id
	UCHAR		Devices;					// @field Number of devices
	USHORT	Version[7];				// @field Firmware version
	UCHAR		EndOfStr;				// @field ID string terminator
#pragma pack()
}	SW3DPRO_ID, *PSW3DPRO_ID;

//---------------------------------------------------------------------------
//	Macros	
//---------------------------------------------------------------------------

#define	LOW_NIBBLE(c)		((c)&GAME_C0_C3_BITS)
#define	HIGH_NIBBLE(c)		(((c)&(GAME_C0_C3_BITS<<4))>>4)

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DPRO_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO_GoDigital (PPACKETINFO IdPacket, ULONG Sequence[]);
static	LONG		SW3DPRO_InterruptPacket (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DPRO_GetId (PPACKETINFO IdPacket);

static	NTSTATUS	SW3DPRO_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_ValidateData (PUCHAR Packet);
static	VOID		SW3DPRO_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DPRO_DriverEntry (VOID);
static	NTSTATUS	SW3DPRO_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DPRO_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DPRO_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x01, 0x00, 0x00,			//	LOGICAL_MAXIMUM (511)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x01, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (511)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9f, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	//dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x08,									//	USAGE_MAXIMUM (Button 8)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{	// no buttons; x, y, t and r centered
							GAME_PHASE_BIT|((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|((GAME_Y7_Y9_BITS>>1)&GAME_Y7_Y9_BITS),
							GAME_B0_B6_BITS,
							GAME_X0_X6_BITS,
							GAME_Y0_Y6_BITS,
							((GAME_R7_R8_BITS>>1)&GAME_R7_R8_BITS)|((GAME_T7_T9_BITS>>1)&GAME_T7_T9_BITS)|GAME_B7_BITS,
							GAME_R0_R6_BITS,
							GAME_T0_T6_BITS,
							0
							};
//
//	Raw Id Buffer
//

static	SW3DPRO_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							PACKET_INTERRUPT_DELAY,
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DPRO_DriverEntry,			// DriverEntry
							SW3DPRO_ConnectDevice,		// ConnectDevice
							SW3DPRO_StartDevice,			//	StartDevice
							SW3DPRO_ReadReport,			// ReadReport
							SW3DPRO_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE] =
							{	// no buttons; x, y, t and r centered
							GAME_PHASE_BIT|((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|((GAME_Y7_Y9_BITS>>1)&GAME_Y7_Y9_BITS),
							GAME_B0_B6_BITS,
							GAME_X0_X6_BITS,
							GAME_Y0_Y6_BITS,
							((GAME_R7_R8_BITS>>1)&GAME_R7_R8_BITS)|((GAME_T7_T9_BITS>>1)&GAME_T7_T9_BITS)|GAME_B7_BITS,
							GAME_R0_R6_BITS,
							GAME_T0_T6_BITS,
							0
							};

//
//	Go Digital Timing Data
//

static	ULONG 		GoDigitalFastTiming[] =
							{
							T1+60,
							T2+60,
							T3+60
							};

static	ULONG 		GoDigitalMediumTiming[] =
							{
							T1,
							T2,
							T3
							};

static	ULONG 		GoDigitalSlowTiming[] =
							{
							T1-20,
							T2-20,
							T3-20
							};

static	ULONG			GoDigitalFails = 0;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	MidasInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							TRUE,								// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO: SW3DPRO_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	DataInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.InterruptDelay = %ld\n", DataInfo.InterruptDelay));
	IdInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.InterruptDelay = %ld\n", IdInfo.InterruptDelay));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ResetDevice (PGAMEPORT PortInfo)
{
	LONG	Result;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode = IdInfo.Mode = IMODE_ANALOG;

	PORTIO_Write (PortInfo, 0);
	Result = SW3DPRO_InterruptPacket (PortInfo);
	if (Result == ERROR_SUCCESS)
		Result = SW3DPRO_InterruptPacket (PortInfo);

	if (Result != ERROR_SUCCESS)
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ResetDevice - InterruptPacket failed\n"));

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Interrupts device during packet transfer
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Internal result
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DPRO_InterruptPacket (PGAMEPORT PortInfo)
{
	LONG	Clks;
	LONG	Result;

	__asm
		{
			push	edi
			push	esi

			lea	edx, IdInfo.PortInfo		; load gameport adddress

			mov	ebx, 64						; Standard Mode = 64 clks.

		Int_CheckState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 0 ?
			jz		Int_ClockRise				; Y: jump

		;Int_ClockFall:

			mov	ecx, TIMEOUT

		Int_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Int_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Int_ClockFall_1			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	IntPacketComplete			; Time out error.

		Int_ClockRise:

			mov	ecx, TIMEOUT

		Int_ClockRise_1:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz 	Int_Transition				; Y: jump. (transition)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec 	ecx
			jnz 	Int_ClockRise_1			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	IntPacketComplete			; Time out error.

		Int_Transition:

			cmp	bl, 14						; Q: 14 clocks left ?
			jne	Int_Transition_1			; N: jump.

			push	0								; write byte to gameport
			push	edx
			call	PORTIO_Write

		Int_Transition_1:

			dec	bl
			jnz	Int_CheckState

			mov eax, ERROR_SUCCESS

		IntPacketComplete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_InterruptPacket - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_InterruptPacket - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;
		}
	#endif

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Puts device into digital mode
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_GoDigital (PPACKETINFO IdPacket, ULONG Sequence[])
{
	LONG			i;
	ULONG			ThreeMilliSecs;
	ULONG			GoDigitalTiming[3];
	LONG			Result 		=	ERROR_SUCCESS;
	ULONG			Attempts		=	MAX_CONNECT_ATTEMPTS;
	PGAMEPORT	PortInfo 	= &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_GoDigital enter\n"));
   
	do
		{
		for (i = 0; i < 3; i++)
			GoDigitalTiming[i] = TIMER_GetDelay (Sequence[i]);
		ThreeMilliSecs = TIMER_GetDelay (THREE_MILLI_SECS);

		if (GoDigitalFails > RECALIBRATE_FAIL_COUNT)
			TIMER_Calibrate ();

		if (!PORTIO_AcquirePort (PortInfo))
			continue;
		PORTIO_MaskInterrupts ();

		PORTIO_Write (PortInfo, 0);

		__asm
			{
				push	edi
				push	esi

				mov	edx, PortInfo				; load gameport adddress

				mov	ecx, MAX_XA_TIMEOUT
				xor	ebx, ebx

			WaitXA:
			
				push	edx							; read byte from gameport
				call	PORTIO_Read

				test	al, INTXA_BIT_MASK		; Q: X axis low ?
				jz		XA_Done						; Y: jump. (complete)
				xor	bh, al						; Q: Clock transition ?
				test	bh, CLOCK_BIT_MASK
				jz		WaitXA_1						; N: jump.
				inc	bl								; inc. clock transition count.

			WaitXA_1:
			
				mov	bh, al
				dec	ecx
				jnz	WaitXA

				jmp	DigitalSwitchFail

			XA_Done:

				cmp	bl, 3							; Q: Already in Digital mode ?
				ja		DigitalSwitchDone			; Y: jump.

				xor	edi, edi
				mov	esi, edx

			DigitalSwitchLoop:

				push	GoDigitalTiming[edi]
				add	edi, 4						; inc loop counter & index
				call	TIMER_DelayMicroSecs
				mov	edx, esi

				push	0								; write byte to gameport
				push	edx
				call	PORTIO_Write

				push	edx
				call	PORTIO_WaitXA_HighLow	; Wait for XA to transition

				or		al, al
				je		DigitalSwitchFail			; if Timeout then fail.
				cmp	edi, 12
				jl		DigitalSwitchLoop
				push	ThreeMilliSecs
				call	TIMER_DelayMicroSecs		; Delay so Firmware can update
				jmp	DigitalSwitchDone

			DigitalSwitchFail:

				mov	Result, ERROR_XA_TIMEOUT

			DigitalSwitchDone:

				pop	esi
				pop	edi
			}

		IdPacket->TimeStamp		= TIMER_GetTickCount ();
		IdPacket->LastError		= Result;
		IdPacket->Transaction	= MSGAME_TRANSACT_GODIGITAL;

		PORTIO_UnMaskInterrupts ();
		PORTIO_ReleasePort (PortInfo);

		if (Result == ERROR_SUCCESS)
			{
			GoDigitalFails = 0;
			break;
			}
		else GoDigitalFails++;

		if (Result == ERROR_XA_TIMEOUT)
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_GoDigital - TimeOut@XAHighLow\n"));

		}	while(--Attempts);

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);
	Result = SW3DPRO_InterruptPacket (PortInfo);
	if (Result != ERROR_SUCCESS)
		goto ReadIdExit;

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = no of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop

		; ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 4
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN	Result;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DPRO_ReadId (IdPacket);

	if (Result)
		{
      if (!strncmp (IdPacket->Data, GAME_ID_STRING, strlen(GAME_ID_STRING)))
			{
			//
			// Do AZTECH test here
			//
			if (IdPacket->B4Transitions > 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DPRO_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DPRO_GetId - 1 Wide Only type card detected\n"));
				SW3DPRO_ResetDevice (&IdPacket->PortInfo);
				SW3DPRO_GoDigital (IdPacket, GoDigitalMediumTiming);
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_GetId - Id string did not match = 0x%X\n", (ULONG)(*(PULONG)IdPacket->Data)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC+200));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	esi, DataInfo.Data

			lea	edx, DataInfo.PortInfo	; load gameport adddress

			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	Std_ClockStartFall
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out

			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 32						; set bit counter = 32+32=64.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 64;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (32-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	esi, DataInfo.Data

			lea	edx, DataInfo.PortInfo	; load gameport adddress

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout
			mov	ebx, 1

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_ClockStartFall			; Y: jump
			loop	Enh_ClockStartState			; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al, CLOCK_BIT_MASK			; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 1						; shift data into edi.
			mov	[esi+4], edi
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++)
		;
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DPRO_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DPRO_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ValidateData (PUCHAR RawData)
{
	LONG		i			= 0;
	LONG		Check		= 0;
	PULONG	Phase		= (PULONG)RawData;
	LONG		Result	= ERROR_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ValidateData enter\n"));

	if (((*Phase & 0x80808080L) != 0x80L) || (*(Phase+1) & 0x80808080L))
		{
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ValidateData - Phase bits non-zero: %X:%X\n", *(Phase+1), *Phase));
		Result = ERROR_PHASEBITS;
		}
	else
		{
		for (i = 0; i < GAME_PACKET_SIZE; i++)
			{
			Check += LOW_NIBBLE(RawData[i]);
			Check += HIGH_NIBBLE(RawData[i]);
			}
		if (LOW_NIBBLE(Check))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ValidateData - Checksum failed: %X:%X\n", *(Phase+1), *Phase));
			Result = ERROR_CHECKSUM;
			}
		}

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 4;
	Report->dwX  |= Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y7_Y9_BYTE] & GAME_Y7_Y9_BITS;
	Report->dwY <<= 7;
	Report->dwY  |= Data[GAME_Y0_Y6_BYTE] & GAME_Y0_Y6_BITS;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R7_R8_BYTE] & GAME_R7_R8_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= Data[GAME_R0_R6_BYTE] & GAME_R0_R6_BITS;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T7_T9_BYTE] & GAME_T7_T9_BITS;
	Report->dwZ <<= 7;
	Report->dwZ  |= Data[GAME_T0_T6_BYTE] & GAME_T0_T6_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B7_BYTE] & GAME_B7_BITS) << 1;
	B2 = ~Data[GAME_B0_B6_BYTE] & GAME_B0_B6_BITS;
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV	= (Data[GAME_H0_H2_BYTE] & GAME_H0_H2_BITS)>>4;
	Report->dwPOV |= (Data[GAME_H3_BYTE] & GAME_H3_BITS)>>3;
	Report->dwPOV  = POV_Values[Report->dwPOV];
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO: SW3DPRO_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SW3DPRO_Calibrate (PortInfo);

	//
	// SW3DPRO Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - resetting device\n"));
		SW3DPRO_ResetDevice (&DataInfo.PortInfo);
		DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_STD;

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		//	3. Put into digital mode
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - going digital\n"));
		SW3DPRO_GoDigital (&DataInfo, GoDigitalMediumTiming);

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC+500));

		//
		// 5. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - getting ID string\n"));

		if (!SW3DPRO_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
      // 6. Mark device found and return
		//

		MidasInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	MidasInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{

		MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DPRO_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DPRO_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadReport - Invalid packet\n"));
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DPRO_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO_StopDevice enter\n"));

	if (TouchHardware)
		SW3DPRO_ResetDevice (PortInfo);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\timer.c ===
//**************************************************************************
//
//		TIMER.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	TIMER.C | Timing routines to support device input/output
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//		Definitions
//---------------------------------------------------------------------------

#define	MILLI_SECONDS				1000L
#define	MICRO_SECONDS				1000000L
#define	TIMER_RESOLUTION			25L
#define	TIMER_CALIBRATE_TRIES	4L
#define	TIMER_CALIBRATE_TIMER	25000L
#define	TIMER_CALIBRATE_PORT		 2500L

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	ULONG		PerformanceFrequency = 	0L;
static	ULONG		CalibratedResolution	=	0L;

//---------------------------------------------------------------------------
// @func		Converts system ticks into microseconds
//	@parm		ULONG	| Ticks | System ticks in system time
// @rdesc	Returns time in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_TimeInMicroseconds (ULONG	Ticks)
{
	ULONG				Remainder;
	LARGE_INTEGER	Microseconds;

	Microseconds = RtlEnlargedUnsignedMultiply (Ticks, MICRO_SECONDS);
	Microseconds = RtlExtendedLargeIntegerDivide (Microseconds, PerformanceFrequency, &Remainder);
	return (Microseconds.LowPart);
}

//---------------------------------------------------------------------------
// @func		Times a fixed delay loop of instructions
// @rdesc	Returns delay in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_CalibrateOnTimer (VOID)
{
	ULONG				Calibration;
	LARGE_INTEGER	StopTicks;
	LARGE_INTEGER	StartTicks;
		
	PORTIO_MaskInterrupts ();
	StartTicks	= KeQueryPerformanceCounter (NULL);
	
	__asm
		{
		mov	ecx, TIMER_CALIBRATE_TIMER
		CalibrationLoop:
		xchg	al, ah
		xchg	al, ah
		dec	ecx
		jne	CalibrationLoop
		}
	StopTicks = KeQueryPerformanceCounter (NULL);
	PORTIO_UnMaskInterrupts ();

	Calibration = TIMER_TimeInMicroseconds (StopTicks.LowPart-StartTicks.LowPart);

	MsGamePrint ((DBG_VERBOSE, "TIMER: TIMER_CalibrateOnTimer Returning %ld uSecs\n", Calibration));
	return (Calibration);
}

//---------------------------------------------------------------------------
// @func		Times a fixed delay loop of port I/O calls
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns delay in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_CalibrateOnPort (PGAMEPORT PortInfo)
{
	ULONG				Calibration;
	LARGE_INTEGER	StopTicks;
	LARGE_INTEGER	StartTicks;
	
	if (!PORTIO_AcquirePort (PortInfo))
		{
		MsGamePrint ((DBG_SEVERE, "TIMER: TIMER_CalibrateOnPort Could Not Acquire Port\n"));
		return (0);
		}

	PORTIO_MaskInterrupts ();
	StartTicks	= KeQueryPerformanceCounter (NULL);
	
	__asm
		{
		mov	ecx, TIMER_CALIBRATE_PORT
		mov	edx, PortInfo

		CalibrationLoop:

		push	edx
		call	PORTIO_Read

		test	al, al
		dec	ecx
		jne	CalibrationLoop
		}
	StopTicks = KeQueryPerformanceCounter (NULL);
	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	Calibration = TIMER_TimeInMicroseconds (StopTicks.LowPart-StartTicks.LowPart);

	MsGamePrint ((DBG_VERBOSE, "TIMER: TIMER_CalibrateOnPort Returning %ld uSecs\n", Calibration));
	return (Calibration);
}

//---------------------------------------------------------------------------
// @func		Retrieves current system time in milliseconds
// @rdesc	Returns current system time in milliseconds
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_GetTickCount (VOID)
{
	ULONG				Remainder;
	LARGE_INTEGER	TickCount;

	TickCount = KeQueryPerformanceCounter (NULL);
	TickCount = RtlExtendedIntegerMultiply (TickCount, MILLI_SECONDS);
	TickCount = RtlExtendedLargeIntegerDivide (TickCount, PerformanceFrequency, &Remainder);
	return (TickCount.LowPart);
}

//---------------------------------------------------------------------------
// @func		Calibrates the system processor speed for timing delays
// @rdesc	Returns NT status code (Success always)
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	TIMER_Calibrate (VOID)
{
	ULONG				Tries;
	ULONG				Rounding;
	ULONG				Accumulator;
	LARGE_INTEGER	Frequency;

	KeQueryPerformanceCounter (&Frequency);
	PerformanceFrequency = Frequency.LowPart;
	MsGamePrint ((DBG_VERBOSE, "TIMER: PerformanceFrequency is %ld hz\n", PerformanceFrequency));

	for (Accumulator = 0, Tries = 0; Tries < TIMER_CALIBRATE_TRIES; Tries++)
		Accumulator += TIMER_CalibrateOnTimer ();

	Rounding		= (Accumulator % TIMER_CALIBRATE_TRIES) >= (TIMER_CALIBRATE_TRIES/2) ? 1 : 0;
	Accumulator	= (Accumulator / TIMER_CALIBRATE_TRIES) + Rounding;
	MsGamePrint ((DBG_VERBOSE, "TIMER: Average Timer Calibration is %ld usecs\n", Accumulator));

	Rounding					= ((TIMER_RESOLUTION*TIMER_CALIBRATE_TIMER)/Accumulator) >= (Accumulator/2) ? 1 : 0;
	CalibratedResolution	= ((TIMER_RESOLUTION*TIMER_CALIBRATE_TIMER)/Accumulator) + Rounding;

	MsGamePrint ((DBG_VERBOSE, "TIMER: Calibrated Timer Resolution on %lu msecs is %ld loops\n", TIMER_RESOLUTION, CalibratedResolution));

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Calibrates delays for the system processor speed during port access
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Microseconds | Delay in microseconds to calibrate
// @rdesc	Returns delay in counts for microseconds during port access
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_CalibratePort (PGAMEPORT PortInfo, ULONG Microseconds)
{
	ULONG				Tries;
	ULONG				Errors;
	ULONG				Calibration;
	ULONG				Rounding;
	ULONG				Accumulator;
	LARGE_INTEGER	Frequency;

	KeQueryPerformanceCounter (&Frequency);
	PerformanceFrequency = Frequency.LowPart;
	MsGamePrint ((DBG_VERBOSE, "TIMER: PerformanceFrequency is %ld hz\n", PerformanceFrequency));

	for (Accumulator = 0, Tries = 0, Errors = 0; Tries < TIMER_CALIBRATE_TRIES; Tries++)
		{
		Calibration = TIMER_CalibrateOnPort (PortInfo);
		if (!Calibration)
			Errors++;
		else Accumulator += Calibration;
		}

	Tries -= Errors;

	if (Tries)
		{
		Rounding		= (Accumulator % Tries) >= (Tries/2) ? 1 : 0;
		Accumulator	= (Accumulator / Tries) + Rounding;
		MsGamePrint ((DBG_VERBOSE, "TIMER: Average Port Calibration is %ld usecs\n", Accumulator));

		Rounding		= ((Microseconds*TIMER_CALIBRATE_PORT)/Accumulator) >= (CalibratedResolution/2) ? 1 : 0;
		Accumulator = ((Microseconds*TIMER_CALIBRATE_PORT)/Accumulator) + Rounding;
		MsGamePrint ((DBG_VERBOSE, "TIMER: Calibrated Port Resolution on %lu msecs is %ld loops\n", Microseconds, Accumulator));
		}
	else Accumulator++;

	return (Accumulator);
}

//---------------------------------------------------------------------------
// @func		Convert delays in microseconds to loop counts based on the system processor speed
//	@parm		ULONG | Microseconds | Delay in microseconds to calibrate
// @rdesc	Returns delay in loop counts
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_GetDelay (ULONG Microseconds)
{
	ULONG	Delay;
	ULONG	Rounding;

	Rounding	= ((Microseconds*CalibratedResolution)%TIMER_RESOLUTION)>(TIMER_RESOLUTION/2) ? 1 : 0;
	Delay		= ((Microseconds*CalibratedResolution)/TIMER_RESOLUTION) + Rounding;
	return (Delay?Delay:1);
}

//---------------------------------------------------------------------------
// @func		Delays in loop counts based on the system processor speed
//	@parm		ULONG | Delay | Calibrated delay in loop counts
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	TIMER_DelayMicroSecs (ULONG Delay)
{
	__asm
		{
		mov	ecx, Delay
		DelayLoop:
		xchg	al, ah
		xchg	al, ah
		dec	ecx
		jne	DelayLoop
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\swledzep.c ===
//**************************************************************************
//
//		SWLEDZEP.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SWLEDZEP.C | Gameport mini-driver for Sidewinder LedZep Force Feedback
//**************************************************************************

#include	"msgame.h"
#include	"swforce.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#ifdef	SAITEK
#define	DEVICENAME					"SAIWHEEL"
#define	DEVICE_PID					0x0016
#define	HARDWARE_ID					L"Gameport\\SaiTekForceFeedbackWheel\0\0"
#else
#define	DEVICENAME					"SWLEDZEP"
#define	DEVICE_PID					0x0015
#define	HARDWARE_ID					L"Gameport\\SideWinderForceFeedbackWheel\0\0"
#endif

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			5
#define	GAME_PACKET_BUTTONS		8
#define	GAME_PACKET_AXIS			4

#define	GAME_X0_X7_BYTE			0					// Packet[0] bits
#define	GAME_X0_X7_BITS			0xff

#define	GAME_X8_X9_BYTE			1					// Packet[1] bits
#define	GAME_X8_X9_BITS			0x03
#define	GAME_YA0_YA5_BYTE			1
#define	GAME_YA0_YA5_BITS			0xfc

#define	GAME_YB0_YB5_BYTE			2					// Packet[2] bits
#define	GAME_YB0_YB5_BITS			0x3f
#define	GAME_B0_B1_BYTE			2
#define	GAME_B0_B1_BITS			0xc0

#define	GAME_B2_B8_BYTE			3					// Packet[3] bits
#define	GAME_B2_B8_BITS			0x7f
#define	GAME_ERR_BYTE				3
#define	GAME_ERR_BITS				0x80

#define	GAME_PPO_BYTE				4					// Packet[4] bits
#define	GAME_PPO_BITS				0x01

#define	ENH_CLOCK_COMPLETE		0x0400

//
//	ID Constants
//

#define	GAME_ID_CLOCKS				8

//
//	Status Constants
//

#define	STATUS_CLOCK_COMPLETE	0x0040

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50
#define	STATUS_START_TIMEOUT		500
#define	STATUS_LOWHIGH_TIMEOUT	75
#define	STATUS_HIGHLOW_TIMEOUT	150
#define	STATUS_GATE_TIMEOUT		3000

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_YA_MIN				0
#define	EXTENTS_YA_MAX				0x3f
#define	EXTENTS_YB_MIN				0
#define	EXTENTS_YB_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{
#pragma pack(1)
	ULONG		ProductId:12;			// @field Device identifier
	ULONG		Version:11;				// @field Firmware version
	ULONG		OddParityBit:1;		// @field Parity bit (odd)
	ULONG		Unused:8;				// @field unused
#pragma pack()
}	SWLEDZEP_ID, *PSWLEDZEP_ID;

typedef	struct
{											// @struct SWLEDZEP_STATUS | Sidwinder Wheel Status
#pragma pack(1)
	ULONG		Effect:7;				// @field Last effect
	ULONG		Status:13;				// @field Status flags
	ULONG		Parity:1;				// @field Parity bit (odd)
	ULONG		Unused:8;				// @field unused
#pragma pack()
}	SWLEDZEP_STATUS, *PSWLEDZEP_STATUS;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SWLEDZEP_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SWLEDZEP_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SWLEDZEP_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SWLEDZEP_GetId (PPACKETINFO IdPacket);

static	BOOLEAN	SWLEDZEP_ReadStatus (PPACKETINFO StatusPacket);
static	BOOLEAN	SWLEDZEP_GetStatus (PPACKETINFO StatusPacket);

static	NTSTATUS	SWLEDZEP_ReadData (PPACKETINFO DataPacket);
static	VOID		SWLEDZEP_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SWLEDZEP_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

static	LONG		SWLEDZEP_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SWLEDZEP_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SWLEDZEP_ForceReset (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_ForceId (PGAMEPORT PortInfo, PVOID IdString);
static	NTSTATUS	SWLEDZEP_ForceStatus (PGAMEPORT PortInfo, PVOID Status);
static	NTSTATUS	SWLEDZEP_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak);
static	NTSTATUS	SWLEDZEP_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck);
static	NTSTATUS	SWLEDZEP_ForceSync (PGAMEPORT PortInfo, PULONG Sync);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SWLEDZEP_DriverEntry (VOID);
static	NTSTATUS	SWLEDZEP_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SWLEDZEP_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);
static	NTSTATUS	SWLEDZEP_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SWLEDZEP_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

#define	HID_USAGE_VEHICLE_STEERING		((USAGE) 0xC8)
#define	HID_USAGE_VEHICLE_ACCELERATOR	((USAGE) 0xC4)
#define	HID_USAGE_VEHICLE_BRAKE			((USAGE) 0xC5)

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	//---------------------------------------------------------------------------
	// JOYINFOEX
	//---------------------------------------------------------------------------

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	HIDP_REPORT_ID_1,				MSGAME_INPUT_JOYINFOEX,

	//	id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_STEERING,	// USAGE (Steering)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	// dwY
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_ACCELERATOR,//  USAGE (Accelerator)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (16)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwZ
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwR
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_BRAKE,		//  USAGE (Brake)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (16)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwPOV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x09,									//	USAGE_MAXIMUM (Button 9)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//---------------------------------------------------------------------------
	// GetID
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETID,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x00,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwProductID
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x01,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwFWVersion
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x02,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetStatus
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSTATUS,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x03,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwXVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x04,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x05,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwXAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x06,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x07,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwEffect
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x08,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwDeviceStatus
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x09,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetAckNak
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETACKNAK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0A,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	//	GetNakAck
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETNAKACK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0B,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetSync
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSYNC,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0C,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//---------------------------------------------------------------------------
	// DoReset
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_RESET,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0D,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x03,									//	FEATURE (Cnst,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetVersion
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETVERSION,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0E,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	HIDP_MAIN_ENDCOLLECTION												//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{	// no buttons; x, ya, yb centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS)|((GAME_YA0_YA5_BITS>>1)&GAME_YA0_YA5_BITS),
							((GAME_YB0_YB5_BITS>>1)&GAME_YB0_YB5_BITS),
							0,
							GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SWLEDZEP_ID	RawId	=
							{
							0
							};

//
//	Raw Status Buffer
//

static	SWLEDZEP_STATUS	RawStatus =
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							STATUS_START_TIMEOUT,
							STATUS_HIGHLOW_TIMEOUT,
							STATUS_LOWHIGH_TIMEOUT,
							STATUS_GATE_TIMEOUT
							};

static	ULONG			StatusGateTimeout;

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Status Packet Info
//

static	PACKETINFO	StatusInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawStatus),		// Size of raw status buffer
							&RawStatus					// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SWLEDZEP_DriverEntry,		// DriverEntry
							SWLEDZEP_ConnectDevice,  	// ConnectDevice
							SWLEDZEP_StartDevice,	  	//	StartDevice
							SWLEDZEP_ReadReport,			// ReadReport
							SWLEDZEP_StopDevice,			// StopDevice
							SWLEDZEP_GetFeature			// GetFeature
							};

//
//	Last Valid Data
//

static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{	// no buttons; x, ya, yb centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS)|((GAME_YA0_YA5_BITS>>1)&GAME_YA0_YA5_BITS),
							((GAME_YB0_YB5_BITS>>1)&GAME_YB0_YB5_BITS) | GAME_B0_B1_BITS,
							GAME_B2_B8_BITS,
							GAME_PPO_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Reset Flag
//

static	BOOLEAN		ResetComplete = FALSE;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	LedZepInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_FIRST,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"%s: %s_Calibrate Enter\n", DEVICENAME, DEVICENAME));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.StartTimeout = %ld\n", DEVICENAME, DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.LowHighTimeout = %ld\n", DEVICENAME, DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.HighLowTimeout = %ld\n", DEVICENAME, DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.StartTimeout = %ld\n", DEVICENAME, IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.LowHighTimeout=%ld\n", DEVICENAME, IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.HighLowTimeout=%ld\n", DEVICENAME, IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.ClockDutyCycle = %ld\n", DEVICENAME, DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.ClockDutyCycle = %ld\n", DEVICENAME, IdInfo.ClockDutyCycle));
	StatusInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.ClockDutyCycle = %ld\n", DEVICENAME, StatusInfo.ClockDutyCycle));
	StatusInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.StartTimeout = %ld\n", DEVICENAME, StatusInfo.StartTimeout));
	StatusInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.LowHighTimeout=%ld\n", DEVICENAME, StatusInfo.LowHighTimeout));
	StatusInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.HighLowTimeout=%ld\n", DEVICENAME, StatusInfo.HighLowTimeout));
	StatusGateTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusGateTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusGateTimeout=%ld\n", DEVICENAME, StatusGateTimeout));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "%s_ResetDevice enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Speed = IdInfo.Speed = StatusInfo.Speed = WHEEL_SPEED_48K;

	if (PORTIO_PulseAndWaitForIdleHandshake (PortInfo, DataInfo.ClockDutyCycle, 4))
		{
		PORTIO_Write (PortInfo, 0);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "%s_ResetDevice - PulseAndWaitForHandshake failed\n", DEVICENAME));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (!Result)
		MsGamePrint ((DBG_SEVERE, "%s_ResetDevice - PulseAndWaitForIdleHandshake failed\n", DEVICENAME));

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ReadId (PPACKETINFO IdPacket)
{
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "%s_ReadId enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, IdInfo.ClockDutyCycle, 2))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; ebx = no of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:

			mov	ah, al
			shr	al, 5
			shrd	esi, eax,3
			dec	ebx
			jne	ID_ClockCheck
			shr	esi, 8						; only 24 bits

		; ID_Success:

			mov	IdInfo.B4Transitions, edi
			mov	eax, ERROR_SUCCESS
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "%s_ReadId - SUCCEEDED, Data=%ld", DEVICENAME, Data));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@Handshaking\n", DEVICENAME));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@LowClockStart, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@HighClockStart, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@ClockFalling, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@ClockRising, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN		Result;
	PSWLEDZEP_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "%s_GetId enter\n", DEVICENAME));

	IdPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SWLEDZEP_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSWLEDZEP_ID)IdPacket->Data;
		if ((Pnp->ProductId != DEVICE_PID) || !DEVICE_IsOddParity (Pnp, sizeof(SWLEDZEP_ID)))
			{
			MsGamePrint ((DBG_SEVERE, "%s_GetId - Id did not match or parity error\n", DEVICENAME));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ReadData (PPACKETINFO DataPacket)
{
	LONG			Result;
	LONG			Clks		= 1L;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadData enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.
			
			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_COMPLETE		; Q: in end-packet ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_Success:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			shr	al, 2								; move 3rd bit over.
			mov	byte ptr [esi+4], al

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	DataInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or		al, al
			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads
			jne	Enh_Complete

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockHigh

			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->TimeStamp	=	TIMER_GetTickCount ();
	DataPacket->LastError	=	Result;
	DataPacket->Transaction	=	MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@LowClockStart, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@HighClockStart, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_EXTRACLOCKS:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - Extra Clocks, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (DataPacket);

	if (Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "%s_ProcessData enter\n", DEVICENAME));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X8_X9_BYTE] & GAME_X8_X9_BITS;
	Report->dwX <<= 8;
	Report->dwX  |= Data[GAME_X0_X7_BYTE] & GAME_X0_X7_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY = (Data[GAME_YA0_YA5_BYTE] & GAME_YA0_YA5_BITS)>>2;

	//
	//	Process R Axis
	//

	Report->dwR = Data[GAME_YB0_YB5_BYTE] & GAME_YB0_YB5_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B0_B1_BYTE] & GAME_B0_B1_BITS)>>6;
	B2 = (~Data[GAME_B2_B8_BYTE] & GAME_B2_B8_BITS)<<2;
	Report->dwButtons  = (B2 | B1);
	// R,L,C,B,A,Z,Y,X Order
	Report->dwButtons  = (Report->dwButtons & 0x7) | ((Report->dwButtons & 0xf0)>>1) | ((Report->dwButtons & 0x8)<<4);
	Report->dwButtons &= ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SWLEDZEP_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "%s_DecrementDevice enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Success					; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_Success:

			shr	al, 5
			dec	al
			and	eax, WHEEL_SPEED_BITS
			cmp	eax, WHEEL_SPEED_RANGE
			jb		DD_Complete
			dec	al
			and	eax, WHEEL_SPEED_BITS

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@Handshaking\n", DEVICENAME));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "%s_DecrementDevice - SUCCEEDED, Speed=%ld\n", DEVICENAME, Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "%s_SetDeviceSpeed enter\n", DEVICENAME));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < WHEEL_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SWLEDZEP_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice failed on %ld attempt\n", DEVICENAME, (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = StatusInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "%s_SetDeviceSpeed failed after %ld attempts\n", DEVICENAME, (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "%s_ProcessDataError enter\n", DEVICENAME));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > WHEEL_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "%s_ProcessDataError - average error = %ld\n", DEVICENAME, Average));
		SWLEDZEP_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < WHEEL_SPEED_98K))
		{
		MsGamePrint ((DBG_CONTROL, "%s_ProcessDataError - average error = %ld\n", DEVICENAME, Average));
		SWLEDZEP_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Reads and validates device status
//	@parm		PPACKETINFO | StatusPacket | Status Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_GetStatus (PPACKETINFO StatusPacket)
{
	BOOLEAN				Result;
	PSWLEDZEP_STATUS	Status;

	MsGamePrint ((DBG_INFORM, "%s_GetStatus Enter\n", DEVICENAME));

	StatusPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SWLEDZEP_ReadStatus (StatusPacket);

	if (Result)
		{
		Status = (PSWLEDZEP_STATUS)StatusPacket->Data;
		if (!DEVICE_IsOddParity (Status, sizeof(SWLEDZEP_STATUS)))
			{
			MsGamePrint ((DBG_SEVERE, "%s_GetStatus - Parity error\n", DEVICENAME));
			Result = FALSE;
			}
		else MsGamePrint ((DBG_INFORM, "%s_GetStatus - Status = 0x%X\n", DEVICENAME, 	(long)Status->Status));
		}

	if (!Result)
		StatusPacket->Failures++;

	if (PORTIO_IsClockActive (&StatusPacket->PortInfo, StatusInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads status packet from gameport
//	@parm		PPACKETINFO | StatusPacket| Status packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ReadStatus (PPACKETINFO StatusPacket)
{
	ULONG			Status;
	LONG			Clks		=	1L;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &StatusPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadStatus enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	StatusPacket->ClocksSampled = 0;
	StatusPacket->B4Transitions = 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, StatusInfo.ClockDutyCycle, 1))
		goto ReadStatusExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, StatusInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, StatusInfo.StartTimeout

		Stat_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Stat_ClockStartState_1		; N: jump
			loop	Stat_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Stat_CollectData				; Y: jump
			loop	Stat_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Stat_ClockStartRise

		;Stat_ClockStartFall:

			mov	ecx, StatusInfo.HighLowTimeout

		Stat_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Stat_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartRise:

			mov	ecx, StatusInfo.LowHighTimeout

		Stat_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Stat_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Stat_Complete					; Time out error.

		Stat_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, STATUS_CLOCK_COMPLETE	; Q: is packet complete ?
			jnz	Stat_Success					; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

		Stat_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 11
			mov	dword ptr [esi], edi
			mov	Status, edi

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	StatusInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or		al, al
			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads
			jne	Stat_Complete

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockHigh

			mov	eax, ERROR_SUCCESS

		Stat_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadStatusExit:
	//	----------------

	for (StatusPacket->ClocksSampled = 0; Clks >> (StatusPacket->ClocksSampled+1); StatusPacket->ClocksSampled++);
	StatusPacket->TimeStamp 	= TIMER_GetTickCount ();
	StatusPacket->LastError 	= Result;
	StatusPacket->LastError		=	Result;
	StatusPacket->Transaction	=	MSGAME_TRANSACT_STATUS;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_VERBOSE, "%s_ReadStatus - SUCCEEDED, Data=0x%X,Clk=%ld\n", DEVICENAME, (ULONG)Status,Clks));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@LowClockStart\n", DEVICENAME));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@HighClockStart\n", DEVICENAME));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, Clks));
			break;
		}
	#endif

	MSGAME_PostTransaction (StatusPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Force feedback reset service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceReset (PGAMEPORT PortInfo)
{
	if (!SWLEDZEP_ResetDevice (PortInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Id | Id output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceId (PGAMEPORT PortInfo, PVOID Id)
{
	PPRODUCT_ID 	pProduct	= (PPRODUCT_ID)Id;
	PSWLEDZEP_ID	pLedZep	= (PSWLEDZEP_ID)&RawId;

	if (!SWLEDZEP_ReadId (&IdInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pProduct->cBytes			=	sizeof (PRODUCT_ID);
	pProduct->dwProductID	=	pLedZep->ProductId;
	pProduct->dwFWVersion	=	pLedZep->Version;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Status | Status output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceStatus (PGAMEPORT PortInfo, PVOID Status)
{
	PJOYCHANNELSTATUS	pChannel	= (PJOYCHANNELSTATUS)Status;
	PSWLEDZEP_STATUS	pLedZep	= (PSWLEDZEP_STATUS)&RawStatus;

	if (!SWLEDZEP_ReadStatus (&StatusInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pChannel->cBytes				=	sizeof (JOYCHANNELSTATUS);
	pChannel->dwXVel				=	0;
	pChannel->dwYVel				=	0;
	pChannel->dwXAccel			=	0;
	pChannel->dwYAccel			=	0;
	pChannel->dwEffect			=	pLedZep->Effect;
	pChannel->dwDeviceStatus	=	pLedZep->Status;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback acknak service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | AckNak | AckNak
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak)
{
	if (!PORTIO_GetAckNak (PortInfo, StatusGateTimeout, (PUCHAR)AckNak))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback NakAck service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck)
{
	if (!PORTIO_GetNakAck (PortInfo, StatusGateTimeout, (PUCHAR)NakAck))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback sync service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceSync (PGAMEPORT PortInfo, PULONG Sync)
{
	*Sync = PORTIO_Read (PortInfo);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"%s: %s_DriverEntry Enter\n", DEVICENAME, DEVICENAME));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "%s_ConnectDevice enter\n", DEVICENAME));

	DataInfo.PortInfo = IdInfo.PortInfo = StatusInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SWLEDZEP_Calibrate (PortInfo);

	//
	// Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 2. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "%s: DeviceConnectProc getting ID string\n", DEVICENAME));
		if (!SWLEDZEP_GetId (&IdInfo))
			continue;

		//
		// 3. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		
		//
		// 4. Reset device (tri-state midi so we don't get unintended forces)
		//

		if (!ResetComplete)
			{
			MsGamePrint ((DBG_CONTROL, "%s_ConnectDevice - resetting device\n", DEVICENAME));
			if (!SWLEDZEP_ResetDevice (&DataInfo.PortInfo))
				continue;
			}

		//
		// 5. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 6. Set speed to 98K for starters
		//

		MsGamePrint ((DBG_CONTROL, "%s: DeviceConnectProc setting device speed\n", DEVICENAME));
		SWLEDZEP_SetDeviceSpeed (&DataInfo.PortInfo, WHEEL_SPEED_98K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		LedZepInfo.NumDevices	=	1;
		ResetComplete				=	TRUE;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	LedZepInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadReport enter\n", DEVICENAME));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "%s_ReadReport - port collision\n", DEVICENAME));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SWLEDZEP_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && DEVICE_IsOddParity (DataInfo.Data, GAME_PACKET_SIZE))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SWLEDZEP_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "%s_ReadReport - Invalid packet or parity error\n", DEVICENAME));
		SWLEDZEP_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SWLEDZEP_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SWLEDZEP_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "%s_StartDevice enter\n", DEVICENAME));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "%s_StopDevice enter\n", DEVICENAME));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Feature requests
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID Feature Id
//	@parm		PVOID | ReportBuffer | Output buffer pointer
//	@parm		ULONG | ReportSize | Output buffer size
//	@parm		PULONG | Returned | Bytes returned pointer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	NTSTATUS	ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_INFORM, "%s_GetFeature enter\n", DEVICENAME));

	//
	//	Handle feature codes
	//

	switch (ReportId)
		{
		case	MSGAME_INPUT_JOYINFOEX:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature JoyInfoEx\n", DEVICENAME));
			if (ReportSize < sizeof (DEVICE_PACKET)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature JoyInfoEx Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ReadReport (PortInfo, ReportBuffer);
				*Returned += sizeof (DEVICE_PACKET);
				}
			break;

		case	MSGAME_FEATURE_GETID:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetId\n", DEVICENAME));
			if (ReportSize < sizeof(PRODUCT_ID)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetId Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceId (PortInfo, ReportBuffer);
				*Returned += sizeof(PRODUCT_ID);
				}
			break;

		case	MSGAME_FEATURE_GETSTATUS:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetStatus\n", DEVICENAME));
			if	(ReportSize < sizeof(JOYCHANNELSTATUS)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetStatus Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceStatus (PortInfo, ReportBuffer);
				*Returned += sizeof(JOYCHANNELSTATUS);
				}
			break;

		case	MSGAME_FEATURE_GETACKNAK:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetAckNak\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetAckNak Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceAckNak (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETNAKACK:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetNakAck\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetNakAck Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceNakAck (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETSYNC:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetSync\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetSync Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceSync (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_RESET:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature Reset\n", DEVICENAME));
			if	(ReportSize < sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetVersion Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
         else
				{
				ntStatus = SWLEDZEP_ForceReset (PortInfo);
				}
			break;

		case	MSGAME_FEATURE_GETVERSION:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetVersion\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetVersion Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
         else
	         {
            *((PULONG)ReportBuffer)	= 0x20000;
			   *Returned += sizeof(ULONG);
   	      }
         break;

		default:
			MsGamePrint ((DBG_SEVERE, "%s_GetFeature Invalid ReportId = %lu\n", DEVICENAME, ReportId));
			ntStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

	return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\timer.h ===
//**************************************************************************
//
//		TIMER.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	TIMER.H | Global includes and definitions for timing functions
//**************************************************************************

#ifndef	__TIMER_H__
#define	__TIMER_H__

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	T1								100
#define	T2								845
#define	T3								410

#define	ONE_MILLI_SEC				1000
#define	TWO_MILLI_SECS				2000
#define	THREE_MILLI_SECS			3000
#define	FOUR_MILLI_SECS			4000
#define	FIVE_MILLI_SECS			5000
#define	SIX_MILLI_SECS				6000
#define	SEVEN_MILLI_SECS			7000
#define	EIGHT_MILLI_SECS			8000
#define	NINE_MILLI_SECS			9000
#define	TEN_MILLI_SECS				10000

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

ULONG
TIMER_GetTickCount (VOID);

NTSTATUS
TIMER_Calibrate (VOID);

ULONG
TIMER_CalibratePort (
	IN		PGAMEPORT	PortInfo,
	IN	 	ULONG			Microseconds
	);

ULONG
TIMER_GetDelay (
	IN		ULONG			Microseconds
	);

VOID	TIMER_DelayMicroSecs (
	IN		ULONG 		Delay
	);

//===========================================================================
//			End
//===========================================================================
#endif	__TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriver.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriver.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <WinIOCTL.h>		// For CTL_CODE definition
#include "..\\GCKernel.sys\\GckExtrn.h"
#include <crtdbg.h>
#include <objbase.h>		// For CoUninitialize
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

const GUID IID_IDirectInputEffectDriver = {
	0x02538130,
	0x898F,
	0x11D0,
	{ 0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35 }
};

extern TCHAR CLSID_SWPIDDriver_String[];

LONG DllAddRef();
LONG DllRelease();

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter);
const DWORD c_dwShutdownWait = 500;		// (0.5 Seconds)

struct DIHIDFFINITINFO_STRUCT {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
};

// PID Defines for Effect Tyoes
#define PID_CONSTANT_FORCE	0x26
#define	PID_RAMP	 		0x27
#define	PID_SQUARE			0x30
#define PID_SINE			0x31
#define	PID_TRIANGLE		0x32
#define	PID_SAWTOOTHUP		0x33
#define	PID_SAWTOOTHDOWN	0x34
#define PID_SPRING			0x40
#define PID_DAMPER			0x41
#define PID_INTERTIA		0x42
#define PID_FRICTION		0x43


struct PercentageEntry
{
	DWORD dwAngle;
	DWORD dwPercentageX;
//	DWORD dwPercentageY; Y == 10000 - X
};

// Array of Fixed value data
const PercentageEntry g_PercentagesArray[] =
{
	// Angle,	Sin^2(Angle)
	{    0,	    0},	// 0 Degrees
	{ 1125,	  381},	// 11.25 Degrees
	{ 2250,	 1465},	// 22.5 Degrees
	{ 3375,	 3087},	// 33.75 Degrees
	{ 4500,	 5000},	// 45 Degrees
	{ 5625,	 6913},	// 56.25 Degrees
	{ 6750,	 8536},	// 67.50 Degrees
	{ 7875,	 9619},	// 78.75 Degrees
	{ 9000,	10000},	// 90 Degrees
};

const DWORD c_dwTableQuantization = g_PercentagesArray[1].dwAngle;
const LONG c_lContributionY = 2;		// (1/2 = 50%)

const BYTE c_bSideWinderPIDReportID_SetEffect = 1;

// Usage Pages (just PID)
const USAGE c_HidUsagePage_PID = 0x0F;

// Usages
const USAGE c_HidUsage_EffectType = 0x25;
const USAGE c_HidUsage_EffectType_Spring = 0x40;
const USAGE c_HidUsage_EffectBlock_Gain = 0x52;
const USAGE c_HidUsage_EffectBlock_Index = 0x22;	// This is the ID of the effect

// Preloaded Effects
const BYTE c_EffectID_RTCSpring = 1;

// Local Debugging Streaming Function that works in release
#undef UseMyDebugOut
void __cdecl myDebugOut (LPCSTR lpszFormat, ...)
{
#ifdef UseMyDebugOut
    //Stolen from inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...) in AtlBase.h
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[1024];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

#ifdef _NDEBUG
	OutputDebugStringA(szBuffer);
#else
    _RPTF0 (_CRT_WARN, szBuffer);
#endif

	va_end(args);
#else
    UNREFERENCED_PARAMETER (lpszFormat);
    return;
#endif
}

/******************** Class CIDirectInputEffectDriver ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriver::CIDirectInputEffectDriver
(
	IDirectInputEffectDriver* pIPIDEffectDriver,		//@parm [IN] Pointer to PID Effect Driver
	IClassFactory* pIPIDClassFactory					//@parm [IN] Pointer to PID Class Factory
) :

	m_ulReferenceCount(1),
	m_dwDIVersion(0xFFFFFFFF),
	m_dwExternalDeviceID(0xFFFFFFFF),
	m_dwInternalDeviceID(0xFFFFFFFF),
	m_pIPIDEffectDriver(pIPIDEffectDriver),
	m_pIPIDClassFactory(pIPIDClassFactory),
	m_hKernelDeviceDriver(NULL),
	m_hKernelDeviceDriverDuplicate(NULL),
	m_hHidDeviceDriver(NULL),
	m_dwGcKernelDevice(0),
	m_hForceSchemeChangeWaitThread(NULL),
	m_dwForceSchemeChangeThreadID(0),
	m_pPreparsedData(NULL)
{
    myDebugOut ("CIDirectInputEffectDriver::Constructor (pIPIDEffectDriver:0x%0p)\n", pIPIDEffectDriver);

	// Add to gobal object count
	DllAddRef();

	// Add references for objects we are holding
	m_pIPIDClassFactory->AddRef();
	m_pIPIDEffectDriver->AddRef();


	::memset((void*)&m_HidAttributes, 0, sizeof(m_HidAttributes));

	m_ForceMapping.AssignmentBlock.CommandHeader.eID = eForceMap;
	m_ForceMapping.AssignmentBlock.CommandHeader.ulByteSize = sizeof(m_ForceMapping);
	m_ForceMapping.AssignmentBlock.ulVidPid = 0;	// Irrelevant
    m_ForceMapping.bMapYToX = FALSE;
	m_ForceMapping.usRTC = 10000;
	m_ForceMapping.usGain = 10000;
}

/*****************************************************************************
**
** CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
{
	_ASSERTE(m_pIPIDEffectDriver == NULL);
	_ASSERTE(m_ulReferenceCount == 0);

	DllRelease();	// Remove our object from the global object count

    myDebugOut ("CIDirectInputEffectDriver::Destructor\n");
}


//IUnknown members
/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an IUnknown for a particular type. This causes reference count increase locally only.
**				If it is a type we don't know, should we give the PID driver a crack (the PID driver
**			might have a customized private interface, we don't want to ruin that). Currently not
**			going to pass on the Query because this could screwup Symmetry.
**
**	@rdesc	S_OK : all is well
**			E_INVALIDARG : if (ppvObject == NULL)
**			E_NOINTERFACE : If requested interface is unsupported
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
    myDebugOut ("CIDirectInputEffectDriver::QueryInterface (refiid:0x%0p, ppvObject:0x%0p)\n", refiid, ppvObject);

	HRESULT hrPidQuery = m_pIPIDEffectDriver->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		// Don't perform a real addref (PID.dll::QueryInterface will do its own)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
		*ppvObject = this;
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::AddRef()
**
**	@func	Bumps up the reference count
**				The PID driver reference count is left alone. We only decrement it when
**				this object is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::AddRef()
{
    myDebugOut ("CIDirectInputEffectDriver::AddRef (Early) 0x%0p\n", m_ulReferenceCount);
	m_pIPIDEffectDriver->AddRef();
	return (ULONG)(::InterlockedIncrement((LONG*)&m_ulReferenceCount));
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::Release()
**
**	@func	Decrements the reference count.
**				if the reference count becomes zero this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::Release()
{
    myDebugOut ("CIDirectInputEffectDriver::Release (Early) 0x%0p\n", m_ulReferenceCount);
	if (m_ulReferenceCount == 0)
	{
		return m_ulReferenceCount;
	}

	if ((::InterlockedDecrement((LONG*)&m_ulReferenceCount)) != 0)
	{
		m_pIPIDEffectDriver->Release();
		return m_ulReferenceCount;
	}


	// Tell the driver to complete outstanding IOCTLs to this device
	if (m_hKernelDeviceDriver == NULL)
	{	// Don't have a handle to PID driver, so open one
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
		}
	}
	if (m_hKernelDeviceDriver != NULL)	// Handle should be open, but check just incase
    {
        DWORD dwReturnDataSize;
        BOOL fSuccess = DeviceIoControl(m_hKernelDeviceDriver, 
            IOCTL_GCK_END_FF_NOTIFICATION,
            (void*)(&m_dwGcKernelDevice), sizeof(DWORD),	// In
            NULL, 0, &dwReturnDataSize,						// Out
            NULL);

        if (!fSuccess)
            myDebugOut ("CIDirectInputEffectDriver::Release : GCK IOCTL_GCK_END_FF_NOTIFICATION failed!\n");
    
        Sleep(c_dwShutdownWait);
        
        ::CloseHandle(m_hKernelDeviceDriver);
    }
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release : Could not Open GCK for IOCTL_GCK_END_FF_NOTIFICATION\n");
    }

	// Free up the preparsed data
	if (m_pPreparsedData != NULL)
	{
		::HidD_FreePreparsedData(m_pPreparsedData);
		m_pPreparsedData = NULL;
	}

	// Close the handle to the HID path of the driver
	::CloseHandle(m_hHidDeviceDriver);
	m_hHidDeviceDriver = NULL;

	// Close the thread handle (which should be done by now)
	if (m_hForceSchemeChangeWaitThread != NULL)
	{
		::CloseHandle(m_hForceSchemeChangeWaitThread);
		m_hForceSchemeChangeWaitThread = NULL;
		m_dwForceSchemeChangeThreadID = 0;
	}
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release() m_hForceSchemeCHangeWaitThread did not finish!\n");
    }

	// Release the low level pid driver and delete ourselves
	m_pIPIDEffectDriver->Release();
	m_pIPIDEffectDriver = NULL;

	// Release the low level factory (include extra release to fix bug in PID.dll)
	if (m_pIPIDClassFactory->Release() > 0)
	{
		m_pIPIDClassFactory->Release();
	}
	m_pIPIDClassFactory = NULL;

	delete this;
	return 0;
}

//IDirectInputEffectDriver members
HRESULT __stdcall CIDirectInputEffectDriver::DeviceID
(
	DWORD dwDIVersion,
	DWORD dwExternalID,
	DWORD dwIsBegining,
	DWORD dwInternalID,
	void* pReserved
)
{
    myDebugOut ("CIDirectInputEffectDriver::DeviceID (dwDIVersion:0x%08p dwExternalID:0x%08p dwIsBeginning:0x%08p dwInternalID:0x%08p pReserved:0x%08p)\n",
        dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Store off some data
	m_dwExternalDeviceID = dwExternalID;
	m_dwInternalDeviceID = dwInternalID;

	bool bPossiblyFirstTime = false;
	// Get a handle to the Kernel Device and activate the thread
	if (m_hKernelDeviceDriver == NULL)
	{
		bPossiblyFirstTime = true;
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
            myDebugOut ("CIDirectInputEffectDriver::DeviceID Create GCK File Failed!\n");
		}
		else
        {
			InitHidInformation((LPDIHIDFFINITINFO)pReserved);		// Set up the HID stuff (preparsed data et al)
            
            if (NULL == pReserved || 
                IsBadReadPtr ((const void*)pReserved, (UINT) sizeof (DIHIDFFINITINFO_STRUCT)) )
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID E_INVALIDARG (pReserved is NULL!)\n");
                return E_INVALIDARG;
                // Call the default guy
                //return m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);
            }
            
            //
			// get the handle for this device
			//
			WCHAR* pwcInstanceName = ((DIHIDFFINITINFO_STRUCT*)(pReserved))->pwszDeviceInterface;
			DWORD dwBytesReturned;
			BOOL fSuccess = ::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_HANDLE,
										pwcInstanceName, ::wcslen(pwcInstanceName)*sizeof(WCHAR),
										&m_dwGcKernelDevice, sizeof(m_dwGcKernelDevice), &dwBytesReturned,
										NULL);

			if (fSuccess != FALSE)
			{
				// Update the force block
				fSuccess =::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_FF_SCHEME_DATA,
										(void*)(&m_dwGcKernelDevice), sizeof(DWORD),
										(void*)(&m_ForceMapping), sizeof(m_ForceMapping), &dwBytesReturned,
										NULL);

				// Get the duplicate handle for the thread
				BOOL bDuplicated = ::DuplicateHandle(::GetCurrentProcess(), m_hKernelDeviceDriver, ::GetCurrentProcess(), &m_hKernelDeviceDriverDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);
				if ((m_hKernelDeviceDriverDuplicate == INVALID_HANDLE_VALUE) || (bDuplicated == FALSE))
				{
					m_hKernelDeviceDriverDuplicate = NULL;
				}
				else
				{
					m_hForceSchemeChangeWaitThread = ::CreateThread(NULL, 0, DoWaitForForceSchemeChange, (void*)this, 0, &m_dwForceSchemeChangeThreadID);
				}
			}
            else
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID IOCTL_GCK_GET_HANDLE Failed!\n");
            }

			// Close since I need to reopen at the end (why is this happening?)
			::CloseHandle(m_hKernelDeviceDriver);
			m_hKernelDeviceDriver = NULL;
		}
	}

	// Hack to get PID.DLL to place keys in registry.
	// -- It won't place them if OEM-FF Key is already there
/*
	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			// Open key specific to the current device (VIDPID is in m_HidAttributes)
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			if (hkeyOEMForceFeedback != NULL)
			{
				// Check to see if the effects key is already there
				HKEY hkeyEffects = NULL;
				::RegOpenKeyEx(hkeyOEMForceFeedback, TEXT("Effects"), 0, KEY_READ, &hkeyEffects);
				::RegCloseKey(hkeyOEMForceFeedback);
				if (hkeyEffects != NULL)
				{
					// Effects key is there, this is not the first time we have run
					::RegCloseKey(hkeyEffects);
					bPossiblyFirstTime = false;
				}
				else	// Delete the whole OEM ForceFeedback key
				{
					::RegDeleteKey(hkeyOEM, rgtcDeviceName);
				}
			}
		}
		::RegCloseKey(hkeyOEM);
	}
*/
	// Call the drivers DeviceID (if we have removed the OEMFF Key it will repopulate)
	HRESULT hrPID = m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Do we need to put ourselves back as the DIEffectDriver?
/*	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			// Set the registry CLSID value to us
			if (hkeyOEMForceFeedback != NULL)
			{
				::RegSetValueEx(hkeyOEMForceFeedback, TEXT("CLSID"), 0, REG_SZ, (BYTE*)CLSID_SWPIDDriver_String, _tcslen(CLSID_SWPIDDriver_String) * sizeof(TCHAR));
				::RegCloseKey(hkeyOEMForceFeedback);
			}
			::RegCloseKey(hkeyOEM);
		}
	}
*/
	return hrPID;	// Value from the System PID driver
}

HRESULT __stdcall CIDirectInputEffectDriver::GetVersions
(
	DIDRIVERVERSIONS* pDriverVersions
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetVersions (pDriverVersions:0x%08p)\n", pDriverVersions);
 	return m_pIPIDEffectDriver->GetVersions(pDriverVersions);
}

HRESULT __stdcall CIDirectInputEffectDriver::Escape
(
	DWORD dwDeviceID,
	DWORD dwEffectID,
	DIEFFESCAPE* pEscape
)
{
    myDebugOut ("CIDirectInputEffectDriver::Escape (dwDeviceID:0x%08p, dwEffectID:0x%08p, pEscape:0x%08p)\n", dwDeviceID, dwEffectID, pEscape);
	return m_pIPIDEffectDriver->Escape(dwDeviceID, dwEffectID, pEscape);
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SetGain(DWORD dwDeviceID, DWORD dwGain)
**
**	@func	Modifies the user gain based on settings and sends it down to the lower PID driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SetGain
(
	DWORD dwDeviceID,		//@parm [IN] ID for device of interest
	DWORD dwGain			//@parm [IN] User selected gain
)
{
	dwGain *= m_ForceMapping.usGain/1000;	// 0 - 100K
	dwGain /= 10;							// 0 - 10K
    myDebugOut ("CIDirectInputEffectDriver::SetGain (dwDeviceID:%d, dwGain:%05d:)\n", dwDeviceID, dwGain);
	return m_pIPIDEffectDriver->SetGain(dwDeviceID, dwGain);
}


/***********************************************************************************
**
**	HRESULT CopyW2T(LPWSTR pswDest, UINT *puDestSize, LPTSTR ptszSrc)
**
**	@mfunc	Copies a WCHAR into a TCHAR while checking buffer length
**
**	@rdesc	S_OK on success, MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER)
**			if destination buffer is too small
**
*************************************************************************************/
HRESULT CopyW2T
(
	LPTSTR ptszDest,	// @parm pointer to WCHAR destination buffer
	UINT&  ruDestSize,	// @parm size of dest in WCHAR's
	LPCWSTR pwcszSrc	// @parm pointer to NULL terminated source string
)
{

	UINT uSizeRequired;
	HRESULT hr = S_OK;
	
	uSizeRequired = wcslen(pwcszSrc)+1; //the one is for a NULL character
	if(ruDestSize < uSizeRequired)
	{
		hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER);
	}
	else
	{
		//
		//	we always return wide, but TCHAR can be WCHAR or char
		//	this compile time so use preprocessor
		//
		#ifdef UNICODE 
			wcscpy(ptszDest, pwcszSrc);
		#else
			int iRetVal=WideCharToMultiByte
				(
					CP_ACP,
					0,
					pwcszSrc,
					-1,
					ptszDest,
					ruDestSize,
					NULL,
					NULL
				);
			if(0==iRetVal) 
					hr=GetLastError();
		#endif //UNICODE
	}
	//Copy size required, or chars copied (same thing)
	ruDestSize = uSizeRequired;
	return hr;
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::InitHidInformation(void* HidInformation)
**
**	@func	Open a hid path to the driver, and get preparsed data and hid caps.
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::InitHidInformation
(
	LPDIHIDFFINITINFO pHIDInitInfo	//@parm [IN] Pointer to structure containing the HID device name
)
{
    myDebugOut ("CIDirectInputEffectDriver::InitHidInformation (pHIDInitInfo: 0x%08p)\n", pHIDInitInfo);
	if (pHIDInitInfo != NULL)
	{
		TCHAR ptchHidDeviceName[MAX_PATH];
		unsigned int dwSize = MAX_PATH;
		::CopyW2T(ptchHidDeviceName, dwSize, pHIDInitInfo->pwszDeviceInterface);
		m_hHidDeviceDriver = ::CreateFile(ptchHidDeviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hHidDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hHidDeviceDriver = NULL;
			return;
		}
		if (m_pPreparsedData == NULL)
		{
			::HidD_GetPreparsedData(m_hHidDeviceDriver, &m_pPreparsedData);
			if (m_pPreparsedData == NULL)
			{
				return;
			}
		}
		::HidP_GetCaps(m_pPreparsedData, &m_HidCaps);

		// Find VID/PID the USB way!
		::HidD_GetAttributes(m_hHidDeviceDriver, &m_HidAttributes);
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendSpringChange()
**
**	@func	Sends a new Spring Modify report to the driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::SendSpringChange()
{
    myDebugOut ("CIDirectInputEffectDriver::SendSpringChange ()\n");
	if ((m_hHidDeviceDriver != NULL) && (m_pPreparsedData != NULL))
	{
		// Setup the spring report
		// 1. Allocate an array of max output size
		BYTE* pbOutReport = new BYTE[m_HidCaps.OutputReportByteLength];
		if (pbOutReport == NULL)
		{
			return;
		}
		// 2. Zero out array
		::memset(pbOutReport, 0, m_HidCaps.OutputReportByteLength);
		// 3. Set the proper report ID
		pbOutReport[0] = c_bSideWinderPIDReportID_SetEffect;
		// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
		pbOutReport[1] = c_EffectID_RTCSpring;	// Effect Block Index (ID)
		unsigned short usRTC = m_ForceMapping.usRTC;	// 0 - 10K
		usRTC /= 100;									// 0 - 100
		usRTC *= 255;									// 0 - 25500
		usRTC /= 100;									// 0 - 255
		if (usRTC > 255)
		{
			usRTC = 255;
		}
		pbOutReport[9] = BYTE(usRTC);		// Effect Gain - Only item the RTC Spring will look at
		// Now that the firmware has change for Godzilla it looks at bunches o stuff
		pbOutReport[7] = 1;  //sample period
		pbOutReport[11] =132;  //direction-axis + FW only force polar flag
		pbOutReport[13] = 255; //Y - direction

        myDebugOut ("CIDirectInputEffectDriver::SendSpringChange -> usRTC:%03d\n", usRTC);

		// 5. Send the report down
		DWORD dwBytesWritten;
		::WriteFile(m_hHidDeviceDriver, pbOutReport, m_HidCaps.OutputReportByteLength, &dwBytesWritten, NULL);

		// 6. Deallocate report array
		delete[] pbOutReport;
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendForceFeedbackCommand()
**
**	@func	Intercepting this call gives us the chance to set the force level of the
**			RTC Spring after a reset
**
**	@rdesc	Result of SendForceFeedbackCommand (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SendForceFeedbackCommand
(
	DWORD dwDeviceID,		//@parm [IN] ID of device this is for
	DWORD dwState			//@parm [IN] The command (we are interested in reset)
)
{
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Enter (dwDeviceID:%x, dwState:0x%08p)\n", dwDeviceID, dwState);
	HRESULT hr = m_pIPIDEffectDriver->SendForceFeedbackCommand(dwDeviceID, dwState);
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Calling Base (hr:0x%08p)\n", hr);
	if (dwState == DISFFC_RESET)	// This is how they turn on the RTC Spring
	{
        myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand RESET sent!\n");
		SendSpringChange();
	}

	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::GetForceFeedbackState
(
	DWORD dwDeviceID,
	DIDEVICESTATE* pDeviceState
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState Begin (dwDeviceID:%d, pDeviceState:0x%08p)\n", dwDeviceID, pDeviceState);
	HRESULT hrPidDriver = S_OK;

	__try
	{
		hrPidDriver = m_pIPIDEffectDriver->GetForceFeedbackState(dwDeviceID, pDeviceState);
		//
		// Invert safety switch and user FF switch bits to compensate for PID/DI mismatch
		// which caused Fighter Ace II to ignore X/Y axes.
		// Note IF clause which will cause fix to be ignored if DI fixes it
		//
		if (pDeviceState->dwState & DIGFFS_USERFFSWITCHOFF)
			pDeviceState->dwState=pDeviceState->dwState^(DIGFFS_SAFETYSWITCHON|DIGFFS_SAFETYSWITCHOFF|DIGFFS_USERFFSWITCHON|DIGFFS_USERFFSWITCHOFF);

	}
	__except ((GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		hrPidDriver = DIERR_INPUTLOST;
		_RPT0(_CRT_WARN, "!!! Caught EXCEPTION_INT_DIVIDE_BY_ZERO !!!\n");
	}

    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState End (dwDeviceID:%d, pDeviceState:0x%08p; hr: 0x%08x)\n", 
        dwDeviceID, pDeviceState, hrPidDriver);

	return hrPidDriver;
}

/***********************************************************************************
**
**	void PercentagesFromAngle()
**
**	@func	Extrapolate the percentages from the table. Makes use of the fact that
**			sin^2(angle) + cos^2(angle) = 1 and xPercentage + yPercentage = 1
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
void PercentagesFromAngle
(
	DWORD dwAngle,		//@parm [IN] Angle to convert to percentages
	LONG& lXPercent,	//@parm [OUT] Resultant X Percentage
	LONG& lYPercent		//@parm [OUT] Resultant Y Percentage
)
{
	// Get the angle mapping into the first quadrant
	DWORD dwMappingAngle = dwAngle;	// 0 - 9000
	bool bFlipSignX = false;	// X is negative in 3rd and 4th quadrants
	bool bFlipSignY = true;		// Y is negative in 1st and 4th quadrants
	if (dwAngle > 9000)
	{
		bFlipSignY = false;
		if (dwAngle > 18000)
		{
			bFlipSignX = true;
			if (dwAngle > 27000)	// 27000 - 36000
			{
				bFlipSignY = true;
				dwMappingAngle = 36000 - dwAngle;
			}
			else	// 18000 - 27000
			{
				dwMappingAngle = dwAngle - 18000;
			}
		}
		else	// 9000 - 18000
		{
			dwMappingAngle = 18000 - dwAngle;
		}
	}

	_ASSERTE(dwMappingAngle <= 9000);

	DWORD quantizedEntry = dwMappingAngle / c_dwTableQuantization;
	DWORD quantizedAngle = quantizedEntry * c_dwTableQuantization;
	if (dwMappingAngle == quantizedAngle)
	{
		lXPercent = g_PercentagesArray[quantizedEntry].dwPercentageX;
	}
	else
	{
		_ASSERTE(quantizedAngle < dwMappingAngle);
		_ASSERTE(dwMappingAngle < 9000);

		DWORD lValue = g_PercentagesArray[quantizedEntry].dwPercentageX;
		DWORD rValue = g_PercentagesArray[quantizedEntry + 1].dwPercentageX;
		long int lSlope = ((rValue - lValue) * 1000)/c_dwTableQuantization;
		lXPercent = lValue + lSlope * (dwMappingAngle - quantizedAngle);
	}

	lYPercent = 10000 - lXPercent;
	if (bFlipSignX == true)
	{
		lXPercent *= -1;
	}
	if (bFlipSignY == true)
	{
		lYPercent *= -1;
	}
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::DownloadEffect()
**
**	@func	Intercepting this call gives us the chance to map the Y forces to the X
**			axis. Switches off the type to determine if the mapping is done.
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::DownloadEffect
(
	DWORD dwDeviceID,				//@parm [IN] ID of device this is for
	DWORD dwInternalEffectType,		//@parm [IN] Type of effect (major, minor)
	DWORD* pdwDnloadID,				//@parm [IN, OUT] >0 - ID of effect to modify. 0 new effect ID returned
	DIEFFECT* pEffect,				//@parm [IN, OUT] Structure containing effect information
	DWORD dwFlags					//@parm [IN] Download flags
)
{
    myDebugOut ("CIDirectInputEffectDriver::DownloadEffect (<NOT DEBUGGED>)\n");

	if (pEffect == NULL)
	{
		return E_INVALIDARG;
	}

	WORD wType = WORD(dwInternalEffectType & 0x0000FFFF);
	bool bGainTruncation = false;

//	case EF_BEHAVIOR:		// We don't axis-map behaviour
//	case EF_USER_DEFINED:	// We don't axis-map user defined
//	case EF_RTC_SPRING:		// We don't axis-map RTC spring
//	case EF_VFX_EFFECT:		// Visual force VFX Effect!!! Danger Will Robinson!
	if ((m_ForceMapping.bMapYToX) && ((wType >= PID_CONSTANT_FORCE) && (wType <= PID_SAWTOOTHDOWN)))
	{
		// We don't support more than 2 axes (currently), and 0 is probably an error
		if ((pEffect->cAxes > 2) || (pEffect->cAxes == 0))
		{
			return E_NOTIMPL;
		}

		// We don't support sperical (3 axis force)
		if (pEffect->dwFlags & DIEFF_SPHERICAL)
		{
			return E_NOTIMPL;	 // .. since got by axis check, programmer goofed up anyway
		}

		// Are the axes reversed?
		bool bAxesReversed = (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1);

		LONG lPercentX = 0;
		LONG lPercentY = 0;

		// Polar, figure out percentage that is X and percentage that is Y
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			if (pEffect->cAxes == 1)	// Polar coordinate must have two axes of data (because DX says so)
			{
				_RPT0(_CRT_WARN, "POLAR effect that has only one AXIS\n");
//				return E_INVALIDARG;
			}
			long int lEffectAngle = pEffect->rglDirection[0];	// in [0] even if reversed
			if (bAxesReversed == true) {	// Indicates (-1, 0) as origin instead of (0, -1)
				lEffectAngle += 27000;
			}
			while (lEffectAngle < 0)	// Make it positive
			{
				lEffectAngle += 36000;
			}
			lEffectAngle %= 36000;	// Make it from 0 to 35900

			PercentagesFromAngle(DWORD(lEffectAngle), lPercentX, lPercentY);

			// Not going to bother reseting the angle, since PID.dll just sends it down and wheel ignores Y component
		}
		else if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			// Here I remove the Y component in case PID.dll maps this to an angle.
			if (bAxesReversed == true)
			{
				lPercentX = pEffect->rglDirection[1];
				lPercentY = pEffect->rglDirection[0];
				pEffect->rglDirection[0] = 0;
			}
			else
			{
				lPercentX = pEffect->rglDirection[0];
				lPercentY = pEffect->rglDirection[1];
				pEffect->rglDirection[1] = 0;
			}
			LONG lTotal = abs(lPercentX) + abs(lPercentY);
            // DIV ZERO Bug
            // If both of the percentages are zero then do nothing
            // Jen-Hung Ho
            if (lTotal)
            {
                lPercentX = (lPercentX * 10000)/lTotal;
				if ( lPercentY > 0 )
                	lPercentY = 10000 - abs(lPercentX);
				else
					lPercentY = abs(lPercentX) - 10000;
            }
		}
		else
		{
			_ASSERTE(FALSE);
			return E_NOTIMPL;	// Some new fangled coordinate system
		}
#if 0	// tempory remove by Jen-Hung Ho
		long int lContributionY = lPercentY/c_lContributionY;
		long int lTotal = lPercentX + lContributionY;
#else
		long int lTotal;
		long int lContributionY = lPercentY/c_lContributionY;
#endif

		// If POLAR set proper angle
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Keep as orginal code, add by Jen-Hung Ho
			lTotal = lPercentX + lContributionY;
			if (lTotal < 0)
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 0 : 27000;
			}
			else
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 18000 : 9000;
			}
		}
		else	// Cartesian
		{	 
			// use X axis force to determain direction, add by Jen-Hung Ho
			// Y axis force follow X axis direction
			if ( lPercentX > 0 )
				lTotal = lPercentX + abs(lContributionY);
			else if ( lPercentX < 0 )
				lTotal = lPercentX - abs(lContributionY);
			else
				lTotal = lContributionY;

			// Already removed Y above
			if (bAxesReversed == true)
			{
				pEffect->rglDirection[1] = lTotal;
			}
			else
			{
				pEffect->rglDirection[0] = lTotal;
			}
		}

		// Allmost all the time we are changing the angle (and pid always sends it anyways)
		dwFlags |= DIEP_DIRECTION;

		// We avoid causing truncation - what if there was truncation? Need to check and return
		if (pEffect->dwGain > 10000)
		{
			bGainTruncation = true;
		}

		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Modify the gain based on lPercentX and lPercentY
			pEffect->dwGain = pEffect->dwGain * abs(lTotal);
			pEffect->dwGain /= 10000;	// Put back in range 0 - 10000
		}

		// Make sure we don't go out of range and cause DI_TRUNCATED to be returned from below
		if (pEffect->dwGain > 10000)	
		{
			pEffect->dwGain = 10000;
		}
	}
	else	// We are not mapping fix cartesian pid bug
	{
		// Cartesian
		if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			short int xAxisIndex = 0;
			short int yAxisIndex = 1;

			// Are the axes reversed?
			if (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
			{
				xAxisIndex = 1;
				yAxisIndex = 0;
			}

			LONG lTotal = abs(pEffect->rglDirection[0]) + abs(pEffect->rglDirection[1]);

			// Fixup the X component so the total maginitude is base on 10K
            if (lTotal)
            {
				pEffect->rglDirection[xAxisIndex] = (10000 * pEffect->rglDirection[xAxisIndex])/lTotal;
            }

			// Remove the Y component to keep PID.dll from playing with it.
			pEffect->rglDirection[yAxisIndex] = 0;
		}
	}

	HRESULT hr = m_pIPIDEffectDriver->DownloadEffect(dwDeviceID, dwInternalEffectType, pdwDnloadID, pEffect, dwFlags);
	if ((hr == S_OK) && (bGainTruncation == true))
	{
		hr = DI_TRUNCATED;
	}
	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::DestroyEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Enter(dwDeviceID:%d, dwDnloadID:%d)\n", 
        dwDeviceID, dwDnloadID);

    HRESULT hr = m_pIPIDEffectDriver->DestroyEffect(dwDeviceID, dwDnloadID);
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Exit (hr:0x%08p)\n", hr); 
    return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::StartEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD dwMode,
	DWORD dwIterations
)
{
    myDebugOut ("CIDirectInputEffectDriver::StartEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StartEffect(dwDeviceID, dwDnloadID, dwMode, dwIterations);
}

HRESULT __stdcall CIDirectInputEffectDriver::StopEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::StopEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StopEffect(dwDeviceID, dwDnloadID);
}

HRESULT __stdcall CIDirectInputEffectDriver::GetEffectStatus
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD* pdwStatusCode
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetEffectStatus (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->GetEffectStatus(dwDeviceID, dwDnloadID, pdwStatusCode);
}

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter)
{
    myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange (pParameter: 0x%08p)\n", pParameter);

	CIDirectInputEffectDriver* pIDirectInputEffectDriver = (CIDirectInputEffectDriver*)pParameter;
    //TODO remove this it could be really slow!
    if (IsBadReadPtr ((const void*)pParameter, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange pParameter is not a valid read ptr!\n");
    }
	if (pIDirectInputEffectDriver != NULL)
	{
		pIDirectInputEffectDriver->WaitForForceSchemeChange();
	}

	return 0;
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::WaitForForceSchemeChange()
**
**	@func	Thread waits on the Event signal for force scheme change until the object goes away.
**			If event is signaled, WaitForForceSchemeChange() is called
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::WaitForForceSchemeChange()
{
	_ASSERTE(m_hKernelDeviceDriverDuplicate != NULL);
    if (IsBadReadPtr ((const void*)this, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver WaitForForceSchemeChange is not a valid read ptr!\n");
    }

	FORCE_BLOCK forceMap;
	DWORD dwReturnDataSize = 0;
	for (;m_ulReferenceCount != 0;)
	{
		// Set up the IOCTL
		BOOL bRet = ::DeviceIoControl(m_hKernelDeviceDriverDuplicate, IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE,
							(void*)(&m_dwGcKernelDevice), sizeof(DWORD),					// In
							(void*)(&forceMap), sizeof(forceMap), &dwReturnDataSize,		// Out
							NULL);
		_RPT0(_CRT_WARN, "Returned from Scheme Change!\n");
		if ((m_ulReferenceCount != 0) && (bRet != FALSE) && (dwReturnDataSize == sizeof(forceMap)))
		{
			// Need a mutext here
			m_ForceMapping = forceMap;
			SendSpringChange();
			SetGain(m_dwInternalDeviceID, 10000);
		}
		else
		{	// We are done
			::CloseHandle(m_hKernelDeviceDriverDuplicate);
			m_hKernelDeviceDriverDuplicate = NULL;
			ExitThread(2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\msgame\swgampad.c ===
//**************************************************************************
//
//		SWGAMPAD.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SWGAMPAD.C | Gameport mini-driver for GamePads
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SWGAMPAD"
#define	DEVICE_PID					0x0003
#define	HARDWARE_ID					L"Gameport\\SideWindergamepad\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			32
#define	GAME_PACKET_BUTTONS		10

#define	GAME_Y_UP_BIT				0x01
#define	GAME_Y_DOWN_BIT			0x02
#define	GAME_Y_BITS					(GAME_Y_UP_BIT|GAME_Y_DOWN_BIT)
#define	GAME_X_LEFT_BIT			0x04
#define	GAME_X_RIGHT_BIT			0x08
#define	GAME_X_BITS					(GAME_X_LEFT_BIT|GAME_X_RIGHT_BIT)
#define	GAME_BUTTON_BITS			0x3ff0

//
//	Id Definitions
//

#define	GAME_ID_STRING				"H0003"

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	 75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	PACKET_INTERRUPT_DELAY	 45
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		 75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		 50

#define	MAX_STD_SCLKS				150

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				1
#define	EXTENTS_X_MID				0x80
#define	EXTENTS_X_MAX				0xff
#define	EXTENTS_Y_MIN				1
#define	EXTENTS_Y_MID				0x80
#define	EXTENTS_Y_MAX				0xff

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SWGAMPAD_ID | GamePad Id String
#pragma pack(1)
	UCHAR		OpenParen;				// @field Open parentheses
	UCHAR		EisaId[5];				// @field Eisa bus Id
	USHORT	Version[3];				// @field Firmware version
	UCHAR		CloseParen;				// @field Close parentheses
	UCHAR		Reserved[22];			// @field Reserved
#pragma pack()
}	SWGAMPAD_ID, *PSWGAMPAD_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SWGAMPAD_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SWGAMPAD_GoAnalog (PPACKETINFO Packet1, PPACKETINFO Packet2);

static	BOOLEAN	SWGAMPAD_ReadId (PPACKETINFO DataPacket, PPACKETINFO IdPacket);
static	BOOLEAN	SWGAMPAD_GetId (PPACKETINFO IdPacket);

static	NTSTATUS	SWGAMPAD_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_ValidateData (PPACKETINFO DataPacket);
static	VOID		SWGAMPAD_ProcessData (ULONG UnitId, USHORT Data[], PDEVICE_PACKET Report);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SWGAMPAD_DriverEntry (VOID);
static	NTSTATUS	SWGAMPAD_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWGAMPAD_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWGAMPAD_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SWGAMPAD_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SWGAMPAD_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,		//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,	//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,	//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x01,								//	LOGICAL_MINIMUM (1)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x00, 0x00, 0x00,		//	LOGICAL_MAXIMUM (255)
	HIDP_GLOBAL_PHY_MIN_1,		0x01,								//	PHYSICAL_MINIMUM (1)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x00, 0x00, 0x00,		//	PHYSICAL_MAXIMUM (255)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,						//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,			//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,			//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,										//	END_COLLECTION
	
	//dwZ
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwR
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwPOV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,		//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,								//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,								//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,								//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,								//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,								//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,								//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,						//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,								//	REPORT_SIZE (1)
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,								//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)

	//dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION											//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	USHORT		RawData[GAME_PACKET_SIZE/sizeof(USHORT)] =
							{
							0
							};
//
//	Raw Id Buffer
//

static	SWGAMPAD_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							PACKET_INTERRUPT_DELAY,
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							FLAG_WAIT_FOR_CLOCK,		// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							FLAG_START_CLOCK_LOW,	// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SWGAMPAD_DriverEntry,	// DriverEntry
							SWGAMPAD_ConnectDevice,	// ConnectDevice
							SWGAMPAD_StartDevice,	//	StartDevice
							SWGAMPAD_ReadReport,		// ReadReport
							SWGAMPAD_StopDevice,		// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//

static	USHORT		ValidData[GAME_PACKET_SIZE/sizeof(USHORT)] =
							{
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS
							};

//
//	Interrupt Flags
//

static	UCHAR			InterruptFlags = 0;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	GamePadInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWGAMPAD_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SWGAMPAD: SWGAMPAD_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	DataInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.InterruptDelay = %ld\n", DataInfo.InterruptDelay));
	IdInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.InterruptDelay = %ld\n", IdInfo.InterruptDelay));
}

//---------------------------------------------------------------------------
// @func		Puts Gamepads into analog mode
//	@parm		PPACKETINFO | Packet1 | Data packet
//	@parm		PPACKETINFO | Packet2 | Id packet
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_GoAnalog (PPACKETINFO Packet1, PPACKETINFO Packet2)
{
	LONG			Result	= ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &Packet1->PortInfo;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	InterruptFlags = INTERRUPT_AFTER_PACKET;
	Packet1->B4Transitions	= 0;
	Packet1->ClocksSampled	= 0;

	PORTIO_Write (PortInfo, 0);

	if (!(PORTIO_Read (PortInfo) & XA_BIT_MASK))
		{
		Result = ERROR_XA_TIMEOUT;
		}
	else
		{
		if (Packet1->Mode == IMODE_DIGITAL_ENH)
			SWGAMPAD_Read3Wide (Packet1);
		else SWGAMPAD_Read1Wide (Packet1);
		Packet2->B4Transitions	= 0;
		Packet2->ClocksSampled	= 0;
		if (Packet2->Mode == IMODE_DIGITAL_ENH)
			{
			SWGAMPAD_Read3Wide (Packet2);
			Result = Packet2->LastError;
			}
		else SWGAMPAD_Read1Wide (Packet2);
		}

	Packet1->B4Transitions	= 0;
	Packet1->ClocksSampled	= 0;
	Packet2->B4Transitions	= 0;
	Packet2->ClocksSampled	= 0;
	InterruptFlags				= 0;

	DataInfo.LastError		= Result;
	DataInfo.Transaction		= MSGAME_TRANSACT_GOANALOG;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (Result == ERROR_SUCCESS)
		DataInfo.Mode = IdInfo.Mode = IMODE_ANALOG;
	else MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ResetDevice (GoAnalog) Failed\n"));

	MSGAME_PostTransaction (&DataInfo);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | DataPacket | Data packet parameters
//	@parm		PPACKETINFO | IdPacket | ID packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_ReadId (PPACKETINFO DataPacket, PPACKETINFO IdPacket)
{
	LONG			Result	= ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	InterruptFlags = INTERRUPT_AFTER_PACKET;
	DataPacket->B4Transitions	= 0;
	DataPacket->ClocksSampled	= 0;

	PORTIO_Write (PortInfo, 0);

	if (!(PORTIO_Read (PortInfo) & XA_BIT_MASK))
		{
		Result = ERROR_XA_TIMEOUT;
		}
	else
		{
		if (DataPacket->Mode == IMODE_DIGITAL_ENH)
			SWGAMPAD_Read3Wide (DataPacket);
		else SWGAMPAD_Read1Wide (DataPacket);
		InterruptFlags = 0;
		IdPacket->B4Transitions	= 0;
		IdPacket->ClocksSampled	= 0;
		SWGAMPAD_Read1Wide (IdPacket);
		Result = IdPacket->LastError;
		}

	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (Result != ERROR_SUCCESS)
		MsGamePrint ((DBG_SEVERE, "SWGAMPAD_GetId Failed\n"));

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_GetId enter\n"));

	IdPacket->Attempts++;

	if (SWGAMPAD_ReadId (&DataInfo, IdPacket))
		{
		ULONG				i;
		PUSHORT			p;
		PSWGAMPAD_ID	pId;
		//
		//	Remove parity bit and convert to words
		//
		p = IdPacket->Data;
		for (i = 0; i < 5; i++, p++)
			*p = ((*p<<1) & 0x7f00) | (*p & 0x7f);
		//
		//	Check Id String
		//
		pId = (PSWGAMPAD_ID)IdPacket->Data;
      if (!strncmp (pId->EisaId, GAME_ID_STRING, strlen(GAME_ID_STRING)))
			{
			if (IdPacket->B4Transitions > 10)
				{
				DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				SWGAMPAD_GoAnalog (&DataInfo, &IdInfo);
				DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_STD;
				}
			Result = TRUE;
			}
		else MsGamePrint ((DBG_SEVERE, "SWGAMPAD_GetId - Id string did not match = 0x%X\n", (ULONG)(*(PULONG)&pId->EisaId)));
		}

	if (!Result)
		IdPacket->Failures++;

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

BOOLEAN	SWGAMPAD_Read1Wide (PPACKETINFO DataPacket)
{
	LONG	Result;

	// MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_Read1Wide enter\n"));

	__asm
		{
			push	edi
			push	esi
			push	ebp

			mov	edi, DataPacket
			mov	esi, (PPACKETINFO [edi]).Data
			lea	edx, (PPACKETINFO [edi]).PortInfo
			mov	ebx, 10000h
			xor	ebp, ebp
			xor	eax, eax

			test	(PPACKETINFO [edi]).Acquisition, FLAG_START_CLOCK_LOW
			jnz	Std_StartClockLow

			; make sure clock is "high" before sampling clocks...

 			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartClockHigh:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Start of Packet ?
			jz		Std_StartHighToLow				; Y: jump
			dec	ecx
			jnz	Std_StartClockHigh				; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketDone							; Time out error.

		Std_StartHighToLow:

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartHighToLow_1:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Std_LowToHigh						; Y: jump.
			dec	ecx
			jnz	Std_StartHighToLow_1				; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketDone							; Time out error.

		Std_StartClockLow:

			; wait for clock to transition to "high" (sample immediately)

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartClockLow_1:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK 				; Q: Clock went high ?
			jnz	CollectData							; Y: jump (sample data)
			dec	ecx
			jnz	Std_StartClockLow_1				; else keep looping

			mov	eax, ERROR_CLOCKRISING
			jmp	PacketDone							; Time out error.

		Std_CheckClkState:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_LowToHigh

		;Std_HighToLow:

			mov	ecx, (PPACKETINFO [edi]).HighLowTimeout

		Std_HighToLow_1:

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Std_LowToHigh						; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Std_HighToLow_1					; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketDone							; Time out error.

		Std_LowToHigh:

			mov	ecx, (PPACKETINFO [edi]).LowHighTimeout

		Std_LowToHigh_1:

			test	al, CLOCK_BIT_MASK				; Q: clock high ?
			jnz	CollectData							; Y: jump. (get data)
			
			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx									; else see if we timed out
			jnz	Std_LowToHigh_1
			jmp	Std_TestInterrupt

		CollectData:

			inc	ebp
			cmp	ebp, MAX_STD_SCLKS
			jg		Std_BufferOverFlow
			xor	ah, al
			test	ah, DATA2_BIT_MASK				; Q: Data 2 is toggled ?
			jz		CollectData_1						; N: jump.
			inc	(PPACKETINFO [edi]).B4Transitions	; Y: increment Data 2 count.

		CollectData_1:
		
			mov	ah, al
			shr	al, 6									; put data into carry
			rcr	bx, 1									; and then in data counter
			add	ebx, 10000h							; inc mini packet clk counter
			test	ebx, 100000h						; Q: done mini packet ?
			jz		Std_CheckClkState					; N: jump.
			shr	bx, 1									; right align
			mov	word ptr [esi], bx				; move mini packet into buffer
			add	esi, 2								; advance data pointer
			mov	ebx, 10000h							; init mini-packet counter
			jmp	Std_CheckClkState					; go look for more clocks.

		Std_TestInterrupt:

			test	InterruptFlags, INTERRUPT_AFTER_PACKET; Q: Interrupt packet ?
			jnz	Std_IntPacket						; Y: jump.

			mov	eax, ERROR_SUCCESS
			jmp	PacketDone

		Std_IntPacket:

			mov	ecx, 700

		Std_IntPacket_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, INTXA_BIT_MASK
			jz		Std_IntPacket_2
			loop	Std_IntPacket_1
			mov	eax, ERROR_XA_TIMEOUT
			jmp	PacketDone

		Std_IntPacket_2:
		
			cmp	ecx, 700
			je		Std_IntOut
			mov	ecx, (PPACKETINFO [edi]).InterruptDelay

		Std_IntPacket_3:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, al
			xchg	al, ah
			dec	ecx
			jnz	Std_IntPacket_3

		Std_IntOut:

			push	0										; write byte to gameport
			push	edx
			call	PORTIO_Write

			mov	eax, ERROR_SUCCESS
			jmp	PacketDone

		Std_BufferOverFlow:

			mov	eax, ERROR_CLOCKOVERFLOW

		PacketDone:

			mov	(PPACKETINFO [edi]).ClocksSampled, ebp

			pop	ebp
			pop	esi
			pop	edi

			mov	Result, eax
		}

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Result;

	// MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_Read3Wide enter\n"));

	__asm
		{
			push	edi
			push	esi
			push	ebp

			mov	edi, DataPacket
			mov	esi, (PPACKETINFO [edi]).Data
			lea	edx, (PPACKETINFO [edi]).PortInfo

			xor	eax, eax
			xor	ebx, ebx
			xor	ebp, ebp

		;StartEnhancedMode:

			test	(PPACKETINFO [edi]).Acquisition, FLAG_START_CLOCK_LOW
			jnz	Enh_LowToHigh

			; make sure clock is "high" before sampling clocks...

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		StartEnhancedMode_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Start of Packet ?
			jnz	Enh_StartHighToLow				; Y: jump
			dec	ecx
			jnz	StartEnhancedMode_1				; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

		Enh_StartHighToLow:

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Enh_StartHighToLow_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Enh_LowToHigh						; Y: jump.
			dec	ecx
			jnz	Enh_StartHighToLow_1				; else see if we timed out

			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

		;Enh_StartClockLow:

			; wait for clock to transition to "high" (sample immediately)

			mov		ecx, (PPACKETINFO [edi]).StartTimeout

		Enh_StartClockLow_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Clock went high ?
			jnz	Enh_CollectData					; Y: jump (sample data)
			dec	ecx
			jnz	Enh_StartClockLow_1				; else keep looping

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_PacketDone						; Time out error.

		Enh_CheckClkState:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_LowToHigh

			; Wait for clock to transition from high to low.

		;Enh_HighToLow:

			mov	ecx, (PPACKETINFO [edi]).HighLowTimeout

		Enh_HighToLow_1:

			test	al, CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_LowToHigh						; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Enh_HighToLow_1					; if !Timeout continue looping.

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

			; Wait for clock to transition from low to high.

		Enh_LowToHigh:

			mov	ecx, (PPACKETINFO [edi]).LowHighTimeout

		Enh_LowToHigh_1:
		
			test	al, CLOCK_BIT_MASK				; Q: Clock = 1 ?
			jnz	Enh_CollectData					; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Enh_LowToHigh_1					; else continue looping.
			jmp	Enh_TestInterrupt

		Enh_CollectData:

			inc	ebp									; inc. total clocks sampled

			test	ebp, 40h
			jnz	Enh_BufferOverflow

			shr	al, 5									; move data to lower 3 bits
			shrd	ebx, eax, 3							; shift data into ebx.
			add	ebp, 10000h							; inc hiword of ebp
			mov	eax, ebp
			shr	eax, 16								; set ax = hiword of ebp
			cmp	al, 5									; Q: mini-packet done ?
			jne	Enh_CheckClkState					; N: jump.
			shr	ebx, 17
			mov	word ptr [esi],bx
			add	esi, 2
			and	ebp, 0ffffh							; zero out hiword of ebp
			jmp	Enh_CheckClkState


		Enh_TestInterrupt:

			test	InterruptFlags, INTERRUPT_AFTER_PACKET ; Q: Interrupt packet ?
			jz		Enh_PacketOK						; N: jump.

			; Wait for XA line to be cleared before we can fire interrupt.

			mov	ecx, 700

		Enh_Interrupt:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, INTXA_BIT_MASK
			jz		Enh_Interrupt_1
			loop	Enh_Interrupt

			mov	eax, ERROR_XA_TIMEOUT
			jmp	Enh_PacketDone

		Enh_Interrupt_1:
		
			mov		ecx, (PPACKETINFO [edi]).InterruptDelay

		Enh_Interrupt_2:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, al
			dec	ecx
			jnz	Enh_Interrupt_2

			push	0										; write byte to gameport
			push	edx
			call	PORTIO_Write

		Enh_PacketOK:

			and	ebp, 0ffffh
			mov	(PPACKETINFO [edi]).ClocksSampled, ebp
			mov	eax, ERROR_SUCCESS
			jmp	Enh_PacketDone

		Enh_BufferOverflow:

			mov	eax, ERROR_CLOCKOVERFLOW

		Enh_PacketDone:

			pop	ebp
			pop	esi
			pop	edi

			mov	Result, eax
		}

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled	= 0;
	DataPacket->B4Transitions	= 0;
	InterruptFlags					= 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			PORTIO_Write (PortInfo, 0);
			Result = SWGAMPAD_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			PORTIO_Write (PortInfo, 0);
			Result = SWGAMPAD_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_ValidateData (PPACKETINFO DataPacket)
{
	BOOLEAN	Result	=	FALSE;
	PVOID		Data		=	DataPacket->Data;
	ULONG		Packets	=	DataPacket->NumPackets;
	ULONG		Clocks	=	DataPacket->ClocksSampled;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ValidateData enter\n"));

	if ((Clocks % 5) || (Clocks > 20))
		{
		MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ValidateData - wrong number of clocks = %lu\n", Clocks));
		return (Result);
		}

	__asm
		{
			mov	esi, Data
			mov	ecx, Packets

		ValidateLoop:

			mov	ax, [esi]
			xor	al, ah
			jpo	ValidateDone
			add	esi, 2
			loop	ValidateLoop
			mov	Result, TRUE

		ValidateDone:
		}

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		ULONG | UnitId | UnitId for this device
//	@parm		USHORT[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWGAMPAD_ProcessData (ULONG UnitId, USHORT Data[], PDEVICE_PACKET Report)
{
	ULONG	B1;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	switch (Data[UnitId] & GAME_X_BITS)
		{
		case	GAME_X_LEFT_BIT:
			Report->dwX = EXTENTS_X_MIN;
			break;

		case	GAME_X_RIGHT_BIT:
			Report->dwX = EXTENTS_X_MAX;
			break;

		default:
			Report->dwX = EXTENTS_X_MID;
			break;
		}

	//
	//	Process Y Axis
	//

	switch (Data[UnitId] & GAME_Y_BITS)
		{
		case	GAME_Y_DOWN_BIT:
			Report->dwY = EXTENTS_Y_MIN;
			break;

		case	GAME_Y_UP_BIT:
			Report->dwY = EXTENTS_Y_MAX;
			break;

		default:
			Report->dwY = EXTENTS_Y_MID;
			break;
		}

	//
	//	Process Buttons
	//

	Report->dwButtons  = ~((Data[UnitId] & GAME_BUTTON_BITS) >> 4);
	Report->dwButtons &=  ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SWGAMPAD: SWGAMPAD_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo;

	//
	//	Convert registry timing values
	//

  	SWGAMPAD_Calibrate (PortInfo);

	//
	// Reset to "known" state
	//

	MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - resetting device\n"));
	if (!SWGAMPAD_GoAnalog (&DataInfo, &IdInfo))
		MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - unable to go Analog\n"));
	else do
		{
		//
		// SWGAMPAD Connection method (try these steps twice)
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - getting ID string\n"));
		if (!SWGAMPAD_GetId (&IdInfo))
			continue;

		//
  	   // Mark device found and return
		//

		if (!GamePadInfo.NumDevices)
			GamePadInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	GamePadInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
	{
		MsGamePrint ((DBG_INFORM, "SWGAMPAD_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SWGAMPAD_ReadData (&DataInfo);
	if (!NT_SUCCESS(ntStatus))
		{
		if (ntStatus != STATUS_DEVICE_BUSY)
			{
			DataInfo.Failures++;
			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadReport - invalid packet\n"));
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ReadReport - Port busy or in use\n"));
			}
		}
	else
		{
		if (DataInfo.Mode == IMODE_DIGITAL_ENH)
			DataInfo.NumPackets = DataInfo.ClocksSampled / 5;
		else DataInfo.NumPackets = DataInfo.ClocksSampled / 15;
		if (DataInfo.NumPackets == 0)
			DataInfo.NumPackets = 1;
		else if (DataInfo.NumPackets > 4)
			DataInfo.NumPackets = 4;
 		if (!SWGAMPAD_ValidateData (&DataInfo))
			{
			DataInfo.Failures++;
			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadReport - invalid packet\n"));
			}
		else memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
 		}

	//	---------------
		ReadReportExit:
	//	---------------

	if (NT_SUCCESS(ntStatus))
		GamePadInfo.NumDevices = DataInfo.NumPackets;

	if (GET_DEVICE_UNIT (PortInfo) < GamePadInfo.NumDevices)
		SWGAMPAD_ProcessData (GET_DEVICE_UNIT (PortInfo), ValidData, Report);
	else ntStatus = STATUS_DEVICE_NOT_CONNECTED;

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SWGAMPAD_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SWGAMPAD_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriverclassfactory.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriverClassFactory.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <crtdbg.h>
#include <objbase.h>

LONG DllAddRef();
LONG DllRelease();

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

/******************** Class CIDirectInputEffectDriverClassFactory ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory
(
	IClassFactory* pIPIDClassFactory		//@parm [IN] Default PID Factory
) :
	m_ulLockCount(0),
	m_ulReferenceCount(1),
	m_pIPIDClassFactory(pIPIDClassFactory)
{
	// Increase global object count
	DllAddRef();

	// Add count to held object
	m_pIPIDClassFactory->AddRef();
}

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
{
	// Decrease Global object count
	DllRelease();

	_ASSERTE(m_pIPIDClassFactory == NULL);
	_ASSERTE(m_ulLockCount == 0);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an Unknown for a particular type. This causes increase locally only
**				If it is a type we don't know, should we give the PID factory a crack (PID factory
**			might have a customized private interface, we don't want to ruin that. Currently not
**			going to pass on the Query, because this could screwup Symmetry.
**
**	@rdesc	S_OK if all is well, E_INVALIDARG if ppvObject is NULL or E_NOINTERFACE
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
	HRESULT hrPidQuery = m_pIPIDClassFactory->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		*ppvObject = this;
		// Increase our reference count only (pid class fact would be incremented by AddRef call)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::AddRef()
**
**	@func	Bumps up the reference count
**				The PID Factory reference count is left alone. We only decrement it when
**				this factory is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::AddRef()
{
	m_pIPIDClassFactory->AddRef();
	return (ULONG)::InterlockedIncrement((LONG*)&m_ulReferenceCount);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::Release()
**
**	@func	Decrements the reference count.
**				If both the reference count and the lock count are zero the PID Factory is
**				released and this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::Release()
{
	m_pIPIDClassFactory->Release();

	if (::InterlockedDecrement((LONG*)&m_ulReferenceCount) != 0)
	{
		return m_ulReferenceCount;
	}

	m_pIPIDClassFactory = NULL;
	g_pClassFactoryObject = NULL;
	delete this;

	return 0;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void** ppvObject)
**
**	@func	Create an instance of the object
**				Also tells the PID factory to create an instance, this is stored in our instance.
**			
**
**	@rdesc	S_OK if intstance is created
**			E_INVALIDARG if (ppvObject == NULL)
**			CLASS_E_NOAGGREGATION  if aggrigation is attempted (pUnkOuter != NULL)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::CreateInstance
(
	IUnknown* pUnkOuter,	//@parm [IN] Aggregate class or NULL
	REFIID riid,			//@parm [IN] IID of Object to create
	void** ppvObject		//@parm [OUT] Address to place the requested object
)
{
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (ppvObject == NULL)
	{
		return E_INVALIDARG;
	}

	if (riid == IID_IDirectInputEffectDriver)
	{
		// Let the PID Factory Create its driver
		IDirectInputEffectDriver* pPIDDriver = NULL;
		HRESULT hrPID = m_pIPIDClassFactory->CreateInstance(pUnkOuter, riid, (void**)(&pPIDDriver));
		if (FAILED(hrPID) || (pPIDDriver == NULL))
		{
			return hrPID;
		}


		// Create our effect driver
		*ppvObject = new CIDirectInputEffectDriver(pPIDDriver, m_pIPIDClassFactory);

		pPIDDriver->Release();	// We no longer care about this (held in our CIDirectInputEffectDriver)

		if (*ppvObject == NULL)
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	return E_NOINTERFACE;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
**
**	@func	Lock this factory down (prevents Release from causing deletion)
**				If Unlocked compleatly (m_ulLockCount becomes 0) and reference count
**			is at 0 - this Factory is destroyed (and the PID factory is released)
**
**	@rdesc	S_OK : All is well
**			E_UNEXPECTED: Unlock on non-locked object
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::LockServer
(
	BOOL fLock		//@parm [IN] Is the server being locked or unlocked
)
{
	HRESULT hrPidLock = m_pIPIDClassFactory->LockServer(fLock);

	if (FAILED(hrPidLock))
	{
		return hrPidLock;
	}
	if (fLock != FALSE)
	{
		::InterlockedIncrement((LONG*)&m_ulLockCount);
		return S_OK;
	}

	if (m_ulLockCount == 0)
	{
		return E_UNEXPECTED;
	}

	::InterlockedDecrement((LONG*)&m_ulLockCount);

	return hrPidLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriverclassfactory.h ===
#ifndef	__IDirectInputEffectDriverClassFactory_H__
#define	__IDirectInputEffectDriverClassFactory_H__

#include <windows.h>
#include <unknwn.h>
//#include <dinputd.h>

class CIDirectInputEffectDriverClassFactory : public IClassFactory
{
	public:
		CIDirectInputEffectDriverClassFactory(IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriverClassFactory();

		//IUnknown members
		HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();

		//IClassFactory members
		HRESULT __stdcall CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		HRESULT __stdcall LockServer(BOOL fLock);

	private:
 		ULONG           m_ulLockCount;
		ULONG			m_ulReferenceCount;

		IClassFactory*	m_pIPIDClassFactory;
};

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

#endif	__IDirectInputEffectDriverClassFactory_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriver.h ===
#ifndef	__IDirectInputEffectDriver_H__
#define	__IDirectInputEffectDriver_H__

#include <windows.h>
#include <unknwn.h>

#include <dinput.h>
#include "dinputd.h"
extern "C"
{
	#include <hidsdi.h>
}
#include <crtdbg.h>
#include "..\ControlItemCollection\Dualmode.h"
#include "..\ControlItemCollection\Actions.h"		// FORCE_BLOCK

// class IDirectInputEffectDriver;

//class CIDirectInputEffectDriver : public IUnknown
class CIDirectInputEffectDriver
{
	public:
		CIDirectInputEffectDriver(IDirectInputEffectDriver* pIPIDEffectDriver, IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriver();

		//IUnknown members
		virtual HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		virtual ULONG __stdcall AddRef();
		virtual ULONG __stdcall Release();

		//IDirectInputEffectDriver
		virtual HRESULT __stdcall DeviceID(DWORD dwDIVersion, DWORD dwExternalID, DWORD dwIsBegining,
									DWORD dwInternalID, void* pReserved);
		virtual HRESULT __stdcall GetVersions(DIDRIVERVERSIONS* pDriverVersions);
		virtual HRESULT __stdcall Escape(DWORD dwDeviceID, DWORD dwEffectID, DIEFFESCAPE* pEscape);
		virtual HRESULT __stdcall SetGain(DWORD dwDeviceID, DWORD dwGain);
		virtual HRESULT __stdcall SendForceFeedbackCommand(DWORD dwDeviceID, DWORD dwState);
		virtual HRESULT __stdcall GetForceFeedbackState(DWORD dwDeviceID, DIDEVICESTATE* pDeviceState);
		virtual HRESULT __stdcall DownloadEffect(DWORD dwDeviceID, DWORD dwInternalEffectType,
											DWORD* pdwDnloadID, DIEFFECT* pEffect, DWORD dwFlags);
		virtual HRESULT __stdcall DestroyEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall StartEffect(DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode,  DWORD dwIterations);
		virtual HRESULT __stdcall StopEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall GetEffectStatus(DWORD dwDeviceID, DWORD dwDnloadID, DWORD* pdwStatusCode);

		void WaitForForceSchemeChange();
	private:
		void InitHidInformation(LPDIHIDFFINITINFO pHIDInitInfo);
		void SendSpringChange();

		DWORD m_dwDIVersion;
		DWORD m_dwExternalDeviceID;
		DWORD m_dwInternalDeviceID;

		ULONG m_ulReferenceCount;
		IDirectInputEffectDriver* m_pIPIDEffectDriver;
		IClassFactory* m_pIPIDClassFactory;
		HANDLE m_hKernelDeviceDriver;
		HANDLE m_hKernelDeviceDriverDuplicate;
		HANDLE m_hHidDeviceDriver;
		DWORD m_dwGcKernelDevice;
		HANDLE m_hForceSchemeChangeWaitThread;
		DWORD m_dwForceSchemeChangeThreadID;
		FORCE_BLOCK m_ForceMapping;
		PHIDP_PREPARSED_DATA m_pPreparsedData;
		HIDD_ATTRIBUTES m_HidAttributes;
		HIDP_CAPS m_HidCaps;
};

extern CIDirectInputEffectDriver* g_IEffectDriverObject;

#endif	__IDirectInputEffectDriver_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriver.h ===
#ifndef	__IDirectInputEffectDriver_H__
#define	__IDirectInputEffectDriver_H__

#include <windows.h>
#include <unknwn.h>

#include <dinput.h>
#include "dinputd.h"
extern "C"
{
	#include <hidsdi.h>
}
#include <crtdbg.h>
#include "..\ControlItemCollection\Dualmode.h"
#include "..\ControlItemCollection\Actions.h"		// FORCE_BLOCK

// class IDirectInputEffectDriver;

//class CIDirectInputEffectDriver : public IUnknown
class CIDirectInputEffectDriver
{
	public:
		CIDirectInputEffectDriver(IDirectInputEffectDriver* pIPIDEffectDriver, IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriver();

		//IUnknown members
		virtual HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		virtual ULONG __stdcall AddRef();
		virtual ULONG __stdcall Release();

		//IDirectInputEffectDriver
		virtual HRESULT __stdcall DeviceID(DWORD dwDIVersion, DWORD dwExternalID, DWORD dwIsBegining,
									DWORD dwInternalID, void* pReserved);
		virtual HRESULT __stdcall GetVersions(DIDRIVERVERSIONS* pDriverVersions);
		virtual HRESULT __stdcall Escape(DWORD dwDeviceID, DWORD dwEffectID, DIEFFESCAPE* pEscape);
		virtual HRESULT __stdcall SetGain(DWORD dwDeviceID, DWORD dwGain);
		virtual HRESULT __stdcall SendForceFeedbackCommand(DWORD dwDeviceID, DWORD dwState);
		virtual HRESULT __stdcall GetForceFeedbackState(DWORD dwDeviceID, DIDEVICESTATE* pDeviceState);
		virtual HRESULT __stdcall DownloadEffect(DWORD dwDeviceID, DWORD dwInternalEffectType,
											DWORD* pdwDnloadID, DIEFFECT* pEffect, DWORD dwFlags);
		virtual HRESULT __stdcall DestroyEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall StartEffect(DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode,  DWORD dwIterations);
		virtual HRESULT __stdcall StopEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall GetEffectStatus(DWORD dwDeviceID, DWORD dwDnloadID, DWORD* pdwStatusCode);

		void WaitForForceSchemeChange();
	private:
		void InitHidInformation(LPDIHIDFFINITINFO pHIDInitInfo);
		void SendSpringChange();

		DWORD m_dwDIVersion;
		DWORD m_dwExternalDeviceID;
		DWORD m_dwInternalDeviceID;

		ULONG m_ulReferenceCount;
		IDirectInputEffectDriver* m_pIPIDEffectDriver;
		IClassFactory* m_pIPIDClassFactory;
		HANDLE m_hKernelDeviceDriver;
		HANDLE m_hKernelDeviceDriverDuplicate;
		HANDLE m_hHidDeviceDriver;
		DWORD m_dwGcKernelDevice;
		HANDLE m_hForceSchemeChangeWaitThread;
		DWORD m_dwForceSchemeChangeThreadID;
		FORCE_BLOCK m_ForceMapping;
		PHIDP_PREPARSED_DATA m_pPreparsedData;
		HIDD_ATTRIBUTES m_HidAttributes;
		HIDP_CAPS m_HidCaps;
};

extern CIDirectInputEffectDriver* g_IEffectDriverObject;

#endif	__IDirectInputEffectDriver_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriverclassfactory.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriverClassFactory.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <crtdbg.h>
#include <objbase.h>

LONG DllAddRef();
LONG DllRelease();

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

/******************** Class CIDirectInputEffectDriverClassFactory ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory
(
	IClassFactory* pIPIDClassFactory		//@parm [IN] Default PID Factory
) :
	m_ulLockCount(0),
	m_ulReferenceCount(1),
	m_pIPIDClassFactory(pIPIDClassFactory)
{
	// Increase global object count
	DllAddRef();

	// Add count to held object
	m_pIPIDClassFactory->AddRef();
}

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
{
	// Decrease Global object count
	DllRelease();

	_ASSERTE(m_pIPIDClassFactory == NULL);
	_ASSERTE(m_ulLockCount == 0);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an Unknown for a particular type. This causes increase locally only
**				If it is a type we don't know, should we give the PID factory a crack (PID factory
**			might have a customized private interface, we don't want to ruin that. Currently not
**			going to pass on the Query, because this could screwup Symmetry.
**
**	@rdesc	S_OK if all is well, E_INVALIDARG if ppvObject is NULL or E_NOINTERFACE
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
	HRESULT hrPidQuery = m_pIPIDClassFactory->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		*ppvObject = this;
		// Increase our reference count only (pid class fact would be incremented by AddRef call)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::AddRef()
**
**	@func	Bumps up the reference count
**				The PID Factory reference count is left alone. We only decrement it when
**				this factory is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::AddRef()
{
	m_pIPIDClassFactory->AddRef();
	return (ULONG)::InterlockedIncrement((LONG*)&m_ulReferenceCount);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::Release()
**
**	@func	Decrements the reference count.
**				If both the reference count and the lock count are zero the PID Factory is
**				released and this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::Release()
{
	m_pIPIDClassFactory->Release();

	if (::InterlockedDecrement((LONG*)&m_ulReferenceCount) != 0)
	{
		return m_ulReferenceCount;
	}

	m_pIPIDClassFactory = NULL;
	g_pClassFactoryObject = NULL;
	delete this;

	return 0;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void** ppvObject)
**
**	@func	Create an instance of the object
**				Also tells the PID factory to create an instance, this is stored in our instance.
**			
**
**	@rdesc	S_OK if intstance is created
**			E_INVALIDARG if (ppvObject == NULL)
**			CLASS_E_NOAGGREGATION  if aggrigation is attempted (pUnkOuter != NULL)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::CreateInstance
(
	IUnknown* pUnkOuter,	//@parm [IN] Aggregate class or NULL
	REFIID riid,			//@parm [IN] IID of Object to create
	void** ppvObject		//@parm [OUT] Address to place the requested object
)
{
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (ppvObject == NULL)
	{
		return E_INVALIDARG;
	}

	if (riid == IID_IDirectInputEffectDriver)
	{
		// Let the PID Factory Create its driver
		IDirectInputEffectDriver* pPIDDriver = NULL;
		HRESULT hrPID = m_pIPIDClassFactory->CreateInstance(pUnkOuter, riid, (void**)(&pPIDDriver));
		if (FAILED(hrPID) || (pPIDDriver == NULL))
		{
			return hrPID;
		}


		// Create our effect driver
		*ppvObject = new CIDirectInputEffectDriver(pPIDDriver, m_pIPIDClassFactory);

		pPIDDriver->Release();	// We no longer care about this (held in our CIDirectInputEffectDriver)

		if (*ppvObject == NULL)
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	return E_NOINTERFACE;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
**
**	@func	Lock this factory down (prevents Release from causing deletion)
**				If Unlocked compleatly (m_ulLockCount becomes 0) and reference count
**			is at 0 - this Factory is destroyed (and the PID factory is released)
**
**	@rdesc	S_OK : All is well
**			E_UNEXPECTED: Unlock on non-locked object
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::LockServer
(
	BOOL fLock		//@parm [IN] Is the server being locked or unlocked
)
{
	HRESULT hrPidLock = m_pIPIDClassFactory->LockServer(fLock);

	if (FAILED(hrPidLock))
	{
		return hrPidLock;
	}
	if (fLock != FALSE)
	{
		::InterlockedIncrement((LONG*)&m_ulLockCount);
		return S_OK;
	}

	if (m_ulLockCount == 0)
	{
		return E_UNEXPECTED;
	}

	::InterlockedDecrement((LONG*)&m_ulLockCount);

	return hrPidLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriverclassfactory.h ===
#ifndef	__IDirectInputEffectDriverClassFactory_H__
#define	__IDirectInputEffectDriverClassFactory_H__

#include <windows.h>
#include <unknwn.h>
//#include <dinputd.h>

class CIDirectInputEffectDriverClassFactory : public IClassFactory
{
	public:
		CIDirectInputEffectDriverClassFactory(IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriverClassFactory();

		//IUnknown members
		HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();

		//IClassFactory members
		HRESULT __stdcall CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		HRESULT __stdcall LockServer(BOOL fLock);

	private:
 		ULONG           m_ulLockCount;
		ULONG			m_ulReferenceCount;

		IClassFactory*	m_pIPIDClassFactory;
};

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

#endif	__IDirectInputEffectDriverClassFactory_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		*(rkey.m_pReferenceCount) = 1;
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	++(*m_pReferenceCount);
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ KEY_ALL_ACCESS, NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenNextSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName, REGSAM access)
{
	if (m_OSRegistryKey == NULL)
	{
		return c_InvalidKey;
	}

	TCHAR rgtcName[256];
	DWORD dwNameSize = 256;

	if (::RegEnumKeyEx(m_OSRegistryKey, ulCookie, rgtcName, &dwNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (subkeyName != NULL) {
			_tcscpy(subkeyName, rgtcName);
		}

		ulCookie++;
		return OpenSubkey(rgtcName, access);
	}

	return c_InvalidKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\usbwheeleffectdriverentrypoints.cpp ===
//	@doc
/**********************************************************************
*
*	@module	USEWheelEffectDriverEntryPoints.cpp	|
*
*	Contains DLL Entry points
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	DLL Entry points	|
*		DllMain - Main Entry Point for DLL (Process/Thread Attach/Detach)
*		DllCanUnloadNow - Can the DLL be removed from memory
*		DllGetClassObject - Retreive the Class Factory
*		DllRegisterServer - Insert keys into the system registry
*		DLLUnRefisterServer - Remove keys from the system registry
*
**********************************************************************/
#include <windows.h>
#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include "Registry.h"
#include <crtdbg.h>

// From objbase.h
WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject = NULL;
LONG g_lObjectCount = 0;
HINSTANCE g_hLocalInstance = NULL;

GUID g_guidSystemPIDDriver = { // EEC6993A-B3FD-11D2-A916-00C04FB98638
	0xEEC6993A,
	0xB3FD,
	0x11D2,
	{ 0xA9, 0x16, 0x00, 0xC0, 0x4F, 0xB9, 0x86, 0x38 }
};

extern TCHAR CLSID_SWPIDDriver_String[] = TEXT("{db11d351-3bf6-4f2c-a82b-b26cb9676d2b}");

#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder PID Filter Object")
#define THREADING_MODEL_STRING TEXT("Both")

/***********************************************************************************
**
**	BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
**
**	@func	Process/Thread is Attaching/Detaching
**
**	@rdesc	TRUE always
**
*************************************************************************************/
BOOL __stdcall DllMain
(
	HINSTANCE hInstance,	//@parm [IN] Instance of the DLL
	DWORD dwReason,			//@parm [IN] Reason for this call
	LPVOID lpReserved		//@parm [IN] Reserved - Ignored
)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hLocalInstance = hInstance;
	}
	return TRUE;
}

/***********************************************************************************
**
**	HRESULT DllCanUnloadNow()
**
**	@func	Query the DLL for Unloadability
**
**	@rdesc	If there are any object S_FALSE, else S_OK
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllCanUnloadNow()
{
	if (g_lObjectCount > 0)
	{
		return S_FALSE;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
**
**	@func	Retrieve the requested Factory
**
**	@rdesc	E_INVALIDARG: if (ppv == NULL)
**			E_NOMEMORY: if can't create the object
**			S_OK: if all is well
**			E_NOINTERFACE: if interface is not supported
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllGetClassObject
(
	REFCLSID rclsid,
	REFIID riid,		//@parm [IN] ID of requested interface on retrieved object
	LPVOID* ppv			//@parm [OUT] Address of location for returned interface
)
{
	if (ppv == NULL)
	{
		return E_INVALIDARG;
	}
	*ppv = NULL;

	if (g_pClassFactoryObject == NULL)
	{
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

		// Need to get the PID Class Factory
		IClassFactory* pIClassFactory = NULL;
		HRESULT hrGetPIDFactory = ::CoGetClassObject(g_guidSystemPIDDriver, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pIClassFactory);
		if (FAILED(hrGetPIDFactory) || (pIClassFactory == NULL))
		{
			return hrGetPIDFactory;
		}

		g_pClassFactoryObject = new CIDirectInputEffectDriverClassFactory(pIClassFactory);
		pIClassFactory->Release();	// CIDirectInputEffectDriverClassFactory adds a reference
		if (g_pClassFactoryObject == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		g_pClassFactoryObject->AddRef();
	}

	HRESULT hrQuery = g_pClassFactoryObject->QueryInterface(riid, ppv);
	g_pClassFactoryObject->Release();		// Force a release (we start with 1)
	return hrQuery;
}

/***********************************************************************************
**
**	HRESULT DllRegisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllRegisterServer()
{
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey)
	{
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_SWPIDDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR rgtcFileName[MAX_PATH];
			DWORD dwNameSize = ::GetModuleFileName(g_hLocalInstance, rgtcFileName, MAX_PATH);
			if (dwNameSize > 0) {
				rgtcFileName[dwNameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)rgtcFileName, sizeof(rgtcFileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
	}

	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllUnregisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllUnregisterServer()
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_SWPIDDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_SWPIDDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}

LONG DllAddRef()
{
	_RPT1(_CRT_WARN, "(DllAddRef)g_lObjectCount: %d\n", g_lObjectCount);
	return ::InterlockedIncrement(&g_lObjectCount);
}

LONG DllRelease()
{
	_RPT1(_CRT_WARN, "(DllRelease)g_lObjectCount: %d\n", g_lObjectCount);
	DWORD dwCount = ::InterlockedDecrement(&g_lObjectCount);
	if (dwCount == 0)
	{
		g_pClassFactoryObject = NULL;
		::CoUninitialize();
	}
	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SWPIDFlt.rc
//
#define IDS_PROJNAME                    100
#define IDS_HELPFILESWPIDFlt          102
#define IDS_DOCSTRINGSWPIDFlt         103
#define IDR_SWPIDFLT                  110
#define IDS_TITLESWPIDFlt				120

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriver.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriver.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <WinIOCTL.h>		// For CTL_CODE definition
#include "..\\GCKernel.sys\\GckExtrn.h"
#include <crtdbg.h>
#include <objbase.h>		// For CoUninitialize
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

/*
void __cdecl LogIt(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);
	char szBuffer[1024];
	FILE* pLogFile = NULL;

	pLogFile = fopen("swpidflt.log", "a");

	_vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	fprintf(pLogFile, szBuffer);
	va_end(args);

	fclose(pLogFile);
}
*/

const GUID IID_IDirectInputEffectDriver = {
	0x02538130,
	0x898F,
	0x11D0,
	{ 0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35 }
};

extern TCHAR CLSID_SWPIDDriver_String[];

LONG DllAddRef();
LONG DllRelease();

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter);
const DWORD c_dwShutdownWait = 500;		// (0.5 Seconds)

struct DIHIDFFINITINFO_STRUCT {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
};

// PID Defines for Effect Tyoes
#define PID_CONSTANT_FORCE	0x26
#define	PID_RAMP	 		0x27
#define	PID_SQUARE			0x30
#define PID_SINE			0x31
#define	PID_TRIANGLE		0x32
#define	PID_SAWTOOTHUP		0x33
#define	PID_SAWTOOTHDOWN	0x34
#define PID_SPRING			0x40
#define PID_DAMPER			0x41
#define PID_INTERTIA		0x42
#define PID_FRICTION		0x43


struct PercentageEntry
{
	DWORD dwAngle;
	DWORD dwPercentageX;
//	DWORD dwPercentageY; Y == 10000 - X
};

// Array of Fixed value data
const PercentageEntry g_PercentagesArray[] =
{
	// Angle,	Sin^2(Angle)
	{    0,	    0},	// 0 Degrees
	{ 1125,	  381},	// 11.25 Degrees
	{ 2250,	 1465},	// 22.5 Degrees
	{ 3375,	 3087},	// 33.75 Degrees
	{ 4500,	 5000},	// 45 Degrees
	{ 5625,	 6913},	// 56.25 Degrees
	{ 6750,	 8536},	// 67.50 Degrees
	{ 7875,	 9619},	// 78.75 Degrees
	{ 9000,	10000},	// 90 Degrees
};

const DWORD c_dwTableQuantization = g_PercentagesArray[1].dwAngle;
const LONG c_lContributionY = 2;		// (1/2 = 50%)

const BYTE c_bSideWinderPIDReportID_SetEffect = 1;

// Usage Pages (just PID)
const USAGE c_HidUsagePage_PID = 0x0F;

// Usages
const USAGE c_HidUsage_EffectType = 0x25;
const USAGE c_HidUsage_EffectType_Spring = 0x40;
const USAGE c_HidUsage_EffectBlock_Gain = 0x52;
const USAGE c_HidUsage_EffectBlock_Index = 0x22;	// This is the ID of the effect

// Preloaded Effects
const BYTE c_EffectID_RTCSpring = 1;

// Local Debugging Streaming Function that works in release
#undef UseMyDebugOut
void __cdecl myDebugOut (LPCSTR lpszFormat, ...)
{
#ifdef UseMyDebugOut
    //Stolen from inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...) in AtlBase.h
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[1024];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

#ifdef _NDEBUG
	OutputDebugStringA(szBuffer);
#else
    _RPTF0 (_CRT_WARN, szBuffer);
#endif

	va_end(args);
#else
    UNREFERENCED_PARAMETER (lpszFormat);
    return;
#endif
}

/******************** Class CIDirectInputEffectDriver ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriver::CIDirectInputEffectDriver
(
	IDirectInputEffectDriver* pIPIDEffectDriver,		//@parm [IN] Pointer to PID Effect Driver
	IClassFactory* pIPIDClassFactory					//@parm [IN] Pointer to PID Class Factory
) :

	m_ulReferenceCount(1),
	m_dwDIVersion(0xFFFFFFFF),
	m_dwExternalDeviceID(0xFFFFFFFF),
	m_dwInternalDeviceID(0xFFFFFFFF),
	m_pIPIDEffectDriver(pIPIDEffectDriver),
	m_pIPIDClassFactory(pIPIDClassFactory),
	m_hKernelDeviceDriver(NULL),
	m_hKernelDeviceDriverDuplicate(NULL),
	m_hHidDeviceDriver(NULL),
	m_dwGcKernelDevice(0),
	m_hForceSchemeChangeWaitThread(NULL),
	m_dwForceSchemeChangeThreadID(0),
	m_pPreparsedData(NULL)
{
    myDebugOut ("CIDirectInputEffectDriver::Constructor (pIPIDEffectDriver:0x%0p)\n", pIPIDEffectDriver);

	// Add to gobal object count
	DllAddRef();

	// Add references for objects we are holding
	m_pIPIDClassFactory->AddRef();
	m_pIPIDEffectDriver->AddRef();


	::memset((void*)&m_HidAttributes, 0, sizeof(m_HidAttributes));

	m_ForceMapping.AssignmentBlock.CommandHeader.eID = eForceMap;
	m_ForceMapping.AssignmentBlock.CommandHeader.ulByteSize = sizeof(m_ForceMapping);
	m_ForceMapping.AssignmentBlock.ulVidPid = 0;	// Irrelevant
    m_ForceMapping.bMapYToX = FALSE;
	m_ForceMapping.usRTC = 10000;
	m_ForceMapping.usGain = 10000;
}

/*****************************************************************************
**
** CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
{
	_ASSERTE(m_pIPIDEffectDriver == NULL);
	_ASSERTE(m_ulReferenceCount == 0);

	DllRelease();	// Remove our object from the global object count

    myDebugOut ("CIDirectInputEffectDriver::Destructor\n");
}


//IUnknown members
/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an IUnknown for a particular type. This causes reference count increase locally only.
**				If it is a type we don't know, should we give the PID driver a crack (the PID driver
**			might have a customized private interface, we don't want to ruin that). Currently not
**			going to pass on the Query because this could screwup Symmetry.
**
**	@rdesc	S_OK : all is well
**			E_INVALIDARG : if (ppvObject == NULL)
**			E_NOINTERFACE : If requested interface is unsupported
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
    myDebugOut ("CIDirectInputEffectDriver::QueryInterface (refiid:0x%0p, ppvObject:0x%0p)\n", refiid, ppvObject);

	HRESULT hrPidQuery = m_pIPIDEffectDriver->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		// Don't perform a real addref (PID.dll::QueryInterface will do its own)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
		*ppvObject = this;
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::AddRef()
**
**	@func	Bumps up the reference count
**				The PID driver reference count is left alone. We only decrement it when
**				this object is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::AddRef()
{
    myDebugOut ("CIDirectInputEffectDriver::AddRef (Early) 0x%0p\n", m_ulReferenceCount);
	m_pIPIDEffectDriver->AddRef();
	return (ULONG)(::InterlockedIncrement((LONG*)&m_ulReferenceCount));
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::Release()
**
**	@func	Decrements the reference count.
**				if the reference count becomes zero this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::Release()
{
    myDebugOut ("CIDirectInputEffectDriver::Release (Early) 0x%0p\n", m_ulReferenceCount);
	if (m_ulReferenceCount == 0)
	{
		return m_ulReferenceCount;
	}

	if ((::InterlockedDecrement((LONG*)&m_ulReferenceCount)) != 0)
	{
		m_pIPIDEffectDriver->Release();
		return m_ulReferenceCount;
	}


	// Tell the driver to complete outstanding IOCTLs to this device
	if (m_hKernelDeviceDriver == NULL)
	{	// Don't have a handle to PID driver, so open one
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
		}
	}
	if (m_hKernelDeviceDriver != NULL)	// Handle should be open, but check just incase
    {
        DWORD dwReturnDataSize;
        BOOL fSuccess = DeviceIoControl(m_hKernelDeviceDriver, 
            IOCTL_GCK_END_FF_NOTIFICATION,
            (void*)(&m_dwGcKernelDevice), sizeof(DWORD),	// In
            NULL, 0, &dwReturnDataSize,						// Out
            NULL);

        if (!fSuccess)
            myDebugOut ("CIDirectInputEffectDriver::Release : GCK IOCTL_GCK_END_FF_NOTIFICATION failed!\n");
    
        Sleep(c_dwShutdownWait);
        
        ::CloseHandle(m_hKernelDeviceDriver);
    }
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release : Could not Open GCK for IOCTL_GCK_END_FF_NOTIFICATION\n");
    }

	// Free up the preparsed data
	if (m_pPreparsedData != NULL)
	{
		::HidD_FreePreparsedData(m_pPreparsedData);
		m_pPreparsedData = NULL;
	}

	// Close the handle to the HID path of the driver
	::CloseHandle(m_hHidDeviceDriver);
	m_hHidDeviceDriver = NULL;

	// Close the thread handle (which should be done by now)
	if (m_hForceSchemeChangeWaitThread != NULL)
	{
		::CloseHandle(m_hForceSchemeChangeWaitThread);
		m_hForceSchemeChangeWaitThread = NULL;
		m_dwForceSchemeChangeThreadID = 0;
	}
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release() m_hForceSchemeCHangeWaitThread did not finish!\n");
    }

	// Release the low level pid driver and delete ourselves
	m_pIPIDEffectDriver->Release();
	m_pIPIDEffectDriver = NULL;

	// Release the low level factory (include extra release to fix bug in PID.dll)
	if (m_pIPIDClassFactory->Release() > 0)
	{
		m_pIPIDClassFactory->Release();
	}
	m_pIPIDClassFactory = NULL;

	delete this;
	return 0;
}

//IDirectInputEffectDriver members
HRESULT __stdcall CIDirectInputEffectDriver::DeviceID
(
	DWORD dwDIVersion,
	DWORD dwExternalID,
	DWORD dwIsBegining,
	DWORD dwInternalID,
	void* pReserved
)
{
    myDebugOut ("CIDirectInputEffectDriver::DeviceID (dwDIVersion:0x%08p dwExternalID:0x%08p dwIsBeginning:0x%08p dwInternalID:0x%08p pReserved:0x%08p)\n",
        dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Store off some data
	m_dwExternalDeviceID = dwExternalID;
	m_dwInternalDeviceID = dwInternalID;

	bool bPossiblyFirstTime = false;
	// Get a handle to the Kernel Device and activate the thread
	if (m_hKernelDeviceDriver == NULL)
	{
		bPossiblyFirstTime = true;
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
            myDebugOut ("CIDirectInputEffectDriver::DeviceID Create GCK File Failed!\n");
		}
		else
        {
			InitHidInformation((LPDIHIDFFINITINFO)pReserved);		// Set up the HID stuff (preparsed data et al)
            
            if (NULL == pReserved || 
                IsBadReadPtr ((const void*)pReserved, (UINT) sizeof (DIHIDFFINITINFO_STRUCT)) )
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID E_INVALIDARG (pReserved is NULL!)\n");
                return E_INVALIDARG;
                // Call the default guy
                //return m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);
            }
            
            //
			// get the handle for this device
			//
			WCHAR* pwcInstanceName = ((DIHIDFFINITINFO_STRUCT*)(pReserved))->pwszDeviceInterface;
			DWORD dwBytesReturned;
			BOOL fSuccess = ::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_HANDLE,
										pwcInstanceName, ::wcslen(pwcInstanceName)*sizeof(WCHAR),
										&m_dwGcKernelDevice, sizeof(m_dwGcKernelDevice), &dwBytesReturned,
										NULL);

			if (fSuccess != FALSE)
			{
				// Update the force block
				fSuccess =::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_FF_SCHEME_DATA,
										(void*)(&m_dwGcKernelDevice), sizeof(DWORD),
										(void*)(&m_ForceMapping), sizeof(m_ForceMapping), &dwBytesReturned,
										NULL);

				// Get the duplicate handle for the thread
				BOOL bDuplicated = ::DuplicateHandle(::GetCurrentProcess(), m_hKernelDeviceDriver, ::GetCurrentProcess(), &m_hKernelDeviceDriverDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);
				if ((m_hKernelDeviceDriverDuplicate == INVALID_HANDLE_VALUE) || (bDuplicated == FALSE))
				{
					m_hKernelDeviceDriverDuplicate = NULL;
				}
				else
				{
					m_hForceSchemeChangeWaitThread = ::CreateThread(NULL, 0, DoWaitForForceSchemeChange, (void*)this, 0, &m_dwForceSchemeChangeThreadID);
				}
			}
            else
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID IOCTL_GCK_GET_HANDLE Failed!\n");
            }

			// Close since I need to reopen at the end (why is this happening?)
			::CloseHandle(m_hKernelDeviceDriver);
			m_hKernelDeviceDriver = NULL;
		}
	}

	// Hack to get PID.DLL to place keys in registry.
	// -- It won't place them if OEM-FF Key is already there
/*
	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			// Open key specific to the current device (VIDPID is in m_HidAttributes)
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			if (hkeyOEMForceFeedback != NULL)
			{
				// Check to see if the effects key is already there
				HKEY hkeyEffects = NULL;
				::RegOpenKeyEx(hkeyOEMForceFeedback, TEXT("Effects"), 0, KEY_READ, &hkeyEffects);
				::RegCloseKey(hkeyOEMForceFeedback);
				if (hkeyEffects != NULL)
				{
					// Effects key is there, this is not the first time we have run
					::RegCloseKey(hkeyEffects);
					bPossiblyFirstTime = false;
				}
				else	// Delete the whole OEM ForceFeedback key
				{
					::RegDeleteKey(hkeyOEM, rgtcDeviceName);
				}
			}
		}
		::RegCloseKey(hkeyOEM);
	}
*/
	// Call the drivers DeviceID (if we have removed the OEMFF Key it will repopulate)
	HRESULT hrPID = m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Do we need to put ourselves back as the DIEffectDriver?
/*	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			// Set the registry CLSID value to us
			if (hkeyOEMForceFeedback != NULL)
			{
				::RegSetValueEx(hkeyOEMForceFeedback, TEXT("CLSID"), 0, REG_SZ, (BYTE*)CLSID_SWPIDDriver_String, _tcslen(CLSID_SWPIDDriver_String) * sizeof(TCHAR));
				::RegCloseKey(hkeyOEMForceFeedback);
			}
			::RegCloseKey(hkeyOEM);
		}
	}
*/
	return hrPID;	// Value from the System PID driver
}

HRESULT __stdcall CIDirectInputEffectDriver::GetVersions
(
	DIDRIVERVERSIONS* pDriverVersions
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetVersions (pDriverVersions:0x%08p)\n", pDriverVersions);
 	return m_pIPIDEffectDriver->GetVersions(pDriverVersions);
}

HRESULT __stdcall CIDirectInputEffectDriver::Escape
(
	DWORD dwDeviceID,
	DWORD dwEffectID,
	DIEFFESCAPE* pEscape
)
{
    myDebugOut ("CIDirectInputEffectDriver::Escape (dwDeviceID:0x%08p, dwEffectID:0x%08p, pEscape:0x%08p)\n", dwDeviceID, dwEffectID, pEscape);
	return m_pIPIDEffectDriver->Escape(dwDeviceID, dwEffectID, pEscape);
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SetGain(DWORD dwDeviceID, DWORD dwGain)
**
**	@func	Modifies the user gain based on settings and sends it down to the lower PID driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SetGain
(
	DWORD dwDeviceID,		//@parm [IN] ID for device of interest
	DWORD dwGain			//@parm [IN] User selected gain
)
{
	dwGain *= m_ForceMapping.usGain/1000;	// 0 - 100K
	dwGain /= 10;							// 0 - 10K
    myDebugOut ("CIDirectInputEffectDriver::SetGain (dwDeviceID:%d, dwGain:%05d:)\n", dwDeviceID, dwGain);
	return m_pIPIDEffectDriver->SetGain(dwDeviceID, dwGain);
}


/***********************************************************************************
**
**	HRESULT CopyW2T(LPWSTR pswDest, UINT *puDestSize, LPTSTR ptszSrc)
**
**	@mfunc	Copies a WCHAR into a TCHAR while checking buffer length
**
**	@rdesc	S_OK on success, MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER)
**			if destination buffer is too small
**
*************************************************************************************/
HRESULT CopyW2T
(
	LPTSTR ptszDest,	// @parm pointer to WCHAR destination buffer
	UINT&  ruDestSize,	// @parm size of dest in WCHAR's
	LPCWSTR pwcszSrc	// @parm pointer to NULL terminated source string
)
{

	UINT uSizeRequired;
	HRESULT hr = S_OK;
	
	uSizeRequired = wcslen(pwcszSrc)+1; //the one is for a NULL character
	if(ruDestSize < uSizeRequired)
	{
		hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER);
	}
	else
	{
		//
		//	we always return wide, but TCHAR can be WCHAR or char
		//	this compile time so use preprocessor
		//
		#ifdef UNICODE 
			wcscpy(ptszDest, pwcszSrc);
		#else
			int iRetVal=WideCharToMultiByte
				(
					CP_ACP,
					0,
					pwcszSrc,
					-1,
					ptszDest,
					ruDestSize,
					NULL,
					NULL
				);
			if(0==iRetVal) 
					hr=GetLastError();
		#endif //UNICODE
	}
	//Copy size required, or chars copied (same thing)
	ruDestSize = uSizeRequired;
	return hr;
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::InitHidInformation(void* HidInformation)
**
**	@func	Open a hid path to the driver, and get preparsed data and hid caps.
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::InitHidInformation
(
	LPDIHIDFFINITINFO pHIDInitInfo	//@parm [IN] Pointer to structure containing the HID device name
)
{
    myDebugOut ("CIDirectInputEffectDriver::InitHidInformation (pHIDInitInfo: 0x%08p)\n", pHIDInitInfo);
	if (pHIDInitInfo != NULL)
	{
		TCHAR ptchHidDeviceName[MAX_PATH];
		unsigned int dwSize = MAX_PATH;
		::CopyW2T(ptchHidDeviceName, dwSize, pHIDInitInfo->pwszDeviceInterface);
		m_hHidDeviceDriver = ::CreateFile(ptchHidDeviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hHidDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hHidDeviceDriver = NULL;
			return;
		}
		if (m_pPreparsedData == NULL)
		{
			::HidD_GetPreparsedData(m_hHidDeviceDriver, &m_pPreparsedData);
			if (m_pPreparsedData == NULL)
			{
				return;
			}
		}
		::HidP_GetCaps(m_pPreparsedData, &m_HidCaps);

		// Find VID/PID the USB way!
		::HidD_GetAttributes(m_hHidDeviceDriver, &m_HidAttributes);
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendSpringChange()
**
**	@func	Sends a new Spring Modify report to the driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::SendSpringChange()
{
    myDebugOut ("CIDirectInputEffectDriver::SendSpringChange ()\n");
	if ((m_hHidDeviceDriver != NULL) && (m_pPreparsedData != NULL))
	{
		// Setup the spring report
		// 1. Allocate an array of max output size
		BYTE* pbOutReport = new BYTE[m_HidCaps.OutputReportByteLength];
		if (pbOutReport == NULL)
		{
			return;
		}
		// 2. Zero out array
		::memset(pbOutReport, 0, m_HidCaps.OutputReportByteLength);
		// 3. Set the proper report ID
		pbOutReport[0] = c_bSideWinderPIDReportID_SetEffect;
		// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
		pbOutReport[1] = c_EffectID_RTCSpring;	// Effect Block Index (ID)
		unsigned short usRTC = m_ForceMapping.usRTC;	// 0 - 10K
		usRTC /= 100;									// 0 - 100
		usRTC *= 255;									// 0 - 25500
		usRTC /= 100;									// 0 - 255
		if (usRTC > 255)
		{
			usRTC = 255;
		}
		pbOutReport[9] = BYTE(usRTC);		// Effect Gain - Only item the RTC Spring will look at
        myDebugOut ("CIDirectInputEffectDriver::SendSpringChange -> usRTC:%03d\n", usRTC);

		// 5. Send the report down
		DWORD dwBytesWritten;
		::WriteFile(m_hHidDeviceDriver, pbOutReport, m_HidCaps.OutputReportByteLength, &dwBytesWritten, NULL);

		// 6. Deallocate report array
		delete[] pbOutReport;
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendForceFeedbackCommand()
**
**	@func	Intercepting this call gives us the chance to set the force level of the
**			RTC Spring after a reset
**
**	@rdesc	Result of SendForceFeedbackCommand (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SendForceFeedbackCommand
(
	DWORD dwDeviceID,		//@parm [IN] ID of device this is for
	DWORD dwState			//@parm [IN] The command (we are interested in reset)
)
{
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Enter (dwDeviceID:%x, dwState:0x%08p)\n", dwDeviceID, dwState);
	HRESULT hr = m_pIPIDEffectDriver->SendForceFeedbackCommand(dwDeviceID, dwState);
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Calling Base (hr:0x%08p)\n", hr);
	if (dwState == DISFFC_RESET)	// This is how they turn on the RTC Spring
	{
        myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand RESET sent!\n");
		SendSpringChange();
	}

	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::GetForceFeedbackState
(
	DWORD dwDeviceID,
	DIDEVICESTATE* pDeviceState
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState Begin (dwDeviceID:%d, pDeviceState:0x%08p)\n", dwDeviceID, pDeviceState);
	HRESULT hrPidDriver = S_OK;

	__try
	{
		hrPidDriver = m_pIPIDEffectDriver->GetForceFeedbackState(dwDeviceID, pDeviceState);
	}
	__except ((GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		hrPidDriver = DIERR_INPUTLOST;
		_RPT0(_CRT_WARN, "!!! Caught EXCEPTION_INT_DIVIDE_BY_ZERO !!!\n");
	}

    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState End (dwDeviceID:%d, pDeviceState:0x%08p; hr: 0x%08x)\n", 
        dwDeviceID, pDeviceState, hrPidDriver);

	return hrPidDriver;
}

/***********************************************************************************
**
**	void PercentagesFromAngle()
**
**	@func	Extrapolate the percentages from the table. Makes use of the fact that
**			sin^2(angle) + cos^2(angle) = 1 and xPercentage + yPercentage = 1
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
void PercentagesFromAngle
(
	DWORD dwAngle,		//@parm [IN] Angle to convert to percentages
	LONG& lXPercent,	//@parm [OUT] Resultant X Percentage
	LONG& lYPercent		//@parm [OUT] Resultant Y Percentage
)
{
	// Get the angle mapping into the first quadrant
	DWORD dwMappingAngle = dwAngle;	// 0 - 9000
	bool bFlipSignX = false;	// X is negative in 3rd and 4th quadrants
	bool bFlipSignY = true;		// Y is negative in 1st and 4th quadrants
	if (dwAngle > 9000)
	{
		bFlipSignY = false;
		if (dwAngle > 18000)
		{
			bFlipSignX = true;
			if (dwAngle > 27000)	// 27000 - 36000
			{
				bFlipSignY = true;
				dwMappingAngle = 36000 - dwAngle;
			}
			else	// 18000 - 27000
			{
				dwMappingAngle = dwAngle - 18000;
			}
		}
		else	// 9000 - 18000
		{
			dwMappingAngle = 18000 - dwAngle;
		}
	}

	_ASSERTE(dwMappingAngle <= 9000);

	DWORD quantizedEntry = dwMappingAngle / c_dwTableQuantization;
	DWORD quantizedAngle = quantizedEntry * c_dwTableQuantization;
	if (dwMappingAngle == quantizedAngle)
	{
		lXPercent = g_PercentagesArray[quantizedEntry].dwPercentageX;
	}
	else
	{
		_ASSERTE(quantizedAngle < dwMappingAngle);
		_ASSERTE(dwMappingAngle < 9000);

		DWORD lValue = g_PercentagesArray[quantizedEntry].dwPercentageX;
		DWORD rValue = g_PercentagesArray[quantizedEntry + 1].dwPercentageX;
		long int lSlope = ((rValue - lValue) * 1000)/c_dwTableQuantization;
		lXPercent = lValue + lSlope * (dwMappingAngle - quantizedAngle);
	}

	lYPercent = 10000 - lXPercent;
	if (bFlipSignX == true)
	{
		lXPercent *= -1;
	}
	if (bFlipSignY == true)
	{
		lYPercent *= -1;
	}
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::DownloadEffect()
**
**	@func	Intercepting this call gives us the chance to map the Y forces to the X
**			axis. Switches off the type to determine if the mapping is done.
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::DownloadEffect
(
	DWORD dwDeviceID,				//@parm [IN] ID of device this is for
	DWORD dwInternalEffectType,		//@parm [IN] Type of effect (major, minor)
	DWORD* pdwDnloadID,				//@parm [IN, OUT] >0 - ID of effect to modify. 0 new effect ID returned
	DIEFFECT* pEffect,				//@parm [IN, OUT] Structure containing effect information
	DWORD dwFlags					//@parm [IN] Download flags
)
{
/*	LogIt("CIDirectInputEffectDriver::DownloadEffect:\n");
	LogIt("\tdwInternalEffectType: 0x%08X\n", dwInternalEffectType);
	LogIt("\tpdwDnloadID: 0x%08X", pdwDnloadID);
	if (pdwDnloadID != NULL)
	{
		LogIt(" (0x%08X)", *pdwDnloadID);
	}
	LogIt("\n\tpEffect: 0x%08X\n", pEffect);
	if (pEffect != NULL)
	{
		LogIt("\t\trglDirection[0]: %ld\n", pEffect->rglDirection[0]);
		LogIt("\t\tdwFlags: 0x%08X\n", pEffect->dwFlags);
		LogIt("\t\tdwGain: 0x%08X\n", pEffect->dwGain);
	}
	LogIt("\tdwFlags: 0x%08X\n", dwFlags);
*/
	DWORD dwOriginalEffectGain = pEffect->dwGain;

    myDebugOut ("CIDirectInputEffectDriver::DownloadEffect (<NOT DEBUGGED>)\n");

	if (pEffect == NULL)
	{
		return E_INVALIDARG;
	}

	WORD wType = WORD(dwInternalEffectType & 0x0000FFFF);
	bool bGainTruncation = false;

//	case EF_BEHAVIOR:		// We don't axis-map behaviour
//	case EF_USER_DEFINED:	// We don't axis-map user defined
//	case EF_RTC_SPRING:		// We don't axis-map RTC spring
//	case EF_VFX_EFFECT:		// Visual force VFX Effect!!! Danger Will Robinson!
	if ((m_ForceMapping.bMapYToX) && ((wType >= PID_CONSTANT_FORCE) && (wType <= PID_SAWTOOTHDOWN)))
	{
		// We don't support more than 2 axes (currently), and 0 is probably an error
		if ((pEffect->cAxes > 2) || (pEffect->cAxes == 0))
		{
			return E_NOTIMPL;
		}

		// We don't support sperical (3 axis force)
		if (pEffect->dwFlags & DIEFF_SPHERICAL)
		{
			return E_NOTIMPL;	 // .. since got by axis check, programmer goofed up anyway
		}

		// Are the axes reversed?
		bool bAxesReversed = (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1);

		LONG lPercentX = 0;
		LONG lPercentY = 0;

		// Polar, figure out percentage that is X and percentage that is Y
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			if (pEffect->cAxes == 1)	// Polar coordinate must have two axes of data (because DX says so)
			{
				_RPT0(_CRT_WARN, "POLAR effect that has only one AXIS\n");
//				return E_INVALIDARG;
			}
			long int lEffectAngle = pEffect->rglDirection[0];	// in [0] even if reversed
			if (bAxesReversed == true) {	// Indicates (-1, 0) as origin instead of (0, -1)
				lEffectAngle += 27000;
			}
			while (lEffectAngle < 0)	// Make it positive
			{
				lEffectAngle += 36000;
			}
			lEffectAngle %= 36000;	// Make it from 0 to 35900

			PercentagesFromAngle(DWORD(lEffectAngle), lPercentX, lPercentY);

			// Not going to bother reseting the angle, since PID.dll just sends it down and wheel ignores Y component
		}
		else if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			// Here I remove the Y component in case PID.dll maps this to an angle.
			if (bAxesReversed == true)
			{
				lPercentX = pEffect->rglDirection[1];
				lPercentY = pEffect->rglDirection[0];
				pEffect->rglDirection[0] = 0;
			}
			else
			{
				lPercentX = pEffect->rglDirection[0];
				lPercentY = pEffect->rglDirection[1];
				pEffect->rglDirection[1] = 0;
			}
			LONG lTotal = abs(lPercentX) + abs(lPercentY);
            // DIV ZERO Bug
            // If both of the percentages are zero then do nothing
            // Jen-Hung Ho
            if (lTotal)
            {
                lPercentX = (lPercentX * 10000)/lTotal;
				if ( lPercentY > 0 )
                	lPercentY = 10000 - abs(lPercentX);
				else
					lPercentY = abs(lPercentX) - 10000;
            }
		}
		else
		{
			_ASSERTE(FALSE);
			return E_NOTIMPL;	// Some new fangled coordinate system
		}
#if 0	// tempory remove by Jen-Hung Ho
		long int lContributionY = lPercentY/c_lContributionY;
		long int lTotal = lPercentX + lContributionY;
#else
		long int lTotal;
		long int lContributionY = lPercentY/c_lContributionY;
#endif

		// If POLAR set proper angle
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Keep as orginal code, add by Jen-Hung Ho
			lTotal = lPercentX + lContributionY;
			if (lTotal < 0)
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 0 : 27000;
			}
			else
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 18000 : 9000;
			}
		}
		else	// Cartesian
		{	 
			// use X axis force to determain direction, add by Jen-Hung Ho
			// Y axis force follow X axis direction
			if ( lPercentX > 0 )
				lTotal = lPercentX + abs(lContributionY);
			else if ( lPercentX < 0 )
				lTotal = lPercentX - abs(lContributionY);
			else
				lTotal = lContributionY;

			// Already removed Y above
			if (bAxesReversed == true)
			{
				pEffect->rglDirection[1] = lTotal;
			}
			else
			{
				pEffect->rglDirection[0] = lTotal;
			}
		}

		// Allmost all the time we are changing the angle (and pid always sends it anyways)
		dwFlags |= DIEP_DIRECTION;

		// We avoid causing truncation - what if there was truncation? Need to check and return
		if (pEffect->dwGain > 10000)
		{
			bGainTruncation = true;
		}

		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Modify the gain based on lPercentX and lPercentY
			pEffect->dwGain = pEffect->dwGain * abs(lTotal);
			pEffect->dwGain /= 10000;	// Put back in range 0 - 10000
		}

		// Make sure we don't go out of range and cause DI_TRUNCATED to be returned from below
		if (pEffect->dwGain > 10000)	
		{
			pEffect->dwGain = 10000;
		}
	}
	else	// We are not mapping fix cartesian pid bug
	{
		// Cartesian
		if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			short int xAxisIndex = 0;
			short int yAxisIndex = 1;

			// Are the axes reversed?
			if (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
			{
				xAxisIndex = 1;
				yAxisIndex = 0;
			}

			LONG lTotal = abs(pEffect->rglDirection[0]) + abs(pEffect->rglDirection[1]);

			// Fixup the X component so the total maginitude is base on 10K
            if (lTotal)
            {
				pEffect->rglDirection[xAxisIndex] = (10000 * pEffect->rglDirection[xAxisIndex])/lTotal;
            }

			// Remove the Y component to keep PID.dll from playing with it.
			pEffect->rglDirection[yAxisIndex] = 0;
		}
	}

	HRESULT hr = m_pIPIDEffectDriver->DownloadEffect(dwDeviceID, dwInternalEffectType, pdwDnloadID, pEffect, dwFlags);
	pEffect->dwGain = dwOriginalEffectGain;

	if ((hr == S_OK) && (bGainTruncation == true))
	{
		hr = DI_TRUNCATED;
	}

/*	LogIt("-- pdwDnloadID: 0x%08X", pdwDnloadID);
	if (pdwDnloadID != NULL)
	{
		LogIt(" (0x%08X)", *pdwDnloadID);
	}
	LogIt("--\n", hr);
*/	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::DestroyEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Enter(dwDeviceID:%d, dwDnloadID:%d)\n", 
        dwDeviceID, dwDnloadID);

    HRESULT hr = m_pIPIDEffectDriver->DestroyEffect(dwDeviceID, dwDnloadID);
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Exit (hr:0x%08p)\n", hr); 
    return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::StartEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD dwMode,
	DWORD dwIterations
)
{
    myDebugOut ("CIDirectInputEffectDriver::StartEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StartEffect(dwDeviceID, dwDnloadID, dwMode, dwIterations);
}

HRESULT __stdcall CIDirectInputEffectDriver::StopEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::StopEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StopEffect(dwDeviceID, dwDnloadID);
}

HRESULT __stdcall CIDirectInputEffectDriver::GetEffectStatus
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD* pdwStatusCode
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetEffectStatus (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->GetEffectStatus(dwDeviceID, dwDnloadID, pdwStatusCode);
}

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter)
{
    myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange (pParameter: 0x%08p)\n", pParameter);

	CIDirectInputEffectDriver* pIDirectInputEffectDriver = (CIDirectInputEffectDriver*)pParameter;
    //TODO remove this it could be really slow!
    if (IsBadReadPtr ((const void*)pParameter, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange pParameter is not a valid read ptr!\n");
    }
	if (pIDirectInputEffectDriver != NULL)
	{
		pIDirectInputEffectDriver->WaitForForceSchemeChange();
	}

	return 0;
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::WaitForForceSchemeChange()
**
**	@func	Thread waits on the Event signal for force scheme change until the object goes away.
**			If event is signaled, WaitForForceSchemeChange() is called
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::WaitForForceSchemeChange()
{
	_ASSERTE(m_hKernelDeviceDriverDuplicate != NULL);
    if (IsBadReadPtr ((const void*)this, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver WaitForForceSchemeChange is not a valid read ptr!\n");
    }

	FORCE_BLOCK forceMap;
	DWORD dwReturnDataSize = 0;
	for (;m_ulReferenceCount != 0;)
	{
		// Set up the IOCTL
		BOOL bRet = ::DeviceIoControl(m_hKernelDeviceDriverDuplicate, IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE,
							(void*)(&m_dwGcKernelDevice), sizeof(DWORD),					// In
							(void*)(&forceMap), sizeof(forceMap), &dwReturnDataSize,		// Out
							NULL);
		_RPT0(_CRT_WARN, "Returned from Scheme Change!\n");
		if ((m_ulReferenceCount != 0) && (bRet != FALSE) && (dwReturnDataSize == sizeof(forceMap)))
		{
			// Need a mutext here
			m_ForceMapping = forceMap;
			SendSpringChange();
			SetGain(m_dwInternalDeviceID, 10000);
		}
		else
		{	// We are done
			::CloseHandle(m_hKernelDeviceDriverDuplicate);
			m_hKernelDeviceDriverDuplicate = NULL;
			ExitThread(2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName = NULL, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SWUsbFlt.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName = NULL, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\usbwheeleffectdriverentrypoints.cpp ===
//	@doc
/**********************************************************************
*
*	@module	USEWheelEffectDriverEntryPoints.cpp	|
*
*	Contains DLL Entry points
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	DLL Entry points	|
*		DllMain - Main Entry Point for DLL (Process/Thread Attach/Detach)
*		DllCanUnloadNow - Can the DLL be removed from memory
*		DllGetClassObject - Retreive the Class Factory
*		DllRegisterServer - Insert keys into the system registry
*		DLLUnRefisterServer - Remove keys from the system registry
*
**********************************************************************/
#include <windows.h>
#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include "Registry.h"
#include <crtdbg.h>

// From objbase.h
WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject = NULL;
LONG g_lObjectCount = 0;
HINSTANCE g_hLocalInstance = NULL;

GUID g_guidSystemPIDDriver = { // EEC6993A-B3FD-11D2-A916-00C04FB98638
	0xEEC6993A,
	0xB3FD,
	0x11D2,
	{ 0xA9, 0x16, 0x00, 0xC0, 0x4F, 0xB9, 0x86, 0x38 }
};

extern TCHAR CLSID_SWPIDDriver_String[] = TEXT("{0914ff80-3477-11d3-8cbd-00c04f8eebb9}");

#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder PID Filter Object")
#define THREADING_MODEL_STRING TEXT("Both")

/***********************************************************************************
**
**	BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
**
**	@func	Process/Thread is Attaching/Detaching
**
**	@rdesc	TRUE always
**
*************************************************************************************/
BOOL __stdcall DllMain
(
	HINSTANCE hInstance,	//@parm [IN] Instance of the DLL
	DWORD dwReason,			//@parm [IN] Reason for this call
	LPVOID lpReserved		//@parm [IN] Reserved - Ignored
)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hLocalInstance = hInstance;
	}
	return TRUE;
}

/***********************************************************************************
**
**	HRESULT DllCanUnloadNow()
**
**	@func	Query the DLL for Unloadability
**
**	@rdesc	If there are any object S_FALSE, else S_OK
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllCanUnloadNow()
{
	if (g_lObjectCount > 0)
	{
		return S_FALSE;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
**
**	@func	Retrieve the requested Factory
**
**	@rdesc	E_INVALIDARG: if (ppv == NULL)
**			E_NOMEMORY: if can't create the object
**			S_OK: if all is well
**			E_NOINTERFACE: if interface is not supported
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllGetClassObject
(
	REFCLSID rclsid,
	REFIID riid,		//@parm [IN] ID of requested interface on retrieved object
	LPVOID* ppv			//@parm [OUT] Address of location for returned interface
)
{
	if (ppv == NULL)
	{
		return E_INVALIDARG;
	}
	*ppv = NULL;

	if (g_pClassFactoryObject == NULL)
	{
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

		// Need to get the PID Class Factory
		IClassFactory* pIClassFactory = NULL;
		HRESULT hrGetPIDFactory = ::CoGetClassObject(g_guidSystemPIDDriver, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pIClassFactory);
		if (FAILED(hrGetPIDFactory) || (pIClassFactory == NULL))
		{
			return hrGetPIDFactory;
		}

		g_pClassFactoryObject = new CIDirectInputEffectDriverClassFactory(pIClassFactory);
		pIClassFactory->Release();	// CIDirectInputEffectDriverClassFactory adds a reference
		if (g_pClassFactoryObject == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		g_pClassFactoryObject->AddRef();
	}

	HRESULT hrQuery = g_pClassFactoryObject->QueryInterface(riid, ppv);
	g_pClassFactoryObject->Release();		// Force a release (we start with 1)
	return hrQuery;
}

/***********************************************************************************
**
**	HRESULT DllRegisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllRegisterServer()
{
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey)
	{
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_SWPIDDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR rgtcFileName[MAX_PATH];
			DWORD dwNameSize = ::GetModuleFileName(g_hLocalInstance, rgtcFileName, MAX_PATH);
			if (dwNameSize > 0) {
				rgtcFileName[dwNameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)rgtcFileName, sizeof(rgtcFileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
	}

	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllUnregisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllUnregisterServer()
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_SWPIDDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_SWPIDDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}

LONG DllAddRef()
{
	_RPT1(_CRT_WARN, "(DllAddRef)g_lObjectCount: %d\n", g_lObjectCount);
	return ::InterlockedIncrement(&g_lObjectCount);
}

LONG DllRelease()
{
	_RPT1(_CRT_WARN, "(DllRelease)g_lObjectCount: %d\n", g_lObjectCount);
	DWORD dwCount = ::InterlockedDecrement(&g_lObjectCount);
	if (dwCount == 0)
	{
		g_pClassFactoryObject = NULL;
		::CoUninitialize();
	}
	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\swusbfltshell.c ===
//	@doc
/**********************************************************************
*
*	@module	SwUsbFltShell.c	|
*
*	Basic driver entry points for SwUsbFlt.sys
*
*	History
*	----------------------------------------------------------
*	Matthew L Coill	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SwUsbFltShell	|
*	Contains the most basic driver entry points (that any WDM driver
*	would have) for SwUsbFlt.sys.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ SWUSBFLTSHELL_C

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include "SwUsbFltShell.h"

typedef unsigned char BYTE;

// Some Local defines for HID
#define HID_REQUEST_TYPE 0x22
#define HID_REPORT_REQUEST 0xA
#define USB_INTERFACE_CLASS_HID     0x03
#define DESCRIPTOR_TYPE_CONFIGURATION 0x22

// Memory TAG
#define SWFILTER_TAG (ULONG)'lfWS'

// Forward Definitions
NTSTATUS SWUSB_AddDevice(IN PDRIVER_OBJECT, IN PDEVICE_OBJECT);
NTSTATUS SWUSB_Power(IN PDEVICE_OBJECT, IN PIRP);
VOID SWUSB_Unload(IN PDRIVER_OBJECT);

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, SWUSB_AddDevice)
#pragma alloc_text (PAGE, SWUSB_Unload)
#pragma alloc_text (PAGE, SWUSB_Power)
#pragma alloc_text (PAGE, SWUSB_PnP)
#endif

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Standard DriverEntry routine
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
	int i;
                
    UNREFERENCED_PARAMETER (puniRegistryPath);
	
	PAGED_CODE();
	KdPrint(("Built %s at %s\n", __DATE__, __TIME__));
	KdPrint(("Entering DriverEntry, pDriverObject = 0x%0.8x\n", pDriverObject));
    
	//	Hook all IRPs so we can pass them on.
	for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION;	i++)
	{
        pDriverObject->MajorFunction[i] = SWUSB_Pass;
    }

	//	Define entries for IRPs we expect to handle
	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SWUSB_Ioctl_Internal;
	pDriverObject->MajorFunction[IRP_MJ_PNP]            = SWUSB_PnP;
	pDriverObject->MajorFunction[IRP_MJ_POWER]			= SWUSB_Power;
	pDriverObject->DriverExtension->AddDevice           = SWUSB_AddDevice;
    pDriverObject->DriverUnload                         = SWUSB_Unload;

    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	VOID SWUSB_Unload(IN PDRIVER_OBJECT pDriverObject)
**
**	@func	Called to unload driver deallocate any memory here
**
*************************************************************************************/
VOID SWUSB_Unload
(
	IN PDRIVER_OBJECT pDriverObject		//@parm Driver Object for our driver
)
{
    PAGED_CODE();
	UNREFERENCED_PARAMETER(pDriverObject);

	KdPrint(("SWUsbFlt.sys unloading\n"));

	return;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPhysicalDeviceObject)
**
**	@func	Handles AddDevice calls from PnP system, create filter device and
**			attach to top of stack.
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_AddDevice
(
	IN PDRIVER_OBJECT pDriverObject,			// @parm Driver object to create filter device for
	IN PDEVICE_OBJECT pPhysicalDeviceObject		// @parm PDO for device to create
)
{
    NTSTATUS			NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT		pDeviceObject = NULL;
	PSWUSB_FILTER_EXT	pFilterExt = NULL;
    
    PAGED_CODE();
    KdPrint(("Entering SWUSB_AddDevice, pDriverObject = 0x%0.8x, pPDO = 0x%0.8x\n", pDriverObject, pPhysicalDeviceObject));
	    
    // Create a filter device object.
    NtStatus = IoCreateDevice(pDriverObject,
                             sizeof (SWUSB_FILTER_EXT),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &pDeviceObject);

    if (!NT_SUCCESS (NtStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
		KdPrint(("Failed to create filter device object\n"));
		KdPrint(("Exiting AddDevice(prematurely) Status: 0x%0.8x\n", NtStatus));
        return NtStatus;
    }

    // Initialize the the device extension.
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension; // Get pointer to extension
	pFilterExt->pPDO = pPhysicalDeviceObject; // Remember our PDO
	pFilterExt->pTopOfStack = NULL; //We are not attached to stack yet
	// We don't have the pipe information until PNP StartDevice
	RtlZeroMemory(&(pFilterExt->outputPipeInfo), sizeof(USBD_PIPE_INFORMATION));

	//we use the same IO method as hidclass.sys, which DO_DIRECT_IO
	pDeviceObject->StackSize = pPhysicalDeviceObject->StackSize + 1;
	pDeviceObject->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    pFilterExt->pTopOfStack = IoAttachDeviceToDeviceStack (pDeviceObject, pPhysicalDeviceObject);
    
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    ASSERT (NULL != pFilterExt->pTopOfStack);

	KdPrint(("Exiting SWUSB_AddDevice with STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

NTSTATUS SWUSB_SubmitUrb
(
	IN PDEVICE_OBJECT pDeviceObject,	//@parm [OUT] Device Object to submit URB on
	IN PURB pUrb						//@parm [OUT] URB to submit	
)
{
    NTSTATUS NtStatus;
	PSWUSB_FILTER_EXT pFilterExt;
    PIRP pIrp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION pNextStack;

	KdPrint(("Entering SWUSB_SubmitUrb\n"));
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

    // issue a synchronous request to read the UTB
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                        pFilterExt->pTopOfStack,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE, /* INTERNAL */
                                        &event,
                                        &ioStatus);

	if (pIrp)
	{	// pass the URB to the USB 'class driver'
		pNextStack = IoGetNextIrpStackLocation(pIrp);
		ASSERT(pNextStack != NULL);
		pNextStack->Parameters.Others.Argument1 = pUrb;

		NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pIrp);
		if (NtStatus == STATUS_PENDING) {
			NTSTATUS waitStatus;

			// Specify a timeout of 5 seconds for this call to complete.
			LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

			waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeout);
			if (waitStatus == STATUS_TIMEOUT)
			{	//  Cancel the Irp we just sent.
				IoCancelIrp(pIrp);

				//  Now wait for the Irp to be cancelled/completed below
				waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

                /*
                 *  Note - Return STATUS_IO_TIMEOUT, not STATUS_TIMEOUT.
                 *  STATUS_IO_TIMEOUT is an NT error status, STATUS_TIMEOUT is not.
                 */
                ioStatus.Status = STATUS_IO_TIMEOUT;
			}

			// USBD maps the error code for us
			NtStatus = ioStatus.Status;
		}
	} 
	else 
	{
		NtStatus = STATUS_INSUFFICIENT_RESOURCES;
	}

	KdPrint(("Exiting SWUSB_SubmitUrb\n"));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_GetConfigurationDescriptor(IN PDEVICE_OBJECT pDeviceObject, OUT USB_CONFIGURATION_DESCRIPTOR** ppUCD)
**
**	@func	Retreive the Full Configuration Descriptor from the device
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_GetConfigurationDescriptor
(
	IN PDEVICE_OBJECT pDeviceObject,			// @parm [IN] Pointer to our DeviceObject
	OUT USB_CONFIGURATION_DESCRIPTOR** ppUCD	// @parm [OUT] Usb Configuration Descriptor (allocated here)
)
{
	NTSTATUS NtStatus;
	PURB pDescriptorRequestUrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), SWFILTER_TAG);
	USB_CONFIGURATION_DESCRIPTOR sizingUCD;

	// Null out incase of error
	*ppUCD = NULL;
	KdPrint(("Entering SWUSB_GetConfigurationDescriptor\n"));
	if (pDescriptorRequestUrb == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Create and send a size gathering descriptor
	UsbBuildGetDescriptorRequest(
		pDescriptorRequestUrb,
		sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
		USB_CONFIGURATION_DESCRIPTOR_TYPE,
		1,
		0,
		&sizingUCD,
		NULL,
		sizeof(USB_CONFIGURATION_DESCRIPTOR),
		NULL
	);
	NtStatus = SWUSB_SubmitUrb(pDeviceObject, pDescriptorRequestUrb);

	if (NT_SUCCESS(NtStatus))
	{	// Allocate the UCD, Create and send an URB to retreive the information
		*ppUCD = ExAllocatePoolWithTag(NonPagedPool, sizingUCD.wTotalLength, SWFILTER_TAG);
		if (*ppUCD == NULL)
		{
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		}
		else
		{
			UsbBuildGetDescriptorRequest(
				pDescriptorRequestUrb,
				sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				1,
				0,
				*ppUCD,
				NULL,
				sizingUCD.wTotalLength,
				NULL
			);
			NtStatus = SWUSB_SubmitUrb(pDeviceObject, pDescriptorRequestUrb);
		}
	}

	// Deallocate the URB
	ExFreePool(pDescriptorRequestUrb);
	KdPrint(("Exiting SWUSB_GetConfigurationDescriptor\n"));
	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS StartDeviceComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	StartDeviceComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS StartDeviceComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;
	UNREFERENCED_PARAMETER(pDeviceObject);

	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***********************************************************************************
**
**	NTSTATUS SWUSB_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PnP
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PSWUSB_FILTER_EXT	pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		*ppPrevDeviceObjectPtr;
	PDEVICE_OBJECT		pCurDeviceObject;
	BOOLEAN				fRemovedFromList;
	BOOLEAN				fFoundOne;

	PAGED_CODE();
	
	//cast device extension to proper type
	pFilterExt = (PSWUSB_FILTER_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch (pIrpStack->MinorFunction) {

		case IRP_MN_REMOVE_DEVICE:
		{
			KdPrint(("IRP_MN_REMOVE_DEVICE\n"));

			// Send on the remove IRP
			IoSkipCurrentIrpStackLocation (pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

			// Clean up
			IoDetachDevice (pFilterExt->pTopOfStack);	//Detach from top of stack
			IoDeleteDevice (pDeviceObject);				//Delete ourselves

			// Must succeed this (???)
			return STATUS_SUCCESS;
		};
		case IRP_MN_START_DEVICE:
		case IRP_MN_QUERY_DEVICE_RELATIONS:
		case IRP_MN_QUERY_STOP_DEVICE:
		case IRP_MN_QUERY_REMOVE_DEVICE:
		case IRP_MN_SURPRISE_REMOVAL:
		case IRP_MN_STOP_DEVICE:			
		case IRP_MN_CANCEL_STOP_DEVICE:
		case IRP_MN_CANCEL_REMOVE_DEVICE:
		case IRP_MN_QUERY_INTERFACE:
		case IRP_MN_QUERY_CAPABILITIES:
		case IRP_MN_QUERY_RESOURCES:
		case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
		case IRP_MN_READ_CONFIG:
		case IRP_MN_WRITE_CONFIG:
		case IRP_MN_EJECT:
		case IRP_MN_SET_LOCK:
		case IRP_MN_QUERY_ID:
		case IRP_MN_QUERY_PNP_DEVICE_STATE:
		default:
			IoSkipCurrentIrpStackLocation (pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
			break;
	}
	
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS ReportDescriptorComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	ReportDescriptorComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS ReportDescriptorComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;

	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS SelectConfigComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	SelectConfigComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS SelectConfigComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;
	USBD_INTERFACE_INFORMATION* pUsbInterfaceInformation;
	PSWUSB_FILTER_EXT pFilterExt;
	PURB pUrb = URB_FROM_IRP(pIrp);
	ULONG pipeIndex;
	pFilterExt = pDeviceObject->DeviceExtension;
	if (pIrp->IoStatus.Status == STATUS_SUCCESS)
	{
		pUsbInterfaceInformation = &(pUrb->UrbSelectConfiguration.Interface);
			
				for (pipeIndex = 0; pipeIndex < pUsbInterfaceInformation->NumberOfPipes; pipeIndex++){
					if ((pUsbInterfaceInformation->Pipes[pipeIndex].EndpointAddress & USB_ENDPOINT_DIRECTION_MASK) == 0)
					{
						if (pUsbInterfaceInformation->Pipes[pipeIndex].PipeType == UsbdPipeTypeInterrupt)
						{
							pFilterExt->outputPipeInfo = pUsbInterfaceInformation->Pipes[pipeIndex];
							break;
						}
					}
				}
	}
	//If the IRP failed somehow, make sure outputPipeInfo stays NULL
	else RtlZeroMemory(&(pFilterExt->outputPipeInfo), sizeof(USBD_PIPE_INFORMATION));

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Ioctl_Internal(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	IRP_MJ_INTERNAL_IOCTL
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_Ioctl_Internal
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
   	NTSTATUS	NtStatus;
	NTSTATUS	NTStatus2;
	ULONG		uIoctl;
	PSWUSB_FILTER_EXT	pFilterExt;
		
	uIoctl = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode;
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

	switch (uIoctl)
	{
		case IOCTL_INTERNAL_USB_SUBMIT_URB:
		{
			PURB pUrb = URB_FROM_IRP(pIrp);
			//Only handle this if it's a HID descriptor request and we have a pipe handle
			if (pUrb->UrbHeader.Function == URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE &&
				pUrb->UrbControlDescriptorRequest.DescriptorType == DESCRIPTOR_TYPE_CONFIGURATION &&
				pFilterExt->outputPipeInfo.PipeHandle != NULL)
			{

				BYTE* pOutData = NULL;
				KEVENT irpCompleteEvent;
				PURB pInterruptUrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), SWFILTER_TAG);
				KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB\n"));
				
				if (pInterruptUrb == NULL)
				{
					pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					IoCompleteRequest(pIrp, IO_NO_INCREMENT);
					KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB -- STATUS_INSUFFICIENT_RESOURCES\n"));
					return STATUS_INSUFFICIENT_RESOURCES;
				}
				pOutData = ExAllocatePoolWithTag(NonPagedPool, sizeof(BYTE)*2, SWFILTER_TAG);
				if (pOutData == NULL)
				{
					ExFreePool(pInterruptUrb);
					pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					IoCompleteRequest(pIrp, IO_NO_INCREMENT);
					KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB (1) -- STATUS_INSUFFICIENT_RESOURCES\n"));
					return STATUS_INSUFFICIENT_RESOURCES;
				}
				pOutData[0] = 0x0D;
				pOutData[1] = 0xFF;
				UsbBuildInterruptOrBulkTransferRequest(
					pInterruptUrb,
					sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
					pFilterExt->outputPipeInfo.PipeHandle,
					pOutData,
					NULL,
					2,
					USBD_SHORT_TRANSFER_OK,
					NULL
				);

				KeInitializeEvent(&irpCompleteEvent, NotificationEvent, FALSE);
				IoCopyCurrentIrpStackLocationToNext(pIrp);
				IoSetCompletionRoutine(pIrp, ReportDescriptorComplete, (PVOID)(&irpCompleteEvent), TRUE, TRUE, TRUE);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				if (NtStatus == STATUS_PENDING)
				{
					KeWaitForSingleObject(&irpCompleteEvent, Executive, KernelMode, FALSE, 0);
				}
				NtStatus = pIrp->IoStatus.Status;

				NTStatus2 = SWUSB_SubmitUrb(pDeviceObject, pInterruptUrb);
			
				ExFreePool(pOutData);
				ExFreePool(pInterruptUrb);
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				return NtStatus;
			}
			if ((pUrb->UrbHeader.Function == URB_FUNCTION_SELECT_CONFIGURATION))
			{
				KEVENT irpCompleteEvent;
				KeInitializeEvent(&irpCompleteEvent, NotificationEvent, FALSE);
				IoCopyCurrentIrpStackLocationToNext(pIrp);
				IoSetCompletionRoutine(pIrp, SelectConfigComplete, (PVOID)(&irpCompleteEvent), TRUE, TRUE, TRUE);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				if (NtStatus == STATUS_PENDING)
				{
					KeWaitForSingleObject(&irpCompleteEvent, Executive, KernelMode, FALSE, 0);
				}
				NtStatus = pIrp->IoStatus.Status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				return NtStatus;
			}
		}
	}

	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
	
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Power(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes on power IRPs to lower drivers 
**
**	@rdesc	Status from lower level driver
**
*************************************************************************************/
NTSTATUS SWUSB_Power
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
)
{
	NTSTATUS NtStatus;
	PSWUSB_FILTER_EXT pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

	PAGED_CODE();

	KdPrint(("SWUSB_Power() - Entering\n"));
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	NtStatus = PoCallDriver(pFilterExt->pTopOfStack, pIrp);
	KdPrint(("SWUSB_Power() - Exiting\n"));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Pass (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes on unhandled IRPs to lower drivers DEBUG version trace out info
**			Cannot be pageable since we have no idea what IRPs we're getting.
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS SWUSB_Pass ( 
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp						// @parm IRP to pass on
)
{
	NTSTATUS			NtStatus;
	PSWUSB_FILTER_EXT	pFilterExt;
	KdPrint(("SWUSB_Pass() - Entering\n"));
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;
	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

	//return
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\swusbfltshell.h ===
#ifndef __SWUSBFLTSHELL_H__
#define __SWUSBFLTSHELL_H__
//	@doc
/**********************************************************************
*
*	@module	SwUsbFltShell.h	|
*
*	Header file for SwUsbFlt.sys WDM shell structure
*
*	History
*	----------------------------------------------------------------------
*	Matthew L. Coill	Original (Adopted from GckShell.h from MitchD)
*
*	(c) 1986-2000 Microsoft Corporation. All right reserved.
*
*	@topic	SwUsbFltShell	|
*	Declaration of all structures, and functions in SwUsbFlt that make up
*	the shell of the driver.
*
**********************************************************************/

//	We use some structures from hidclass.h
#include <hidclass.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <hidusage.h>

//	A little more rigorous than our normal build
#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
//	@struct SWUSB_FILTER_EXT | Device Extension for this device filter
//
typedef struct _tagSWUSB_FILTER_EXT
{
    PDEVICE_OBJECT	pPDO;						// @field PDO to which this filter is attached
    PDEVICE_OBJECT	pTopOfStack;				// @field Top of the device stack just beneath this filter device object
	USBD_PIPE_INFORMATION outputPipeInfo;		// @field Information about the Output Pipe
} SWUSB_FILTER_EXT, *PSWUSB_FILTER_EXT;


/*****************************************************************************
** Declaration of Driver Entry Points
******************************************************************************/
//
// General Entry Points - In SwUsbFltShell.c
//

NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT  pDriverObject,
	IN PUNICODE_STRING pRegistryPath
);

NTSTATUS SWUSB_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS SWUSB_Ioctl_Internal (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS SWUSB_Pass (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

#endif __SWUSBFLTSHELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		*(rkey.m_pReferenceCount) = 1;
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	++(*m_pReferenceCount);
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ KEY_ALL_ACCESS, NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenNextSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName, REGSAM access)
{
	if (m_OSRegistryKey == NULL)
	{
		return c_InvalidKey;
	}

	TCHAR rgtcName[256];
	DWORD dwNameSize = 256;

	if (::RegEnumKeyEx(m_OSRegistryKey, ulCookie, rgtcName, &dwNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (subkeyName != NULL) {
			_tcscpy(subkeyName, rgtcName);
		}

		ulCookie++;
		return OpenSubkey(rgtcName, access);
	}

	return c_InvalidKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dtrans.cpp ===
//@doc
/******************************************************
**
** @module DTRANS.CPP | DataTransmitter implementation file
**
** Description:
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "FFDevice.h"
#include "DTrans.h"
//#include <devioctl.h>

#ifdef _DEBUG
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

const char cCommPortNames[4][5] = { "COM1", "COM2", "COM3", "COM4" };
const unsigned short c1_16_BytesPerShot = 3;
const DWORD c1_16_SerialSleepTime = 1;

#define UART_FILTER_NAME TEXT("\\\\.\\.\\PortClass0\\Uart")
const WORD c_LongMsgMax = 256;

inline BOOL IsHandleValid(HANDLE handleToCheck)
{
	return ((handleToCheck != NULL) && (handleToCheck != INVALID_HANDLE_VALUE));
}

#define CHECK_RELEASE_AND_NULL(pIUnknown)	\
	if (pIUnknown != NULL)					\
	{										\
		pIUnknown->Release();				\
		pIUnknown = NULL;					\
	}

/************************** SerialDataTransmitter Class ******************************/

/******************************************************
**
** SerialDataTransmitter::SerialDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialDataTransmitter::SerialDataTransmitter() : DataTransmitter(),
	m_SerialPort(INVALID_HANDLE_VALUE),
	m_SerialPortIDHack(0)
{
}

/******************************************************
**
** SerialDataTransmitter::~SerialDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
SerialDataTransmitter::~SerialDataTransmitter()
{
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}
}


/******************************************************
**
** SerialDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialDataTransmitter::Initialize()
{
	// If already open, close for reinitialization
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}

	for (int portNum = 0; portNum < 4; portNum++) {
		DebugOut(cCommPortNames[portNum]);
		DebugOut(":\r\n");
		m_SerialPort = ::CreateFile(cCommPortNames[portNum], GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (m_SerialPort != INVALID_HANDLE_VALUE) {
			DCB CommDCB;
			if (::GetCommState(m_SerialPort, &CommDCB)) {
#ifdef _DEBUG
				char dbgout[255];
				wsprintf(dbgout, "Baud Rate = 0x%08X (38400 = 0x%08X)\r\n", CommDCB.BaudRate, CBR_38400);
				::OutputDebugString(dbgout);
#endif _DEBUG
				CommDCB.BaudRate = CBR_38400;
				CommDCB.StopBits = ONESTOPBIT;
				CommDCB.ByteSize = 8;
				CommDCB.Parity = NOPARITY;
				if (!::SetCommState(m_SerialPort, &CommDCB)) {
					DebugOut("Unabled to set baud rate\r\n");
				}
			}
			::GetCommState(m_SerialPort, &CommDCB);

			if (g_ForceFeedbackDevice.DetectHardware()) {
				m_SerialPortIDHack = portNum + 1;
				// Write to shared file
				DebugOut(" Opened and FFDev Detected\r\n");
				break;	// Exit from for loop
			}
			// Not found
			::CloseHandle(m_SerialPort);
			DebugOut(" Opened but FFDev NOT detected\r\n");
			m_SerialPort = INVALID_HANDLE_VALUE;
		} else {
			DebugOut(" Not able to open\r\n");
		}
	}
	return (m_SerialPort != INVALID_HANDLE_VALUE);
}

/******************************************************
**
** SerialDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL SerialDataTransmitter::Send(BYTE* data, UINT numBytes)
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_SerialPort == NULL) {
		return FALSE;
	}

/*	char dbgOut[255];
	::OutputDebugString("(SerialDataTransmitter::Send) : ");
	for (UINT i = 0; i < numBytes; i++) {
		wsprintf(dbgOut, " 0x%02X", data[i]);
		::OutputDebugString(dbgOut);
	}
	::OutputDebugString("\r\n");
*/
	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)) {
		DWORD subTotalWritten;
		DWORD totalWritten = 0;
		DWORD numLeft = numBytes;
		while (numLeft > c1_16_BytesPerShot) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), c1_16_BytesPerShot, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
			numLeft -= subTotalWritten;
			Sleep(c1_16_SerialSleepTime);
		}
		if (numLeft > 0) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), numLeft, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
		}
		return (totalWritten == numBytes);
	}

	// Firmware other than 1.16
	DWORD numWritten;
	if (::WriteFile(m_SerialPort, data, numBytes, &numWritten, NULL) == FALSE) {
		return FALSE;
	}
	return (numWritten == numBytes);
}

/************************** DMusicTransmitter Class ******************************/

/****************************************
**
**	DMusicTransmitter::DMusicTransmitter()
**
**	@mfunc Constructor for DirectMusic Transmitter
**
*****************************************/
DMusicTransmitter::DMusicTransmitter() : DataTransmitter(),
	m_pIDirectMusic(NULL),
	m_pIDirectMusicPort(NULL),
	m_pIDirectMusicBuffer(NULL)
{
}

/****************************************
**
**	DMusicTransmitter::~DMusicTransmitter()
**
**	@mfunc Destructor for DirectMusic Transmitter
**
*****************************************/
DMusicTransmitter::~DMusicTransmitter()
{
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicBuffer);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicPort);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusic);
}

/****************************************
**
**	BOOL DMusicTransmitter::Initialize()
**
**	@mfunc Intialize the Direct Music Transmission path
**
**	@rdesc TRUE if initialization was successful, FALSE otherwise
**
*****************************************/
BOOL DMusicTransmitter::Initialize()
{
	// Case they are reinitializing
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicBuffer);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicPort);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusic);

	// Create the global IDirectMusic Interface
	HRESULT hr = ::CoCreateInstance(CLSID_DirectMusic, NULL, CLSCTX_INPROC, IID_IDirectMusic, (void**)&m_pIDirectMusic);
	if (FAILED(hr) || m_pIDirectMusic == NULL)
	{
		return FALSE;
	}

	// Enumerate and create the port when valid one is found
	DMUS_PORTCAPS portCaps;
	portCaps.dwSize = sizeof portCaps;
	DWORD dwPortIndex = 0;
	for (;;)
	{
		HRESULT hr = m_pIDirectMusic->EnumPort(dwPortIndex, &portCaps);
		if (FAILED(hr) || hr == S_FALSE)
		{	// Either we have failed or run out of ports
			return FALSE;
		}
		if (portCaps.dwClass == DMUS_PC_OUTPUTCLASS)
		{
			DMUS_PORTPARAMS portParams;
			portParams.dwSize = sizeof DMUS_PORTPARAMS;
			portParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS;
			portParams.dwChannelGroups = 1;
//			hr = m_pIDirectMusic->CreatePort(portCaps.guidPort, GUID_NULL, &portParams, &m_pIDirectMusicPort, NULL);
			hr = m_pIDirectMusic->CreatePort(portCaps.guidPort, &portParams, &m_pIDirectMusicPort, NULL);
			break;
		}
		dwPortIndex++;
	}

	// Create the buffer
	DMUS_BUFFERDESC dmbd;
	dmbd.dwSize = sizeof DMUS_BUFFERDESC;
	dmbd.dwFlags = 0;
//	dmbd.guidBufferFormat = GUID_KSMusicFormat;
	dmbd.guidBufferFormat = GUID_NULL;
	dmbd.cbBuffer = 256;
	hr = m_pIDirectMusic->CreateMusicBuffer(&dmbd, &m_pIDirectMusicBuffer, NULL);
	if (FAILED(hr) || m_pIDirectMusicBuffer == NULL)
	{
		return FALSE;
	}

	return TRUE;
}

/****************************************
**
**	BOOL DMusicTransmitter::Send(BYTE* pData, UINT ulByteCount)
**
**	@mfunc Sends bytes via DirectMusic to the stick
**
**	@rdesc TRUE if send was successful, FALSE otherwise
**
*****************************************/
BOOL DMusicTransmitter::Send
(
	BYTE* pData,		//@parm Data buffer to send
	UINT ulByteCount	//@parm Number of bytes in buffer to send
)
{
	// Do sanity checks
	if ((pData == NULL) || (m_pIDirectMusicPort == NULL) || (m_pIDirectMusicBuffer == NULL) || (ulByteCount == 0))
	{
		return FALSE;
	}

	// Check if we need to pack sysex or channel message
	if (pData[0] == 0xF0)
	{	// Create system exclusive
/*
		// Pack the sysex-message into the buffer
		HRESULT hr = m_pIDirectMusicBuffer->PackSysEx(0, 1, ulByteCount, pData);
		if (FAILED(hr))
		{	// Unable to pack the buffer
			return FALSE;
		}
*/	}
	else
	{	// Channel Message (fix intel backwards byte order)
		DWORD channelMessage = pData[0];
		if (ulByteCount > 1)
		{
			channelMessage |= pData[1] << 8;
			if (ulByteCount > 2)
			{
				channelMessage |= pData[2] << 16;
			}
		}

		// Pack the channel-message into the buffer
/*		HRESULT hr = m_pIDirectMusicBuffer->PackChannelMsg(0, 1, channelMessage);
		if (FAILED(hr))
		{	// Unable to pack the buffer
			return FALSE;
		}
*/	}

	// Send the buffer to the port
	HRESULT hr = m_pIDirectMusicPort->PlayBuffer(m_pIDirectMusicBuffer);
	if (FAILED(hr))
	{	// Unable to send the data across the port
		return FALSE;
	}

	return TRUE;
}


#if 0
/************************** PinTransmitter Class ******************************/

/******************************************************
**
** PinTransmitter::PinTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
PinTransmitter::PinTransmitter() : DataTransmitter(),
	m_UartFilter(INVALID_HANDLE_VALUE),
	m_MidiPin(INVALID_HANDLE_VALUE),
	m_MidiOutEvent(INVALID_HANDLE_VALUE)
{
}

/******************************************************
**
** PinTransmitter::~PinTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
PinTransmitter::~PinTransmitter()
{
	// Close the send event
	if (IsHandleValid(m_MidiOutEvent)) {
		::CloseHandle(m_MidiOutEvent);
		m_MidiOutEvent = NULL;
	}

	// Close the pin
	if (IsHandleValid(m_MidiPin)) {
		::CloseHandle(m_MidiPin);
		m_MidiPin = INVALID_HANDLE_VALUE;
	}

	// Close the Uart
	if (IsHandleValid(m_UartFilter)) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** PinTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL PinTransmitter::Initialize()
{
	// Load the ksUserLibrary and grab the create pin function
	HINSTANCE ksUserLib = ::LoadLibrary(TEXT("KsUser.dll"));
	if (ksUserLib == NULL) {
		return FALSE;
	}
	KSCREATEPIN pfCreatePin = (KSCREATEPIN)::GetProcAddress(ksUserLib, TEXT("KsCreatePin"));
	if (pfCreatePin == NULL) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Open the Uart
	m_UartFilter = ::CreateFile(UART_FILTER_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (m_UartFilter == INVALID_HANDLE_VALUE) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Create Overlapped event
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	// Get the number of pins
	KSP_PIN ksPinProp;
	::memset(&ksPinProp, 0, sizeof(ksPinProp));
	ksPinProp.Property.Set = KSPROPSETID_Pin;
	ksPinProp.Property.Id = KSPROPERTY_PIN_CTYPES;
	ksPinProp.Property.Flags = KSPROPERTY_TYPE_GET;
	DWORD numPins = 0;
	OverLappedPinIOCTL(overlapped, ksPinProp, &numPins, sizeof(numPins));

	// Check each pin for proper type, then try to create
	BOOL wasCreated = FALSE;
	for (UINT pinNum = 0; (pinNum < numPins) && (wasCreated == FALSE); pinNum++) {
		ksPinProp.PinId = pinNum;
		ksPinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
		KSPIN_DATAFLOW dataFlow = (KSPIN_DATAFLOW)0;
		if (OverLappedPinIOCTL(overlapped, ksPinProp, &dataFlow, sizeof(dataFlow)) == TRUE) {
			if (dataFlow == KSPIN_DATAFLOW_IN) {
				ksPinProp.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
				KSPIN_COMMUNICATION communication = KSPIN_COMMUNICATION_NONE;
				if (OverLappedPinIOCTL(overlapped, ksPinProp, &communication, sizeof(communication)) == TRUE) {
					if ((communication == KSPIN_COMMUNICATION_SINK) || (communication == KSPIN_COMMUNICATION_BOTH)) {
						wasCreated = CreatePinInstance(pinNum, pfCreatePin);
					}
				}
			}
		}
	}
	::FreeLibrary(ksUserLib);
	::CloseHandle(overlapped.hEvent);
	if (wasCreated == FALSE) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
		return FALSE;
	}
	return TRUE;
}

/******************************************************
**
** PinTransmitter::OverLappedPinIOCTL()
**
** returns: TRUE if able to proform Pin Property IOCTL
** @mfunc OverLappedPinIOCTL.
******************************************************/
BOOL PinTransmitter::OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize)
{
	// IOCTL the Property
	if (::DeviceIoControl(m_UartFilter, IOCTL_KS_PROPERTY, &ksPinProp, sizeof(ksPinProp), pData, dataSize, NULL, &overlapped) == TRUE) {
		return TRUE;
	}

	// Failed IOCTL check if more time is needed
	if (::GetLastError() != ERROR_IO_PENDING) {
		return FALSE;
	}

	// Do wait
	if (::WaitForSingleObject(overlapped.hEvent, 3000) == WAIT_OBJECT_0) {
		return TRUE;	// Waiting paid off
	}
	return FALSE;	// Grew tired of waiting
}

/******************************************************
**
** PinTransmitter::CreatePinInstance()
**
** returns: TRUE if able to create the requested pin instance
** @mfunc CreatePinInstance.
******************************************************/
BOOL PinTransmitter::CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin)
{
	// Set the pin format
	KSDATAFORMAT ksDataFormat;
	::memset(&ksDataFormat, 0, sizeof(ksDataFormat));
	ksDataFormat.FormatSize = sizeof(ksDataFormat);
	ksDataFormat.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
	ksDataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
	ksDataFormat.Specifier = KSDATAFORMAT_SPECIFIER_NONE;

	// Set the pin connection information
	KSPIN_CONNECT* pConnectionInfo = (KSPIN_CONNECT*) new BYTE[sizeof(KSPIN_CONNECT) + sizeof(ksDataFormat)];
	::memset(pConnectionInfo, 0, sizeof(KSPIN_CONNECT));
	pConnectionInfo->Interface.Set = KSINTERFACESETID_Standard;
	pConnectionInfo->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
	pConnectionInfo->Medium.Set = KSMEDIUMSETID_Standard;
	pConnectionInfo->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
	pConnectionInfo->PinId = pinNumber;
	pConnectionInfo->Priority.PriorityClass = KSPRIORITY_NORMAL;
	pConnectionInfo->Priority.PrioritySubClass  = 1;
	::memcpy(pConnectionInfo + 1, &ksDataFormat, sizeof(ksDataFormat));

	DWORD status = pfCreatePin(m_UartFilter, pConnectionInfo, FILE_WRITE_ACCESS, &m_MidiPin);
	delete[] pConnectionInfo;
	if (status != NO_ERROR) {
#ifdef _DEBUG
		TCHAR buff[256];
		wsprintf(buff, TEXT("Error Creating Pin: 0x%08X\r\n"), status);
		::OutputDebugString(buff);
#endif
		return FALSE;
	}

	SetPinState(KSSTATE_PAUSE);

	return TRUE;
}

/******************************************************
**
** PinTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL PinTransmitter::Send(BYTE* pData, UINT numBytes)
{
	if (!IsHandleValid(m_MidiPin)) {
		return FALSE;
	}

	BYTE musicData[c_LongMsgMax + sizeof(KSMUSICFORMAT)];
	::memset(musicData, 0, sizeof(musicData));
	((KSMUSICFORMAT*)musicData)->ByteCount = numBytes;
	::memcpy(((KSMUSICFORMAT*)musicData) + 1, pData, numBytes);

	KSSTREAM_HEADER ksStreamHeader;
	::memset(&ksStreamHeader, 0, sizeof(ksStreamHeader));
	ksStreamHeader.Size = sizeof(ksStreamHeader);
	ksStreamHeader.PresentationTime.Numerator = 1;
	ksStreamHeader.PresentationTime.Denominator = 1;
	ksStreamHeader.FrameExtent = sizeof(musicData);
	ksStreamHeader.DataUsed = sizeof KSMUSICFORMAT + numBytes;
	ksStreamHeader.Data = (void*)musicData;

	if (!IsHandleValid(m_MidiOutEvent)) {
		m_MidiOutEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = m_MidiOutEvent;


	SetPinState(KSSTATE_RUN);
	if (!DeviceIoControl(m_MidiPin, IOCTL_KS_WRITE_STREAM, NULL, 0,
							&ksStreamHeader, sizeof(ksStreamHeader), NULL, &overlapped)) {
		if (GetLastError() == ERROR_IO_PENDING) {
			::WaitForSingleObject(overlapped.hEvent, 3000);
		}
	}
	SetPinState(KSSTATE_PAUSE);
	return TRUE;
}

/******************************************************
**
** PinTransmitter::SetPinState()
**
** returns: Nothing
** @mfunc SetPinState.
**
******************************************************/
void PinTransmitter::SetPinState(KSSTATE state)
{
	if (!IsHandleValid(m_MidiPin)) {
		return;
	}

	KSPROPERTY ksProperty;
	::memset(&ksProperty, 0, sizeof(ksProperty));
	ksProperty.Set = KSPROPSETID_Connection;
	ksProperty.Id = KSPROPERTY_CONNECTION_STATE;
	ksProperty.Flags = KSPROPERTY_TYPE_SET;

	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (IsHandleValid(overlapped.hEvent)) {
		if( !DeviceIoControl(m_MidiPin, IOCTL_KS_PROPERTY, &ksProperty, sizeof ksProperty, &state, sizeof state, NULL, &overlapped )) {
			if (GetLastError() == ERROR_IO_PENDING) {
				WaitForSingleObject(overlapped.hEvent, 30000);
			}
		}
		::CloseHandle(overlapped.hEvent);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dtrans.h ===
//@doc
/******************************************************
**
** @module DTRANS.H | Definition file for DataTransmitter
**
** Description:
**		The Data Transmitters allow virtualization of the
**	actual media used for transmission of data to the FF Device
**		DataTransmitter - Base class that defines the functionality
**		SerialDataTransmitter - Transmitter for Serial (via CreateFile)
**
** Classes:
**		DataTransmitter
**		SerialDataTransmitter
**		PinTransmitter
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DTRANS_H__
#define	__DTRANS_H__

#ifdef DIRECTINPUT_VERSION
#undef DIRECTINPUT_VERSION
#endif
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dmusicc.h>

#ifndef override
#define override
#endif

//
// @class DataTransmitter class
//
class DataTransmitter
{
	//@access Constructor
	protected:
		//@cmember constructor
		DataTransmitter() {};
	//@access Destructor
	public:
		//@cmember destructor
		virtual ~DataTransmitter() {};

	//@access Member functions
	public:
		virtual BOOL Initialize() { return FALSE; }

		virtual BOOL Send(BYTE* data, UINT numBytes) { return FALSE; }
		virtual BOOL ReceiveData(BYTE* data, UINT numBytes) { return FALSE; }
		virtual HANDLE GetCOMMHandleHack() const { return NULL; }
		virtual void StopAutoClose() {}; // Temporary hack to avoid closing own handle (for backdoor serial)
		virtual ULONG GetSerialPortHack() { return 0; }
};

//
// @class SerialDataTransmitter class
//
class SerialDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialDataTransmitter();
		//@cmember destructor
		override ~SerialDataTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		override  HANDLE GetCOMMHandleHack() const { return m_SerialPort; }
		override void StopAutoClose() { m_SerialPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return m_SerialPortIDHack; }
		//@access private data members
	private:
		HANDLE m_SerialPort;
		ULONG m_SerialPortIDHack;
};


/************************************************************************
**
**	@class DMusicTransmitter |
**		This transmitter uses the IDirectMusic Interface to send data
**		to the joystick.
**
*************************************************************************/
class DMusicTransmitter :
	public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DMusicTransmitter();
		//@cmember destructor
		override ~DMusicTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* pData, UINT ulByteCount);

		//@access private data members
	private:
		IDirectMusic* m_pIDirectMusic;
		IDirectMusicPort* m_pIDirectMusicPort;
		IDirectMusicBuffer* m_pIDirectMusicBuffer;
};

#if 0		// Fix pin later

typedef DWORD (WINAPI* KSCREATEPIN)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, HANDLE*);

//
// @class PinTransmitter class
//
class PinTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		PinTransmitter();
		//@cmember destructor
		override ~PinTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		//@access private data members
	private:
		BOOL CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin);
		BOOL OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize);
		void SetPinState(KSSTATE state);

		HANDLE m_UartFilter;
		HANDLE m_MidiPin;
		HANDLE m_MidiOutEvent;
};

#endif

#endif	__DTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dx_map.hpp ===
/****************************************************************************

    MODULE:     	DX_MAP.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Mapper for converting SWForce FFD_ to DirectInput Force
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	14-Feb-97       MEA     original
        
****************************************************************************/
#ifndef _DX_MAP_SEEN
#define _DX_MAP_SEEN
#include <windows.h>
#include "dinput.h"
#include "dinputd.h"


// Diagnostics Counters
typedef struct _DIAG_COUNTER
{
	ULONG			m_NACKCounter;		// For Debugging, how many NACKS
	ULONG			m_LongMsgCounter;  	// How many SysEx messages
	ULONG			m_ShortMsgCounter;	// How many 3 byte Short messages
	ULONG			m_RetryCounter;		// Number of retries
} DIAG_COUNTER, *PDIAG_COUNTER;

//
// --- Mapping from DX to SWForce FFD
//

typedef struct IDirectInputEffect	 *PSWEFFECT;  
typedef struct IDirectInputEffect	**PPSWEFFECT;  

#define SW_NUMBER_OF_BUTTONS 9

#define DNHANDLE	USHORT		// Download Effect Handle type
#define PDNHANDLE	DNHANDLE *	// Pointer

#define MIN_ANGLE			0
#define MAX_ANGLE			36000
#define MIN_FORCEOUTPUTRATE 1
#define MIN_GAIN			1
#define MAX_GAIN			10000
#define MAX_FORCE			10000
#define MIN_FORCE			-10000
#define MIN_TIME_PERIOD		1
#define MAX_TIME_PERIOD		4294967296L	// 4096 * 10^^6 usecs
#define MAX_POSITION		10000
#define MIN_POSITION		-10000
#define MAX_CONSTANT		10000
#define MIN_CONSTANT		-10000

#define SCALE_GAIN			100		// DX is +/- 10000, SWForce in +/-100
#define SCALE_TIME			1000	// DX is in microseconds, SWForce in msec
#define	SCALE_POSITION		100		// DX is +/- 10000, SWForce in +/- 100+
#define	SCALE_CONSTANTS		100		// DX is +/- 10000, SWForce in +/- 100+
#define SCALE_DIRECTION		100		// DX is 0 to 35900, SWForce is 0 to 359

// 
// --- Default Values
//
#define	DEFAULT_OFFSET			0
#define DEFAULT_ATTACK_LEVEL	0
#define DEFAULT_ATTACK_TIME		0
#define DEFAULT_SUSTAIN_LEVEL	10000
#define DEFAULT_FADE_LEVEL		0
#define DEFAULT_FADE_TIME		0

// PlaybackEffect Command Modes
#define PLAY_SUPERIMPOSE	0x01
#define PLAY_SOLO			0x02
#define PLAY_STORE			0x04	// Store only
#define PLAY_UPDATE			0x08
//reserved					0x10
#define PLAY_LOOP			0x20
#define PLAY_FOREVER		0x40
#define PLAY_STOP			0x80
#define PLAY_MODE_MASK		0xff

#define DEV_SHUTDOWN		DEV_RESET

//
// --- Effect Status
//
#define ES_HOST			0x00000001L	// Effect is in HOST memory
#define ES_DOWNLOADED	0x00000002L	// Effect is downloaded
#define ES_STOPPED		0x00000004L	// Effect is stopped
#define ES_PLAYING		0x00000008L	// Effect is playing

//
// --- Axis Masks
//
#define X_AXIS		0x01
#define Y_AXIS		0x02
#define Z_AXIS		0x04
#define ROT_X_AXIS	0x08
#define ROT_Y_AXIS	0x10
#define ROT_Z_AXIS	0x20

//
// --- Button Masks
//
#define BUTTON1_PLAY 	0x00000001L	// Trigger button (usually)
#define BUTTON2_PLAY	0x00000002L
#define BUTTON3_PLAY	0x00000004L
#define BUTTON4_PLAY	0x00000008L
#define BUTTON5_PLAY	0x00000010L
#define BUTTON6_PLAY	0x00000020L
#define BUTTON7_PLAY	0x00000040L
#define BUTTON8_PLAY	0x00000080L
#define BUTTON9_PLAY	0x00000100L
#define BUTTON10_PLAY	0x00000200L
#define BUTTON11_PLAY	0x00000400L
#define BUTTON12_PLAY	0x00000800L
#define BUTTON13_PLAY	0x00001000L
#define BUTTON14_PLAY	0x00002000L
#define BUTTON15_PLAY	0x00004000L
#define BUTTON16_PLAY	0x00008000L	// . . . 16th button

// 
// --- Force Feedback Device State
//
typedef struct _SWDEVICESTATE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0 = Hands Off, 1 = Hands On
	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
} SWDEVICESTATE, *PSWDEVICESTATE;


#define MAX_SIZE_SNAME	64

//
//
// --- Force Feedback Device Capabilities
//
typedef struct _FFDEVICEINFO {
	ULONG	m_Bytes;		// Size of this structure
	TCHAR	m_ProductName[MAX_SIZE_SNAME];	// Device Name 64 chars
	TCHAR	m_ManufacturerName[MAX_SIZE_SNAME]; // Manufacturer
	ULONG	m_ProductVersion;	// Device Product Version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceDriverVersion;	// Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceFirmwareVersion; // Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_Interface;		// HIWORD: OUTPUT:HID_INTERFACE||VJOYD_INTERFACE 
								// LOWORD: INPUT: HID_INTERFACE||VJOYD_INTERFACE 
	ULONG	m_MaxSampleRate;	// Maximum Force output rate
	ULONG	m_MaxMemory;		// Max amount of RAM
	ULONG	m_NumberOfSensors;	// SENSOR_AXIS total in the device (INPUT)
	ULONG	m_NumberOfAxes;		// ACTUATOR_AXIS total in the device (OUTPUT)
	ULONG	m_EffectsCaps;		// Built-in Effects capability
	ULONG	m_Reserved;			// 
	ULONG	m_JoystickID;		// VJOYD Joystick ID (0-based)
	ULONG	m_ExtraInfo;		// For future stuff
} FFDEVICEINFO, *PFFDEVICEINFO;


//
// --- AXISCAPS Sensor or Actuator Axes capabilities
//
typedef struct _AXISCAPS {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bit position for Actuator or Sensor Axes
	ULONG	m_LogicalExtentMin;	// Minimum logical extent
	ULONG	m_LogicalExtentMax;	// Maximum logical extent
	ULONG	m_PhysicalExtentMin;// Minimum physical extent
	ULONG	m_PhysicalExtentMax;// Maximum Physical extent
	ULONG	m_Units;			// HID style physical SI units
	ULONG	m_Resolution;		// Position increments per physical SI unit
	ULONG	m_ServoLoopRate;	// Loop rate in cycles/sec
} AXISCAPS, *PAXISCAPS;


typedef struct _FORCE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_DirectionAngle2D;	// From X-Axis = theta1
	LONG	m_DirectionAngle3D;	// From Z-Axis = (theta2, note: theta1+theta2)>= 90
	LONG	m_ForceValue;		// Actual force in +/- 100%
} FORCE, *PFORCE;


typedef struct _FORCECONTEXT {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_Position;			// Position along the Axis -32768 to +32767
	LONG	m_Velocity;			// Velocity in -32768 to +32767 units TBD
	LONG	m_Acceleration;		// Acceleration in -32768 to +32767 units TBD
} FORCECONTEXT, *PFORCECONTEXT;


// The following are Type Specific parameters structures
//
//

//
// -- an Effect structure
//
typedef struct _EFFECT {
	ULONG	m_Bytes;			// Size of this structure
	TCHAR	m_Name[MAX_SIZE_SNAME];
	ULONG	m_Type;				// Major Effect type, e.g. EF_BEHAVIOR, etc..
	ULONG	m_SubType;			// Minor Effect type, e.g. SE_xxx,BE_xxx,UD_xxx
	ULONG	m_AxisMask;			// Bitmask for axis to send the effect, 
								//   If NULL, use value from Device Capabilities
	ULONG	m_DirectionAngle2D;	// From Y-Axis (cone) = theta1
	ULONG	m_DirectionAngle3D;	// From Z-Axis (cone) = theta2
								//  note: theta1+theta2)>= 90
	ULONG	m_Duration;			// Duration in ms., 00 = infinite
	ULONG	m_ForceOutputRate;	// Sample Rate for Force Data output
	ULONG	m_Gain;				// Gain to apply, normally this is set
								// to 100. Gain is 1 to  100.
	ULONG	m_ButtonPlayMask;	// Mask to indicate which button to assign Effect
} EFFECT, *PEFFECT;


//
// --- ENVELOPE
//
// Note:  There are two types of Envelope control, using PERCENTAGE,
// and using TIME.  
// PERCENTAGE defines Envelope using Percentage for the Attack,Sustain and Decay
//
// TIME Envelope type will require the time in 1 millisecond increment, and
// m_StartAmp is the Amplitude to start the waveform, while m_EndAmp is used
// to decay or end the waveform. m_SustainAmp is used to set Sustain amplitude
//
#define PERCENTAGE	0x00000000	// Envelope is in percentage values
#define TIME		0x00000001	// Envelope is in 1 millisecond time increments

//For PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Note: Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline -->>> (m_MaxAmp - m_MinAmp)/2
// m_EndAmp = m_StartAmp;
//
//Valid Ranges:
//PERCENTAGE mode:  
//		m_Attack, m_Sustain, m_Decay = 1 to 100%, and must sum up to 100%
//TIME mode:
//		m_Attack = 0 to 32,768 ms,
//      m_Sustain = 0 to 32,768 ms
//      m_Decay = 0 to 32,768 ms.   (All are in 1 ms increments).
//Note: For an infinite duration (value in m_Duration = 0), the Effect will 
//      never decay and m_Decay is ignored.
//
// Envelopes are only valid for Synthesized Waveforms (SE_XXX) type
//
//
typedef struct _ENVELOPE {
	ULONG	m_Bytes;		// Size of this structure
	ULONG	m_Type;			// PERCENTAGE || TIME
	ULONG	m_Attack;		// Rise time to Sustain Value
							//  in % of Duration, or in msec Time
	ULONG	m_Sustain;		// Sustain time at Sustain Value in % Duration,
							//  or in msec Time
	ULONG	m_Decay;		// Decay time to Minimum Value,
							//  in % of Duration, or in msec Time
	ULONG	m_StartAmp;		// Amplitude to start the Envelope, from baseline		
	ULONG	m_EndAmp;		// Amplitude to End the Envelope, from baseline
	ULONG	m_SustainAmp;	// Amplitude to Sustain the Envelope, from baseline
} ENVELOPE, *PENVELOPE;


//
// ---	EF_BEHAVIOR = {BE_SPRINGxx||BE_DAMPERxx||BE_INTERTIAxx||BE_FRICTIONxx
//						||BE_WALL||BE_DELAY}
//  Note: Behavioral Effects do not have an Envelope.
//
typedef struct _BE_SPRING_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_Kconstant;		// K constant
	LONG	m_AxisCenter;		// Center of the function
} BE_SPRING_PARAM, *PBE_SPRING_PARAM;

typedef struct _BE_SPRING_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_XKconstant;		// X_Axis K constant
	LONG	m_XAxisCenter;		// X_Axis Center
	LONG	m_YKconstant;		// Y_Axis K constant
	LONG	m_YAxisCenter;		// Y_Axis Center
} BE_SPRING_2D_PARAM, *PBE_SPRING_2D_PARAM;

typedef struct _BE_DAMPER_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Bconstant;		// B constant
	LONG	m_V0;				// Initial Velocity
} BE_DAMPER_PARAM, *PBE_DAMPER_PARAM;

typedef struct _BE_DAMPER_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XBconstant;		// X_AXIS B constant
	LONG	m_XV0;				// X_AXIS Initial Velocity
	LONG	m_YBconstant;		// Y_Axis B constant
	LONG	m_YV0;				// Y_AXIS Initial Velocity
} BE_DAMPER_2D_PARAM, *PBE_DAMPER_2D_PARAM;

typedef struct _BE_INERTIA_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_Mconstant;		// M constant
	LONG	m_A0;				// Initial Acceleration
} BE_INERTIA_PARAM, *PBE_INERTIA_PARAM;

typedef struct _BE_INERTIA_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XMconstant;		// X_AXIS M constant
	LONG	m_XA0;				// X_AXIS Initial Acceleration
	LONG	m_YMconstant;		// Y_AXIS M constant
	LONG	m_YA0;				// Y_AXIS Initial Acceleration
} BE_INERTIA_2D_PARAM, *PBE_INERTIA_2D_PARAM;

typedef struct _BE_FRICTION_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Fconstant;        // F Friction constant
} BE_FRICTION_PARAM, *PBE_FRICTION_PARAM;

typedef struct _BE_FRICTION_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XFconstant;		// X_AXIS F Friction constant
	LONG	m_YFconstant;		// Y_AXIS F Friction constant
} BE_FRICTION_2D_PARAM, *PBE_FRICTION_2D_PARAM;

//
// --- WALL Effect
//
#define WALL_INNER			0	// Wall material:from center to Wall Distance
#define WALL_OUTER			1	// Wall material:greater than Wall Distance

typedef struct _BE_WALL_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG 	m_WallType;			// WALL_INNER or WALL_OUTER
	LONG	m_WallConstant;		// in +/- 10000%
	ULONG	m_WallAngle;		// 0 to 35900
	ULONG	m_WallDistance;		// Distance from Wall face normal to center. 0 to 100
} BE_WALL_PARAM, *PBE_WALL_PARAM;

//
// ---	DELAY Effect
//
// Use EFFECT.m_SubType = BE_DELAY
// This has no type specific parameters.
//

//
// ---	EF_SYNTHESIZED = {  SE_CONSTANT_FORCE||SE_SINE||SE_SQUARE||SE_RAMPUP
//						  ||SE_RAMPDN||SE_TRIANGLE||SE_SAWTOOTH}
typedef struct _SE_PARAM {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_Freq;				// Frequency in Hz units
	ULONG	m_SampleRate;		// Sample rate in Hz units
	LONG	m_MaxAmp;			// Maximum Amplitude in Force units
	LONG	m_MinAmp;			// Minimum Amplitude in Force units
} SE_PARAM, *PSE_PARAM;

//
// ---	EF_USER_DEFINED = { Waveform defined by the user }
//
// Subtype: UD_WAVEFORM
typedef struct _UD_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_NumVectors;		// Number of entries in the Array
	LONG *	m_pForceData;		// Ptr to an array of LONG Force values.
} UD_PARAM, *PUD_PARAM;

//
// { Process List defined by the user }
// Subtype: PL_CONCATENATE || PL_SUPERIMPOSE
//
typedef struct _PL_PARAM {
	ULONG		m_Bytes;		// Size of this structure
	ULONG		m_NumEffects;	// # of Effects in list
	PPSWEFFECT	m_pProcessList;	// Ptr to a list of ISWEffect pointers
} PL_PARAM, *PPL_PARAM;

//
// ---	EF_ROM_EFFECT = { ROM Built-in Waveforms defined by the OEM }
//
// This has no type specific parameters.
// Subtypes:  See further below

#define DEFAULT_ROM_EFFECT_GAIN		100		// Set dwGain to this for Default
											// ROM Effect gain
#define DEFAULT_ROM_EFFECT_DURATION	1000	// Set dwDuration to this for Default
											// ROM Effect Duration
#define DEFAULT_ROM_EFFECT_OUTPUTRATE	1000	// Set dwSampleRate to this for 
												// Default ROM Effect output rate

//
// ---	EF_VFX_EFFECT = { FRC file effects }
//
// Subtypes:  none

#define VFX_FILENAME	0L
#define VFX_BUFFER		1L

#define DEFAULT_VFX_EFFECT_GAIN			10000	// Set dwGain to this for Default
												// VFX Effect gain
#define DEFAULT_VFX_EFFECT_DIRECTION	0		// Set polar direction to this for Default
												// VFX Effect direction
#define DEFAULT_VFX_EFFECT_DURATION		1000	// Set dwDuration to this for Default
												// VFX Effect duration

typedef struct _VFX_PARAM
{
	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
} VFX_PARAM, *PVFX_PARAM;

//
// --- RTC Spring Effect Structure
//
typedef struct _RTCSPRING_PARAM{
	ULONG	m_Bytes;				// Size of this structure
	LONG	m_XKConstant;			// K Constant for X-axis
	LONG	m_YKConstant;			// "   "      for Y-axis
	LONG	m_XAxisCenter;			// RTC Spring center for X-axis
	LONG	m_YAxisCenter;			// "   "      "      for Y-axis
	LONG	m_XSaturation;			// Saturation for X-axis
	LONG	m_YSaturation;			// "          for Y-axis
	LONG	m_XDeadBand;			// Deadband for X-axis
	LONG	m_YDeadBand;			// "        for Y-axis
} RTCSPRING_PARAM, *PRTCSPRING_PARAM;


//
// --- Major Type: Effects categories
//
#define	EF_BEHAVIOR		1L	// Behavioral Effect, e.g. Spring, Damper, etc.
#define	EF_SYNTHESIZED	2L	// Synthesized Effect, e.g. Sine, Square
#define EF_USER_DEFINED	3L	// User Defined Waveform
#define EF_ROM_EFFECT	4L	// ROM Built-in Waveforms defined by the OEM 
#define EF_VFX_EFFECT	5L	// FRC file effects
#define EF_RAW_FORCE	6L	// For PutRawForce
#define EF_RTC_SPRING	7L	// Permanent RTC Spring

//
// --- Subtypes for EF_BEHAVIOR
//
#define BE_SPRING	   	1L
#define BE_SPRING_2D   	2L
#define BE_DAMPER	   	3L
#define BE_DAMPER_2D   	4L
#define BE_INERTIA	   	5L
#define BE_INERTIA_2D  	6L
#define BE_FRICTION	   	7L
#define BE_FRICTION_2D	8L
#define BE_WALL			9L
#define BE_DELAY		10L
//
// --- DXFF map
//
#define ID_SPRING			(BE_SPRING 			+ (EF_BEHAVIOR<<16))
#define ID_DAMPER			(BE_DAMPER 			+ (EF_BEHAVIOR<<16))
#define ID_INERTIA			(BE_INERTIA 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION			(BE_FRICTION 		+ (EF_BEHAVIOR<<16))
// --- SWForce extensions
#define ID_SPRING_2D		(BE_SPRING_2D 		+ (EF_BEHAVIOR<<16))
#define ID_DAMPER_2D		(BE_DAMPER_2D 		+ (EF_BEHAVIOR<<16))
#define ID_INERTIA_2D		(BE_INERTIA_2D 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION_2D		(BE_FRICTION_2D 	+ (EF_BEHAVIOR<<16))
#define ID_WALL				(BE_WALL 			+ (EF_BEHAVIOR<<16))
#define ID_DELAY			(BE_DELAY 			+ (EF_BEHAVIOR<<16))

//
// --- Subtypes for EF_SYNTHESIZE
//								
#define SE_CONSTANT_FORCE	101L
#define SE_SINE				102L
#define SE_COSINE			103L
#define	SE_SQUARELOW		104L
#define	SE_SQUAREHIGH		105L
#define	SE_RAMPUP  			106L
#define	SE_RAMPDOWN			107L
#define	SE_TRIANGLEUP		108L
#define	SE_TRIANGLEDOWN		109L
#define	SE_SAWTOOTHUP		110L
#define	SE_SAWTOOTHDOWN		111L
//
// --- DXFF map
//
#define ID_CONSTANTFORCE	(SE_CONSTANTFORCE 	+ (EF_SYNTHESIZED<<16))
#define ID_RAMPFORCE		(SE_RAMPUP  	  	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARE			(SE_SQUARELOW	  	+ (EF_SYNTHESIZED<<16))
#define ID_SINE				(SE_SINE		  	+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLE			(SE_TRIANGLEUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHUP		(SE_SAWTOOTHUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHDOWN		(SE_SAWTOOTHDOWN	+ (EF_SYNTHESIZED<<16))
#define ID_RAMP				(SE_RAMPUP		  	+ (EF_SYNTHESIZED<<16))
//
// --- SWForce extensions
//
#define ID_COSINE			(SE_COSINE		 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUAREHIGH		(SE_SQUAREHIGH	 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARELOW		(SE_SQUARELOW		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPUP  			(SE_RAMPUP  		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPDOWN			(SE_RAMPDOWN		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEUP		(SE_TRIANGLEUP		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEDOWN		(SE_TRIANGLEDOWN	+ (EF_SYNTHESIZED<<16))

//
// --- Subtypes for EF_USER_DEFINED
//
#define UD_WAVEFORM			201L
#define PL_CONCATENATE		202L
#define PL_SUPERIMPOSE		203L
//
// --- DXFF map
//
#define ID_CUSTOMFORCE		(UD_WAVEFORM	 	+ (EF_USER_DEFINED<<16))
//
// --- SWForce extensions
//
#define ID_PL_CONCATENATE	(PL_CONCATENATE 	+ (EF_USER_DEFINED<<16))
#define ID_PL_SUPERIMPOSE	(PL_SUPERIMPOSE 	+ (EF_USER_DEFINED<<16))

//
// --- Subtypes for EF_ROM_EFFECT
// starts at 0x12D
#define RE_ROMID_START	301L
#define	RE_ROMID1		(RE_ROMID_START     )	
#define	RE_ROMID2		(RE_ROMID_START +  1)		
#define	RE_ROMID3		(RE_ROMID_START +  2)			
#define	RE_ROMID4		(RE_ROMID_START +  3)		
#define	RE_ROMID5		(RE_ROMID_START +  4)		
#define	RE_ROMID6		(RE_ROMID_START +  5)	
#define RE_ROMID7		(RE_ROMID_START +  6)
#define	RE_ROMID8		(RE_ROMID_START +  7)	
#define	RE_ROMID9		(RE_ROMID_START +  8)		
#define	RE_ROMID10		(RE_ROMID_START +  9)			
#define	RE_ROMID11		(RE_ROMID_START + 10)		
#define	RE_ROMID12		(RE_ROMID_START + 11)		
#define	RE_ROMID13		(RE_ROMID_START + 12)	
#define RE_ROMID14		(RE_ROMID_START + 13)
#define	RE_ROMID15		(RE_ROMID_START + 14)		
#define	RE_ROMID16		(RE_ROMID_START + 15)	
#define RE_ROMID17		(RE_ROMID_START + 16)
#define	RE_ROMID18		(RE_ROMID_START + 17)	
#define	RE_ROMID19		(RE_ROMID_START + 18)
#define	RE_ROMID20		(RE_ROMID_START + 19)			
#define	RE_ROMID21		(RE_ROMID_START + 20)		
#define	RE_ROMID22		(RE_ROMID_START + 21)		
#define	RE_ROMID23		(RE_ROMID_START + 22)	
#define RE_ROMID24		(RE_ROMID_START + 23)
#define	RE_ROMID25		(RE_ROMID_START + 24)		
#define	RE_ROMID26		(RE_ROMID_START + 25)	
#define RE_ROMID27		(RE_ROMID_START + 26)
#define	RE_ROMID28		(RE_ROMID_START + 27)
#define	RE_ROMID29		(RE_ROMID_START + 28)
#define	RE_ROMID30		(RE_ROMID_START + 29)
#define RE_ROMID31		(RE_ROMID_START + 30)
#define RE_ROMID32		(RE_ROMID_START + 31)
#if 0
#define	RE_ROMID33		(RE_ROMID_START + 32)	
#define RE_ROMID34		(RE_ROMID_START + 33)
#define	RE_ROMID35		(RE_ROMID_START + 34)		
#define	RE_ROMID36		(RE_ROMID_START + 35)	
#define RE_ROMID37		(RE_ROMID_START + 36)
#define	RE_ROMID38		(RE_ROMID_START + 37)	
#define	RE_ROMID39		(RE_ROMID_START + 38)
#define	RE_ROMID40		(RE_ROMID_START + 39)			
#define	RE_ROMID41		(RE_ROMID_START + 40)		
#define	RE_ROMID42		(RE_ROMID_START + 41)		
#define	RE_ROMID43		(RE_ROMID_START + 42)	
#define RE_ROMID44		(RE_ROMID_START + 43)
#define	RE_ROMID45		(RE_ROMID_START + 44)		
#define	RE_ROMID46		(RE_ROMID_START + 45)	
#define RE_ROMID47		(RE_ROMID_START + 46)
#define	RE_ROMID48		(RE_ROMID_START + 47)
#define	RE_ROMID49		(RE_ROMID_START + 48)
#define	RE_ROMID50		(RE_ROMID_START + 49)
#define RE_ROMID51		(RE_ROMID_START + 50)
#define RE_ROMID52		(RE_ROMID_START + 51)
#define	RE_ROMID53		(RE_ROMID_START + 52)	
#define RE_ROMID54		(RE_ROMID_START + 53)
#define	RE_ROMID55		(RE_ROMID_START + 54)		
#define	RE_ROMID56		(RE_ROMID_START + 55)	
#define RE_ROMID57		(RE_ROMID_START + 56)
#define	RE_ROMID58		(RE_ROMID_START + 57)	
#define	RE_ROMID59		(RE_ROMID_START + 58)
#define	RE_ROMID60		(RE_ROMID_START + 59)			
#define	RE_ROMID61		(RE_ROMID_START + 60)		
#define	RE_ROMID62		(RE_ROMID_START + 61)		
#define	RE_ROMID63		(RE_ROMID_START + 62)	
#define RE_ROMID64		(RE_ROMID_START + 63)
#endif
#define MAX_ROM_EFFECTS (RE_ROMID32 - RE_ROMID_START + 1)

//
// --- DXFF map
//
#define ID_RANDOM_NOISE				(RE_ROMID1  + (EF_ROM_EFFECT<<16))
#define ID_AIRCRAFT_CARRIER_TAKEOFF	(RE_ROMID2	+ (EF_ROM_EFFECT<<16))
#define ID_BASKETBALL_DRIBBLE		(RE_ROMID3	+ (EF_ROM_EFFECT<<16))
#define ID_CAR_ENGINE_IDLE			(RE_ROMID4	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IDLE			(RE_ROMID5	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IN_ACTION		(RE_ROMID6	+ (EF_ROM_EFFECT<<16))
#define ID_DIESEL_ENGINE_IDLE		(RE_ROMID7	+ (EF_ROM_EFFECT<<16))
#define ID_JUMP						(RE_ROMID8	+ (EF_ROM_EFFECT<<16))
#define ID_LAND						(RE_ROMID9	+ (EF_ROM_EFFECT<<16))
#define ID_MACHINEGUN				(RE_ROMID10 + (EF_ROM_EFFECT<<16))
#define ID_PUNCHED					(RE_ROMID11 + (EF_ROM_EFFECT<<16))
#define ID_ROCKET_LAUNCH			(RE_ROMID12 + (EF_ROM_EFFECT<<16))
#define ID_SECRET_DOOR				(RE_ROMID13 + (EF_ROM_EFFECT<<16))
#define ID_SWITCH_CLICK				(RE_ROMID14 + (EF_ROM_EFFECT<<16))
#define ID_WIND_GUST				(RE_ROMID15 + (EF_ROM_EFFECT<<16))
#define ID_WIND_SHEAR				(RE_ROMID16 + (EF_ROM_EFFECT<<16))
#define ID_PISTOL					(RE_ROMID17 + (EF_ROM_EFFECT<<16))
#define ID_SHOTGUN					(RE_ROMID18 + (EF_ROM_EFFECT<<16))
#define ID_LASER1					(RE_ROMID19 + (EF_ROM_EFFECT<<16))
#define ID_LASER2					(RE_ROMID20 + (EF_ROM_EFFECT<<16))
#define ID_LASER3					(RE_ROMID21 + (EF_ROM_EFFECT<<16))
#define ID_LASER4					(RE_ROMID22 + (EF_ROM_EFFECT<<16))
#define ID_LASER5					(RE_ROMID23 + (EF_ROM_EFFECT<<16))
#define ID_LASER6					(RE_ROMID24 + (EF_ROM_EFFECT<<16))
#define ID_OUT_OF_AMMO				(RE_ROMID25 + (EF_ROM_EFFECT<<16))
#define ID_LIGHTNING_GUN			(RE_ROMID26 + (EF_ROM_EFFECT<<16))
#define ID_MISSILE					(RE_ROMID27 + (EF_ROM_EFFECT<<16))
#define ID_GATLING_GUN				(RE_ROMID28 + (EF_ROM_EFFECT<<16))
#define ID_SHORT_PLASMA				(RE_ROMID29 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON1			(RE_ROMID30 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON2			(RE_ROMID31 + (EF_ROM_EFFECT<<16))
#define ID_CANNON					(RE_ROMID32 + (EF_ROM_EFFECT<<16))
//#define ID_FLAME_THROWER			(RE_ROMID33 + (EF_ROM_EFFECT<<16))
//#define ID_BOLT_ACTION_RIFLE		(RE_ROMID34 + (EF_ROM_EFFECT<<16))
//#define ID_CROSSBOW					(RE_ROMID35 + (EF_ROM_EFFECT<<16))



#endif // of ifdef _DX_MAP_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffdevice.cpp ===
//@doc
/******************************************************
**
** @module FFDEVICE.CPP | Implementation file for FFDevice class
**
** Description:
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
**			20-Mar-99	waltw	Added dwDeviceID to SetFirmwareVersion
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#include "FFDevice.h"
#include "Midi_obj.hpp"
#include "DTrans.h"
#include "joyregst.hpp"

extern CJoltMidi* g_pJoltMidi;

ForceFeedbackDevice g_ForceFeedbackDevice;

/******************************************************
**
** ForceFeedbackDevice::ForceFeedbackDevice()
**
** @mfunc Constructor.
**
******************************************************/
ForceFeedbackDevice::ForceFeedbackDevice() :
	m_FirmwareAckNackValues(0),
	m_FirmwareVersionMajor(0),
	m_FirmwareVersionMinor(0),
	m_DriverVersionMajor(0),
	m_DriverVersionMinor(0)
{
	m_OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&m_OSVersion);
}

/******************************************************
**
** ForceFeedbackDevice::DetectHardware()
**
** @mfunc DetectHardware.
**
******************************************************/
BOOL ForceFeedbackDevice::DetectHardware()
{
	if (NULL == g_pJoltMidi) return FALSE;
	return g_pJoltMidi->QueryForJolt();
}

/******************************************************
**
** ForceFeedbackDevice::SetFirmwareVersion(DWORD major, DWORD minor)
**
** @mfunc SetFirmwareVersion.
**
******************************************************/
void ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
{
	m_FirmwareVersionMajor = major;
	m_FirmwareVersionMinor = minor;

	m_FirmwareAckNackValues = GetAckNackMethodFromRegistry(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
**
** @mfunc SetDriverVersion.
**
******************************************************/
void ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
{
	if ((major == 0xFFFFFFFF) && (minor == 0xFFFFFFFF)) {	// Check for version 1.0 driver version error
		m_DriverVersionMajor = 1;
		m_DriverVersionMinor = 0;
	} else {
		m_DriverVersionMajor = major;
		m_DriverVersionMinor = minor;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffdevice.h ===
//@doc
/******************************************************
**
** @module FFDEVICE.H | Definition file for FFDevice class
**
** Description:
**		This is the generic FF device. Independant of
**	Firmawate and how data reaches the device
**	This first implementation uses the old CJoltMidi to
**	minimize new code.
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__FFDEVICE_H__
#define	__FFDEVICE_H__

#ifdef DIRECTINPUT_VERSION
#undef DIRECTINPUT_VERSION
#endif
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>

// Currently there is some extra stuff in here, that should be part of other objects

//
// @class ForceFeedbackDevice class
//
class ForceFeedbackDevice
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		ForceFeedbackDevice();
		//@cmember destructor
		~ForceFeedbackDevice() {};

		BOOL DetectHardware();

		DWORD GetPlatform() const { return m_OSVersion.dwPlatformId; }
		DWORD GetPlatformMajorVersion() const { return m_OSVersion.dwMajorVersion; }
		DWORD GetPlatformMinorVersion() const { return m_OSVersion.dwMinorVersion; }
		DWORD GetOSBuildNumber() const { return m_OSVersion.dwBuildNumber; }

		BOOL IsOSNT5() const { return ((m_OSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) && (m_OSVersion.dwMajorVersion == 5)); }

		void SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor);
		DWORD GetFirmwareVersionMajor() const { return m_FirmwareVersionMajor; }
		DWORD GetFirmwareVersionMinor() const { return m_FirmwareVersionMinor; }

		USHORT GetAckNackMethod(USHORT methodIndex) const { return USHORT((m_FirmwareAckNackValues >> methodIndex) & 0x00000003); }

		DWORD GetDriverVersionMajor() const { return m_DriverVersionMajor; }
		DWORD GetDriverVersionMinor() const { return m_DriverVersionMinor; }
		void SetDriverVersion(DWORD major, DWORD minor);

		//@access private data members
	private:
		OSVERSIONINFO m_OSVersion;
		DWORD m_FirmwareVersionMajor;
		DWORD m_FirmwareVersionMinor;
		DWORD m_FirmwareAckNackValues;
		DWORD m_DriverVersionMajor;
		DWORD m_DriverVersionMinor;
};


extern ForceFeedbackDevice g_ForceFeedbackDevice;

#endif	__FFDEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\critsec.h ===
//@doc
/******************************************************
**
** @module CRITSEC.H | Header file for CriticalSection class
**
** Description:
**		Critical Section - Encapsulation of CriticalSection object
**
** History:
**	Created 03/02/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__CRITSEC_H__
#define	__CRITSEC_H__

#include <winbase.h>
#include <winuser.h>

// Assumption macros (I don't like asserts msg boxes)
#ifdef _DEBUG
	inline void _myassume(BOOL condition, const char* fname, int line)
	{
		if (!condition) {
			char buff[256];
			::wsprintf(buff, "SW_EFFECT.DLL: Assumption Failed in %s on line %d\r\n", fname, line);
			::OutputDebugString(buff);
		}
	}

	#define ASSUME(x) _myassume(x, __FILE__, __LINE__);
	#define ASSUME_NOT_NULL(x) _myassume(x != NULL, __FILE__, __LINE__);
	#define ASSUME_NOT_REACHED() _myassume(FALSE, __FILE__, __LINE__);
#else	!_DEBUG
	#define ASSUME(x)
	#define ASSUME_NOT_NULL(x)
	#define ASSUME_NOT_REACHED()
#endif _DEBUG

//
// @class CriticalSection class
//
class CriticalSection
{
	public:
		CriticalSection() : m_EntryDepth(0) {
			__try
			{
				::InitializeCriticalSection(&m_OSCriticalSection); 
				m_Initialized = TRUE;
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				m_Initialized = FALSE;
			}
		}

		~CriticalSection() {
			ASSUME(m_EntryDepth == 0);
			::DeleteCriticalSection(&m_OSCriticalSection);
		}

		bool IsInitialized() const
		{
			if (m_Initialized == TRUE)
			{
				return true;
			}
			return false;
		}

		bool Enter() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			m_EntryDepth++;
			::EnterCriticalSection(&m_OSCriticalSection);
			return true;
		}

		bool Leave() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			ASSUME(m_EntryDepth > 0);
			m_EntryDepth--;
			::LeaveCriticalSection(&m_OSCriticalSection);
			return true;
		}

/*	-- Windows NT Only
		BOOL TryEntry() {
			if (::TryEnterCriticalSection(&m_OSCriticalSection) != 0) {
				m_EntryDepth++;
				return TRUE;
			}
			return FALSE;
		}

		BOOL WaitEntry(short timeOut, BOOL doSleep) {
			// right now timeout is just a loop (since it is not being used anyways)
			while(1) {
				if (TryEntry()) { return TRUE; }
				if (--timeOut > 0) {
					if (doSleep) { ::Sleep(0); }
				} else {
					return FALSE;
				}
			}
		}
 -- Windows NT Only */
	private:
		CriticalSection& operator=(CriticalSection& rhs);	// Cannot be copied

		CRITICAL_SECTION m_OSCriticalSection;
		short m_EntryDepth;
		short m_Initialized;
};
extern CriticalSection g_CriticalSection;

//
// @class CriticalLock class
//
// Critical lock is usefor functions with multiple-exit points. Create a stack CriticalLock
// -- object and everything is taken care of for you when it's lifetime ends.
class CriticalLock
{
	public:
		CriticalLock() { g_CriticalSection.Enter(); }
		~CriticalLock() { g_CriticalSection.Leave(); }
};

#endif	__CRITSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffd_swff.cpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.CPP
	Tab settings: 	5 9

	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	FFD (SWForce HAL) API
    
    FUNCTIONS:		Function prototypes for Force Feedback Joystick interface
    				between the SWForce and the device

		FFD_PutRawForce
		FFD_DownloadEffect
	  	FFD_DestroyEffect
		FFD_GetEffectForceValue
		FFD_PutRawForce

		VFX functions:
			Download_VFX
			CreateEffectFromFile
			CreateEffectFromBuffer

	These functionality are not necessarily supported by all Force Feedback 
	devices.  For example, if a device does not support built-in synthesis 
	capability, then the entry point DownloadEffect, will return an error
	code ERROR_NO_SUPPORT.

	COMMENTS:
	This module of functions are encapsulated in SWFF_PRO.dll the DirectInput 
	DDI driver

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	21-Mar-97       MEA     original from SWForce code
			12-Mar-99		waltw	Removed dead code (mostly FFD_xxx functions)
										These functions no longer exported in .def
	              
****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "midi.hpp"
#include "hau_midi.hpp"
#include "math.h"
#include "FFD_SWFF.hpp"
#include "midi_obj.hpp"
#include "CritSec.h"


// Force Output range values
#define MAX_AMP	2047
#define MIN_AMP	-2048
#define FORCE_RANGE ((MAX_AMP - MIN_AMP)/2)

extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

static HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY);

// *** ---------------------------------------------------------------------***
// Function:   	FFD_GetDiagCounters
// Purpose:    	Returns the DIAG_COUNTER structure
// Parameters: 
//			   	PDIAG_COUNTER pDiagCounter	- Ptr to DIAG_COUNTER struct.
//
// Returns:    	SUCCESS - always successful
//
// Algorithm:
// Comments:   	
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_GetDiagCounters(PDIAG_COUNTER pDiagCounter)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "FFD_GetDiagCounters: %s \r\n", &szDeviceName[0]);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	pDiagCounter = g_pJoltMidi->DiagCounterPtrOf();
	return (SUCCESS);
}


// *** ---------------------------------------------------------------------***
// Function:   	FFD_PutRawForce
// Purpose:    	Send force object parameters to be played back by the FF device.
// Parameters: 
//				IN PFORCE	pForce	- A pointer to a FORCE data structure
//
// Returns:    	SUCCESS if successful, else
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//			Note:  The Playback mode will be ONCE
//
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_PutRawForce(
	IN PFORCE pForce)
{
	assert(pForce);
	HRESULT hRet;

	long lForceDataX, lForceDataY;
	long lForceData = (long) ( FORCE_RANGE * (float) (pForce->m_ForceValue/100.00));

// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
//	if (AngleToXY(pForce->m_DirectionAngle2D+90, lForceData, pForce->m_AxisMask, 
//		&lForceDataX, &lForceDataY) != SUCCESS) return SFERR_NO_SUPPORT;

	if (AngleToXY(pForce->m_DirectionAngle2D, lForceData, pForce->m_AxisMask, 
		&lForceDataX, &lForceDataY) != SUCCESS) return SFERR_NO_SUPPORT;

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_PutRawForce: %Force=%ld\n",szDeviceName, (LONG) lForceData);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	switch (pForce->m_AxisMask)
	{
		case (X_AXIS|Y_AXIS):			// use 2D
			hRet = CMD_Force_Out(lForceDataX, X_AXIS);
			if (FAILED(hRet)) break;
			hRet = CMD_Force_Out(lForceDataY, Y_AXIS);
			break;

		case X_AXIS:
			lForceDataX = lForceData;
			hRet = CMD_Force_Out(lForceDataX, X_AXIS);
			break;

		case Y_AXIS:
			lForceDataY = lForceData;
			hRet = CMD_Force_Out(lForceDataY, Y_AXIS);
			break;
		
		default:
			hRet = SFERR_NO_SUPPORT;	
			break;
	}

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_PutRawForce: %Force=%ld\n",szDeviceName, (LONG) lForceData);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return hRet;
}


// ----------------------------------------------------------------------------
// Function:    FFD_Download
//
// Purpose:     Downloads the specified Effect object UD/BE/SE to the FF device.
// Parameters:
//				IN OUT PDNHANDLE pDnloadD   - Ptr to DNHANDLE to store EffectID
//				IN PEFFECT 		 pEffect	- Ptr Common attributes for Effects
//				IN PENVELOPE	 pEnvelope	- Ptr to an ENVELOPE
// 				IN PVOID		 pTypeParam	- Ptr to a Type specific parameter
// 				IN ULONG		 ulAction	- Type of action desired
//
// Returns:
//		SUCCESS - if successful
//		SFERR_FFDEVICE_MEMORY - no more download RAM available
//		SFERR_INVALID_PARAM - Invalid parameters
//		SFERR_NO_SUPPORT - if function is unsupported.
// Algorithm:
//
// Comments:
//
//  ulAction: Type of action desired after downloading
//      PLAY_STORE   - stores in Device only
//      || the following options:
//      PLAY_STORE   - stores in Device only
//      || the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
//          PLAY_LOOP       - Loops for Count times, where count value is in
//                            HIWORD 
//          PLAY_FOREVER    - Play forever until told to stop: PLAY_LOOP with 0 
//							  value in HIWORD
// ----------------------------------------------------------------------------
HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DownloadEffect. DnloadID= %ld, Type=%ld, SubType=%ld\r\n",
   					*pDnloadID,
   					pEffect->m_Type, pEffect->m_SubType);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

// If the Effect type is not a BE_DELAY or EF_ROM_EFFECT,
// make sure there is a pTypeParam
	if ((BE_DELAY != pEffect->m_SubType) && (EF_ROM_EFFECT != pEffect->m_Type))
	{
		assert(pTypeParam);
		if (NULL == pTypeParam) return (SFERR_INVALID_PARAM);
	}

	// Don't support PLAY_LOOP for this version
	if ((ulAction & PLAY_LOOP) || (ulAction & 0xffff0000))
		return (SFERR_NO_SUPPORT);

// REVIEW:  TO increase performance, we should do a parameter mod check
// For now, we'll assume all parameters are changed, for dwFlags
// otherwise, we should check for:
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Figure out the Common members
	BYTE bAxisMask = (BYTE) pEffect->m_AxisMask;
	ULONG ulDuration = pEffect->m_Duration;
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER)) 	ulDuration  = 0;

	// map button 10 to button 9
	if(pEffect->m_ButtonPlayMask == 0x0200)
		pEffect->m_ButtonPlayMask = 0x0100;
	else if(pEffect->m_ButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;

	DWORD dwFlags = DIEP_ALLPARAMS;
	SE_PARAM seParam = { sizeof(SE_PARAM)};

	PBE_SPRING_PARAM pBE_xxx1D;
	PBE_SPRING_2D_PARAM pBE_xxx2D;
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;

	// Decode the type of Download to use
	HRESULT hRet = SFERR_INVALID_PARAM;
	ULONG ulSubType = pEffect->m_SubType;
	switch (pEffect->m_Type)
	{
		case EF_BEHAVIOR:
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					pBE_xxx1D = (PBE_SPRING_PARAM) pTypeParam;
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pBE_xxx1D->m_Kconstant;
						BE_xxx.m_YConstant = 0;
						if (ulSubType != BE_FRICTION)
							BE_xxx.m_Param3 = pBE_xxx1D->m_AxisCenter;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pBE_xxx1D->m_Kconstant;
							BE_xxx.m_XConstant = 0;
							if (ulSubType != BE_FRICTION)
								BE_xxx.m_Param4 = pBE_xxx1D->m_AxisCenter;
							BE_xxx.m_Param3= 0;
						}
					}
					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damperfs
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					pBE_xxx2D = (PBE_SPRING_2D_PARAM) pTypeParam;
					BE_xxx.m_XConstant = pBE_xxx2D->m_XKconstant;
					if (ulSubType != BE_FRICTION_2D)
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_YKconstant;
						BE_xxx.m_Param3 = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param4 = pBE_xxx2D->m_YAxisCenter;
					}
					else
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param3 = 0;
						BE_xxx.m_Param4 = 0;
					}

					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					pBE_Wall = (PBE_WALL_PARAM) pTypeParam;
					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 90)
						|| (pBE_Wall->m_WallAngle == 180)
						|| (pBE_Wall->m_WallAngle == 270) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance;
						hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						hRet = SFERR_NO_SUPPORT;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
					hRet = CMD_Download_NOP_DELAY(ulDuration, pEffect, (PDNHANDLE) pDnloadID);
					break;

				default:
					hRet = SFERR_NO_SUPPORT;
					break;
			}
			break;

		case EF_USER_DEFINED:
			hRet = CMD_Download_UD_Waveform(ulDuration, pEffect, 
					((PUD_PARAM)pTypeParam)->m_NumVectors,
					((PUD_PARAM)pTypeParam)->m_pForceData, 
					 ulAction, pDnloadID, dwFlags);
			break;

		case EF_ROM_EFFECT:
			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(pEffect))
			{
				hRet = SFERR_INVALID_OBJECT;
				break;
			}
			
			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;				// unused by ROM Effect
			seParam.m_SampleRate = pEffect->m_ForceOutputRate;
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;
			
			hRet = CMD_Download_SYNTH(pEffect, pEnvelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);			
			break;
			
		case EF_SYNTHESIZED:
			if (0 == ((PSE_PARAM)pTypeParam)->m_SampleRate)
				((PSE_PARAM)pTypeParam)->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			if (0 == pEffect->m_ForceOutputRate)
				pEffect->m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;

			hRet = CMD_Download_SYNTH(pEffect, pEnvelope, 
						(PSE_PARAM) pTypeParam, ulAction, pDnloadID, dwFlags);
			break;

		default:
			hRet = SFERR_INVALID_PARAM;
	}
	
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DownloadEffect. DnloadID = %lx, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_DestroyEffect
// Purpose:    	Destroys the Effect from download RAM storage area.
// Parameters: 
//				IN EFHANDLE EffectID		// an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_ID
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//				The Device's Effect ID and memory is returned to free pool.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	HRESULT hRet = CMD_DestroyEffect(DnloadID);

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}





// *** ---------------------------------------------------------------------***
// Function:   	FFD_VFXProcessEffect
// Purpose:    	Commands FF device to process downloaded Effects
//
// Parameters: 
//				IN OUT PDNHANDLE pDnloadID	// Storage for new Download ID
//				IN int 	nNumEffects			// Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	// Processing mode
//				IN PDNHANDLE pPListArray// Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pEFHandle:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  The first entry pEFHandle[0] will be
//		used to store the new Effect ID created for the CONCATENATE
//		and SUPERIMPOSE process choice.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_ProcessEffect, DnloadID=%ld\r\n",
					*pDnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	assert(pDnloadID && pPListArray);
	if ((NULL == pDnloadID) || (NULL == pPListArray)) return (SFERR_INVALID_PARAM);

	assert(nNumEffects > 0 && nNumEffects <= MAX_PLIST_EFFECT_SIZE);
	if ((nNumEffects > MAX_PLIST_EFFECT_SIZE) || (nNumEffects <= 0))
		return (SFERR_INVALID_PARAM);

	// map button 10 to button 9
	if(ulButtonPlayMask == 0x0200)
		ulButtonPlayMask = 0x0100;
	else if(ulButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;   

	HRESULT hRet;
	hRet = CMD_VFXProcessEffect(ulButtonPlayMask, pDnloadID,nNumEffects,
			ulProcessMode,pPListArray, PLAY_STORE);
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_GetEffectForceValue
// Purpose:    	Returns the force value at tick time for the Effect
//
// Parameters:	DNHANDLE DnloadID	- Effect ID
//				ULONG ulAxisMask	- X_AXIS or Y_AXIS
//				ULONG ulIndex		- Index into the Effect
//				PLONG pForceValue	- Ptr to a LONG variable
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
// *** ---------------------------------------------------------------------***
HRESULT FFD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex,
	IN OUT PLONG pForceValue)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_GetEffectForceValue, DnloadID=%d\r\n", DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (SFERR_NO_SUPPORT);
}


// *** ---------------------------------------------------------------------***
// Function:   	AngleToXY
// Purpose:    	Computes XY from Angle
// Parameters: 
//				IN LONG lDirectionAngle2D	- Angle in Degrees
//				IN LONG lForceValue			- Resultant Force
//				IN ULONG ulAxisMask			- Axis to Affect
//				IN OUT PLONG pX				- X-Axis store
//				IN OUT PLONG pY				- Y-Axis store
// Returns:    	pX, pY with valid angle components
//
// *** ---------------------------------------------------------------------***
HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY)
{
// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
// If X, Y, and Z-axis, then use 3D angle
// If axis is other than X,Y,Z then no support
	double Radian;

	switch (ulAxisMask)
	{
		case (X_AXIS|Y_AXIS):	// use 2D
			Radian = xDegrees2Radians(lDirectionAngle2D % 360);
#ifdef ORIENTATION_MODE1
			*pX = - (long) (lValueData * cos(Radian));
			*pY = (long) (lValueData * sin(Radian));
#else
			*pX = - (long) (lValueData * sin(Radian));
			*pY = (long) (lValueData * cos(Radian));
#endif
			break;

		case X_AXIS:
			*pX = lValueData;
			*pY = 0;
			break;

		case Y_AXIS:
			*pX = 0;
			*pY = lValueData;
			break;
		
		case (X_AXIS|Y_AXIS|Z_AXIS):	// use 3D
		default:
			return (SFERR_NO_SUPPORT);	
			break;
	}
	return SUCCESS;
}

//
// ---  VFX SUPPORT FUNCTIONS
//

// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromFile
// Purpose:    	Creates an Effect from a RIFF file
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				TCHAR* pszFileName				- Name of file to open 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***
HRESULT CreateEffectFromFile(
		IN LPCTSTR pszFileName,
		IN ULONG ulAction,
		IN OUT PDNHANDLE pDnloadID,
		IN DWORD dwFlags)
{
#ifdef _DEBUG
   	OutputDebugString("CImpIVFX::CreateEffectFromFile\n");
#endif
	// parameter checking
	if ( !(pszFileName && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	HMMIO hmmio = NULL;
	DWORD dwFileSize;
	DWORD dwFilePos;
	BYTE* pBuffer = NULL;
	DWORD dwBytesRead;
	HRESULT hResult = SUCCESS;
	MMRESULT mmresult;
	
	// open a RIFF file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= NULL;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= 0;
	mmioinfo.pchBuffer		= NULL;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[3]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;

	// make a non-constant copy of the string
	TCHAR szFileNameCopy[256];
	strcpy(szFileNameCopy, pszFileName);

	// open the RIFF file for reading
	hmmio = mmioOpen(szFileNameCopy, &mmioinfo, MMIO_READ);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// calculate the size of the file
	dwFileSize = mmioSeek(hmmio, 0, SEEK_END);
	if(dwFileSize == -1)
	{
		hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
		goto cleanup;
	}
	dwFilePos = mmioSeek(hmmio, 0, SEEK_SET);
	if(dwFilePos == -1)
	{
		hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
		goto cleanup;
	}

	// get a chunk of memory big enough to hold it
	pBuffer = new BYTE[dwFileSize];
	if(pBuffer == NULL)
	{
		hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
		goto cleanup;
	}
	
	// read the file into the chunk of memory
	dwBytesRead = mmioRead(hmmio, (char*)pBuffer, dwFileSize);
	if(dwBytesRead != dwFileSize)
	{
		if(dwBytesRead == 0)
			hResult = VFX_ERR_FILE_END_OF_FILE;
		else
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
		goto cleanup;
	}

	// close the RIFF file
	mmresult = mmioClose(hmmio, 0);
	hmmio = NULL;
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// call CreateEffectFromBuffer
	hResult = CreateEffectFromBuffer(pBuffer, dwFileSize, ulAction, pDnloadID, dwFlags);
	// clean up
	cleanup:

	// close the RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pBuffer != NULL)
		delete [] pBuffer;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;
}


// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromBuffer
// Purpose:    	Creates an Effect from a buffer
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				PVOID pBuffer					- Ptr to a buffer block 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwByteCount,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags)
{
#ifdef _DEBUG
   	OutputDebugString("CImpIVFX::CreateEffectFromBuffer\n");
#endif
	// parameter checking
	if ( !(pBuffer && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	// variables used in this function
	#define ID_TABLE_SIZE	50
	MMRESULT mmresult;
	DWORD dwMaxID = 0;		// maximum id of effects entered into the following table
	DNHANDLE rgdwDnloadIDTable[ID_TABLE_SIZE];
	DNHANDLE dwCurrentDnloadID = 0;
	int nNextID = 0;
	HRESULT hResult = SUCCESS;
	DWORD dwBytesRead;
	DWORD dwBytesToRead;
	BYTE* pParam = NULL;
	BOOL bDone = FALSE;
	BOOL bSubEffects = FALSE;
	DWORD dwID;
	DWORD c;	// cleanup counter variable

	// debugging variables (to make sure we destroy all but one
	// created effect on success, and that we destory every
	// created effect on failure)...
#ifdef _DEBUG
	int nEffectsCreated = 0;
	int nEffectsDestroyed = 0;
	BOOL bFunctionSuccessful = FALSE;
#endif //_DEBUG

	// clear effect table (we check it during cleanup...  anything
	// that isn't NULL gets destroyed.)
	memset(rgdwDnloadIDTable,NULL,sizeof(rgdwDnloadIDTable));

	// open a RIFF memory file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= FOURCC_MEM;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= dwByteCount;
	mmioinfo.pchBuffer		= (char*)pBuffer;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[2]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;
	
	HMMIO hmmio;
	hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// descend into FORC RIFF
	MMCKINFO mmckinfoForceEffectRIFF;
	mmckinfoForceEffectRIFF.fccType = FCC_FORCE_EFFECT_RIFF;
	mmresult = mmioDescend(hmmio, &mmckinfoForceEffectRIFF, NULL, MMIO_FINDRIFF);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	//! handle loading of GUID chunk when its implemented/testable

	// descend into trak list
	MMCKINFO mmckinfoTrackLIST;
	mmckinfoTrackLIST.fccType = FCC_TRACK_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoTrackLIST, &mmckinfoForceEffectRIFF,
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// descend into the first efct list (there has to be at least one effect)
	MMCKINFO mmckinfoEffectLIST;
	mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	bDone = FALSE;
	do
	{
		// descend into id chunk
		MMCKINFO mmckinfoIDCHUNK;
		mmckinfoIDCHUNK.ckid = FCC_ID_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoIDCHUNK, &mmckinfoEffectLIST, 
							   MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the id
		//DWORD dwID;  moved to being function global so we can use it near the end
		dwBytesToRead = sizeof(DWORD);
		dwBytesRead = mmioRead(hmmio, (char*)&dwID, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}
		if(dwID >= ID_TABLE_SIZE)
		{
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			goto cleanup;
		}

		// ascend from id chunk
		mmresult = mmioAscend(hmmio, &mmckinfoIDCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// descend into data chunk
		MMCKINFO mmckinfoDataCHUNK;
		mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoDataCHUNK, &mmckinfoEffectLIST, 
								MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the effect structure
		EFFECT effect;
		dwBytesToRead = sizeof(EFFECT);
		dwBytesRead = mmioRead(hmmio, (char*)&effect, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// get the envelope structure
		ENVELOPE envelope;
		dwBytesToRead = sizeof(ENVELOPE);
		dwBytesRead = mmioRead(hmmio, (char*)&envelope, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// calculate the size of and allocate a param structure
		if(pParam != NULL)
		{
			delete [] pParam;
			pParam = NULL;
		}
		// find cur pos w/o changing it
		DWORD dwCurrentFilePos = mmioSeek(hmmio, 0, SEEK_CUR);
		if(dwCurrentFilePos == -1)
		{
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
			goto cleanup;
		}
		DWORD dwEndOfChunk = mmckinfoDataCHUNK.dwDataOffset
							 + mmckinfoDataCHUNK.cksize;
		dwBytesToRead = dwEndOfChunk - dwCurrentFilePos;
		pParam = new BYTE[dwBytesToRead];
		if(pParam == NULL)
		{
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			goto cleanup;
		}

		// get the param structure
		dwBytesRead = mmioRead(hmmio, (char*)pParam, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// ascend the data chunk
		mmresult = mmioAscend(hmmio, &mmckinfoDataCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// ascend from the efct list
		mmresult = mmioAscend(hmmio, &mmckinfoEffectLIST, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// reset subeffects flag
		bSubEffects = FALSE;

		// special fix-ups for user-defined
		if(effect.m_Type == EF_USER_DEFINED && 
				(effect.m_SubType == PL_CONCATENATE 
				|| effect.m_SubType == PL_SUPERIMPOSE
				|| effect.m_SubType == UD_WAVEFORM))
		{
			if(effect.m_SubType == UD_WAVEFORM)
			{
				// fix the pointer to the force data in the UD_PARAM
				BYTE* pForceData = pParam + sizeof(UD_PARAM); // - sizeof(LONG*);
				UD_PARAM* pUDParam =  (UD_PARAM*)pParam;
				pUDParam->m_pForceData = (LONG*)pForceData;

				// do a sanity check
				if(pUDParam->m_NumVectors > MAX_UD_PARAM_FORCE_DATA_COUNT)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}
			}
			else if(effect.m_SubType == PL_CONCATENATE 
									|| effect.m_SubType == PL_SUPERIMPOSE)
			{
				// fix the pointer to the PSWEFFECT list in the PL_PARAM
				BYTE* pProcessList = pParam + sizeof(PL_PARAM);
				PL_PARAM* pPLParam = (PL_PARAM*)pParam;
				pPLParam->m_pProcessList = (PPSWEFFECT)pProcessList;
				
				// do a sanity check
				if(pPLParam->m_NumEffects > MAX_PL_PARAM_NUM_EFFECTS)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}

				// make sure all entries in this process list are valid
				ULONG i;
				for (i = 0; i < pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];
					if(nThisID >= ID_TABLE_SIZE)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];
					if(dwThisDnloadID == 0)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}
				}
				
				// use the ID table to insert the download ID's
				for(i=0; i<pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];

					pPLParam->m_pProcessList[i] = (IDirectInputEffect*)dwThisDnloadID;

					// since this effect has been used in a process list,
					// and it will be destroyed after being used in CreateEffect,
					// null it's entry in the table so it doesn't get erroneously
					// redestroyed during cleanup of an error.
					rgdwDnloadIDTable[nThisID] = NULL;
				}

				// we have a process list with sub effects, so set the flag
				bSubEffects = TRUE;
			}
			else
			{
				// there are no other UD sub-types
				hResult = VFX_ERR_FILE_BAD_FORMAT;
				goto cleanup;
			}
		}

		// download the effect

		// create the effect
		//hResult = pISWForce->CreateEffect(&pISWEffect, &effect, 
		//				&envelope, pParam);


		if(effect.m_SubType != PL_CONCATENATE && effect.m_SubType != PL_SUPERIMPOSE)
		{
			EFFECT SmallEffect;
			SmallEffect.m_Bytes = sizeof(EFFECT);
			SmallEffect.m_Type = effect.m_Type;
			SmallEffect.m_SubType = effect.m_SubType;
			SmallEffect.m_AxisMask = effect.m_AxisMask;
			SmallEffect.m_DirectionAngle2D = effect.m_DirectionAngle2D;
			SmallEffect.m_DirectionAngle3D = effect.m_DirectionAngle3D;
			SmallEffect.m_Duration = effect.m_Duration;
			SmallEffect.m_ForceOutputRate = effect.m_ForceOutputRate;
			SmallEffect.m_Gain = effect.m_Gain;
			SmallEffect.m_ButtonPlayMask = effect.m_ButtonPlayMask;
			*pDnloadID = 0;

			hResult = FFD_DownloadEffect(pDnloadID, &SmallEffect, &envelope, pParam, ulAction);
		}
		else
		{
			ULONG ulButtonPlayMask = effect.m_ButtonPlayMask;
			int nNumEffects = ((PL_PARAM*)pParam)->m_NumEffects;
			ULONG ulProcessMode = effect.m_SubType;
			PDNHANDLE pPListArray = new DNHANDLE[ID_TABLE_SIZE];
			for(int i=0; i<nNumEffects; i++)
				pPListArray[i] = (DNHANDLE)(((PL_PARAM*)pParam)->m_pProcessList[i]);
			*pDnloadID = 0;

			hResult = FFD_VFXProcessEffect(ulButtonPlayMask, pDnloadID, nNumEffects,
				ulProcessMode,pPListArray);
		}

		// moved check for success below...

#ifdef _DEBUG
		if (!FAILED(hResult))
			nEffectsCreated++;
#endif //_DEBUG

		// if there were sub effects we need to destroy them, making
		// their ref counts become 1, so the entire effect can be destroyed
		// by destroying the root effect.
#if 0
		if (bSubEffects)
		{
			PL_PARAM* pPLParam = (PL_PARAM*)pParam;

			for (ULONG i = 0; i < pPLParam->m_NumEffects; i++)
			{
				ASSERT(pPLParam->m_pProcessList[i] != NULL);
				pISWForce->DestroyEffect(pPLParam->m_pProcessList[i]);
#ifdef _DEBUG
				nEffectsDestroyed++;
#endif //_DEBUG
			}
		}
#endif

		// now check for success of CreateEffect, because regardless of
		// whether or not it succeeded, we -must- have destroyed the subeffects
		// before continuing, or cleanup will not work properly...
		if (SUCCESS != hResult)
		{
			goto cleanup;
		}

		// put the id/DnloadID pair into the map
		rgdwDnloadIDTable[dwID] = *pDnloadID; //pISWEffect;
		
		// keep track of the highest ID in the effect table
		if (dwID > dwMaxID)
			dwMaxID = dwID;

		// try to descend the next efct
		mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
							   MMIO_FINDLIST);
		if(mmresult == MMIOERR_CHUNKNOTFOUND)
		{
			// we are at the end of the list
			bDone = TRUE;
		}
		else if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}
	}
	while(!bDone);

	// ascend from trak list
	mmresult = mmioAscend(hmmio, &mmckinfoTrackLIST, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// ascend from FORCE RIFF
	mmresult = mmioAscend(hmmio, &mmckinfoForceEffectRIFF, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// get the return value
	//*pDnloadID = dwCurrentDnloadID;

	// clear the final effect's entry in the table so we don't destroy it during cleanup
	rgdwDnloadIDTable[dwID] = 0;

	// at this point the entire table should be NULL... make sure of it
	for (c = 0; c <= dwMaxID; c++)
		;

#ifdef _DEBUG
	bFunctionSuccessful = TRUE;
#endif //_DEBUG

	cleanup:

	// destroy everything in the effect table that isn't NULL 
	for (c = 0; c <= dwMaxID; c++)
		if (NULL != rgdwDnloadIDTable[c])
		{
			FFD_DestroyEffect(rgdwDnloadIDTable[c]);
			rgdwDnloadIDTable[c] = 0;
#ifdef _DEBUG
			nEffectsDestroyed++;
#endif //_DEBUG
		}

#ifdef _DEBUG
	// make sure we destroy all but one created effect on success,
	// and that we destory -every- created effect on failure.
	if (bFunctionSuccessful)
	{
		;//ASSERT(nEffectsCreated - 1 == nEffectsDestroyed);
	}
	else
	{
		;//ASSERT(nEffectsCreated == nEffectsDestroyed);
	}
#endif //_DEBUG

	// close the memory RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pParam != NULL)
		delete [] pParam;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;

}

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult)
{
	HRESULT hResult;

	switch(mmresult)
	{
		case MMIOERR_FILENOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_OUTOFMEMORY:
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			break;
		case MMIOERR_CANNOTOPEN:
			hResult = VFX_ERR_FILE_CANNOT_OPEN;
			break;
		case MMIOERR_CANNOTCLOSE:
			hResult = VFX_ERR_FILE_CANNOT_CLOSE;
			break;
		case MMIOERR_CANNOTREAD:
			hResult = VFX_ERR_FILE_CANNOT_READ;
			break;
		case MMIOERR_CANNOTWRITE:
			hResult = VFX_ERR_FILE_CANNOT_WRITE;
			break;
		case MMIOERR_CANNOTSEEK:
			hResult = VFX_ERR_FILE_CANNOT_SEEK;
			break;
		case MMIOERR_CANNOTEXPAND:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_CHUNKNOTFOUND:
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			break;
		case MMIOERR_UNBUFFERED:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_PATHNOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_ACCESSDENIED:
			hResult = VFX_ERR_FILE_ACCESS_DENIED;
			break;
		case MMIOERR_SHARINGVIOLATION:
			hResult = VFX_ERR_FILE_SHARING_VIOLATION;
			break;
		case MMIOERR_NETWORKERROR:
			hResult = VFX_ERR_FILE_NETWORK_ERROR;
			break;
		case MMIOERR_TOOMANYOPENFILES:
			hResult = VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			break;
		case MMIOERR_INVALIDFILE:
			hResult = VFX_ERR_FILE_INVALID;
			break;
		default:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffeature.h ===
#ifndef __ForceFeatures_h__
#define __ForceFeatures_h__

#define MSGAME_FEATURE_GETID		2
#define MSGAME_FEATURE_GETSTATUS	3
#define MSGAME_FEATURE_GETACKNAK	4
#define MSGAME_FEATURE_GETNAKACK	5
#define MSGAME_FEATURE_GETSYNC		6
#define MSGAME_FEATURE_DORESET		7

/*
#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08
*/		

typedef struct
{
	ULONG	cBytes;
	ULONG	dwProductID;
	ULONG	dwFWVersion;
} PRODUCT_ID;

typedef	struct
{
	ULONG	cBytes;
	LONG		dwXVel;
	LONG		dwYVel;
	LONG		dwXAccel;
	LONG		dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
} JOYCHANNELSTATUS;

//
//	HID prepends exactly, one byte so we need to
//	be careful about packing
//
#pragma pack(push, OLD_CONTEXT_1)
#pragma pack(1)
typedef struct
{
	BYTE		bReportId;
	PRODUCT_ID	ProductId;
} PRODUCT_ID_REPORT;
typedef struct
{
	BYTE				bReportId;
	JOYCHANNELSTATUS	JoyChannelStatus;
} JOYCHANNELSTATUS_REPORT;

typedef struct
{
	BYTE	bReportId;
	ULONG	uLong;
} ULONG_REPORT;
#pragma pack(pop, OLD_CONTEXT_1)
//
//	End packing of 1
//


class CForceFeatures
{
	public:
		CForceFeatures();
		~CForceFeatures();

		HRESULT Initialize(UINT uJoystickId, HINSTANCE hinstModule);
		ULONG GetVersion(){ return (4 << 16 | 0 ); } //returns version 4.0
		HRESULT GetId(PRODUCT_ID_REPORT& rProductId);
		HRESULT GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus);
		HRESULT GetAckNak(ULONG_REPORT& rulAckNak);
		HRESULT GetNakAck(ULONG_REPORT& rulNakAck);
		HRESULT GetSync(ULONG_REPORT& rulGameport);
		HRESULT DoReset();
	private:
		HANDLE	m_hDevice;
		UINT m_uiMaxFeatureLength;
};

#endif // __ForceFeatures_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffeature.cpp ===
//	@doc
/**********************************************************************
*
*	@module	ForceFeatures.cpp	|
*
*	Implements CForceFeatures to use msgame's HID features.
*
*	History
*	----------------------------------------------------------
*	Mitchell Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ForceFeatures	|
*	CForceFeatures opens a handle to msgame in the context of
*	a particular device on construction.
*	The public members expose the feature interface for msgame.
*
*	Will work with NT5 as is.  For Win98 we need a different
*	scheme for getting HID path.  DI promises to fix somehow.
**********************************************************************///

#include <windows.h>
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dinputd.h>
extern "C" {
	#include <hidsdi.h>
}
#include "FFeature.h"

/***********************************************************************************
**
**	CForceFeatures::CForceFeatures(UINT uJoystickId)
**
**	@mfunc	C'tor gets Hid Path from Joystick and opens path to driver
**
**	@rdesc	None since this is c'tor.  However at the end of this routine
**			m_hDevice will contain a handle for the driver on success, or
**			will contain NULL on failure.  All routines will check the
**			value of m_hDevice before proceeding.
**
*************************************************************************************/
CForceFeatures::CForceFeatures() :
	m_hDevice(NULL)
{
}


/***********************************************************************************
**
**	CForceFeatures::~CForceFeatures()
**
**	@mfunc	D'tor closes handle to driver, if it was open
**
*************************************************************************************/
CForceFeatures::~CForceFeatures()
{
	if(m_hDevice)
	{
		CloseHandle(m_hDevice);
	}
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::Initialize(UINT uJoystickId, HINSTANCE hinstModule)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::Initialize
(
	UINT uJoystickId,		//@parm Joystick Id as used by winmm
	HINSTANCE hinstModule	//@parm Instance of the DLL for Creating DirectInput
)
{
	if (m_hDevice != NULL) {
		return S_OK;	// No need to reinitialize
	}

	HRESULT hr;
	
	//**
	//** Get HidPath
	//**  
	//**

	//
	//	Get IDirectInput interface	
	//
	IDirectInput *pDirectInput = NULL;
	IDirectInputJoyConfig *pDirectInputJoyConfig = NULL; 
	hr = DirectInputCreate(
			hinstModule,
			DIRECTINPUT_VERSION,
			&pDirectInput,
			NULL
			);
	if( FAILED(hr) ) return hr;

	//
	//	Get IDirectInputJoyConfig
	//
	hr=pDirectInput->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID *)&pDirectInputJoyConfig);
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}
	
	//
	//	GetConfig for JoyId
	//
	DIJOYCONFIG DiJoyConfig;
	DiJoyConfig.dwSize=sizeof(DIJOYCONFIG);
	hr = pDirectInputJoyConfig->GetConfig(
									uJoystickId,
									&DiJoyConfig,
									DIJC_GUIDINSTANCE
									);
	//
	//	Done with pDirectInputJoyConfig
	//
	pDirectInputJoyConfig->Release();
	pDirectInputJoyConfig = NULL;
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}

	//
	//  Get IDirectInputDevice interface
	//
	IDirectInputDevice *pDirectInputDevice;
	hr = pDirectInput->CreateDevice(DiJoyConfig.guidInstance, &pDirectInputDevice, NULL);
	//
	//	Done pDirectInput
	//
	pDirectInput->Release();
	pDirectInput = NULL;
	if( FAILED(hr) ) return hr;
	
	//
	//	Get HidPath
	//
	DIPROPGUIDANDPATH DiPropGuidAndPath;
	DiPropGuidAndPath.diph.dwSize = sizeof(DIPROPGUIDANDPATH);
	DiPropGuidAndPath.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	DiPropGuidAndPath.diph.dwObj = 0;
	DiPropGuidAndPath.diph.dwHow = DIPH_DEVICE;
	hr=pDirectInputDevice->GetProperty( DIPROP_GUIDANDPATH, &DiPropGuidAndPath.diph);

	//
	//	Done with pDirectInputDevice
	//
	pDirectInputDevice->Release();
	pDirectInputDevice = NULL;
	if( FAILED(hr) ) return hr;

	//**
	//**	Open Path to Driver
	//**
	m_hDevice = CreateFileW(
		DiPropGuidAndPath.wszPath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		m_hDevice = NULL;
	}
	if (m_hDevice == NULL)
	{
		DWORD err = ::GetLastError();
		return E_FAIL;
	}

	PHIDP_PREPARSED_DATA pHidPreparsedData;
	if (HidD_GetPreparsedData(m_hDevice, &pHidPreparsedData) == FALSE)
	{
		::CloseHandle(m_hDevice);
		m_hDevice = NULL;
		return E_FAIL;
	}
	HIDP_CAPS hidpCaps;
	HidP_GetCaps(pHidPreparsedData, &hidpCaps);
	m_uiMaxFeatureLength = hidpCaps.FeatureReportByteLength;
	HidD_FreePreparsedData(pHidPreparsedData);
	
	//
	//	On success, m_hDevice now contains a handle to the device
	//
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetId(PRODUCT_ID_REPORT& rProductId)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetId
(
	PRODUCT_ID_REPORT& rProductId	// @parm Reference to PRODUCT_ID_REPORT to get from driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}

	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rProductId.bReportId = MSGAME_FEATURE_GETID;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rProductId), m_uiMaxFeatureLength);

//	 -- HIDPI.H
//	 HIDP_GetData(Report Type, Data, Lenght, Preparse Data, Report, ReportLength);

	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}


/***********************************************************************************
**
**	HRESULT CForceFeatures::GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus)
**
**	@mfunc	Get the JoyChannel Status from msgame's MSGAME_FEATURE_GETSTATUS
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetStatus
(
	JOYCHANNELSTATUS_REPORT& rJoyChannelStatus	// @parm Reference to JOYCHANNELSTATUS_REPORT to be filled by driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rJoyChannelStatus.bReportId = MSGAME_FEATURE_GETSTATUS;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rJoyChannelStatus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
		DWORD err = GetLastError();
		return HRESULT_FROM_WIN32(err);
//	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulAckNak)
**
**	@mfunc	Returns an AckNak by using msgame's GetAckNak Featue
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetAckNak
(
	ULONG_REPORT& rulAckNak	// @parm REFERENCE to ULONG_REPORT to be filled by driver with AckNak
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulAckNak.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulAckNak), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulNakAck)
**
**	@mfunc	Returns an AckNak by using msgame's MSGAME_FEATURE_NAKACK
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetNakAck(
	ULONG_REPORT& rulNakAck	// @parm REFERENCE to ULONG_REPORT to be filled by driver with NakAck
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulNakAck.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulNakAck), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
/***********************************************************************************
**
**	HRESULT CForceFeatures::GetSync(ULONG_REPORT& rulGameport)
**
**	@mfunc	Get Sync information from MSGAME's MSGAME_FEATURE_GETSYNC
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetSync
(
	ULONG_REPORT& rulGameport	// @parm REFERENCE to ULONG_REPORT to be filled by driver with Gameport
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulGameport.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulGameport), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::DoReset()
**
**	@mfunc	Does Reset via MSGAME's MSGAME_FEATURE_DORESET
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::DoReset()
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	ULONG_REPORT ulBogus;
	ulBogus.bReportId = MSGAME_FEATURE_DORESET;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&ulBogus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffd_swff.hpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header to define FFD (Swforce) Force Feedback Driver API
    
    FUNCTIONS:		


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	22-Jan-96       MEA     original
	1.1		21-Mar-97		MEA		from SWForce
			12-Mar-99		waltw	Removed dead code (mostly FFD_xxx functions)
										These functions no longer exported in .def
		        
****************************************************************************/
#ifndef FFD_SWFF_SEEN
#define FFD_SWFF_SEEN
#include "DX_Map.hpp"
#include "hau_midi.hpp"

#define	TWOPI	(3.14159265358979323846 * 2)
#define	PI		(3.14159265358979323846)
#define	PI2		(1.57079632679489661923)
#define	PI4		(0.78539816339744830966)
#define RADIAN 	(57.29577951)

#define xDegrees2Radians(rAngle) 		((rAngle) * PI / 180.0)
#define xRadians2Degrees(rAngle) 		((rAngle) * 180.0 / PI)

//
// --- Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')


#define MAX_UD_PARAM_FORCE_DATA_COUNT	1000
#define MAX_PL_PARAM_NUM_EFFECTS		50


//---------------------------------------------------------------------------
// Function prototype declarations
//---------------------------------------------------------------------------
#ifdef _cplusplus
extern "C" {
#endif

HRESULT CreateEffectFromFile(
		IN LPCTSTR pszFileName,
		IN ULONG ulAction,
		IN OUT PDNHANDLE pDnloadID,
		IN DWORD dwFlags);

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwFileSize,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags);

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult);

HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lForceValue,
	IN ULONG ulAxisMask,
	IN OUT PSHORT pX,
	IN OUT PSHORT pY);

HRESULT WINAPI FFD_GetDiagCounters(
	IN OUT PDIAG_COUNTER pDiagCounter);

HRESULT WINAPI FFD_SetDeviceState(ULONG);

HRESULT WINAPI FFD_PutRawForce(
	IN PFORCE pForce);

HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction);

HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE EffectID);

HRESULT WINAPI FFD_PlaybackEffect(
	IN DNHANDLE hEffectID,  
	IN ULONG ulMode);

HRESULT WINAPI FFD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

HRESULT FFD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex,
	IN OUT PLONG pForceValue);

#ifdef _cplusplus
}
#endif


#endif // of ifndef FFD_SWFF_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\hau_midi.cpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for Jolt Midi device command Protocol
    
    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			02-Apr-96	MEA   	Original
				19-Sep-96	MEA		Removed ES1.0 specific code
				05-Dec-96	MEA		Removed ALLACK debug switch
	1.1			17-Mar-97	MEA		DX-FF mode
				14-Apr-97	MEA		Added support for RTC spring
				16-Mar-99	waltw	Add checks for NULL g_pJoltMidi

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "midi_obj.hpp"
#include "dx_map.hpp"
#include "sw_objec.hpp"
#include "ffd_swff.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/

/****************************************************************************

   Declaration of variables

****************************************************************************/
//
// Globals specific to hau_midi
//
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// *** ---------------------------------------------------------------------***
// Function:   	CMD_Init
// Purpose:    	Inits JOLT for MIDI channel
// Parameters: 
//			   	none
//
// Returns:    	SUCCESS - if successful, else
//				a device Error code
//
// Algorithm:
//
// Comments:
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_Init(void)
{
	HRESULT hRet;
	BYTE bChannel = DEFAULT_MIDI_CHANNEL;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	g_pJoltMidi->SetMidiChannel(bChannel);	// Force this channel
	hRet = CMD_MIDI_Assign(bChannel);
	return(hRet);
}

//
// --- EFFECT_CMDs
//
/****************************************************************************

    FUNCTION:   CMD_Force_Out

	PARAMETERS:	IN LONG	lForceData	- Actual force 
				IN ULONG ulAxisMask - Axis Mask

	RETURNS:	SUCCESS or FAILURE

   	COMMENTS:	Sends force vector to MIDI channel

  Byte 0	= EFFECT_CMD + Channel #
									D7 D6  D5  D4  D3  D2  D1  D0
									-- --  --  --  --  --  --  --
  Byte 1	= Low byte of Force		 0 v4  v3  v2  v1  v0  d   d
  Byte 2	= High byte of Force	 0 v11 v10 v9  v8  v7  v6  v5 
	where: d  d
	       -  -
		   0  0	reserved
		   0  1	PUT_FORCE_X
		   1  0	PUT_FORCE_Y
		   1  1	PUT_FORCE_XY

****************************************************************************/
HRESULT CMD_Force_Out(LONG lForceData, ULONG ulAxisMask)
{
	HRESULT hRet;
	BYTE cData1;
	BYTE cData2;
	BYTE cAxis;		

 	BYTE cStatus = EFFECT_CMD;
	switch(ulAxisMask)	
	{
		case X_AXIS:
			cAxis = PUT_FORCE_X;
			break;
		case Y_AXIS:
			cAxis = PUT_FORCE_Y;
			break;
		case (X_AXIS | Y_AXIS):
			cAxis = PUT_FORCE_XY;
			break;
		default:
			return (SFERR_INVALID_PARAM);				
			break;
	}
	cData1 = ((int) lForceData << 2) & 0x7c;
	cData1 = cData1 | cAxis;
	cData2 = ((int) lForceData >> 5) & 0x7f;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, cData1, cData2);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR, 
					DRIVER_ERROR_MIDI_OUTPUT));
	// Note: PutForce used to not expect an ACK/NACK, only used to slow down
	// transmission to Jolt and prevent any lockups
	//Sleep(SHORT_MSG_TIMEOUT);
	//ACKNACK AckNack = {sizeof(ACKNACK)};
	//hRet = g_pJoltMidi->GetAckNackData(g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay, &AckNack);
#if 0
	static DWORD dwMod = 0;
	dwMod++;
	if(dwMod%g_pJoltMidi->DelayParamsPtrOf()->dwForceOutMod == 0)
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay);
#endif
	DWORD dwIn;
	int nDelayCount = g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay;
	for(int i=0; i<nDelayCount; i++)
		g_pDriverCommunicator->GetStatusGateData(dwIn);
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_DestroyEffect
// Purpose:    	Destroys the Effect from Device
// Parameters: 
//				IN DNHANDLE DnloadID		- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//	The Device's Effect ID and memory is returned to free pool.
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= DESTROY_EFFECT		0   0   0   1   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(NULL != pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	// Send the command

	HRESULT hRet = pMidiEffect->DestroyEffect();

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	// Wait for ACK.  Note: WinMM has callback Event notification
	// while Backdoor and serial does not.
	if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
	{	
		hRet = g_pJoltMidi->GetAckNackData(ACKNACK_EFFECT_STATUS_TIMEOUT, &AckNack, REGBITS_DESTROYEFFECT);
	}
	else
		hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_DESTROYEFFECT);

	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));

	// Delete the Effect
	delete pMidiEffect;
    return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	CMD_PlayEffectSuperimpose
// Purpose:    	Plays the Effect in Device
// Parameters: 
//				IN DNHANDLE DnloadID	- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:	This is PLAY_SUPERIMPOSE mode
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//										D7  D6  D5  D4  D3  D2  D1  D0
//										--  --  --  --  --  --  --  --
//  Byte 1	= PLAY_EFFECT_SUPERIMPOSE	0   0   1   0   0   0   0   0
//  Byte 2	= EffectID (7 bits)			0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_PlayEffectSuperimpose( 
	IN DNHANDLE DnloadID) 
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

#if 0
	// Hack to fix firmware bug #1138 which causes an infinite duration
	// effect not to be felt on re-start once the effect has been stopped.
	// The hack is to "change" the duration from infinite to infinite
	ULONG ulDuration = pMidiEffect->DurationOf();
	if(ulDuration == 0)
	{
		// see if it is a PL or an atomic effect
		ULONG ulSubType = pMidiEffect->SubTypeOf();
		BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);
		if(!bProcessList)
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, 0);
	}
#endif

	// Update the playback mode for this Effect
	pMidiEffect->SetPlayMode(PLAY_SUPERIMPOSE);

	assert((BYTE) DnloadID < MAX_EFFECT_IDS);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,PLAY_EFFECT_SUPERIMPOSE,(BYTE)DnloadID);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_PLAYEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_PlayEffectSolo
// Purpose:    	Plays the Effect in Device as PLAY_SOLO
// Parameters: 
//				IN DNHANDLE EffectID	- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:	This is PLAY_SOLO mode
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= PLAY_EFFECT_SOLO	 	0   0   0   0   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_PlayEffectSolo( 
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

#if 0
	// Hack to fix firmware bug #1138 which causes an infinite duration
	// effect not to be felt on re-start once the effect has been stopped.
	// The hack is to "change" the duration from infinite to infinite
	ULONG ulDuration = pMidiEffect->DurationOf();
	if(ulDuration == 0)
	{
		// see if it is a PL or an atomic effect
		ULONG ulSubType = pMidiEffect->SubTypeOf();
		BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);
		if(!bProcessList)
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, 0);
	}
#endif

	// Update the playback mode for this Effect
	pMidiEffect->SetPlayMode(PLAY_SOLO);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,PLAY_EFFECT_SOLO, (BYTE) DnloadID);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_PLAYEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_StopEffect
// Purpose:    	Stops the Effect in Device
// Parameters: 
//				IN DNHANDLE EffectID		- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= STOP_EFFECT		 	0   0   1   1   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_StopEffect( 
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, STOP_EFFECT, (BYTE) DnloadID);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_STOPEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetIndex
// Purpose:    	Sets the autoincrementing Index for MODIFY_CMD
// Parameters: 
//				IN int nIndex			- Index value 0 - 15
//				IN DNHANDLE DnloadID	- Effect ID in stick
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= SET_INDEX+index	 	0   1   i   i   i   i   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	if (SYSTEM_EFFECT_ID != DnloadID)
	{
		CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiEffect);
		if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	}

	assert((nIndex <= MAX_INDEX) && (nIndex >= 0));
	if ((nIndex < 0) || (nIndex > MAX_INDEX)) return (SFERR_INVALID_PARAM);
	
	BYTE cByte1;
	cByte1 = SET_INDEX | (BYTE) (nIndex << 2);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, cByte1, (BYTE) DnloadID);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: SetIndex used to not require ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_SETINDEX);
	// :
	if (SUCCESS != hRet)
		return (SFERR_DRIVER_ERROR);
	
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParam
// Purpose:    	Modifies an Effect parameter
// Parameters: 
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= MODIFY_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Low 7 bits data	 	0   v   v   v   v   v   v   v
//  Byte 2	= High 7 bits data		0   v   v   v   v   v   v   v
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParam( 
	IN WORD wNewParam)
{
	HRESULT hRet;
	BYTE cByte1, cByte2;
	cByte1 = wNewParam & 0x7f;
	cByte2 = (BYTE) ((wNewParam >> 7) & 0x7f);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(MODIFY_CMD, cByte1, cByte2);
	
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: ModifyParam used to not require an ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_MODIFYPARAM);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParamByIndex
// Purpose:    	Modifies an Effect parameter, given an Index
// Parameters: 
//				IN	int nIndex			- Index 0 to 15
//				IN DNHANDLE DnloadID	- Download ID
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//	Assumes DnloadID is already valid
//	Calls SetIndex followed by ModifyParam
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParamByIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID, 
	IN WORD wNewParam)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	if ((nIndex < 0) || (nIndex > MAX_INDEX))
		return (SFERR_INVALID_PARAM);

	int i;
	for (i=0; i<MAX_RETRY_COUNT; i++)
	{
		hRet = CMD_SetIndex(nIndex,DnloadID);
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwSetIndexDelay);
		if (SUCCESS == hRet) break;
#ifdef _DEBUG
		OutputDebugString("CMD_SetIndex Failed. Retrying again\n");
#endif
	}
	if (SUCCESS != hRet)
		return (hRet);
	else
	{
		for (i=0; i<MAX_RETRY_COUNT; i++)
		{
			hRet = CMD_ModifyParam(wNewParam);
			Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwModifyParamDelay);
			if (SUCCESS == hRet) break;
#ifdef _DEBUG
			OutputDebugString("CMD_SetIndex Failed. Retrying again\n");
#endif
		}
	}
	return (hRet);
}

//
// --- SYSTEM_CMDs
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetDeviceState
// Purpose:    	Sets the FF device State
// Parameters: 
//			   	ULONG ulMode 
//
// Returns:    	SUCCESS - if successful, else
//				Device error code
//
// Algorithm:
// Comments:   	
//	ulMode:
//	  DEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
//	  DEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
//	  DEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
//	  DEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
//	  DEV_PAUSE		5L		// All Effects are "Paused"
//	  DEV_STOP_ALL	6L		// Stops all Effects. 
//
//  Byte 0	= SYSTEM_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Set Device Type	 	0   0   0   0   0   0   0   1
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetDeviceState(
	IN ULONG ulMode)
{
	HRESULT hRet = SUCCESS;
	assert(g_pJoltMidi);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	BYTE	bChannel = g_pJoltMidi->MidiChannelOf();
	MIDIINFO *pMidiOutInfo = g_pJoltMidi->MidiOutInfoOf();
	switch (ulMode)
	{
		case DEV_RESET:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_SHUTDOWN, 0);
			break;

		case DEV_FORCE_ON:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_FORCE_ON, 0);
			break;

		case DEV_FORCE_OFF:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_FORCE_OFF, 0);
			break;

		case DEV_CONTINUE:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_CONTINUE, 0);
			break;

		case DEV_PAUSE:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_PAUSE, 0);
			break;

		case DEV_STOP_ALL:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_STOP_ALL, 0);
			break;

		case SWDEV_KILL_MIDI:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_KILL_MIDI, 0);
			break;

		default:
			return SFERR_INVALID_PARAM;
	}
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Wait for ACK or NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
	if (DEV_RESET == ulMode)
	{	// Wait for Jolt to complete the cycle
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay);
		hRet = g_pJoltMidi->GetAckNackData(ACKNACK_TIMEOUT, &AckNack, REGBITS_SETDEVICESTATE);
	}
	else
	{
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);
		hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_SETDEVICESTATE);
	}

	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));

	// Special case Shutdown
	if (DEV_RESET == ulMode)
	{
		// Delete all Effects except built-in RTC Spring and FRICTION cancel.
		g_pJoltMidi->DeleteDownloadedEffects();	
	}
	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwPostSetDeviceStateDelay);
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_GetEffectStatus
// Purpose:    	Returns Status of Effect ID
// Parameters: 
//			   	DNHANDLE DnloadID		- Effect ID
//				PBYTE	 pStatusCode	- Status Code
//
// Returns:    	SUCCESS - if successful, else
//				a device Error code
//				*pStatusCode set to		- SWDEV_STS_EFFECT_STOPPED
//										  SWDEV_STS_EFFECT_RUNNING
//
// Algorithm:
//
// Comments:   	
//  Byte 0	= STATUS_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Effect ID			 	0   0   0   0   0   1   0   0
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_GetEffectStatus(DNHANDLE DnloadID, PBYTE pStatusCode)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(STATUS_CMD, (BYTE) DnloadID, 0);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay);// enough for about 3 bytes of data being sent at 330us/byte	

	DWORD dwIn;
	hRet = g_pDriverCommunicator->GetStatusGateData(dwIn);
	if (SUCCESS != hRet) return (hRet);

	if ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & RUNNING_MASK_200))
	{
		*pStatusCode = SWDEV_STS_EFFECT_RUNNING;
	}
	else
	{
		*pStatusCode = SWDEV_STS_EFFECT_STOPPED;
	}
	return (hRet);
}

//
// --- System Exclusive Commands
//
// System Exclusive Command:MIDI_ASSIGN
// 
// *** ---------------------------------------------------------------------***
// Function:   	CMD_MIDI_Assign
// Purpose:    	Inits JOLT MIDI channel
// Parameters:	BYTE bMidiChannel	- Channel to assign 
//
// Returns:    	SUCCESS or Error code
//				
//
// Algorithm:
//
// Comments:   	SYS_EX type command
//   
//	Body							D7  D6  D5  D4  D3  D2  D1  D0
//  ------							--  --  --  --  --  --  --  --
//  Byte 0	= MIDI_ASSIGN			0   0   0   1   0   0   0   0
//  Byte 1	= channel#(0-15) e.g. 5	0   0   0   0   0   1   0   1
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_MIDI_Assign(
	IN BYTE bMidiChannel)
{
	HRESULT hRet;
	PMIDI_ASSIGN_SYS_EX lpData;
	CMidiAssign *pMidiAssign;

	assert((bMidiChannel > 0) && (bMidiChannel < MAX_MIDI_CHANNEL));

	pMidiAssign = new CMidiAssign;
	assert(pMidiAssign);
	if (!pMidiAssign) return (SFERR_DRIVER_ERROR);
	pMidiAssign->SetMidiAssignChannel(bMidiChannel);
	lpData = (PMIDI_ASSIGN_SYS_EX) pMidiAssign->GenerateSysExPacket();
	assert(lpData);
	if(!lpData) return (SFERR_DRIVER_ERROR);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Prepare the buffer for SysEx output
	g_pJoltMidi->MidiAssignBuffer((LPSTR) lpData, 
					(DWORD) sizeof(MIDI_ASSIGN_SYS_EX), TRUE);

	// Send the message and Wait for the ACK
	hRet = g_pJoltMidi->MidiSendLongMsg();
	if (SUCCESS == hRet)
	{
		ACKNACK AckNack = {sizeof(ACKNACK)};
		// Wait for ACK.  Note: WinMM has callback Event notification
		// while Backdoor and serial does not.
		if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
		{	
			hRet = g_pJoltMidi->GetAckNackData(ACKNACK_TIMEOUT, &AckNack, REGBITS_DEVICEINIT);
		}
		else
			hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_DEVICEINIT);

		// :
		if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
		if (ACK != AckNack.dwAckNack)
			hRet = g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode);
 	}
	else
		hRet = SFERR_DRIVER_ERROR;

	// Release the Midi buffers and delete the MIDI sys_ex object
	g_pJoltMidi->MidiAssignBuffer((LPSTR) lpData, 0, FALSE);
	delete pMidiAssign;
	return (hRet);
}

//
// System Exclusive Command:DNLOAD_DATA
//
/****************************************************************************

    FUNCTION:   CMD_Download_BE_XXX

	PARAMETERS:	PEFFECT pEffect		- Ptr to a EFFECT data structure
				PENVELOPE pEnvelope	- Ptr to an ENVELOPE data structure 
				PBE_XXX pBE_XXX		- Ptr to a BE_XXX data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage
				DWORD dwFlags		- dwFlags from Kernel

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads BE_XXX type Effect params to the device
				Uses SysEx prototype and ModifyParam methods
				Note: Normally pEnvelope = NULL

****************************************************************************/
HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PBEHAVIORAL_SYS_EX lpData;
	CMidiBehavioral *pMidiBehavioral;
	BOOL fXConstantChanged=FALSE;
	BOOL fYConstantChanged=FALSE;
	BOOL fParam3Changed=FALSE;
	BOOL fParam4Changed=FALSE;

	assert(pEffect && pBE_XXX && pDnloadID);
	if ((NULL == pEffect) || (NULL == pBE_XXX) || (NULL == pDnloadID))
		return (SFERR_INVALID_PARAM);

	DNHANDLE DnloadID =*pDnloadID;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// scale the constants using the fudge factor
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	switch(pEffect->m_SubType)
	{
		case BE_INERTIA:
		case BE_INERTIA_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleMx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleMy))/((int)100);
			break;

		case BE_SPRING:
		case BE_SPRING_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleKx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleKy))/((int)100);
			break;

		case BE_DAMPER:
		case BE_DAMPER_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleBx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleBy))/((int)100);
			break;

		case BE_FRICTION:
		case BE_FRICTION_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleFx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleFy))/((int)100);
			break;

		case BE_WALL:
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleW))/((int)100);
			break;

		default:
			// do not scale
			break;
	}

// If Create New, then create a new object, using SysEx
// else, update the existing Effect object, using ModifyParam
	if (NULL == DnloadID)	// New, Make a new object, use SysEx
	{
		if ((BE_FRICTION == pEffect->m_SubType) || (BE_FRICTION_2D == pEffect->m_SubType))
		{
			pMidiBehavioral = new CMidiFriction(pEffect, pEnvelope, pBE_XXX);
			assert(pMidiBehavioral);
		}
		else	// Wall
			if	(BE_WALL == pEffect->m_SubType)
			{
				pMidiBehavioral = new CMidiWall(pEffect, pEnvelope, pBE_XXX);
				assert(pMidiBehavioral);
			}
			// BE_SPRINGxx, BE_DAMPERxx, BE_INERTIAxx
			else
			{
				pMidiBehavioral = new CMidiBehavioral(pEffect, pEnvelope, pBE_XXX);
				assert(pMidiBehavioral);
			}
		if (NULL == pMidiBehavioral) return (SFERR_INVALID_OBJECT);
		// Generate Sys_Ex packet then prepare for output	
		lpData = (PBEHAVIORAL_SYS_EX) pMidiBehavioral->GenerateSysExPacket();
		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);

		// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
		pMidiBehavioral->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
		hRet = pMidiBehavioral->SendPacket(pDnloadID, pMidiBehavioral->MidiBufferSizeOf());
		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiBehavioral;
		}
	}
	else	// Modify existing
	{
		pMidiBehavioral = (CMidiBehavioral *) g_pJoltMidi->GetEffectByID(*pDnloadID);
		assert(pMidiBehavioral);
		if (NULL == pMidiBehavioral) return (SFERR_INVALID_OBJECT);

		// Check if Type specific params have changed.
		if (BE_WALL == pEffect->m_SubType)
		{
			if ((pBE_XXX->m_XConstant) != pMidiBehavioral->XConstantOf())
				fXConstantChanged=TRUE;		// Wall Type
			if ((pBE_XXX->m_YConstant) != pMidiBehavioral->YConstantOf())
				fYConstantChanged=TRUE;		// Wall Constant
			if ((pBE_XXX->m_Param3) != pMidiBehavioral->Param3Of())
				fParam3Changed=TRUE;		// Wall Angle
			if ((pBE_XXX->m_Param4) != pMidiBehavioral->Param4Of())
				fParam4Changed=TRUE;		// Wall Distance
		}
		else
		{
			if ((pBE_XXX->m_XConstant) != pMidiBehavioral->XConstantOf())
				fXConstantChanged=TRUE;
			if ((pBE_XXX->m_YConstant) != pMidiBehavioral->YConstantOf())
				fYConstantChanged=TRUE;
			if ((BE_FRICTION != pEffect->m_SubType) && (BE_FRICTION_2D != pEffect->m_SubType))
			{
				if ((pBE_XXX->m_Param3) != pMidiBehavioral->Param3Of())
					fParam3Changed=TRUE;
				if ((pBE_XXX->m_Param4) != pMidiBehavioral->Param4Of())
					fParam4Changed=TRUE;
			}
		}

		// Fill in the common Effect and Behavioral specific parameters
		// Only update Duration and Button Play as common effect parameters
		// Double check if DURATION and TRIGGERBUTTON changed, to speed operation
		DWORD dwTempFlags = 0;
		if (pEffect->m_Duration != pMidiBehavioral->DurationOf())
			dwTempFlags = dwTempFlags | DIEP_DURATION;
		if (pEffect->m_ButtonPlayMask != pMidiBehavioral->ButtonPlayMaskOf())
			dwTempFlags = dwTempFlags | DIEP_TRIGGERBUTTON;
		pMidiBehavioral->SetEffectParams(pEffect, pBE_XXX);
		hRet = ModifyEffectParams(DnloadID, pEffect, dwTempFlags);
		if (SUCCESS!=hRet) return hRet;

		if (BE_WALL == pEffect->m_SubType)
		{
			// Generate Sys_Ex packet then prepare for output	
			lpData = (PBEHAVIORAL_SYS_EX) pMidiBehavioral->GenerateSysExPacket();
			assert(lpData);
			if (!lpData) return (SFERR_DRIVER_ERROR);

			// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
			pMidiBehavioral->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
			hRet = pMidiBehavioral->SendPacket(pDnloadID, pMidiBehavioral->MidiBufferSizeOf());
		}
		else // Use ModifyParameter 
		{
			// Type Specific Params
			if (dwFlags & DIEP_TYPESPECIFICPARAMS)
			{
		 
				if (fYConstantChanged)	// KY/BY/MY/FY
				{
					hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (pBE_XXX->m_YConstant * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}
			
				if(fXConstantChanged)	// KX/BX/MX/FX
				{
					hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT) (pBE_XXX->m_XConstant * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}

				if (fParam4Changed)		// CY/VY/AY
				{
					hRet = CMD_ModifyParamByIndex(INDEX5, DnloadID, (SHORT) (pBE_XXX->m_Param4 * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}

				if (fParam3Changed)		// CX/VX/AX
				{
					hRet = CMD_ModifyParamByIndex(INDEX4, DnloadID, (SHORT) (pBE_XXX->m_Param3 * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}
			}
		}
	}                   
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Download_RTCSpring

	PARAMETERS:	PRTCSPRING_PARAM pRTCSpring	- Ptr to a RTCSPRING_PARAM structure
				PDNHANDLE pDnloadID		- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads RTCSPRING type Effect params to the device
				Uses SysEx prototype and ModifyParam methods

****************************************************************************/
HRESULT CMD_Download_RTCSpring(
 	IN PRTCSPRING_PARAM pRTCSpring,
	IN OUT PDNHANDLE pDnloadID)
{ 
	HRESULT hRet = SUCCESS;
	CMidiRTCSpring *pMidiRTCSpring;

	assert(pRTCSpring && pDnloadID);
	if ((NULL == pRTCSpring) || (NULL == pDnloadID))
		return (SFERR_INVALID_PARAM);

	DNHANDLE DnloadID = SYSTEM_RTCSPRING_ID;
	*pDnloadID = DnloadID;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Note: RTC Spring is a permanent System Effect ID 2
	pMidiRTCSpring = (CMidiRTCSpring *) g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiRTCSpring);
	if (NULL == pMidiRTCSpring) return (SFERR_INVALID_OBJECT);

	// Check if Type specific params have changed, if so, Modify it
	if ((pRTCSpring->m_XKConstant) != pMidiRTCSpring->XKConstantOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX0, DnloadID, 
				(SHORT) (pRTCSpring->m_XKConstant * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YKConstant) != pMidiRTCSpring->YKConstantOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX1, DnloadID, 
				(SHORT) (pRTCSpring->m_YKConstant * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XAxisCenter) != pMidiRTCSpring->XAxisCenterOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX2, DnloadID, 
				(SHORT) (pRTCSpring->m_XAxisCenter * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YAxisCenter) != pMidiRTCSpring->YAxisCenterOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX3, DnloadID, 
				(SHORT) (pRTCSpring->m_YAxisCenter * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XSaturation) != pMidiRTCSpring->XSaturationOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX4, DnloadID, 
				(SHORT) (pRTCSpring->m_XSaturation * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YSaturation) != pMidiRTCSpring->YSaturationOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX5, DnloadID, 
				(SHORT) (pRTCSpring->m_YSaturation * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XDeadBand) != pMidiRTCSpring->XDeadBandOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX6, DnloadID, 
				(SHORT) (pRTCSpring->m_XDeadBand * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YDeadBand) != pMidiRTCSpring->YDeadBandOf())
	{
		hRet=CMD_ModifyParamByIndex(INDEX7, DnloadID,
				(SHORT) (pRTCSpring->m_YDeadBand * MAX_SCALE));
	}
	
	pMidiRTCSpring->SetEffectParams(pRTCSpring);
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Dnload_NOP_DELAY

	PARAMETERS:	ULONG ulDuration	- Duration delay

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads NOP_DELAY Effect params to the device
				Uses SysEx prototype

****************************************************************************/
HRESULT CMD_Download_NOP_DELAY(
 	IN ULONG ulDuration,
	IN PEFFECT pEffect,
 	IN OUT PDNHANDLE pDnloadID)
{ 
	HRESULT hRet = SUCCESS;
	PNOP_SYS_EX lpData;
	CMidiDelay *pMidiDelay;
	BOOL fCreateNew = FALSE;

	assert(pDnloadID);
	assert(0 != ulDuration);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, 
// else, update the existing Effect object.
	if (NULL == *pDnloadID) fCreateNew = TRUE;

	if (fCreateNew)	// New, Make a new object
	{
		pMidiDelay = new CMidiDelay(pEffect);
		assert(pMidiDelay);
		if (NULL == pMidiDelay) return (SFERR_INVALID_OBJECT);
		pMidiDelay->SetEffectID(NEW_EFFECT_ID);
	}
	else	// Modify existing
	{
		pMidiDelay = (CMidiDelay *) g_pJoltMidi->GetEffectByID(*pDnloadID);
		assert(pMidiDelay);
		if (NULL == pMidiDelay) return (SFERR_INVALID_OBJECT);
		pMidiDelay->SetEffectID((BYTE) *pDnloadID);
	}
	pMidiDelay->SetDuration(ulDuration);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PNOP_SYS_EX) pMidiDelay->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	pMidiDelay->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiDelay->SendPacket(pDnloadID, sizeof(NOP_SYS_EX));
	if (FAILED(hRet) && fCreateNew) // Create NEW, Failure
	{
		delete pMidiDelay;
	}
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Dnload_UD_Waveform

	PARAMETERS:	ULONG ulDuration	- what fun!
				PEFFECT pEffect		- Ptr to an EFFECT structure
				ULONG   ulNumVectors- Number of vectors in the array
				PLONG   pUD_Array	- Ptr to a UD_WAVEFORM byte array
				ULONG	ulAction	- Mode for download
				PDNHANDLE pDnloadID - Ptr to a DNHANDLE store
				DWORD dwFlags		- dwFlags from Kernel

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads UD_WAVEFORM Effect params to the device
				Uses SysEx prototype

****************************************************************************/
HRESULT CMD_Download_UD_Waveform(
	IN ULONG ulDuration,
	IN PEFFECT pEffect,
	IN ULONG ulNumVectors,
 	IN PLONG pUD_Array,
	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PUD_WAVEFORM_SYS_EX lpData;
	CMidiUD_Waveform *pMidiUD_Waveform;

	assert(pEffect && pUD_Array);
	assert(ulNumVectors > 0);
	assert(pDnloadID);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, 
// else, update the existing Effect object.
	DNHANDLE DnloadID = *pDnloadID;
	if (NULL == DnloadID)	// New, Make a new object
	{
		pMidiUD_Waveform = new CMidiUD_Waveform(pEffect, ulNumVectors, pUD_Array);
		assert(pMidiUD_Waveform);

		if (NULL == pMidiUD_Waveform) return (SFERR_INVALID_OBJECT);

		if (0 == pMidiUD_Waveform->MidiBufferSizeOf())
		{
			delete pMidiUD_Waveform;
			return (SFERR_INVALID_PARAM);
		}
		// Generate Sys_Ex packet then prepare for output	
		lpData = (PUD_WAVEFORM_SYS_EX) pMidiUD_Waveform->GenerateSysExPacket();
		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);

		// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
		pMidiUD_Waveform->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
		hRet = pMidiUD_Waveform->SendPacket(pDnloadID, pMidiUD_Waveform->MidiBufferSizeOf());
		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiUD_Waveform;
		}
	}
	else	// Modify existing
	{
		pMidiUD_Waveform = (CMidiUD_Waveform *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiUD_Waveform);
		if (NULL == pMidiUD_Waveform) return (SFERR_INVALID_OBJECT);		

		// fix the output rate (waveform is compressed)
		pEffect->m_ForceOutputRate = pEffect->m_ForceOutputRate*pMidiUD_Waveform->ForceOutRateOf()/pMidiUD_Waveform->OriginalEffectParamOf()->m_ForceOutputRate;

		// Modify EFFECT, and ENVELOPE params
		hRet = ModifyEffectParams(DnloadID, pEffect, dwFlags);
		if (SUCCESS!=hRet) return hRet;
	}
	return (hRet);
}

/****************************************************************************

    FUNCTION:   CMD_Dnload_SYNTH

	PARAMETERS:	PSYNTH pSynth		- Ptr to a SYNTH data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads SE_xxx Effect params to the device
				Uses SysEx prototype

 Algorithm:
 The following dwFlags may be sent by the kernel

	#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
	#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
	#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
	#define DIEP_DURATION 				0x00000001	- dwDuration
	#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
	#define DIEP_GAIN 					0x00000004	- dwGain
	#define DIEP_NODOWNLOAD 			0x80000000	- suppress auto - download
	#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
	#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
	#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
	#define DIEP_TYPESPECIFICPARAMS 	0x00000100	- cbTypeSpecificParams
													  and lpTypeSpecificParams
	 Jolt has two options for downloading - Full SysEx or Modify Parameter
	 Pass the dwFlags to each CMD_xxx function and let the MIDI function
	 determine whether to use SysEx or Modify Parameter.

****************************************************************************/
HRESULT CMD_Download_SYNTH(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PSE_PARAM pSE_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PSE_WAVEFORM_SYS_EX lpData;
	CMidiSynthesized *pMidiSynthesized;
	BOOL fFreqChanged = FALSE;
	BOOL fMaxAmpChanged = FALSE;
	BOOL fMinAmpChanged = FALSE;
	DNHANDLE DnloadID =*pDnloadID;
	assert(pEffect && pEnvelope && pSE_Param && pDnloadID);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, and use SysEx method
// else, update the existing Effect object. using ModifyParam method
	if (NULL == DnloadID)	// New, Make a new object
	{
		pMidiSynthesized = new CMidiSynthesized(pEffect, pEnvelope, pSE_Param);
		assert(pMidiSynthesized);
		if (NULL == pMidiSynthesized) return (SFERR_DRIVER_ERROR);

		// Generate Sys_Ex packet then prepare for output	
		lpData = (PSE_WAVEFORM_SYS_EX) pMidiSynthesized->GenerateSysExPacket();

		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);
		pMidiSynthesized->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());

		hRet = pMidiSynthesized->SendPacket(pDnloadID, sizeof(SE_WAVEFORM_SYS_EX));

		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiSynthesized;
			pMidiSynthesized = NULL;

			return hRet;
		}

		// Hack to fix firmware bug #1138 which causes an infinite duration
		// effect not to be felt on re-start once the effect has been stopped.
		// The hack is to "change" the duration from infinite to infinite
		ULONG ulDuration = pMidiSynthesized->DurationOf();
		if(ulDuration == 0)
		{
			hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, 0);

		}

		return (hRet);
	}
	else	// Modify existing
	{
		pMidiSynthesized = (CMidiSynthesized *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiSynthesized);
		if (NULL == pMidiSynthesized) return (SFERR_INVALID_OBJECT);

		// check to see if they are trying to change sub-type (not allowed)
		if((dwFlags & DIEP_TYPESPECIFICPARAMS) && pEffect->m_SubType != pMidiSynthesized->SubTypeOf())
			return SFERR_NO_SUPPORT;

		if(dwFlags & DIEP_NODOWNLOAD)
			return DI_DOWNLOADSKIPPED;

		// Check if Type specific params have changed.
		if (pSE_Param->m_Freq != pMidiSynthesized->FreqOf())
			fFreqChanged=TRUE;
		if ((pSE_Param->m_MaxAmp) != pMidiSynthesized->MaxAmpOf()) 
			fMaxAmpChanged=TRUE;
		if ((pSE_Param->m_MinAmp) != pMidiSynthesized->MinAmpOf()) 
			fMinAmpChanged=TRUE;

		// Fill in the common Effect and Synth specific parameters
		pMidiSynthesized->SetEffectParams(pEffect, pSE_Param, ulAction);
//		// Fill in the Envelope
//		pMidiSynthesized->SetEnvelope(pEnvelope);

		// Modify EFFECT, ENVELOPE and Type Specific
		hRet = ModifyEffectParams(DnloadID, pEffect, dwFlags);
		if (SUCCESS!=hRet) return hRet;

		hRet = ModifyEnvelopeParams(pMidiSynthesized, DnloadID, pEffect->m_Duration, pEnvelope, dwFlags);
		if (SUCCESS!=hRet) return hRet;
		
		// Fill in the Envelope
		pMidiSynthesized->SetEnvelope(pEnvelope);

		// Type Specific Params
		if (dwFlags & DIEP_TYPESPECIFICPARAMS)
		{
		 	if(fFreqChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX12, DnloadID, (SHORT) pSE_Param->m_Freq);
				if (SUCCESS!=hRet) return hRet;
			}
			if (fMaxAmpChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX13, DnloadID, (SHORT) (pSE_Param->m_MaxAmp * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}
			if (fMinAmpChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX14, DnloadID, (SHORT) (pSE_Param->m_MinAmp * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}
		}
	}                   
	return (hRet);
}

/****************************************************************************

    FUNCTION:   CMD_Download_VFX

	PARAMETERS:	PSYNTH pSynth		- Ptr to a SYNTH data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads SE_xxx Effect params to the device
				Uses SysEx prototype

 Algorithm:
 The following dwFlags may be sent by the kernel

	#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
	#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
	#define DIEP_GAIN 					0x00000004	- dwGain
	#define DIEP_NODOWNLOAD 			0x80000000	- suppress auto - download
	#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
	#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
	#define DIEP_TYPESPECIFICPARAMS 	0x00000100	- cbTypeSpecificParams
													  and lpTypeSpecificParams
	 Jolt has two options for downloading - Full SysEx or Modify Parameter
	 Pass the dwFlags to each CMD_xxx function and let the MIDI function
	 determine whether to use SysEx or Modify Parameter.

****************************************************************************/
HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFXParam,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{
	HRESULT hRet = SUCCESS;
	DNHANDLE DnloadID = *pDnloadID;


	assert(pEffect && !pEnvelope && pVFXParam);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	BOOL bModify = DnloadID != 0;

	if(*pDnloadID == 0)
	{
		// make a new object
		if(pVFXParam->m_PointerType == VFX_FILENAME)
			hRet = CreateEffectFromFile((LPCTSTR)pVFXParam->m_pFileNameOrBuffer, ulAction, (USHORT*)pDnloadID, dwFlags);
		else if(pVFXParam->m_PointerType == VFX_BUFFER)
			hRet = CreateEffectFromBuffer(pVFXParam->m_pFileNameOrBuffer, pVFXParam->m_BufferSize, ulAction, (USHORT*)pDnloadID, dwFlags);
		else
			hRet = SFERR_INVALID_PARAM;

		if(FAILED(hRet)) return hRet;

		DnloadID = *pDnloadID;
	}

	// modify an existing object or the effect just created

	// get the effect associated with this ID
	CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

	// change the button play mask only on a modify
	if (bModify && (dwFlags & DIEP_TRIGGERBUTTON))
	{
		// get the button play mask
		ULONG ulButtonPlayMask = pEffect->m_ButtonPlayMask;

		// modify the param in the CMidiEffect
		pMidiEffect->SetButtonPlaymask(ulButtonPlayMask);

		// modify the param in the stick
		hRet = CMD_ModifyParamByIndex(INDEX1, DnloadID, (SHORT)ulButtonPlayMask);
		if (SUCCESS!=hRet) return hRet;
	}

	// see if it is a PL or an atomic effect
	ULONG ulSubType = pMidiEffect->SubTypeOf();
	BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);

	// modify gain and direction
	if(bProcessList)
	{
		// modify gain and direction for each sub-effect

		// convert the pointer to CMidiProcessList
		CMidiProcessList* pMidiProcessList = (CMidiProcessList*)pMidiEffect;

		// get the number of sub-effects and the array
		UINT ulNumEffects = pMidiProcessList->NumEffectsOf();
		PBYTE pEffectArray = pMidiProcessList->EffectArrayOf();
		assert(pEffectArray);
		if(pEffectArray == NULL) return (SFERR_INVALID_OBJECT);

		// calculate the nominal duration of the process list
		ULONG ulNominalDuration = 0;
		for(UINT i=0; i<ulNumEffects; i++)
		{
			// get the download ID of the next sub-effect
			DNHANDLE SubDnloadID = pEffectArray[i];

			// get the sub-effect
			CMidiEffect* pMidiSubEffect = g_pJoltMidi->GetEffectByID(SubDnloadID);
			assert(pMidiSubEffect);
			if (NULL == pMidiSubEffect) return (SFERR_INVALID_OBJECT);

			// get the original effect param
			PEFFECT pOriginalEffectParam = pMidiSubEffect->OriginalEffectParamOf();

			// get the original duration of this sub-effect
			ULONG ulSubEffectDuration = pOriginalEffectParam->m_Duration;
			//ASSERT(ulSubEffectDuration != 0);

			// update the nominal duration of the overall effect to reflect this sub-effect
			if(ulSubType == PL_CONCATENATE)
				ulNominalDuration += ulSubEffectDuration;
			else
				ulNominalDuration = max(ulNominalDuration, ulSubEffectDuration);
		}

		// iterate throught the list of sub-effects
		for(i=0; i<ulNumEffects; i++)
		{
			// get the download ID of the next sub-effect
			DNHANDLE SubDnloadID = pEffectArray[i];

			// get the sub-effect
			CMidiEffect* pMidiSubEffect = g_pJoltMidi->GetEffectByID(SubDnloadID);
			assert(pMidiSubEffect);
			if (NULL == pMidiSubEffect) return (SFERR_INVALID_OBJECT);

			// get the original effect param
			PEFFECT pOriginalEffectParam = pMidiSubEffect->OriginalEffectParamOf();
					
			// Direction? Note: No Direction modify for Behaviorals!!!!
			if ((dwFlags & DIEP_DIRECTION) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
			{
				// calculate the new angle
				ULONG nOriginalAngle2D = pOriginalEffectParam->m_DirectionAngle2D;
				ULONG nDeltaAngle2D = pEffect->m_DirectionAngle2D;
				ULONG nNewAngle2D = (nOriginalAngle2D + nDeltaAngle2D)%360;

				// modify the param in the midi sub-effect
				pMidiSubEffect->SetDirectionAngle(nNewAngle2D);

				// modify the parameter in the stick
				hRet = CMD_ModifyParamByIndex(INDEX2, SubDnloadID, (SHORT)nNewAngle2D);
				if (SUCCESS!=hRet) return hRet;
			}

			// Gain?
			// Gain? Note: No Gain modify for Behaviorals!!!!
			if ((dwFlags & DIEP_GAIN) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
			{
				// calculate the new gain
				ULONG nOriginalGain = pOriginalEffectParam->m_Gain;
				ULONG nOverallGain = pEffect->m_Gain;
				ULONG nNewGain = nOverallGain*nOriginalGain/100;

				// modify the param in the midi effect
				pMidiSubEffect->SetGain((BYTE)nNewGain);

				// modify the parameter in the stick
				hRet = CMD_ModifyParamByIndex(INDEX3, SubDnloadID, (SHORT) (nNewGain * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}

			if(dwFlags & DIEP_DURATION)
			{
				// calculate the new duration
				ULONG nOriginalDuration = pOriginalEffectParam->m_Duration;
				ULONG nOverallDuration = pEffect->m_Duration;
				ULONG nNewDuration;
				if(nOverallDuration == (ULONG)-1)
				{
					// default length
					nNewDuration = nOriginalDuration;
				}
				else if(nOverallDuration == 0)
				{
					// infinite duration

					// for a concatenated process list we make the last effect infinite, others default
					// for a superimpose process list we make all effects infinite
					if(ulSubType == PL_CONCATENATE)
					{
						if(i == ulNumEffects-1)
						{
							// make last effect in PL infinite
							nNewDuration = 0;
						}
						else
						{
							// make other effects default
							nNewDuration = nOriginalDuration;
						}
					}
					else
					{
						assert(ulSubType == PL_SUPERIMPOSE);

						// make effects infinite
						nNewDuration = 0;
					}
				}
				else
				{
					// scale the duration (at least 1mS)
					nNewDuration = nOriginalDuration*nOverallDuration/ulNominalDuration;
					nNewDuration = max(1, nNewDuration);
				}

				// modify the parameter in the midi sub-effect
				pMidiSubEffect->SetDuration(nNewDuration);

				// modify the parameter in the stick
				if (nNewDuration != 0)
				{
					nNewDuration = (ULONG) ( (float) nNewDuration/TICKRATE);
					if (nNewDuration <= 0) 
						nNewDuration = 1;
				}		
				hRet = CMD_ModifyParamByIndex(INDEX0, SubDnloadID, (SHORT) nNewDuration);
				if (SUCCESS!=hRet) return hRet;
			}
		}
	}
	else
	{
		// modify gain and direction for the atomic effect

		// get the original effect param
		PEFFECT pOriginalEffectParam = pMidiEffect->OriginalEffectParamOf();
				
		// Direction? Note: No Direction modify for Behaviorals!!!!
		if ((dwFlags & DIEP_DIRECTION) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
		{
			// calculate the new angle
			ULONG nOriginalAngle2D = pOriginalEffectParam->m_DirectionAngle2D;
			ULONG nDeltaAngle2D = pEffect->m_DirectionAngle2D;
			ULONG nNewAngle2D = (nOriginalAngle2D + nDeltaAngle2D)%360;

			// modify the param in the midi effect
			pMidiEffect->SetDirectionAngle(nNewAngle2D);

			// modify the parameter in the stick
			hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT)nNewAngle2D);
			if (SUCCESS!=hRet) return hRet;
		}

		// Gain?
		// Gain? Note: No Gain modify for Behaviorals!!!!
		if ((dwFlags & DIEP_GAIN) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))		
		{
			// calculate the new gain
			ULONG nOriginalGain = pOriginalEffectParam->m_Gain;
			ULONG nOverallGain = pEffect->m_Gain;
			ULONG nNewGain = nOverallGain*nOriginalGain/100;

			// modify the param in the midi effect
			pMidiEffect->SetGain((BYTE)nNewGain);

			// modify the parameter in the stick
			hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (nNewGain * MAX_SCALE));
			if (SUCCESS!=hRet) return hRet;
		}

		if(dwFlags & DIEP_DURATION)
		{
			// calculate the new duration
			ULONG nOriginalDuration = pOriginalEffectParam->m_Duration;
			ULONG nOverallDuration = pEffect->m_Duration;
			ULONG nNewDuration;
			if(nOverallDuration == (ULONG)-1)
			{
				// default length
				nNewDuration = nOriginalDuration;
			}
			else if(nOverallDuration == 0)
			{
				// infinite duration -- make effect infinite
				nNewDuration = 0;
			}
			else
			{
				// scale the duration (at least 1mS)
				nNewDuration = nOverallDuration;
			}

			// modify the parameter in the midi effect
			pMidiEffect->SetDuration(nNewDuration);

			// modify the parameter in the stick
			if (nNewDuration != 0)
			{
				nNewDuration = (ULONG) ( (float) nNewDuration/TICKRATE);
				if (nNewDuration <= 0) 
					nNewDuration = 1;
			}		
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, (SHORT) nNewDuration);
			if (SUCCESS!=hRet) return hRet;
		}

	}

	return hRet;
}


//
// --- System Exclusive Command:PROCESS_DATA
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_ProcessEffect
// Purpose:    	Processes the List
//				IN ULONG ulButtonPlayMask
//				IN OUT PDNHANDLE pDnloadID	- Storage for new Download ID
//				IN int 	nNumEffects			- Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	- Processing mode
//				IN PDNHANDLE pPListArray	- Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				E_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pPListArray:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  
//
//  Byte 0	= MIDI_CMD_EFFECT + Channel #
//									D7 D6  D5  D4  D3  D2  D1  D0
//									-- --  --  --  --  --  --  --
//  Byte 1	= Low byte of Force		 0 
//  Byte 2	= High byte of Force	 0 
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
	IN ULONG ulAction)
{
	HRESULT hRet = SUCCESS;
	PPROCESS_LIST_SYS_EX lpData;
	CMidiProcessList *pMidiProcessList;
	assert(pDnloadID && pPListArray);
	if ((NULL  == pDnloadID) || (NULL == pPListArray))
		return (SFERR_INVALID_PARAM);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	DNHANDLE DnloadID = *pDnloadID;

// If Create New, then create a new object, 
// else, update the existing Effect object.

// Build the special Parameter
	PLIST PList;
	PList.ulNumEffects = (ULONG) nNumEffects;
	PList.ulProcessMode = ulProcessMode; 
	PList.pEffectArray = pPListArray;
	PList.ulAction = ulAction;	

	if (NULL == DnloadID)	// New, Make a new object
	{
		// make sure we are not trying to create a PL within a PL
		for(int i=0; i<nNumEffects; i++)
		{
			// get the next sub-effect
			int nID = pPListArray[i];
			CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DNHANDLE(nID));
			if(pMidiEffect == NULL)
				return SFERR_INVALID_PARAM;

			// make sure it is not a process list
			ULONG ulSubType = pMidiEffect->SubTypeOf();
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_INVALID_PARAM;
		}

		// create the CMidiProcessList object
		pMidiProcessList = new CMidiProcessList(ulButtonPlayMask, &PList);
		assert(pMidiProcessList);
		pMidiProcessList->SetEffectID(NEW_EFFECT_ID);
		pMidiProcessList->SetSubType(ulProcessMode);
	}
	else	// Modify existing
	{
		pMidiProcessList = (CMidiProcessList *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiProcessList);
		if (NULL == pMidiProcessList) return (SFERR_INVALID_OBJECT);
		pMidiProcessList->SetEffectID((BYTE) DnloadID);
	}

	// Fill in the parameters
	pMidiProcessList->SetParams(ulButtonPlayMask, &PList);
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER))
		pMidiProcessList->SetDuration(0);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PPROCESS_LIST_SYS_EX) pMidiProcessList->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	int nSizeBuf = sizeof(SYS_EX_HDR) + 5 + nNumEffects + 2;
	pMidiProcessList->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiProcessList->SendPacket(pDnloadID, nSizeBuf);
	if (SUCCESS != hRet) // Create NEW, Failure
	{
		delete pMidiProcessList;
	}
	else
	{
		// workaround to FW bug #1211, modify PL type with same PL type
		ULONG ulSubType;
		if (PL_SUPERIMPOSE == ulProcessMode) 
			ulSubType = PLIST_SUPERIMPOSE; 
		else
			ulSubType = PLIST_CONCATENATE;  


		hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, (SHORT) ulSubType);
	}

	return (hRet);
}

//
// --- System Exclusive Command:PROCESS_DATA
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_VFXProcessEffect
// Purpose:    	Processes the List
//				IN ULONG ulButtonPlayMask
//				IN OUT PDNHANDLE pDnloadID	- Storage for new Download ID
//				IN int 	nNumEffects			- Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	- Processing mode
//				IN PDNHANDLE pPListArray	- Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				E_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pPListArray:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  
//
//  Byte 0	= MIDI_CMD_EFFECT + Channel #
//									D7 D6  D5  D4  D3  D2  D1  D0
//									-- --  --  --  --  --  --  --
//  Byte 1	= Low byte of Force		 0 
//  Byte 2	= High byte of Force	 0 
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
	IN ULONG ulAction)
{
	HRESULT hRet = SUCCESS;
	PPROCESS_LIST_SYS_EX lpData;
	CMidiVFXProcessList *pMidiProcessList;
	assert(pDnloadID && pPListArray);
	if ((NULL  == pDnloadID) || (NULL == pPListArray))
		return (SFERR_INVALID_PARAM);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	DNHANDLE DnloadID = *pDnloadID;

// If Create New, then create a new object, 
// else, update the existing Effect object.

// Build the special Parameter
	PLIST PList;
	PList.ulNumEffects = (ULONG) nNumEffects;
	PList.ulProcessMode = ulProcessMode; 
	PList.pEffectArray = pPListArray;
	PList.ulAction = ulAction;	

	if (NULL == DnloadID)	// New, Make a new object
	{
		// make sure we are not trying to create a PL within a PL
		for(int i=0; i<nNumEffects; i++)
		{
			// get the next sub-effect
			int nID = pPListArray[i];
			CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DNHANDLE(nID));
			if(pMidiEffect == NULL)
				return SFERR_INVALID_PARAM;

			// make sure it is not a process list
			ULONG ulSubType = pMidiEffect->SubTypeOf();
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_INVALID_PARAM;
		}

		pMidiProcessList = new CMidiVFXProcessList(ulButtonPlayMask, &PList);
		assert(pMidiProcessList);
		if (!pMidiProcessList) return (SFERR_DRIVER_ERROR);

		pMidiProcessList->SetEffectID(NEW_EFFECT_ID);
		pMidiProcessList->SetSubType(ulProcessMode);
	}
	else	// Modify existing
	{
		pMidiProcessList = (CMidiVFXProcessList *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiProcessList);
		if (NULL == pMidiProcessList) return (SFERR_INVALID_OBJECT);
		pMidiProcessList->SetEffectID((BYTE) DnloadID);
	}

	// Fill in the parameters
	pMidiProcessList->SetParams(ulButtonPlayMask, &PList);
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER))
		pMidiProcessList->SetDuration(0);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PPROCESS_LIST_SYS_EX) pMidiProcessList->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	int nSizeBuf = sizeof(SYS_EX_HDR) + 5 + nNumEffects + 2;
	pMidiProcessList->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiProcessList->SendPacket(pDnloadID, nSizeBuf);
	if (SUCCESS != hRet) // Create NEW, Failure
	{
		delete pMidiProcessList;
	}
	else
	{
		// workaround to FW bug #1211, modify PL type with same PL type
		ULONG ulSubType;
		if (PL_SUPERIMPOSE == ulProcessMode) 
			ulSubType = PLIST_SUPERIMPOSE; 
		else
			ulSubType = PLIST_CONCATENATE;  


		hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, (SHORT) ulSubType);
	}

	return (hRet);
}

/****************************************************************************

    FUNCTION:   ModifyEffectParams

	PARAMETERS:	DNHANDLE DnloadID	- Download ID
				PEFFECT pEffect		- Ptr to EFFECT structure
				DWORD dwFlags		- Flags indicating which changed

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Modifies EFFECT parameters

 Algorithm:

****************************************************************************/
HRESULT ModifyEffectParams(
	IN DNHANDLE DnloadID,
	IN PEFFECT pEffect,
	IN DWORD dwFlags)
{	 
	HRESULT hRet = SUCCESS;
	// Check dwFlags for each parameter that changed.
	// Duration?
	ULONG ulDuration = pEffect->m_Duration;	
	if (dwFlags & DIEP_DURATION)
	{
		if (ulDuration != 0)
		{
			ulDuration = (ULONG) ( (float) ulDuration/TICKRATE);
			if (ulDuration <= 0) 
				ulDuration = 1;
		}		
		hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, (SHORT) ulDuration);
		if (SUCCESS!=hRet) return hRet;
	}

	// ButtonPlayback?
	if (dwFlags & DIEP_TRIGGERBUTTON)
	{
		hRet = CMD_ModifyParamByIndex(INDEX1, DnloadID, (SHORT) pEffect->m_ButtonPlayMask);
		if (SUCCESS!=hRet) return hRet;
	}

	// Direction?
	if (dwFlags & DIEP_DIRECTION)
	{
		hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT) pEffect->m_DirectionAngle2D);
		if (SUCCESS!=hRet) return hRet;
	}

	// Gain?
	if (dwFlags & DIEP_GAIN)
	{
		hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (pEffect->m_Gain * MAX_SCALE));
		if (SUCCESS!=hRet) return hRet;
	}

	// Force Output Rate
	if (dwFlags & DIEP_SAMPLEPERIOD )
	{
		hRet = CMD_ModifyParamByIndex(INDEX4, DnloadID, (SHORT) (pEffect->m_ForceOutputRate));
		if (SUCCESS!=hRet) return hRet;
	}

	return (hRet);
}


/****************************************************************************

    FUNCTION:   ModifyEnvelopeParams

	PARAMETERS:	CMidiSynthesized * pMidiEffect - Ptr to Effect object
				DNHANDLE DnloadID	- Download ID
				PENVELOPE pEnvelope - Ptr to ENVELOPE structure
				DWORD dwFlags		- Flags indicating which changed

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Modifies ENVELOPE parameters

 Algorithm:

****************************************************************************/
HRESULT ModifyEnvelopeParams(
	IN CMidiSynthesized *pMidiEffect,
	IN DNHANDLE DnloadID,
	IN ULONG ulDuration,
	IN PENVELOPE pEnvelope,
	IN DWORD dwFlags)
{
	HRESULT hRet=SUCCESS;
	ULONG ulTimeToSustain; 
	ULONG ulTimeToDecay;

	// Envelope?
	if (dwFlags & DIEP_ENVELOPE)
	{
		if (PERCENTAGE == pEnvelope->m_Type)
		{
			ulTimeToSustain = (ULONG) ((pEnvelope->m_Attack * ulDuration) /100.);
			ulTimeToDecay   = (ULONG) ((pEnvelope->m_Attack + pEnvelope->m_Sustain)
									 * ulDuration /100.);
		}
		else	// TIME option envelope
		{
			ulTimeToSustain = (ULONG) (pEnvelope->m_Attack);
			ulTimeToDecay   = (ULONG) (pEnvelope->m_Attack + pEnvelope->m_Sustain);
		}
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

// REVIEW: Do a parameters changed check in order to speed this up - TOO MANY BYTES!!!
		if (pEnvelope->m_Attack != (pMidiEffect->EnvelopePtrOf())->m_Attack)
		{
			hRet = CMD_ModifyParamByIndex(INDEX7,  DnloadID, (SHORT) ulTimeToSustain);	
			if (SUCCESS!=hRet) return hRet;
		}
		if (   (pEnvelope->m_Attack != (pMidiEffect->EnvelopePtrOf())->m_Attack)
			|| (pEnvelope->m_Sustain != (pMidiEffect->EnvelopePtrOf())->m_Sustain) )
		{
			hRet = CMD_ModifyParamByIndex(INDEX8,  DnloadID, (SHORT) ulTimeToDecay);	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_StartAmp != (pMidiEffect->EnvelopePtrOf())->m_StartAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX9,  DnloadID, (SHORT) (pEnvelope->m_StartAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_SustainAmp != (pMidiEffect->EnvelopePtrOf())->m_SustainAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX10, DnloadID, (SHORT) (pEnvelope->m_SustainAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_EndAmp != (pMidiEffect->EnvelopePtrOf())->m_EndAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX11, DnloadID, (SHORT) (pEnvelope->m_EndAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}
	}
	return (hRet);
}

/****************************************************************************

    FUNCTION:   MapEnvelope

	PARAMETERS:	ULONG ulDuration		- Total Duration
				ULONG dwMagnitude
				ULONG * pMaxLevel
				LPDIENVELOPE pIDEnvelope- Ptr to DIENVELOPE structure
				PENVELOPE pEnvelope		- SWForce ENVELOPE

	RETURNS:	none

   	COMMENTS:	Maps DIENVELOPE to ENVELOPE

 Algorithm:

****************************************************************************/
void MapEnvelope( 
	IN ULONG ulDuration,
	IN ULONG dwMagnitude,
	IN ULONG * pMaxLevel,
	IN LPDIENVELOPE pDIEnvelope, 
	IN OUT PENVELOPE pEnvelope)
{
	ULONG ulMaxLevel = *pMaxLevel;
	if (pDIEnvelope)
	{
		// if there is an envelope, MaxLevel must look at attack/fade
		ulMaxLevel = max(ulMaxLevel, pDIEnvelope->dwAttackLevel);
		ulMaxLevel = max(ulMaxLevel, pDIEnvelope->dwFadeLevel);

		pEnvelope->m_Type = TIME;

		// find attack/sustain/decay which sum to ulDuration
		pEnvelope->m_Attack = pDIEnvelope->dwAttackTime/SCALE_TIME;
		pEnvelope->m_Decay = pDIEnvelope->dwFadeTime/SCALE_TIME;
// REVIEW: is this correct for ulDuration == 0?
		if(ulDuration != 0)
			pEnvelope->m_Sustain = ulDuration - pEnvelope->m_Attack - pEnvelope->m_Decay;
		else
			pEnvelope->m_Sustain = 0;

		// convert to StartAmp/SustainAmp/EndAmp, which is a % of the magnitude
		if(ulMaxLevel != 0)
		{
			pEnvelope->m_StartAmp = pDIEnvelope->dwAttackLevel*100/ulMaxLevel;
			pEnvelope->m_SustainAmp = dwMagnitude*100/ulMaxLevel;
			pEnvelope->m_EndAmp = pDIEnvelope->dwFadeLevel*100/ulMaxLevel;
		}
		else
		{
			pEnvelope->m_StartAmp = pDIEnvelope->dwAttackLevel;
			pEnvelope->m_SustainAmp = 100;
			pEnvelope->m_EndAmp = pDIEnvelope->dwFadeLevel;
		}
	}
	else // No Envelope
	{
		pEnvelope->m_Type = TIME;
		pEnvelope->m_Attack = 0;
		pEnvelope->m_Sustain = ulDuration;
		pEnvelope->m_Decay = 0;

		pEnvelope->m_StartAmp = 0;
		pEnvelope->m_SustainAmp = 100;
		pEnvelope->m_EndAmp = 0;
	}
	*pMaxLevel = ulMaxLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\joyregst.cpp ===
/****************************************************************************

    MODULE:     	joyregst.CPP
	Tab stops 5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for VJOYD Registry entries
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	0.1			20-Jun-96	MEA     original
				12-Mar-99	waltw	Removed dead joyGetOEMProductName &
										joyGetOEMForceFeedbackDriverDLLName
				20-Mar-99	waltw	Nuked dead GetRing0DriverName

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <stdio.h>
#include <TCHAR.h>
#include "joyregst.hpp"
#include "sw_error.hpp"
#include "Registry.h"
#include "FFDevice.h"
#include "CritSec.h"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//#define ACKNACK_1_16_DEFAULT 0x0000949A
#define ACKNACK_1_16_DEFAULT 0x0000955A
#define ACKNACK_1_20_DEFAULT 0x0000955A


MMRESULT joyGetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN OUT ULONG *pCOMMInterface,
			IN OUT ULONG *pCOMMPort)
{

	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	DWORD dwcb = sizeof(DWORD); 

	MMRESULT lr = RegQueryValueEx( hOEMForceFeedbackKey,
			  REGSTR_VAL_COMM_INTERFACE,
			  0, NULL,
			  (LPBYTE) pCOMMInterface,
			  (LPDWORD) &dwcb);
	if (SUCCESS != lr) return (lr);
	lr = RegQueryValueEx( hOEMForceFeedbackKey,
			  REGSTR_VAL_COMM_PORT,
			  0, NULL,
			  (LPBYTE) pCOMMPort,
			  (LPDWORD) &dwcb);
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"joyGetForceFeedbackCOMMInterface:COMMInterface=%lx, COMMPort=%lx\n",
			*pCOMMInterface, *pCOMMPort);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (lr);
}

MMRESULT joySetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN ULONG ulCOMMInterface,
			IN ULONG ulCOMMPort)
{
	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.SetValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(&ulCOMMInterface), sizeof(DWORD), REG_DWORD);
	MMRESULT lr = oemFFKey.SetValue(REGSTR_VAL_COMM_PORT, (BYTE*)(&ulCOMMPort), sizeof(DWORD), REG_DWORD);

	return (lr);
}


HKEY joyOpenOEMForceFeedbackKey(UINT id)
{
	JOYCAPS JoyCaps;
	TCHAR szKey[256];
	TCHAR szValue[256];
	UCHAR szOEMKey[256];

	HKEY hKey;
	DWORD dwcb;
	LONG lr;

// Note: JOYSTICKID1-16 is zero-based, Registry entries for VJOYD is 1-based.
	id++;		
	if (id > joyGetNumDevs() ) return 0;

// open .. MediaResources\CurentJoystickSettings
	joyGetDevCaps((id-1), &JoyCaps, sizeof(JoyCaps));
//
#ifdef _NOJOY
	strcpy(JoyCaps.szRegKey,"msjstick.drv<0004>");
#endif
//
//
	sprintf(szKey,
			"%s\\%s\\%s",
			REGSTR_PATH_JOYCONFIG,
			JoyCaps.szRegKey,
			REGSTR_KEY_JOYCURR);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) return 0;

// Get OEM Key name
	dwcb = sizeof(szOEMKey);
 	sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
	lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &szOEMKey, (LPDWORD) &dwcb);
	RegCloseKey(hKey);
	if (lr != ERROR_SUCCESS) return 0;

// open OEM\name\OEMForceFeedback	from ...MediaProperties
	sprintf(szKey, "%s\\%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey, 
			REGSTR_OEMFORCEFEEDBACK);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) 
		return 0;
	else
		return hKey;
}


/******************************************************
**
** GetAckNackMethodFromRegistry(UINT id)
**
** @mfunct GetAckNackMethodFromRegistry.
**
******************************************************/
DWORD GetAckNackMethodFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD ackNackInfo = 0;
	TCHAR firmwareString[32] = "";
	::wsprintf(firmwareString, TEXT("%d.%d-AckNack"), g_ForceFeedbackDevice.GetFirmwareVersionMajor(), g_ForceFeedbackDevice.GetFirmwareVersionMinor());
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(firmwareString, (BYTE*)&ackNackInfo, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
			if (g_ForceFeedbackDevice.GetFirmwareVersionMinor() < 20) {
				ackNackInfo = ACKNACK_1_16_DEFAULT;
			} else {	// 1.20 and greater
				ackNackInfo = ACKNACK_1_20_DEFAULT;
			}
		} else {	// Firmware greater than 1.0
			ackNackInfo = ACKNACK_1_20_DEFAULT;	// Use the latest I know of
		}
		ffRegKey.SetValue(firmwareString, (BYTE*)&ackNackInfo, sizeof(DWORD), REG_DWORD);
	}

	return ackNackInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\joyregst.hpp ===
/****************************************************************************

    MODULE:     	joyregst.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for VJOYD Registry functions
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original
			12-Mar-99		waltw	Removed dead joyGetOEMProductName &
										joyGetOEMForceFeedbackDriverDLLName
			20-Mar-99		waltw	Nuked dead GetRing0DriverName

****************************************************************************/
#ifndef joyregst_SEEN
#define joyregst_SEEN

#define REGSTR_OEMFORCEFEEDBACK 		        "OEMForceFeedback"
#define REGSTR_VAL_SFORCE_DRIVERDLL		        "Driver DLL"
#define REGSTR_VAL_SFORCE_PRODUCTNAME		    "ProductName"
#define REGSTR_VAL_SFORCE_MANUFACTURERNAME	    "Manufacturer"
#define REGSTR_VAL_SFORCE_PRODUCTVERSION	    "ProductVersion"
#define REGSTR_VAL_SFORCE_DEVICEDRIVERVERSION	"DeviceDriverVersion"
#define REGSTR_VAL_SFORCE_DEVICEFIRMWAREVERSION "DeviceFirmwareVersion"
#define REGSTR_VAL_SFORCE_INTERFACE		        "Interface"
#define REGSTR_VAL_SFORCE_MAXSAMPLERATE	        "MaxSampleRate"
#define REGSTR_VAL_SFORCE_MAXMEMORY		        "MaxMemory"
#define REGSTR_VAL_SFORCE_NUMBEROFSENSORS       "NumberOfSensors"
#define REGSTR_VAL_SFORCE_NUMBEROFAXES          "NumberOfAxes"
#define REGSTR_VAL_SFORCE_EFFECTSCAPS		    "EffectsCaps"
#define REGSTR_VAL_SFORCE_EXTRAINFO		        "ExtraInfo"
#define REGSTR_VAL_COMM_INTERFACE		        "COMMInterface"
#define REGSTR_VAL_COMM_PORT		        	"COMMPort"
#define REGSTR_VAL_RING0_DRIVER					"RING0 Driver"

HKEY 	 joyOpenOEMForceFeedbackKey(UINT id);
MMRESULT joyGetForceFeedbackCOMMInterface(UINT id, ULONG* ulArg1, ULONG* ulArg2);
MMRESULT joySetForceFeedbackCOMMInterface(UINT id, ULONG ulCOMMInterface, ULONG ulCOMMPort);

DWORD GetAckNackMethodFromRegistry(UINT id);

#define REGBITS_DESTROYEFFECT	14
#define REGBITS_PLAYEFFECT		12
#define REGBITS_STOPEFFECT		10
#define REGBITS_SETINDEX		8
#define REGBITS_MODIFYPARAM		6
#define REGBITS_SETDEVICESTATE	4
#define REGBITS_DOWNLOADEFFECT	2
#define REGBITS_DEVICEINIT		0

#define ACKNACK_NOTHING			0x00
#define ACKNACK_BUTTONSTATUS	0x01
#define ACKNACK_STATUSPACKET	0x02

#endif // of if joyregst_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi.hpp ===
/****************************************************************************

    MODULE:     	MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
        
****************************************************************************/
#ifndef _MIDI_SEEN
#define _MIDI_SEEN

#define MMNODRV
#define MMNOSOUND
#define MMNOWAVE
// #define MMNOMIDI  // we need the MIDI definitions
#define MMNOAUX
#define MMNOTIMER
#define MMNOJOY
#define MMNOMMIO
#define MMNOMCI
#include <winuser.h>
#include <mmsystem.h>

//////////////////////////////////////////////////////////////////////////////
//
// manifest constants and macros for MIDI message protocol
//
//////////////////////////////////////////////////////////////////////////////

// MIDI Status Bytes for Channel Voice Messages
#define MIDI_NOTE_OFF           0x80
#define MIDI_NOTE_ON            0x90
#define MIDI_POLY_PRESSURE      0xA0
#define MIDI_CONTROL_CHANGE     0xB0
#define MIDI_PROGRAM_CHANGE     0xC0
#define MIDI_CHANNEL_PRESSURE   0xD0
#define MIDI_AFTERTOUCH         0xD0  // synonym for channel pressure
#define MIDI_PITCH_WHEEL        0xE0

// MIDI Status Bytes for System Common Messages
#define MIDI_SYSEX              0xF0  // beginning of system exclusive message
#define MIDI_MTC_QTR_FRAME      0xF1
#define MIDI_SONG_POSITION_PTR  0xF2
#define MIDI_SONG_SELECT        0xF3
#define MIDI_TUNE_REQUEST       0xF6
#define MIDI_EOX                0xF7  // marks end of system exclusive message

// MIDI Status Bytes for System Real-Time Messages
#define MIDI_TIMING_CLOCK       0xF8
#define MIDI_START              0xFA
#define MIDI_CONTINUE           0xFB
#define MIDI_STOP               0xFC
#define MIDI_ACTIVE_SENSING     0xFE
#define MIDI_SYSTEM_RESET       0xFF

// control numbers for MIDI_CONTROL_CHANGE (MIDI status byte 0xB0)
// note: not a complete list
#define MIDI_MOD_WHEEL              0x01
#define MIDI_BREATH_CONTROL         0x02
#define MIDI_FOOT_CONTROL           0x04
#define MIDI_PORTAMENTO_TIME        0x05
#define MIDI_DATA_ENTRY_SLIDER      0x06
#define MIDI_VOLUME                 0x07
#define MIDI_BALANCE                0x08
#define MIDI_PAN                    0x0A
#define MIDI_EXPRESSION             0x0B
#define MIDI_GENERAL_PURPOSE_1      0x10   
#define MIDI_GENERAL_PURPOSE_2      0x11
#define MIDI_GENERAL_PURPOSE_3      0x12
#define MIDI_GENERAL_PURPOSE_4      0x13
#define MIDI_SUSTAIN                0x40
#define MIDI_PORTAMENTO             0x41
#define MIDI_SOSTENUTO              0x42
#define MIDI_SOFT                   0x43
#define MIDI_HOLD_2                 0x45
#define MIDI_GENERAL_PURPOSE_5      0x50
#define MIDI_GENERAL_PURPOSE_6      0x51
#define MIDI_GENERAL_PURPOSE_7      0x52
#define MIDI_GENERAL_PURPOSE_8      0x53
#define MIDI_EXTERNAL_EFFECTS_DEPTH 0x5B
#define MIDI_TREMELO_DEPTH          0x5C
#define MIDI_CHORUS_DEPTH           0x5D
#define MIDI_CELESTE_DEPTH          0x5E
#define MIDI_PHASER_DEPTH           0x5F
#define MIDI_DATA_INCREMENT         0x60
#define MIDI_DATA_DECREMENT         0x61
#define MIDI_NONREG_PARAM_NUM_MSB   0x62
#define MIDI_NONREG_PARAM_NUM_LSB   0x63
#define MIDI_REG_PARAM_NUM_MSB      0x64
#define MIDI_REG_PARAM_NUM_LSB      0x65
#define MIDI_RESET_ALL_CONTROLLERS  0x79
#define MIDI_LOCAL_CONTROL          0x7A
#define MIDI_ALL_NOTES_OFF          0x7B
#define MIDI_OMNI_MODE_OFF          0x7C
#define MIDI_OMNI_MODE_ON           0x7D
#define MIDI_MONO_MODE_ON           0x7E
#define MIDI_POLY_MODE_ON           0x7F      

// macro to pack a MIDI short message                                                
#define MAKEMIDISHORTMSG(cStatus, cChannel, cData1, cData2)            \
    cStatus | cChannel | (((UINT)cData1) << 8) | (((DWORD)cData2) << 16)
    
// macros to unpack a MIDI short message    
#define MIDI_STATUS(dwMsg)  ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0xF0 : LOBYTE(LOWORD(dwMsg)))
#define MIDI_CHANNEL(dwMsg) ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0x0F : 0)
#define MIDI_DATA1(dwMsg)   (HIBYTE(LOWORD(dwMsg)))
#define MIDI_DATA2(dwMsg)   (LOBYTE(HIWORD(dwMsg))) 

//////////////////////////////////////////////////////////////////////////////
//
// declarations for MIDI wrapper functions
//
//////////////////////////////////////////////////////////////////////////////

#define MIDI_IN      0x0001  // specifies MIDI input device
#define MIDI_OUT     0x0002  // specifies MIDI output device
#define NO_MIDI      0xFF00  // MIDI device unavaible or not selected 

#define MIDI_OPEN    0x0001  // uActivateMode parameter for MidiActivate
#define MIDI_CLOSE   0x0010  // uActivateMode parameter for MidiActivate
#define MIDI_ABANDON 0x0011  // uActivateMode parameter for MidiActivate
#define MIDI_BUSY    0xFF01  // possible MidiActivate return value

#define MIDI_ERRMSG_SIZE 128 // for MidiShowError string buffer

typedef struct _MIDIINFO     // MIDI device information block
{                           
    UINT uDeviceType;        // either MIDI_IN, MIDI_OUT or NO_MIDI
    UINT uDeviceID;          // ID of device chosen by user or NO_MIDI 
    union
    { 
        HMIDIIN  hMidiIn;    // input device handle used if MIDI_IN device
        HMIDIOUT hMidiOut;   // output device handle used if MIDI_OUT device
    };
    MIDIHDR MidiHdr;         // required for system exclusive   
    BOOL fAlwaysKeepOpen;    // access level requested by application
    UINT uDeviceStatus;      // current status of device
} MIDIINFO, *LPMIDIINFO;

// defines for MIDIINFO uDeviceStatus member
#define MIDI_DEVICE_IDLE        0x0000  // device is not in use
#define MIDI_DEVICE_BUSY        0x0001  // device is busy
#define MIDI_DEVICE_ABANDONED   0x0002  // device was reset while busy

    
BOOL MidiInit(LPMIDIINFO, LPMIDIINFO);
MMRESULT MidiGetDeviceName(UINT, UINT, LPWORD, LPWORD, LPSTR);
UINT MidiActivateDevice(LPMIDIINFO, UINT);
UINT MidiSendShortMsg(LPMIDIINFO, BYTE, BYTE, BYTE, BYTE); 
UINT MidiAssignBuffer(LPMIDIINFO, LPSTR, DWORD, BOOL);
UINT MidiSendLongMsg(LPMIDIINFO, BOOL);
UINT MidiRecord(LPMIDIINFO, BOOL);
BOOL MidiExit(LPMIDIINFO, LPMIDIINFO);

#endif // of ifdef _MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\hau_midi.hpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for HAU_MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
			16-Mar-99		waltw	Remove unused DetectMidiDevice declaration
			16-Mar-99		waltw	DEFAULT_GET_DATA_PACKET_DELAY changed from
									1 to 2. 1 worked OK for Win9x, but NT5
									requires a value of 2. See NT RAID# 295373
									(Jolt resets after crash in FlightSym 98)
			29-Mar-99		waltw	Fixed typo by restoring DEFAULT_GET_DATA_PACKET_DELAY
									to 1 and bumping DEFAULT_GET_ID_PACKET_DELAY -> 2
			29-Mar-99		waltw	& dennisle - bump DEFAULT_GET_STATUS_PACKET_DELAY ->2
									This fix may also fix the multi-proc issue.
        
****************************************************************************/
#ifndef _HAU_MIDI_SEEN
#define _HAU_MIDI_SEEN
#include "DX_MAP.hpp"

#define MAX_EFFECT_IDS				32
#define	NEW_EFFECT_ID				0x7f
#define SYSTEM_EFFECT_ID			0x7f
#define SYSTEM_RTCSPRING_ID			0
#define SYSTEM_FRICTIONCANCEL_ID	1
#define SYSTEM_RTCSPRING_ALIAS_ID	0x7e	// Due to internal ID=0 means create new

#define MAX_MIDI_CHANNEL		16
#define DEFAULT_MIDI_CHANNEL	5
#define DEFAULT_MIDI_PORTIO		0x330

#define COMM_WINMM					0x01
#define COMM_MIDI_BACKDOOR			0x02
#define COMM_SERIAL_BACKDOOR		0x03
#define COMM_SERIAL_FILE			0x04
#define MASK_OVERRIDE_MIDI_PATH		0x80000000
#define MASK_SERIAL_BACKDOOR		0x40000000
#define COMM_SERIAL1			1			// COMM Port 1
#define MIN_COMMSERIAL			1
#define MAX_COMMSERIAL			4

#define DEFAULT_JOLT_FORCE_RATE	100
#define DEFAULT_PERCENT			10000

#define MAX_SYS_EX_BUFFER_SIZE	1024		// Maximum Primary buffer size
#define DIFFERENCE_THRESHOLD	32			// Threshold to using absolute data
#define DIFFERENCE_BIT			0x40		// Bit to set for Difference data
#define MAX_MIDI_WAVEFORM_PACKET_SIZE	(256-20)	// Midi SYS_EX packet size
#define MAX_MIDI_WAVEFORM_DATA_SIZE	100		// Midi SYS_EX Data sample window size
#define	MAX_PLIST_EFFECT_SIZE	8			// 8 effects in a PList
#define MAX_PLIST_EFFECT		8			// 8 PLists allowed

#define MAX_INDEX				15
#define MAX_SIZE_SNAME			64								

#define MS_MANUFACTURER_ID		0x0a01 
#define JOLT_PRODUCT_ID			0x01         // REVIEW: Is this correct?

#define DRIVER_ERROR_NO_MIDI_INPUT	0x100	// No open Midi input device
#define DRIVER_ERROR_MIDI_OUTPUT	0x101	// Error outputing to Midi output


//
// --- RTC Spring defaults
//
#define	DEFAULT_RTC_KX		80
#define	DEFAULT_RTC_KY		80
#define	DEFAULT_RTC_X0		0
#define	DEFAULT_RTC_Y0		0
#define	DEFAULT_RTC_XSAT	96
#define	DEFAULT_RTC_YSAT	96
#define	DEFAULT_RTC_XDBAND	16
#define	DEFAULT_RTC_YDBAND	16

//
// --- Effect status code from Device
//
#define SWDEV_STS_EFFECT_STOPPED	0x01
#define SWDEV_STS_EFFECT_RUNNING	0x02

//
// --- Bitmasks for Device Status
//
#define BANDWIDTH_MASK			0x200		// Bandwidth bit
#define COMM_MODE_MASK			0x100		// 0 = MIDI, 1 = Serial
#define AC_FAULT_MASK			0x80		// 1= AC brick fault
#define HOTS_MASK				0x20		// Hands on Throttle Sensor
#define RESET_MASK				0x10		// 1 = Power On Reset detected
#define SHUTDOWN_MASK			0x08		// 0 = normal Shutdown, else 1 = Soft Reset

#define MINIMUM_BANDWIDTH		1
#define MAXIMUM_BANDWIDTH		100			// in %

//
// --- ERROR CODES from Device
//
#define DEV_ERR_SUCCESS			0x00	// Success
#define DEV_ERR_INVALID_ID		0x01	// Effect ID is invalid or not found
#define DEV_ERR_INVALID_PARAM	0x02	// Invalid parameter in data structure
#define DEV_ERR_CHECKSUM		0x03	// Invalid checksum
#define DEV_ERR_TYPE_FULL		0x04	// No more room for specified Effect
#define DEV_ERR_UNKNOWN_CMD		0x05	// Unrecognized command
#define DEV_ERR_PLAYLIST_FULL	0x06	// Play List is full, cannot play any
										// more effects
#define DEV_ERR_PROCESS_LIST_FULL 0x07	// Process List is full


//
// --- MIDI Command codes
//
#define MODIFY_CMD			0xA0
#define EFFECT_CMD	        0xB0
#define SYSTEM_CMD	        0xC0
#define STATUS_CMD			0xD0
#define RESPONSE_CMD	    0xE0		// Device to Host
#define SYS_EX_CMD			0xF0
#define ASSIGN_CMD	        0xF0
#define DNLOAD_CMD	        0xF0
#define UPLOAD_CMD	        0xF0
#define PROCESS_CMD	        0xF0
#define MIDI_EOX			0xF7

//
// --- Second byte sub-commands
//
// --- MIDI_CMD_EFFECT second byte sub-command
#define	NO_OVERRIDE         	0x00
#define DESTINATION_X			0x01
#define DESTINATION_Y			0x02
#define DESTINATION_XY			0x03
#define	PUT_FORCE_X				0x01
#define	PUT_FORCE_Y				0x02
#define	PUT_FORCE_XY			0x03
#define PLAY_EFFECT_SOLO		0x00
#define DESTROY_EFFECT			0x10	
#define	PLAY_EFFECT_SUPERIMPOSE	0x20
#define	STOP_EFFECT				0x30
#define SET_INDEX				0x40


// --- MIDI_CMD_SYSTEM second byte sub-command
#define SWDEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
#define SWDEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
#define SWDEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
#define SWDEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
#define SWDEV_PAUSE		5L		// All Effects are "Paused"
#define SWDEV_STOP_ALL	6L		// Stops all Effects. 
#define SWDEV_KILL_MIDI	7L		// Kills (tri-states) MIDI

// Remap for dinput modes
#define DEV_RESET       SWDEV_SHUTDOWN
#define DEV_FORCE_ON    SWDEV_FORCE_ON
#define DEV_FORCE_OFF   SWDEV_FORCE_OFF
#define DEV_CONTINUE    SWDEV_CONTINUE
#define DEV_PAUSE       SWDEV_PAUSE
#define DEV_STOP_ALL    SWDEV_STOP_ALL

//
// --- ACK and NACK 2nd byte from RESPONSE_CMD
//
#define ACK                 0x00
#define NACK                0x7f
#define ACKNACK_TIMEOUT		50			// 50*1msec timeout = 50msecs
#define ACKNACK_EFFECT_STATUS_TIMEOUT 1	// 1ms Timeout
#define MAX_RETRY_COUNT		10			// Retry count for comm NACKS
//#define MAX_GET_STATUS_PACKET_RETRY_COUNT 30
#define MAX_GET_STATUS_PACKET_RETRY_COUNT 10
#define SHORT_MSG_TIMEOUT	1
#define LONG_MSG_TIMEOUT	2
#define POWER_ON_MSG		0x007F00E5UL
#define RESPONSE_NACK		0x007FE0UL	// Example for MIDI channel 0.
#define RESPONSE_ACK		0x0000E0UL	// " "

// timing delays, in mS
#define DEFAULT_SHORT_MSG_DELAY				1		/* currently unused */
#define DEFAULT_LONG_MSG_DELAY				1
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	1
#define DEFAULT_SHUTDOWN_DELAY				10
#define DEFAULT_HWRESET_DELAY				20		
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	1
#define DEFAULT_GET_EFFECT_STATUS_DELAY		2
#define DEFAULT_GET_DATA_PACKET_DELAY		1
#define DEFAULT_GET_STATUS_PACKET_DELAY		2
#define DEFAULT_GET_ID_PACKET_DELAY			2
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY			0
#define DEFAULT_FORCE_OUT_DELAY				1
#define DEFAULT_DESTROY_EFFECT_DELAY		1
#define DEFAULT_FORCE_OUT_MOD				1

typedef struct _DELAY_PARAMS
{
	DWORD	dwBytes;
	DWORD	dwDigitalOverdrivePrechargeCmdDelay;
	DWORD	dwShutdownDelay;
	DWORD	dwHWResetDelay;
	DWORD	dwPostSetDeviceStateDelay;
	DWORD	dwGetEffectStatusDelay;
	DWORD	dwGetDataPacketDelay;
	DWORD	dwGetStatusPacketDelay;
	DWORD	dwGetIDPacketDelay;
	DWORD	dwGetStatusGateDataDelay;
	DWORD	dwSetIndexDelay;
	DWORD	dwModifyParamDelay;
	DWORD	dwForceOutDelay;
	DWORD	dwShortMsgDelay;
	DWORD	dwLongMsgDelay;
	DWORD	dwDestroyEffectDelay;
	DWORD	dwForceOutMod;
} DELAY_PARAMS, *PDELAY_PARAMS;

void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams);

//
// --- Format of Download command
//     Bytes in SYS EX body (starting from Byte 5 to (n-1)
//
// Byte     Contents
// -----    ---------
//  0       bOpCode			- see detail on OPCODE below
//  1       bSubType		- e.g. ET_UD_WAVEFORM, etc.
//	2		bEffectID		- Effect ID, 0x7f = Create New
//  3       bDurationL		- Low 7 bits duration in 2ms ticks, 0=Forever
//  4       bDurationH		- High 7 bits

//  5       bAngleL			- Low 7 bits Direction Angle
//  7	    bAngleH			- High 2 bits Direction Angle
//	8		bGain			- 7 bits Gain 1 - 100%
//	9		bButtonPlayL	- Low 7 bits button mask
//	10		bButtonPlayH	- High 2 bits button mask
//	11		bForceOutRateL	- Low 7 bits, 1 to 500 Hz
//	12		bForceOutRateH	- High 2 bits
//	13		bLoopCountL		- Low 7 bits Loop Count, Normally 1
//  14      bLoopCountH		- High 7 bits Loop count
//  		
//
//  The next block is optional and starts at Byte 15
//	15		bAttack			- %tage
//	16		bSustain;		- %tage
//  17 		bDecay;			- %tage
//
//  Otherwise, Type specific Parameters start at either Byte 15 or 18
//	18		Type specific parameter bytes here
//	  
//
//  ...
//  n       7 bits Checksum of bytes 0 to n
//
//
//
// --- MIDI_CMD_ASSIGN, MIDI_CMD_DNLOAD, MIDI_CMD_PROCESS
//     second byte sub-command
// Opcode is defined as follows:
// 7  6  5  4  3  2  1  0 
// -  -  -  -  -  -  -  -
// 0  c  c  c  a  a  d  d
//
// where:
//    c  c  c
//    -  -  -
//    0  0  0	- EXTEND_ESCAPE
//	  0  0  1	- MIDI_ASSIGN
//	  0  1  0	- DNLOAD_DATA
//	  0  1  1	- UPLOAD_DATA
//	  1  0  0	- PROCESS_DATA
//	  1  0  1	- reserved
//	  1  1  0	- reserved
//	  1  1  1	- reserved
// 
// and:
//             a  a
//             -  -
//             0  0 - DL_PLAY_STORE only after download
//             0  1 - DL_PLAY_SUPERIMPOSE right after download
//             1  0 - DL_PLAY_SOLO right after download
//			   1  1 - reserved
// and:
//		             d  d
//					 -  -
//					 0  0	- reserved
//					 0  1	- X-Axis
//					 1  0	- Y-Axis
//					 1  1	- X and Y-Axis
//

#define EXTEND_ESCAPE		0x00
#define MIDI_ASSIGN			0x10
#define DNLOAD_DATA			0x20
#define UPLOAD_DATA			0x30
#define PROCESS_DATA		0x40
#define GET_FORCE_EFFECT_VALUE	0x50

// --- Download sub-commands
//
#define DL_PLAY_STORE       0x00
#define DL_PLAY_SUPERIMPOSE 0x04
#define DL_PLAY_SOLO        0x08

//
// --- Process List sub-commands
//
#define PLIST_CONCATENATE      0x01 //0x11	// Temp. s/b 0x01
#define PLIST_SUPERIMPOSE      0x02 //0x12 // Temp. s/b 0x02


//
// --- Special UD_EFFECT parameters
//
#define UD_DIFFERENCE_DATA  0x40


//
// --- Bitmap Indexes into Parameter storage array
//
#define	INDEX0_MASK	 0x00000001L
#define INDEX1_MASK	 0x00000002L
#define INDEX2_MASK	 0x00000004L
#define INDEX3_MASK	 0x00000008L
#define INDEX4_MASK	 0x00000010L
#define INDEX5_MASK	 0x00000020L
#define	INDEX6_MASK	 0x00000040L
#define INDEX7_MASK	 0x00000080L
#define INDEX8_MASK	 0x00000100L
#define INDEX9_MASK	 0x00000200L
#define INDEX10_MASK 0x00000400L
#define INDEX11_MASK 0x00000800L
#define INDEX12_MASK 0x00001000L
#define INDEX13_MASK 0x00002000L
#define INDEX14_MASK 0x00004000L
#define INDEX15_MASK 0x00008000L

#define	INDEX0	0L
#define INDEX1	1L
#define INDEX2	2L
#define INDEX3	3L
#define INDEX4	4L
#define INDEX5	5L
#define	INDEX6	6L
#define INDEX7	7L
#define INDEX8	8L
#define INDEX9	9L
#define INDEX10 10L
#define INDEX11 11L
#define INDEX12 12L
#define INDEX13 13L
#define INDEX14 14L
#define INDEX15 15L

	
//
// --- Effect types
//

#define ET_UD_WAVEFORM      	1   // User Defined Waveform

#define ET_SE_SINE				2	// Sinusoidal
#define ET_SE_COSINE			3	// Cosine
#define ET_SE_SQUARELOW			4	// Square starting Low	
#define ET_SE_SQUAREHIGH		5	// Square starting High	
#define ET_SE_RAMPUP        	6   // Ramp UP			    
#define ET_SE_RAMPDOWN      	7   // Ramp Down		    
#define	ET_SE_TRIANGLEUP    	8	// Triangle rising	    
#define ET_SE_TRIANGLEDOWN		9	// Triangle falling
#define ET_SE_SAWTOOTHUP		10	// Sawtooth rising 
#define ET_SE_SAWTOOTHDOWN		11	// Sawtooth falling

#define ET_BE_DELAY				12  // NOP delay
#define ET_BE_SPRING        	13  // Springs
#define ET_BE_DAMPER        	14  // Dampers
#define ET_BE_INERTIA       	15  // Gravity
#define ET_BE_FRICTION      	16  // Friction
#define ET_BE_WALL 				17 	// Wall (bumper)
#define ET_SE_CONSTANT_FORCE	18	// Constant Force

#define ET_PL_CONCATENATE		19	// Concatenate process list
#define ET_PL_SUPERIMPOSE		20	// Superimpose process list

// ROM Effect IDS
#define ET_RE_ROMID1			32
#define ET_RE_ROMID2			33
#define ET_RE_ROMID3			34
#define ET_RE_ROMID4			35
#define ET_RE_ROMID5			36
#define ET_RE_ROMID6			37
#define ET_RE_ROMID7			38
#define ET_RE_ROMID8			39
#define ET_RE_ROMID9			40
#define ET_RE_ROMID10			41
#define ET_RE_ROMID11			42
#define ET_RE_ROMID12			43
#define ET_RE_ROMID13			44
#define ET_RE_ROMID14			45
#define ET_RE_ROMID15			46
#define ET_RE_ROMID16			47
#define ET_RE_ROMID17			48
#define ET_RE_ROMID18			49
#define ET_RE_ROMID19			50
#define ET_RE_ROMID20			51
#define ET_RE_ROMID21			52
#define ET_RE_ROMID22			53
#define ET_RE_ROMID23			54
#define ET_RE_ROMID24			55
#define ET_RE_ROMID25			56
#define ET_RE_ROMID26			57
#define ET_RE_ROMID27			58
#define ET_RE_ROMID28			59
#define ET_RE_ROMID29			60
#define ET_RE_ROMID30			61
#define ET_RE_ROMID31			62
#define ET_RE_ROMID32			63
#define ET_RE_ROMID33			64
#define ET_RE_ROMID34			65
#define ET_RE_ROMID35			66
#define ET_RE_ROMID36			67
#define ET_RE_ROMID37			68

 								
// more to be defined....		
 
//
// Effect IDs as defined in Jolt device
//
#define	EFFECT_ID_RTC_SPRING		0	// Built-in Return To Center Virtual Spring
#define	EFFECT_ID_FRICTIONCANCEL	1	// Friction cancellation


//
// --- Process List Structure
//
typedef struct _PLIST {
	ULONG	ulNumEffects;
	ULONG	ulProcessMode;	// PLIST_SUPERIMPOSE or PLIST_CONCATENATE
	PDNHANDLE pEffectArray;	// Effect ID[0} . . .
	ULONG	ulAction;
	ULONG	ulDuration;
} PLIST, *PPLIST;

//
// --- Behavioral Effects Structure
//
typedef struct _BE_XXX {
	LONG	m_XConstant;	//(KX/BX/MX/FX/Wall type)	
	LONG	m_YConstant;	//(KY/BY/MY/FY/KWall)
	LONG	m_Param3;		//(CX/VX/AX/Wall angle)
	LONG	m_Param4;		//(CY/VYO/AY/Wall distance)
} BE_XXX, *PBE_XXX;

//
// --- SysEx Messages
//
typedef struct _SYS_EX_HDR {
	BYTE		m_bSysExCmd;	// SysEx Fx command
	BYTE		m_bEscManufID;	// Escape to long Manufac. ID, s/b 0
	BYTE		m_bManufIDL;	// Low byte
	BYTE		m_bManufIDH;	// High byte
	BYTE		m_bProdID;		// Product ID
} SYS_EX_HDR, *PSYS_EX_HDR;

// --- Common Effect parameters
typedef struct _MIDI_EFFECT {
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bAngleL;		// Low 7 bits Direction Angle
	BYTE		bAngleH;		// High 2 bits Direction Angle
	BYTE		bGain;			// 7 bits Gain 1 - 100%
	BYTE		bForceOutRateL;	// Low 7 bits, 1 to 500 Hz
	BYTE		bForceOutRateH;	// High 2 bits
	BYTE		bPercentL;		// Low 7 bits Percent of waveform 1 to 10000
	BYTE		bPercentH;		// High 7 bits Loop Count
} MIDI_EFFECT, *PMIDI_EFFECT;

// --- Envelope
typedef struct MIDI_ENVELOPE {
	BYTE		bAttackLevel;	// Initial Attack amplitude 0 to +127
	BYTE		bSustainL;		// time to Sustain in 2ms ticks
	BYTE		bSustainH;		// 
	BYTE		bSustainLevel;	// Amplitude level to sustain
	BYTE		bDecayL;		// time to Decay in 2ms ticks 
	BYTE		bDecayH;
	BYTE		bDecayLevel;	// Amplitude level to decay
} MIDI_ENVELOPE, *PMIDI_ENVELOPE;
 
// --- Midi Assign
typedef struct _MIDI_ASSIGN_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: MIDI_ASSIGN
	BYTE		bChannel;		// Midi channel 1-16
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_ASSIGN_SYS_EX, *PMIDI_ASSIGN_SYS_EX;

// --- Get Effect Force Value at a tick sample time
typedef struct _MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX  {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: GET_EFFECT_FORCE_VALUE
	BYTE		bEffectID;		// Effect ID
	BYTE		bSampleTimeL;	// Low 7 bits in 2ms ticks
	BYTE		bSampleTimeH;	// High 7 bits in 2ms ticks
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX, *PMIDI_GET_EFFECT_FORCE_VALUE_SYS_EX;


// --- Note: For the following, if bEffectID = 0x7f, then New, else Modify
// --- Download Data - Synthesized Waveform
typedef struct _SE_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// ex: ET_SE_SINE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
// SE Parameters
	BYTE		bFreqL;			// Low 7 bits Frequency 1-2048Hz
	BYTE		bFreqH;			// High 4 bits	  
	BYTE		bMaxAmpL;		// Low 7 bits Maximum Amplitude	+/- 100%
	BYTE		bMaxAmpH;		// High 1 bit
	BYTE		bMinAmpL;		// Low 7 bits Minimum Amplitude	+/- 100%
	BYTE		bMinAmpH;		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} SE_WAVEFORM_SYS_EX, *PSE_WAVEFORM_SYS_EX;

// --- Download Data - NOP Delay
typedef struct _NOP_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID, 0x7F = Create NEw
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bChecksum;
	BYTE		bEOX;
} NOP_SYS_EX, *PNOP_SYS_EX;

// --- Download Data - Behavioral SysEx 
typedef struct _BEHAVIORAL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_SPRING
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_XXX Parameters
	BYTE		bXConstantL;	// Low 7 bits K	(in +/- 100%) X-Axis
	BYTE		bXConstantH;	// High 1 bit K
	BYTE		bYConstantL;	// Low 7 bits K	(in +/- 100%) Y-Axis
	BYTE		bYConstantH;	// High 1 bit K
	BYTE		bParam3L;   	// Low 7 bits Axis center (in +/- 100%)	X-Axis
	BYTE		bParam3H;  		// High 1 bit
	BYTE		bParam4L;   	// Low 7 bits Axis center (in +/- 100%)	Y-Axis
	BYTE		bParam4H;  		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} BEHAVIORAL_SYS_EX, *PBEHAVIORAL_SYS_EX;


// --- Download Data - Friction SysEx
typedef struct _FRICTION_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_FRICTION Parameters
	BYTE		bXFConstantL;	// Low 7 bits F	(in +/- 100%) X-Axis
	BYTE		bXFConstantH;	// High 1 bit F
	BYTE		bYFConstantL;	// Low 7 bits F	(in +/- 100%) Y-Axis
	BYTE		bYFConstantH;	// High 1 bit F
	BYTE		bChecksum;
	BYTE		bEOX;
} FRICTION_SYS_EX, *PFRICTION_SYS_EX;


// --- Download Data - WALL SysEx
#define INNER_WALL				0	// Wall face to center
#define	OUTER_WALL				1	// Wall face away from center

typedef struct _WALL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: e.g. EF_BE_WALL
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_SPRING Parameters
	BYTE		bWallType;		// INNER_WALL or OUTER_WALL
	BYTE		bWallConstantL;	// Low 7 bits: Similar to Spring Constant.  
								//   Value is from +/- 100%. 
	BYTE		bWallConstantH;	// High 1 bit
	BYTE		bWallAngleL;	// Low 7 bits: 0 to 359 degrees
								//   For simple vertical and horizontal walls, 
								//   this value should be set to 0, 90,  180, 270
	BYTE		bWallAngleH;	// Low 2 bit
	BYTE		bWallDistance;  // 7 bits: Distance from Center of stick 0 to 100
	BYTE		bChecksum;
	BYTE		bEOX;
} WALL_SYS_EX, *PWALL_SYS_EX;

// --- Download Data - User Defined Waveform SysEx
typedef struct _UD_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
//	BYTE		bWaveformArray;	// Force Data . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} UD_WAVEFORM_SYS_EX, *PUD_WAVEFORM_SYS_EX;
#define UD_WAVEFORM_START_OFFSET (sizeof(UD_WAVEFORM_SYS_EX))


// --- Download Data - Process List SysEx
typedef struct _PROCESS_LIST_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bEffectArrayID;	// Effect ID[0] . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} PROCESS_LIST_SYS_EX, *PPROCESS_LIST_SYS_EX;
#define PROCESS_LIST_EFFECT_START_OFFSET (sizeof(PROCESS_LIST_SYS_EX))


//
// --- Function Prototypes
//
HRESULT CMD_Init(void);

HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID);

HRESULT CMD_ModifyParam( 
	IN WORD wNewParam);

HRESULT CMD_ModifyParamByIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID, 
	IN WORD wNewParam);

HRESULT CMD_Force_Out(
    IN LONG lForceData, 
    IN ULONG ulAxisMask);

HRESULT CMD_DestroyEffect( 
	IN DNHANDLE hEffectID);

HRESULT CMD_PlayEffectSolo( 
	IN DNHANDLE hEffectID);

HRESULT CMD_PlayEffectSuperimpose( 
	IN DNHANDLE hEffectID);

HRESULT CMD_StopEffect( 
	IN DNHANDLE hEffectID);

HRESULT CMD_SetDeviceState(
	IN ULONG ulMode);

HRESULT CMD_GetEffectStatus(
	IN DNHANDLE hDnloadID, 
	IN OUT PBYTE pStatusCode);

HRESULT CMD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex, 
	IN OUT PLONG pForceValue);

HRESULT CMD_MIDI_Assign(
	IN BYTE bMidiChannel);

HRESULT CMD_Download_NOP_DELAY(
 	IN ULONG ulDuration,
	IN PEFFECT pEffect,
 	IN OUT PDNHANDLE pDnloadID);

HRESULT CMD_Download_UD_Waveform(
	IN ULONG ulDuration,
	IN PEFFECT pEffect,
	IN ULONG ulNumVectors,
 	IN PLONG pUD_Array,
	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_SYNTH(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PSE_PARAM pSE_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFX_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_RTCSpring(
 	IN PRTCSPRING_PARAM pRTCSpring,
	IN OUT PDNHANDLE pDnloadID);

HRESULT CMD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
 	IN ULONG ulAction);

HRESULT CMD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
 	IN ULONG ulAction);

HRESULT ModifyEffectParams(
	IN DNHANDLE DnloadID,
	IN PEFFECT pEffect,
	IN DWORD dwFlags);

class CMidiSynthesized;

HRESULT ModifyEnvelopeParams(
	IN CMidiSynthesized *pMidiEffect,
	IN DNHANDLE DnloadID,
	IN ULONG ulDuration,
	IN PENVELOPE pEnvelope,
	IN DWORD dwFlags);

void MapEnvelope( 
	IN ULONG ulDuration,
	IN ULONG dwMagnitude,
	IN ULONG * pMaxLevel,
	IN LPDIENVELOPE pDIEnvelope, 
	IN OUT PENVELOPE pEnvelope);


#endif // of ifdef _HAU_MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_obj.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for SWFF MIDI device object

    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -----------------------------------------
	0.1			10-Sep-96	MEA     original
	1.1			20-May-97	MEA		Added Mutex and Thread safe code
				17-Jun-97	MEA		Fixed bug Midi Handle lost if 1st process
									terminated.
				16-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
									and pass down food chain
				16-Mar-99	waltw	GetRing0DriverName in InitDigitalOverDrive
									now passes down joystick ID
				20-Mar-99	waltw	Added dwDeviceID param to DetectMidiDevice
				20-Mar-99	waltw	Comment out invalid call to CloseHandle in dtor

****************************************************************************/
#include <assert.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mmsystem.h>
#include "SW_Error.hpp"
#include "midi_obj.hpp"
#include "vxdioctl.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "CritSec.h"

#define NT50 1

#include "DTrans.h"
DataTransmitter* g_pDataTransmitter = NULL;

/****************************************************************************

   Declaration of externs

****************************************************************************/
extern void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;

/****************************************************************************

   Declaration of variables

****************************************************************************/


/****************************************************************************

   Macros etc

****************************************************************************/

#ifdef _DEBUG
extern char g_cMsg[160];
void DebugOut(LPCTSTR szDebug)
{
	g_CriticalSection.Enter();
	OutputDebugString(szDebug);
	g_CriticalSection.Leave();

#ifdef _LOG_DEBUG
#pragma message("Compiling with Debug Log to sw_effct.txt")
	FILE *pf = fopen("sw_effct.txt", "a");
	if (pf != NULL)
	{
		fputs(szDebug, pf);
		fclose(pf);
	}
#endif // _LOG_DEBUG
}
#else !_DEBUG
#define DebugOut(x)
#endif // _DEBUG


// ****************************************************************************
// *** --- Member functions for base CJoltMidi
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::CJoltMidi
// Purpose:		Constructor(s)/Destructor for CJoltMidi Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CJoltMidi::CJoltMidi(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	static char cWaterMark[MAX_SIZE_SNAME] = {"SWFF_SHAREDMEMORY MEA"};
	BOOL bAlreadyMapped = FALSE;
#ifdef _DEBUG
	DebugOut("sw_effct(DX):CJoltMidi::CJoltMidi\n");
#endif
	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

	// Create an in-memory memory-mapped file
	m_hSharedMemoryFile = CreateFileMapping((HANDLE) 0xFFFFFFFF,
							NULL, PAGE_READWRITE, 0, SIZE_SHARED_MEMORY,
    							__TEXT(SWFF_SHAREDMEM_FILE));

	if (m_hSharedMemoryFile == NULL)
	{
#ifdef _DEBUG
	    DebugOut("sw_effct(DX):ERROR! Failed to create Memory mapped file\n");
#endif
	}
	else
	{
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	    {
			bAlreadyMapped = TRUE;
	    }
		// File mapping created successfully.
		// Map a view of the file into the address space.
		m_pSharedMemory = (PSHARED_MEMORY) MapViewOfFile(m_hSharedMemoryFile,
			              FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
		if ((BYTE *) m_pSharedMemory == NULL)
		{
#ifdef _DEBUG
		    DebugOut("sw_effct(DX):ERROR! Failed to Map view of shared memory\n");
#endif
		}

// ***** Shared Memory Access *****
		LockSharedMemory();
		if (!bAlreadyMapped)
		{
			// Set watermark and initialize, Bump Ref Count
			memcpy(&m_pSharedMemory->m_cWaterMark[0], &cWaterMark[0], MAX_SIZE_SNAME);
			m_pSharedMemory->m_RefCnt = 0;
		}
		m_pSharedMemory->m_RefCnt++;
	}
#ifdef _DEBUG
		wsprintf(g_cMsg, "sw_effct(DX): Shared Memory:%lx, m_RefCnt:%d\n",m_pSharedMemory,
				m_pSharedMemory->m_RefCnt);
		DebugOut(g_cMsg);
#endif
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****

// --- END OF CRITICAL SECTION
//
}

// --- Destructor
CJoltMidi::~CJoltMidi()
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	BOOL bKillObject = FALSE;

#ifdef _DEBUG
	DebugOut("sw_effct(DX):CJoltMidi::~CJoltMidi()\n");
#endif
	// Normal CJoltMidi Destructor
	// Free all buffers and other data
    if (m_lpCallbackInstanceData) FreeCallbackInstanceData();

	// Free the MIDI Effect objects (except RTC Spring)
	DeleteDownloadedEffects();

// Free the Primary SYS_EX locked memory
	if (m_hPrimaryBuffer)
	{
	    GlobalUnlock(m_hPrimaryBuffer);
    	GlobalFree(m_hPrimaryBuffer);
	}

// ***** Shared Memory Access *****
	LockSharedMemory();
	// Decrement Ref Count and clean up if equal to zero.
	m_pSharedMemory->m_RefCnt--;
#ifdef _DEBUG
	wsprintf(g_cMsg,"CJoltMidi::~CJoltMidi. RefCnt = %d\n",m_pSharedMemory->m_RefCnt);
	DebugOut(g_cMsg);
#endif

	if (0 == m_pSharedMemory->m_RefCnt)	
	{
		bKillObject = TRUE;

		// Tri-state Midi lines
		CMD_SetDeviceState(SWDEV_KILL_MIDI);

		if (m_pSharedMemory->m_hMidiOut) {
			if (COMM_WINMM == m_COMMInterface) {
				DebugOut("CJoltMidi::~CJoltMidi. Resetting and closing Midi handles\n");

				// Reset, close and release Midi Handles
				midiOutReset(HMIDIOUT(m_pSharedMemory->m_hMidiOut));
				midiOutClose(HMIDIOUT(m_pSharedMemory->m_hMidiOut));
			}
			// This is bogus - midiOutClose has already closed this handle
			// if (g_pDataTransmitter == NULL) {		// DataTransmitter closes its own handle
			//  	CloseHandle(m_pSharedMemory->m_hMidiOut);
			// }
			m_pSharedMemory->m_hMidiOut = NULL;
		}

		// Kill Data Transmitter
		if (g_pDataTransmitter != NULL) {
			delete g_pDataTransmitter;
			g_pDataTransmitter = NULL;
		}


		// Release Mutex handles
//		if (m_hSWFFDataMutex) CloseHandle(m_hSWFFDataMutex); -- Unlock will take care of this

		// Kill RTC Spring object
		if (m_pJoltEffectList[SYSTEM_RTCSPRING_ID])
		{
			delete m_pJoltEffectList[SYSTEM_RTCSPRING_ID];
			m_pJoltEffectList[SYSTEM_RTCSPRING_ID] = NULL;
		}
		// Release the Midi Output Event handles
		if (m_hMidiOutputEvent)	
		{
			CloseHandle (m_hMidiOutputEvent);
			m_hMidiOutputEvent = NULL;
		}
	}

	UnlockSharedMemory();
// ***** End of Shared Memory Access *****

	// Release Memory Mapped file handles
	if (m_hSharedMemoryFile)
	{
		BOOL bRet = UnmapViewOfFile((LPCVOID) m_pSharedMemory);
		bRet = CloseHandle(m_hSharedMemoryFile);
	}

	// Close VxD handles
	if (g_pDriverCommunicator != NULL)
	{
		delete g_pDriverCommunicator;
		g_pDriverCommunicator = NULL;
	}

	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

// --- END OF CRITICAL SECTION
//
	if (bKillObject)
	{
		// Delete the critical section object
//		DeleteCriticalSection(&g_SWFFCriticalSection);
	}
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::Initialize
// Purpose:		Initializer
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::Initialize(DWORD dwDeviceID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet = SUCCESS;

	// initialize the MIDI output information block
	m_MidiOutInfo.uDeviceType     = MIDI_OUT;
	m_MidiOutInfo.hMidiOut        = NULL;
    m_MidiOutInfo.fAlwaysKeepOpen = TRUE;
    m_MidiOutInfo.uDeviceStatus   = MIDI_DEVICE_IDLE;
	m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;
	m_MidiOutInfo.MidiHdr.dwUser = 0;
	m_MidiOutInfo.MidiHdr.dwOffset = 0;
	m_MidiOutInfo.MidiHdr.dwFlags = 0;
	
    // Allocate and lock global memory for SysEx messages
    m_hPrimaryBuffer = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, MAX_SYS_EX_BUFFER_SIZE);
	assert(m_hPrimaryBuffer);
	if(NULL == m_hPrimaryBuffer)
	{
		return (SFERR_DRIVER_ERROR);
	}

    m_pPrimaryBuffer = (LPBYTE) GlobalLock(m_hPrimaryBuffer);
	assert(m_pPrimaryBuffer);
    if(NULL == m_pPrimaryBuffer)
	{
	   	GlobalFree(m_hPrimaryBuffer);
		return (SFERR_DRIVER_ERROR);
	}

	// Initialize the IOCTL interface to VjoyD mini-driver
	hRet = InitDigitalOverDrive(dwDeviceID);
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Digital OverDrive\n");
		return (hRet);
	}
	else
		DebugOut("InitDigitalOverDrive - Success\n");

	// Create a Callback Event
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (NULL == hEvent)
	{
		// Create an Event for notification when Midi Output has completed
		m_hMidiOutputEvent = CreateEvent(NULL,  // No security
                          TRUE,			// Manual reset
                          FALSE,		// Initial event is non-signaled
                          SWFF_MIDIEVENT );		// Named
		assert(m_hMidiOutputEvent);
	}
	else
		m_hMidiOutputEvent = hEvent;

	// We are only called after g_pJoltMidi is created
	assert(g_pJoltMidi);
	PDELAY_PARAMS pDelayParams = g_pJoltMidi->DelayParamsPtrOf();
	GetDelayParams(dwDeviceID, pDelayParams);

	// Reset HW first
	g_pDriverCommunicator->ResetDevice();
	Sleep(DelayParamsPtrOf()->dwHWResetDelay);

	// Set MIDI channel to default then Detect a Midi Device
	SetMidiChannel(DEFAULT_MIDI_CHANNEL);
	if (!DetectMidiDevice(dwDeviceID,				// joystick ID
						  &m_MidiOutInfo.uDeviceID,	// Midi Device ID
						  &m_COMMInterface, 		// COMM_WINMM||COMM_BACKDOOR
						  							// ||COMM_SERIAL
						  &m_COMMPort))				// Port address
	{
		DebugOut("SW_EFFCT: Warning! No Midi Device detected\n");
		return (SFERR_DRIVER_ERROR);
	}
	else
	{
#ifdef _DEBUG
		wsprintf(g_cMsg,"DetectMidiDevice returned: DeviceID=%d, COMMInterface=%x, COMMPort=%x\n",
			m_MidiOutInfo.uDeviceID, m_COMMInterface, m_COMMPort);
		DebugOut(g_cMsg);
#endif
	}

// Allocate the Instance data buffer
    m_lpCallbackInstanceData = AllocCallbackInstanceData();
	assert(m_lpCallbackInstanceData);

// Initialize Midi channel, then open the Input and Output channels
	m_MidiChannel = DEFAULT_MIDI_CHANNEL;

	// Send Initialization packet(s) to Jolt
	hRet = CMD_Init();
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Jolt\n");
		return (hRet);
	}		
	else
		DebugOut("JOLT CMD_Init - Success\n");

	// At this point, we have a valid MIDI path...
	// Continue by setting up the ROM Effects default table entries
							 // ID  , OutputRate, Gain, Duration
	static	ROM_FX_PARAM RomFxTable [] = {{ RE_ROMID1 , 100, 100, 12289 }, // Random Noise
								  { RE_ROMID2 , 100, 100,  2625 }, // AircraftCarrierTakeOff
								  { RE_ROMID3 , 100,  50,   166 }, // BasketballDribble
								  { RE_ROMID4 , 100,  14, 10000 }, // CarEngineIdling
								  { RE_ROMID5 , 100,  30,  1000 }, // Chainsaw
								  { RE_ROMID6 , 100, 100,  1000 }, // ChainsawingThings
								  { RE_ROMID7 , 100,  40, 10000 }, // DieselEngineIdling
								  { RE_ROMID8 , 100, 100,   348 }, // Jump
								  { RE_ROMID9 , 100, 100,   250 }, // Land
								  { RE_ROMID10, 200, 100,  1000 }, // MachineGun
								  { RE_ROMID11, 100, 100,    83 }, // Punched
								  { RE_ROMID12, 100, 100,  1000 }, // RocketLauncher
								  { RE_ROMID13, 100,  98,   500 }, // SecretDoor
								  { RE_ROMID14, 100,  66,    25 }, // SwitchClick
								  { RE_ROMID15, 100,  75,   500 }, // WindGust
								  { RE_ROMID16, 100, 100,  2500 }, // WindShear
								  { RE_ROMID17, 100, 100,    50 }, // Pistol
								  { RE_ROMID18, 100, 100,   295 }, // Shotgun
								  { RE_ROMID19, 500,  95,  1000 }, // Laser1
								  { RE_ROMID20, 500,  96,  1000 }, // Laser2
								  { RE_ROMID21, 500, 100,  1000 }, // Laser3
								  { RE_ROMID22, 500, 100,  1000 }, // Laser4
								  { RE_ROMID23, 500, 100,  1000 }, // Laser5
								  { RE_ROMID24, 500,  70,  1000 }, // Laser6
								  { RE_ROMID25, 100, 100,    25 }, // OutOfAmmo
								  { RE_ROMID26, 100,  71,  1000 }, // LigntningGun
								  { RE_ROMID27, 100, 100,   250 }, // Missile
								  { RE_ROMID28, 100, 100,  1000 }, // GatlingGun
								  { RE_ROMID29, 500,  97,   250 }, // ShortPlasma
								  { RE_ROMID30, 500, 100,   500 }, // PlasmaCannon1
								  { RE_ROMID31, 500,  99,   625 }, // PlasmaCannon2
								  { RE_ROMID32, 100, 100,   440 }}; // Cannon
//								  { RE_ROMID33, 100,  68,  1000 }, // FlameThrower
//								  { RE_ROMID34, 100, 100,    75 }, // BoltActionRifle
//								  { RE_ROMID35, 500, 100,   300 }, // Crossbow
//								  { RE_ROMID36, 100, 100,  1000 }, // Sine
//								  { RE_ROMID37, 100, 100,  1000 }}; // Cosine
	m_pRomFxTable = &RomFxTable[0];

// ***** Shared Memory Access *****
	LockSharedMemory();
	LONG lRefCnt = m_pSharedMemory->m_RefCnt;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		
	// Initialize the RTC_Spring object
	SYSTEM_PARAMS SystemParams;
	GetSystemParams(dwDeviceID, &SystemParams);

	RTCSPRING_PARAM RTCSpring = { sizeof(RTCSPRING_PARAM),
								  DEFAULT_RTC_KX,
								  DEFAULT_RTC_KY,
								  DEFAULT_RTC_X0,
								  DEFAULT_RTC_Y0,
								  DEFAULT_RTC_XSAT,
								  DEFAULT_RTC_YSAT,
								  DEFAULT_RTC_XDBAND,
								  DEFAULT_RTC_YDBAND };

	
	CMidiRTCSpring * pMidiRTCSpring = new CMidiRTCSpring(&RTCSpring);

	SetEffectByID(SYSTEM_RTCSPRING_ID, pMidiRTCSpring);

	DNHANDLE DnHandle;
	CMD_Download_RTCSpring(&(SystemParams.RTCSpringParam),&DnHandle);

	// initialize the joystick params
	JOYSTICK_PARAMS JoystickParams;
	GetJoystickParams(dwDeviceID, &JoystickParams);
	UpdateJoystickParams(&JoystickParams);

	// initialize the firmware params fudge factors (for the first time)
	// in the case of the FFD interface, this will be the only time they
	// are initialized, which may cause a problem because joystick is assumed
	// to be ID1
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	GetFirmwareParams(dwDeviceID, pFirmwareParams);

// --- END OF CRITICAL SECTION
//
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::LockSharedMemory
// Purpose:     Creates a Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     TRUE if Mutex available else FALSE

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::LockSharedMemory(void)
{
	DWORD dwRet;
	{ // --- THIS IS A CRITICAL SECTION
		CriticalLock cl;

		// Create the SWFF mutex
		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, SWFF_SHAREDMEM_MUTEX);
		if (NULL == hMutex) {
			// Doesn't exist yet, so create it
			hMutex = CreateMutex(NULL, TRUE, SWFF_SHAREDMEM_MUTEX);
			if (NULL == hMutex)
			{
#ifdef _DEBUG
				DebugOut("Error! Could not create SWFFDataMutex\n");
#endif
				m_hSWFFDataMutex = NULL;
				return (FALSE);
			}
		}
		// SUCCESS
		m_hSWFFDataMutex = hMutex;
		dwRet = WaitForSingleObject(m_hSWFFDataMutex, MUTEX_TIMEOUT);
	} 	// --- END OF CRITICAL SECTION

	if (WAIT_OBJECT_0 == dwRet)
		return (TRUE);
	else
	{
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"CJoltMidi::LockSharedMemory() error return: %lx\n", dwRet);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif		
		return (FALSE);
	}
}


// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::UnlockSharedMemory
// Purpose:     Releases Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     none

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
void CJoltMidi::UnlockSharedMemory(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	if (NULL != m_hSWFFDataMutex)
	{
		ReleaseMutex(m_hSWFFDataMutex);
		CloseHandle(m_hSWFFDataMutex);
		m_hSWFFDataMutex=NULL;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::NewEffectID
// Purpose:		Generates a new Effect ID
// Parameters:	PDNHANDLE pDnloadID	- Pointer to a new Effect ID
//
// Returns:		TRUE if successful, else FALSE
// Algorithm:
// ----------------------------------------------------------------------------
BOOL CJoltMidi::NewEffectID(PDNHANDLE pDnloadID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	BOOL bRet = FALSE;
	int nID_Index = 2;		// ID0 = RTC Spring, ID1 = Friction cancellation
	for (int i=nID_Index; i<MAX_EFFECT_IDS; i++)
	{
		if (NULL == m_pJoltEffectList[i])
		{
			*pDnloadID = (DNHANDLE) i;
#ifdef _DEBUG
			wsprintf(g_cMsg,"New Effect ID=%d\n",i);
			DebugOut(g_cMsg);
#endif
			bRet = TRUE;
			break;
		}
	}

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (bRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::DeleteDownloadedEffects
// Purpose:		Deletes all downloaded Effects
// Parameters:	none
//
// Returns:
// Algorithm:
// Note: Does not delete System Effect IDs like RTC_SPRING and FRICTION CANCEL
//
// ----------------------------------------------------------------------------
void CJoltMidi::DeleteDownloadedEffects(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

#ifdef _DEBUG
	DebugOut("CJoltMidi::DeleteDownloadedEffects()\n");
#endif
	// Free the MIDI Effect objects
	for (int i=(SYSTEM_RTCSPRING_ID+1); i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i])
		{
			delete m_pJoltEffectList[i];
			m_pJoltEffectList[i]= NULL;
		}
	}

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::RestoreDownloadedEffects
// Purpose:		Restores all Downloaded Effects
// Parameters:	none
//
// Returns:
// Algorithm:
// ----------------------------------------------------------------------------
void CJoltMidi::RestoreDownloadedEffects(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet;
	DNHANDLE DummyID;

#ifdef _DEBUG
	DebugOut("CJoltMidi::RestoreDownloadedEffects()\n");
#endif
	// Walk the list and restore the MIDI Effect objects
	for (int i=0; i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i])
		{
#ifdef _DEBUG
			wsprintf(g_cMsg,"Restoring Effect ID:%d\n", i);
			DebugOut(g_cMsg);
#endif
			// Generate Sys_Ex packet then prepare for output	
			(m_pJoltEffectList[i])->GenerateSysExPacket();
			int nSizeBuf = (m_pJoltEffectList[i])->MidiBufferSizeOf();
			int nRetries = MAX_RETRY_COUNT;
			while (nRetries > 0)
			{
				hRet = (m_pJoltEffectList[i])->SendPacket(&DummyID, nSizeBuf);
				if (SUCCESS == hRet) break;
				BumpRetryCounter();
				nRetries--;
			}
			assert(SUCCESS == hRet);
		}
	}
// --- END OF CRITICAL SECTION
//
}


// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::OpenOutput
// Purpose:		Opens Midi Output
// Parameters:	int nDeviceID - MIDI device ID 0-based.
//
// Returns:		success or Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::OpenOutput(int nDeviceID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

// ***** Shared Memory Access *****
	LockSharedMemory();	
	// Return if already opened by another task
	if (m_pSharedMemory->m_hMidiOut)
	{
		m_MidiOutInfo = m_pSharedMemory->m_MidiOutInfo;
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		return (SUCCESS);
	}

	MMRESULT wRtn;
	// Get MIDI input device caps
	assert(nDeviceID <= (int) midiOutGetNumDevs());
	wRtn = midiOutGetDevCaps(nDeviceID, (LPMIDIOUTCAPS) &m_MidiOutCaps,
                               sizeof(MIDIOUTCAPS));
	if(MMSYSERR_NOERROR != wRtn)
	{
#ifdef _DEBUG
		midiOutGetErrorText(wRtn, (LPSTR)g_cMsg, sizeof(g_cMsg));
    	DebugOut(g_cMsg);
		DebugOut(":midiOutGetDevCaps\n");
#endif
		return (SFERR_DRIVER_ERROR);
	}

	// Now open, with Callback handler
	HANDLE hMidiOut = NULL;
	wRtn = midiOutOpen((LPHMIDIOUT)&hMidiOut,
                      nDeviceID,
//                      (DWORD) m_hMidiOutputEvent,
                      (DWORD) NULL,
                      (DWORD) this,			// the CJoltMidi object
                      CALLBACK_EVENT);

	if(MMSYSERR_NOERROR != wRtn)
	{
#ifdef _DEBUG
		midiOutGetErrorText(wRtn, (LPSTR)g_cMsg, sizeof(g_cMsg));
		DebugOut(g_cMsg);
		wsprintf(g_cMsg, "midiOutOpen(%u)\n", nDeviceID);
		DebugOut(g_cMsg);
#endif
		return (SFERR_DRIVER_ERROR);
	}
	m_MidiOutInfo.hMidiOut = HMIDIOUT(hMidiOut);
	m_MidiOutDeviceID = nDeviceID;
	m_MidiOutOpened = TRUE;
	m_pSharedMemory->m_MidiOutInfo = m_MidiOutInfo;

	// Copy Midi Output handle to SharedMemory
	m_pSharedMemory->m_hMidiOut = hMidiOut;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****

// --- END OF CRITICAL SECTION
//
	return (SUCCESS);
}


// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::AllocCallbackInstanceData
// Purpose:		Allocates a CALLBACKINSTANCEDATA structure.  This structure is
//				used to pass information to the low-level callback function,
//				each time it receives a message. Because this structure is
//				accessed by the low-level callback function, it must be
//				allocated using GlobalAlloc() with the  GMEM_SHARE and
//				GMEM_MOVEABLE flags and page-locked with GlobalPageLock().
//
// Parameters:	none
//
// Returns:		A pointer to the allocated CALLBACKINSTANCE data structure.
//				else NULL if Fail
// Algorithm:
// ----------------------------------------------------------------------------
LPCALLBACKINSTANCEDATA CJoltMidi::AllocCallbackInstanceData(void)
{
    HANDLE hMem;
    LPCALLBACKINSTANCEDATA lpBuf;

    // Allocate and lock global memory.
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CALLBACKINSTANCEDATA));
    if(hMem == NULL) return NULL;

    lpBuf = (LPCALLBACKINSTANCEDATA)GlobalLock(hMem);
    if(lpBuf == NULL)
    {
        GlobalFree(hMem);
        return NULL;
    }

	// Save the handle.
    lpBuf->hSelf = hMem;
    return lpBuf;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::FreeCallbackInstanceData
// Purpose:		Frees the memory for the CALLBACKINSTANCEDATA structure
// Parameters:	none
//
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CJoltMidi::FreeCallbackInstanceData(void)
{
LPCALLBACKINSTANCEDATA lpBuf = m_lpCallbackInstanceData;
    HANDLE hMem;

// Save the handle until we're through here.
    hMem = lpBuf->hSelf;

// Free the structure.
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetAckNackData
// Purpose:		Waits for a Response ACK
//
// Parameters:	int nTImeWait		- Time to wait in 1 ms increment, 0=no wait
//				PACKNACK pAckNack	- Pointer to ACKNACK structure
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetAckNackData(
	IN int nTimeWait,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	assert(pAckNack);
// Use IOCTL from VxD to get AckNack data
// Wait for Event to be set
	if (nTimeWait && m_hMidiOutputEvent)
	{
		DWORD dwRet = WaitForSingleObject(m_hMidiOutputEvent, nTimeWait);
		//		:
#ifdef _DEBUG
		wsprintf(g_cMsg,"WaitForSingleObject %lx returned %lx, nTimeWait=%ld\n", m_hMidiOutputEvent, dwRet, nTimeWait);
		DebugOut(g_cMsg);
#endif
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);
	}

	HRESULT hRet = g_pDriverCommunicator->GetAckNack(*pAckNack, regindex);

// --- END OF CRITICAL SECTION
//
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetEffectStatus
// Purpose:		Checks status of Effect
//
// Parameters:	int DnloadID		- Effect ID
//				PBYTE pStatusCode	- Ptr to a byte for status code
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetEffectStatus(
	IN DWORD DnloadID ,
	IN OUT PBYTE pStatusCode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	assert(pStatusCode);
	HRESULT hRet = CMD_GetEffectStatus((DNHANDLE) DnloadID, pStatusCode);

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::InitDigitalOverDrive
// Purpose:		Initialize the VxD interface
//
// Parameters:	none
//
// Returns:		SUCCESS or Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT	CJoltMidi::InitDigitalOverDrive(DWORD dwDeviceID)
{
	if (g_pDriverCommunicator != NULL)
	{	// Attempt to reinit
		ASSUME_NOT_REACHED();
		return S_OK;
	}

//
// --- THIS IS A CRITICAL SECTION
//
	HRESULT hRet = SUCCESS;
	DWORD driverMajor = 0xFFFFFFFF;
	DWORD driverMinor = 0xFFFFFFFF;

	g_CriticalSection.Enter();
	// This fork works on NT5 only (VxD stuff removed)
	assert(g_ForceFeedbackDevice.IsOSNT5() == TRUE);
	{
		g_pDriverCommunicator = new HIDFeatureCommunicator;
		if (g_pDriverCommunicator == NULL)
		{
			g_CriticalSection.Leave();
			return DIERR_OUTOFMEMORY;
		}
		if (((HIDFeatureCommunicator*)g_pDriverCommunicator)->Initialize(dwDeviceID) == FALSE)
		{	// Could not load the driver
			hRet = SFERR_DRIVER_ERROR;
		}
	}

	if (FAILED(hRet))
	{
		return hRet;
	}

	// Loaded driver, get the version
	g_pDriverCommunicator->GetDriverVersion(driverMajor, driverMinor);

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

	g_ForceFeedbackDevice.SetDriverVersion(driverMajor, driverMinor);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltStatus
// Purpose:		Returns JOLT Device Status using SWForce SWDEVICESTATE struct
//
// Parameters:	LPDEVICESTATE pDeviceState
//
// Returns:		none
//				
// Algorithm:	copies SWDEVICESTATUS to caller
// Internal Representation:
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
									//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
									// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// TRUE=SERIAL, FALSE=MIDI
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltStatus(PSWDEVICESTATE pDeviceState)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	
	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
	
	HRESULT hRet = g_pDriverCommunicator->GetStatus(statusPacket);
	if (hRet == SUCCESS) {
		// Store/update Jolt's status in main object
		SetJoltStatus(&statusPacket);
		memcpy(pDeviceState, &m_DeviceState, sizeof(SWDEVICESTATE));
	}

//
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltStatus
// Purpose:		Returns JOLT Device Status
//
// Parameters:	LPDEVICESTATE pDeviceState using DXFF DEVICESTATE
//
// Returns:		none
//				
// Algorithm:	copies SWDEVICESTATUS to caller converted to DEVICESTATE
// Internal Representation:
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//    0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								//    Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// DirectInputEffect Representation
//typedef struct DEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
//where:
//// dwState values:
//DS_FORCE_SHUTDOWN   0x00000001
//DS_FORCE_ON         0x00000002
//DS_FORCE_OFF        0x00000003
//DS_CONTINUE         0x00000004
//DS_PAUSE            0x00000005
//DS_STOP_ALL         0x00000006
//
// dwSwitches values:
//DSW_ACTUATORSON         0x00000001
//DSW_ACTUATORSOFF        0x00000002
//DSW_POWERON             0x00000004
//DSW_POWEROFF            0x00000008
//DSW_SAFETYSWITCHON      0x00000010
//DSW_SAFETYSWITCHOFF     0x00000020
//DSW_USERFFSWITCHON      0x00000040
//DSW_USERFFSWTTCHOFF     0x00000080
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltStatus(LPDIDEVICESTATE pDeviceState)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};

	HRESULT hRet = g_pDriverCommunicator->GetStatus(StatusPacket);
	if (hRet != SUCCESS)  {
		return (hRet);
	}
	
	// Store/update Jolts status
	SetJoltStatus(&StatusPacket);
#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: DXFF:dwDeviceStatus=%.8lx\n",&szDeviceName, StatusPacket.dwDeviceStatus);	
	DebugOut(g_cMsg);
#endif

	pDeviceState->dwState = 0;
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//		 So, also Map the redundant info that DI needs if necessary
	switch(m_DeviceState.m_ForceState)
	{
		case SWDEV_SHUTDOWN:
			pDeviceState->dwState = DIGFFS_ACTUATORSON;
			break;
		
		case SWDEV_FORCE_ON:
			pDeviceState->dwState = DIGFFS_ACTUATORSON;
			break;

		case SWDEV_FORCE_OFF:
			pDeviceState->dwState = DIGFFS_ACTUATORSOFF;
			break;
		
		default:
			break;
	}

	// see if the stick is empty
	// remember that ID's start at 2
	BOOL bEmpty = TRUE;
	for (int i=2; i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i] != NULL)
			bEmpty = FALSE;
	}
	
	if(bEmpty)
		pDeviceState->dwState |= DIGFFS_EMPTY;


	switch(m_DeviceState.m_EffectState)
	{
		case SWDEV_PAUSE:
			pDeviceState->dwState |= DIGFFS_PAUSED;
			break;

		case SWDEV_CONTINUE:
			break;

		case SWDEV_STOP_ALL:
			pDeviceState->dwState |= DIGFFS_STOPPED;
			break;

		default:
			break;
	}

	if(m_DeviceState.m_HOTS)
		pDeviceState->dwState |= DIGFFS_SAFETYSWITCHON;
	else
		pDeviceState->dwState |= DIGFFS_SAFETYSWITCHOFF;

	if (m_DeviceState.m_ACBrickFault)
		pDeviceState->dwState |= DIGFFS_POWEROFF;
	else
		pDeviceState->dwState |= DIGFFS_POWERON;

	pDeviceState->dwLoad = 0;	//m_DeviceState.m_BandWidth * SCALE_GAIN;

// --- END OF CRITICAL SECTION
//
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::SetJoltStatus
// Purpose:		Sets JOLT Device Status
//
// Parameters:	PJOYCHANNELSTATUS pJoyChannelStatus
//
// Returns:		none
//				
// Algorithm:	Sets SWDEVICESTATE from caller

//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_FORCE_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0(FALSE) = Hands Off, 1 (TRUE) = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0(FALSE) = AC Brick OK, 1(TRUE) = AC Fault
//	ULONG	m_ResetDetect;		// 1(TRUE) = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1(TRUE) = Shutdown detected
//	ULONG	m_CommMode;			// 0(FALSE) = Midi, 1(TRUE) = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
// ----------------------------------------------------------------------------
void CJoltMidi::SetJoltStatus(JOYCHANNELSTATUS* pJoyChannelStatus)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	if (pJoyChannelStatus->dwDeviceStatus & HOTS_MASK)
		m_DeviceState.m_HOTS = TRUE;
	else
		m_DeviceState.m_HOTS = FALSE;

	if (pJoyChannelStatus->dwDeviceStatus & BANDWIDTH_MASK)
		m_DeviceState.m_BandWidth = MINIMUM_BANDWIDTH;
	else
		m_DeviceState.m_BandWidth = MAXIMUM_BANDWIDTH;
	
	if (pJoyChannelStatus->dwDeviceStatus & AC_FAULT_MASK)
		m_DeviceState.m_ACBrickFault = TRUE;
	else
		m_DeviceState.m_ACBrickFault = FALSE;


	if (pJoyChannelStatus->dwDeviceStatus & COMM_MODE_MASK)
		m_DeviceState.m_CommMode = TRUE;	// Serial RS232
	else
		m_DeviceState.m_CommMode = FALSE;	// Midi port

	if (pJoyChannelStatus->dwDeviceStatus & RESET_MASK)
		m_DeviceState.m_ResetDetect = TRUE;	// Power ON Reset entered
	else
		m_DeviceState.m_ResetDetect = FALSE;
//REVIEW: If we detected a Reset, shouldn't we go through re-init of object?

	if (pJoyChannelStatus->dwDeviceStatus & SHUTDOWN_MASK)
		m_DeviceState.m_ShutdownDetect = TRUE;	// Soft Reset received
	else
		m_DeviceState.m_ShutdownDetect = FALSE;

// --- END OF CRITICAL SECTION
//
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::UpdateDeviceMode
// Purpose:		Sets JOLT Device Mode
//
// Parameters:	ULONG ulMode
//
// Returns:		none
//				
// Algorithm:
// This is the SideWinder State structure
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
void CJoltMidi::UpdateDeviceMode(ULONG ulMode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	switch (ulMode)
	{
		case SWDEV_FORCE_ON:			// REVIEW
		case SWDEV_FORCE_OFF:
			m_DeviceState.m_ForceState = ulMode;
			break;

		case SWDEV_SHUTDOWN:
			m_DeviceState.m_ForceState = ulMode;
			m_DeviceState.m_EffectState = 0;
			break;

		case SWDEV_STOP_ALL:
		case SWDEV_CONTINUE:
		case SWDEV_PAUSE:
			m_DeviceState.m_EffectState = ulMode;
			break;

		default:
			break;
	}
// --- END OF CRITICAL SECTION
//
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltID
// Purpose:		Returns JOLT ProductID
//
// Parameters:	LOCAL_PRODUCT_ID pProductID	- Pointer to a LOCAL_PRODUCT_ID structure
//
// Returns:		none
//				
// Algorithm:	
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltID(LOCAL_PRODUCT_ID* pProductID)
{
	HRESULT hRet;
	assert(pProductID->cBytes = sizeof LOCAL_PRODUCT_ID);
	if (pProductID->cBytes != sizeof LOCAL_PRODUCT_ID) return (SFERR_INVALID_STRUCT_SIZE);

//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		if (SUCCESS == (hRet = g_pDriverCommunicator->GetID(*pProductID))) break;
	}
	if (SUCCESS == hRet)
	{
		memcpy(&m_ProductID, pProductID, sizeof LOCAL_PRODUCT_ID);
	}
	else
		DebugOut("GetJoltID: Warning! GetIDPacket - Fail\n");

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::LogError
// Purpose:		Logs Error codes
//
// Parameters:	HRESULT SystemError		- System Error code
//				HRESULT DriverError		- Driver Error code
//
// Returns:		SWFORCE Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
typedef struct _DRIVERERROR {
	ULONG	ulDriverCode;
	LONG	lSystemCode;
} DRIVERERROR, *PDRIVERERROR;

HRESULT	CJoltMidi::LogError(
	IN HRESULT SystemError,
	IN HRESULT DriverError)
{
// REVIEW: map MM error codes to our SWForce codes

	DRIVERERROR DriverErrorCodes[] = {
		{DEV_ERR_INVALID_ID        , SWDEV_ERR_INVALID_ID},
		{DEV_ERR_INVALID_PARAM     , SWDEV_ERR_INVALID_PARAM},
		{DEV_ERR_CHECKSUM          , SWDEV_ERR_CHECKSUM},
		{DEV_ERR_TYPE_FULL         , SWDEV_ERR_TYPE_FULL},
		{DEV_ERR_UNKNOWN_CMD       , SWDEV_ERR_UNKNOWN_CMD},
		{DEV_ERR_PLAYLIST_FULL     , SWDEV_ERR_PLAYLIST_FULL},
		{DEV_ERR_PROCESS_LIST_FULL , SWDEV_ERR_PROCESSLIST_FULL} };

	int nDriverErrorCodes = sizeof(DriverErrorCodes)/(sizeof(DRIVERERROR));
	for (int i=0; i<nDriverErrorCodes; i++)
	{
		if (DriverError == (LONG) DriverErrorCodes[i].ulDriverCode)
		{
			SystemError = DriverErrorCodes[i].lSystemCode;
			break;
		}
	}
	// Store in Jolt object
	m_Error.HCode = SystemError;
	m_Error.ulDriverCode = DriverError;

#ifdef _DEBUG
	wsprintf(g_cMsg,"LogError: SystemError=%.8lx, DriverError=%.8lx\n",
			 SystemError, DriverError);
	DebugOut(g_cMsg);
#endif
	return SystemError;
}

//
// ----------------------------------------------------------------------------
// Function: 	SetupROM_Fx
// Purpose:		Sets up parameters for ROM Effects
// Parameters:  PEFFECT pEffect
//				
//
// Returns:		pEffect is updated with new ROM parameters
//				OutputRate
//				Gain
//				Duration
//	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::SetupROM_Fx(
	IN OUT PEFFECT pEffect)
{
	assert(pEffect);
	if (NULL == pEffect) return (SFERR_INVALID_PARAM);
							
	ULONG ulSubType = pEffect->m_SubType;
	BOOL bFound = FALSE;
	for (int i=0; i< MAX_ROM_EFFECTS; i++)
	{
		if (ulSubType == m_pRomFxTable[i].m_ROM_Id)
		{
			bFound = TRUE;
			break;
		}
	}
	if (!bFound) return (SFERR_INVALID_OBJECT);
	// Found, so fill in the default parameters, use Default if Gain=1, Duration=-1, OutputRate=-1
	BOOL bDefaultDuration = (ULONG)-1 == pEffect->m_Duration;
	if (1 == pEffect->m_Gain) pEffect->m_Gain = m_pRomFxTable[i].m_Gain;
	if (bDefaultDuration) pEffect->m_Duration = m_pRomFxTable[i].m_Duration;
	if ((ULONG)-1 == pEffect->m_ForceOutputRate)
	{
		pEffect->m_ForceOutputRate = m_pRomFxTable[i].m_ForceOutputRate;
	}
	else if(bDefaultDuration && pEffect->m_ForceOutputRate != 0)
	{
		// scale the duration to correspond to the output rate
		pEffect->m_Duration = pEffect->m_Duration*m_pRomFxTable[i].m_ForceOutputRate/pEffect->m_ForceOutputRate;
	}
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	DetectMidiDevice
// Purpose:    	Determines Midi Output Device ID
// Parameters:
//				DWORD dwDeviceID		- joystick ID
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//				else FALSE
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::DetectMidiDevice(
	IN DWORD dwDeviceID,
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet;
	BOOL bMidiOutFound = FALSE;
	int nMidiOutDevices;

	// Valid Serial and MIDI ports table
	ULONG MIDI_Ports[] = {0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
						0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	ULONG Serial_Ports[] = { 1, 2, 3, 4 };	// Entry0 is default
	int nMIDI_Ports = sizeof(MIDI_Ports)/sizeof(ULONG);
	int nSerial_Ports = sizeof(Serial_Ports)/sizeof(ULONG);

	// Set defaults
	*pCOMMInterface = COMM_WINMM;
	*pCOMMPort      = NULL;
	*pDeviceOutID 	= 0;

	SWDEVICESTATE SWDeviceState = {sizeof(SWDEVICESTATE)};
	
	// Turn on tristated Jolt MIDI lines by call GetIDPacket()
	LOCAL_PRODUCT_ID ProductID = {sizeof LOCAL_PRODUCT_ID };
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);	
	if (SUCCESS != GetJoltID(&ProductID))
	{
		DebugOut("DetectMidiDevice: Warning! GetIDPacket - Fail\n");
		return (FALSE);
	}

#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: ProductID=%.8lx, FWVersion=%d.%.2ld\n",
		&szDeviceName,	
		m_ProductID.dwProductID,
		m_ProductID.dwFWMajVersion,
		m_ProductID.dwFWMinVersion);
	DebugOut(g_cMsg);
#endif
	// Set the device firmware version from GetID
	g_ForceFeedbackDevice.SetFirmwareVersion(dwDeviceID, m_ProductID.dwFWMajVersion, m_ProductID.dwFWMinVersion);

	// Get Device status prior to starting detection
	BOOL statusPacketFailed = (GetJoltStatus(&SWDeviceState) != SUCCESS);
	if (statusPacketFailed)
	{
		DebugOut("DetectMidiDevice: Warning! StatusPacket - Fail\n");
	}
	if (statusPacketFailed == FALSE) {
#ifdef _DEBUG
		wsprintf(g_cMsg, "RESETDetect=%.8lx, SHUTDOWNDetect=%.8lx, COMMMode=%.8lx\n",
			SWDeviceState.m_ResetDetect,
			SWDeviceState.m_ShutdownDetect,
			SWDeviceState.m_CommMode);
		DebugOut(g_cMsg);
#endif
		// Make sure HW Reset Detect bit is cleared after GetID
		if (SWDeviceState.m_ResetDetect) {
    		DebugOut("DetectMidiDevice: Error! Jolt ResetDetect bit not cleared after GetID\n");
			return (FALSE);
		}
	}

	// See if Serial Dongle connected, otherwise must be MIDI device
    DebugOut("sw_effct:Trying Auto HW Detection: MIDI Serial Port Device...\n");

	// Get Registry values, If high bit of COMMInterface is set, then force override
	// otherwise, do automatic scanning as follows:
	// 1.  Backdoor mode
	// 2.  WinMM mode
	//
	// joyGetForceFeedbackCOMMInterface's 1st param changed to joystick ID
	if (SUCCESS != joyGetForceFeedbackCOMMInterface(dwDeviceID, pCOMMInterface, pCOMMPort)) {
		DebugOut("DetectMidiDevice: Registry key(s) missing! Bailing Out...\n");
		return (FALSE);
	}
#ifdef _DEBUG
	wsprintf(g_cMsg, "DetectMidiDevice: Registry.COMMInterface=%lx, Registry.COMMPort=%lx\n",
			*pCOMMInterface, *pCOMMPort);
	DebugOut(g_cMsg);
#endif																		

	ULONG regInterface = *pCOMMInterface;

	// Was a serial dongle detected, or did we fail to get status
	if (SWDeviceState.m_CommMode || statusPacketFailed) {	// Use serial (regardless what registry says!)
		DebugOut("DetectMidiDevice: Serial Port interface detected.\n");


		// Set to backdoor serial method by default
		*pCOMMInterface = COMM_SERIAL_BACKDOOR;
		m_COMMInterface = COMM_SERIAL_BACKDOOR;

		// Use front-door (serial file method) only, if NT5
		// since there is no backdoor on NT5 registry is irrelevent
		if (g_ForceFeedbackDevice.IsOSNT5()) {
			*pCOMMInterface = COMM_SERIAL_FILE;
			m_COMMInterface = COMM_SERIAL_FILE;
		} else if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() != 16)) {
			// Firmware is not 1.16 (which can't use the frontdoor serial with quick ack/nack)
			if (!(regInterface & MASK_SERIAL_BACKDOOR)) {	// Is back door forced by registry
				*pCOMMInterface = COMM_SERIAL_FILE;	// Use Serial File method
				m_COMMInterface = COMM_SERIAL_FILE;
			}
		}

		// See if already detected and ready to use
		// ***** Shared Memory Access *****
		LockSharedMemory();
		HANDLE hMidiOut = m_pSharedMemory->m_hMidiOut;
		UnlockSharedMemory();
		// ***** End of Shared Memory Access *****

		// Return if already opened by another task
		if (NULL != hMidiOut) {
			bMidiOutFound = TRUE;
		} else {		// Use the serial transmitter to find the proper port (even if backdoor selected)
			if (g_pDataTransmitter != NULL) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			g_pDataTransmitter = new SerialDataTransmitter();

			if (g_pDataTransmitter->Initialize()) {
				LockSharedMemory();
				m_pSharedMemory->m_hMidiOut = g_pDataTransmitter->GetCOMMHandleHack();
				UnlockSharedMemory();
				bMidiOutFound = TRUE;
			}

			// If Serial Backdoor let the driver know which port, kill DataTransmitter (without closing port)
			if (m_COMMInterface == COMM_SERIAL_BACKDOOR) {
				hRet = g_pDriverCommunicator->SetBackdoorPort(g_pDataTransmitter->GetSerialPortHack());
				if (hRet != SUCCESS) { // Low level driver fails, use normal serial routines not backdoor
					DebugOut("\nDetectMidiDevice: Warning! Could not set serial I/O port, cannot use backdoor serial\n");
					*pCOMMInterface = COMM_SERIAL_FILE;
					m_COMMInterface = COMM_SERIAL_FILE;
				} else {
					g_pDataTransmitter->StopAutoClose();
					delete g_pDataTransmitter;
					g_pDataTransmitter = NULL;
				}
			}
		}

		if (bMidiOutFound)
		{
			regInterface = (regInterface & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | m_COMMInterface;
			// joySetForceFeedbackCOMMInterface's 1st param changed to joystick ID
			joySetForceFeedbackCOMMInterface(dwDeviceID, regInterface, *pCOMMPort);
		}

		if ((statusPacketFailed == FALSE) || bMidiOutFound)
		{
			return (bMidiOutFound);
		}
	}	// End of Serial Port Auto HW selection

	// No Serial HW dongle detected, check if any Midi device for WinMM and Backdoor
	DebugOut("sw_effct:Scanning MIDI Output Devices\n");
	nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) {
		DebugOut("DetectMidiDevice: No MIDI devices present\n");
		return (FALSE);
	}

#if 0
	// Try the midi pin solution
	g_pDataTransmitter = new PinTransmitter();
	if (g_pDataTransmitter->Initialize()) {
		// Use backdoor flag for now
		m_COMMInterface = COMM_MIDI_BACKDOOR;
		*pCOMMInterface = COMM_MIDI_BACKDOOR;
		return TRUE;
	}
	// Pin failed delete transmitter continue looking
	delete g_pDataTransmitter;
	g_pDataTransmitter = NULL;
#endif


	ULONG ulPort = *pCOMMPort;
	if ( !(*pCOMMInterface & MASK_OVERRIDE_MIDI_PATH) ) {	// Use Automatic detection
		DebugOut("DetectMidiDevice: Auto Detection. Trying Backdoor\n");
		// Back Door
		bMidiOutFound = FindJoltBackdoor(pDeviceOutID, pCOMMInterface, pCOMMPort);
		if (!bMidiOutFound) {	// Try Front Door
			DebugOut("DetectMidiDevice: trying WINMM...\n");
			bMidiOutFound = FindJoltWinMM(pDeviceOutID, pCOMMInterface, pCOMMPort);
		}
		if (bMidiOutFound) {
			regInterface = (regInterface & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | m_COMMInterface;
			joySetForceFeedbackCOMMInterface(*pDeviceOutID, regInterface, *pCOMMPort);
		}
		return (bMidiOutFound);
	}

	// Over-ride since high bit is set
	*pCOMMInterface &= ~(MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR);	// Mask out high bit (and second bit)
	switch (*pCOMMInterface)
	{
		case COMM_WINMM:
			bMidiOutFound = FindJoltWinMM(pDeviceOutID, pCOMMInterface, pCOMMPort);
			if (!bMidiOutFound) {
				DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values!\n");
			}
			return (bMidiOutFound);
			
		case COMM_MIDI_BACKDOOR:
			int i;
			for (i=0;i<nMIDI_Ports;i++)
			{
				if (ulPort == MIDI_Ports[i])
				{
					bMidiOutFound = TRUE;
					break;
				}
			}
			break;

		case COMM_SERIAL_BACKDOOR:		// mlc - This should never work if no dongle detected
			for (i=0;i<nSerial_Ports;i++)
			{
				if (ulPort == Serial_Ports[i])
				{
					bMidiOutFound = TRUE;
					break;
				}
			}			
			break;					

		default:
			bMidiOutFound	= FALSE;
			break;
	}

	if (!bMidiOutFound)
	{
		DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values\n");
		return (bMidiOutFound);
	}

	// We have the forced Port #, Let's see if Jolt is out there
#ifdef _DEBUG
	wsprintf(g_cMsg,"DetectMidiDevice: (Over-ride) MIDI%.8lx Query - ", ulPort);
	DebugOut(g_cMsg);
#endif
	bMidiOutFound = FALSE;
	hRet = g_pDriverCommunicator->SetBackdoorPort(ulPort);

	if (SUCCESS != hRet)
	{
		DebugOut("\nDetectMidiDevice: Warning! Could not Set Midi/Serial I/O Port\n");
	}
	else
	{
		if (QueryForJolt())
		{
			DebugOut(" Success!\n");
			bMidiOutFound = TRUE;
		}
		else
			DebugOut(" No Answer\n");
	}		

// --- END OF CRITICAL SECTION
//
	return (bMidiOutFound);
}



// *** ---------------------------------------------------------------------***
// Function:   	FindJoltWinMM
// Purpose:    	Searches for Jolt using WinMM
// Parameters: 	none
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::FindJoltWinMM(
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
	HRESULT hRet;
	WORD wTechnology;	// looking for MOD_MIDIPORT
	WORD wChannelMask;	// ==0xFFFF if all 16 channels
	BOOL bMidiOutFound = FALSE;
	
	// Device Capabilities
    MIDIOUTCAPS midiOutCaps;

    int nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) return (FALSE);

	m_COMMInterface = COMM_WINMM;	
	for (int nIndex=0;nIndex<(nMidiOutDevices);nIndex++)
	{
        MMRESULT ret = midiOutGetDevCaps(nIndex, &midiOutCaps, sizeof(midiOutCaps));
		if (ret != MMSYSERR_NOERROR) break;
		wTechnology = midiOutCaps.wTechnology;
		wChannelMask= midiOutCaps.wChannelMask;
#ifdef _DEBUG
		g_CriticalSection.Enter();
        wsprintf(g_cMsg,"FindJoltWinMM: Technology=%x," \
         		"ChannelMask=%x, Mid=%d, Pid=%d\r\n", midiOutCaps.szPname,
         		wTechnology, wChannelMask, midiOutCaps.wMid,
         		midiOutCaps.wPid);
        DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		// Check if this is a MOD_MIDIPORT device
		//REVIEW: Need to check for multiple MOD_MIDIPORT devices
		if (wTechnology == MOD_MIDIPORT)
		{
			*pDeviceOutID = (UINT) nIndex;
#ifdef _DEBUG
			DebugOut("DetectMidiDevice: Opening WinMM Midi Output\n");
#endif
			hRet = OpenOutput(m_MidiOutInfo.uDeviceID);
			if (SUCCESS != hRet)
			{	
				DebugOut("DetectMidiDevice: Error! Could not Open WinMM Midi Output\n");
				return (FALSE);
			}
			else
			{
				DebugOut("Open Midi Output - Success.\nQuery for Jolt Device - ");
				if (QueryForJolt())
				{
					DebugOut(" Success!\n");
					bMidiOutFound = TRUE;
				}
				else
				{
					DebugOut(" No Answer\n");
					bMidiOutFound = FALSE;
					break;
				}
				return (bMidiOutFound);
			}
		} // end of MOD_MIDIPORT
	}
	return (bMidiOutFound);
}


// *** ---------------------------------------------------------------------***
// Function:   	FindJoltBackdoor
// Purpose:    	Searches for Jolt using BackDoor
// Parameters: 	none
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::FindJoltBackdoor(
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
    int nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) return (FALSE);

	HRESULT hRet;
	// Valid Serial and MIDI ports table
	ULONG MIDI_Ports[] = {0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
						0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	int nMIDI_Ports = sizeof(MIDI_Ports)/sizeof(ULONG);
	BOOL bMidiOutFound = FALSE;
	
	m_COMMInterface = COMM_MIDI_BACKDOOR;
	*pCOMMInterface = COMM_MIDI_BACKDOOR;
	*pCOMMPort = 0;
	for (int i=0;i<nMIDI_Ports;i++)
	{
#ifdef _DEBUG
        wsprintf(g_cMsg,"FindJoltBackdoor: Midi Port:%lx - ", MIDI_Ports[i]);
        DebugOut(g_cMsg);
#endif
		// We have the Port #, Let's see if Jolt is out there
		hRet = g_pDriverCommunicator->SetBackdoorPort(MIDI_Ports[i]);
		if (SUCCESS == hRet)
		{
			if (QueryForJolt())
			{
				DebugOut(" Success!\n");
				bMidiOutFound = TRUE;
				*pCOMMPort = MIDI_Ports[i];
				break;
			}
			else
				DebugOut(" No Answer\n");
		}		
	}
	return (bMidiOutFound);
}


// *** ---------------------------------------------------------------------***
// Function:   	QueryForJolt
// Purpose:    	Sends Shutdown and Queries for Shutdown status bit
// Parameters: 	none
// Returns:    	BOOL TRUE if Jolt found, else FALSE
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::QueryForJolt(void)
{
	HRESULT hRet;

// Send Shutdown command then detect if Shutdown Detect bit is set
	SWDEVICESTATE SWDeviceState = {sizeof(SWDEVICESTATE)};
	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		// Send a ShutDown, then check for response
		MidiSendShortMsg((SYSTEM_CMD|DEFAULT_MIDI_CHANNEL), SWDEV_SHUTDOWN, 0);
		Sleep(DelayParamsPtrOf()->dwShutdownDelay);	// 10 ms		
		if (SUCCESS == (hRet=GetJoltStatus(&SWDeviceState))) break;
	}
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);		
	// Clear the Previous state and turn on tri-state buffers
	LOCAL_PRODUCT_ID ProductID = {sizeof LOCAL_PRODUCT_ID };
	hRet = GetJoltID(&ProductID);
	if (SUCCESS != hRet)
	{
#ifdef _DEBUG
    	DebugOut("QueryForJolt: Driver Error. Get Jolt Status/ID\n");
#endif
		return (FALSE);
	}
	if (SWDeviceState.m_ShutdownDetect)
		return (TRUE);
	else
		return (FALSE);
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendShortMsg
// Purpose:    	Send status, channel and data.
// Parameters:
//				BYTE cStatus	-  MIDI status byte for this message
//				BYTE cData1		-  MIDI data byte for this message
//				BYTE cData2		-  2nd MIDI data byte for this message (may be 0)
// Returns:    	HRESULT
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendShortMsg(
    IN BYTE cStatus,
    IN BYTE cData1,
    IN BYTE cData2)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

    DWORD dwMsg;
    HRESULT hRet = SUCCESS;
// For diagnostics, record the attempts at this message
	BumpShortMsgCounter();

    if ((m_COMMInterface == COMM_WINMM) && (NULL == m_MidiOutInfo.hMidiOut))
    {
		DebugOut("SW_EFFECT: No Midi Out Devs opened\r\n     ");
		ASSUME_NOT_REACHED();
    	return (SFERR_DRIVER_ERROR);
    }

	// pack the message and send it
    dwMsg = MAKEMIDISHORTMSG(cStatus, m_MidiChannel, cData1, cData2);
	if (COMM_WINMM == m_COMMInterface)
	{
		// Clear the Event Callback
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);

		// send the message only if valid Handle
		if (SUCCESS == ValidateMidiHandle())
		{
			hRet = midiOutShortMsg(m_MidiOutInfo.hMidiOut, dwMsg);
		}
		else
		{
			return (SFERR_DRIVER_ERROR);
		}
		if (SUCCESS != hRet) hRet = SFERR_DRIVER_ERROR;
	}
	else
	{
		hRet = g_pDriverCommunicator->SendBackdoorShortMidi(dwMsg);
	}
// --- END OF CRITICAL SECTION
//
    return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendLongMsg
// Purpose:    	Send system exclusive message or series of short messages.
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendLongMsg(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
    HRESULT hRet = SUCCESS;
// For diagnostics, record the attempts at this message
	BumpLongMsgCounter();

    if (m_MidiOutInfo.uDeviceType != MIDI_OUT)
    {
#ifdef _DEBUG
		MessageBox(NULL, "Must use a MIDI output device",
            "MidiSendLongMsg", MB_ICONSTOP);
#endif
		return (SFERR_DRIVER_ERROR);
    }

	if (COMM_WINMM == m_COMMInterface)
	{
		// Clear the Event Callback
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);

		// send the long message only if valid Handle
		if (SUCCESS == ValidateMidiHandle())
			hRet = midiOutLongMsg(m_MidiOutInfo.hMidiOut,
    	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
		else
		{
			return (SFERR_DRIVER_ERROR);
		}

		if (SUCCESS == hRet)
			m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_BUSY;
    	else
		{
			if (m_MidiOutInfo.MidiHdr.dwFlags != MHDR_DONE)
    		{
    	    	// abort the current message
    	    	hRet = midiOutReset(m_MidiOutInfo.hMidiOut);
    	    	
    	    	// set the device status because buffer(s) have been marked as
    	    	// done and returned to the application
    	    	if (SUCCESS == hRet)
    	    	    m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_ABANDONED;
    		}
    		else
    	    	// tried to abort but the operation was already complete
    	    	m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;
		}
		if (SUCCESS != hRet) hRet = (SFERR_DRIVER_ERROR);
    }
	else
	{
		hRet = g_pDriverCommunicator->SendBackdoorLongMidi(PBYTE(m_MidiOutInfo.MidiHdr.lpData));
	}
	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwLongMsgDelay);

// --- END OF CRITICAL SECTION
//
    return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	ValidateMidiHandle
// Purpose:    	Validates Midi handle and reopens if necessary
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::ValidateMidiHandle(void)
{
	HRESULT hRet = SUCCESS;
	UINT dwID;
	if (MMSYSERR_INVALHANDLE == midiOutGetID(m_MidiOutInfo.hMidiOut, &dwID))
	{
#ifdef _DEBUG
		DebugOut("CJoltMidi::MidiValidateHandle - Midi Handle invalid. Re-opening...\n");
#endif
		// Clear old global handle and Re-open Midi channel
		// ***** Shared Memory Access *****
		LockSharedMemory();
		m_pSharedMemory->m_hMidiOut = NULL;
		UnlockSharedMemory();
		// ***** End of Shared Memory Access *****			
		hRet = OpenOutput(m_MidiOutInfo.uDeviceID);
	}
	return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	MidiAssignBuffer
// Purpose:    	Assign lpData and dwBufferLength members and prepare the
//              MIDIHDR.  Also add the buffer if it is an input buffer.
//              If the third parameter is false, unprepare and reinitialize
//              the header.
// Parameters:
//			    LPSTR lpData    - address of buffer, NULL if cleaning up
//				DWORD dwBufferLength	- buffer size in bytes
//				BOOL fAssign	- TRUE = Assign, FALSE = cleanup
//
// Returns:    	SUCCESS or SFERR_DRIVER_ERROR
//				
// Note: assumes m_pMidiOutInfo structure is valid
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiAssignBuffer(
    LPSTR lpData,             // address of buffer, NULL if cleaning up
    DWORD dwBufferLength,     // size of buffer in bytes, 0L if cleaning up
    BOOL fAssign)             // TRUE = assign, FALSE = cleanup
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;
#ifdef _DEBUG
    DebugOut("MidiAssignBuffer:\n");
#endif
    HRESULT hRet = SUCCESS;
    if (m_MidiOutInfo.uDeviceType == MIDI_OUT)
    {
		if ((COMM_WINMM == m_COMMInterface) && !m_MidiOutInfo.hMidiOut)
        {
            if (!fAssign && m_MidiOutInfo.uDeviceStatus == MIDI_DEVICE_ABANDONED)
            {
                // clear the device status
                m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;

                // don't return an error for this case because if the user aborts
                // the transmission of a long message before it completes the
                // buffers will be marked as done and returned to the application,
                // just as when recording successfully completes.  So it is ok
                // for this function to be called (with fAssign = FALSE) when
                // hMidiIn = 0, as long as uDeviceStatus = MIDI_DEVICE_ABANDONED.
				return (SUCCESS);
            }
            else
            {
                // all other cases are an application error
#ifdef _DEBUG
                MessageBox(NULL, "Must open MIDI output device first",
                    "MidiAssignBuffer", MB_ICONSTOP);
#endif
                // because this failed call might result in an input or output
                // device being reset (if the application is written to do so),
                // an MM_MOM_DONE or MM_MIM_LONGDATA message could be sent to
                // the application.  This might result in an additional call to
                // this routine, so set the device status to prevent another
                // error message
                m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_ABANDONED;
                return (SFERR_DRIVER_ERROR);
            }
        }
    }
    else
    {
#ifdef _DEBUG
        DebugOut("\r\nMidiAssignBuffer: uDeviceType bad");
#endif
        return (SFERR_INVALID_PARAM);
    }

    if (fAssign)
    {
		// check for the buffer's address and size
        if (!lpData || !dwBufferLength)
        {
#ifdef _DEBUG
            MessageBox(NULL, "Must specify a buffer and size",
                "MidiAssignBuffer", MB_ICONSTOP);
#endif
	        return (SFERR_INVALID_PARAM);
        }
        // assign buffer to the MIDIHDR
        m_MidiOutInfo.MidiHdr.lpData = lpData;
        m_MidiOutInfo.MidiHdr.dwBufferLength = dwBufferLength;
        m_MidiOutInfo.MidiHdr.dwBytesRecorded = dwBufferLength;

 		if (COMM_WINMM == m_COMMInterface)
        {
        	// prepare the MIDIHDR
        	m_MidiOutInfo.MidiHdr.dwFlags = 0;
        	hRet = midiOutPrepareHeader(m_MidiOutInfo.hMidiOut,
        	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
		}
	}
    else
    {   // unprepare the MIDIHDR
 		if (COMM_WINMM == m_COMMInterface)
        {
			if ((m_MidiOutInfo.MidiHdr.dwFlags & MHDR_DONE) != MHDR_DONE)
			{
				//hRet = midiOutReset(m_MidiOutInfo.hMidiOut);
			}
			if (SUCCESS == hRet)
        	{
				hRet = midiOutUnprepareHeader(m_MidiOutInfo.hMidiOut,
        	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
        	}
		}
		else
			hRet = SUCCESS;

		if (SUCCESS == hRet)
		{
        	// reinitialize MIDIHDR to guard against casual re-use
        	m_MidiOutInfo.MidiHdr.lpData = NULL;
        	m_MidiOutInfo.MidiHdr.dwBufferLength = 0;
			m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;			
        	// clear the device status
        	m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;
		}
    }

    if (SUCCESS != hRet) hRet = SFERR_DRIVER_ERROR;
#ifdef _DEBUG
    wsprintf(g_cMsg, "Returning from MidiAssignBuffer: %lx\n", hRet);
#endif

// --- END OF CRITICAL SECTION
//
	return (hRet);
}


// ****************************************************************************
// *** --- Helper functions for CJoltMidi
//
// ****************************************************************************
//
#define REGSTR_VAL_FIRMWARE_PARAMS	"FirmwareParams"
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(FIRMWARE_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_FIRMWARE_PARAMS,
							  NULL, NULL,
							  (PBYTE)pFirmwareParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pFirmwareParams->dwScaleKx = DEF_SCALE_KX;
		pFirmwareParams->dwScaleKy = DEF_SCALE_KY;
		pFirmwareParams->dwScaleBx = DEF_SCALE_BX;
		pFirmwareParams->dwScaleBy = DEF_SCALE_BY;
		pFirmwareParams->dwScaleMx = DEF_SCALE_MX;
		pFirmwareParams->dwScaleMy = DEF_SCALE_MY;
		pFirmwareParams->dwScaleFx = DEF_SCALE_FX;
		pFirmwareParams->dwScaleFy = DEF_SCALE_FY;
		pFirmwareParams->dwScaleW  = DEF_SCALE_W;
	}
}

#define REGSTR_VAL_SYSTEM_PARAMS	"SystemParams"
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(SYSTEM_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_SYSTEM_PARAMS,
							  NULL, NULL,
							  (PBYTE)pSystemParams,
							  &dwcb);

		// scale them
		pSystemParams->RTCSpringParam.m_XKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_YKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_XAxisCenter /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YAxisCenter = -pSystemParams->RTCSpringParam.m_YAxisCenter/SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XDeadBand	/= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YDeadBand	/= SCALE_POSITION;



		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pSystemParams->RTCSpringParam.m_Bytes		= sizeof(RTCSPRING_PARAM);
		pSystemParams->RTCSpringParam.m_XKConstant	= DEFAULT_RTC_KX;
		pSystemParams->RTCSpringParam.m_YKConstant	= DEFAULT_RTC_KY;
		pSystemParams->RTCSpringParam.m_XAxisCenter = DEFAULT_RTC_X0;
		pSystemParams->RTCSpringParam.m_YAxisCenter = DEFAULT_RTC_Y0;
		pSystemParams->RTCSpringParam.m_XSaturation = DEFAULT_RTC_XSAT;
		pSystemParams->RTCSpringParam.m_YSaturation = DEFAULT_RTC_YSAT;
		pSystemParams->RTCSpringParam.m_XDeadBand	= DEFAULT_RTC_XDBAND;
		pSystemParams->RTCSpringParam.m_YDeadBand	= DEFAULT_RTC_YDBAND;
	}
}

#define REGSTR_VAL_DELAY_PARAMS	"TimingParams"
void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(DELAY_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_DELAY_PARAMS,
							  NULL, NULL,
							  (PBYTE)pDelayParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pDelayParams->dwBytes								= sizeof(DELAY_PARAMS);
		pDelayParams->dwDigitalOverdrivePrechargeCmdDelay	= DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY;
		pDelayParams->dwShutdownDelay						= DEFAULT_SHUTDOWN_DELAY;
		pDelayParams->dwHWResetDelay						= DEFAULT_HWRESET_DELAY;
		pDelayParams->dwPostSetDeviceStateDelay				= DEFAULT_POST_SET_DEVICE_STATE_DELAY;
		pDelayParams->dwGetEffectStatusDelay				= DEFAULT_GET_EFFECT_STATUS_DELAY;
		pDelayParams->dwGetDataPacketDelay					= DEFAULT_GET_DATA_PACKET_DELAY;
		pDelayParams->dwGetStatusPacketDelay				= DEFAULT_GET_STATUS_PACKET_DELAY;
		pDelayParams->dwGetIDPacketDelay					= DEFAULT_GET_ID_PACKET_DELAY;
		pDelayParams->dwGetStatusGateDataDelay				= DEFAULT_GET_STATUS_GATE_DATA_DELAY;
		pDelayParams->dwSetIndexDelay						= DEFAULT_SET_INDEX_DELAY;
		pDelayParams->dwModifyParamDelay					= DEFAULT_MODIFY_PARAM_DELAY;
		pDelayParams->dwForceOutDelay						= DEFAULT_FORCE_OUT_DELAY;
		pDelayParams->dwShortMsgDelay						= DEFAULT_SHORT_MSG_DELAY;
		pDelayParams->dwLongMsgDelay						= DEFAULT_LONG_MSG_DELAY;
		pDelayParams->dwDestroyEffectDelay					= DEFAULT_DESTROY_EFFECT_DELAY;
		pDelayParams->dwForceOutMod							= DEFAULT_FORCE_OUT_MOD;

		// write the defaults to the registry
		hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
		if(hKey)
		{
			// Modify Registry Values
			RegSetValueEx ( hKey, REGSTR_VAL_DELAY_PARAMS, 0, REG_BINARY, (const unsigned char *)pDelayParams, sizeof(DELAY_PARAMS) );

			// Close Key
			RegCloseKey(hKey);
		}

	}
	if(pDelayParams->dwForceOutMod == 0)
		pDelayParams->dwForceOutMod = 1;
}

#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"
void GetJoystickParams(UINT nJoystickID, PJOYSTICK_PARAMS pJoystickParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(JOYSTICK_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_JOYSTICK_PARAMS,
							  NULL, NULL,
							  (PBYTE)pJoystickParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pJoystickParams->dwXYConst		= DEF_XY_CONST;
		pJoystickParams->dwRotConst		= DEF_ROT_CONST;
		pJoystickParams->dwSldrConst	= DEF_SLDR_CONST;
		pJoystickParams->dwAJPos		= DEF_AJ_POS;
		pJoystickParams->dwAJRot		= DEF_AJ_ROT;
		pJoystickParams->dwAJSldr		= DEF_AJ_SLDR;
		pJoystickParams->dwSprScl		= DEF_SPR_SCL;
		pJoystickParams->dwBmpScl		= DEF_BMP_SCL;
		pJoystickParams->dwDmpScl		= DEF_DMP_SCL;
		pJoystickParams->dwInertScl		= DEF_INERT_SCL;
		pJoystickParams->dwVelOffScl	= DEF_VEL_OFFSET_SCL;
		pJoystickParams->dwAccOffScl	= DEF_ACC_OFFSET_SCL;
		pJoystickParams->dwYMotBoost	= DEF_Y_MOT_BOOST;
		pJoystickParams->dwXMotSat		= DEF_X_MOT_SATURATION;
		pJoystickParams->dwReserved		= 0;
		pJoystickParams->dwMasterGain	= 0;
	}
}

void UpdateJoystickParams(PJOYSTICK_PARAMS pJoystickParams)
{
	// modify the Joystick Params by modifying the SYSTEM_EFFECT_ID
	// note that some parameters must be divided by 2 before being sent
	// Jolt will multiply by 2 to restore to original
	CMD_ModifyParamByIndex(INDEX0, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwXYConst))/2);
	CMD_ModifyParamByIndex(INDEX1, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwRotConst))/2);
	CMD_ModifyParamByIndex(INDEX2, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwSldrConst));
	CMD_ModifyParamByIndex(INDEX3, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJPos));
	CMD_ModifyParamByIndex(INDEX4, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJRot));
	CMD_ModifyParamByIndex(INDEX5, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJSldr));
	CMD_ModifyParamByIndex(INDEX6, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwSprScl));
	CMD_ModifyParamByIndex(INDEX7, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwBmpScl));
	CMD_ModifyParamByIndex(INDEX8, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwDmpScl));
	CMD_ModifyParamByIndex(INDEX9, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwInertScl));
	CMD_ModifyParamByIndex(INDEX10, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwVelOffScl));
	CMD_ModifyParamByIndex(INDEX11, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAccOffScl));
	CMD_ModifyParamByIndex(INDEX12, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwYMotBoost))/2);
	CMD_ModifyParamByIndex(INDEX13, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwXMotSat));
}



// ****************************************************************************
// *** --- Member functions for base class CMidiEffect
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(IN ULONG ulButtonPlayMask)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	Effect.bDurationL	= 1;				// in 2ms increments
	Effect.bDurationH	= 0;				// in 2ms increments
	Effect.bAngleL		= 0;				// 0 to 359 degrees
	Effect.bAngleH		= 0;
	Effect.bGain		= (BYTE) 100;		// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL= DEFAULT_JOLT_FORCE_RATE;	// 1 to 500 Hz
	Effect.bForceOutRateH=0;
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default
}


// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_OpCode    		= DNLOAD_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:DNLOAD_DATA
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	SetDuration(pEffect->m_Duration);
	Effect.bDurationL	= (BYTE)  (m_Duration & 0x7f);					// in 2ms increments
	Effect.bDurationH	= (BYTE) ((m_Duration >> 7 ) & 0x7f);			// in 2ms increments
	Effect.bAngleL		= (BYTE)  (pEffect->m_DirectionAngle2D & 0x7f);	// 0 to 359 degrees
	Effect.bAngleH		= (BYTE) ((pEffect->m_DirectionAngle2D >> 7 ) & 0x7f);
	Effect.bGain		= (BYTE)  (pEffect->m_Gain & 0x7f);				// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE)  (pEffect->m_ButtonPlayMask & 0x7f);
	Effect.bButtonPlayH = (BYTE) ((pEffect->m_ButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL=(BYTE)  (pEffect->m_ForceOutputRate & 0x7f);	// 1 to 500 Hz
	Effect.bForceOutRateH=(BYTE) ((pEffect->m_ForceOutputRate >> 7 ) & 0x03);
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default

	// Set Envelope members
	if (pEnvelope)
	{
		m_Envelope.m_Type = pEnvelope->m_Type;
		m_Envelope.m_Attack = pEnvelope->m_Attack;
		m_Envelope.m_Sustain = pEnvelope->m_Sustain;
		m_Envelope.m_Decay = pEnvelope->m_Decay;
		m_Envelope.m_StartAmp = (ULONG) (pEnvelope->m_StartAmp);
		m_Envelope.m_SustainAmp = (ULONG) (pEnvelope->m_SustainAmp);
		m_Envelope.m_EndAmp = (ULONG) (pEnvelope->m_EndAmp);
	}

	// save the original effect params
	m_OriginalEffectParam = *pEffect;
}

// --- Destructor
CMidiEffect::~CMidiEffect()
{
	memset(this, 0, sizeof(CMidiEffect));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetDuration
// Purpose:		Sets the Duration member
// Parameters:	ULONG ulArg	- the duration
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetDuration(ULONG ulArg)
{
	if (ulArg != 0)
	{
		ulArg = (ULONG) ( (float) ulArg/TICKRATE);
		if (ulArg <= 0) ulArg = 1;
	}
	m_Duration = ulArg;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetTotalDuration
// Purpose:		Modifies the Effect.bDurationL/H parameter for Loop Counts
// Parameters:	none
//
// Returns:		Effect.bDurationL/H is filled with total duration
// Algorithm:
//	Notes: Percentage is 1 to 10000
//	Total Duration = ((Percentage of waveform)/10000) * Duration * Loop Count
//	Example: Loop count of 1, the Percentage of waveform =10000,
//			 Total Duration = (10000/10000) * 1 * Duration
//
// ----------------------------------------------------------------------------
void CMidiEffect::SetTotalDuration(void)
{
	ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);
	ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
	Effect.bDurationL = (BYTE) ulTotalDuration & 0x7f;
	Effect.bDurationH = (BYTE) (ulTotalDuration >> 7) & 0x7f;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeEnvelope
// Purpose:		Computes the Envelope for the Effect, Loopcount in consideration
// Parameters:	none
// Returns:		none
// Algorithm:
//For our standard PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline
// m_EndAmp = m_StartAmp;
// where: baseline = (Effect.m_MaxAmp + Effect.m_MinAmp)/2;
// ----------------------------------------------------------------------------
void CMidiEffect::ComputeEnvelope(void)
{
	ULONG ulTimeToSustain;
	ULONG ulTimeToDecay;

	//REVIEW: TIME vs PERCENTAGE option
	if (PERCENTAGE == m_Envelope.m_Type)
	{
		ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);		
		ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
		ulTimeToSustain = (ULONG) ((m_Envelope.m_Attack * ulTotalDuration) /100.);
		ulTimeToDecay   = (ULONG) ((m_Envelope.m_Attack + m_Envelope.m_Sustain)
								 * ulTotalDuration /100.);
	}
	else	// TIME option envelope
	{
		ulTimeToSustain = (ULONG) (m_Envelope.m_Attack);
		ulTimeToDecay   = (ULONG) (m_Envelope.m_Attack + m_Envelope.m_Sustain);
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

	}
		Envelope.bAttackLevel  = (BYTE) (m_Envelope.m_StartAmp & 0x7f);
		Envelope.bSustainLevel = (BYTE) (m_Envelope.m_SustainAmp & 0x7f);
		Envelope.bDecayLevel   = (BYTE) (m_Envelope.m_EndAmp & 0x7f);

		Envelope.bSustainL = (BYTE) (ulTimeToSustain & 0x7f);
		Envelope.bSustainH = (BYTE) ((ulTimeToSustain >> 7) & 0x7f);
		Envelope.bDecayL   = (BYTE) (ulTimeToDecay & 0x7f);
		Envelope.bDecayH   = (BYTE) ((ulTimeToDecay >> 7) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Returns the SubType for the Effect
// Parameters:	none
// Returns:		ULONG - DirectEffect style SubType
// Algorithm:
// ----------------------------------------------------------------------------
ULONG CMidiEffect::SubTypeOf(void)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (m_SubType == EffectTypes[i].bDeviceSubType)
			return EffectTypes[i].ulHostSubType;
	}
	return (NULL);		
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Sets the SubType for the Effect
// Parameters:	ULONG - DirectEffect style SubType
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetSubType(ULONG ulSubType)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (ulSubType == EffectTypes[i].ulHostSubType)
		{
			m_SubType = EffectTypes[i].bDeviceSubType;
			return;
		}
	}
	m_SubType = NULL;	
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeChecksum
// Purpose:		Computes current checksum in the m_pBuffer
// Parameters:	none
// Returns:		Midi packet block is checksummed
// Algorithm:
// ----------------------------------------------------------------------------
BYTE CMidiEffect::ComputeChecksum(PBYTE pBuffer, int nBufferSize)
{
	assert(pBuffer);
	int nStart = sizeof(SYS_EX_HDR);
	PBYTE pBytePacket = pBuffer;
	pBytePacket += nStart;
	BYTE nSum = 0;
	// Checksum only the bytes in the "Body" and s/b 7 bit checksum.
	for (int i=nStart;i < (nBufferSize-2);i++)
	{
		nSum += *pBytePacket;
		pBytePacket++;
	}
	return ((-nSum) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SendPacket
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::SendPacket(PDNHANDLE pDnloadID, int nPacketSize)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet = SUCCESS;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Prepare the buffer for SysEx output
	hRet = g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer,
			(DWORD) nPacketSize, TRUE);

	assert(SUCCESS == hRet);
	if (SUCCESS != hRet)
	{
		return (hRet);
	}

	ACKNACK AckNack = {sizeof(ACKNACK)};
	for(int i=0; i<MAX_RETRY_COUNT; i++)
	{
		g_pJoltMidi->BumpLongMsgCounter();
		// Send the message and Wait for the ACK + Download ID
		hRet = g_pJoltMidi->MidiSendLongMsg();
		assert(SUCCESS == hRet);
		if (SUCCESS != hRet)
		{
#ifdef _DEBUG
			OutputDebugString("SendPacket Error: MidiSendLongMsg()\n");
#endif
			// Release the Midi buffers	and Return
			g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer, 0, FALSE);
			return (hRet);
		}

		// Wait for ACK.  Note: WinMM has callback Event notification
		// while Backdoor and serial does not.
		if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
		{	
			hRet = g_pJoltMidi->GetAckNackData(10, &AckNack, REGBITS_DOWNLOADEFFECT);
		}
		else   // Serial or Backdoor
		{
			if ((COMM_SERIAL_FILE == g_pJoltMidi->COMMInterfaceOf()) || (COMM_SERIAL_BACKDOOR == g_pJoltMidi->COMMInterfaceOf()))			
			{
				hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_DOWNLOADEFFECT);
			}
			else	// Backdoor, hopefully to keep Jeff(Mr. Performance '97) happy
			{
				hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_DOWNLOADEFFECT);
			}
		}
		//	:

#ifdef _DEBUG
		if (SUCCESS!=hRet)
			OutputDebugString("Error getting ACKNACK data\n");
		if (ACK != AckNack.dwAckNack)
			g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode);
#endif
	
		// NOTE: Special check for Device-Full because in certain circumstances
		// (e.g. create multiple ROM effects after STOP_ALL command), retries of
		// creation will succeed even though device is full
		if (ACK == AckNack.dwAckNack || (NACK == AckNack.dwAckNack && AckNack.dwErrorCode == DEV_ERR_TYPE_FULL))
			break;
		// ******
	}

	// Release the Midi buffers
	g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer, 0, FALSE);
	if (SUCCEEDED(hRet) && (ACK == AckNack.dwAckNack))
	{
		// Store in Device ID List Array
		// First we need to generate a new Effect ID if necessary
		if (NEW_EFFECT_ID == m_bEffectID)
		{
			DNHANDLE DnloadID;
			if (g_pJoltMidi->NewEffectID(&DnloadID))	// Successful ID created
			{
				m_bEffectID = (BYTE) DnloadID;
				*pDnloadID = DnloadID;
				g_pJoltMidi->SetEffectByID((BYTE) *pDnloadID, this);
			}
		}
	}
	else	// Failure of some sort
	{
		if(NACK == AckNack.dwAckNack)
		{
			g_pJoltMidi->BumpNACKCounter();
			switch (AckNack.dwErrorCode)
			{
				case DEV_ERR_TYPE_FULL:
				case DEV_ERR_PROCESS_LIST_FULL:
				case DEV_ERR_PLAYLIST_FULL:
					hRet = g_pJoltMidi->LogError(SFERR_FFDEVICE_MEMORY,
										AckNack.dwErrorCode);
					break;
				
				default:
				case DEV_ERR_INVALID_PARAM:
				case DEV_ERR_CHECKSUM:
				case DEV_ERR_UNKNOWN_CMD:
				case DEV_ERR_INVALID_ID:
					hRet = g_pJoltMidi->LogError(SFERR_DEVICE_NACK,
										AckNack.dwErrorCode);
					break;
			}
		}
	}

// --- END OF CRITICAL SECTION
//
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::DestroyEffect
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::DestroyEffect()
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,DESTROY_EFFECT,EffectIDOf());
	if(!FAILED(hRet))
		g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay);

	return hRet;
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiBehavioral
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::CMidiBehavioral
// Purpose:		Constructor(s)/Destructor for CMidiBehavioral Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiBehavioral::CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope,
				PBE_XXX pBE_XXX):CMidiEffect(pEffect, NULL)
{
	SetSubType(pEffect->m_SubType);
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
	m_MidiBufferSize = sizeof(BEHAVIORAL_SYS_EX);
}

// --- Destructor
CMidiBehavioral::~CMidiBehavioral()
{
	memset(this, 0, sizeof(CMidiBehavioral));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiBehavioral::SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for BE_XXX
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiBehavioral::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PBEHAVIORAL_SYS_EX pBuf = (PBEHAVIORAL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Behavioral params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXConstantL  	= (BYTE)  XConstant & 0x7f;
	pBuf->bXConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYConstantL  	= (BYTE)  YConstant & 0x7f;
	pBuf->bYConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;

	LONG Param3 		= (LONG) (Param3Of()  * MAX_SCALE);
	LONG Param4 		= (LONG) (Param4Of()  * MAX_SCALE);
	pBuf->bParam3L  	= (BYTE)  Param3 & 0x7f;
	pBuf->bParam3H 		= (BYTE) (Param3 >> 7 ) & 0x01;
	pBuf->bParam4L  	= (BYTE)  Param4 & 0x7f;
	pBuf->bParam4H 		= (BYTE) (Param4 >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;

	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(BEHAVIORAL_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiFriction
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::CMidiFriction
// Purpose:		Constructor(s)/Destructor for CMidiFriction Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiFriction::CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(FRICTION_SYS_EX);
}

// --- Destructor
CMidiFriction::~CMidiFriction()
{
	memset(this, 0, sizeof(CMidiFriction));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiFriction::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PFRICTION_SYS_EX pBuf = (PFRICTION_SYS_EX) pSysExBuffer;

	SetTotalDuration();	// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_FRICTION params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXFConstantL  = (BYTE)  XConstant & 0x7f;
	pBuf->bXFConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYFConstantL  = (BYTE)  YConstant & 0x7f;
	pBuf->bYFConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;
	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(FRICTION_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiWall
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::CMidiWall
// Purpose:		Constructor(s)/Destructor for CMidiWall Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiWall::CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(WALL_SYS_EX);
}

// --- Destructor
CMidiWall::~CMidiWall()
{
	memset(this, 0, sizeof(CMidiWall));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiWall::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PWALL_SYS_EX pBuf = (PWALL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL		= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH		= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_WALL params
	LONG WallType 			= (LONG) (XConstantOf());
	LONG WallConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	LONG WallAngle			= (LONG)  Param3Of();
	LONG WallDistance		= (LONG) (Param4Of() * MAX_SCALE);

	pBuf->bWallType  		= (BYTE) (WallType & 0x01);
	pBuf->bWallConstantL  	= (BYTE) (WallConstant & 0x7f);
	pBuf->bWallConstantH	= (BYTE) ((WallConstant >> 7 ) & 0x01); //+/-100
	pBuf->bWallAngleL  		= (BYTE) (WallAngle & 0x7f);			// 0 to 359
	pBuf->bWallAngleH	 	= (BYTE) ((WallAngle >> 7 ) & 0x03);
	pBuf->bWallDistance		= (BYTE) (WallDistance & 0x7f);
	pBuf->bEffectID 		=  m_bEffectID;

	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
	  									sizeof(WALL_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiRTCSpring
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::CMidiRTCSpring
// Purpose:		Constructor(s)/Destructor for CMidiRTCSpring Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiRTCSpring::CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring):CMidiEffect(NULL)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// --- Destructor
CMidiRTCSpring::~CMidiRTCSpring()
{
	memset(this, 0, sizeof(CMidiRTCSpring));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::SetEffectParams
// Purpose:		Sets parameters
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiRTCSpring::SetEffectParams(PRTCSPRING_PARAM pRTCSpring)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::GenerateSysExPacket
// Purpose:		virtual
// Parameters:	none
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiRTCSpring::GenerateSysExPacket(void)
{
	return (NULL);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiDelay
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::CMidiDelay
// Purpose:		Constructor(s)/Destructor for CMidiDelay Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiDelay::CMidiDelay(PEFFECT pEffect) : CMidiEffect(pEffect, NULL)
{
	m_SubType   = ET_BE_DELAY;		// BE Effect Type: BE_DELAY
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS | PLAY_SUPERIMPOSE;
	m_MidiBufferSize = sizeof(NOP_SYS_EX);
}

// --- Destructor
CMidiDelay::~CMidiDelay()
{
	memset(this, 0, sizeof(CMidiDelay));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiDelay::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PNOP_SYS_EX pBuf = (PNOP_SYS_EX) pSysExBuffer;

	pBuf->bEffectID		=  m_bEffectID;
	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bChecksum		= ComputeChecksum((PBYTE) pSysExBuffer,
					 				sizeof(NOP_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiSynthesized
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::CMidiSynthesized
// Purpose:		Constructor(s)/Destructor for CMidiSynthesized Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiSynthesized::CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope,
						PSE_PARAM pParam ) : CMidiEffect(pEffect, pEnvelope)
{
	SetSubType(pEffect->m_SubType);				// SE Effect Type
//	Effect.bForceOutRateL= (BYTE) pParam->m_SampleRate & 0x7f;	// 1 to 500 Hz
//	Effect.bForceOutRateH= (BYTE) ((pParam->m_SampleRate >> 7) & 0x3);
	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);

	m_Freq		= pParam->m_Freq;				// Frequency
	m_MaxAmp	= pParam->m_MaxAmp;				// Maximum Amplitude
	// Special case a SE_CONSTANT_FORCE
	if (SE_CONSTANT_FORCE == pEffect->m_SubType)
		m_MinAmp = 0;
	else
		m_MinAmp = pParam->m_MinAmp;			// Minimum Amplitude

	m_MidiBufferSize = sizeof(SE_WAVEFORM_SYS_EX);
}

// --- Destructor
CMidiSynthesized::~CMidiSynthesized()
{
	memset(this, 0, sizeof(CMidiSynthesized));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiSynthesized::SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam,
									   ULONG ulAction)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	//Set the loop count from HIWORD of ulAction
	m_LoopCount = (ulAction >> 16) & 0xffff;
	if (0 == m_LoopCount) m_LoopCount++;

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for SE_xxx
	m_Freq	 = pParam->m_Freq;
	m_MaxAmp = pParam->m_MaxAmp;
	m_MinAmp = pParam->m_MinAmp;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiSynthesized::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);

	// Compute total with Loop count parameter, Note: Envelope parameters are
	// adjusted according to the Loop Count parameter, if affected.
	SetTotalDuration();
	ComputeEnvelope();

	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID + MIDI_EFFECT
	//			+ MIDI_ENVELOPE
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR)+3+sizeof(MIDI_EFFECT)+
				sizeof(MIDI_ENVELOPE)) );

	PSE_WAVEFORM_SYS_EX pBuf = (PSE_WAVEFORM_SYS_EX) pSysExBuffer;
	
	// Scale the gain, and Envelope amplitudes
	pBuf->Effect.bGain = (BYTE) (pBuf->Effect.bGain * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bAttackLevel  = (BYTE) (pBuf->Envelope.bAttackLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bSustainLevel = (BYTE) (pBuf->Envelope.bSustainLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bDecayLevel   = (BYTE) (pBuf->Envelope.bDecayLevel * MAX_SCALE) & 0x7f;

	// Copy the SE specific parameters
	LONG MaxAmp = (LONG) (m_MaxAmp * MAX_SCALE);
	LONG MinAmp = (LONG) (m_MinAmp * MAX_SCALE);
	pBuf->bFreqL   	= (BYTE)  (m_Freq & 0x7f);
	pBuf->bFreqH   	= (BYTE) ((m_Freq >> 7 ) & 0x03); 	// 1 to 500
	pBuf->bMaxAmpL 	= (BYTE)  (MaxAmp & 0x7f);
	pBuf->bMaxAmpH 	= (BYTE) ((MaxAmp >> 7 ) &0x01); 	// +127 to -128

	pBuf->bMinAmpL 	= (BYTE)  (MinAmp & 0x7f);
	pBuf->bMinAmpH 	= (BYTE) ((MinAmp >> 7 ) & 0x01);

	pBuf->bChecksum	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(SE_WAVEFORM_SYS_EX));
	pBuf->bEOX	   	= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CUD_Waveform
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CUD_Waveform::CUD_Waveform
// Purpose:		Constructor(s)/Destructor for CUD_Waveform Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiUD_Waveform::CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray) : CMidiEffect(pEffect, NULL),
	m_pRawData(NULL)
{
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS;// Sub-command opcode: DNLOAD_DATA
	m_SubType   = ET_UD_WAVEFORM;	// Effect Type: UD_WAVEFORM

	assert(pArray);
	// Create the buffer to hold the waveform data, compress it,
	// then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	// Set a fixed maximum size
	DWORD nSize = MAX_MIDI_WAVEFORM_DATA_SIZE + 2;
	m_pArrayData = new BYTE[nSize];
//	m_pRawData = new BYTE [nSize*2];
	assert(m_pArrayData);

	ULONG NewForceRate;
	m_MidiBufferSize = SetTypeParams(ulNumVectors, pArray, &NewForceRate);

	// Copy structures to object
	memcpy(&m_Effect.m_Bytes, pEffect, sizeof(EFFECT));
	SetForceOutRate(NewForceRate);
	m_Effect.m_Gain = m_Effect.m_Gain & 0x7f;
	m_Effect.m_Duration = (ULONG) ((float) (m_Effect.m_Duration / TICKRATE));
	m_Duration = m_Effect.m_Duration;
}

// --- Destructor
CMidiUD_Waveform::~CMidiUD_Waveform()
{
	if (m_pArrayData) delete [] m_pArrayData;
	memset(this, 0, sizeof(CMidiUD_Waveform));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetEffectParams
// Purpose:		Sets the Effect specific parameters
// Parameters:	PEFFECT pEffect
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiUD_Waveform::SetEffectParams(PEFFECT pEffect)
{	
	// Set the MIDI_EFFECT parameters
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);	
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetTypeParams
// Purpose:		Sets the type specific parameters
// Parameters:	int nSize		- size of the array
//				PLONG pArray - Pointer to an ARRAY of force values
//				
// Returns:		MidiBuffer size for the packet
// Algorithm:
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate)
{	
	// Compress the buffer data then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	m_NumberOfVectors = 0;

	m_pRawData = new BYTE [nSize*2];

	if (m_pRawData != NULL)
	{
		// Convert to -128 to +127
		for (int i=0; i<nSize; i++)
		{
			m_pRawData[i] = (BYTE) ((LONG) (pArray[i] * MAX_SCALE));		
		}

		m_NumberOfVectors = CompressWaveform(&m_pRawData[0], m_pArrayData, nSize, pNewRate);
		assert(m_NumberOfVectors <= (MAX_MIDI_WAVEFORM_DATA_SIZE));
		delete [] m_pRawData;
		m_pRawData = 0;
	}
	if (0 == m_NumberOfVectors)		// No room!
		return (0);
	m_MidiBufferSize = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX) + 2);
	return (m_MidiBufferSize);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::CompressWaveform
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	PBYTE pSrcArray		- Source Array pointer
//				PBYTE pDestArray 	- Dest. Array Pointer
//				int nSize			- Size in Bytes of the Source Array
//
// Returns:		int 	- Size of the compressed Array (in bytes)
// Algorithm:
// To "compress" we need to fit the entire waveform into 98 points (there is a
// FW bug that limits us to 100 points only, and we need at least two samples
// for the starting Absolute mode point.
// 1.  Determine how many points over 98.
//     nSrcSize:    Total sample size
//     nMaxSamples: Maximum samples to squeeze into = 98
//	   nOver:		nSrcSize - nMaxSamples
//	   nSkipSample:	# of points to keep before skipping one
//					= nSrcSize/nOver
//	   while ( Sample is less than nSrcSize, bump index)
//	   {
//		  if ( (index % nSkipSample) == 0)	// no remainder
//		  {
//			index++							// bump to skip the next sample
//		  }
//		  Compress the data
//	   }
//
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::CompressWaveform(
	IN PBYTE pSrcArray,
	IN OUT PBYTE pDestArray,
	IN int nSrcSize,
	OUT ULONG *pNewForceRate)
{
	assert(pSrcArray && pDestArray);
	LONG nDifference;

	// 8 bits (-128 to +127) Starting Absolute Data Value
	pDestArray[0] = pSrcArray[0] & 0x3f;
	pDestArray[1] = (pSrcArray[0] >> 6) & 0x03;

//	int nMaxSamples = MAX_MIDI_WAVEFORM_DATA_SIZE;

	int nSkipSample, nSrcIndex, nDestIndex;
	int nAbsolute = 0;
	int nRelative = 0;
	//
	// Start with Finest Resolution, then reduce until # of Samples <= nMaxSamples
	//
	nSkipSample = nSrcSize;
	while (TRUE)
	{
		nSrcIndex = 0;				// 1st sample already accounted for
		nDestIndex = 2;
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"nSkipSample=%d\n",nSkipSample);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		while (nSrcIndex < nSrcSize)
		{
			nSrcIndex++;
			if (0 == (nSrcIndex % nSkipSample))
			{
				nSrcIndex++;			// Skip next one
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-2]);
			}
			else
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-1]);

			// make sure we do not write outside of array bounds
			if(nDestIndex > MAX_MIDI_WAVEFORM_DATA_SIZE) break;

			if (abs(nDifference) < DIFFERENCE_THRESHOLD)
			{
				pDestArray[nDestIndex] = (BYTE)((nDifference & 0x3f) | DIFFERENCE_BIT);
				nDestIndex++;
				nRelative++;
			}
			else	// Switch to Absolute Data (8 bits)
			{
				pDestArray[nDestIndex] 	 = pSrcArray[nSrcIndex] & 0x3f;
				pDestArray[nDestIndex+1] = (pSrcArray[nSrcIndex] >> 6) & 0x3;
				nDestIndex = nDestIndex+2;
				nAbsolute++;
			}
		}
		if (nDestIndex <= MAX_MIDI_WAVEFORM_DATA_SIZE) break;
		// Reduce the resolution
		if (nSkipSample < 8)
			nSkipSample--;
		else
			nSkipSample = nSkipSample/2;
		if (1 == nSkipSample) return (0);	// Sorry charlie, no room!
		nAbsolute = 0;
		nRelative = 0;
	}

	// Done
	ULONG ulOriginalForceRate = ForceOutRateOf();
//	*pNewForceRate = (ulOriginalForceRate - (ULONG) (ulOriginalForceRate * ((float) nSkipSample / (float) nSrcSize)))/nSkipSample;
	*pNewForceRate = (ULONG) ((1.0f - (1.0f/nSkipSample)) * ulOriginalForceRate);


#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "CompressWaveform: nSrcSize=%d, nSkipSample=%d, NewForceRate=%d\n",
			nSrcSize, nSkipSample, *pNewForceRate);
	DebugOut(g_cMsg);
	wsprintf(g_cMsg,"\nTotal Absolute Data:%d, Relative Data:%d", nAbsolute, nRelative);
	DebugOut(g_cMsg);
	g_CriticalSection.Leave();
#endif


#ifdef _SHOWCOMPRESS
#pragma message("Compiling with SHOWCOMPRESS")
	g_CriticalSection.Enter();
	DebugOut("CMidiUD_Waveform::CompressWaveform(..) \npSrcArray Dump (Decimal)\n");
	for (int i=0; i<nSrcSize; i++)
	{
		wsprintf(g_cMsg," %0.4ld",((char) pSrcArray[i]));
		DebugOut(g_cMsg);
	}
	DebugOut("\npDestArray Dump (HEX)\n");

	for (i=0; i<nDestIndex; i++)
	{
		wsprintf(g_cMsg," %0.4x",pDestArray[i]);
		DebugOut(g_cMsg);
	}
	g_CriticalSection.Leave();
#endif
	return (nDestIndex);
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiUD_Waveform::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PUD_WAVEFORM_SYS_EX pBuf = (PUD_WAVEFORM_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->Effect.bDurationL     = (BYTE) (m_Duration & 0x7f);
	pBuf->Effect.bDurationH     = (BYTE) (m_Duration >> 7) & 0x7f;		
	pBuf->Effect.bAngleL	    =  Effect.bAngleL & 0x7f;	
	pBuf->Effect.bAngleH	    =  Effect.bAngleH & 0x7f;			
	pBuf->Effect.bGain		    = (BYTE) (Effect.bGain * MAX_SCALE) & 0x7f;	
	pBuf->Effect.bButtonPlayL   =  Effect.bButtonPlayL  & 0x7f;		
	pBuf->Effect.bButtonPlayH   =  Effect.bButtonPlayH  & 0x7f;	
	pBuf->Effect.bForceOutRateL =  Effect.bForceOutRateL & 0x7f;		
	pBuf->Effect.bForceOutRateH =  Effect.bForceOutRateH & 0x7f;
	pBuf->Effect.bPercentL	    =  Effect.bPercentL & 0x7f;
	pBuf->Effect.bPercentH	    =  Effect.bPercentH & 0x7f;

	// Fill in the Array Data
	PBYTE pArray = ((PBYTE) pBuf) + UD_WAVEFORM_START_OFFSET;
	memcpy(pArray, m_pArrayData, m_NumberOfVectors);	// Already scaled!

	pBuf->bEffectID	=  m_bEffectID;
	int nArraySize  = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX));
	pSysExBuffer[nArraySize] = 0;
	pSysExBuffer[nArraySize+1] = 0;
	pSysExBuffer[nArraySize] = ComputeChecksum((PBYTE) pSysExBuffer, (nArraySize+2));
	pSysExBuffer[nArraySize+1]= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiProcessList
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::CMidiProcessList
// Purpose:		Constructor(s)/Destructor for CMidiProcessList Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiProcessList::CMidiProcessList(ULONG ulButtonPlayMask, PPLIST pParam)
	: CMidiEffect(ulButtonPlayMask)
{
	m_OpCode    = PROCESS_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:PROCESS_DATA
	m_NumEffects  = pParam->ulNumEffects;
	if (m_NumEffects > MAX_PLIST_EFFECT_SIZE) m_NumEffects = MAX_PLIST_EFFECT_SIZE;
	assert(m_NumEffects > 0 && m_NumEffects <= MAX_PLIST_EFFECT_SIZE);

	m_ProcessMode = pParam->ulProcessMode;
	m_pEffectArray = new BYTE [m_NumEffects];

	if (m_pEffectArray != NULL)
	{
		for (int i=0; i< (int) m_NumEffects; i++)
		{
			m_pEffectArray[i] = (BYTE) (pParam->pEffectArray)[i];
		}
	}
	m_MidiBufferSize = sizeof(SYS_EX_HDR)+5+m_NumEffects + 2;
}

// --- Destructor
CMidiProcessList::~CMidiProcessList()
{
	if (m_pEffectArray) delete [] m_pEffectArray;
	memset(this, 0, sizeof(CMidiProcessList));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::SetParams
// Purpose:		Sets the type specific parameters
// Parameters:	PPLIST pParam
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiProcessList::SetParams(ULONG ulButtonPlayMask, PPLIST pParam)
{
	m_NumEffects  = pParam->ulNumEffects;
	if (m_NumEffects > MAX_PLIST_EFFECT_SIZE) m_NumEffects = MAX_PLIST_EFFECT_SIZE;
	assert(m_NumEffects > 0 && m_NumEffects <= MAX_PLIST_EFFECT_SIZE);

	Effect.bButtonPlayL = (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);

	m_ProcessMode = pParam->ulProcessMode;

	if (m_pEffectArray != NULL)
	{
		for (int i=0; i< (int) m_NumEffects; i++)
		{
			m_pEffectArray[i] = (BYTE) (pParam->pEffectArray)[i];
		}
	}
}

// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiProcessList::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID  + m_bButtonPlayL
	//	+ m_bButtonPlayH
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR) + 5 ));
	PPROCESS_LIST_SYS_EX pBuf = (PPROCESS_LIST_SYS_EX) pSysExBuffer;

	if (PL_SUPERIMPOSE == m_ProcessMode)
		pBuf->bSubType = PLIST_SUPERIMPOSE;
	else
		pBuf->bSubType = PLIST_CONCATENATE;

	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Copy the PLIST specific parameters
	memcpy(&pBuf->bEffectArrayID, m_pEffectArray, m_NumEffects);
	PBYTE pChecksum = (PBYTE) ( &pBuf->bEffectArrayID + m_NumEffects );

	pChecksum[0] = ComputeChecksum((PBYTE) pSysExBuffer,
							sizeof(SYS_EX_HDR)+5+m_NumEffects+2);					
	pChecksum[1] = MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiVFXProcessList
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiVFXProcessList::CMidiVFXProcessList
// Purpose:		Constructor(s)/Destructor for CMidiVFXProcessList Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiVFXProcessList::CMidiVFXProcessList(ULONG ulButtonPlayMask, PPLIST pParam)
	: CMidiProcessList(ulButtonPlayMask, pParam)
{
}

// ----------------------------------------------------------------------------
// Function: 	CMidiVFXEffect::DestroyEffect
// Purpose:		Sends the Short Message for itself and children
// Parameters:
// Returns:		Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiVFXProcessList::DestroyEffect()
{
	HRESULT hRet;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// destroy the children
	for (int i=0; i< (int) m_NumEffects; i++)
	{
		// get the CMidiEffect object corresponding to child ID
		CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(m_pEffectArray[i]);
		assert(NULL != pMidiEffect);
		if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

		// destroy the effect
		hRet = pMidiEffect->DestroyEffect();

		// remove it from the map
		if(!FAILED(hRet))
			g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

		// delete the object
		delete pMidiEffect;
	}

	// destroy itself
	hRet = CMidiEffect::DestroyEffect();

	// remove it from the map
	if(!FAILED(hRet))
		g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

	return hRet;
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiAssign
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiAssign::CMidiAssign
// Purpose:		Constructor(s)/Destructor for CMidiAssign Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiAssign::CMidiAssign(void) : CMidiEffect(NULL)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	m_OpCode    = MIDI_ASSIGN;					// Sub-command opcode
	m_SubType   = 0;							// not used
	m_Channel 	= DEFAULT_MIDI_CHANNEL;			// Midi channel
	m_MidiBufferSize = sizeof(MIDI_ASSIGN_SYS_EX);

// --- END OF CRITICAL SECTION
//
}

// --- Destructor
CMidiAssign::~CMidiAssign()
{
	memset(this, 0, sizeof(CMidiAssign));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiAssign::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiAssign::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);

	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );

	PMIDI_ASSIGN_SYS_EX pBuf = (PMIDI_ASSIGN_SYS_EX) pSysExBuffer;

	pBuf->bChannel  		= (BYTE) (m_Channel & 0x0f);
	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(MIDI_ASSIGN_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_out.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OUT.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Uses a low-level callback function to get timestamped 
    				MIDI output. The callback function sets an Event to indicate
    				to wake up a blocked object.
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			10-Jan-97	MEA     original

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "midi_obj.hpp"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// Prototypes
void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);



// ----------------------------------------------------------------------------
// Function: 	midiOutputHandler
// Purpose:		
// Parameters:	hMidiIn - Handle for the associated output device.
//				wMsg - One of the MIM_***** messages.
//				dwInstance - Points to CALLBACKINSTANCEDATA structure.
//				dwParam1 - MIDI data.
//				dwParam2 - Timestamp (in milliseconds)
//
// Returns:		none
// Algorithm:
// Comments:
//		Low-level callback function to handle MIDI output.
//      Installed by midiOutOpen().  The Output handler checks for MM_MOM_DONE
//		message and wakes up the thread waiting for completion of MIDI SysEx 
//		output.  Note: Normal Short messages don't get notification!!!
//      This function is accessed at interrupt time, so it should be as 
//      fast and efficient as possible.  You can't make any
//      Windows calls here, except PostMessage().  The only Multimedia
//      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
// ----------------------------------------------------------------------------
void CALLBACK midiOutputHandler(
	IN HMIDIOUT hMidiOut, 
	IN UINT wMsg, 
	IN DWORD dwInstance, 
	IN DWORD dwParam1, 
	IN DWORD dwParam2)
{
	CJoltMidi *pJoltMidi = (CJoltMidi *) dwInstance;
	assert(pJoltMidi);
	BOOL bRet;
    
	switch(wMsg)
    {
        case MOM_OPEN:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: MOM_OPEN.\n");
#endif
            break;

        case MM_MOM_DONE:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: MM_MOM_DONE\n");
#endif
			// Notify task waiting on this object to trigger
			bRet = SetEvent(pJoltMidi->MidiOutputEventHandleOf());
			assert(bRet);
            break;

        default:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: default case.\n");
#endif
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swff_pro.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\swd_guid.cpp ===
/****************************************************************************

    MODULE:         SWD_GUID.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPODE:    	Instantiate GUIDS
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce

****************************************************************************/
#ifdef   WIN32
#define  INITGUIDS
#include <objbase.h>
#else
#include <memory.h>
#include <string.h>
#include <compobj.h>
#endif
#include <initguid.h>
#include "dinput.h"
#include "dinputd.h"
#include "SWD_Guid.hpp"
#include <dmusicc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
	}

	if (rkey.m_pReferenceCount != NULL) {
		*(rkey.m_pReferenceCount) = 1;
		m_pReferenceCount = rkey.m_pReferenceCount;
		++(*m_pReferenceCount);
	}
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	if (rhs.m_pReferenceCount != NULL)
	{
		*(rhs.m_pReferenceCount) = 1;
		m_pReferenceCount = rhs.m_pReferenceCount;
		++(*m_pReferenceCount);
	}

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\swd_guid.hpp ===
/****************************************************************************

    MODULE:     	SWD_GUID.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:            CLSIDs and IIDs defined for DirectInputForce

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SWD_GUID_SEEN
#define _SWD_GUID_SEEN

#ifdef INITGUIDS
#include <initguid.h>
#endif //INITGUIDS


/*
 * GUIDs
 *
 */

//
// --- SideWinder Force Feedback Device Driver Interface
//
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{e84cd1b1-81fa-11d0-94ab-0080c74c7e95}")
#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

//
// --- Effect GUIDs
//
DEFINE_GUID(GUID_Wall, /* e84cd1a1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ProcessList, /* e84cd1a2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// Built in ROM Effects
DEFINE_GUID(GUID_RandomNoise, /* e84cd1a3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_AircraftCarrierTakeOff, /* e84cd1a4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_BasketballDribble, /* e84cd1a5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_CarEngineIdle, /* e84cd1a6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawIdle, /* e84cd1a7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawInAction, /* e84cd1a8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_DieselEngineIdle, /* e84cd1a9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Jump, /* e84cd1aa-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1aa,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Land, /* e84cd1ab-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ab,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_MachineGun, /* e84cd1ac-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ac,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Punched, /* e84cd1ad-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ad,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_RocketLaunch, /* e84cd1ae-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ae,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SecretDoor, /* e84cd1af-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1af,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SwitchClick, /* e84cd1b0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindGust, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindShear, /* e84cd1b2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Pistol, /* e84cd1b3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Shotgun, /* e84cd1b4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser1, /* e84cd1b5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser2, /* e84cd1b6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser3, /* e84cd1b7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser4, /* e84cd1b8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser5, /* e84cd1b9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser6, /* e84cd1ba-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ba,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_OutOfAmmo, /* e84cd1bb-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bb,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_LightningGun, /* e84cd1bc-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bc,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Missile, /* e84cd1bd-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bd,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_GatlingGun, /* e84cd1be-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1be,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ShortPlasma, /* e84cd1bf-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bf,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon1, /* e84cd1c0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon2, /* e84cd1c1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Cannon, /* e84cd1c2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RawForce, /* e84cd1c6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_VFXEffect, /* e84cd1c7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RTCSpring, /* e84cd1c8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

//
// --- UNUSED but reserved for future GUIDs
//


#endif //_SWD_GUID_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_obj.hpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.HPP
	Tab Settings:	5 9

    PURPOSE:    	Header to define SWFF MIDI device objects
    
    FUNCTIONS:
        		Classes with members and methods are kept in this header file

	Version Date        Author  Comments
	0.1		10-Sep-96	MEA     original
	1.1		17-Mar-97	MEA		DX-FF mode

****************************************************************************/
#ifndef MIDI_OBJ_SEEN
#define MIDI_OBJ_SEEN
 
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "dinput.h"
#include "vxdioctl.hpp"
#include "sw_error.hpp"

#define MAX_SCALE	1.27				// 1 to 100 = 1 to 127
#define TICKRATE	2					// 2 ms per tick divisor

#define SWFF_SHAREDMEM_FILE		"SWFF_SharedMemFile"
#define SWFF_MIDIEVENT			"SWFFMidiEvent\0"
#define SWFF_SHAREDMEM_MUTEX	"SWFFSharedMemMutex\0"
#define SWFF_JOLTOUTPUTDATA_MUTEX	"SWFFJoltOutputDataMutex\0"
#define SIZE_SHARED_MEMORY 1024			// 1024 bytes
#define MUTEX_TIMEOUT	10000			// 10 seconds timeout

// spring
#define DEF_SCALE_KX	100
#define DEF_SCALE_KY	100

// damper
#define DEF_SCALE_BX	100
#define DEF_SCALE_BY	100

// inertia
#define DEF_SCALE_MX	80
#define DEF_SCALE_MY	80

// friction
#define DEF_SCALE_FX	100
#define DEF_SCALE_FY	100

// wall
#define DEF_SCALE_W		100

typedef struct _FIRMWARE_PARAMS
{
	DWORD dwScaleKx;
	DWORD dwScaleKy;
	DWORD dwScaleBx;
	DWORD dwScaleBy;
	DWORD dwScaleMx;
	DWORD dwScaleMy;
	DWORD dwScaleFx;
	DWORD dwScaleFy;
	DWORD dwScaleW;
} FIRMWARE_PARAMS, *PFIRMWARE_PARAMS;
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams);

typedef struct _SYSTEM_PARAMS
{
	RTCSPRING_PARAM RTCSpringParam;
} SYSTEM_PARAMS, *PSYSTEM_PARAMS;
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams);


#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

typedef struct _JOYSTICK_PARAMS
{
	DWORD dwXYConst;
	DWORD dwRotConst;
	DWORD dwSldrConst;
	DWORD dwAJPos;
	DWORD dwAJRot;
	DWORD dwAJSldr;
	DWORD dwSprScl;
	DWORD dwBmpScl;
	DWORD dwDmpScl;
	DWORD dwInertScl;
	DWORD dwVelOffScl;
	DWORD dwAccOffScl;
	DWORD dwYMotBoost;
	DWORD dwXMotSat;
	DWORD dwReserved;
	DWORD dwMasterGain;
} JOYSTICK_PARAMS, *PJOYSTICK_PARAMS;
void GetJoystickParams(UINT nJoystickID, PJOYSTICK_PARAMS pJoystickParams);
void UpdateJoystickParams(PJOYSTICK_PARAMS pJoystickParams);



// Shared Memory data structure
typedef struct _SHARED_MEMORY {
	char	m_cWaterMark[MAX_SIZE_SNAME];
	ULONG	m_RefCnt;
	HANDLE	m_hMidiOut;
	MIDIINFO m_MidiOutInfo;
} SHARED_MEMORY, *PSHARED_MEMORY;


// Effect Types conversion structure
typedef struct _EFFECT_TYPE {
	ULONG	ulHostSubType;
	BYTE	bDeviceSubType;
} EFFECT_TYPE, *PEFFECT_TYPE;

//
// --- ROM Effects default parameters structure
//
typedef struct _ROM_FX_PARAM {
	ULONG	m_ROM_Id;
	ULONG	m_ForceOutputRate;
	ULONG	m_Gain;
	ULONG	m_Duration;
} ROM_FX_PARAM, *PROM_FX_PARAM;


// Structure to pass instance data from the application
//   to the low-level callback function. (Output done notification)
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    HMIDIOUT            hMapper;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

class CJoltMidi;
//	--- MIDI Effect base class
class CMidiEffect : public SYS_EX_HDR
{
 protected:
	BYTE	m_OpCode;				// Sub-command opcode: e.g. DNLOAD_DATA
	BYTE	m_SubType;				// Effect SubType: e.g. BE_SPRING
	BYTE	m_bEffectID;			// 0x7F = Create New, else valid Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
	BYTE	m_bAxisMask;
	BYTE	m_bPlayMode;			// DL_PLAY_SUPERIMPOSE || DL_PLAY_SOLO
    LPSTR	m_pBuffer;				// Ptr to a Midi SYS_EX Buffer
	int		m_MidiBufferSize;		// Size of SYS_EX buffer
	int		m_LoopCount;			// Loop Count for the playback
	LONG	m_Duration;				// Atomic Effect Duration (for 1 cycle)
	ENVELOPE	m_Envelope;			// Atomic Envelope (no loop count)
	EFFECT	m_OriginalEffectParam;	// the effect param when the effect was created

 public:
	// Constructor/Destructor
	CMidiEffect(ULONG ulButtonPlayMask);
	CMidiEffect(PEFFECT pEffect, PENVELOPE pEnvelope);
	virtual ~CMidiEffect(void);

	// Methods
	ULONG	SubTypeOf(void);
	BYTE	EffectIDOf(void) { return m_bEffectID; }
	ULONG	DurationOf(void) { return m_Duration * TICKRATE; }
	BYTE	AxisMaskOf(void) { return m_bAxisMask; }
	ULONG	DirectionAngle2DOf(void) 
			{ return(Effect.bAngleL+((USHORT)Effect.bAngleH<<7));}
	BYTE	GainOf(void) { return Effect.bGain; }
	ULONG	ButtonPlayMaskOf(void) 
			{ return(Effect.bButtonPlayL+((USHORT)Effect.bButtonPlayH<<7));}
	ULONG	ForceOutRateOf(void) 
			{ return (Effect.bForceOutRateL+((USHORT)Effect.bForceOutRateH<<7));}
	ULONG	PlayModeOf(void) { 
					if (DL_PLAY_SOLO == m_bPlayMode)
						return PLAY_SOLO;
					else 
						return PLAY_SUPERIMPOSE; }

	int		MidiBufferSizeOf(void) { return m_MidiBufferSize; }
    LPSTR	LockedBufferPtrOf(void) { return m_pBuffer; }
	int		LoopCountOf(void) { return m_LoopCount; }

	PEFFECT OriginalEffectParamOf() { return &m_OriginalEffectParam; }
	ENVELOPE * EnvelopePtrOf() { return &m_Envelope; }

	void	SetSubType(ULONG ulArg);
	void	SetEffectID(BYTE bArg) { m_bEffectID = bArg; }
	void	SetDuration(ULONG ulArg);
	void	SetAxisMask(BYTE bArg) { m_bAxisMask = bArg; }
	void	SetDirectionAngle(ULONG ulArg) 
			{ Effect.bAngleL = (BYTE) ulArg & 0x7f;
			  Effect.bAngleH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetGain(BYTE bArg) { Effect.bGain = (BYTE) (bArg * MAX_SCALE); }
	void	SetButtonPlaymask(ULONG ulArg)
			{ Effect.bButtonPlayL = (BYTE) ulArg & 0x7f;
			  Effect.bButtonPlayH = (BYTE) ((ulArg >> 7) & 0x03);}
	void	SetForceOutRate(ULONG ulArg) 
			{ Effect.bForceOutRateL = (BYTE) ulArg & 0x7f;
			  Effect.bForceOutRateH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetMidiBufferSize(int nArg) { m_MidiBufferSize = nArg; }
	void	SetMidiBufferPtr(LPSTR pArg) { m_pBuffer = pArg; }
	
	void	SetPlayMode(ULONG ulArg) { 
					if (PLAY_SOLO == ulArg) 
						m_bPlayMode = DL_PLAY_SOLO;
					else
						m_bPlayMode = DL_PLAY_SUPERIMPOSE; }

	void	SetLoopCount(ULONG ulAction) 
					{ m_LoopCount = ((ulAction >> 16) & 0xffff); }
	void	SetTotalDuration(void);
	void	SetEnvelope(PENVELOPE pArg) 
				{ m_Envelope.m_Type = pArg->m_Type;
				  m_Envelope.m_Attack = pArg->m_Attack;
				  m_Envelope.m_Sustain = pArg->m_Sustain;
				  m_Envelope.m_Decay = pArg->m_Decay;
				  m_Envelope.m_StartAmp = pArg->m_StartAmp;
				  m_Envelope.m_SustainAmp = pArg->m_SustainAmp;
				  m_Envelope.m_EndAmp = pArg->m_EndAmp; }
	void	ComputeEnvelope(void);
	BYTE  	ComputeChecksum(PBYTE pArg, int nBufferSize); 
	virtual PBYTE GenerateSysExPacket(void) = 0;
	HRESULT SendPacket(PDNHANDLE pDnloadID, int nPacketSize); 

	virtual HRESULT DestroyEffect();
};

//	--- MIDI Behavioral Effect derived class
class CMidiBehavioral : public CMidiEffect
{
 protected:
	BE_XXX	m_BE_XXXParam;	// Behavioral Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiBehavioral(void);

	// Methods
	LONG	XConstantOf(void) { return m_BE_XXXParam.m_XConstant; }
	LONG	YConstantOf(void) { return m_BE_XXXParam.m_YConstant; }
	LONG	Param3Of(void) { return m_BE_XXXParam.m_Param3; }
	LONG	Param4Of(void) { return m_BE_XXXParam.m_Param4; }

	void	SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX);
	void	SetXConstant(LONG lArg) { m_BE_XXXParam.m_XConstant = lArg; }
	void	SetYConstant(LONG lArg) { m_BE_XXXParam.m_YConstant = lArg; }
	void	SetParam3(LONG lArg) { m_BE_XXXParam.m_Param3 = lArg; }
	void	SetParam4(LONG lArg) { m_BE_XXXParam.m_Param4 = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Friction Effect derived class
class CMidiFriction : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiFriction(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Wall Effect derived class
class CMidiWall : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiWall(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI RTC Spring Effect derived class
class CMidiRTCSpring : public CMidiEffect
{
 protected:
	RTCSPRING_PARAM	m_RTCSPRINGParam;	// RTCSpring Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring);
	virtual ~CMidiRTCSpring(void);

	// Methods
	LONG	XKConstantOf(void) { return m_RTCSPRINGParam.m_XKConstant; }
	LONG	YKConstantOf(void) { return m_RTCSPRINGParam.m_YKConstant; }
	LONG	XAxisCenterOf(void) { return m_RTCSPRINGParam.m_XAxisCenter; }
	LONG	YAxisCenterOf(void) { return m_RTCSPRINGParam.m_YAxisCenter; }
	LONG	XSaturationOf(void) { return m_RTCSPRINGParam.m_XSaturation; }
	LONG	YSaturationOf(void) { return m_RTCSPRINGParam.m_YSaturation; }
	LONG	XDeadBandOf(void) { return m_RTCSPRINGParam.m_XDeadBand; }
	LONG	YDeadBandOf(void) { return m_RTCSPRINGParam.m_YDeadBand; }
	void	SetEffectParams(PRTCSPRING_PARAM pRTCSpring);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Delay Effect derived class
class CMidiDelay : public CMidiEffect
{
 protected:
 public:
	// Constructor/Destructor
	CMidiDelay(PEFFECT pEffect);
	virtual ~CMidiDelay(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Synthesized Effect derived class
class CMidiSynthesized : public CMidiEffect
{
 protected:
	ULONG	m_Freq;			// Frequency
	LONG	m_MaxAmp;		// Maximum Amplitude
	LONG	m_MinAmp;		// Minimum Amplitude
 public:
	// Constructor/Destructor
	CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope, PSE_PARAM pParam);
	virtual ~CMidiSynthesized(void);

	// Methods
	ULONG	FreqOf(void)   { return m_Freq; }
	LONG	MaxAmpOf(void) { return m_MaxAmp; }
	LONG	MinAmpOf(void) { return m_MinAmp; }

	void	SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam, ULONG ulMode);
	void	SetFreq(ULONG ulArg) { m_Freq = ulArg; }
	void	SetMaxAmp(LONG lArg) { m_MaxAmp = lArg; }
	void	SetMinAmp(LONG lArg) { m_MinAmp = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI UD_Waveform Effect derived class
class CMidiUD_Waveform : public CMidiEffect
{
 protected:
	EFFECT  m_Effect;
	int		m_NumberOfVectors;// Size of the Array
	PBYTE	m_pArrayData;	// Pointer to an scaled (+/-127) array of forces
	PBYTE	m_pRawData;		// Pointer to unscaled array of forces

 public:
	// Constructor/Destructor
	CMidiUD_Waveform(PEFFECT pEffect);
	CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray);
	virtual ~CMidiUD_Waveform(void);

	// Methods
	PEFFECT EffectPtrOf() { return (PEFFECT) &m_Effect.m_Bytes; }
	int		NumberOfVectorsOf(void) { return m_NumberOfVectors; }
	PBYTE	ArrayDataPtrOf(void) { return m_pArrayData; }
	int		CompressWaveform(PBYTE pSrcArray, PBYTE pDestArray, int nSrcSize, ULONG *pNewRate);
	void	SetEffectParams(PEFFECT pEffect);
	int		SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate);
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Process List Effect derived class
class CMidiProcessList : public CMidiEffect
{
 protected:
	ULONG	m_NumEffects;
	ULONG	m_ProcessMode;	// PL_SUPERIMPOSE or PL_CONCATENATE
	PBYTE	m_pEffectArray;	// Effect ID[0} . . .

 public:
	// Constructor/Destructor
	CMidiProcessList(ULONG ulButtonPlayMask, PPLIST pParam);
	virtual ~CMidiProcessList(void);

	// Methods
	ULONG	NumEffectsOf(void) { return (ULONG) m_NumEffects; }
	PBYTE	EffectArrayOf(void) { return m_pEffectArray; }
	void	SetProcessMode(ULONG ulArg) { m_ProcessMode = ulArg; }
	void	SetParams(ULONG ulButtonPlayMask, PPLIST pPlist);	
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Process List Effect derived class
class CMidiVFXProcessList : public CMidiProcessList
{
 protected:

 public:
	// Constructor/Destructor
	CMidiVFXProcessList(ULONG ulButtonPlayMask, PPLIST pParam);

	// Methods
	virtual HRESULT DestroyEffect();
};

//	--- MIDI Assign Midi channel command "Effect" derived class
class CMidiAssign : public CMidiEffect
{
 protected:
	ULONG	m_Channel;		// Channel 0 - 15
 public:
	// Constructor/Destructor
	CMidiAssign(void);
	virtual ~CMidiAssign(void);

	// Methods
	ULONG	MidiAssignChannelOf(void) { return m_Channel; }

	void	SetMidiAssignChannel(ULONG ulArg) { m_Channel = ulArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- Jolt Device base class
class CJoltMidi
{
 protected:
	LOCAL_PRODUCT_ID m_ProductID;		// Device information
	FIRMWARE_PARAMS	m_FirmwareParams;	// Behavioral effect fudge factors
	DELAY_PARAMS	m_DelayParams;		// Timing parameters

	// Power Cycle Restore Thread variables
#if 0
	DWORD   m_dwThreadID;
	HANDLE  m_hDataEvent;
	HANDLE  m_hDataThread;
	DWORD	m_dwThreadSignal;
	DWORD	m_dwThreadStatus;	        // TRUE = thread is alive, else FALSE
#endif
	ULONG			m_COMMInterface;	// COMM_WINMM || COMM_MIDI_BACKDOOR || COMM_SERIAL_BACKDOOR || COMM_SERIAL_FILE
	ULONG			m_COMMPort;			// e.g. 330, 3F8, or 0 for winmm
	HANDLE			m_hVxD;				// Handle to VxD for IOCTL interface
	HANDLE  		m_hMidiOutputEvent;	// Handle to Midi Output Event
	MIDIOUTCAPS 	m_MidiOutCaps; 		// MIDI Output Device capabilities structures
	int				m_MidiOutDeviceID;	// Midi Output device ID
	BOOL			m_MidiOutOpened;	// TRUE = MidiOutOpen called
	LPCALLBACKINSTANCEDATA m_lpCallbackInstanceData;
	CMidiEffect		*m_pJoltEffectList[MAX_EFFECT_IDS];	// Array of Downloaded Effects IPTrs
	BYTE			m_MidiChannel;		// Midi Channel
	SWFF_ERROR  	m_Error;		 	// System Error codes
	MIDIINFO 		m_MidiOutInfo;		// Midi output Info structure
	BOOL			m_ShutdownSent;		// TRUE = Last command sent was Shutdown
	DIAG_COUNTER	m_DiagCounter;		// For debugging, Diagnostics counter

	SWDEVICESTATE	m_DeviceState;
	HANDLE			m_hPrimaryBuffer;	// Handle to locked memory
	LPBYTE			m_pPrimaryBuffer;	// Pointer to the Primary buffer memory
	PROM_FX_PARAM	m_pRomFxTable;		// Default settings for ROM Effects
	HANDLE	m_hSharedMemoryFile;		// Handle to a memory mapped file
	PSHARED_MEMORY	m_pSharedMemory;	// Pointer to a Shared Memory structure
	HANDLE			m_hSWFFDataMutex;	// Local copy of Mutex handle
//	HANDLE			m_hJoltOutputDataMutex;	// Local copy of Mutex handle (locks Jolt to
//										// single output command at a time.

 public:
	// Constructor/Destructor
	CJoltMidi(void);
	~CJoltMidi(void);

	// Methods
	HANDLE SWFFDataMutexHandleOf() { return m_hSWFFDataMutex; }
	HRESULT Initialize(DWORD dwDeviceID);
#if 0
	HANDLE JoltOutputDataMutexHandleOf() { return m_hJoltOutputDataMutex; }
	DWORD  ThreadIDOf(void) { return m_dwThreadID; }
	HANDLE DataEventOf(void) {return m_hDataEvent; }
	HANDLE DataThreadOf(void) {return m_hDataThread; }
	DWORD  ThreadSignalOf(void) { return m_dwThreadSignal; }
	DWORD  ThreadStatusOf(void) { return m_dwThreadStatus; }
#endif

	HANDLE	MidiOutputEventHandleOf(void) { return m_hMidiOutputEvent; }
	HMIDIOUT MidiOutHandleOf(void) { return HMIDIOUT(m_pSharedMemory->m_hMidiOut); }
	int 	MidiOutDeviceIDOf(void) { return m_MidiOutDeviceID; }
	LPCALLBACKINSTANCEDATA CallbackInstanceDataOf(void) 
					{ return m_lpCallbackInstanceData; }
	BYTE	MidiChannelOf(void) { return m_MidiChannel; }
	void	CJoltGetLastError(PSWFF_ERROR pError)
							{ pError->HCode = m_Error.HCode;
							  pError->ulDriverCode = m_Error.ulDriverCode; }
	MIDIINFO *MidiOutInfoOf(void) { return &m_MidiOutInfo; }
	BOOL	ShutdownSentOf(void) { return m_ShutdownSent; }
	PDIAG_COUNTER DiagCounterPtrOf() { return &m_DiagCounter; }
	PBYTE	PrimaryBufferPtrOf() { return m_pPrimaryBuffer; }

	LOCAL_PRODUCT_ID* ProductIDPtrOf() { return &m_ProductID; }
	PFIRMWARE_PARAMS FirmwareParamsPtrOf() {return &m_FirmwareParams; }
	PDELAY_PARAMS DelayParamsPtrOf() {return &m_DelayParams; }
	ULONG	COMMInterfaceOf() { return m_COMMInterface; }
	ULONG	COMMPortOf() { return m_COMMPort; }

#if 0
	void 	SetThreadIDOf(DWORD dwArg) { m_dwThreadID = dwArg; }
	void 	SetDataEvent(HANDLE hArg) { m_hDataEvent = hArg; }
	void 	SetDataThread(HANDLE hArg) { m_hDataThread = hArg; }
	void 	SetThreadSignal(DWORD dwArg) { m_dwThreadSignal = dwArg; }
	void 	SetThreadStatus(DWORD dwArg) { m_dwThreadStatus = dwArg; }
	BOOL	LockJoltOutputData(void);
	void	UnlockJoltOutputData(void);
#endif

	BOOL	LockSharedMemory(void);
	void	UnlockSharedMemory(void);

	void	SetSWFFDataMutexHandle(HANDLE hArg) { m_hSWFFDataMutex = hArg;}
//	void	SetJoltOutputDataMutexHandle(HANDLE hArg) { m_hJoltOutputDataMutex = hArg;}
	void 	SetMidiOutHandle(HMIDIOUT hArg) { LockSharedMemory();
											  m_pSharedMemory->m_hMidiOut = hArg;
											  UnlockSharedMemory();}	
	void 	SetMidiOutDeviceID(int nArg) {m_MidiOutDeviceID = nArg; }
	void 	SetCallbackInstanceData(LPCALLBACKINSTANCEDATA pArg) 
				{ m_lpCallbackInstanceData = pArg; }
	void	SetMidiChannel(BYTE nArg) { m_MidiChannel = nArg; }
	void	SetShutdownSent(BOOL bArg) { m_ShutdownSent = bArg; }
	void	ClearDiagCounters(void) { m_DiagCounter.m_NACKCounter = 0;
									  m_DiagCounter.m_LongMsgCounter = 0; 
									  m_DiagCounter.m_ShortMsgCounter = 0;
									  m_DiagCounter.m_RetryCounter = 0; }
	void	BumpNACKCounter(void) { m_DiagCounter.m_NACKCounter++; }
	void	BumpLongMsgCounter(void) { m_DiagCounter.m_LongMsgCounter++; }
	void	BumpShortMsgCounter(void) { m_DiagCounter.m_ShortMsgCounter++; }
	void	BumpRetryCounter(void) { m_DiagCounter.m_RetryCounter++; }

	HRESULT	LogError(HRESULT hSystemError, HRESULT DriverError);

	void	SetJoltStatus(JOYCHANNELSTATUS* pJoyStatus);
	HRESULT	GetJoltStatus(LPDIDEVICESTATE);
	HRESULT	GetJoltStatus(PSWDEVICESTATE);
	SWDEVICESTATE GetSWDeviceStateNoUpdate() const { return m_DeviceState; } 

	void	UpdateDeviceMode(ULONG ulMode);
	HRESULT GetJoltID(LOCAL_PRODUCT_ID* pProductID);

	// Downloaded Effects management
	CMidiEffect *GetEffectByID(DNHANDLE hID)
				{ 	assert(hID < 0x7f);
    			  	if (hID >= 0x7f)
    			  		return NULL;
					else
						return m_pJoltEffectList[hID]; }
						
	void	SetEffectByID(DNHANDLE hID, CMidiEffect *pArg) 
				{ m_pJoltEffectList[hID] = pArg; }

	BOOL	NewEffectID(PDNHANDLE pDnloadID);
	void    DeleteDownloadedEffects(void);
	void	RestoreDownloadedEffects(void);
	
	// Midi management
	BOOL	DetectMidiDevice(DWORD dwDeviceID, UINT *pDeviceOutID,
							ULONG *pCOMMInterface, ULONG *pCOMMPort);

	HRESULT	ValidateMidiHandle(void);
	HRESULT OpenOutput(int nDeviceID);
	BOOL	IsMidiOutputOpened(void) { return m_MidiOutOpened; }
	HRESULT MidiSendShortMsg(BYTE cStatus, BYTE cData1,BYTE cData2);
	HRESULT MidiSendLongMsg(void);
	HRESULT MidiAssignBuffer(LPSTR lpData, DWORD dwBufferLength, BOOL fAssign);
	
	// Response from Jolt management
	HRESULT GetAckNackData(int nTimeWait, PACKNACK pAckNack, USHORT regindex);
	HRESULT GetEffectStatus(DWORD DnloadID, PBYTE pStatusCode);
	BOOL	QueryForJolt(void);
	BOOL	FindJoltWinMM(UINT *pDeviceOutID,ULONG *pCOMMInterface,ULONG *pCOMMPort);
	BOOL	FindJoltBackdoor(UINT *pDeviceOutID,ULONG *pCOMMInterface,ULONG *pCOMMPort);

	// Instance Data management
	LPCALLBACKINSTANCEDATA AllocCallbackInstanceData(void);
	void 	FreeCallbackInstanceData(void);

	// Digital OverDrive interface
	HRESULT	InitDigitalOverDrive(DWORD dwDeviceID);
	HANDLE	VxDHandleOf(void) { return m_hVxD; }

	// ROM Effects
	HRESULT SetupROM_Fx(PEFFECT pEffect);

	// Thread
//	HRESULT PowerCycleThreadCreate(void);
};

extern CJoltMidi* g_pJoltMidi;	// Global Jolt Object

#endif    // of ifndef MIDI_OBJ_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_globs.cpp ===
/****************************************************************************

    MODULE:     	SW_GLOBS.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	SWFF_PRO Global Variables
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.1    		15-May-97   MEA     original
				20-Mar-99	waltw	Added validity checks into functions that use
									g_pJoltMidi. Because of structure of code,
									some of these are redundant but safer than
									depending on call tree not changing.

****************************************************************************/
#include <windows.h>
#include "midi_obj.hpp"

//
// Globals
//

#ifdef _DEBUG
char g_cMsg[160];
TCHAR szDeviceName[MAX_SIZE_SNAME] = {"Microsoft SideWinder Force Feedback Pro"};
#endif

// 
// *** Global on per process space only
//
CJoltMidi *g_pJoltMidi = NULL;


// *** End of Globals on per process space
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\version.h ===
/*******************************************************************************
**
**       MODULE: VERSION.H
**
**  DESCRIPTION: Contains version numbers for Vger Project
**
**
**       AUTHOR: Manolito Adan
**
**
**      CREATED: 30-Sep-96
**		REVISED: 23-Dec-96
**				 15-Mar-99	waltw	Now get info from ntverp.h & common.ver in
**									NT build tree
**
**
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T    C O R P   1 9 8 1 - 1 9 9 4.
**
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cfact.hpp ===
/****************************************************************************

    MODULE:     	SW_CFACT.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definitions, classes, and prototypes for a DLL that
    				provides Effect objects to any other object user.

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce	
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SW_CFACT_SEEN
#define _SW_CFACT_SEEN


//Get the object definitions
#include "SW_objec.hpp"

void ObjectDestroyed(void);

//SW_CFACT.CPP
//This class factory object creates DirectInputEffectDriver objects.

class CDirectInputEffectDriverClassFactory : public IClassFactory
{
 protected:
 	ULONG           m_cRef;

 public:
    CDirectInputEffectDriverClassFactory(void);
    ~CDirectInputEffectDriverClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                             , PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDirectInputEffectDriverClassFactory *PCDirectInputEffectDriverClassFactory;

#endif //_SW_CFACT_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_error.hpp ===
/****************************************************************************

    MODULE:     	SW_Error.HPP
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for Error Codes
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original

****************************************************************************/
#ifndef SW_Error_SEEN
#define SW_Error_SEEN

#include <winerror.h>
#include <windows.h>
#include <mmsystem.h>


typedef struct _SWFF_ERROR {
	HRESULT	HCode;			// HRESULT code
	ULONG	ulDriverCode;	// Error code from device driver
} SWFF_ERROR, *PSWFF_ERROR;


//---------------------------------------------------------------------------
// Error Status Codes
//---------------------------------------------------------------------------
/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */

// SWForce Errors
#define MAKE_FF_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_FF_E( err )  (MAKE_FF_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_FF_S( warn ) (MAKE_FF_SCODE( 0, FACILITY_ITF, warn ))

#define DINPUT_DRIVER_ERR_BASE	0x500

#define SUCCESS					0x00										// successful
#define SFERR_INVALID_OBJECT		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 1)	// Invalid object ID
#define SFERR_INVALID_PARAM			DIERR_INVALIDPARAM						// Invalid parameters
#define SFERR_NO_SUPPORT			DIERR_UNSUPPORTED						// Function not supported
#define SFERR_INVALID_DEVICE		DIERR_DEVICENOTREG						// Device not found
#define	SFERR_FFDEVICE_MEMORY		DIERR_DEVICEFULL						// Out of download RAM
#define SFERR_END_OF_LIST			MAKE_FF_S(DINPUT_DRIVER_ERR_BASE + 6)	// End of the list
#define SFERR_DEVICE_NACK			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 7)	// Device NACK received
#define SFERR_INVALID_STRUCT_SIZE 	DIERR_INVALIDPARAM						// Invalid structure passed
#define SFERR_EFFECT_NOT_IN_DEVICE 	DIERR_NOTDOWNLOADED					// Effect was not downloaded, so
																			// cannot unload.
#define SFERR_RAW_OUT_DATAEVENT_CREATION 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 10)	// Could not create Event
#define SFERR_RAW_OUT_THREAD_CREATION 		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 11)	// Could not create a thread
#define SFERR_EFFECT_STATUS_BUSY DIERR_EFFECTPLAYING								// Device busy playing Effect
#define SFERR_OUT_OF_FF_MEMORY		DIERR_OUTOFMEMORY								// FF system has run out of memory
																					//  cannot create new Effect
#define SFERR_SYSTEM_INIT			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 14)	// Could not create SWForce
#define SFERR_DRIVER_ERROR      	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 15)  // Driver error detected
#define SFERR_NON_FF_DEVICE     	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 16)  // This is a non-FF device, driver not found
#define SFERR_INVALID_HAL_OBJECT 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 17)	// HAL cannot emulate this object
#define SFERR_INVALID_MEMBER_VALUE 	DIERR_INVALIDPARAM						// Data structure has invalid member value

// VFX_ error codes
#define VFX_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 100
#define VFX_ERR_FILE_NOT_FOUND				HRESULT_FROM_WIN32(MMIOERR_FILENOTFOUND)
#define VFX_ERR_FILE_OUT_OF_MEMORY			DIERR_OUTOFMEMORY
#define VFX_ERR_FILE_CANNOT_OPEN			HRESULT_FROM_WIN32(MMIOERR_CANNOTOPEN)
#define VFX_ERR_FILE_CANNOT_CLOSE			HRESULT_FROM_WIN32(MMIOERR_CANNOTCLOSE)
#define VFX_ERR_FILE_CANNOT_READ			HRESULT_FROM_WIN32(MMIOERR_CANNOTREAD)
#define VFX_ERR_FILE_CANNOT_WRITE			HRESULT_FROM_WIN32(MMIOERR_CANNOTWRITE)
#define VFX_ERR_FILE_CANNOT_SEEK			HRESULT_FROM_WIN32(MMIOERR_CANNOTSEEK)
#define VFX_ERR_FILE_UNKNOWN_ERROR			MAKE_FF_E(VFX_ERR_BASE + 8)
#define VFX_ERR_FILE_BAD_FORMAT				MAKE_FF_E(VFX_ERR_BASE + 9)
#define VFX_ERR_FILE_ACCESS_DENIED			HRESULT_FROM_WIN32(MMIOERR_ACCESSDENIED)
#define VFX_ERR_FILE_SHARING_VIOLATION		HRESULT_FROM_WIN32(MMIOERR_SHARINGVIOLATION)
#define VFX_ERR_FILE_NETWORK_ERROR			HRESULT_FROM_WIN32(MMIOERR_NETWORKERROR)
#define VFX_ERR_FILE_TOO_MANY_OPEN_FILES	HRESULT_FROM_WIN32(MMIOERR_TOOMANYOPENFILES)
#define VFX_ERR_FILE_INVALID				HRESULT_FROM_WIN32(MMIOERR_INVALIDFILE)
#define VFX_ERR_FILE_END_OF_FILE			MAKE_FF_E(VFX_ERR_BASE + 15)

// SideWinder Driver Error codes
#define SWDEV_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 200
#define SWDEV_ERR_INVALID_ID				MAKE_FF_E(SWDEV_ERR_BASE + 1)  // Invalid Download ID
#define SWDEV_ERR_INVALID_PARAM				MAKE_FF_E(SWDEV_ERR_BASE + 2)  // Invalid Download Parameter
#define SWDEV_ERR_CHECKSUM					MAKE_FF_E(SWDEV_ERR_BASE + 3)  // Invalid Checksum in COMM Packet
#define SWDEV_ERR_TYPE_FULL					MAKE_FF_E(SWDEV_ERR_BASE + 4)  // No More RAM space for Effect Type
#define SWDEV_ERR_UNKNOWN_CMD				MAKE_FF_E(SWDEV_ERR_BASE + 5)  // Unrecognized Device command
#define SWDEV_ERR_PLAYLIST_FULL				MAKE_FF_E(SWDEV_ERR_BASE + 6)  // Play List is full, cannot play any more Effects
#define SWDEV_ERR_PROCESSLIST_FULL			MAKE_FF_E(SWDEV_ERR_BASE + 7)  // Process List is full, cannot download 


#endif // of ifndef SW_Error_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_objec.hpp ===
/****************************************************************************

    MODULE:     	SW_Objec.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definition of the CDirectInputEffectDriver class that uses interface
					implementations to provide IDirectInputEffectDriver
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
				26-Feb-97	MEA		Added SetGain
				13-Mar-99	waltw	Deleted unused m_pJoltMidi and accessors

****************************************************************************/
#ifndef _SW_OBJEC_SEEN
#define _SW_OBJEC_SEEN

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include "dinput.h"
#include "dinputd.h"
#include "midi_obj.hpp"
#include "dx_map.hpp"


//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                 {\
                delete p;\
                p=NULL;\
                }\
            }

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID


/*
 * The object we want to provide in OLE supports the IUnknown,
 * IDirectInputEffectDriver interfaces.
 *
 * The C++ class, CDirectInputEffectDriver, implements these interfaces with
 * "interface implementations" where the C++ class itself inherits
 * from and implements IUnknown members and then contains
 * other C++ classes that each separately inherit from the other
 * interfaces.  The other classes are the "interface implementations."
 */


/*
 * In this technique you'll generally need forward references
 * like this for use in declaring the object class.
 */
class CImpIDirectInputEffectDriver;
typedef CImpIDirectInputEffectDriver *PCImpIDirectInputEffectDriver;

//The C++ class that manages the actual object.
class CDirectInputEffectDriver : public IUnknown
{
    /*
     * Usually interface implementations will need back pointers
     * to the object itself since this object usually manages
     * the important data members.  In that case, make the
     * interface implementation classes friends of the object.
     */

    friend CImpIDirectInputEffectDriver;

 protected:
 	ULONG           m_cRef;         //Object reference count
    LPUNKNOWN       m_pUnkOuter;    //Controlling unknown

    PFNDESTROYED    m_pfnDestroy;   //To call on closure

    /*
     * I use "m_pImpI" as a prefix to differentiate interface
     * implementations for this object from other interface
     * pointer variables I might hold to other objects, which
     * would be prefixed with "m_pI".
     */
    PCImpIDirectInputEffectDriver  m_pImpIDirectInputEffectDriver;

 public:
     CDirectInputEffectDriver(LPUNKNOWN, PFNDESTROYED);
     ~CDirectInputEffectDriver(void);

     BOOL Init(void);

     //IUnknown members
     STDMETHODIMP         QueryInterface(REFIID, PPVOID);
     STDMETHODIMP_(DWORD) AddRef(void);
     STDMETHODIMP_(DWORD) Release(void);
};


typedef CDirectInputEffectDriver *PCDirectInputEffectDriver;


/*
 * Interface implementation classes are C++ classes that
 * each singly inherit from an interface.  Their IUnknown
 * members delegate calls to CDirectInputEffectDriver's IUnknown members--
 * since IUnknown members affect the entire *object*, and
 * since these interfaces are not the object itself, we must
 * delegate to implement the correct behavior.
 */

class CImpIDirectInputEffectDriver : public IDirectInputEffectDriver
{
 private:
	DWORD		m_cRef;         //For debugging
	PCDirectInputEffectDriver	m_pObj;	//Back pointer for delegation

 public:
    CImpIDirectInputEffectDriver(PCDirectInputEffectDriver);
    ~CImpIDirectInputEffectDriver(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(DWORD) AddRef(void);
    STDMETHODIMP_(DWORD) Release(void);

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID);
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS);
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE);
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD);
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD);
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE);
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD);
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD);
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD);
};

#endif _SW_OBJEC_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_objec.cpp ===
/****************************************************************************

    MODULE:     	SW_OBJEC.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IUnknown Method(s) for DirectInputEffectDriver Class objects
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
				16-Mar-99	waltw	Moved CJoltMidi initialization from
									CDirectInputEffectDriver::Init to
									CImpIDirectInputEffectDriver::DeviceID

****************************************************************************/
#include "SW_objec.hpp"

//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif
extern HANDLE g_hSWFFDataMutex;



// ****************************************************************************
// *** --- Member functions for base class CDirectInputEffectDriver
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::CDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CDirectInputEffectDriver Object
// Parameters:  LPUNKNOWN 		pUnkOuter	 - Ptr to a controlling unknown.
//				PFNDESTROYED	pfnDestroy   - Call when object is destroyed.
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CDirectInputEffectDriver::CDirectInputEffectDriver(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy)
{
#ifdef _DEBUG
   	OutputDebugString("CDirectInputEffectDriver::CDirectInputEffectDriver()\r\n");
#endif

    m_cRef=0;

    m_pImpIDirectInputEffectDriver=NULL;
    m_pUnkOuter=pUnkOuter;
    m_pfnDestroy=pfnDestroy;
    return;
}

CDirectInputEffectDriver::~CDirectInputEffectDriver(void)
{
#ifdef _DEBUG
   	OutputDebugString("CDirectInputEffectDriver::~CDirectInputEffectDriver()\r\n");
#endif

//Delete the interface implementations created in Init
    DeleteInterfaceImp(m_pImpIDirectInputEffectDriver);
    return;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::Init
// Purpose:		Instantiates the interface implementations for this object.
// Parameters:  none
//				
// Returns:		BOOL	- TRUE if initialization succeeds, FALSE otherwise.
// Algorithm:
//
// Note:
//		Creating the interfaces means creating instances of
//		the interface implementation classes.  The constructor
//		parameters is a pointer to CDirectInputEffectDriver that has the
//		IUnknown functions to which the interface implementations
//		delegate.
//
// ----------------------------------------------------------------------------
BOOL CDirectInputEffectDriver::Init(void)
{
#ifdef _DEBUG
	OutputDebugString("CDirectInputEffectDriver::Init\n");
#endif

    m_pImpIDirectInputEffectDriver=new CImpIDirectInputEffectDriver(this);
    if (NULL==m_pImpIDirectInputEffectDriver)
		return FALSE;

	return TRUE;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::QueryInterface
// Purpose:		Manages the interfaces for this object which supports the
//				IUnknown, and IDirectInputEffectDriver interfaces.
//
// Parameters:  REFIID riid		- REFIID of the interface to return.
//				PPVOID ppv      - PPVOID in which to store the pointer.
//
//				
// Returns:		HRESULT         NOERROR on success, E_NOINTERFACE if the
//				                interface is not supported.
//
// Algorithm:
//
// Note:
//		IUnknown comes from CDirectInputEffectDriver.  Note that here and in
//		the lines below we do not need to explicitly typecast
//		the object pointers into interface pointers because
//		the vtables are identical.  If we had additional virtual
//		member functions in the object, we would have to cast
//		in order to set the right vtable.  This is demonstrated
//		in the multiple-inheritance version, CObject3.
//
// ----------------------------------------------------------------------------
STDMETHODIMP CDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
	//Always NULL the out-parameters
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    //Other interfaces come from interface implementations
    if (IID_IDirectInputEffectDriver==riid)
        *ppv=m_pImpIDirectInputEffectDriver;

    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::AddRef and CDirectInputEffectDriver::Release
// Purpose:		Reference counting members.  When Release sees a zero count
//				the object destroys itself.
//
// Parameters:  none
//				
// Returns:		DWORD	m_cRef value
//
// Algorithm:
//
// Note:
//
// ----------------------------------------------------------------------------
DWORD CDirectInputEffectDriver::AddRef(void)
{
	return ++m_cRef;
}

DWORD CDirectInputEffectDriver::Release(void)
{
    if (0!=--m_cRef) return m_cRef;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cfact.cpp ===
/****************************************************************************

    MODULE:     	SW_CFact.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Class Object structured in a DLL server.
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#include "SW_CFact.hpp"
#include "SWD_Guid.hpp"

#include <olectl.h>	// Self Reg errors

// Needed for auto registration
#include "Registry.h"
#include "CritSec.h"

// Define CriticalSection object for everyone
CriticalSection g_CriticalSection;

//
// Global Data
//
ULONG       g_cObj=0;	//Count number of objects and number of locks.
ULONG       g_cLock=0;
HINSTANCE	g_MyInstance = NULL;

//
// External Functions
//

//
// Internal Function Prototypes
//


//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif

#define BUFSIZE 80


/*
 * DllMain
 *
 * Purpose:
 *  Entry point provides the proper structure for each environment.
 */

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	switch (ulReason) {
		case DLL_PROCESS_ATTACH: {
			//
			// DLL is attaching to the address space of the current process.
			//
			g_MyInstance = hInstance;
#ifdef _DEBUG
			::OutputDebugString("sw_effct.dll: DLL_PROCESS_ATTACH\r\n");
#endif
			return TRUE;
		}

		case DLL_THREAD_ATTACH:
     	//
     	// A new thread is being created in the current process.
     	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_THREAD_ATTACH\r\n");
#endif
	   		break;

       	case DLL_THREAD_DETACH:
     	//
     	// A thread is exiting cleanly.
     	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_THREAD_DETACH\r\n");
#endif
     		break;

		case DLL_PROCESS_DETACH:
    	//
    	// The calling process is detaching the DLL from its address space.
    	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_PROCESS_DETACH\r\n");
#endif
			break;
	}
   return(TRUE);
}

// ----------------------------------------------------------------------------
// Function: 	DllRegisterServer
//
// Purpose:		Auto-magically puts default entries into registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	// Register CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_DirectInputEffectDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR fileName[MAX_PATH];
			DWORD nameSize = ::GetModuleFileName(g_MyInstance, fileName, MAX_PATH);
			if (nameSize > 0) {
				fileName[nameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)fileName, sizeof(fileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
		// NotInsertable ""
		RegistryKey notInsertableKey = driverKey.OpenCreateSubkey(TEXT("NotInsertable"));
		if (notInsertableKey != c_InvalidKey) {
			notInsertableKey.SetValue(NULL, (BYTE*)TEXT(""), sizeof(TEXT(""))/sizeof(TCHAR), REG_SZ);
		}
		// ProgID "Sidewinder ForceFeedback blah blah2.0"
		RegistryKey progIDKey = driverKey.OpenCreateSubkey(TEXT("ProgID"));
		if (progIDKey != c_InvalidKey) {
			progIDKey.SetValue(NULL, (BYTE*)PROGID_NAME, sizeof(PROGID_NAME)/sizeof(TCHAR), REG_SZ);
		}
		// VersionIndpendentProgID "Sidewinder ForceFeedback blah blah"
		RegistryKey progIDVersionlessKey = driverKey.OpenCreateSubkey(TEXT("VersionIndpendentProgID"));
		if (progIDVersionlessKey != c_InvalidKey) {
			progIDVersionlessKey.SetValue(NULL, (BYTE*)PROGID_NOVERSION_NAME, sizeof(PROGID_NOVERSION_NAME)/sizeof(TCHAR), REG_SZ);
		}
	} else {
		return SELFREG_E_CLASS;
	}

	// Made it here valid driver key
	return S_OK;
}

// ----------------------------------------------------------------------------
// Function: 	DllUnregisterServer
//
// Purpose:		Auto-magically removed default entries from registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hres = S_OK;
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
    
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	// driverKey Destructor will close the key
	// -- If the key is there get it, else we don't have to remove it
	RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_DirectInputEffectDriver_String);
	if (driverKey != c_InvalidKey) {	// Is it there
		driverKey.RemoveSubkey(TEXT("InProcServer32"));
		driverKey.RemoveSubkey(TEXT("NotInsertable"));
		driverKey.RemoveSubkey(TEXT("ProgID"));
		driverKey.RemoveSubkey(TEXT("VersionIndpendentProgID"));
	    if (driverKey.GetNumSubkeys() == 0) {
		    hres = clsidKey.RemoveSubkey(CLSID_DirectInputEffectDriver_String);
	    }
	} else {	
	    // Key is not there, count removal as a success
	}

	return hres;
}

// ----------------------------------------------------------------------------
// Function: 	DllGetClassObject
//
// Purpose:		Provides an IClassFactory for a given CLSID that this DLL is
//				registered to support.  This DLL is placed under the CLSID
//				in the registration database as the InProcServer.
//
// Parameters:  REFCLSID clsID	- REFCLSID that identifies the class factory
//                				  desired.  Since this parameter is passed this
//                				  DLL can handle any number of objects simply
//                				  by returning different class factories here
//                				  for different CLSIDs.
//
//				REFIID riid     - REFIID specifying the interface the caller 
//				                  wants on the class object, usually 
//								  IID_ClassFactory.
//
//				PPVOID ppv      - PPVOID in which to return the interface ptr.
//
// Returns:		HRESULT         NOERROR on success, otherwise an error code.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT             hr;
    CDirectInputEffectDriverClassFactory *pObj;

#ifdef _DEBUG
    OutputDebugString("sw_effct.dll: DllGetClassObject()\r\n");
#endif                 
    if (CLSID_DirectInputEffectDriver !=rclsid) return ResultFromScode(E_FAIL);

    pObj=new CDirectInputEffectDriverClassFactory();

    if (NULL==pObj) return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))	delete pObj;
    return hr;
}


// ----------------------------------------------------------------------------
// Function: 	DllCanUnloadNow
//
// Purpose:		Answers if the DLL can be freed, that is, if there are no
//				references to anything this DLL provides.
//				
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //Our answer is whether there are any object or locks
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


// ----------------------------------------------------------------------------
// Function: 	ObjectDestroyed
//
// Purpose:		Function for the DirectInputEffectDriver object to call when it gets destroyed.
//				Since we're in a DLL we only track the number of objects here,
//				letting DllCanUnloadNow take care of the rest.
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
void ObjectDestroyed(void)
{
    g_cObj--;
    return;
}


/*
 * CVIObjectClassFactory::CVIObjectClassFactory
 * CVIObjectClassFactory::~CVIObjectClassFactory
 *
 * Constructor Parameters:
 *  None
 */

CDirectInputEffectDriverClassFactory::CDirectInputEffectDriverClassFactory(void)
{
    m_cRef=0L;
    return;
}

CDirectInputEffectDriverClassFactory::~CDirectInputEffectDriverClassFactory(void)
{
    return;
}




/*
 * CDirectInputEffectDriverClassFactory::QueryInterface
 * CDirectInputEffectDriverClassFactory::AddRef
 * CDirectInputEffectDriverClassFactory::Release
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    	return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::Release(void)
{
    if (0L!=--m_cRef) return m_cRef;
    delete this;
    return 0L;
}

/*
 * CDirectInputEffectDriverClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a DirectInputEffectDriver object returning an interface pointer.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired
 *                  interface pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
 *                  if we cannot support the requested interface.
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, 
    REFIID riid, PPVOID ppvObj)
{
    PCDirectInputEffectDriver       pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    pObj=new CDirectInputEffectDriver(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj) return hr;

    if (pObj->Init()) hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))	
    	delete pObj;
    else
        g_cObj++;
    return hr;
}


/*
 * CDirectInputEffectDriverClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the DLL.  If the
 *  lock count goes to zero and there are no objects, the DLL
 *  is allowed to unload.  See DllCanUnloadNow.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */
STDMETHODIMP CDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
        g_cLock--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cimpi.cpp ===
/****************************************************************************

    MODULE:     	SW_CImpI.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IDEffect Implementation.
    
    Function(s):
					CImpIDirectInputEffectDriver::DeviceID
					CImpIDirectInputEffectDriver::GetVersions
    			    CImpIDirectInputEffectDriver::Escape
				    CImpIDirectInputEffectDriver::SetGain
    			    CImpIDirectInputEffectDriver::SendForceFeedbackCommand
    			    CImpIDirectInputEffectDriver::GetForceFeedbackState
    			    CImpIDirectInputEffectDriver::DownloadEffect
    			    CImpIDirectInputEffectDriver::DestroyEffect
    			    CImpIDirectInputEffectDriver::StartEffect
    			    CImpIDirectInputEffectDriver::StopEffect
    			    CImpIDirectInputEffectDriver::GetEffectStatus

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
  	1.0    	06-Feb-97   MEA     original, Based on SWForce
			23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
			23-Mar-97	MEA/DS	Added VFX support
			13-Mar-99	waltw	Deleted unused m_pJoltMidi and accessors
			15-Mar-99	waltw	Get version info from ntverp.h (was version.h)
			16-Mar-99	waltw	GetFirmwareParams, GetSystemParams,
								CMD_Download_RTCSpring, GetDelayParams,
								GetJoystickParams, & UpdateJoystickParams
								calls removed from DeviceID since they are
								called from g_pJoltMidi->Initialize.

****************************************************************************/
#include <windows.h>
#include <math.h>
#include <assert.h>
#include "dinput.h"
#include "dinputd.h"
#include "SW_objec.hpp"
#include "hau_midi.hpp"
#include "ffd_swff.hpp"
#include "FFDevice.h"
#include "ntverp.h"
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
#endif
extern CJoltMidi *g_pJoltMidi;





// ****************************************************************************
// *** --- Member functions for base class CImpIDirectInputEffectDriver Interface
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CImpIDirectInputEffectDriver Object
// Parameters:  PCDirectInputEffectDriver pObj	- Ptr to the outer object
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver(PCDirectInputEffectDriver pObj)
{
    m_cRef=0;
    m_pObj=pObj;
    return;
}

CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver(void)
{
#ifdef _DEBUG
	OutputDebugString("CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver()\n");
#endif
	// Destroy the CEffect object we created and release any interfaces
	if (g_pJoltMidi) 
	{
		delete g_pJoltMidi;
		g_pJoltMidi = NULL;
	}

#ifdef _DEBUG
		// No critical section here because g_SWFFCriticalSection already destroyed
		wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::~CimpIDEffect()\n");
		OutputDebugString(g_cMsg);
#endif
}

// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::QueryInterface
//				CImpIDirectInputEffectDriver::AddRef
//				CImpIDirectInputEffectDriver::Release
//
// Purpose:		IUnknown members that delegate to m_pObj
// Parameters:  
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
STDMETHODIMP CImpIDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
    return m_pObj->QueryInterface(riid, ppv);
}

DWORD CImpIDirectInputEffectDriver::AddRef(void)
{
//
//  We maintain an "interface reference count" for debugging
//  purposes, because the client of an object should match
//  AddRef and Release calls through each interface pointer.
//  
    ++m_cRef;
    return m_pObj->AddRef();
}

DWORD CImpIDirectInputEffectDriver::Release(void)
{
//	m_cRef is again only for debugging.  It doesn't affect
//	CSWEffect although the call to m_pObj->Release does.
	--m_cRef;
    return m_pObj->Release();
}


// ----------------------------------------------------------------------------
// Function:    DeviceID
//
// Purpose:     
// Parameters:  DWORD dwExternalID		-The joystick ID number being us
//				DWORD fBegin			-Nonzero if access to the device is beginning; Zero if ending
//				DWORD dwInternalID		-Internal joystick id
//				LPVOID lpReserved		-Reserved for future use (HID)
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DeviceID(
	IN DWORD dwDirectInputVersion,
    IN DWORD dwExternalID,
    IN DWORD fBegin,
    IN DWORD dwInternalID,
	LPVOID lpReserved)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::DeviceID(%lu, %lu, %lu, %lu, %lx)\n", dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, lpReserved);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	assert(NULL == g_pJoltMidi);
	
	// Create and Initialize our CJoltMidi object
#ifdef _DEBUG
	OutputDebugString("Creating and Initializing CJoltMidi object\n");
#endif
	g_pJoltMidi = new CJoltMidi();
	if (NULL == g_pJoltMidi)
	{
		return (E_OUTOFMEMORY);
	}
	else
	{
		return g_pJoltMidi->Initialize(dwExternalID);
	}
}


// ----------------------------------------------------------------------------
// Function:    GetVersions
//
// Purpose:     
// Parameters:  LPDIDRIVERVERSIONS pvers -Pointer to structure which receives version info
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetVersions(
	IN OUT LPDIDRIVERVERSIONS pvers)
{
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	LOCAL_PRODUCT_ID* pProductID = g_pJoltMidi->ProductIDPtrOf();
	if(pProductID == NULL)
		return E_FAIL;

	pvers->dwFirmwareRevision = (pProductID->dwFWMajVersion << 8) | (pProductID->dwFWMinVersion);
	pvers->dwHardwareRevision = pProductID->dwProductID;

	// Get version from ntverp.h (was FULLVersion from version.h)
	pvers->dwFFDriverVersion = VER_PRODUCTVERSION_DW;

#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::GetVersions(%lu, %lu, %lu)\n", pvers->dwFirmwareRevision, pvers->dwHardwareRevision, pvers->dwFFDriverVersion);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function:    Escape
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				LPDIEFFESCAPE pEsc	- Pointer to a DIFEFESCAPE struct
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::Escape(
    IN DWORD dwDeviceID,
	IN DWORD dwEffectID,
	IN OUT LPDIEFFESCAPE pEsc )
{
	HRESULT hRet = SUCCESS;
	return (hRet);
}


// ----------------------------------------------------------------------------
// Function:    SetGain
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwGain		- Device gain
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SetGain(
    IN DWORD dwDeviceID,
    IN DWORD dwGain)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SetGain: %s Gain=%ld\r\n", &szDeviceName, dwGain);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if ((dwGain <= 0) || (dwGain > MAX_GAIN)) return (SFERR_INVALID_PARAM);
	dwGain = dwGain / SCALE_GAIN;
	return(CMD_ModifyParamByIndex(INDEX15, SYSTEM_EFFECT_ID, (USHORT)(dwGain * MAX_SCALE)));
}

// ----------------------------------------------------------------------------
// Function:    SendForceFeedbackCommand
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwState		- Command to set Device state
//
//
// Returns:		SUCCESS or Error code
//
// Need to map the following DX to Jolt
// DS_FORCE_SHUTDOWN   0x00000001	// Actuators (Motors) are enabled.
// DS_FORCE_ON         0x00000002	// Actuators (Motors) are disabled.
// DS_FORCE_OFF        0x00000003	// All Effects are "Paused"
// DS_CONTINUE         0x00000004	// All "Paused" Effects are continued
// DS_PAUSE            0x00000005	// All Effects are stopped.
// DS_STOP_ALL         0x00000006	// All Effects destroyed,Motors disabled
//
//	Jolt Device ulMode:
//	SWDEV_SHUTDOWN 		1L			// All Effects destroyed, Motors disabled
//	SWDEV_FORCE_ON 		2L			// Motors enabled.  "Un-Mute"
//	SWDEV_FORCE_OFF		3L			// Motors disabled.	"Mute"
//	SWDEV_CONTINUE 		4L			// All "Paused" Effects are allow to continue
//	SWDEV_PAUSE	   		5L			// All Effects are "Paused"
//	SWDEV_STOP_ALL 		6L			// Stops all Effects.  
//   	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SendForceFeedbackCommand(
    IN DWORD dwDeviceID,
    IN DWORD dwState)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SendForceFeedbackCommand: %s State=%ld\r\n", &szDeviceName, dwState);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	HRESULT hRet = SUCCESS;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Convert to Jolt modes
	ULONG ulDeviceMode;
	switch(dwState)
	{
		case DISFFC_SETACTUATORSON:	
			ulDeviceMode = SWDEV_FORCE_ON;
			break;

		case DISFFC_SETACTUATORSOFF:
			ulDeviceMode = SWDEV_FORCE_OFF;
			break;

		case DISFFC_PAUSE:		
			ulDeviceMode = SWDEV_PAUSE;
			break;

		case DISFFC_CONTINUE:	
			ulDeviceMode = SWDEV_CONTINUE;
			break;

		case DISFFC_STOPALL:		
			ulDeviceMode = SWDEV_STOP_ALL;
			break;

		case DISFFC_RESET:		
			ulDeviceMode = SWDEV_SHUTDOWN;
			break;

		default:
			return (SFERR_INVALID_PARAM);
	}
	hRet = CMD_SetDeviceState(ulDeviceMode);
	if (SUCCESS == hRet)
		g_pJoltMidi->UpdateDeviceMode(ulDeviceMode);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    GetForceFeedbackState
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				LPDIDEVICESTATE pDeviceState	- Pointer to a DIDEVICESTATE struct
//
// Returns:		SUCCESS or Error code and state updated in pDeviceState
//
// Member: dwState
//		DS_FORCE_SHUTDOWN   	0x00000001
//		DS_FORCE_ON         	0x00000002
//		DS_FORCE_OFF        	0x00000003
//		DS_CONTINUE         	0x00000004
//		DS_PAUSE            	0x00000005
//		DS_STOP_ALL         	0x00000006
//
// Member: dwSwitches
//		DSW_ACTUATORSON         0x00000001
//		DSW_ACTUATORSOFF        0x00000002
//		DSW_POWERON             0x00000004
//		DSW_POWEROFF            0x00000008
//		DSW_SAFETYSWITCHON      0x00000010
//		DSW_SAFETYSWITCHOFF     0x00000020
//		DSW_USERFFSWITCHON      0x00000040
//		DSW_USERFFSWTTCHOFF     0x00000080
//
// Algorithm:
// This is the DI Device State structure
//typedef struct DIDEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
// This is the SideWinder State structure (copy kept in CJoltMidi object)
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetForceFeedbackState(
    IN DWORD dwDeviceID,
    IN LPDIDEVICESTATE pDeviceState)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "GetForceFeedbackState: %s\r\n", &szDeviceName[0]);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	assert(pDeviceState);
	if (NULL == pDeviceState) return (SFERR_INVALID_PARAM);
	assert(pDeviceState->dwSize == sizeof(DIDEVICESTATE));
	if (pDeviceState->dwSize != sizeof(DIDEVICESTATE) )return (SFERR_INVALID_STRUCT_SIZE);

	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 20)) {
		if ((g_pJoltMidi) && (g_pJoltMidi->GetSWDeviceStateNoUpdate().m_ForceState == SWDEV_FORCE_OFF)) {	// Echo state back to fix 1.20 bug
			CMD_SetDeviceState(SWDEV_FORCE_OFF);
		} else {
			CMD_SetDeviceState(SWDEV_FORCE_ON);
		}
	}

	// zero out the device state structure then pass to GetJoltStatus(LPDEVICESTATE)
	pDeviceState->dwState = 0;
	//pDeviceState->dwSwitches = 0;
	pDeviceState->dwLoad = 0;
   	HRESULT hRet = g_pJoltMidi->GetJoltStatus(pDeviceState);
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "dwState=%.8lx, dwLoad=%d\n",
		 pDeviceState->dwState, pDeviceState->dwLoad);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    DownloadEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				DWORD dwInternalEffectType	- Internal Effect Type
//				IN OUT LPDWORD pDnloadID	- Pointer to a DWORD for DnloadID
//				IN LPCDIEFFECT pEffect		- Pointer to a DIEFFECT structure
//				IN DWORD dwFlags			- for parameters that changed
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// The following dwFlags may be sent by the kernel
//
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Jolt has two options for downloading - Full SysEx or Modify Parameter
// Pass the dwFlags to each CMD_xxx function and let the MIDI function
// determine whether to use SysEx or Modify Parameter.
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DownloadEffect(
    IN DWORD dwDeviceID,
    IN DWORD dwInternalEffectType,
    IN OUT LPDWORD pDnloadID,
    IN LPCDIEFFECT pEffect,
	IN DWORD dwFlags)
{
	HRESULT hRet = SUCCESS;
	BOOL bTruncated = FALSE;	// TRUE if some effect parameters out of range

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DownloadEffect. DnloadID= %ld, Type=%lx, dwFlags= %lx\r\n",
   					&szDeviceName[0], *pDnloadID, dwInternalEffectType, dwFlags);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

	// Compute the Axis Mask equivalent
	int nAxes = pEffect->cAxes;
	if (nAxes > 2) return (SFERR_NO_SUPPORT);
	BYTE bAxisMask = 0;

	for (int i=0; i<nAxes; i++)
	{
		int nAxisNumber = DIDFT_GETINSTANCE(pEffect->rgdwAxes[i]);
		bAxisMask |= 1 << nAxisNumber;
	}

	// check to see if the X and Y axes were switched
	BOOL bAxesReversed = FALSE;
	if(nAxes == 2 && DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
		bAxesReversed = TRUE;

	// convert dwTriggerButton to a Button Mask
	ULONG ulButtonPlayMask = 0;
	if (pEffect->dwTriggerButton != -1)
	{	
		int nButtonNumber = DIDFT_GETINSTANCE(pEffect->dwTriggerButton);
		// map button 10 to button 9
		if(nButtonNumber == 9)
			nButtonNumber = 8;
		else if(nButtonNumber == 8)
			return SFERR_NO_SUPPORT;

		ulButtonPlayMask = 1 << nButtonNumber;
	}

	// Compute the Direction Angle
	ULONG nDirectionAngle2D, nDirectionAngle3D;
	nDirectionAngle3D = 0;

	if (pEffect->dwFlags & DIEFF_POLAR)
	{
		if (2 != nAxes) return (SFERR_INVALID_PARAM);
		nDirectionAngle2D = pEffect->rglDirection[0]/SCALE_DIRECTION;
	}
	//else if(pEffect->dwFlags & DIEFF_SPHERICAL)
	//{
	//	nDirectionAngle2D = (pEffect->rglDirection[0]/SCALE_DIRECTION + 90)%360;
	//}
	else	// Rectangular, so convert to Polar
	{
		// Special case 1D Effects
		if (1 == nAxes)
		{
			if (X_AXIS == (bAxisMask & X_AXIS)) 
				nDirectionAngle2D = 90;
			else
				nDirectionAngle2D = 0;
		}
		else
		{
			// get the x-component
			int nXComponent;
			if(bAxisMask & X_AXIS)
				nXComponent = pEffect->rglDirection[bAxesReversed ? 1 : 0];
			else
				nXComponent = 0;

			// get the y-component
			int nYComponent;
			if(bAxisMask & Y_AXIS)
			{
				if(bAxisMask & X_AXIS)
					nYComponent = -pEffect->rglDirection[bAxesReversed ? 0 : 1];
				else
					nYComponent = -pEffect->rglDirection[bAxesReversed ? 1 : 0];
			}
			else
				nYComponent = 0;

			// calculate the angle in degrees
			double lfAngle = atan2((double)nYComponent, (double)nXComponent)*180.0/3.14159;

			// convert it to our kind of angle
			int nAngle;
			if(lfAngle >= 0.0)
				nAngle = -(int)(lfAngle + 0.5) + 90;
			else
				nAngle = -(int)(lfAngle - 0.5) + 90;
			if(nAngle < 0)
				nAngle += 360;
			else if(nAngle >= 360)
				nAngle -= 360;
			nDirectionAngle2D = nAngle;
		}
	}
	
	// Scale the Duration, Gain
	ULONG ulDuration;
	if(pEffect->dwDuration == INFINITE)
		ulDuration = 0;
	else
		ulDuration = max(1, (ULONG) (pEffect->dwDuration/SCALE_TIME));
	ULONG ulGain = (ULONG) (pEffect->dwGain/SCALE_GAIN);
	ULONG ulAction = PLAY_STORE;

	int nSamples;
	
	// universal characteristics
	DWORD dwMagnitude;	// DX units
	LONG lOffset;		// DX units
	ULONG ulFrequency;	// SW units
	ULONG ulMaxLevel;

	// Create Jolt Behavior Effects
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;
	LPDICONDITION pDICondition;
	LPDICUSTOMFORCE pDICustomForce;
	LPDIENVELOPE pDIEnvelope;

	float T;
	PLONG pScaledForceData;

	// Note: HIWORD(dwInternalEffectType) = Major Type
	//		 LOWORD(dwInternalEffectType) = Minor Type
	// Decode the type of Download to use
	hRet = SFERR_INVALID_PARAM;
	ULONG ulType = HIWORD(dwInternalEffectType);
	ULONG ulSubType = LOWORD(dwInternalEffectType);
	
	// if this is a modify, make sure we are not trying to modify
	// parameters which are not modifiable
	BOOL bAttemptToModifyUnmodifiable = FALSE;
	if(*pDnloadID != 0)
	{
		// get a bitmask of the parameters that can be modified
		DWORD dwModifyCaps = 0;
		switch(ulType)
		{
			case EF_BEHAVIOR:
				switch(ulSubType)
				{
					case BE_WALL:
						dwModifyCaps = DIEP_DURATION | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
						break;
					default:
						// all other behavioral/condition effects
						dwModifyCaps = DIEP_DURATION | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
						break;
				}
				break;
			case EF_USER_DEFINED:
				// custom force
				dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION;
				break;
			case EF_ROM_EFFECT:
				dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE;
				break;
			case EF_SYNTHESIZED:
				switch(ulSubType)
				{
					case SE_CONSTANT_FORCE:
						dwModifyCaps = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
						break;
					default:
						dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
						break;
				}
				break;
			case EF_VFX_EFFECT:
				dwModifyCaps = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION;
				break;
			case EF_RAW_FORCE:
				dwModifyCaps = DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS;
				break;
			case EF_RTC_SPRING:
				dwModifyCaps = DIEP_TYPESPECIFICPARAMS;
				break;
			default:
				break;
		}

		// At this point dwModifyCaps is a bitmask of the parameters that can
		// be modified for this type of effect.

		// see if there are any bits set that correspond to parameters we cannot modify
		DWORD dwModifyFlags = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON
								| DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION
								| DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
		if(~dwModifyCaps & dwFlags & dwModifyFlags)
			bAttemptToModifyUnmodifiable = TRUE;

		// clear the bits in dwFlags that correspond to parameters we cannot modify
		dwFlags &= dwModifyCaps | ~dwModifyFlags;
	}

	// Map the common Effect parameters
	EFFECT effect = {sizeof(EFFECT)};
	effect.m_SubType = ulSubType;
	effect.m_AxisMask = (ULONG) bAxisMask;
	effect.m_DirectionAngle2D = nDirectionAngle2D;
	effect.m_DirectionAngle3D = 0;
	effect.m_Duration = ulDuration;
	effect.m_Gain = ulGain;
	effect.m_ButtonPlayMask = ulButtonPlayMask;

	ENVELOPE envelope = {sizeof(ENVELOPE)};
	SE_PARAM seParam = {sizeof(SE_PARAM)};

	switch (ulType)
	{
		case EF_BEHAVIOR:
			pDICondition = (LPDICONDITION) pEffect->lpvTypeSpecificParams;
			// Map the EFFECT Type
			effect.m_Type = EF_BEHAVIOR;

			// Because in DX 1D and 2D conditions have the same type, we must
			// convert to appropriate subtype depending on axis mask
			if(ulSubType != BE_WALL && ulSubType != BE_DELAY && bAxisMask == (X_AXIS|Y_AXIS))
			{
				ulSubType++;
				effect.m_SubType = ulSubType;
			}
			
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pDICondition[0].lPositiveCoefficient/SCALE_CONSTANTS;
						BE_xxx.m_YConstant = 0;
						BE_xxx.m_Param3 = pDICondition[0].lOffset/SCALE_POSITION;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pDICondition[0].lPositiveCoefficient/SCALE_CONSTANTS;
							BE_xxx.m_XConstant = 0;
							BE_xxx.m_Param4 = -pDICondition[0].lOffset/SCALE_POSITION;
							BE_xxx.m_Param3= 0;
						}
					}

					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damper
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;

					BE_xxx.m_XConstant = pDICondition[bAxesReversed ? 1 : 0].lPositiveCoefficient/SCALE_CONSTANTS;
					BE_xxx.m_YConstant = pDICondition[bAxesReversed ? 0 : 1].lPositiveCoefficient/SCALE_CONSTANTS;
					BE_xxx.m_Param3 = pDICondition[bAxesReversed ? 1 : 0].lOffset/SCALE_POSITION;
					BE_xxx.m_Param4 = -pDICondition[bAxesReversed ? 0 : 1].lOffset/SCALE_POSITION;
					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					// check for NULL typespecificparams
					if(pEffect->lpvTypeSpecificParams == NULL)
						return (SFERR_INVALID_PARAM);

					pBE_Wall = (PBE_WALL_PARAM) pEffect->lpvTypeSpecificParams;
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					// Range check params
					if (pBE_Wall->m_Bytes != sizeof(BE_WALL_PARAM))
						return (SFERR_INVALID_PARAM);
					if ((pBE_Wall->m_WallType != INNER_WALL) && (pBE_Wall->m_WallType != OUTER_WALL))
						return (SFERR_INVALID_PARAM);
					if ((pBE_Wall->m_WallConstant < MIN_CONSTANT) || (pBE_Wall->m_WallConstant > MAX_CONSTANT))
						return (SFERR_INVALID_PARAM);
					if (/*(pBE_Wall->m_WallDistance < 0) || */(pBE_Wall->m_WallDistance > MAX_POSITION))
						return (SFERR_INVALID_PARAM);

					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 9000)
						|| (pBE_Wall->m_WallAngle == 18000)
						|| (pBE_Wall->m_WallAngle == 27000) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant/SCALE_CONSTANTS;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle/SCALE_DIRECTION;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance/SCALE_POSITION;
						if(dwFlags & DIEP_NODOWNLOAD)
							return DI_DOWNLOADSKIPPED;
						hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						return SFERR_INVALID_PARAM;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_NOP_DELAY(ulDuration, &effect, (PDNHANDLE) pDnloadID);
					break;

				default:
					return SFERR_NO_SUPPORT;
			}
			break;

		case EF_USER_DEFINED:
		{
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_NO_SUPPORT;

			// check for an envelope (we do not support envelopes)
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			if(pDIEnvelope)
			{
				// try to be somewhat smart about not supporting envelopes
				if(pDIEnvelope->dwAttackTime != 0 && pDIEnvelope->dwAttackLevel != 10000
					|| pDIEnvelope->dwFadeTime != 0 && pDIEnvelope->dwFadeLevel != 10000)
				{
					return SFERR_NO_SUPPORT;
				}
			}

			// check for modifying type-specific (we do not support)
			if(*pDnloadID != 0 && (dwFlags & DIEP_TYPESPECIFICPARAMS))
				return SFERR_NO_SUPPORT;

			pDICustomForce = (LPDICUSTOMFORCE) pEffect->lpvTypeSpecificParams;
			if (pDICustomForce->cChannels > 1) return (SFERR_NO_SUPPORT);
			// Map the EFFECT type
			effect.m_Type = EF_USER_DEFINED;

			DWORD dwSamplePeriod = pDICustomForce->dwSamplePeriod;
			if (dwSamplePeriod == 0) {
				dwSamplePeriod = pEffect->dwSamplePeriod;
			}
			if (dwSamplePeriod == 0) {		// 0 indicates use default
				return SFERR_NO_SUPPORT;
			} else  {
				T = (float) ((dwSamplePeriod/(float)SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = (ULONG) ((float) 1.0/ T);
				if (0 == effect.m_ForceOutputRate) effect.m_ForceOutputRate = 1;
			}

			// Scale the Force values to +/-100
			nSamples = pDICustomForce->cSamples;
			pScaledForceData = new LONG[nSamples];
			if (NULL == pScaledForceData) return (SFERR_DRIVER_ERROR);

			for (i=0; i<nSamples; i++)
			{
				LONG lForceData = pDICustomForce->rglForceData[i];
				if(lForceData > DI_FFNOMINALMAX)
				{
					lForceData = DI_FFNOMINALMAX;
					bTruncated = TRUE;
				}
				else if(lForceData < -DI_FFNOMINALMAX)
				{
					lForceData = -DI_FFNOMINALMAX;
					bTruncated = TRUE;
				}
				pScaledForceData[i] = lForceData/SCALE_GAIN;
			}
			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;

			// give a short duration effect the shortest possible duration
			// that does not translate to zero, (which implies infinite duration)
			if(ulDuration == 1)
			{
				ulDuration = 2;
				effect.m_Duration = ulDuration;
			}

			hRet = CMD_Download_UD_Waveform(ulDuration, &effect, 
					pDICustomForce->cSamples,
					pScaledForceData, 
					ulAction, (PDNHANDLE) pDnloadID, dwFlags);
			delete [] pScaledForceData;
			break;
		}

		case EF_ROM_EFFECT:
			// Map the EFFECT type
			effect.m_Type = EF_ROM_EFFECT;

			// check for default output rate
			if(pEffect->dwSamplePeriod == DEFAULT_ROM_EFFECT_OUTPUTRATE) {
				// signal default output rate by setting to -1
				effect.m_ForceOutputRate = (ULONG)-1;
			} else if (pEffect->dwSamplePeriod == 0) {
				effect.m_ForceOutputRate = 100;
			} else {
				T = (float) ((pEffect->dwSamplePeriod/SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = max(1, (ULONG) ((float) 1.0/ T));
			}

			// check for default duration
			if(pEffect->dwDuration == DEFAULT_ROM_EFFECT_DURATION)
			{
				// signal default duration by setting to -1
				ulDuration = (ULONG)-1;
				effect.m_Duration = ulDuration;
			}

			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(&effect))
				return (SFERR_INVALID_OBJECT);

			// update the duration if it was changed in SetupROM_Fx(...)
			ulDuration = effect.m_Duration;
			
			// Map the Envelope
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			dwMagnitude = 10000;
			ulMaxLevel = dwMagnitude;
			MapEnvelope(ulDuration, dwMagnitude, &ulMaxLevel, pDIEnvelope, &envelope);

			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;		// unused by ROM Effect
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;

			// set the sample rate
			seParam.m_SampleRate = effect.m_ForceOutputRate;

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_SYNTH(&effect, &envelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);			
			break;
			

		case EF_SYNTHESIZED:
		{
			// Map the EFFECT type
			effect.m_Type = EF_SYNTHESIZED;

			// treat constant force as a special case
			int nConstantForceSign = 1;

			if(ulSubType == SE_CONSTANT_FORCE)
			{
				// cast the type-specific parameters to constant force type
				LPDICONSTANTFORCE pDIConstantForce = (LPDICONSTANTFORCE) pEffect->lpvTypeSpecificParams;

				// see if this is the special case of negative constant force
				if(pDIConstantForce->lMagnitude < 0)
					nConstantForceSign = -1;

				// find the magnitude, offset, and frequency
				dwMagnitude = abs(pDIConstantForce->lMagnitude);
				lOffset = 0;
				ulFrequency = 1;
			}
			else if(ulSubType == SE_RAMPUP)
			{
				// cast the type-specific parameters to ramp type
				LPDIRAMPFORCE pDIRampForce = (LPDIRAMPFORCE) pEffect->lpvTypeSpecificParams;

				// temporary variables
				int nStart = pDIRampForce->lStart;
				int nEnd = pDIRampForce->lEnd;

				// map the subtype based on direction of ramp
				if(nEnd < nStart)
				{
					ulSubType = SE_RAMPDOWN;
					effect.m_SubType = ulSubType;
				}

				// find magnitude, offset, and frequency
				dwMagnitude = abs(nStart - nEnd)/2;
				lOffset = (nStart + nEnd)/2;
				ulFrequency = 1;
			}
			else
			{
				// cast the type-specific parameters to periodic type
				LPDIPERIODIC pDIPeriodic = (LPDIPERIODIC) pEffect->lpvTypeSpecificParams;

				// map the subtype based on the phase
				DWORD dwPhase = pDIPeriodic->dwPhase;
				if(dwPhase != 0)
				{
					if(ulSubType == SE_SINE && dwPhase == 9000)
					{
						ulSubType = SE_COSINE;
						effect.m_SubType = ulSubType;
					}
					else if(ulSubType == SE_SQUAREHIGH && dwPhase == 18000)
					{
						ulSubType = SE_SQUARELOW;
						effect.m_SubType = ulSubType;
					}
					else if(ulSubType == SE_TRIANGLEUP && dwPhase == 18000)
					{
						ulSubType = SE_TRIANGLEDOWN;
						effect.m_SubType = ulSubType;
					}
					else
						return SFERR_NO_SUPPORT;
				}
				// find magnitude, offset, and frequency
				dwMagnitude = pDIPeriodic->dwMagnitude;
				lOffset = pDIPeriodic->lOffset;
				T = (float) ((pDIPeriodic->dwPeriod/SCALE_TIME)/1000.);
				ulFrequency = max(1, (ULONG) ((float) 1.0/ T));
			}

			if (pEffect->dwSamplePeriod)
			{
				T = (float) ((pEffect->dwSamplePeriod/SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = max(1, (ULONG) ((float) 1.0/ T));
			}
			else
				effect.m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;
			
			// Map the SE_PARAM
			// set the frequency and Sample rate
			seParam.m_Freq = ulFrequency;
			seParam.m_SampleRate = DEFAULT_JOLT_FORCE_RATE;

			// see if the offset is out of range
			if(lOffset > DI_FFNOMINALMAX)
			{
				lOffset = DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}
			else if(lOffset < -DI_FFNOMINALMAX)
			{
				lOffset = -DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}

			// see if the magnitude is out of range
			DWORD dwPeak = abs(lOffset) + dwMagnitude;
			if(dwPeak > DI_FFNOMINALMAX)
			{
				dwMagnitude -= dwPeak - DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}
			
			// MaxLevel is the peak magnitude throughout attack/sustain/decay
			ulMaxLevel = dwMagnitude;

			// Map the Envelope
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			MapEnvelope(ulDuration, dwMagnitude, &ulMaxLevel, pDIEnvelope, &envelope);

			// use MaxLevel and Offset to find MinAmp/MaxAmp
			if(ulSubType == SE_CONSTANT_FORCE)
			{
				// constant force is a special case
				seParam.m_MaxAmp = nConstantForceSign*((int)ulMaxLevel + lOffset)/SCALE_GAIN;
				seParam.m_MinAmp = 0;
			}
			else
			{
				seParam.m_MinAmp = (-(int)ulMaxLevel + lOffset)/SCALE_GAIN;
				seParam.m_MaxAmp = ((int)ulMaxLevel + lOffset)/SCALE_GAIN;
			}

			if(*pDnloadID == 0 && (dwFlags & DIEP_NODOWNLOAD))
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_SYNTH(&effect, &envelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);
			break;
		}

		case EF_VFX_EFFECT:
		{
			PVFX_PARAM pVFXParam = (PVFX_PARAM)pEffect->lpvTypeSpecificParams;

			// parameter checking
			if(pVFXParam == NULL)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_Bytes != sizeof(VFX_PARAM))
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_PointerType != VFX_FILENAME && pVFXParam->m_PointerType != VFX_BUFFER)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_PointerType == VFX_BUFFER && pVFXParam->m_BufferSize == 0)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_pFileNameOrBuffer == NULL)
				return (SFERR_INVALID_PARAM);

			// check for modifying type-specific (we do not support)
			if(*pDnloadID != 0 && (dwFlags & DIEP_TYPESPECIFICPARAMS))
				return SFERR_NO_SUPPORT;

			// check for default duration
			if(pEffect->dwDuration == DEFAULT_VFX_EFFECT_DURATION)
			{
				// signal default duration by setting duration to -1
				ulDuration = (ULONG)-1;
				effect.m_Duration = ulDuration;
			}


			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_VFX(&effect, NULL, pVFXParam, ulAction, (USHORT*)pDnloadID, dwFlags);

			break;
		}

		case EF_RAW_FORCE:
		{
			// cast the type-specific parameters to constant force type
			LPDICONSTANTFORCE pDIConstantForce = (LPDICONSTANTFORCE) pEffect->lpvTypeSpecificParams;
			if(pDIConstantForce == NULL)
				return SFERR_INVALID_PARAM;
			LONG nForceValue = pDIConstantForce->lMagnitude/SCALE_GAIN;
			if(nForceValue > 100 || nForceValue < -100)
				return SFERR_INVALID_PARAM;

			// translate to a FORCE structure
			FORCE force;
			force.m_Bytes = sizeof(FORCE);
			force.m_AxisMask = (ULONG)bAxisMask;
			force.m_DirectionAngle2D = nDirectionAngle2D;
			force.m_DirectionAngle3D = 0;
			force.m_ForceValue = nForceValue;

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = FFD_PutRawForce(&force);
			if(!FAILED(hRet))
				*pDnloadID = SYSTEM_EFFECT_ID;

			break;
		}

		case EF_RTC_SPRING:
		{
			PRTCSPRING_PARAM pRTCSpringParam = (PRTCSPRING_PARAM)pEffect->lpvTypeSpecificParams;
			RTCSPRING_PARAM RTCSpringParam;


			// Parameter validate
			if (pRTCSpringParam == NULL)
				return SFERR_INVALID_PARAM;

			if (pRTCSpringParam->m_Bytes != sizeof(RTCSPRING_PARAM))
				return SFERR_INVALID_PARAM;

			if ((pRTCSpringParam->m_XKConstant < MIN_CONSTANT) 
				|| (pRTCSpringParam->m_XKConstant > MAX_CONSTANT))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YKConstant < MIN_CONSTANT) 
				|| (pRTCSpringParam->m_YKConstant > MAX_CONSTANT))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XAxisCenter < MIN_POSITION) 
				|| (pRTCSpringParam->m_XAxisCenter > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YAxisCenter < MIN_POSITION) 
				|| (pRTCSpringParam->m_YAxisCenter > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XSaturation < MIN_POSITION) 
				|| (pRTCSpringParam->m_XSaturation > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YSaturation < MIN_POSITION) 
				|| (pRTCSpringParam->m_YSaturation > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XDeadBand < MIN_POSITION) 
				|| (pRTCSpringParam->m_XDeadBand > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YDeadBand < MIN_POSITION) 
				|| (pRTCSpringParam->m_YDeadBand > MAX_POSITION))
				return (SFERR_INVALID_PARAM);

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;

			// Scale to Jolt numbers
			RTCSpringParam.m_XKConstant  =  pRTCSpringParam->m_XKConstant/SCALE_CONSTANTS;
			RTCSpringParam.m_YKConstant  =  pRTCSpringParam->m_YKConstant/SCALE_CONSTANTS;
			RTCSpringParam.m_XAxisCenter =  pRTCSpringParam->m_XAxisCenter/SCALE_POSITION;
			RTCSpringParam.m_YAxisCenter = -pRTCSpringParam->m_YAxisCenter/SCALE_POSITION;
			RTCSpringParam.m_XSaturation =  pRTCSpringParam->m_XSaturation/SCALE_POSITION;
			RTCSpringParam.m_YSaturation =  pRTCSpringParam->m_YSaturation/SCALE_POSITION;
			RTCSpringParam.m_XDeadBand   =  pRTCSpringParam->m_XDeadBand/SCALE_POSITION;
			RTCSpringParam.m_YDeadBand   =  pRTCSpringParam->m_YDeadBand/SCALE_POSITION;

			hRet = CMD_Download_RTCSpring(&RTCSpringParam, (USHORT*)pDnloadID);
			*pDnloadID = SYSTEM_RTCSPRING_ALIAS_ID;		// Jolt returns ID0 for RTC Spring
														// so return an alias to that
			break;
		}

		default:
			hRet = SFERR_INVALID_PARAM;
	}
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "DownloadEffect. DnloadID = %ld, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// after successful download, check to see if kernel told us to start/restart effect
	if(!FAILED(hRet) && *pDnloadID != 0 && (dwFlags & DIEP_START))
	{
		hRet = CMD_StopEffect((USHORT)*pDnloadID);
		if(FAILED(hRet)) return hRet;
		hRet = CMD_PlayEffectSuperimpose((USHORT)*pDnloadID);
	}

	if(!FAILED(hRet) && bTruncated)
		return DI_TRUNCATED;
	else if(!FAILED(hRet) && bAttemptToModifyUnmodifiable)
		return S_FALSE;
	else
		return (hRet);
}


// ----------------------------------------------------------------------------
// Function:    DestroyEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to destroy
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DestroyEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DestroyEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// Note: Cannot allow actually destroying the SYSTEM Effects
	// so either fake it, or stop the System Effect.
	if (SYSTEM_FRICTIONCANCEL_ID == DnloadID)
		return SUCCESS;

	// Note: SYSTEM_EFFECT_ID is used for PutRawForce
	if (   (SYSTEM_EFFECT_ID == DnloadID)
		|| (SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		|| (SYSTEM_RTCSPRING_ID == DnloadID))
	{
		return (StopEffect(dwDeviceID, SYSTEM_EFFECT_ID));
	}

	return(CMD_DestroyEffect((DNHANDLE) DnloadID));
}

// ----------------------------------------------------------------------------
// Function:    StartEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Start
//				DWORD dwMode		- Playback mode
//				DWORD dwCount		- Loop count
//
//
// Returns:		SUCCESS or Error code
//
//  dwMode: Playback mode is available with the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StartEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    IN DWORD dwMode,
    IN DWORD dwCount)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StartEffect. DnloadID:%ld, Mode:%lx, Count:%lx\r\n",
   			  &szDeviceName[0], DnloadID, dwMode, dwCount);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// special case for raw force
	if(SYSTEM_EFFECT_ID == DnloadID)
	{
		// start has no meaning for raw force
		return S_FALSE;
	}

	// Special case RTC Spring ID
	if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID

	HRESULT hRet = SUCCESS;
	// Don't support PLAY_LOOP for this version
	if (dwCount != 1) 	return (SFERR_NO_SUPPORT);
	// Is it PLAY_SOLO?
	if (dwMode & DIES_SOLO)
	{
		hRet = CMD_PlayEffectSolo((DNHANDLE) DnloadID);
	}
	else
	{
		hRet = CMD_PlayEffectSuperimpose((DNHANDLE) DnloadID);
	}
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    StopEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Stop
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StopEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StopEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// special case for putrawforce
	if(SYSTEM_EFFECT_ID == DnloadID)
	{
		// stop has no meaning for raw force
		return S_FALSE;
	}
	else
	{
	// Special case RTC Spring ID
		if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
			DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID
	}
	return (CMD_StopEffect((DNHANDLE) DnloadID));
}

// ----------------------------------------------------------------------------
// Function:    GetEffectStatus
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	-	 Device ID
//				DWORD DnloadID			- Download ID to get Status
//				LPDWORD pdwStatusCode	- Pointer to a DWORD for Status
//
//
// Returns:		SUCCESS or Error code
//				Status Code: DEV_STS_EFFECT_STOPPED
//							 DEV_STS_EFFECT_RUNNING
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetEffectStatus(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    OUT LPDWORD pdwStatusCode)
{
	HRESULT hRet = SUCCESS;
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "GetEffectStatus, DnloadID=%d\r\n", DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

// Special case RTC Spring ID
	if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID	
	assert(pdwStatusCode);
	BYTE bStatusCode = SWDEV_STS_EFFECT_STOPPED;

	hRet = g_pJoltMidi->GetEffectStatus(DnloadID, &bStatusCode);
	if (SUCCESS != hRet) return hRet;
	if (SWDEV_STS_EFFECT_RUNNING == bStatusCode) 
		*pdwStatusCode = DIEGES_PLAYING;
	else
		*pdwStatusCode = NULL;	// Stopped

	return (hRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\vxdioctl.hpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.HPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header file for VXDIOCTL.CPP
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL	
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				20-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!

****************************************************************************/
#ifndef __VXDIOCTL_HPP__
#define __VXDIOCTL_HPP__

#include <windows.h>
#include "FFeature.h"

#ifndef override
#define override
#endif

//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

//--------------------- Host converted Channel ID Structure -----------------
struct LOCAL_PRODUCT_ID {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
};

// Bitmasks for Response Status - 1.xx (we don't support version 1 - informational only)
//#define STATUS_GATE_1XX			0x08
//#define RUNNING_MASK_1XX			0x04
//#define ACKNACK_MASK_1XX			0x02
//#define SCLK_MASK_1XX				0x01

// Bitmasks for Response Status - Version 2
#define STATUS_GATE_200				0x80
#define RUNNING_MASK_200			0x40
#define ACKNACK_MASK_200			0x20
#define SCLK_MASK_200				0x10

/************************************************************************
**
**	@class DriverCommunicator |
**		This is the interface for driver communications
**
*************************************************************************/
class DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DriverCommunicator() {};
		//@cmember destructor
		virtual ~DriverCommunicator() {};

		virtual HRESULT ResetDevice() { return E_NOTIMPL; }
		virtual HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor) { return E_NOTIMPL; }
		virtual HRESULT GetID(LOCAL_PRODUCT_ID& rProductID) { return E_NOTIMPL; }
		virtual HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus) { return E_NOTIMPL; }
		virtual HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex) { return E_NOTIMPL; }
		virtual HRESULT GetStatusGateData(DWORD& dwGateData) { return E_NOTIMPL; }
		virtual HRESULT SetBackdoorPort(ULONG ulPortAddress) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoorShortMidi(DWORD dwMidiMessage) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoorLongMidi(BYTE* pMidiData) { return E_NOTIMPL; }
};


/************************************************************************
**
**	@class HIDFeatureCommunicator |
**		Communicates with the HID driver via HID Features (NT5)
**
*************************************************************************/
class HIDFeatureCommunicator :
	public DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		HIDFeatureCommunicator();
		//@cmember destructor
		override ~HIDFeatureCommunicator();

		BOOL Initialize(UINT uJoystickId);
		override HRESULT ResetDevice();
		override HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor);
		override HRESULT GetID(LOCAL_PRODUCT_ID& rProductID);
		override HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus);
		override HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex);
		override HRESULT GetStatusGateData(DWORD& rdwGateData);
		override HRESULT SendBackdoorShortMidi(DWORD dwMidiMessage);
		override HRESULT SendBackdoorLongMidi(BYTE* pMidiData);
	//@access Private Data Members
	private:
		CForceFeatures m_ForceFeature;
};


extern DriverCommunicator* g_pDriverCommunicator;

/********************************** Old dead code ***********************************/
#if 0
#define NT_VXD
#ifdef NT_VXD
// REVIEW: swforce.sys should use _JOYCHANNELID instead of _PRODUCT_ID
#define _PRODUCT_ID _JOYCHANNELID
#define PRODUCT_ID JOYCHANNELID
#define PPRODUCT_ID PJOYCHANNELID
#include "swforce.h"
#undef _PRODUCT_ID
#undef PRODUCT_ID
#undef PPRODUCT_ID
#endif

#define IOCTL_OPEN               	0
#define IOCTL_GET_DRIVERVERSION		1
#define IOCTL_GET_DATAPACKET  		2
#define IOCTL_GET_STATUSPACKET 		3
#define IOCTL_GET_IDPACKET 	   		4
#define IOCTL_GET_DIAGNOSTICS		5
#define IOCTL_MIDISENDSHORTMSG   	6
#define IOCTL_GET_ACKNACK			7
#define IOCTL_SET_MIDIPORT			8
#define IOCTL_MIDISENDLONGMSG		9
#define	IOCTL_HW_RESET				10

#define	COMM_DEFAULT_MIDI_PORT		0
#define COMM_COM1					1
#define COMM_COM2					2
#define COMM_COM3					3
#define COMM_COM4					4
#define COMM_MIDI300				0x300


//----------------------- Joystick Diagnostics Counters Data Structure ---
typedef struct _DIAGNOSTIC_COUNTER {
	DWORD	cBytes;
	DWORD	DataFailCount;			// GetData
	DWORD	StatusFailCount;		// GetStatus
	DWORD	IDFailCount;			// GetID
	DWORD	AckNackFailCount;		// Get Ack/Nack
	DWORD	DataPacketCount;		
	DWORD	StatusPacketCount;
	DWORD	IDPacketCount;
	DWORD	AckNackPacketCount;
	DWORD	TotalPktFails;

} DIAGNOSTIC_COUNTER, *PDIAGNOSTIC_COUNTER;


//--------------------- Joystick Channel Data Structure --------------------
typedef struct _JOYCHANNELDATA {
	DWORD	cBytes;
	DWORD	dwXAxis;
	DWORD	dwYAxis;
	DWORD	dwThrottle;
	DWORD	dwRudder;
	DWORD	dwHatSwitch;
	DWORD	dwButtons;
} JOYCHANNELDATA,   *PJOYCHANNELDATA;

//--------------------- Joystick Channel Status Structure --------------------
#ifndef NT_VXD
typedef struct _JOYCHANNELSTATUS {
	DWORD	cBytes;
	LONG	dwXVel;
	LONG	dwYVel;
	LONG	dwXAccel;
	LONG	dwYAccel;
	DWORD	dwDeviceStatus;
} JOYCHANNELSTATUS, *PJOYCHANNELSTATUS;
#endif !NT_VXD

//--------------------- Joystick Channel ID Structure -----------------------
#ifndef NT_VXD
typedef struct _JOYCHANNELID  {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWVersion;
} JOYCHANNELID, *PJOYCHANNELID;
#endif !NT_VXD

//--------------------- Host converted Channel ID Structure -----------------
typedef struct _PRODUCT_ID  {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
} PRODUCT_ID, *PPRODUCT_ID;


//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;


//
// --- IOCTL interface to Digital OverDrive mini-driver ---------------------
//
HANDLE WINAPI GetDevice(
	IN const char* vxdName);

BOOL WINAPI CloseDevice(
	IN HANDLE hVxD);


HRESULT QueryDriverVersion(DWORD& major, DWORD& minor);

HRESULT WINAPI GetDataPacket(
	IN HANDLE hDevice,
	IN OUT PJOYCHANNELDATA pDataPacket);

HRESULT WINAPI GetStatusPacket(
	IN HANDLE hDevice, 
	IN OUT PJOYCHANNELSTATUS pStatusPacket);

HRESULT WINAPI GetIDPacket(
	IN HANDLE hDevice, 
	IN OUT PPRODUCT_ID pID);

HRESULT WINAPI GetDiagnostics(
	IN HANDLE hDevice, 
	IN OUT PDIAGNOSTIC_COUNTER pDiagnostics);

HRESULT WINAPI GetAckNack(
	IN HANDLE hDevice,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex);

HRESULT WINAPI GetStatusGateData(
	IN HANDLE hDevice,
	IN OUT DWORD *pdwStatusGateData);

HRESULT WINAPI SendBackDoorShortMidi(
	IN HANDLE hDevice,
	IN ULONG ulData);

HRESULT WINAPI SendBackDoorLongMidi(
	IN HANDLE hDevice,
	IN PBYTE pData);

HRESULT WINAPI SetMidiPort(
	IN HANDLE hDevice,
	IN ULONG  ulPort);

HRESULT WINAPI JoltHWReset(
	IN HANDLE hDevice);

#endif
#endif __VXDIOCTL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\critsec.h ===
//@doc
/******************************************************
**
** @module CRITSEC.H | Header file for CriticalSection class
**
** Description:
**		Critical Section - Encapsulation of CriticalSection object
**
** History:
**	Created 03/02/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__CRITSEC_H__
#define	__CRITSEC_H__

#include <winbase.h>
#include <winuser.h>
#include <crtdbg.h>

// Assumption macros (I don't like asserts msg boxes)
#ifdef _DEBUG
	inline void myassume(BOOL condition, const char* fname, int line)
	{
		if (!condition) {
			char buff[256];
			::wsprintf(buff, "SW_WHEEL.DLL: Assumption Failed in %s on line %d\r\n", fname, line);
			_RPT0(_CRT_WARN, buff);
		}
	}

	#define ASSUME(x) myassume(x, __FILE__, __LINE__);
	#define ASSUME_NOT_NULL(x) myassume(x != NULL, __FILE__, __LINE__);
	#define ASSUME_NOT_REACHED() myassume(FALSE, __FILE__, __LINE__);
#else	!_DEBUG
	#define ASSUME(x)
	#define ASSUME_NOT_NULL(x)
	#define ASSUME_NOT_REACHED()
#endif _DEBUG

//
// @class CriticalSection class
//
class CriticalSection
{
	public:
		CriticalSection() : m_EntryDepth(0)
		{
			__try
			{
				::InitializeCriticalSection(&m_OSCriticalSection); 
				m_Initialized = TRUE;
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				m_Initialized = FALSE;
			}
		}
		~CriticalSection() {
			ASSUME(m_EntryDepth == 0);
			::DeleteCriticalSection(&m_OSCriticalSection);
		}

		bool IsInitialized() const
		{
			if (m_Initialized == TRUE)
			{
				return true;
			}
			return false;
		}

		bool Enter() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			m_EntryDepth++;
			::EnterCriticalSection(&m_OSCriticalSection);
			return true;
		}

		bool Leave() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			ASSUME(m_EntryDepth > 0);
			m_EntryDepth--;
			::LeaveCriticalSection(&m_OSCriticalSection);
			return true;
		}

/*	-- Windows NT Only
		BOOL TryEntry() {
			if (::TryEnterCriticalSection(&m_OSCriticalSection) != 0) {
				m_EntryDepth++;
				return TRUE;
			}
			return FALSE;
		}

		BOOL WaitEntry(short timeOut, BOOL doSleep) {
			// right now timeout is just a loop (since it is not being used anyways)
			while(1) {
				if (TryEntry()) { return TRUE; }
				if (--timeOut > 0) {
					if (doSleep) { ::Sleep(0); }
				} else {
					return FALSE;
				}
			}
		}
 -- Windows NT Only */
	private:
		CriticalSection& operator=(CriticalSection& rhs);	// Cannot be copied

		CRITICAL_SECTION m_OSCriticalSection;
		short m_EntryDepth;
		short m_Initialized;
};
extern CriticalSection g_CriticalSection;

//
// @class CriticalLock class
//
// Critical lock is usefor functions with multiple-exit points. Create a stack CriticalLock
// -- object and everything is taken care of for you when it's lifetime ends.
class CriticalLock
{
	public:
		CriticalLock() { g_CriticalSection.Enter(); }
		~CriticalLock() { g_CriticalSection.Leave(); }
};

#endif	__CRITSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dtrans.cpp ===
//@doc
/******************************************************
**
** @module DTRANS.CPP | DataTransmitter implementation file
**
** Description:
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
**	21-Mar-99	waltw	Removed unused ReportTransmission (Win9x only)
**	22-Mar-99	waltw	Added DWORD dwDeviceID param to Initialize
**						members of DataTransmitter and derived classes
**
** (c) 1986-1999 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "FFDevice.h"
#include "DTrans.h"
#include "DPack.h"
#include "WinIOCTL.h"	// For IOCTLs
#include "VxDIOCTL.hpp"
#include "SW_error.hpp"
#include "midi_obj.hpp"
#include "joyregst.hpp"
#include "CritSec.h"

DataTransmitter* g_pDataTransmitter = NULL;

extern CJoltMidi *g_pJoltMidi;

#ifdef _DEBUG
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

const char cCommPortNames[4][5] = { "COM1", "COM2", "COM3", "COM4" };
const unsigned short c1_16_BytesPerShot = 3;
const DWORD c1_16_SerialSleepTime = 1;

/****************** DataTransmitter class ***************/
HRESULT DataTransmitter::Transmit(ACKNACK& ackNack)
{
	ackNack.cBytes = 0;	// Indicated not valid (ack/nack not done)

	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	BOOL forcedToggle = FALSE;
	if (m_NackToggle == 2) {	// When Not yet sunk up == 2, probably initializing if 2 (synch up)
		ULONG portByte = 0;
		g_pDriverCommunicator->GetPortByte(portByte); // don't care about success, always fails on old driver
		if (portByte & STATUS_GATE_200) {
			SetNextNack(1);
		} else {
			SetNextNack(0);
		}
		forcedToggle = TRUE;
	}

	DataPacket* pNextPacket = NULL;
	for (USHORT packetIndex = 0; packetIndex < g_pDataPackager->GetNumDataPackets();  packetIndex++) {
		pNextPacket = g_pDataPackager->GetPacket(packetIndex);
		ASSUME_NOT_NULL(pNextPacket);
		if (pNextPacket == NULL) {
			return SFERR_DRIVER_ERROR;
		}
		BOOL success = FALSE;
		int retries = int(pNextPacket->m_NumberOfRetries);
		do {
			m_NackToggle = (m_NackToggle + 1) % 2;	// Verions 2.0 switches button-line ack/nack methods each time
			ULONG portByte = 0;
			BOOL error = FALSE;
			if (g_pDriverCommunicator->GetPortByte(portByte) == SUCCESS) {	// Will fail on old driver
				if (portByte & STATUS_GATE_200) {	// Line is high
					if (m_NackToggle != 0) { // We should be expecting low
						m_NackToggle = 0;		// Update it if wrong
						error = TRUE;
						DebugOut("SW_WHEEL.DLL: Status Gate is out of Synch (High - Expecting Low)!!!\r\n");
					}
				} else {	// Line is low
					if (m_NackToggle != 1) { // We should be expecting high
						m_NackToggle = 1;		// Update it if wrong
						error = TRUE;
						DebugOut("SW_WHEEL.DLL: Status Gate is out of Synch (Low - Expecting High)!!!\r\n");
					}
				}
			}

			Send(pNextPacket->m_pData, pNextPacket->m_BytesOfData);

			if (pNextPacket->m_AckNackDelay != 0) {
				Sleep(pNextPacket->m_AckNackDelay);
			}
			
			ackNack.cBytes = sizeof(ACKNACK);
			HRESULT hr = g_pJoltMidi->GetAckNackData(pNextPacket->m_AckNackTimeout, &ackNack, (USHORT)pNextPacket->m_AckNackMethod);
			if 	(forcedToggle == TRUE) {
				m_NackToggle = 2;
			}
			if (hr != SUCCESS) {
				return SFERR_DRIVER_ERROR;
			}
			success = (ackNack.dwAckNack == ACK);
			if (success == FALSE) {		// We don't want to bother retrying on certian error codes, retrying is worthless
				success = ((ackNack.dwErrorCode == DEV_ERR_MEM_FULL_200) || (ackNack.dwErrorCode == DEV_ERR_PLAY_FULL_200) || (ackNack.dwErrorCode == DEV_ERR_INVALID_ID_200));
			}
		} while (!success && (--retries > 0));
		if (ackNack.dwAckNack == NACK) {
			return SFERR_DEVICE_NACK;
		}
	}
	g_pDataPackager->ClearPackets();
	return SUCCESS;
}

/****************** SerialDataTransmitter class ***************/

/******************************************************
**
** SerialDataTransmitter::SerialDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialDataTransmitter::SerialDataTransmitter() : DataTransmitter(),
	m_SerialPort(INVALID_HANDLE_VALUE),
	m_SerialPortIDHack(0)
{
}

/******************************************************
**
** SerialDataTransmitter::~SerialDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
SerialDataTransmitter::~SerialDataTransmitter()
{
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}
}


/******************************************************
**
** SerialDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialDataTransmitter::Initialize(DWORD dwDeviceID)
{
	// If already open, close for reinitialization
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}

	for (unsigned int portNum = 0; portNum < 4; portNum++) {
		DebugOut(cCommPortNames[portNum]);
		DebugOut(":\r\n");
		m_SerialPort = ::CreateFile(cCommPortNames[portNum], GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (m_SerialPort != INVALID_HANDLE_VALUE) {
			DCB CommDCB;
			if (::GetCommState(m_SerialPort, &CommDCB)) {
#ifdef _DEBUG
				char dbgout[255];
				wsprintf(dbgout, "Baud Rate = 0x%08X (38400 = 0x%08X)\r\n", CommDCB.BaudRate, CBR_38400);
				_RPT0(_CRT_WARN, dbgout);
#endif _DEBUG
				CommDCB.BaudRate = CBR_38400;
				CommDCB.StopBits = ONESTOPBIT;
				CommDCB.ByteSize = 8;
				CommDCB.Parity = NOPARITY;
				if (!::SetCommState(m_SerialPort, &CommDCB)) {
					DebugOut("Unabled to set baud rate\r\n");
				}
			}
			::GetCommState(m_SerialPort, &CommDCB);

			if (g_ForceFeedbackDevice.DetectHardware()) {
				m_SerialPortIDHack = portNum + 1;
				// Write to shared file
				DebugOut(" Opened and FFDev Detected\r\n");
				break;	// Exit from for loop
			}
			// Not found
			::CloseHandle(m_SerialPort);
			DebugOut(" Opened but FFDev NOT detected\r\n");
			m_SerialPort = INVALID_HANDLE_VALUE;
		} else {
			DebugOut(" Not able to open\r\n");
		}
	}
	if (m_SerialPort != INVALID_HANDLE_VALUE) {	// Found it
		DWORD oldPortID;
		DWORD oldAccessMethod;
		joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
		DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_SERIAL_FILE;
		if ((accessMethod != oldAccessMethod) || (portNum != oldPortID)) {
			joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, portNum);
		}
		return TRUE;
	}
	return FALSE;
}

/******************************************************
**
** SerialDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL SerialDataTransmitter::Send(BYTE* data, UINT numBytes) const
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_SerialPort == NULL) {
		return FALSE;
	}

	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)) {
		DWORD subTotalWritten;
		DWORD totalWritten = 0;
		DWORD numLeft = numBytes;
		while (numLeft > c1_16_BytesPerShot) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), c1_16_BytesPerShot, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
			numLeft -= subTotalWritten;
			Sleep(c1_16_SerialSleepTime);
		}
		if (numLeft > 0) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), numLeft, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
		}
		return (totalWritten == numBytes);
	}

	// Firmware other than 1.16
	DWORD numWritten;
	if (::WriteFile(m_SerialPort, data, numBytes, &numWritten, NULL) == FALSE) {
		return FALSE;
	}
	return (numWritten == numBytes);
}


/****************** WinMMDataTransmitter class ******************/
/******************************************************
**
** WinMMDataTransmitter::WinMMDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
WinMMDataTransmitter::WinMMDataTransmitter() : DataTransmitter(),
	m_MidiOutHandle(NULL)
{
	// Check for callback event
	m_EventMidiOutputFinished = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (m_EventMidiOutputFinished == NULL) {	// Event not yet created
		m_EventMidiOutputFinished = CreateEvent(NULL, TRUE, FALSE, SWFF_MIDIEVENT);
	}
}

/******************************************************
**
** WinMMDataTransmitter::~WinMMDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
WinMMDataTransmitter::~WinMMDataTransmitter()
{
	// Kill MidiOutputEvent
	if (m_EventMidiOutputFinished != NULL) {
		CloseHandle(m_EventMidiOutputFinished);
		m_EventMidiOutputFinished = NULL;
	}

	// Close MidiHandle	-- Check shared memory
	if (m_MidiOutHandle != NULL) {
		if ((NULL != g_pJoltMidi) && (g_pJoltMidi->GetSharedMemoryReferenceCount() == 0)) {	// Just me (reference count has already been lowered for me)
			// Reset, close and release Midi Handles
			::midiOutReset(m_MidiOutHandle);
			::midiOutClose(m_MidiOutHandle);
			m_MidiOutHandle = NULL;
		} else {
			DebugOut("SW_WHEEL.DLL: Cannot close midi in use by another process\r\n");
		}
	}
}


/******************************************************
**
** WinMMDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL WinMMDataTransmitter::Initialize(DWORD dwDeviceID)
{
	// Wouldn't want to people initializing at the same time
	g_CriticalSection.Enter();

	if (NULL == g_pJoltMidi)
	{
		g_CriticalSection.Leave();
		return (FALSE);
	}
	// Check to see if another task has already opened MidiPort
	if (g_pJoltMidi->MidiOutHandleOf() != NULL) {
		m_MidiOutHandle = g_pJoltMidi->MidiOutHandleOf();
		DebugOut("SW_WHEEL.DLL: Using winmm handle from another process\r\n");
		g_CriticalSection.Leave();
		return TRUE;
	}

	try {
		UINT numMidiDevices = ::midiOutGetNumDevs();
		if (numMidiDevices == 0) {
			throw 0;	// No devices to check
		}

		MIDIOUTCAPS midiOutCaps;
		for (UINT midiDeviceID = 0; midiDeviceID < numMidiDevices; midiDeviceID++) {
			// Get dev-caps
			MMRESULT midiRet = ::midiOutGetDevCaps(midiDeviceID, &midiOutCaps, sizeof(midiOutCaps));
			if (midiRet != MMSYSERR_NOERROR) {
				throw 0;	// Something went ugly - All ids should be valid upto numMidiDevs
			}

			// Midi hardware-port device (thats what we are looking for)
			if (midiOutCaps.wTechnology == MOD_MIDIPORT) {
				DebugOut("DetectMidiDevice: Opening WinMM Midi Output\n");

				// Try to open the thing

				UINT openRet = ::midiOutOpen(&m_MidiOutHandle, midiDeviceID, (DWORD) m_EventMidiOutputFinished, (DWORD) this, CALLBACK_EVENT);
//				UINT openRet = ::midiOutOpen(&m_MidiOutHandle, midiDeviceID, (DWORD) NULL, (DWORD) this, CALLBACK_EVENT);
				if ((openRet != MMSYSERR_NOERROR) || (m_MidiOutHandle == NULL)) {
					throw 0;	// Unable to open midi handle for midi-device
				}

				DebugOut("Open Midi Output - Success.\r\n");
				if (g_ForceFeedbackDevice.DetectHardware()) {
					// Found Microsoft FF hardware - Set all the stuff and return happy
					g_pJoltMidi->SetMidiOutHandle(m_MidiOutHandle);

					// Tell the Registry WinMM was okay
					DWORD oldPortID;
					DWORD oldAccessMethod;
					joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
					DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_WINMM;
					if ((accessMethod != oldAccessMethod) || (oldPortID != 0)) {
						joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, 0);
					}
					g_CriticalSection.Leave();
					return TRUE;
				}

				// Not what we were looking for - close and continue
				::midiOutClose(m_MidiOutHandle);
				m_MidiOutHandle = NULL;
			}	// End of ModMidiPort found
		}	// End of for loop
		throw 0; // Did not find MS FFDevice
	} catch (...) {
		m_MidiOutHandle = NULL;
		DebugOut("Failure to initlaize WinMMDataTransmitter\r\n");
		g_CriticalSection.Leave();
		return FALSE;
	}
}

/******************************************************
**
** WinMMDataTransmitter::MakeShortMessage()
**
** returns: DWORD WinMM MidiShort message
** @mfunc MakeShortMessage.
**
******************************************************/
DWORD WinMMDataTransmitter::MakeShortMessage(BYTE* data, UINT numBytes) const
{
	DWORD shortMessage = data[0];
	if (numBytes > 1) {
		shortMessage |= (data[1] << 8);
		if (numBytes < 2) {
			shortMessage |= (data[2] << 16);
		}
	}
	return shortMessage;
}

/******************************************************
**
** WinMMDataTransmitter::MakeLongMessageHeader()
**
** returns: SUCCESS indication and WinMM MidiLong message header
** @mfunc MakeLongMessageHeader.
**
******************************************************/
BOOL WinMMDataTransmitter::MakeLongMessageHeader(MIDIHDR& longHeader, BYTE* data, UINT numBytes) const
{
    longHeader.lpData = LPSTR(data);
    longHeader.dwBufferLength = numBytes;
    longHeader.dwBytesRecorded = numBytes;
    longHeader.dwFlags = 0;
	longHeader.dwUser = 0;
	longHeader.dwOffset = 0;

    return (::midiOutPrepareHeader(m_MidiOutHandle, &longHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
}

/******************************************************
**
** WinMMDataTransmitter::DestroyLongMessageHeader()
**
** returns: TRUE if header was unprepared
** @mfunc DestroyLongMessageHeader.
**
******************************************************/
BOOL WinMMDataTransmitter::DestroyLongMessageHeader(MIDIHDR& longHeader) const
{
    return (::midiOutUnprepareHeader(m_MidiOutHandle, &longHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
}

/******************************************************
**
** WinMMDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL WinMMDataTransmitter::Send(BYTE* data, UINT numBytes) const
{
	// Do we have a valid midi port (hopefully with MS FF device connected)
	if (m_MidiOutHandle == NULL) {
		return FALSE;
	}

	// Sanity check
	if ((data == NULL) || (numBytes == 0)) {
		return FALSE;
	}

	// Clear the Event Callback
	::ResetEvent(m_EventMidiOutputFinished);

	// Short message
	if (data[0] < 0xF0) {
		DWORD shortMessage = MakeShortMessage(data, numBytes);
		return (::midiOutShortMsg(m_MidiOutHandle, shortMessage) == MMSYSERR_NOERROR);
	}

	// Long message
	BOOL retVal = FALSE;
	MIDIHDR midiHeader;
	if (MakeLongMessageHeader(midiHeader, data, numBytes)) {
		retVal = (::midiOutLongMsg(m_MidiOutHandle, &midiHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
		DestroyLongMessageHeader(midiHeader);

		if (retVal == FALSE) {	// Didn't work, kick it
			::midiOutReset(m_MidiOutHandle);
		}
	}

	return retVal;
}

/******************************************************
**
** WinMMDataTransmitter::WaitTillSendFinished()
**
** returns: TRUE when all data is successfully sent or
**			FALSE for timeOut
** @mfunc Send.
**
******************************************************/
BOOL WinMMDataTransmitter::WaitTillSendFinished(DWORD timeOut)
{
	BOOL retVal = FALSE;
	if (m_EventMidiOutputFinished != NULL) {
		retVal = (::WaitForSingleObject(m_EventMidiOutputFinished, timeOut) == WAIT_OBJECT_0);
		::ResetEvent(m_EventMidiOutputFinished);
	}
	return retVal;
}

/****************** BackdoorDataTransmitter class ***************/

/******************************************************
**
** BackdoorDataTransmitter::BackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
BackdoorDataTransmitter::BackdoorDataTransmitter() : DataTransmitter(),
	m_DataPort(INVALID_HANDLE_VALUE)
{
	m_OldBackdoor = (g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (g_ForceFeedbackDevice.GetDriverVersionMinor() == 0);
}

/******************************************************
**
** BackdoorDataTransmitter::~BackdoorDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
BackdoorDataTransmitter::~BackdoorDataTransmitter()
{
	if (m_DataPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_DataPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_DataPort = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** BackdoorDataTransmitter::Initialize()
**
** returns: This base class only does error checking on preset values
** @mfunc Initialize.
**
******************************************************/
BOOL BackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (g_ForceFeedbackDevice.IsOSNT5()) {
		return FALSE;	// NT5 cannot use backdoor!
	}

	return TRUE;
}

/******************************************************
**
** BackdoorDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL BackdoorDataTransmitter::Send(BYTE* pData, UINT numBytes) const
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_DataPort == NULL) {
		return FALSE;
	}

	return SUCCEEDED(g_pDriverCommunicator->SendBackdoor(pData, numBytes));
}

/****************** SerialBackdoorDataTransmitter class ***************/

/******************************************************
**
** SerialBackdoorDataTransmitter::SerialBackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialBackdoorDataTransmitter::SerialBackdoorDataTransmitter() : BackdoorDataTransmitter()
{
}

/******************************************************
**
** SerialBackdoorDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialBackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

	SerialDataTransmitter serialFrontDoor;

	// This is funky
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}
	g_pDataTransmitter = &serialFrontDoor;

	if (serialFrontDoor.Initialize(dwDeviceID)) {
		m_DataPort = HANDLE(serialFrontDoor.GetSerialPortHack());
		if (g_pDriverCommunicator->SetBackdoorPort(ULONG(m_DataPort)) == SUCCESS) {
			serialFrontDoor.StopAutoClose();
			DWORD oldPortID, oldAccessMethod;
			joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
			DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_SERIAL_BACKDOOR;
			joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, oldPortID);
			g_pDataTransmitter = this;
			return TRUE;
		}
	}
	g_pDataTransmitter = this;
	return FALSE;
}

/****************** MidiBackdoorDataTransmitter class ***************/

/******************************************************
**
** MidiBackdoorDataTransmitter::MidiBackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
MidiBackdoorDataTransmitter::MidiBackdoorDataTransmitter() : BackdoorDataTransmitter()
{
}

/******************************************************
**
** MidiBackdoorDataTransmitter::~MidiBackdoorDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
MidiBackdoorDataTransmitter::~MidiBackdoorDataTransmitter()
{
	m_DataPort = NULL;		// Prevent attempt to ::CloseHandle(m_DataPort)
}

/******************************************************
**
** MidiBackdoorDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL MidiBackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

    if (midiOutGetNumDevs() == 0) {
		return FALSE;	// No midi-devices backdoor check is worthless
	}

	// Valid MIDI ports table for backdoor - ordered by probability of working
	DWORD midiPorts[] = {0x330, 0x300, 0x320, 0x340, 0x310, 0x350, 0x360, 0x370, 0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	int numMidiPorts = sizeof(midiPorts)/sizeof(DWORD);

	m_DataPort = NULL;

	for (int i=0; i < numMidiPorts; i++) {
#ifdef _DEBUG
		char buff[256];
        wsprintf(buff, "MidiBackdoorDataTransmitter::Initialize(): Midi Port:%lx - ", midiPorts[i]);
        DebugOut(buff);
#endif
		// We have the Port #, Let's see if Jolt is out there
		m_DataPort = HANDLE(midiPorts[i]);
		if (g_pDriverCommunicator->SetBackdoorPort(ULONG(m_DataPort)) == SUCCESS) {
			if (g_ForceFeedbackDevice.DetectHardware()) {
				DebugOut(" Success!\n");

				DWORD oldPortID;
				DWORD oldAccessMethod;
				joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
				DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_MIDI_BACKDOOR;
				if ((accessMethod != oldAccessMethod) || (ULONG(m_DataPort) != oldPortID)) {
					joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, ULONG(m_DataPort));
				}
//				joySetForceFeedbackCOMMInterface(0, COMM_MIDI_BACKDOOR, ULONG(m_DataPort));
				return TRUE;
			} else {
				m_DataPort = NULL;
				DebugOut(" No Answer\n");
			}
		}		
	}

	// If we have fallen through we have failed
	return FALSE;
}

/******************************************************
**
** MidiBackdoorDataTransmitter::InitializeSpecific(HANDLE specificHandle)
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL MidiBackdoorDataTransmitter::InitializeSpecific(DWORD dwDeviceID, HANDLE specificHandle)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

    if (midiOutGetNumDevs() == 0) {
		return FALSE;	// No midi-devices backdoor check is worthless
	}

	m_DataPort = NULL;

	// We have the Port #, Let's see if Jolt is out there
	if (g_pDriverCommunicator->SetBackdoorPort(ULONG(specificHandle) == SUCCESS)) {
		if (g_ForceFeedbackDevice.DetectHardware()) {
			m_DataPort = specificHandle;
//			No need to set registry the registry is what brought us here
			return TRUE;
		}
	}

	// If we have fallen through we have failed
	return FALSE;
}

#if 0
/************************** PinTransmitter Class ******************************/

/******************************************************
**
** PinTransmitter::PinTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
PinTransmitter::PinTransmitter() : DataTransmitter(),
	m_UartFilter(INVALID_HANDLE_VALUE),
	m_MidiPin(INVALID_HANDLE_VALUE),
	m_MidiOutEvent(INVALID_HANDLE_VALUE)
{
}

/******************************************************
**
** PinTransmitter::~PinTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
PinTransmitter::~PinTransmitter()
{
	// Close the send event
	if (IsHandleValid(m_MidiOutEvent)) {
		::CloseHandle(m_MidiOutEvent);
		m_MidiOutEvent = NULL;
	}

	// Close the pin
	if (IsHandleValid(m_MidiPin)) {
		::CloseHandle(m_MidiPin);
		m_MidiPin = INVALID_HANDLE_VALUE;
	}

	// Close the Uart
	if (IsHandleValid(m_UartFilter)) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** PinTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL PinTransmitter::Initialize()
{
	// Load the ksUserLibrary and grab the create pin function
	HINSTANCE ksUserLib = ::LoadLibrary(TEXT("KsUser.dll"));
	if (ksUserLib == NULL) {
		return FALSE;
	}
	KSCREATEPIN pfCreatePin = (KSCREATEPIN)::GetProcAddress(ksUserLib, TEXT("KsCreatePin"));
	if (pfCreatePin == NULL) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Open the Uart
	m_UartFilter = ::CreateFile(UART_FILTER_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (m_UartFilter == INVALID_HANDLE_VALUE) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Create Overlapped event
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	// Get the number of pins
	KSP_PIN ksPinProp;
	::memset(&ksPinProp, 0, sizeof(ksPinProp));
	ksPinProp.Property.Set = KSPROPSETID_Pin;
	ksPinProp.Property.Id = KSPROPERTY_PIN_CTYPES;
	ksPinProp.Property.Flags = KSPROPERTY_TYPE_GET;
	DWORD numPins = 0;
	OverLappedPinIOCTL(overlapped, ksPinProp, &numPins, sizeof(numPins));

	// Check each pin for proper type, then try to create
	BOOL wasCreated = FALSE;
	for (UINT pinNum = 0; (pinNum < numPins) && (wasCreated == FALSE); pinNum++) {
		ksPinProp.PinId = pinNum;
		ksPinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
		KSPIN_DATAFLOW dataFlow = (KSPIN_DATAFLOW)0;
		if (OverLappedPinIOCTL(overlapped, ksPinProp, &dataFlow, sizeof(dataFlow)) == TRUE) {
			if (dataFlow == KSPIN_DATAFLOW_IN) {
				ksPinProp.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
				KSPIN_COMMUNICATION communication = KSPIN_COMMUNICATION_NONE;
				if (OverLappedPinIOCTL(overlapped, ksPinProp, &communication, sizeof(communication)) == TRUE) {
					if ((communication == KSPIN_COMMUNICATION_SINK) || (communication == KSPIN_COMMUNICATION_BOTH)) {
						wasCreated = CreatePinInstance(pinNum, pfCreatePin);
					}
				}
			}
		}
	}
	::FreeLibrary(ksUserLib);
	::CloseHandle(overlapped.hEvent);
	if (wasCreated == FALSE) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
		return FALSE;
	}
	return TRUE;
}

/******************************************************
**
** PinTransmitter::OverLappedPinIOCTL()
**
** returns: TRUE if able to proform Pin Property IOCTL
** @mfunc OverLappedPinIOCTL.
******************************************************/
BOOL PinTransmitter::OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize)
{
	// IOCTL the Property
	if (::DeviceIoControl(m_UartFilter, IOCTL_KS_PROPERTY, &ksPinProp, sizeof(ksPinProp), pData, dataSize, NULL, &overlapped) == TRUE) {
		return TRUE;
	}

	// Failed IOCTL check if more time is needed
	if (::GetLastError() != ERROR_IO_PENDING) {
		return FALSE;
	}

	// Do wait
	if (::WaitForSingleObject(overlapped.hEvent, 3000) == WAIT_OBJECT_0) {
		return TRUE;	// Waiting paid off
	}
	return FALSE;	// Grew tired of waiting
}

/******************************************************
**
** PinTransmitter::CreatePinInstance()
**
** returns: TRUE if able to create the requested pin instance
** @mfunc CreatePinInstance.
******************************************************/
BOOL PinTransmitter::CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin)
{
	// Set the pin format
	KSDATAFORMAT ksDataFormat;
	::memset(&ksDataFormat, 0, sizeof(ksDataFormat));
	ksDataFormat.FormatSize = sizeof(ksDataFormat);
	ksDataFormat.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
	ksDataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
	ksDataFormat.Specifier = KSDATAFORMAT_SPECIFIER_NONE;

	// Set the pin connection information
	KSPIN_CONNECT* pConnectionInfo = (KSPIN_CONNECT*) new BYTE[sizeof(KSPIN_CONNECT) + sizeof(ksDataFormat)];
	::memset(pConnectionInfo, 0, sizeof(KSPIN_CONNECT));
	pConnectionInfo->Interface.Set = KSINTERFACESETID_Standard;
	pConnectionInfo->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
	pConnectionInfo->Medium.Set = KSMEDIUMSETID_Standard;
	pConnectionInfo->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
	pConnectionInfo->PinId = pinNumber;
	pConnectionInfo->Priority.PriorityClass = KSPRIORITY_NORMAL;
	pConnectionInfo->Priority.PrioritySubClass  = 1;
	::memcpy(pConnectionInfo + 1, &ksDataFormat, sizeof(ksDataFormat));

	DWORD status = pfCreatePin(m_UartFilter, pConnectionInfo, FILE_WRITE_ACCESS, &m_MidiPin);
	delete[] pConnectionInfo;
	if (status != NO_ERROR) {
#ifdef _DEBUG
		TCHAR buff[256];
		wsprintf(buff, TEXT("Error Creating Pin: 0x%08X\r\n"), status);
		_RPT0(_CRT_WARN, buff);
#endif
		return FALSE;
	}

	SetPinState(KSSTATE_PAUSE);

	return TRUE;
}

/******************************************************
**
** PinTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL PinTransmitter::Send(BYTE* pData, UINT numBytes)
{
	if (!IsHandleValid(m_MidiPin)) {
		return FALSE;
	}

	BYTE musicData[c_LongMsgMax + sizeof(KSMUSICFORMAT)];
	::memset(musicData, 0, sizeof(musicData));
	((KSMUSICFORMAT*)musicData)->ByteCount = numBytes;
	::memcpy(((KSMUSICFORMAT*)musicData) + 1, pData, numBytes);

	KSSTREAM_HEADER ksStreamHeader;
	::memset(&ksStreamHeader, 0, sizeof(ksStreamHeader));
	ksStreamHeader.Size = sizeof(ksStreamHeader);
	ksStreamHeader.PresentationTime.Numerator = 1;
	ksStreamHeader.PresentationTime.Denominator = 1;
	ksStreamHeader.FrameExtent = sizeof(musicData);
	ksStreamHeader.DataUsed = sizeof KSMUSICFORMAT + numBytes;
	ksStreamHeader.Data = (void*)musicData;

	if (!IsHandleValid(m_MidiOutEvent)) {
		m_MidiOutEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = m_MidiOutEvent;


	SetPinState(KSSTATE_RUN);
	if (!DeviceIoControl(m_MidiPin, IOCTL_KS_WRITE_STREAM, NULL, 0,
							&ksStreamHeader, sizeof(ksStreamHeader), NULL, &overlapped)) {
		if (GetLastError() == ERROR_IO_PENDING) {
			::WaitForSingleObject(overlapped.hEvent, 3000);
		}
	}
	SetPinState(KSSTATE_PAUSE);
	return TRUE;
}

/******************************************************
**
** PinTransmitter::SetPinState()
**
** returns: Nothing
** @mfunc SetPinState.
**
******************************************************/
void PinTransmitter::SetPinState(KSSTATE state)
{
	if (!IsHandleValid(m_MidiPin)) {
		return;
	}

	KSPROPERTY ksProperty;
	::memset(&ksProperty, 0, sizeof(ksProperty));
	ksProperty.Set = KSPROPSETID_Connection;
	ksProperty.Id = KSPROPERTY_CONNECTION_STATE;
	ksProperty.Flags = KSPROPERTY_TYPE_SET;

	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (IsHandleValid(overlapped.hEvent)) {
		if( !DeviceIoControl(m_MidiPin, IOCTL_KS_PROPERTY, &ksProperty, sizeof ksProperty, &state, sizeof state, NULL, &overlapped )) {
			if (GetLastError() == ERROR_IO_PENDING) {
				WaitForSingleObject(overlapped.hEvent, 30000);
			}
		}
		::CloseHandle(overlapped.hEvent);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dtrans.h ===
//@doc
/******************************************************
**
** @module DTRANS.H | Definition file for DataTransmitter
**
** Description:
**		The Data Transmitters allow virtualization of the
**	actual media used for transmission of data to the FF Device
**		DataTransmitter - Base class that defines the functionality
**		SerialDataTransmitter - Transmitter for Serial (via CreateFile)
**		BackdoorDataTransmitter - Base class for Ring0 Driver based direct port communication
**		SerialBackdoorDataTransmitter - Direct backdoor Serial Port Communication
**		MidiBackdoorDataTransmitter - Direct backdoor Midi Port Communication
**
** Classes:
**		DataTransmitter
**		SerialDataTransmitter : DataTransmitter
**		BackdoorDataTransmitter : DataTransmitter
**		SerialBackdoorDataTransmitter : BackdoorDataTransmitter
**		MidiBackdoorDataTransmitter : BackdoorDataTransmitter
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**			22-Mar-99	waltw	Added DWORD dwDeviceID param to Initialize
**								members of DataTransmitter and derived classes
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DTRANS_H__
#define	__DTRANS_H__

#include <dinput.h>
#include "midi.hpp"
#include "VxdIOCTL.hpp"

#ifndef override
#define override
#endif

//
// @class DataTransmitter class
//
class DataTransmitter
{
	//@access Constructor
	protected:
		//@cmember constructor
		DataTransmitter() : m_NackToggle(2) {};
	//@access Destructor
	public:
		//@cmember destructor
		virtual ~DataTransmitter() {};

	//@access Member functions
	public:
		HRESULT Transmit(ACKNACK& ackNack);

		virtual BOOL Initialize(DWORD dwDeviceID) { return FALSE; }
		void SetNextNack(SHORT nextNack) { m_NackToggle = nextNack; }
		BOOL NackToggle() const { return (m_NackToggle == 1); }

		virtual BOOL WaitTillSendFinished(DWORD timeOut) { return TRUE; }
		virtual HANDLE GetCOMMHandleHack() const { return NULL; }
		virtual void StopAutoClose() {}; // Temporary hack to avoid closing own handle (for backdoor serial)
		virtual ULONG GetSerialPortHack() { return 0; }
	protected:
		virtual BOOL Send(BYTE* data, UINT numBytes) const { return FALSE; }	// Outsiders call transmit!

	private:
		SHORT m_NackToggle;
};

//
// @class SerialDataTransmitter class
//
class SerialDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialDataTransmitter();
		//@cmember destructor
		override ~SerialDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;

		override  HANDLE GetCOMMHandleHack() const { return m_SerialPort; }
		override void StopAutoClose() { m_SerialPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return m_SerialPortIDHack; }
		//@access private data members
	private:
		HANDLE m_SerialPort;
		ULONG m_SerialPortIDHack;
};

//
// @class WinMMDataTransmitter class
//
class WinMMDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		WinMMDataTransmitter ();
		//@cmember destructor
		override ~WinMMDataTransmitter ();

		override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;
		override BOOL WaitTillSendFinished(DWORD timeOut);

		override  HANDLE GetCOMMHandleHack() const { return HANDLE(m_MidiOutHandle); }
		override void StopAutoClose() { m_MidiOutHandle = HMIDIOUT(INVALID_HANDLE_VALUE); }
		override ULONG GetSerialPortHack() { return ULONG(m_MidiOutHandle); }
		//@access private data members
	private:
		DWORD MakeShortMessage(BYTE* data, UINT numBytes) const;
		BOOL MakeLongMessageHeader(MIDIHDR& longHeader, BYTE* data, UINT numBytes) const;
		BOOL DestroyLongMessageHeader(MIDIHDR& longHeader) const;

		HANDLE m_EventMidiOutputFinished;
		HMIDIOUT m_MidiOutHandle;
};

//
// @class BackdoorDataTransmitter class
//
class BackdoorDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember destructor
		virtual override ~BackdoorDataTransmitter();

		virtual override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;

		override  HANDLE GetCOMMHandleHack() const { return m_DataPort; }
		override void StopAutoClose() { m_DataPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return ULONG(m_DataPort); }
		//@access private data members
	protected:
		//@cmember constructor - protected, cannot create instance of this class
		BackdoorDataTransmitter();

		HANDLE m_DataPort;
		BOOL m_OldBackdoor;
};

//
// @class SerialBackdoorDataTransmitter class
//
class SerialBackdoorDataTransmitter : public BackdoorDataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialBackdoorDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
};

//
// @class MidiBackdoorDataTransmitter class
//
class MidiBackdoorDataTransmitter : public BackdoorDataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		MidiBackdoorDataTransmitter();

		//@cmember destructor
		override ~MidiBackdoorDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
		BOOL InitializeSpecific(DWORD dwDeviceID, HANDLE specificHandle);
};

#if 0		// Fix pin later

typedef DWORD (WINAPI* KSCREATEPIN)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, HANDLE*);

//
// @class PinTransmitter class
//
class PinTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		PinTransmitter();
		//@cmember destructor
		override ~PinTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		//@access private data members
	private:
		BOOL CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin);
		BOOL OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize);
		void SetPinState(KSSTATE state);

		HANDLE m_UartFilter;
		HANDLE m_MidiPin;
		HANDLE m_MidiOutEvent;
};

#endif

extern DataTransmitter* g_pDataTransmitter;

#endif	__DTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dpack.cpp ===
//@doc
/******************************************************
**
** @module DPACK.CPP | DataPackager implementation file
**
** Description:
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "DPack.h"
#include "FFDevice.h"
#include "Midi_Obj.hpp"
#include "joyregst.hpp"
#include "SW_Error.hpp"
#include "Hau_midi.hpp"
#include "CritSec.h"

DataPackager* g_pDataPackager = NULL;
extern CJoltMidi* g_pJoltMidi;

//
// --- MIDI Command codes 200
//
#define PLAYSOLO_OP_200		0x00
#define DESTROY_OP_200		0x01
#define PLAYSUPER_OP_200	0x02
#define STOP_OP_200			0x03
#define STATUS_OP_200		0x04
#define FORCEX_OP_200		0x06
#define FORCEY_OP_200		0x07

//#define MODIFY_CMD_200		0xF1  -- In Header
//#define EFFECT_CMD_200		0xF2  -- In Header
#define DEVICE_CMD_200		0xF3
#define SHUTDOWN_OP_200		0x01
#define ENABLE_OP_200		0x02
#define DISABLE_OP_200		0x03
#define PAUSE_OP_200		0x04
#define CONTINUE_OP_200		0x05
#define STOPALL_OP_200		0x06
#define KILLMIDI_OP_200		0x07

#define GAIN_SCALE_200		78.74
#define PERCENT_SHIFT		10000
#define PERCENT_TO_DEVICE	158

/************** DataPacket class ******************/
DataPacket::DataPacket() :
	m_BytesOfData(0),
	m_AckNackMethod(0),
	m_AckNackDelay(0),
	m_AckNackTimeout(0),
	m_NumberOfRetries(0)
{
	m_pData = m_pFixedData;
}

DataPacket::~DataPacket()
{
	if (m_pData != m_pFixedData) {
		delete[] m_pData;
	}
	m_pData = NULL;
	m_BytesOfData = 0;
}

BOOL DataPacket::AllocateBytes(DWORD numBytes)
{	
	if (m_pData != m_pFixedData) {
		delete[] m_pData;
	}
	if (numBytes <= 32) {
		m_pData = m_pFixedData;
	} else {
		m_pData = new BYTE[numBytes];
	}
	m_BytesOfData = numBytes;
	m_AckNackMethod = ACKNACK_NOTHING;
	m_AckNackDelay = 0;
	m_AckNackTimeout = 0;
	m_NumberOfRetries = 0;

	return (m_pData != NULL);
}


/************** DataPackeger class ******************/
DataPackager::DataPackager() :
	m_NumDataPackets(0),
	m_DirectInputVersion(0)
{
	m_pDataPackets = m_pStaticPackets;
}

DataPackager::~DataPackager()
{
	if (m_pDataPackets != m_pStaticPackets) {
		delete[] m_pDataPackets;
	}
	m_NumDataPackets = 0;
	m_pDataPackets = NULL;
}

HRESULT DataPackager::Escape(DWORD effectID, LPDIEFFESCAPE pEscape)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SetGain(DWORD gain)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SendForceFeedbackCommand(DWORD state)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::GetForceFeedbackState(DIDEVICESTATE* pDeviceState)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::CreateEffect(const InternalEffect& effect, DWORD diFlags)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* commandPacket = GetPacket(0);
	HRESULT hr = effect.FillCreatePacket(*commandPacket);
	if (FAILED(hr)) {
		ClearPackets();
	}
	return hr;
}

HRESULT DataPackager::ModifyEffect(InternalEffect& currentEffect, InternalEffect& newEffect, DWORD modFlags)
{
	return currentEffect.Modify(newEffect, modFlags);
}

HRESULT DataPackager::DestroyEffect(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::StopEffect(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::GetEffectStatus(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SetMidiChannel(BYTE channel)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::ForceOut(LONG lForceData, ULONG ulAxisMask)
{
	ClearPackets();
	return SUCCESS;
}

DataPacket* DataPackager::GetPacket(USHORT packet) const
{
	if ((packet >= 0) && (packet < m_NumDataPackets)) {
		return (m_pDataPackets + packet);
	}
	return NULL;
}

BOOL DataPackager::AllocateDataPackets(USHORT numPackets)
{
	// Out with the old
	if (m_pDataPackets != m_pStaticPackets) {	// Allocated, need to deallocate
		delete[] m_pDataPackets;
	} else {	// Static, need to uninitialize
		for (int i = 0; i < m_NumDataPackets; i++) {
			m_pStaticPackets[i].AllocateBytes(0);
		}
	}

	// In with the new
	if (numPackets <= 3) {
		m_pDataPackets = m_pStaticPackets;
	} else {
		m_pDataPackets = new DataPacket[numPackets];
	}
	m_NumDataPackets = numPackets;

	return (m_pDataPackets != NULL);
}

void DataPackager::ClearPackets()
{
	if (m_pDataPackets != m_pStaticPackets) {	// Were allocated (deallocate)
		delete[] m_pDataPackets;
		m_pDataPackets = m_pStaticPackets;
	} else {	// Static, need to uninitialize
		for (int i = 0; i < m_NumDataPackets; i++) {
			m_pStaticPackets[i].AllocateBytes(0);
		}
	}
	m_NumDataPackets = 0;
}

/************** DataPackeger100 class ******************/

HRESULT DataPackager100::SetGain(DWORD gain)
{
	if (!AllocateDataPackets(2)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* setIndexPacket = GetPacket(0);
	if (!setIndexPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	setIndexPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	setIndexPacket->m_pData[1] = SET_INDEX | (BYTE) (INDEX15 << 2);
	setIndexPacket->m_pData[2] = SYSTEM_EFFECT_ID;
	setIndexPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	setIndexPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	// Packet to set modify data[index] of current effect
	DataPacket* modifyParamPacket = GetPacket(1);
	if (!modifyParamPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	modifyParamPacket->m_pData[0] = MODIFY_CMD | DEFAULT_MIDI_CHANNEL;
	gain /= SCALE_GAIN;
	gain *= DWORD(MAX_SCALE);
	modifyParamPacket->m_pData[1] = BYTE(gain & 0x7f);
	modifyParamPacket->m_pData[2] = (BYTE) ((gain >> 7) & 0x7f);
	modifyParamPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyParamPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager100::SendForceFeedbackCommand(DWORD state)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* commandPacket = GetPacket(0);
	if (!commandPacket->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	commandPacket->m_pData[0] = SYSTEM_CMD | DEFAULT_MIDI_CHANNEL;
	switch (state) {
		case DISFFC_SETACTUATORSON:
			commandPacket->m_pData[1] = SWDEV_FORCE_ON; break;
		case DISFFC_SETACTUATORSOFF:
			commandPacket->m_pData[1] = SWDEV_FORCE_OFF; break;
		case DISFFC_PAUSE:
			commandPacket->m_pData[1] = SWDEV_PAUSE; break;
		case DISFFC_CONTINUE:
			commandPacket->m_pData[1] = SWDEV_CONTINUE; break;
		case DISFFC_STOPALL:
			commandPacket->m_pData[1] = SWDEV_STOP_ALL; break;
		case DISFFC_RESET:
			commandPacket->m_pData[1] = SWDEV_SHUTDOWN; break;
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	commandPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	commandPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
	commandPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::GetForceFeedbackState(LPDIDEVICESTATE pDeviceState)
{
	return DataPackager::GetForceFeedbackState(pDeviceState);
}

HRESULT DataPackager100::DestroyEffect(DWORD downloadID)
{
	ClearPackets();

	// Note: Cannot allow actually destroying the SYSTEM Effects - Control panel might call this
	if ((downloadID == SYSTEM_FRICTIONCANCEL_ID) || (downloadID == SYSTEM_EFFECT_ID) ||
		(downloadID == SYSTEM_RTCSPRING_ALIAS_ID) || (downloadID == SYSTEM_RTCSPRING_ID)) {
		ASSUME_NOT_REACHED();
		return S_FALSE;		// User should have no acces to these
	}

	{	// Check for valid Effect and destroy it
		InternalEffect* pEffect = g_ForceFeedbackDevice.RemoveEffect(downloadID);
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();
			return SFERR_INVALID_OBJECT;
		}
		delete pEffect;
	}

	// Allocate DestroyEffect packet
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for destroy effect
	DataPacket* destroyPacket = GetPacket(0);
	if (!destroyPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	destroyPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	destroyPacket->m_pData[1] = DESTROY_EFFECT;
	destroyPacket->m_pData[2] = BYTE(downloadID);
	destroyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DESTROYEFFECT);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	destroyPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay;
	destroyPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	if (downloadID == SYSTEM_EFFECT_ID) { // start has no meaning for raw force
		ClearPackets();
		return S_FALSE;
	}

	if (count != 1) { // Don't support PLAY_LOOP for this version
		ClearPackets();
		return SFERR_NO_SUPPORT;
	}

	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) { 	// Remap RTC Spring ID Alias
		downloadID = SYSTEM_RTCSPRING_ID;
	}

	ASSUME(BYTE(downloadID) < MAX_EFFECT_IDS);	// Small sanity check

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ClearPackets();
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for play effect
	DataPacket* playPacket = GetPacket(0);
	if (!playPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	playPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	playPacket->m_pData[2] = BYTE(downloadID);
	playPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_PLAYEFFECT);
	playPacket->m_AckNackTimeout = LONG_MSG_TIMEOUT;

	if (mode & DIES_SOLO) {	// Is it PLAY_SOLO?
		playPacket->m_pData[1] = PLAY_EFFECT_SOLO;
//		pMidiEffect->SetPlayMode(PLAY_SOLO); // Update the playback mode for this Effect
	} else {
		playPacket->m_pData[1] = PLAY_EFFECT_SUPERIMPOSE;
//		pMidiEffect->SetPlayMode(PLAY_SUPERIMPOSE); // Update the playback mode for this Effect
	}

	return SUCCESS;
}

HRESULT DataPackager100::StopEffect(DWORD downloadID)
{
	// Special case for putrawforce (Cannot stop - this is up for discussion)
	if (downloadID == SYSTEM_EFFECT_ID) {
		ClearPackets();
		return S_FALSE;
	}

	// Remap alias ID properly
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring so return send alias ID
	}

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ASSUME_NOT_REACHED();
		ClearPackets();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* stopPacket = GetPacket(0);
	if (!stopPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	stopPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	stopPacket->m_pData[1] = STOP_EFFECT;
	stopPacket->m_pData[2] = BYTE(downloadID);
	stopPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_STOPEFFECT);
	stopPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::GetEffectStatus(DWORD downloadID)
{
	// Special case RTC Spring ID
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = SYSTEM_RTCSPRING_ID;	// Jolt returned ID0 for RTC Spring so return send alias ID	
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	packet->m_pData[0] = STATUS_CMD | DEFAULT_MIDI_CHANNEL;
	packet->m_pData[1] = BYTE(downloadID);
	packet->m_AckNackMethod = ACKNACK_NOTHING;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	packet->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay;

	return SUCCESS;
}

HRESULT DataPackager100::SetMidiChannel(BYTE channel)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for channel set
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(9)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	// SysEx Header
	packet->m_pData[0] = SYS_EX_CMD;							// SysEX CMD
	packet->m_pData[1] = 0;									// Escape to Manufacturer ID
	packet->m_pData[2] = MS_MANUFACTURER_ID & 0x7f;			// Manufacturer High Byte
	packet->m_pData[3] = (MS_MANUFACTURER_ID >> 8) & 0x7f;	// Manufacturer Low Byte (note shifted 8!)
	packet->m_pData[4] = JOLT_PRODUCT_ID;					// Product ID

	// Midi Assign specific
	packet->m_pData[5] = MIDI_ASSIGN;						// Opcode, midi assign
	packet->m_pData[6] = channel & 0x7F;						// 7 bit channel ID

	// Midi Footer
	packet->m_pData[7] = InternalEffect::ComputeChecksum(*packet, 7);	// Checksum
	packet->m_pData[8] = MIDI_EOX;										// End of SysEX command

	packet->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DEVICEINIT);
	packet->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::ForceOut(LONG forceData, ULONG axisMask)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* pPacket = GetPacket(0);
	if (!pPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	pPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	pPacket->m_pData[1] = BYTE(int(forceData) << 2) & 0x7c;
	switch (axisMask) {
		case X_AXIS: {
			pPacket->m_pData[1] |= PUT_FORCE_X; break;
		}
		case Y_AXIS: {
			pPacket->m_pData[1] |= PUT_FORCE_Y; break;
		}
//		case X_AXIS | Y_AXIS: {		// Never Sent!!!
//			pPacket->m_pData[1] |= PUT_FORCE_XY; break;
//		}
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	pPacket->m_pData[2] = BYTE(int(forceData) >> 5) & 0x7f;

	pPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	pPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

/************** DataPackeger200 class ******************/

BYTE DataPackager200::EffectCommandParity(const DataPacket& packet) const
{
	BYTE w = packet.m_pData[0] ^ (packet.m_pData[1] & 0xF0) ^ packet.m_pData[2];
	return (w >> 4) ^ (w & 0x0F);
}

BYTE DataPackager200::DeviceCommandParity(const DataPacket& packet) const
{
	BYTE w = packet.m_pData[0] ^ (packet.m_pData[1] & 0xF0);
	return (w >> 4) ^ (w & 0x0F);
}


// Gain is parameter 0 from effect 0
HRESULT DataPackager200::SetGain(DWORD gain)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* modifyPacket = GetPacket(0);
	if ((modifyPacket == NULL) || (!modifyPacket->AllocateBytes(6))) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	DWORD value = DWORD(double(gain)/GAIN_SCALE_200);
	modifyPacket->m_pData[0] = MODIFY_CMD_200;
	modifyPacket->m_pData[1] = 0;	// Temporary for checksum calc.
	modifyPacket->m_pData[2] = 0;
	modifyPacket->m_pData[3] = 0;
	modifyPacket->m_pData[4] = BYTE(value & 0x7F);
	modifyPacket->m_pData[5] = 0;	// Gain is only 0 to 127

	// New checksum method just to be annoying
	BYTE checksum = modifyPacket->m_pData[0] + modifyPacket->m_pData[4];
	checksum = 0 - checksum;
	checksum &= 0xFF;
	modifyPacket->m_pData[1] = BYTE(checksum & 0x7F);
	modifyPacket->m_pData[2] |= BYTE(checksum >> 1) & 0x40;

	modifyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::SendForceFeedbackCommand(DWORD state)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set requested System Command
	DataPacket* commandPacket = GetPacket(0);
	if (!commandPacket->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	commandPacket->m_pData[0] = DEVICE_CMD_200;
	switch (state) {
		case DISFFC_SETACTUATORSON:
			commandPacket->m_pData[1] = ENABLE_OP_200; break;
		case DISFFC_SETACTUATORSOFF:
			commandPacket->m_pData[1] = DISABLE_OP_200; break;
		case DISFFC_PAUSE:
			commandPacket->m_pData[1] = PAUSE_OP_200; break;
		case DISFFC_CONTINUE:
			commandPacket->m_pData[1] = CONTINUE_OP_200; break;
		case DISFFC_STOPALL:
			commandPacket->m_pData[1] = STOPALL_OP_200; break;
		case DISFFC_RESET:
			commandPacket->m_pData[1] = SHUTDOWN_OP_200; break;
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	commandPacket->m_pData[1] = BYTE(commandPacket->m_pData[1] << 4);
	commandPacket->m_pData[1] |= DeviceCommandParity(*commandPacket) & 0x0F;

	commandPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
	commandPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	commandPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
	commandPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager200::GetForceFeedbackState(DIDEVICESTATE* pDeviceState)
{
	return DataPackager::GetForceFeedbackState(pDeviceState);
}

HRESULT DataPackager200::CreateEffect(const InternalEffect& effect, DWORD diFlags)
{
	// Figure out the number of packets nessacary
	UINT totPackets = effect.GetModifyOnlyNeeded() + 1;

	if (!AllocateDataPackets((USHORT)totPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* createPacket = GetPacket(0);
	HRESULT hr = effect.FillCreatePacket(*createPacket);
	if (hr != SUCCESS) {
		ClearPackets();
		return hr;
	}
	createPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DOWNLOADEFFECT);
	createPacket->m_AckNackDelay = 0;
	createPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	createPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	hr = effect.FillModifyOnlyParms();	// Add the params that can only be modified
	if (hr != SUCCESS) {
		ClearPackets();
	}

	return hr;
}


HRESULT DataPackager200::DestroyEffect(DWORD downloadID)
{
	ClearPackets();

	// Note: Cannot allow actually destroying the SYSTEM Effects - Control panel might call this
	if ((downloadID == SYSTEM_FRICTIONCANCEL_ID) || (downloadID == SYSTEM_EFFECT_ID) ||
		(downloadID == SYSTEM_RTCSPRING_ALIAS_ID) || (downloadID == ID_RTCSPRING_200)) {
		ASSUME_NOT_REACHED();
		return S_FALSE;		// User should have no acces to these
	}

	{	// Check for valid Effect and destroy it
		InternalEffect* pEffect = g_ForceFeedbackDevice.RemoveEffect(downloadID);
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();
			return SFERR_INVALID_OBJECT;
		}
		delete pEffect;
	}

	// Allocate DestroyEffect packet
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for destroy effect
	DataPacket* destroyPacket = GetPacket(0);
	if (!destroyPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	destroyPacket->m_pData[0] = EFFECT_CMD_200;
	destroyPacket->m_pData[1] = BYTE(DESTROY_OP_200 << 4);
	destroyPacket->m_pData[2] = BYTE(downloadID);
	destroyPacket->m_pData[1] |= EffectCommandParity(*destroyPacket) & 0x0F;
	destroyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DESTROYEFFECT);
	destroyPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay;
	destroyPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	destroyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	if ((downloadID == SYSTEM_EFFECT_ID) || (downloadID == RAW_FORCE_ALIAS)) { // start has no meaning for raw force
		ClearPackets();
		return S_FALSE;
	}

#ifdef _DEBUG
	if (downloadID != SYSTEM_RTCSPRING_ALIAS_ID) { 	// Remap RTC Spring ID Alias
		ASSUME(BYTE(downloadID) < MAX_EFFECT_IDS);	// Small sanity check
	}
#endif _DEBUG

	InternalEffect* pEffect = g_ForceFeedbackDevice.GetEffect(downloadID);
	if (pEffect == NULL) { // Check for valid Effect
		ClearPackets();
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_OBJECT;
	}

	if (count == 0) {	// I can do this easily
		ClearPackets();
		return S_OK;
	}

	BOOL truncate = FALSE;
	if (count == INFINITE) {	// Device expects zero for infinite
		count = 0;
	} else if (count > 127) {	// Device MAX
		count = 127;
		truncate = TRUE;
	}

	int allocCount = 1;
	if ((mode & DIES_SOLO) && count != 1) {
		allocCount = 2;	// Need to stopall for SOLO with count
	}
	if (!AllocateDataPackets((USHORT)allocCount)) {
		return SFERR_DRIVER_ERROR;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	if (count != 1) { // Special case, done via modify
		BYTE nextPacket = 0;
		if (mode & DIES_SOLO) {	// need to stop all first
			DataPacket* stopAllPacket = GetPacket(0);
			if (!stopAllPacket->AllocateBytes(2)) {
				ClearPackets();
				return SFERR_DRIVER_ERROR;
			}
			stopAllPacket->m_pData[0] = DEVICE_CMD_200;
			stopAllPacket->m_pData[1] = STOPALL_OP_200 << 4;
			stopAllPacket->m_pData[1] |= DeviceCommandParity(*stopAllPacket) & 0x0F;
			stopAllPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
			stopAllPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
			stopAllPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;
			stopAllPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

			nextPacket = 1;
		}
		HRESULT hr = pEffect->FillModifyPacket200(nextPacket, pEffect->GetRepeatIndex(), count);
		if ((hr == S_OK) && (truncate == TRUE)) {
			return DI_TRUNCATED;
		}
		return hr;
	}

	// Packet for play effect
	DataPacket* playPacket = GetPacket(0);
	if (!playPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	playPacket->m_pData[0] = EFFECT_CMD_200;
	playPacket->m_pData[2] = BYTE(pEffect->GetDeviceID());
	playPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_PLAYEFFECT);
	playPacket->m_AckNackTimeout = LONG_MSG_TIMEOUT;
	playPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	if (mode & DIES_SOLO) {	// Is it PLAY_SOLO?
		playPacket->m_pData[1] = PLAYSOLO_OP_200;
	} else {
		playPacket->m_pData[1] = PLAYSUPER_OP_200;
	}
	playPacket->m_pData[1] = BYTE(playPacket->m_pData[1] << 4);
	playPacket->m_pData[1] |= EffectCommandParity(*playPacket) & 0x0F;

	return SUCCESS;
}

HRESULT DataPackager200::StopEffect(DWORD downloadID)
{
	// Special case for putrawforce (Cannot stop - this is up for discussion)
	if ((downloadID == SYSTEM_EFFECT_ID) || (downloadID == RAW_FORCE_ALIAS)) {
		ClearPackets();
		return S_FALSE;
	}

	// Remap alias ID properly
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = ID_RTCSPRING_200;		// Jolt returned ID0 for RTC Spring so return send alias ID
	}

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ASSUME_NOT_REACHED();
		ClearPackets();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* stopPacket = GetPacket(0);
	if (!stopPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	stopPacket->m_pData[0] = EFFECT_CMD_200;
	stopPacket->m_pData[1] = BYTE(STOP_OP_200 << 4);
	stopPacket->m_pData[2] = BYTE(downloadID);
	stopPacket->m_pData[1] |= EffectCommandParity(*stopPacket) & 0x0F;
	stopPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_STOPEFFECT);
	stopPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	stopPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::GetEffectStatus(DWORD downloadID)
{
	// Special case RTC Spring ID
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = ID_RTCSPRING_200;	// Jolt returned ID0 for RTC Spring so return send alias ID	
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for status effect command
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	packet->m_pData[0] = EFFECT_CMD_200;
	packet->m_pData[1] = BYTE(STATUS_OP_200 << 4);
	packet->m_pData[2] = BYTE(downloadID);
	packet->m_pData[1] |= EffectCommandParity(*packet) & 0x0F;
	packet->m_AckNackMethod = ACKNACK_BUTTONSTATUS;
	packet->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay;
	packet->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;

}

HRESULT DataPackager200::ForceOut(LONG forceData, ULONG axisMask)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* pPacket = GetPacket(0);
	if (!pPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	pPacket->m_pData[0] = EFFECT_CMD_200;
	switch (axisMask) {
		case X_AXIS: {
			pPacket->m_pData[1] = BYTE(FORCEX_OP_200 << 4); break;
		}
		case Y_AXIS: {
			pPacket->m_pData[1] = BYTE(FORCEY_OP_200 << 4); break;
		}
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	BYTE calc = BYTE((PERCENT_SHIFT - forceData)/PERCENT_TO_DEVICE);
	pPacket->m_pData[2] = BYTE(calc & 0x7f);
	pPacket->m_pData[1] |= EffectCommandParity(*pPacket) & 0x0F;

	pPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	pPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_effct\vxdioctl.cpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.CPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for communicating with VJoyD min-driver specific
    				to Jolt Midi device
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				17-Jun-97	MEA		Added MAX_RETRY_COUNT on IOCTLs
				20-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				20-Mar-99	waltw	Nuked unused IsHandleValid

****************************************************************************/

#include "vxdioctl.hpp"
//#include <crtdbg.h>			// For RPT macros
#include <WINIOCTL.H>		// For IOCTL definitions (CTL_CODE)
#include "FFDevice.h"		// For g_ForceFeedbackDevice
#include "sw_error.hpp"		// For Sidewinder HRESULT Error codes
#include "hau_midi.hpp"		// For MAX_RETRY_COUNT and others
#include "midi_obj.hpp"		// Global Jolt midi object and definition
#include "JoyRegst.hpp"		// The differnt types of ACK_NACK
#include "DTrans.h"			// For global Data Transmitter

DriverCommunicator* g_pDriverCommunicator = NULL;
extern DataTransmitter* g_pDataTransmitter;
extern HINSTANCE g_MyInstance;


// Bitmasks for FW Version 
#define FW_MAJOR_VERSION			0x40		// Bit 6
#define FW_MINOR_VERSION			0x3F		// Bit 5-0
#define FW_PRODUCT_ID				0xff

// Bitmasks for Get Status packet dwDeviceStatus member
#define ERROR_STATUS_MASK			0x07		// only bits 0-2 valid


/********************************** HIDFeatureCommunicator class ***********************************/

/****************************************
**
**	HIDFeatureCommunicator::HIDFeatureCommunicator()
**
**	@mfunc Constructor for VxD Communications path
**
*****************************************/
HIDFeatureCommunicator::HIDFeatureCommunicator() :
	DriverCommunicator(),
	m_ForceFeature()
{
}

/****************************************
**
**	HIDFeatureCommunicator::~HIDFeatureCommunicator()
**
**	@mfunc Destructor for VxD communications path
**
*****************************************/
HIDFeatureCommunicator::~HIDFeatureCommunicator()
{
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::Initialize(UINT uJoystickId)
**
**	@mfunc Opens the driver for communications via IOCTLs
**
**	@rdesc TRUE if driver opened, FALSE otherwise
**
*****************************************/
BOOL HIDFeatureCommunicator::Initialize
(
	UINT uJoystickId //@parm Joystick ID to use
)
{
	if (g_ForceFeedbackDevice.IsOSNT5() == FALSE)
	{	// Only allowable on NT5
		return FALSE;
	}

	return (SUCCEEDED(m_ForceFeature.Initialize(uJoystickId, g_MyInstance)));
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::ResetDevice()
**
**	@mfunc Sends the driver a device reset IOCTL
**
**	@rdesc S_OK if IOCTL suceeds, 
**
*****************************************/
HRESULT HIDFeatureCommunicator::ResetDevice()
{
	return m_ForceFeature.DoReset();
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor)
**
**	@mfunc IOCTLs a version request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetDriverVersion
(
	DWORD& rdwMajor,	//@parm reference to returned major part of version
	DWORD& rdwMinor		//@parm reference to returned minor part of version
)
{
	ULONG ulVersion = m_ForceFeature.GetVersion();
	rdwMajor = (ulVersion >> 16) & 0x0000FFFF;
	rdwMinor = ulVersion & 0x0000FFFF;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetID(LOCAL_PRODUCT_ID& rProductID)
**
**	@mfunc IOCTLs a product id request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetID
(
	LOCAL_PRODUCT_ID& rProductID	//@parm reference to local product id structure for return value
)
{
	if (rProductID.cBytes != sizeof LOCAL_PRODUCT_ID)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Create report packet and request
	PRODUCT_ID_REPORT productIDReport;
	productIDReport.ProductId.cBytes = sizeof PRODUCT_ID;
	HRESULT hr = m_ForceFeature.GetId(productIDReport);
	if (FAILED(hr))
	{	// There was a problem
		return hr;
	}

	// Decode to local packet
	rProductID.dwProductID = productIDReport.ProductId.dwProductID & FW_PRODUCT_ID;
	rProductID.dwFWMajVersion = 1;
	if (productIDReport.ProductId.dwFWVersion & FW_MAJOR_VERSION)
	{
		rProductID.dwFWMajVersion++;
	}
	rProductID.dwFWMinVersion = productIDReport.ProductId.dwFWVersion & FW_MINOR_VERSION;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatus(JOYCHANNELSTATUS& rChannelStatus)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatus
(
	JOYCHANNELSTATUS& rChannelStatus	//@parm reference to status packet for result
)
{
	if (rChannelStatus.cBytes != sizeof JOYCHANNELSTATUS)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create report packet and perform request
	JOYCHANNELSTATUS_REPORT statusReport;
	statusReport.JoyChannelStatus.cBytes = sizeof JOYCHANNELSTATUS;

	HRESULT hr = S_OK;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		hr = m_ForceFeature.GetStatus(statusReport);

		if (FAILED(hr))
		{	// There was a problem
			if (i > 5)
			{
				Sleep(1);
			}
		}
		else
		{
			break;
		}
	}

	if (SUCCEEDED(hr))
	{	// Get the data from report packet
		::memcpy(&rChannelStatus, &(statusReport.JoyChannelStatus), sizeof JOYCHANNELSTATUS);
	}
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetAckNack
(
	ACKNACK& rAckNack,	//@parm Structure for return of acking
	USHORT usRegIndex	//@parm Index to what type of ack/nack to do
)
{
	if (rAckNack.cBytes != sizeof ACKNACK)
	{	// Invalid structure size
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Determine how to get the result
	switch (g_ForceFeedbackDevice.GetAckNackMethod(usRegIndex))
	{
		case ACKNACK_NOTHING:
		{	// This one is real easy - do nothing
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		case ACKNACK_BUTTONSTATUS:
		{	// Look at the button status (status gate)
			ULONG_REPORT report;
			HRESULT hr = m_ForceFeature.GetAckNak(report);
			if (FAILED(hr))
			{	// There was a problem
				return hr;
			}

			if (report.uLong & ACKNACK_MASK_200)
			{ // NACK error, so get Error code
				rAckNack.dwAckNack = NACK;
				JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
				if (FAILED(hr = GetStatus(statusPacket)))
				{	// Failed to get status error
					return hr;
				}
				rAckNack.dwErrorCode = (statusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return S_OK;
			}
			// ACK success
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;

			if (report.uLong & RUNNING_MASK_200)
			{	// Current driver and effect running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			}
			else
			{	// Effect not running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return S_OK;
		}
		case ACKNACK_STATUSPACKET:
		{	// Use the Status Packet Error code field to determine ACK or NACK and Get Error code
			JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
 
			HRESULT hr = GetStatus(statusPacket);
			if (FAILED(hr))
			{	// Failed (retried inside GetStatus)
				return SFERR_DRIVER_ERROR;
			}
			rAckNack.dwErrorCode = statusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
			rAckNack.dwAckNack = (rAckNack.dwErrorCode) ? NACK : ACK;
			return S_OK;
		}
		default:
		{	// Someone put garbage in the registry (do nothing)
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		
	}

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatusGateData(DWORD& rdwGateData)
**
**	@mfunc IOCTLs a status gate request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatusGateData
(
	DWORD& rdwGateData	//@parm reference to return gate data
)
{
	ULONG_REPORT report;
	HRESULT hr = m_ForceFeature.GetAckNak(report);
	rdwGateData = report.uLong;
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::SendBackdoorShortMidi(DWORD dwMidiMessage)
**
**	@mfunc IOCTLs a request sending a message through midi backdoor
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::SendBackdoorShortMidi
(
	DWORD dwMidiMessage	//@parm Midi Channel Message to send via IOCTL
)
{
	// Byte count
	short int sByteCount = 3;
	BYTE bCmd = BYTE(dwMidiMessage & 0xF0);
	if ((bCmd == 0xC0 ) || (bCmd == 0xD0)) {
		sByteCount = 2;
	}

	// Send via data transmitter
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send((BYTE*)(&dwMidiMessage), sByteCount)) {
			return S_OK;
		}
        return SFERR_DRIVER_ERROR;
	}

	// Must use the data transmitter there is no backdoor in NT5
	return E_FAIL;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::SendBackdoorLongMidi(BYTE* pMidiData)
**
**	@mfunc IOCTLs a request sending a message through midi backdoor
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::SendBackdoorLongMidi
(
	BYTE* pMidiData	//@parm Array of bytes to send out
)
{
	// Count the bytes
	short int sByteCount = 1;
	while (!(pMidiData[sByteCount++] & 0x80));

	// Send via data transmitter?
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send(pMidiData, sByteCount)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// There is no real backdoor in NT
	return E_FAIL;
}

/********************************** Old dead code ***********************************/
#if 0
#include <windows.h>

#include <WINIOCTL.H>

#include "vxdioctl.hpp"
#include "SW_error.hpp"
#include "version.h"
#include "hau_midi.hpp"
#include "midi_obj.hpp"

#include "DTrans.h"
#include "FFDevice.h"
#include "joyregst.hpp"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

#ifdef _DEBUG
extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
#define DebugOut(x)
#endif _DEBUG


extern DataTransmitter* g_pDataTransmitter;
DWORD g_PreviousShortMidi = 0;

class CJoltMidi;
extern CJoltMidi *g_pJoltMidi;

//
// --- IOCTL Functions
//
/****************************************************************************

    FUNCTION:   GetDevice

	PARAMETERS:	IN const char* vxdName	- Name of VxD

	RETURNS:	valid HANDLE if successful or NULL

   	COMMENTS:	

****************************************************************************/
HANDLE WINAPI GetDevice(
	IN const char* vxdName)
{
	char fileName[64];
	HANDLE retVal;

	if (g_ForceFeedbackDevice.IsOSNT5()) { // Need to start MSGameIO
		try {
			// Open the Service Control Managere
			SC_HANDLE serviceControlManager = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (serviceControlManager == NULL) {
				throw 0;
			}
			// Open the Service
			SC_HANDLE ring0DriverService = ::OpenService(serviceControlManager, vxdName, SERVICE_QUERY_STATUS | SERVICE_START);
			if (ring0DriverService == NULL) {
				throw 0;
			}
			// Start for service
			if (!::StartService(ring0DriverService, 0, NULL)) {
				throw 0;
			}
			// Did it start yet - Do some fancy waiting
			SERVICE_STATUS serviceStatus;
			DWORD lastCheckPoint = 0;
			do {
				if (!::QueryServiceStatus(ring0DriverService, &serviceStatus)) {
					throw 0;
				}
				if (serviceStatus.dwCurrentState == SERVICE_START_PENDING) {
					if (serviceStatus.dwCheckPoint <= lastCheckPoint) {
						DebugOut("Failed to start service\r\n");
						break;	
					}
					lastCheckPoint = serviceStatus.dwCheckPoint;
					::Sleep(serviceStatus.dwWaitHint);
				} else {
					DebugOut("Service Started (maybe), Yeah!\r\n");
					break;
				}
			} while (1);
			::CloseServiceHandle(ring0DriverService);		// Close the Ring0 Handle
			::CloseServiceHandle(serviceControlManager);	// Close the service control manager handle
		} catch(...) {
			DWORD errorCode = ::GetLastError();
			if (errorCode == ERROR_ACCESS_DENIED) {	// We are screwed
				DebugOut("Access is denied\r\n");
			} else {
				DebugOut("Unable to start service\r\n");
			}
		}
	}


	wsprintf(fileName, "\\\\.\\%s", vxdName);
	retVal = CreateFile(fileName, GENERIC_READ | GENERIC_WRITE,
		0, 0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
#ifdef _DEBUG
	wsprintf(g_cMsg, "GetDevice: %s -- Vxd Handle: 0x%X\r\n", vxdName, retVal);
	OutputDebugString(g_cMsg);
#endif
	return retVal;
}

/****************************************************************************

    FUNCTION:   CloseDevice

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle

	RETURNS:	BOOL TRUE if successful else FALSE

   	COMMENTS:	

****************************************************************************/
BOOL WINAPI CloseDevice(
	IN HANDLE hVxD)
{
	if (hVxD != INVALID_HANDLE_VALUE)
		return (CloseHandle(hVxD));
	return FALSE;
}


/****************************************************************************

    FUNCTION:   QueryDriverVersion

	PARAMETERS:	DWORD& major, DWORD& minor - Major and Minor parts of driver version

	RETURNS:	BOOL TRUE if successful else FALSE

   	COMMENTS:	

****************************************************************************/
HRESULT QueryDriverVersion(DWORD& major, DWORD& minor)
{
	if ((g_pJoltMidi == NULL) || (g_pJoltMidi->VxDHandleOf() == INVALID_HANDLE_VALUE)) {
		return SFERR_DRIVER_ERROR;
	}

	DWORD version = 0x00000000;
	DWORD bytesReturned = 0;
//	HRESULT hr = DeviceIoControl(g_pJoltMidi->VxDHandleOf(), DIOC_GETVERSION, NULL, 0, &version, 4, &bytesReturned, NULL);
	if (::DeviceIoControl(g_pJoltMidi->VxDHandleOf(), IOCTL_GET_VERSION, NULL, 0, &version, 4, &bytesReturned, NULL)) {
		major = (version >> 16) & 0x0000FFFF;
		minor = version & 0x0000FFFF;
	}
	return S_OK;
}


/****************************************************************************

    FUNCTION:   GetDataPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PJOYCHANNELDATA pDataPacket	- Pointer to JOYCHANNELDATA
									structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	No longer a valid IOCTL (mlc)

****************************************************************************/
HRESULT WINAPI GetDataPacket(
	IN HANDLE hDevice,
	IN OUT PJOYCHANNELDATA pDataPacket)
{
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   GetStatusPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PJOYCHANNELSTATUS pStatusPacket	- Pointer to
									JOYCHANNELSTATUS structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetStatusPacket(
	IN HANDLE hDevice, 
	IN OUT PJOYCHANNELSTATUS pStatusPacket)
{
	DWORD   dwBytesReturned;

	if (INVALID_HANDLE_VALUE == hDevice) {
		return SFERR_DRIVER_ERROR;
	}

	if (pStatusPacket->cBytes != sizeof(JOYCHANNELSTATUS)) {
		return (SFERR_INVALID_STRUCT_SIZE);
	}

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETSTATUS : IOCTL_GET_STATUSPACKET;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		// Send the IOCTL
		BOOL bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
                               (LPVOID) pStatusPacket,
                               (DWORD)  sizeof(JOYCHANNELSTATUS),
                               (LPVOID) pStatusPacket,
                               (DWORD)  sizeof(JOYCHANNELSTATUS),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 


		if (bRetFlag) {
			// Convert values to a signed LONG
			pStatusPacket->dwXVel = (LONG)((char)(pStatusPacket->dwXVel));
			pStatusPacket->dwYVel = (LONG)((char)(pStatusPacket->dwYVel));
			pStatusPacket->dwXAccel = (LONG)((char)(pStatusPacket->dwXAccel));
			pStatusPacket->dwXAccel = (LONG)((char)(pStatusPacket->dwYAccel));
			return SUCCESS;
		}
		if(i>5) {
			Sleep(1);
		}

	}
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   GetIDPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PPRODUCT_ID pID	- Pointer to PRODUCT_ID structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetIDPacket(
	IN HANDLE hDevice, 
	IN OUT PPRODUCT_ID pID)
{
	DWORD   dwBytesReturned;

	if (INVALID_HANDLE_VALUE == hDevice)
		return SFERR_DRIVER_ERROR;

	if (pID->cBytes != sizeof(PRODUCT_ID))
		return (SFERR_INVALID_STRUCT_SIZE);

	JOYCHANNELID IDPacket = {sizeof(JOYCHANNELID)};

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETID : IOCTL_GET_IDPACKET;
	for (int i=0; i<MAX_RETRY_COUNT; i++)
	{
		// Send the IOCTL
		BOOL bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
								(LPVOID) &IDPacket,
								(DWORD)  sizeof(JOYCHANNELID),
								(LPVOID) &IDPacket,
								(DWORD)  sizeof(JOYCHANNELID),
								(LPDWORD)  &dwBytesReturned,
								(LPOVERLAPPED) NULL); 

		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetIDPacketDelay);	

		// Any error codes are returned in the first DWORD of the structure
		if (bRetFlag) {
			pID->dwProductID = IDPacket.dwProductID & FW_PRODUCT_ID;
			pID->dwFWMajVersion = 1;
			if (IDPacket.dwFWVersion & FW_MAJOR_VERSION) 
				pID->dwFWMajVersion++;
			pID->dwFWMinVersion = IDPacket.dwFWVersion & FW_MINOR_VERSION;
			return SUCCESS;
		}                                          
	}
	return SFERR_DRIVER_ERROR;
}

/****************************************************************************

    FUNCTION:   GetDiagnostics

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PDIAGNOSTIC_COUNTER pDiagnostics	- Pointer to
									DIAGNOSTIC_COUNTER structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetDiagnostics(
	IN HANDLE hDevice, 
	IN OUT PDIAGNOSTIC_COUNTER pDiagnostics)
{
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	if (pDiagnostics->cBytes != sizeof(DIAGNOSTIC_COUNTER))
		return (SFERR_INVALID_STRUCT_SIZE);

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
                               (DWORD)  IOCTL_GET_DIAGNOSTICS,
                               (LPVOID) pDiagnostics,
                               (DWORD)  sizeof(DIAGNOSTIC_COUNTER),
                               (LPVOID) pDiagnostics,
                               (DWORD)  sizeof(DIAGNOSTIC_COUNTER),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 
    // Any error codes are returned in the first DWORD of the structure
    if (!bRetFlag || (dwBytesReturned != sizeof(DIAGNOSTIC_COUNTER)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);
}


/****************************************************************************

    FUNCTION:   GetAckNack

	PARAMETERS:	IN HANDLE hVxD 				-	valid VxD Handle
				IN OUT PACKNACK pAckNack	- Pointer to ACKNACK structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	
	typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

****************************************************************************/
HRESULT WINAPI GetAckNack(
	IN HANDLE hDevice,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex)
{
	if (INVALID_HANDLE_VALUE == hDevice) {
		return SFERR_DRIVER_ERROR;
	}

	if (pAckNack->cBytes != sizeof(ACKNACK)) {
		return SFERR_INVALID_STRUCT_SIZE;
	}

	switch (g_ForceFeedbackDevice.GetAckNackMethod(regindex)) {
		case ACKNACK_NOTHING: {
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;
			return SUCCESS;
		}
		case ACKNACK_BUTTONSTATUS: {
			DWORD   dwBytesReturned;
			BOOL    bRetFlag;
			DWORD	dwIn;

			DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETACKNACK : IOCTL_GET_ACKNACK;

			// Send the IOCTL
			bRetFlag = DeviceIoControl(hDevice,
										ioctlID,
									   (LPVOID) &dwIn,
									   (DWORD)  sizeof(DWORD),
									   (LPVOID) &dwIn,
									   (DWORD)  sizeof(DWORD),
									   (LPDWORD)  &dwBytesReturned,
									   (LPOVERLAPPED) NULL); 
  
			if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) ) {
				return (SFERR_DRIVER_ERROR);
			}                                          

			if (((g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (dwIn & ACKNACK_MASK_1XX))
					|| ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & ACKNACK_MASK_200))) { // NACK error, so get Error code
				pAckNack->dwAckNack = NACK;
				JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};
				if (FAILED(GetStatusPacket(hDevice, &StatusPacket))) {
					return (SFERR_DRIVER_ERROR);
				}
				pAckNack->dwErrorCode = (StatusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return SUCCESS;
			}
			// ACK success
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;

			if (((g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (dwIn & RUNNING_MASK_1XX))
					|| ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & RUNNING_MASK_200))) {
				pAckNack->dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			} else {
				pAckNack->dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return SUCCESS;
		}
		case ACKNACK_STATUSPACKET: {
			// Use the Status Packet Error code field to determine ACK or NACK
			// Get Error code
			JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};
 
			HRESULT hRet = GetStatusPacket(hDevice, &StatusPacket);		// Retry count in GetStatusPacket function
			if (FAILED(hRet)) {
				DebugOut("GetStatusPacket Error\n");
				hRet = SFERR_DRIVER_ERROR;
			} else {
				pAckNack->dwErrorCode = StatusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
				pAckNack->dwAckNack = (pAckNack->dwErrorCode) ? NACK : ACK;
			}
			return hRet;
		}
		default: {	// Someone put garbage in the registry (do nothing)
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;
			return SUCCESS;
		}
		
	}
}


/****************************************************************************

    FUNCTION:   GetStatusGateData

	PARAMETERS:	IN HANDLE hVxD 					- valid VxD Handle
				IN OUT DWORD *pdwStatusGateData	- Pointer to Status Gate

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetStatusGateData(
	IN HANDLE hDevice,
	IN OUT DWORD *pdwStatusGateData)
{
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	HRESULT hRet = SFERR_DRIVER_ERROR;
	if (INVALID_HANDLE_VALUE == hDevice)
		return (hRet);

	if (NULL == pdwStatusGateData)
		return (SFERR_INVALID_PARAM);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETACKNACK : IOCTL_GET_ACKNACK;
	for (int i=0; i<MAX_RETRY_COUNT; i++)
	{
		// Obtain Status Gate data
		// Send the IOCTL
		bRetFlag = DeviceIoControl(hDevice,
                               ioctlID,
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 

		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusGateDataDelay);	

  
		if (bRetFlag && (dwBytesReturned == sizeof(DWORD)))
		{
			hRet = SUCCESS;
			break;
		}                                          
	}

	*pdwStatusGateData = dwIn;
	return (hRet);
}


/****************************************************************************

    FUNCTION:   SendBackDoorShortMidi

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulData 	- DWORD to send
	RETURNS:	

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI SendBackDoorShortMidi(
	IN HANDLE hDevice,
	IN ULONG ulData)
{
#ifdef _DEBUG
//	wsprintf(g_cMsg, "SendBackDoorShortMidi Data=%.8lx\r\n", ulData);
//	OutputDebugString(g_cMsg);
#endif
	DWORD	dwIn;
	DWORD   bytesReturned;

	// Byte count
	int numBytes = 3;
	DWORD cmd = ulData & 0xF0;
	if ((cmd == 0xC0 ) || (cmd == 0xD0)) {
		numBytes = 2;
	}

	// Send via data transmitter
	if (g_pDataTransmitter != NULL) {
		g_PreviousShortMidi = ulData;
		if (g_pDataTransmitter->Send((BYTE*)(&ulData), numBytes)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// Is there a proper ring0 driver?
	if (INVALID_HANDLE_VALUE == hDevice) {
		return (SFERR_DRIVER_ERROR);
	}

	// Send via new single send IOCTL
	if (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) {
		if (DeviceIoControl(hDevice, IOCTL_SWFORCE_SENDDATA, (void*)&ulData, DWORD(numBytes),
									(void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
									(LPOVERLAPPED) NULL)) {
			if (bytesReturned == DWORD(numBytes)) {
				return SUCCESS;
			}
		}
    
		return SFERR_DRIVER_ERROR;
	}

	// Send the IOCTL the old way
    if (DeviceIoControl(hDevice, IOCTL_MIDISENDSHORTMSG, (void*)&ulData, sizeof(DWORD),
                               (void*)&dwIn, sizeof(DWORD), &bytesReturned,
                               (LPOVERLAPPED) NULL)) {
		if (bytesReturned == sizeof(DWORD)) {
				return (SUCCESS);

		}
	}
	return SFERR_DRIVER_ERROR;
}

/****************************************************************************

    FUNCTION:   SendBackDoorLongMidi

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulData 	- DWORD to send
	RETURNS:	

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI SendBackDoorLongMidi(
	IN HANDLE hDevice,
	IN PBYTE  pData)
{
#ifdef _VERBOSE
#pragma message("Compiling with VERBOSE mode")
#ifdef _DEBUG
	wsprintf(g_cMsg, "SendBackDoorLongMidi pData\n%.2x ", pData[0]);
	OutputDebugString(g_cMsg);
	int i=1;
	while(TRUE)
	{
		wsprintf(g_cMsg,"%.2x ", pData[i]);
		OutputDebugString(g_cMsg);
		if (pData[i] & 0x80) 
			break;
		else
			i++;
	}
	OutputDebugString("\n");
#endif

#endif
	DWORD	dwIn;
	DWORD   bytesReturned;

	// Count the bytes
	int numBytes = 1;
	while (!(pData[numBytes++] & 0x80));

	// Send via data transmitter?
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send(pData, numBytes)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// Is there a proper ring0 driver?
	if (INVALID_HANDLE_VALUE == hDevice) {
		return (SFERR_DRIVER_ERROR);
	}

	// Send via new single send IOCTL
	if (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) {
		if (DeviceIoControl(hDevice, IOCTL_SWFORCE_SENDDATA, (void*)pData, DWORD(numBytes),
									(void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
									(LPOVERLAPPED) NULL)) {
			if (bytesReturned == DWORD(numBytes)) {
				return SUCCESS;
			}
		}
    
		return SFERR_DRIVER_ERROR;
	}

	// Send the IOCTL the old way
    if (DeviceIoControl(hDevice, IOCTL_MIDISENDLONGMSG, (void*)pData, sizeof(DWORD),
                               (void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
                               (LPOVERLAPPED) NULL)) {
		if (bytesReturned == sizeof(DWORD)) {
			return SUCCESS;
		}
	}
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   SetMidiPort

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulPort 	- Port #
	RETURNS:	

   	COMMENTS:	
				  0 = DEFAULT MIDI UART 330
				  1 = COM1
				  2 = COM2
				  3 = COM3
				  4 = COM4
				  or other MIDI port 340, etc...

****************************************************************************/
HRESULT WINAPI SetMidiPort(
	IN HANDLE hDevice,
	IN ULONG  ulPort)
{
	if (g_ForceFeedbackDevice.IsOSNT5()) {
		return SUCCESS;
	}

#ifdef _DEBUG
	wsprintf(g_cMsg, "SetMidiPort Port %lx\r\n", ulPort);
	OutputDebugString(g_cMsg);
#endif
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_SETPORT : IOCTL_SET_MIDIPORT;

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
                               ioctlID,
                               (LPVOID) &ulPort,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL);
    
    if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);

}

/****************************************************************************

    FUNCTION:   JoltHWReset

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd

	RETURNS:	

   	COMMENTS:	
				  Jolt is Reset (4 knocks)

****************************************************************************/
HRESULT WINAPI JoltHWReset(
	IN HANDLE hDevice)
{
#ifdef _DEBUG
	wsprintf(g_cMsg, "JoltHWReset\r\n");
	OutputDebugString(g_cMsg);
#endif

	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_RESET : IOCTL_HW_RESET;

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
                               (LPVOID) NULL,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 
    
    if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dpack.h ===
//@doc
/******************************************************
**
** @module DPACK.H | Definition file for DataPackager and DataPacket
**
** Description:
**		The Data Packager allows virtualization of the
**	commands into the different firmware versions packet format
**		DataPackager - Base class that defines the functionality of all DataPackagers
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**
** Classes:
**		DataPackager
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**		DataPacket - Array of bytes for download. If there are 32 or less items
**				it is fixed on the stack if more are requested it is heap based.
**				(most things use less than 32)
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DPACK_H__
#define	__DPACK_H__

#include "DX_Map.hpp"

#ifndef override
#define override
#endif

#define MODIFY_CMD_200	0xF1
#define EFFECT_CMD_200	0xF2

class InternalEffect;

//
// @class DataPacket class
//
class DataPacket
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPacket();
		~DataPacket();

		BOOL AllocateBytes(DWORD numBytes);

		BYTE* m_pData;
		BYTE m_pFixedData[32];
		DWORD m_BytesOfData;
		UINT m_AckNackMethod;
		DWORD m_AckNackDelay;
		DWORD m_AckNackTimeout;
		DWORD m_NumberOfRetries;
};
typedef DataPacket* DataPacketPtr;

//
// @class DataPackager class
//
class DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager();
		virtual ~DataPackager();

		void SetDirectInputVersion(DWORD diVersion) { m_DirectInputVersion = diVersion; }

		// Commands to be packaged
		virtual HRESULT Escape(DWORD effectID, LPDIEFFESCAPE pEscape);
		virtual HRESULT SetGain(DWORD gain);
		virtual HRESULT SendForceFeedbackCommand(DWORD state);
		virtual HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		virtual HRESULT CreateEffect(const InternalEffect& effect, DWORD diFlags);
		virtual HRESULT ModifyEffect(InternalEffect& currentEffect, InternalEffect& newEffect, DWORD modFlags);
		virtual HRESULT DestroyEffect(DWORD downloadID);
		virtual HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		virtual HRESULT StopEffect(DWORD downloadID);
		virtual HRESULT GetEffectStatus(DWORD downloadID);
		virtual HRESULT SetMidiChannel(BYTE channel);
		virtual HRESULT ForceOut(LONG lForceData, ULONG ulAxisMask);

		// Access to packages
		USHORT GetNumDataPackets() const { return m_NumDataPackets; }
		DataPacket* GetPacket(USHORT packet) const;

		void ClearPackets();
		BOOL AllocateDataPackets(USHORT numPackets);
	private:
		DataPacket* m_pDataPackets;
		DataPacket m_pStaticPackets[3];
		USHORT m_NumDataPackets;
		DWORD m_DirectInputVersion;
};

//
// @class DataPackager class
//
class DataPackager100 : public DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager100() : DataPackager() {};

		// Commands to be packaged
		override HRESULT SetGain(DWORD gain);
		override HRESULT SendForceFeedbackCommand(DWORD state);
		override HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		override HRESULT DestroyEffect(DWORD downloadID);
		override HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		override HRESULT StopEffect(DWORD downloadID);
		override HRESULT GetEffectStatus(DWORD downloadID);
		override HRESULT SetMidiChannel(BYTE channel);
		override HRESULT ForceOut(LONG lForceData, ULONG ulAxisMask);
};

//
// @class DataPackager class
//
class DataPackager200 : public DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager200() : DataPackager() {};

		// Commands to be packaged
		override HRESULT SetGain(DWORD gain);
		override HRESULT SendForceFeedbackCommand(DWORD state);
		override HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		override HRESULT CreateEffect(const InternalEffect& effect, DWORD diFlags);
		override HRESULT DestroyEffect(DWORD downloadID);
		override HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		override HRESULT StopEffect(DWORD downloadID);
		override HRESULT GetEffectStatus(DWORD downloadID);
		override HRESULT ForceOut(LONG forceData, ULONG axisMask);
	private:
		BYTE EffectCommandParity(const DataPacket& packet) const;
		BYTE DeviceCommandParity(const DataPacket& packet) const;
};

extern DataPackager* g_pDataPackager;

#endif	__DPACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dx_map.hpp ===
/****************************************************************************

    MODULE:     	DX_MAP.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Mapper for converting SWForce FFD_ to DirectInput Force
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	14-Feb-97       MEA     original
        
****************************************************************************/
#ifndef _DX_MAP_SEEN
#define _DX_MAP_SEEN
#include <windows.h>
#include "dinput.h"
#include "dinputd.h"


// Diagnostics Counters
typedef struct _DIAG_COUNTER
{
	ULONG			m_NACKCounter;		// For Debugging, how many NACKS
	ULONG			m_LongMsgCounter;  	// How many SysEx messages
	ULONG			m_ShortMsgCounter;	// How many 3 byte Short messages
	ULONG			m_RetryCounter;		// Number of retries
} DIAG_COUNTER, *PDIAG_COUNTER;

//
// --- Mapping from DX to SWForce FFD
//

typedef struct IDirectInputEffect	 *PSWEFFECT;  
typedef struct IDirectInputEffect	**PPSWEFFECT;  

#define SW_NUMBER_OF_BUTTONS 9

#define DNHANDLE	USHORT		// Download Effect Handle type
#define PDNHANDLE	DNHANDLE *	// Pointer

#define MIN_ANGLE			0
#define MAX_ANGLE			36000
#define MIN_FORCEOUTPUTRATE 1
#define MIN_GAIN			1
#define MAX_GAIN			10000
#define MAX_FORCE			10000
#define MIN_FORCE			-10000
#define MIN_TIME_PERIOD		1
#define MAX_TIME_PERIOD		4294967296L	// 4096 * 10^^6 usecs
#define MAX_POSITION		10000
#define MIN_POSITION		-10000
#define MAX_CONSTANT		10000
#define MIN_CONSTANT		-10000

#define SCALE_GAIN			100		// DX is +/- 10000, SWForce in +/-100
#define SCALE_TIME			1000	// DX is in microseconds, SWForce in msec
#define	SCALE_POSITION		100		// DX is +/- 10000, SWForce in +/- 100+
#define	SCALE_CONSTANTS		100		// DX is +/- 10000, SWForce in +/- 100+
#define SCALE_DIRECTION		100		// DX is 0 to 35900, SWForce is 0 to 359

// 
// --- Default Values
//
#define	DEFAULT_OFFSET			0
#define DEFAULT_ATTACK_LEVEL	0
#define DEFAULT_ATTACK_TIME		0
#define DEFAULT_SUSTAIN_LEVEL	10000
#define DEFAULT_FADE_LEVEL		0
#define DEFAULT_FADE_TIME		0

// PlaybackEffect Command Modes
#define PLAY_SUPERIMPOSE	0x01
#define PLAY_SOLO			0x02
#define PLAY_STORE			0x04	// Store only
#define PLAY_UPDATE			0x08
//reserved					0x10
#define PLAY_LOOP			0x20
#define PLAY_FOREVER		0x40
#define PLAY_STOP			0x80
#define PLAY_MODE_MASK		0xff

#define DEV_SHUTDOWN		DEV_RESET

//
// --- Effect Status
//
#define ES_HOST			0x00000001L	// Effect is in HOST memory
#define ES_DOWNLOADED	0x00000002L	// Effect is downloaded
#define ES_STOPPED		0x00000004L	// Effect is stopped
#define ES_PLAYING		0x00000008L	// Effect is playing

//
// --- Axis Masks
//
#define X_AXIS		0x01
#define Y_AXIS		0x02
#define Z_AXIS		0x04
#define ROT_X_AXIS	0x08
#define ROT_Y_AXIS	0x10
#define ROT_Z_AXIS	0x20

//
// --- Button Masks
//
#define BUTTON1_PLAY 	0x00000001L	// Trigger button (usually)
#define BUTTON2_PLAY	0x00000002L
#define BUTTON3_PLAY	0x00000004L
#define BUTTON4_PLAY	0x00000008L
#define BUTTON5_PLAY	0x00000010L
#define BUTTON6_PLAY	0x00000020L
#define BUTTON7_PLAY	0x00000040L
#define BUTTON8_PLAY	0x00000080L
#define BUTTON9_PLAY	0x00000100L
#define BUTTON10_PLAY	0x00000200L
#define BUTTON11_PLAY	0x00000400L
#define BUTTON12_PLAY	0x00000800L
#define BUTTON13_PLAY	0x00001000L
#define BUTTON14_PLAY	0x00002000L
#define BUTTON15_PLAY	0x00004000L
#define BUTTON16_PLAY	0x00008000L	// . . . 16th button

// 
// --- Force Feedback Device State
//
typedef struct _SWDEVICESTATE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0 = Hands Off, 1 = Hands On
	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
} SWDEVICESTATE, *PSWDEVICESTATE;


#define MAX_SIZE_SNAME	64

//
//
// --- Force Feedback Device Capabilities
//
typedef struct _FFDEVICEINFO {
	ULONG	m_Bytes;		// Size of this structure
	TCHAR	m_ProductName[MAX_SIZE_SNAME];	// Device Name 64 chars
	TCHAR	m_ManufacturerName[MAX_SIZE_SNAME]; // Manufacturer
	ULONG	m_ProductVersion;	// Device Product Version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceDriverVersion;	// Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceFirmwareVersion; // Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_Interface;		// HIWORD: OUTPUT:HID_INTERFACE||VJOYD_INTERFACE 
								// LOWORD: INPUT: HID_INTERFACE||VJOYD_INTERFACE 
	ULONG	m_MaxSampleRate;	// Maximum Force output rate
	ULONG	m_MaxMemory;		// Max amount of RAM
	ULONG	m_NumberOfSensors;	// SENSOR_AXIS total in the device (INPUT)
	ULONG	m_NumberOfAxes;		// ACTUATOR_AXIS total in the device (OUTPUT)
	ULONG	m_EffectsCaps;		// Built-in Effects capability
	ULONG	m_Reserved;			// 
	ULONG	m_JoystickID;		// VJOYD Joystick ID (0-based)
	ULONG	m_ExtraInfo;		// For future stuff
} FFDEVICEINFO, *PFFDEVICEINFO;


//
// --- AXISCAPS Sensor or Actuator Axes capabilities
//
typedef struct _AXISCAPS {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bit position for Actuator or Sensor Axes
	ULONG	m_LogicalExtentMin;	// Minimum logical extent
	ULONG	m_LogicalExtentMax;	// Maximum logical extent
	ULONG	m_PhysicalExtentMin;// Minimum physical extent
	ULONG	m_PhysicalExtentMax;// Maximum Physical extent
	ULONG	m_Units;			// HID style physical SI units
	ULONG	m_Resolution;		// Position increments per physical SI unit
	ULONG	m_ServoLoopRate;	// Loop rate in cycles/sec
} AXISCAPS, *PAXISCAPS;


typedef struct _FORCE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_DirectionAngle2D;	// From X-Axis = theta1
	LONG	m_DirectionAngle3D;	// From Z-Axis = (theta2, note: theta1+theta2)>= 90
	LONG	m_ForceValue;		// Actual force in +/- 100%
} FORCE, *PFORCE;


typedef struct _FORCECONTEXT {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_Position;			// Position along the Axis -32768 to +32767
	LONG	m_Velocity;			// Velocity in -32768 to +32767 units TBD
	LONG	m_Acceleration;		// Acceleration in -32768 to +32767 units TBD
} FORCECONTEXT, *PFORCECONTEXT;


// The following are Type Specific parameters structures
//
//

//
// -- an Effect structure
//
typedef struct _EFFECT {
	ULONG	m_Bytes;			// Size of this structure
	TCHAR	m_Name[MAX_SIZE_SNAME];
	ULONG	m_Type;				// Major Effect type, e.g. EF_BEHAVIOR, etc..
	ULONG	m_SubType;			// Minor Effect type, e.g. SE_xxx,BE_xxx,UD_xxx
	ULONG	m_AxisMask;			// Bitmask for axis to send the effect, 
								//   If NULL, use value from Device Capabilities
	ULONG	m_DirectionAngle2D;	// From Y-Axis (cone) = theta1
	ULONG	m_DirectionAngle3D;	// From Z-Axis (cone) = theta2
								//  note: theta1+theta2)>= 90
	ULONG	m_Duration;			// Duration in ms., 00 = infinite
	ULONG	m_ForceOutputRate;	// Sample Rate for Force Data output
	ULONG	m_Gain;				// Gain to apply, normally this is set
								// to 100. Gain is 1 to  100.
	ULONG	m_ButtonPlayMask;	// Mask to indicate which button to assign Effect
} EFFECT, *PEFFECT;


//
// --- ENVELOPE
//
// Note:  There are two types of Envelope control, using PERCENTAGE,
// and using TIME.  
// PERCENTAGE defines Envelope using Percentage for the Attack,Sustain and Decay
//
// TIME Envelope type will require the time in 1 millisecond increment, and
// m_StartAmp is the Amplitude to start the waveform, while m_EndAmp is used
// to decay or end the waveform. m_SustainAmp is used to set Sustain amplitude
//
#define PERCENTAGE	0x00000000	// Envelope is in percentage values
#define TIME		0x00000001	// Envelope is in 1 millisecond time increments

//For PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Note: Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline -->>> (m_MaxAmp - m_MinAmp)/2
// m_EndAmp = m_StartAmp;
//
//Valid Ranges:
//PERCENTAGE mode:  
//		m_Attack, m_Sustain, m_Decay = 1 to 100%, and must sum up to 100%
//TIME mode:
//		m_Attack = 0 to 32,768 ms,
//      m_Sustain = 0 to 32,768 ms
//      m_Decay = 0 to 32,768 ms.   (All are in 1 ms increments).
//Note: For an infinite duration (value in m_Duration = 0), the Effect will 
//      never decay and m_Decay is ignored.
//
// Envelopes are only valid for Synthesized Waveforms (SE_XXX) type
//
//
typedef struct _ENVELOPE {
	ULONG	m_Bytes;		// Size of this structure
	ULONG	m_Type;			// PERCENTAGE || TIME
	ULONG	m_Attack;		// Rise time to Sustain Value
							//  in % of Duration, or in msec Time
	ULONG	m_Sustain;		// Sustain time at Sustain Value in % Duration,
							//  or in msec Time
	ULONG	m_Decay;		// Decay time to Minimum Value,
							//  in % of Duration, or in msec Time
	ULONG	m_StartAmp;		// Amplitude to start the Envelope, from baseline		
	ULONG	m_EndAmp;		// Amplitude to End the Envelope, from baseline
	ULONG	m_SustainAmp;	// Amplitude to Sustain the Envelope, from baseline
} ENVELOPE, *PENVELOPE;


//
// ---	EF_BEHAVIOR = {BE_SPRINGxx||BE_DAMPERxx||BE_INTERTIAxx||BE_FRICTIONxx
//						||BE_WALL||BE_DELAY}
//  Note: Behavioral Effects do not have an Envelope.
//
typedef struct _BE_SPRING_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_Kconstant;		// K constant
	LONG	m_AxisCenter;		// Center of the function
} BE_SPRING_PARAM, *PBE_SPRING_PARAM;

typedef struct _BE_SPRING_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_XKconstant;		// X_Axis K constant
	LONG	m_XAxisCenter;		// X_Axis Center
	LONG	m_YKconstant;		// Y_Axis K constant
	LONG	m_YAxisCenter;		// Y_Axis Center
} BE_SPRING_2D_PARAM, *PBE_SPRING_2D_PARAM;

typedef struct _BE_DAMPER_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Bconstant;		// B constant
	LONG	m_V0;				// Initial Velocity
} BE_DAMPER_PARAM, *PBE_DAMPER_PARAM;

typedef struct _BE_DAMPER_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XBconstant;		// X_AXIS B constant
	LONG	m_XV0;				// X_AXIS Initial Velocity
	LONG	m_YBconstant;		// Y_Axis B constant
	LONG	m_YV0;				// Y_AXIS Initial Velocity
} BE_DAMPER_2D_PARAM, *PBE_DAMPER_2D_PARAM;

typedef struct _BE_INERTIA_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_Mconstant;		// M constant
	LONG	m_A0;				// Initial Acceleration
} BE_INERTIA_PARAM, *PBE_INERTIA_PARAM;

typedef struct _BE_INERTIA_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XMconstant;		// X_AXIS M constant
	LONG	m_XA0;				// X_AXIS Initial Acceleration
	LONG	m_YMconstant;		// Y_AXIS M constant
	LONG	m_YA0;				// Y_AXIS Initial Acceleration
} BE_INERTIA_2D_PARAM, *PBE_INERTIA_2D_PARAM;

typedef struct _BE_FRICTION_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Fconstant;        // F Friction constant
} BE_FRICTION_PARAM, *PBE_FRICTION_PARAM;

typedef struct _BE_FRICTION_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XFconstant;		// X_AXIS F Friction constant
	LONG	m_YFconstant;		// Y_AXIS F Friction constant
} BE_FRICTION_2D_PARAM, *PBE_FRICTION_2D_PARAM;

//
// --- WALL Effect
//
#define WALL_INNER			0	// Wall material:from center to Wall Distance
#define WALL_OUTER			1	// Wall material:greater than Wall Distance

typedef struct _BE_WALL_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG 	m_WallType;			// WALL_INNER or WALL_OUTER
	LONG	m_WallConstant;		// in +/- 10000%
	ULONG	m_WallAngle;		// 0 to 35900
	ULONG	m_WallDistance;		// Distance from Wall face normal to center. 0 to 100
} BE_WALL_PARAM, *PBE_WALL_PARAM;

//
// ---	DELAY Effect
//
// Use EFFECT.m_SubType = BE_DELAY
// This has no type specific parameters.
//

//
// ---	EF_SYNTHESIZED = {  SE_CONSTANT_FORCE||SE_SINE||SE_SQUARE||SE_RAMPUP
//						  ||SE_RAMPDN||SE_TRIANGLE||SE_SAWTOOTH}
typedef struct _SE_PARAM {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_Freq;				// Frequency in Hz units
	ULONG	m_SampleRate;		// Sample rate in Hz units
	LONG	m_MaxAmp;			// Maximum Amplitude in Force units
	LONG	m_MinAmp;			// Minimum Amplitude in Force units
} SE_PARAM, *PSE_PARAM;

//
// ---	EF_USER_DEFINED = { Waveform defined by the user }
//
// Subtype: UD_WAVEFORM
typedef struct _UD_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_NumVectors;		// Number of entries in the Array
	LONG *	m_pForceData;		// Ptr to an array of LONG Force values.
} UD_PARAM, *PUD_PARAM;

//
// { Process List defined by the user }
// Subtype: PL_CONCATENATE || PL_SUPERIMPOSE
//
typedef struct _PL_PARAM {
	ULONG		m_Bytes;		// Size of this structure
	ULONG		m_NumEffects;	// # of Effects in list
	PPSWEFFECT	m_pProcessList;	// Ptr to a list of ISWEffect pointers
} PL_PARAM, *PPL_PARAM;

//
// ---	EF_ROM_EFFECT = { ROM Built-in Waveforms defined by the OEM }
//
// This has no type specific parameters.
// Subtypes:  See further below

#define DEFAULT_ROM_EFFECT_GAIN		100		// Set dwGain to this for Default
											// ROM Effect gain
#define DEFAULT_ROM_EFFECT_DURATION	1000	// Set dwDuration to this for Default
											// ROM Effect Duration
#define DEFAULT_ROM_EFFECT_OUTPUTRATE	1000	// Set dwSampleRate to this for 
												// Default ROM Effect output rate

//
// ---	EF_VFX_EFFECT = { FRC file effects }
//
// Subtypes:  none

#define VFX_FILENAME	0L
#define VFX_BUFFER		1L

typedef struct _VFX_PARAM
{
	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
} VFX_PARAM, *PVFX_PARAM;

//
// --- RTC Spring Effect Structure
//
typedef struct _RTCSPRING_PARAM{
	ULONG	m_Bytes;				// Size of this structure
	LONG	m_XKConstant;			// K Constant for X-axis
	LONG	m_YKConstant;			// "   "      for Y-axis
	LONG	m_XAxisCenter;			// RTC Spring center for X-axis
	LONG	m_YAxisCenter;			// "   "      "      for Y-axis
	LONG	m_XSaturation;			// Saturation for X-axis
	LONG	m_YSaturation;			// "          for Y-axis
	LONG	m_XDeadBand;			// Deadband for X-axis
	LONG	m_YDeadBand;			// "        for Y-axis
} RTCSPRING_PARAM, *PRTCSPRING_PARAM;


//
// --- Major Type: Effects categories
//
#define	EF_BEHAVIOR		1L	// Behavioral Effect, e.g. Spring, Damper, etc.
#define	EF_SYNTHESIZED	2L	// Synthesized Effect, e.g. Sine, Square
#define EF_USER_DEFINED	3L	// User Defined Waveform
#define EF_ROM_EFFECT	4L	// ROM Built-in Waveforms defined by the OEM 
#define EF_VFX_EFFECT	5L	// FRC file effects
#define EF_RAW_FORCE	6L	// For PutRawForce
#define EF_RTC_SPRING	7L	// Permanent RTC Spring

//
// --- Subtypes for EF_BEHAVIOR
//
#define BE_SPRING	   	1L
#define BE_SPRING_2D   	2L
#define BE_DAMPER	   	3L
#define BE_DAMPER_2D   	4L
#define BE_INERTIA	   	5L
#define BE_INERTIA_2D  	6L
#define BE_FRICTION	   	7L
#define BE_FRICTION_2D	8L
#define BE_WALL			9L
#define BE_DELAY		10L
//
// --- DXFF map
//
#define ID_SPRING			(BE_SPRING 			+ (EF_BEHAVIOR<<16))
#define ID_DAMPER			(BE_DAMPER 			+ (EF_BEHAVIOR<<16))
#define ID_INERTIA			(BE_INERTIA 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION			(BE_FRICTION 		+ (EF_BEHAVIOR<<16))
// --- SWForce exte