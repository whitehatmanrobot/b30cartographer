/
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG PageSize;

//
// Valid for the lifetime of the debug session.
//

ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;


PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if (Client->QueryInterface(__uuidof(IDebugSymbols2), 
                                 (void **)&g_ExtSymbols2) != S_OK)
    {
        g_ExtSymbols2 = NULL;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 /*Argument*/)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                    DEBUG_DATA_MmPageSize, &Page,
                    sizeof(Page), NULL)) == S_OK)
                {
                    PageSize = (ULONG)(ULONG_PTR)Page;
                }

                DebugDataSpaces->Release();
            }
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE /*hModule*/,
    DWORD  dwReason,
    DWORD  /*dwReserved*/
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\data.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __data_h__
#define __data_h__

#include "..\..\inc\cor.h"

BOOL FileExist (const char *filename);
BOOL FileExist (const WCHAR *filename);

enum JitType;

// We use global variables
// because move returns void if it fails
//typedef DWORD DWORD_PTR;
//typedef ULONG ULONG_PTR;

// Max length in WCHAR for a buffer to store metadata name
const int mdNameLen = 2048;
extern WCHAR g_mdName[mdNameLen];

const int nMDIMPORT = 128;
struct MDIMPORT
{
    enum MDType {InMemory, InFile, Dynamic};
    WCHAR *name;
    size_t base;
    char *metaData;
    ULONG metaDataSize;
    MDType type;
    IMetaDataImport *pImport;

    MDIMPORT *left;
    MDIMPORT *right;
};

class Module;

class MDImportSet
{
    MDIMPORT *root;
public:
    MDImportSet()
        :root(NULL)
    {
    }
    ~MDImportSet()
    {
    }
    void Destroy();
    IMetaDataImport *GetImport(Module *pModule);
private:
    void DestroyInternal(MDIMPORT *node);
};

#ifdef _X86_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
    unsigned char ediSaved   :1;
    unsigned char esiSaved   :1;
    unsigned char ebxSaved   :1;
    unsigned char ebpSaved   :1;
    unsigned char ebpFrame;
    unsigned short argCount;
};

#endif // _X86_

#ifdef _IA64_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
//    unsigned char ediSaved   :1;
//    unsigned char esiSaved   :1;
//    unsigned char ebxSaved   :1;
//    unsigned char ebpSaved   :1;
//    unsigned char ebpFrame;
    unsigned short argCount;
};


#endif // _IA64_

extern MDImportSet mdImportSet;

extern DWORD_PTR EEManager;
extern BOOL ControlC;
extern IMetaDataDispenserEx *pDisp;

const int NumEEDllPath=8;
class EEDllPath
{
    WCHAR path[NumEEDllPath][MAX_PATH];
    EEDllPath *next;
public:
    EEDllPath ()
    {
        next = NULL;
        for (int i = 0; i < NumEEDllPath; i ++) {
            path[i][0] = L'\0';
        }
    }
    ~EEDllPath ()
    {
        if (next) {
            delete next;
        }
    }
    void AddPath (const WCHAR* str)
    {
        EEDllPath *ptr = this;
        while (ptr->next != NULL) {
            ptr = ptr->next;
        }
        for (int i = 0; i < NumEEDllPath; i ++) {
            if (ptr->path[i][0] == L'\0') {
                wcscpy (ptr->path[i], str);
                return;
            }
            else if (_wcsicmp (ptr->path[i],str) == 0) {
                return;
            }
        }
        if (ptr->next == NULL) {
            ptr->next = new EEDllPath;
        }
        ptr = ptr->next;
        wcscpy (ptr->path[0], str);
    }

    void AddPath (const char* str)
    {
		WCHAR path[MAX_PATH+1];
		MultiByteToWideChar (CP_ACP,0,str,-1,path,MAX_PATH);
		AddPath (path);
    }

    const WCHAR* PathToDll (const WCHAR* str)
    {
        EEDllPath *ptr = this;
        WCHAR filename[MAX_PATH+1];
        while (ptr) {
            for (int i = 0; i < NumEEDllPath; i ++) {
                if (ptr->path[i][0] == L'\0') {
                    return NULL;
                }
                wcscpy (filename, ptr->path[i]);
                wcscat (filename, L"\\");
                size_t n = wcslen (filename);
                wcsncat (filename, str, MAX_PATH-n);
                filename[MAX_PATH] = L'\0';
                if (FileExist (filename)) {
                    return ptr->path[i];
                }
            }
            ptr = ptr->next;
        }
        return NULL;
    }

    void DisplayPath ();

    void Reset ()
    {
        EEDllPath *ptr = this;
        while (ptr) {
            for (int i = 0; i < NumEEDllPath; i ++) {
                ptr->path[i][0] = L'\0';
            }
            ptr = ptr->next;
        }
    }
};

extern EEDllPath *DllPath;
#endif // __data_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\dllsext.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "util.h"

#ifndef UNDER_CE

void DllsNameFromPeb(
    ULONG_PTR addrContaining,
    WCHAR *dllName
	)
{
    ULONG64 ProcessPeb;
    g_ExtSystem->GetCurrentProcessPeb (&ProcessPeb);

    ULONG64 pLdrEntry;
    ULONG64 PebLdrAddress;
    ULONG64 Next;
    ULONG64 OrderModuleListStart;
    
    //
    // Capture PebLdrData
    //

    static ULONG Offset_Ldr = -1;
    if (Offset_Ldr == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB", &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "Ldr", &Offset_Ldr)))
                Offset_Ldr = -1;
        }
    }
    // We can not get it from PDB.  Use the fixed one.
    if (Offset_Ldr == -1)
        Offset_Ldr = offsetof (PEB, Ldr);

    PEB peb;
    if (FAILED(g_ExtData->ReadVirtual(ProcessPeb+Offset_Ldr, &peb.Ldr,
                                      sizeof(peb.Ldr), NULL)))
    {
        ExtOut ( "    Unable to read PEB_LDR_DATA address at %p\n", (ULONG64)(ProcessPeb+Offset_Ldr));
        return;
    }

    PebLdrAddress = (ULONG64)peb.Ldr;
    
    //
    // Walk through the loaded module table and display all ldr data
    //

    static ULONG Offset_ModuleList = -1;
    if (Offset_ModuleList == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB_LDR_DATA",
                                                  &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "InMemoryOrderModuleList",
                                                     &Offset_ModuleList)))
                Offset_ModuleList = -1;
        }
    }
    // We can not get it from PDB.  Use the fixed one.
    if (Offset_ModuleList == -1)
        Offset_ModuleList = offsetof (PEB_LDR_DATA, InMemoryOrderModuleList);
    
    OrderModuleListStart = PebLdrAddress + Offset_ModuleList;
    PEB_LDR_DATA Ldr;
    if (FAILED(g_ExtData->ReadVirtual(OrderModuleListStart,
                                      &Ldr.InMemoryOrderModuleList,
                                      sizeof(Ldr.InMemoryOrderModuleList),
                                      NULL)))
    {
        ExtOut ( "    Unable to read InMemoryOrderModuleList address at %p\n", OrderModuleListStart);
        return;
    }
    Next = (ULONG64)Ldr.InMemoryOrderModuleList.Flink;

    static ULONG Offset_OrderLinks = -1;
    static ULONG Offset_FullDllName = -1;
    static ULONG Offset_DllBase = -1;
    static ULONG Offset_SizeOfImage = -1;
    if (Offset_OrderLinks == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "LDR_DATA_TABLE_ENTRY",
                                                  &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "InMemoryOrderLinks",
                                                     &Offset_OrderLinks)))
                Offset_OrderLinks = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "FullDllName",
                                                     &Offset_FullDllName)))
                Offset_FullDllName = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "DllBase",
                                                     &Offset_DllBase)))
                Offset_DllBase = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "SizeOfImage",
                                                     &Offset_SizeOfImage)))
                Offset_SizeOfImage = -1;
        }
    }

    // We can not get it from PDB.  Use the fixed one.
    if (Offset_OrderLinks == -1 || Offset_OrderLinks == 0)
    {
        Offset_OrderLinks = offsetof (LDR_DATA_TABLE_ENTRY,
                                      InMemoryOrderLinks);
        Offset_FullDllName = offsetof (LDR_DATA_TABLE_ENTRY,
                                       FullDllName);
        Offset_DllBase = offsetof (LDR_DATA_TABLE_ENTRY,
                                   DllBase);
        Offset_SizeOfImage = offsetof (LDR_DATA_TABLE_ENTRY,
                                       SizeOfImage);
    }

    _UNICODE_STRING FullDllName;
    __try {
        while (Next != OrderModuleListStart) {
            if (IsInterrupt())
                return;
            
            pLdrEntry = Next - Offset_OrderLinks;
    
            //
            // Capture LdrEntry
            //
            if (FAILED(g_ExtData->ReadVirtual(pLdrEntry + Offset_FullDllName,
                                              &FullDllName,
                                              sizeof(FullDllName),
                                              NULL)))
            {
                ExtOut ( "    Unable to read FullDllName address at %p\n",
                         pLdrEntry + Offset_FullDllName);
                return;
            }
            ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            if (FAILED(g_ExtData->ReadVirtual((ULONG64)FullDllName.Buffer,
                                              dllName,
                                              FullDllName.Length,
                                              NULL)))
            {
#if 0
                ExtOut ( "    Unable to read FullDllName.Buffer address at %p\n",
                         (ULONG64)FullDllName.Buffer);
#endif
                ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            }
    
            //
            // Dump the ldr entry data
            // (dump all the entries if no containing address specified)
            //
            LDR_DATA_TABLE_ENTRY LdrEntry;
            if (SUCCEEDED(g_ExtData->ReadVirtual(pLdrEntry + Offset_DllBase,
                                                 &LdrEntry.DllBase,
                                                 sizeof(LdrEntry.DllBase),
                                                 NULL))
                &&
                SUCCEEDED(g_ExtData->ReadVirtual(pLdrEntry + Offset_SizeOfImage,
                                                 &LdrEntry.SizeOfImage,
                                                 sizeof(LdrEntry.SizeOfImage),
                                                 NULL))
                )
            {
                if (((ULONG_PTR)LdrEntry.DllBase <= addrContaining) &&
                    (addrContaining <= (ULONG_PTR)LdrEntry.DllBase + (ULONG_PTR)LdrEntry.SizeOfImage))
                    break;
            }
    
            ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            if (FAILED(g_ExtData->ReadVirtual(pLdrEntry + Offset_OrderLinks,
                                              &LdrEntry.InMemoryOrderLinks,
                                              sizeof(LdrEntry.InMemoryOrderLinks),
                                              NULL)))
                break;
            
            Next = (ULONG64)LdrEntry.InMemoryOrderLinks.Flink;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        ExtOut ("exception during reading PEB\n");
        return;
    }
}

VOID
DllsName(
    ULONG_PTR addrContaining,
    WCHAR *dllName
    )
{
    dllName[0] = L'\0';
    
    ULONG Index;
    ULONG64 base;
    if (g_ExtSymbols->GetModuleByOffset(addrContaining, 0, &Index, &base) != S_OK)
        return;
    CHAR name[MAX_PATH+1];
    ULONG length;
    if (g_ExtSymbols->GetModuleNames(Index,base,name,MAX_PATH,&length,NULL,0,NULL,NULL,0,NULL) == S_OK)
    {
        MultiByteToWideChar (CP_ACP,0,name,-1,dllName,MAX_PATH);
    }
    if (wcsrchr (dllName, '\\') == NULL) {
        DllsNameFromPeb (addrContaining,dllName);
    }
}

VOID
MatchDllsName (WCHAR *wname, WCHAR *dllName, ULONG64 base)
{
    if (!IsDumpFile() && !IsKernelDebugger()) {
        if (FileExist(wname)) {
            wcscpy (dllName,wname);
            return;
        }
    }
    else
    {
        if (IsKernelDebugger() && DllPath == NULL) {
            ExtOut ("Path for managed Dll not set yet\n");
            goto NotFound;
        }
        
        WCHAR *wptr = wcsrchr (wname, '\\');
        
        if (wptr == NULL) {
            wptr = wname;
        }
        else
            wptr ++;
        
        if (wptr && DllPath == NULL) {
            if (FileExist(wname)) {
                wcscpy (dllName, wname);
                return;
            }
        }
        if (DllPath == NULL) {
            ExtOut ("Path for managed Dll not set yet\n");
            goto NotFound;
        }
        
        const WCHAR *path = DllPath->PathToDll(wptr);
    
        if (path) {
            wcscpy (dllName,path);
            wcscat (dllName,L"\\");
            wcscat (dllName,wptr);
            return;
        }
    }
    
NotFound:
    // We do not find the module
    wcscpy (dllName,L"Not Available: ");
    int len = wcslen (wname);
    WCHAR *wptr = wname;
    if (len > 200) {
        wptr += len-200;
    }
    wcscat (dllName, wptr);
    wptr = dllName + wcslen (dllName);

    wsprintfW (wptr, L" [Base %p]", base);
    return;
}
#else // UNDER_CE

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
DECLARE_API(Help);

VOID help(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    Help(NULL, NULL, NULL, NULL, NULL);
}

VOID
CheckVersion(
    VOID
    )
{
}

VOID WINAPI
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

BOOL WINAPI DllInit(HANDLE hModule, DWORD dwReason, DWORD dwReserved)
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_PROCESS_ATTACH:
            break;
    }
    return TRUE;
}

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\eestructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __eestructs_h__
#define __eestructs_h__

#ifdef STRIKE
#pragma warning(disable:4200)
#include "..\..\vm\specialstatics.h"
#pragma warning(default:4200)
#include "data.h"
#include "symbol.h"

#endif //STRIKE

#define volatile

#include "MiniEE.h"

#ifdef STRIKE
#include "strikeEE.h"
#endif

#endif  // __eestructs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\eeheap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "util.h"

void* operator new(size_t, void* p) 
{
    return p;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to update GC heap statistics.             *  
*                                                                      *
\**********************************************************************/
void HeapStat::Add(DWORD_PTR aMT, DWORD aSize)
{
    if (head == 0)
    {
        head = (Node*)malloc(sizeof(Node));
        if (head == NULL)
        {
            dprintf ("Not enough memory\n");
            ControlC = TRUE;
            return;
        }
        head = new (head) Node;
        head->MT = aMT;
    }
    Node *walk = head;
    while (walk->MT != aMT)
    {
        if (IsInterrupt())
            return;
        if (aMT < walk->MT)
        {
            if (walk->left == NULL)
                break;
            walk = walk->left;
        }
        else
        {
            if (walk->right == NULL)
                break;
            walk = walk->right;
        }
    }
    
    if (aMT == walk->MT)
    {
        walk->count ++;
        walk->totalSize += aSize;
    }
    else
    {
        Node *node = (Node*)malloc(sizeof(Node));
        if (node == NULL)
        {
            dprintf ("Not enough memory\n");
            ControlC = TRUE;
            return;
        }
        node = new (node) Node;
        node->MT = aMT;
        node->totalSize = aSize;
        node->count ++;
        
        if (aMT < walk->MT)
        {
            walk->left = node;
        }
        else
        {
            walk->right = node;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to sort all entries in the heap stat.     *  
*                                                                      *
\**********************************************************************/
void HeapStat::Sort ()
{
    Node *root = head;
    head = NULL;
    ReverseLeftMost (root);

    Node *sortRoot = NULL;
    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // add tmp
        tmp->right = NULL;
        tmp->left = NULL;
        SortAdd (sortRoot, tmp);
    }
    head = sortRoot;

    // Change binary tree to a linear tree
    root = head;
    head = NULL;
    ReverseLeftMost (root);
    sortRoot = NULL;
    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // add tmp
        tmp->right = NULL;
        tmp->left = NULL;
        LinearAdd (sortRoot, tmp);
    }
    head = sortRoot;

    //reverse the order
    root = head;
    head = NULL;
    sortRoot = NULL;
    while (root)
    {
        Node *tmp = root->right;
        root->left = NULL;
        root->right = NULL;
        LinearAdd (sortRoot, root);
        root = tmp;
    }
    head = sortRoot;
}

void HeapStat::ReverseLeftMost (Node *root)
{
    while (root)
    {
        Node *tmp = root->left;
        root->left = head;
        head = root;
        root = tmp;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to help to sort heap stat.                *  
*                                                                      *
\**********************************************************************/
void HeapStat::SortAdd (Node *&root, Node *entry)
{
    if (root == NULL)
    {
        root = entry;
    }
    else
    {
        Node *parent = root;
        Node *ptr = root;
        while (ptr)
        {
            parent = ptr;
            if (ptr->totalSize < entry->totalSize)
                ptr = ptr->right;
            else
                ptr = ptr->left;
        }
        if (parent->totalSize < entry->totalSize)
            parent->right = entry;
        else
            parent->left = entry;
    }
}

void HeapStat::LinearAdd(Node *&root, Node *entry)
{
    if (root == NULL)
    {
        root = entry;
    }
    else
    {
        entry->right = root;
        root = entry;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print GC heap statistics.              *  
*                                                                      *
\**********************************************************************/
void HeapStat::Print()
{
    Node *root = head;
    int ncount = 0;
    while (root)
    {
        if (IsInterrupt())
            return;
        dprintf ("%8x %8d %9d ", root->MT, root->count, root->totalSize);
        ncount += root->count;
        if (root->MT == MTForFreeObj())
        {
            dprintf ("%9s\n","Free");
        }
        else
        {
            NameForMT (root->MT, g_mdName);
            dprintf ("%S\n", g_mdName);
        }
        root = root->right;
    }
    dprintf ("Total %d objects\n", ncount);
}

void HeapStat::Delete()
{
    Node *root = head;
    head = NULL;
    ReverseLeftMost (root);

    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // free tmp
        free (tmp);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Print the gc heap info.                                           *  
*                                                                      *
\**********************************************************************/
void GCHeapInfo(gc_heap &heap, DWORD_PTR &total_size)
{
    DWORD_PTR dwAddrSeg;
    heap_segment segment;
    int n;
    for (n = 0; n <= heap.g_max_generation; n ++)
    {
        if (IsInterrupt())
            return;
        dprintf ("generation %d starts at 0x%p\n",
                 n, (ULONG64)heap.generation_table[n].allocation_start);
    }
    dwAddrSeg = (DWORD_PTR)heap.generation_table[heap.g_max_generation].start_segment;

    dprintf (" segment    begin allocated     size\n");

    total_size = 0;
    n = 0;
    DWORD_PTR dwAddr;
    while (dwAddrSeg != (DWORD_PTR)heap.generation_table[0].start_segment)
    {
        if (IsInterrupt())
            return;
        dwAddr = dwAddrSeg;
        segment.Fill (dwAddr);
        dprintf ("%p %p  %p 0x%p(%d)\n", (ULONG64)dwAddrSeg,
                 (ULONG64)segment.mem, (ULONG64)segment.allocated,
                 (ULONG64)(segment.allocated - segment.mem),
                 segment.allocated - segment.mem);
        total_size += segment.allocated - segment.mem;
        dwAddrSeg = (DWORD_PTR)segment.next;
        n ++;
        if (n > 20)
            break;
    }

    dwAddr = (DWORD_PTR)heap.generation_table[0].start_segment;
    segment.Fill (dwAddr);
    //DWORD_PTR end = (DWORD_PTR)heap.generation_table[0].allocation_context.alloc_ptr;
    DWORD_PTR end = (DWORD_PTR)heap.alloc_allocated;
    dprintf ("%p %p  %p %p(%d)\n", (ULONG64)dwAddrSeg,
             (ULONG64)segment.mem, (ULONG64)end,
             (ULONG64)(end - (DWORD_PTR)segment.mem),
             end - (DWORD_PTR)segment.mem);
    
    total_size += end - (DWORD_PTR)segment.mem;
    dprintf ("Total Size  %#8x(%d)\n", total_size, total_size);
}


//Alignment constant for allocation
#ifdef _X86_
#define ALIGNCONST 3
#else
#define ALIGNCONST 7
#endif

static BOOL MemOverlap (DWORD_PTR beg1, DWORD_PTR end1,
                        DWORD_PTR beg2, DWORD_PTR end2)
{
    if (beg2 >= beg1 && beg2 <= end1)
        return TRUE;
    else if (end2 >= beg1 && end2 <= end1)
        return TRUE;
    else if (beg1 >= beg2 && beg1 <= end2)
        return TRUE;
    else if (end1 >= beg2 && end1 <= end2)
        return TRUE;
    else
        return FALSE;
}

#define plug_skew           sizeof(DWORD)
#define min_obj_size        (sizeof(BYTE*)+plug_skew+sizeof(size_t))
size_t Align (size_t nbytes)
{
    return (nbytes + ALIGNCONST) & ~ALIGNCONST;
}
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Dump objects on the gc heap.                                      *  
*                                                                      *
\**********************************************************************/
void GCHeapDump(gc_heap &heap, DWORD_PTR &nObj, DumpHeapFlags &flags,
                AllocInfo* pallocInfo)
{
    DWORD_PTR begin_youngest;
    DWORD_PTR end_youngest;    
    begin_youngest = (DWORD_PTR)heap.generation_table[0].allocation_start;
    DWORD_PTR dwAddr = (DWORD_PTR)heap.ephemeral_heap_segment;
    heap_segment segment;
    segment.Fill (dwAddr);
    end_youngest = (DWORD_PTR)heap.alloc_allocated;
    
    DWORD_PTR dwAddrSeg = (DWORD_PTR)heap.generation_table[2].start_segment;
    dwAddr = dwAddrSeg;
    segment.Fill (dwAddr);
    
    DWORD_PTR dwAddrCurrObj = (DWORD_PTR)heap.generation_table[2].allocation_start;
    if (flags.bFixRange) {
        dwAddrCurrObj = flags.startObject;
        DWORD_PTR end_of_segment = (DWORD_PTR)segment.allocated;
        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
        {
            end_of_segment = end_youngest;
        }
        // Find the correct segment for this address.
        while (dwAddrCurrObj > end_of_segment || dwAddrCurrObj < dwAddrSeg) {
            dwAddrSeg = (DWORD_PTR)segment.next;
            if (dwAddrSeg)
            {
                dwAddr = dwAddrSeg;
                segment.Fill (dwAddr);
                
                if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
                {
                    end_of_segment = end_youngest;
                }
            }
            else
                return;
        }
    }

    size_t s;
    MethodTable vMethTable;
    DWORD_PTR dwAddrMethTable;
    nObj = 0;
    DWORD_PTR dwAddrPrevObj=0;

    while(1)
    {
        if (IsInterrupt())
            break;
        if (dwAddrCurrObj > flags.endObject)
            break;
        DWORD_PTR end_of_segment = (DWORD_PTR)segment.allocated;
        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
        {
            end_of_segment = end_youngest;
            if (dwAddrCurrObj == end_youngest - Align(min_obj_size))
                break;
        }
        if (dwAddrCurrObj >= (DWORD_PTR)end_of_segment
            || !MemOverlap (flags.startObject, flags.endObject,
                            (DWORD_PTR)segment.mem,
                            (DWORD_PTR)end_of_segment))
        {
            if (dwAddrCurrObj > (DWORD_PTR)end_of_segment)
            {
                dprintf ("curr_object: %p > heap_segment_allocated (seg: %p)\n",
                         (ULONG64)dwAddrCurrObj, (ULONG64)dwAddrSeg);
                if (dwAddrPrevObj) {
                    dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
                }
                break;
            }
            dwAddrSeg = (DWORD_PTR)segment.next;
            if (dwAddrSeg)
            {
                dwAddr = dwAddrSeg;
                segment.Fill (dwAddr);
                dwAddrCurrObj = (DWORD_PTR)segment.mem;
                continue;
            }
            else
                break;  // Done Verifying Heap
        }

        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment
            && dwAddrCurrObj >= end_youngest)
        {
            if (dwAddrCurrObj > end_youngest)
            {
                // prev_object length is too long
                dprintf ("curr_object: %p > end_youngest: %p\n",
                         (ULONG64)dwAddrCurrObj, (ULONG64)end_youngest);
                if (dwAddrPrevObj) {
                    dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
                }
                break;
            }
            break;
        }

        move (dwAddrMethTable, dwAddrCurrObj);
        dwAddrMethTable = dwAddrMethTable & ~3;
        if (dwAddrMethTable == 0)
        {
            // Is this the beginning of an allocation context?
            int i;
            for (i = 0; i < pallocInfo->num; i ++)
            {
                if (dwAddrCurrObj == (DWORD_PTR)pallocInfo->array[i].alloc_ptr)
                {
                    dwAddrCurrObj =
                        (DWORD_PTR)pallocInfo->array[i].alloc_limit + Align(min_obj_size);
                    break;
                }
            }
            if (i < pallocInfo->num)
                continue;
        }
        if (dwAddrMethTable != MTForFreeObj() && !IsMethodTable (dwAddrMethTable))
        {
            dprintf ("Bad MethodTable for Obj at %p\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        DWORD_PTR dwAddrTmp = dwAddrMethTable;
        DWORD_PTR mtAddr = dwAddrTmp;
        vMethTable.Fill (dwAddrTmp);
        if (!CallStatus)
        {
            dprintf ("Fail to read MethodTable for Obj at %p\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        
        s = ObjectSize (dwAddrCurrObj);
        if (s == 0)
        {
            dprintf ("curr_object : %p size=0\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        if (dwAddrCurrObj >= flags.startObject &&
            dwAddrCurrObj <= flags.endObject
            && s > flags.min_size && s < flags.max_size
            && (flags.MT == 0 || flags.MT == mtAddr))
        {
            nObj ++;
            if (!flags.bStatOnly)
                dprintf ("%p %p %8d%s\n", (ULONG64)dwAddrCurrObj, (ULONG64)dwAddrMethTable, s,
                         (dwAddrMethTable==MTForFreeObj())?" Free":"");
            stat->Add (dwAddrMethTable, (DWORD)s);
        }
        s = (s + ALIGNCONST) & ~ALIGNCONST;
        dwAddrPrevObj = dwAddrCurrObj;
        dwAddrCurrObj += s;
    }
}

DWORD_PTR LoaderHeapInfo (LoaderHeap *pLoaderHeap)
{
    LoaderHeapBlock heapBlock;
    DWORD_PTR totalSize = 0;
    DWORD_PTR wastedSize = 0;
    DWORD_PTR heapAddr = (DWORD_PTR)pLoaderHeap->m_pFirstBlock;
    DWORD_PTR dwCurBlock = (DWORD_PTR)pLoaderHeap->m_pCurBlock;

    while (1)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = heapAddr;
        heapBlock.Fill (dwAddr);
        if (!CallStatus)
        {
            break;
        }
        DWORD_PTR curSize = 0;
        if (heapAddr != dwCurBlock)
        {
            DWORD_PTR dwAddr;
            char ch;
            for (dwAddr = (DWORD_PTR)heapBlock.pVirtualAddress;
                 dwAddr < (DWORD_PTR)heapBlock.pVirtualAddress
                     + heapBlock.dwVirtualSize;
                 dwAddr += OSPageSize())
            {
                if (IsInterrupt())
                    break;
                if (SafeReadMemory(dwAddr, &ch, sizeof(ch), NULL))
                {
                    curSize += OSPageSize();
                }
                else
                    break;
            }
            wastedSize += heapBlock.dwVirtualSize - curSize;
        }
        else
        {
            curSize =
                (DWORD_PTR)pLoaderHeap->m_pPtrToEndOfCommittedRegion
                - (DWORD_PTR)heapAddr;
        }
        
        totalSize += curSize;
        dprintf ("%p(%x", (ULONG64)heapBlock.pVirtualAddress,
                 heapBlock.dwVirtualSize);
        if (curSize != heapBlock.dwVirtualSize)
            dprintf (":%p", (ULONG64)curSize);
        dprintf (") ");

        heapAddr = (DWORD_PTR)heapBlock.pNext;
        if (heapAddr == 0)
        {
            dprintf ("\n");
            break;
        }
    }
    dprintf ("Size: 0x%p(%d) bytes.\n", (ULONG64)totalSize, totalSize);
    if (wastedSize)
        dprintf ("Wasted: 0x%p(%d) bytes.\n", (ULONG64)wastedSize, wastedSize);
    
    return totalSize;
}

DWORD_PTR JitHeapInfo ()
{
    // walk ExecutionManager__m_pJitList
    static DWORD_PTR dwJitListAddr = 0;
    if (dwJitListAddr == 0)
    {
        dwJitListAddr = GetValueFromExpression("MSCOREE!ExecutionManager__m_pJitList");
    }

    DWORD_PTR dwJitList;
    
    if (!SafeReadMemory(dwJitListAddr, &dwJitList, sizeof(DWORD_PTR), NULL))
    {
        return 0;
    }
    if (dwJitList == 0)
        return 0;

    EEJitManager vEEJitManager;
    IJitManager vIJitManager;
    DWORD_PTR totalSize = 0;
    while (dwJitList)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR vtbl;
        if (!SafeReadMemory(dwJitList, &vtbl, sizeof(DWORD_PTR), NULL))
        {
            break;
        }
        JitType jitType = GetJitType (vtbl);
        DWORD_PTR dwAddr = dwJitList;
        if (jitType == JIT)
        {
            vEEJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vEEJitManager.m_next;
            dprintf ("Normal Jit:");
            HeapList vHeapList;
            LoaderHeap v_LoaderHeap;
            dwAddr = (DWORD_PTR)vEEJitManager.m_pCodeHeap;
            while (dwAddr)
            {
                if (IsInterrupt())
                    break;
                vHeapList.Fill (dwAddr);
                v_LoaderHeap.Fill (vHeapList.pHeap);
                totalSize += LoaderHeapInfo (&v_LoaderHeap);
                dwAddr = vHeapList.hpNext;
            }
        }
        else if (jitType == EJIT)
        {
            vIJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vIJitManager.m_next;
            dprintf ("FJIT: ");
            dwAddr = GetValueFromExpression ("mscoree!EconoJitManager__m_CodeHeap");
            unsigned value;
            SafeReadMemory(dwAddr, &value, sizeof(unsigned), NULL);
            dprintf ("%x", value);
            dwAddr = GetValueFromExpression ("mscoree!EconoJitManager__m_CodeHeapCommittedSize");
            SafeReadMemory(dwAddr, &value, sizeof(unsigned), NULL);
            dprintf ("(%x)", value);
            dprintf ("\n");
            dprintf ("Size 0x%x(%d)bytes\n", value);
            totalSize += value;
        }
        else if (jitType == PJIT)
        {
            vIJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vIJitManager.m_next;
        }
        else
        {
            dprintf ("Unknown Jit\n");
            break;
        }
    }
    dprintf ("Total size 0x%p(%d)bytes.\n", (ULONG64)totalSize, totalSize);
    return totalSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\eestructs.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "symbol.h"
#include "util.h"

/* This file contains functions to fill EE structures.
   If pdb file is available, we use the type desc in the pdb file.
   Otherwise assume we have matched structures defined in eestructs.h,
   and selectively fill in structures.*/

char *CorElementTypeName[ELEMENT_TYPE_MAX]=
{
#define TYPEINFO(e,c,s,g,ie,ia,ip,if,im,ial)    c,
#include "cortypeinfo.h"
#undef TYPEINFO
};

#define STRIKEFUNC(CLASS)                                                   \
ULONG CLASS::GetFieldOffset(const char *field)                              \
{                                                                           \
    SYM_OFFSET *offset;                                                     \
    size_t nEntry;                                                          \
    SetupTypeOffset (&offset, &nEntry);                                     \
    ULONG pos = 0;                                                          \
    MEMBEROFFSET(offset, nEntry, field, pos);                               \
    return pos;                                                             \
}                                                                           \
                                                                            \
ULONG CLASS::size()                                                         \
{                                                                           \
    SYM_OFFSET *offset;                                                     \
    size_t nEntry;                                                          \
    ULONG length = -1;                                                      \
    if (length == -1)                                                       \
        length = SetupTypeOffset (&offset, &nEntry);                        \
    return (length == 0?sizeof(CLASS):length);                              \
}                                                                           \
                                                                            \
ULONG CLASS::SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry)       \
{                                                                           \
    static ULONG typeLength = 0;                                            \
    static SYM_OFFSET offset[] = 
    

#define STRIKEFUNCEND(CLASS)                                               \
    if (typeLength == 0)                                                    \
        typeLength = GetSymbolType (#CLASS, offset,                         \
                                    sizeof (offset)/sizeof (SYM_OFFSET));   \
    *symoffset = offset;                                                    \
    *nEntry = sizeof (offset)/sizeof (SYM_OFFSET);                          \
    return typeLength;                                                      \
}


/* Find the offset for a member. */
inline void MEMBEROFFSET(SYM_OFFSET *symOffset, size_t symCount, const char *member, ULONG &result)
{                                                                 
    size_t n;                                                     
    for (n = 0; n < symCount; n ++)                               
    {                                                             
        if (strcmp (member, symOffset[n].name) == 0)             
        {                                                         
            if (symOffset[n].offset == -1)                        
            {                                                     
                dprintf ("offset not exist for %s\n", member);   
            }                                                     
            result = symOffset[n].offset;                         
            break;                                                
        }                                                         
    }                                                             
                                                                  
    if (n == symCount)                                            
    {                                                             
        result = -1;                                              
        dprintf ("offset not found for %s\n", member);           
        /*return;*/                                               
    }                                                             
}

STRIKEFUNC(MethodDesc)
    {{"m_pDebugEEClass", -2},{"m_pszDebugMethodName", -2},{"m_wFlags"},
     {"m_CodeOrIL"},{"m_pszDebugMethodSignature", -2}
    };
STRIKEFUNCEND(MethodDesc);

void MethodDesc::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset;
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        if (IsDebugBuildEE())
        {
            FILLCLASSMEMBER (offset, nEntry, m_pDebugEEClass, dwStartAddr);
            FILLCLASSMEMBER (offset, nEntry, m_pszDebugMethodName, dwStartAddr);
            FILLCLASSMEMBER (offset, nEntry, m_pszDebugMethodSignature, dwStartAddr);
        }
        FILLCLASSMEMBER (offset, nEntry, m_wFlags, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_CodeOrIL, dwStartAddr);
        DWORD_PTR dwAddr = dwStartAddr + MD_IndexOffset();
        char ch;
        move (ch, dwAddr);
        dwAddr = dwStartAddr + ch * MethodDesc::ALIGNMENT + MD_SkewOffset();
        MethodDescChunk vMDChunk;
        vMDChunk.Fill(dwAddr);
        BYTE tokrange = vMDChunk.m_tokrange;
        dwAddr = dwStartAddr - METHOD_PREPAD;
        StubCallInstrs vStubCall;
        vStubCall.Fill(dwAddr);
        unsigned __int16 tokremainder = vStubCall.m_wTokenRemainder;
        m_dwToken = (tokrange << 16) | tokremainder;
        m_dwToken |= mdtMethodDef;
        GetMethodTable(dwStartAddr, m_MTAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(MethodDescChunk)
    {{"m_tokrange"},{"m_count"}
    };
STRIKEFUNCEND(MethodDescChunk);

void MethodDescChunk::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_tokrange, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_count, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(StubCallInstrs)
    {{"m_wTokenRemainder"},{"m_chunkIndex"}
    };
STRIKEFUNCEND(StubCallInstrs);

void StubCallInstrs::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_wTokenRemainder, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_chunkIndex, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(EEClass)
    {{"m_cl"},{"m_pParentClass"},{"m_pLoader"}, {"m_pMethodTable"},
     {"m_wNumVtableSlots"},{"m_wNumMethodSlots"},{"m_dwAttrClass"},
     {"m_VMFlags"},{"m_wNumInstanceFields"},{"m_wNumStaticFields"},
     {"m_wThreadStaticOffset"},{"m_wContextStaticOffset"},
     {"m_wThreadStaticsSize"},{"m_wContextStaticsSize"},
     {"m_pFieldDescList"},{"m_pMethodTable"},{"m_szDebugClassName", -2},
     {"m_SiblingsChain"},{"m_ChildrenChain"}
    };
STRIKEFUNCEND(EEClass);

void EEClass::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        if (IsDebugBuildEE())
            FILLCLASSMEMBER (offset, nEntry, m_szDebugClassName, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_cl, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pParentClass, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pLoader, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pMethodTable, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wNumVtableSlots, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wNumMethodSlots, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_dwAttrClass, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_VMFlags, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wNumInstanceFields, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wNumStaticFields, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wThreadStaticOffset, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wContextStaticOffset, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wThreadStaticsSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wContextStaticsSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pFieldDescList, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pMethodTable, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_SiblingsChain, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_ChildrenChain, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(TypeDesc)
    {{"m_Type"}
    };
STRIKEFUNCEND(TypeDesc);

void TypeDesc::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSBITMEMBER (offset, nEntry, preBit1, m_Type, dwStartAddr, 8);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ParamTypeDesc)
    {{"m_Arg"}
    };
STRIKEFUNCEND(ParamTypeDesc);

void ParamTypeDesc::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        DWORD_PTR dwAddr = dwStartAddr;
        TypeDesc::Fill (dwAddr);
        if (!CallStatus) {
            return;
        }
        FILLCLASSMEMBER (offset, nEntry, m_Arg, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ArrayClass)
    {{"m_dwRank"},{"m_ElementType"}, {"m_ElementTypeHnd"}
    };
STRIKEFUNCEND(ArrayClass);

void ArrayClass::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSBITMEMBER (offset, nEntry, preBit1, m_dwRank, dwStartAddr, 16);
        FILLCLASSMEMBER (offset, nEntry, m_ElementTypeHnd, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(MethodTable)
    {{"m_pEEClass"},{"m_pModule"},{"m_pEEClass"}, {"m_wFlags"},
     {"m_BaseSize"},{"m_ComponentSize"},{"m_wNumInterface"},{"m_pIMap"},
     {"m_cbSlots"},{"m_Vtable"}
    };
STRIKEFUNCEND(MethodTable);

void MethodTable::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pEEClass, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pModule, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pEEClass, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wFlags, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_BaseSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_ComponentSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_wNumInterface, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pIMap, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_cbSlots, dwStartAddr);
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_Vtable", value);
        m_Vtable[0] = (SLOT)(dwStartAddr + value);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(RangeSection)
    {{"LowAddress"},{"HighAddress"},{"pjit"},{"ptable"},{"pright"},{"pleft"}
    };
STRIKEFUNCEND(RangeSection);

void RangeSection::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, LowAddress, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, HighAddress, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pjit, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, ptable, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pright, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pleft, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Crst)
    {{"m_criticalsection"}
    };
STRIKEFUNCEND(Crst);

void Crst::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(AwareLock)
    {{"m_MonitorHeld"},{"m_Recursion"},{"m_HoldingThread"}
    };
STRIKEFUNCEND(AwareLock);

void AwareLock::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_MonitorHeld, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_Recursion, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_HoldingThread, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(SyncBlock)
    {{"m_Monitor"},{"m_pComData"},{"m_Link"}
    };
STRIKEFUNCEND(SyncBlock);

void SyncBlock::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        DWORD_PTR dwAddr = dwStartAddr;
        m_Monitor.Fill (dwAddr);
        FILLCLASSMEMBER (offset, nEntry, m_Link, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pComData, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(SyncTableEntry)
    {{"m_SyncBlock"},{"m_Object"}
    };
STRIKEFUNCEND(SyncTableEntry);

void SyncTableEntry::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_SyncBlock, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_Object, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(WaitEventLink)
    {{"m_Thread"}, {"m_LinkSB"}
    };
STRIKEFUNCEND(WaitEventLink);

void WaitEventLink::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_Thread, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_LinkSB, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(EEHashEntry)
    {{"pNext"}, {"Data"}, {"Key"}
    };
STRIKEFUNCEND(EEHashEntry);

void EEHashEntry::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, Data, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(EEHashTable)
    {{"m_pBuckets"}, {"m_dwNumBuckets"},{"m_dwNumEntries"},{"m_pVolatileBucketTable"}
    };
STRIKEFUNCEND(EEHashTableOfEEClass);  // EEHashTable is a template, EEHashTableOfEEClass is a real type

void EEHashTable::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        if (GetFieldOffset("m_pVolatileBucketTable") == -1) {
            // TODO: remove this support for old EEHashTable when V1 is released.
            FILLCLASSMEMBER (offset, nEntry, m_pBuckets, dwStartAddr);
            FILLCLASSMEMBER (offset, nEntry, m_dwNumBuckets, dwStartAddr);
        }
        else
        {
            FILLCLASSMEMBER (offset, nEntry, m_pVolatileBucketTable, dwStartAddr);
            BucketTable *tmp = (BucketTable*)&m_pBuckets;
            g_ExtData->ReadVirtual((ULONG64)m_pVolatileBucketTable, tmp, sizeof(BucketTable),NULL);
        }
        FILLCLASSMEMBER (offset, nEntry, m_dwNumEntries, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(SyncBlockCache)
    {{"m_pCleanupBlockList"},{"m_FreeSyncTableIndex"}
    };
STRIKEFUNCEND(SyncBlockCache);

void SyncBlockCache::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_FreeSyncTableIndex, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pCleanupBlockList, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ThreadStore)
    {{"m_ThreadList"},{"m_ThreadCount"},{"m_UnstartedThreadCount"},
     {"m_BackgroundThreadCount"},{"m_PendingThreadCount"},
     {"m_DeadThreadCount"}
    };
STRIKEFUNCEND(ThreadStore);

void ThreadStore::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_ThreadList, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_ThreadCount, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_UnstartedThreadCount, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_BackgroundThreadCount, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_PendingThreadCount, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_DeadThreadCount, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(LoaderHeapBlock)
    {{"pNext"},{"pVirtualAddress"},{"dwVirtualSize"}
    };
STRIKEFUNCEND(LoaderHeapBlock);

void LoaderHeapBlock::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pVirtualAddress, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, dwVirtualSize, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(UnlockedLoaderHeap)
    {{"m_pFirstBlock"},{"m_pCurBlock"},{"m_pPtrToEndOfCommittedRegion"}
    };
STRIKEFUNCEND(UnlockedLoaderHeap);

void UnlockedLoaderHeap::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pFirstBlock, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pCurBlock, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pPtrToEndOfCommittedRegion, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(LoaderHeap)
    {{"m_CriticalSection"}
    };
STRIKEFUNCEND(LoaderHeap);

void LoaderHeap::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
    DWORD_PTR dwAddr = dwStartAddr;
    UnlockedLoaderHeap::Fill (dwAddr);
    if (!CallStatus)
        return;
    CallStatus = FALSE;
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    dwStartAddr = dwAddr;
    move (m_CriticalSection, dwStartAddr);
    dwStartAddr += sizeof (m_CriticalSection);
    CallStatus = TRUE;
}


STRIKEFUNC(HashMap)
    {{"m_rgBuckets"}
    };
STRIKEFUNCEND(HashMap);

void HashMap::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_rgBuckets, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(PtrHashMap)
    {{"m_HashMap"}
    };
STRIKEFUNCEND(PtrHashMap);

void PtrHashMap::Fill (DWORD_PTR &dwStartAddr)
{
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    m_HashMap.Fill (dwStartAddr);
}

STRIKEFUNC(LookupMap)
    {{"dwMaxIndex"},{"pTable"},{"pNext"}
    };
STRIKEFUNCEND(LookupMap);

void LookupMap::Fill (DWORD_PTR &dwStartAddr)
{
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, dwMaxIndex, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pTable, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pNext, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    moveBlock (*this, dwStartAddr, sizeof(*this));
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(PEFile)
    {{"m_wszSourceFile"},{"m_hModule"},{"m_base"},{"m_pNT"},{"m_pLoadersFileName"}
    };
STRIKEFUNCEND(PEFile);

void PEFile::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_wszSourceFile, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pLoadersFileName, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_hModule, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_base, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pNT, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    moveBlock (*this, dwStartAddr, sizeof(*this));
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Module)
    {{"m_dwFlags"},{"m_pAssembly"},{"m_file"},{"m_zapFile"},{"m_ilBase"},
     {"m_pLookupTableHeap"},{"m_TypeDefToMethodTableMap"},
     {"m_TypeRefToMethodTableMap"},{"m_MethodDefToDescMap"},
     {"m_FieldDefToDescMap"},{"m_MemberRefToDescMap"},{"m_FileReferencesMap"},
     {"m_AssemblyReferencesMap"},{"m_pNextModule"},{"m_dwBaseClassIndex"}
    };
STRIKEFUNCEND(Module);

void Module::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        CallStatus = FALSE;
        FILLCLASSMEMBER (offset, nEntry, m_dwFlags, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pAssembly, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_file, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_zapFile, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pLookupTableHeap, dwStartAddr);
        m_ilBase = 0;
        FILLCLASSMEMBER (offset, nEntry, m_ilBase, dwStartAddr);
        DWORD_PTR dwAddr = dwStartAddr + GetFieldOffset ("m_TypeDefToMethodTableMap");
        m_TypeDefToMethodTableMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_TypeRefToMethodTableMap");
        m_TypeRefToMethodTableMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_MethodDefToDescMap");
        m_MethodDefToDescMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_FieldDefToDescMap");
        m_FieldDefToDescMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_MemberRefToDescMap");
        m_MemberRefToDescMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_FileReferencesMap");
        m_FileReferencesMap.Fill (dwAddr);
        dwAddr = dwStartAddr + GetFieldOffset ("m_AssemblyReferencesMap");
        m_AssemblyReferencesMap.Fill (dwAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pNextModule, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_dwBaseClassIndex, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(LockEntry)
    {{"pNext"},{"dwULockID"},{"dwLLockID"},{"wReaderLevel"}
    };
STRIKEFUNCEND(LockEntry);

void LockEntry::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, dwULockID, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, dwLLockID, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, wReaderLevel, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(StackingAllocator)
    {{"m_FirstBlock"}
    };
STRIKEFUNCEND(StackingAllocator);

void StackingAllocator::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Thread)
    {{"m_ThreadId"},{"m_dwLockCount"},{"m_State"},{"m_pFrame"}, {"m_LinkStore"}, {"m_pDomain"}, {"m_Context"},
     {"m_fPreemptiveGCDisabled"},{"m_LastThrownObjectHandle"},{"m_pTEB"},
     {"m_ThreadHandle"},{"m_pHead"},{"m_pUnsharedStaticData"},
     {"m_pSharedStaticData"},{"m_alloc_context"}
    };
STRIKEFUNCEND(Thread);

void Thread::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        BOOL bHaveToFixSymbol = HaveToFixThreadSymbol ();
        FILLCLASSMEMBER (offset, nEntry, m_fPreemptiveGCDisabled, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_State, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_dwLockCount, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pFrame, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_alloc_context, dwStartAddr);
        DWORD adjust = (bHaveToFixSymbol?8:0);
        FILLCLASSMEMBER (offset, nEntry, m_ThreadId, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_LinkStore, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_pDomain, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_Context, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_LastThrownObjectHandle, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_pTEB, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_ThreadHandle, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_pHead, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_pUnsharedStaticData, dwStartAddr+adjust);
        FILLCLASSMEMBER (offset, nEntry, m_pSharedStaticData, dwStartAddr+adjust);
        dwStartAddr += typeLength+adjust;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Context)
    {{"m_pUnsharedStaticData"}, {"m_pSharedStaticData"}, {"m_pDomain"}
    };
STRIKEFUNCEND(Context);

void Context::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pUnsharedStaticData, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pSharedStaticData, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pDomain, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    moveBlock (*this, dwStartAddr, sizeof(*this));
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ExposedType)
    {{"m_ExposedTypeObject"}
    };
STRIKEFUNCEND(ExposedType);

void ExposedType::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    moveBlock (*this, dwStartAddr, sizeof(*this));
    dwStartAddr += sizeof(*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Assembly)
    {{"m_pDomain"},{"m_psName"},{"m_pClassLoader"},{"m_pwsFullName"},{"m_isDynamic"}
    };
STRIKEFUNCEND(Assembly);

void Assembly::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pDomain, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pwsFullName, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_psName, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pClassLoader, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_isDynamic, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ArrayList)
    {{"m_count"},{"m_firstBlock"}
    };
STRIKEFUNCEND(ArrayList);

void ArrayList::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_count, dwStartAddr);
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_firstBlock", value);
        DWORD_PTR dwAddr = dwStartAddr + value;
        move (m_firstBlock, dwAddr);
        dwStartAddr += typeLength;

        if (m_firstBlock.m_blockSize != ARRAY_BLOCK_SIZE_START)
        {
            dprintf("strike error: unexpected block size in ArrayList\n");
            return;
        }

        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

void *ArrayList::Get (DWORD index)
{
    ArrayListBlock* pBlock  = (ArrayListBlock*)malloc(sizeof(FirstArrayListBlock));
    SIZE_T          nEntries;
    SIZE_T          cbBlock;
    void*           pvReturnVal;
    DWORD_PTR       nextBlockAddr;

    memcpy (pBlock, &m_firstBlock, sizeof(FirstArrayListBlock));
    nEntries = pBlock->m_blockSize;

    while (index >= nEntries)
    {
        index -= nEntries;

        nextBlockAddr = (DWORD_PTR)(pBlock->m_next);
        if (!SafeReadMemory(nextBlockAddr, pBlock, sizeof(ArrayListBlock), NULL))
        {
            free(pBlock);
            return 0;
        }

        nEntries = pBlock->m_blockSize;
        cbBlock  = sizeof(ArrayListBlock) + ((nEntries-1) * sizeof(void*));
        free(pBlock);
        pBlock = (ArrayListBlock*)malloc(cbBlock);

        if (!SafeReadMemory(nextBlockAddr, pBlock, cbBlock, NULL))
        {
            free(pBlock);
            return 0;
        }
    }
    pvReturnVal = pBlock->m_array[index];
    free(pBlock);
    return pvReturnVal;
}

STRIKEFUNC(BaseDomain)
    {{"m_pLowFrequencyHeap"},{"m_pHighFrequencyHeap"},{"m_pStubHeap"},
     {"m_Assemblies"}
    };
STRIKEFUNCEND(BaseDomain);

void BaseDomain::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pLowFrequencyHeap, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pHighFrequencyHeap, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pStubHeap, dwStartAddr);
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_Assemblies", value);
        DWORD_PTR dwAddr = dwStartAddr + value;
        m_Assemblies.Fill (dwAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(DomainLocalBlock)
    {{"m_pSlots"}
    };
STRIKEFUNCEND(DomainLocalBlock);

void DomainLocalBlock::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pSlots, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(AppDomain)
    {{"m_pwzFriendlyName"},{"m_sDomainLocalBlock"},
     {"m_pDefaultContext"}
    };
STRIKEFUNCEND(AppDomain);

void AppDomain::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pwzFriendlyName, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pDefaultContext, dwStartAddr);
        DWORD_PTR dwAddr = dwStartAddr;
        BaseDomain::Fill (dwAddr);
        if (!CallStatus)
            return;
        CallStatus = FALSE;
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_sDomainLocalBlock", value);
        dwAddr = dwStartAddr + value;
        m_sDomainLocalBlock.Fill (dwAddr);
        CallStatus = FALSE;
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(SystemDomain)
    {{"BaseDomain"}
    };
STRIKEFUNCEND(SystemDomain);

void SystemDomain::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        DWORD_PTR dwAddr = dwStartAddr;
        BaseDomain::Fill (dwAddr);
        if (!CallStatus)
            return;
        CallStatus = FALSE;
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Bucket)
    {{"m_rgValues"}
    };
STRIKEFUNCEND(Bucket);

void Bucket::Fill (DWORD_PTR &dwStartAddr)
{
#if 0
    // We do not have PDB info for Bucket
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_rgValues, dwStartAddr);
        for (int i = 0; i < 4; i ++) {
            m_rgValues[i] &= VALUE_MASK;
        }
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
#endif
    move (*this, dwStartAddr);
    for (int i = 0; i < 4; i ++) {
        m_rgValues[i] &= VALUE_MASK;
    }
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(SharedDomain)
    {{"m_pDLSRecords"}, {"m_cDLSRecords"}, {"m_assemblyMap"}
    };
STRIKEFUNCEND(SharedDomain);

void SharedDomain::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        DWORD_PTR dwAddr = dwStartAddr;
        BaseDomain::Fill (dwAddr);
        if (!CallStatus)
            return;
        CallStatus = FALSE;
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_assemblyMap", value);
        dwAddr = dwStartAddr + value;
        m_assemblyMap.Fill (dwAddr);
        if (!CallStatus)
            return;
        FILLCLASSMEMBER (offset, nEntry, m_pDLSRecords, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_cDLSRecords, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ClassLoader)
    {{"m_pAssembly"},{"m_pNext"},{"m_pHeadModule"}
    };
STRIKEFUNCEND(ClassLoader);

void ClassLoader::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pAssembly, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_pHeadModule, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(alloc_context)
    {{"heap"}
    };
STRIKEFUNCEND(alloc_context);

void alloc_context::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, heap, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(heap_segment)
    {{"allocated"},{"next"},{"mem"}
    };
STRIKEFUNCEND(heap_segment);

void heap_segment::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, allocated, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, next, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, mem, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(generation)
    {{"allocation_context"},{"start_segment"},{"allocation_start"}
    };
STRIKEFUNCEND(generation);

void generation::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, allocation_context, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, start_segment, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, allocation_start, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(CFinalize)
    {{"m_Array"},{"m_FillPointers"},{"m_EndArray"}
    };
STRIKEFUNCEND(CFinalize);

void CFinalize::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE

    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_Array, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_FillPointers, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_EndArray, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
}

STRIKEFUNC(gc_heap)
    {{"alloc_allocated"},{"generation_table"},{"ephemeral_heap_segment"},{"finalize_queue"}
    };
STRIKEFUNCEND(gc_heap);

void gc_heap::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE

    static DWORD_PTR dwAddrLarge = 0;
    if (dwAddrLarge == 0)
        dwAddrLarge =
            GetValueFromExpression("mscoree!gc_heap__large_blocks_size");
    move (large_blocks_size, dwAddrLarge);

    static DWORD_PTR dwAddrGenNum = 0;
    if (dwAddrGenNum == 0)
        dwAddrGenNum =
            GetValueFromExpression("MSCOREE!gc_heap__g_max_generation");    
    move (g_max_generation, dwAddrGenNum);

    if (!IsServerBuild())
    {
        static DWORD_PTR dwAddrAlloc = 0;
        if (dwAddrAlloc == 0)
            dwAddrAlloc =
                GetValueFromExpression("mscoree!gc_heap__alloc_allocated");
        move (alloc_allocated, dwAddrAlloc);

        static DWORD_PTR dwAddrEphSeg = 0;
        if (dwAddrEphSeg == 0)
            dwAddrEphSeg =
                GetValueFromExpression("mscoree!gc_heap__ephemeral_heap_segment");
        move (ephemeral_heap_segment, dwAddrEphSeg);

        static DWORD_PTR dwAddrFinal = 0;
        if (dwAddrFinal == 0)
            dwAddrFinal =
                GetValueFromExpression("mscoree!gc_heap__finalize_queue");
        move (finalize_queue, dwAddrFinal);

        static DWORD_PTR dwAddrGenTable = 0;
        if (dwAddrGenTable == 0)
            dwAddrGenTable =
                GetValueFromExpression("mscoree!generation_table");
        DWORD_PTR dwAddr = dwAddrGenTable;
        for (int n = 0; n < NUMBERGENERATIONS; n ++)
        {
            generation_table[n].Fill (dwAddr);
        }
        CallStatus = TRUE;
    }
    else
    {
        ULONG typeLength;
        SYM_OFFSET *offset; 
        size_t nEntry;
        typeLength = SetupTypeOffset (&offset, &nEntry);
        if (typeLength > 0)
        {
            FILLCLASSMEMBER (offset, nEntry, alloc_allocated, dwStartAddr);
            FILLCLASSMEMBER (offset, nEntry, ephemeral_heap_segment, dwStartAddr);
            FILLCLASSMEMBER (offset, nEntry, finalize_queue, dwStartAddr);
            static int itable = -1;
            if (itable == -1)
            {
                int m;
                for (m = 0; (size_t)m < nEntry; m ++)
                {
                    if (strcmp ("generation_table", offset[m].name) == 0)
                    {
                        itable = m;
                        break;
                    }
                }
            }
            if (itable == -1)
                return;
            DWORD_PTR dwAddr = dwStartAddr + offset[itable].offset;
            for (int n = 0; n < NUMBERGENERATIONS; n ++)
            {
                generation_table[n].Fill (dwAddr);
            }
            dwStartAddr += typeLength;
            CallStatus = TRUE;
            return;
        }
    }
#endif
}


STRIKEFUNC(large_object_block)
    {{"next"}
    };
STRIKEFUNCEND(large_object_block);

void large_object_block::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, next, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}


STRIKEFUNC(FieldDesc)
    {{"m_mb"},{"m_dwOffset"},
     {"m_pMTOfEnclosingClass"}
    };
STRIKEFUNCEND(FieldDesc);

void FieldDesc::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSBITMEMBER (offset, nEntry, preBit1, m_mb, dwStartAddr, 32);
        FILLCLASSBITMEMBER (offset, nEntry, preBit2, m_dwOffset, dwStartAddr, 32);
        FILLCLASSMEMBER (offset, nEntry, m_pMTOfEnclosingClass, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}


STRIKEFUNC(HeapList)
    {{"hpNext"},{"pHeap"}
    };
STRIKEFUNCEND(HeapList);

void HeapList::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, hpNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pHeap, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(CRWLock)
    {{"_pMT"},{"_hWriterEvent"},{"_hReaderEvent"},{"_dwState"},{"_dwULockID"},
    {"_dwLLockID"},{"_dwWriterID"},{"_dwWriterSeqNum"},{"_wFlags"},{"_wWriterLevel"}
    };
STRIKEFUNCEND(CRWLock);

void CRWLock::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, _pMT, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _hWriterEvent, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _hReaderEvent, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _dwState, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _dwULockID, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _dwLLockID, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _dwWriterID, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _dwWriterSeqNum, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _wFlags, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, _wWriterLevel, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(Fjit_hdrInfo)
    {{"prologSize"},{"methodSize"},{"epilogSize"},{"methodArgsSize"}
    };
STRIKEFUNCEND(Fjit_hdrInfo);

void Fjit_hdrInfo::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, prologSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, methodSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, epilogSize, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, methodArgsSize, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(IJitManager)
    {{"m_jit"},{"m_next"}
    };
STRIKEFUNCEND(IJitManager);

void IJitManager::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_jit, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_next, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(EEJitManager)
    {{"m_pCodeHeap"}
    };
STRIKEFUNCEND(EEJitManager);

void EEJitManager::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
    DWORD_PTR dwAddr = dwStartAddr;
    IJitManager::Fill (dwAddr);
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pCodeHeap, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(CORCOMPILE_METHOD_HEADER)
    {{"gcInfo"},{"methodDesc"}
    };
STRIKEFUNCEND(CORCOMPILE_METHOD_HEADER);

void CORCOMPILE_METHOD_HEADER::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, gcInfo, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, methodDesc, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(PerfAllocVars)
    {{"g_PerfEnabled"}, {"g_AllocListFirst"}
    };
STRIKEFUNCEND(PerfAllocVars);

void PerfAllocVars::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, g_PerfEnabled, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, g_AllocListFirst, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(PerfAllocHeader)
    {{"m_Length"}, {"m_Next"}, {"m_Prev"}, {"m_AllocEIP"}
    };
STRIKEFUNCEND(PerfAllocHeader);

void PerfAllocHeader::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_Length, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_Next, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_Prev, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_AllocEIP, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}


STRIKEFUNC(TableSegment)
    {{"rgBlockType"}, {"pNextSegment"}, {"bEmptyLine"}, {"rgValue"}
    };
STRIKEFUNCEND(TableSegment);

void TableSegment::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, rgBlockType, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pNextSegment, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, bEmptyLine, dwStartAddr);
        size_t nHandles = bEmptyLine * HANDLE_HANDLES_PER_BLOCK;
        ULONG value=0;
        MEMBEROFFSET(offset, nEntry, "rgValue", value);
        firstHandle = dwStartAddr+value;
        moveBlock (rgValue[0], firstHandle, nHandles*HANDLE_SIZE);
        //FILLCLASSMEMBER (offset, nEntry, rgValue, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}


STRIKEFUNC(HandleTable)
    {{"pSegmentList"}
    };
STRIKEFUNCEND(HandleTable);

void HandleTable::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pSegmentList, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}


STRIKEFUNC(HandleTableMap)
    {{"pTable"},{"pNext"},{"dwMaxIndex"}
    };
STRIKEFUNCEND(HandleTableMap);

void HandleTableMap::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pTable, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, dwMaxIndex, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ComPlusApartmentCleanupGroup)
    {{"m_CtxCookieToContextCleanupGroupMap"},{"m_pSTAThread"}
    };
STRIKEFUNCEND(ComPlusApartmentCleanupGroup);

void ComPlusApartmentCleanupGroup::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pSTAThread, dwStartAddr);
        ULONG value;
        MEMBEROFFSET(offset, nEntry, "m_CtxCookieToContextCleanupGroupMap", value);
        DWORD_PTR dwAddr = dwStartAddr + value;
        m_CtxCookieToContextCleanupGroupMap.Fill(dwAddr);
        if (!CallStatus) {
            return;
        }
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ComPlusContextCleanupGroup)
    {{"m_pNext"},{"m_apWrapper"},{"m_dwNumWrappers"}
    };
STRIKEFUNCEND(ComPlusContextCleanupGroup);

void ComPlusContextCleanupGroup::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pNext, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_apWrapper, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, m_dwNumWrappers, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(ComPlusWrapperCleanupList)
    {{"m_STAThreadToApartmentCleanupGroupMap"},{"m_pMTACleanupGroup"}
    };
STRIKEFUNCEND(ComPlusWrapperCleanupList);

void ComPlusWrapperCleanupList::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, m_pMTACleanupGroup, dwStartAddr);
        ULONG value;
        MEMBEROFFSET(offset, nEntry, "m_STAThreadToApartmentCleanupGroupMap", value);
        DWORD_PTR dwAddr = dwStartAddr + value;
        m_STAThreadToApartmentCleanupGroupMap.Fill(dwAddr);
        if (!CallStatus) {
            return;
        }
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(VMHELPDEF)
    {{"pfnHelper"}
    };
STRIKEFUNCEND(VMHELPDEF);

void VMHELPDEF::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, pfnHelper, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}

STRIKEFUNC(WorkRequest)
    {{"next"},{"Function"},{"Context"}
    };
STRIKEFUNCEND(ThreadpoolMgr::WorkRequest);

void WorkRequest::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
#ifndef UNDER_CE
    ULONG typeLength;
    SYM_OFFSET *offset; 
    size_t nEntry;
    typeLength = SetupTypeOffset (&offset, &nEntry);
    if (typeLength > 0)
    {
        FILLCLASSMEMBER (offset, nEntry, next, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, Function, dwStartAddr);
        FILLCLASSMEMBER (offset, nEntry, Context, dwStartAddr);
        dwStartAddr += typeLength;
        CallStatus = TRUE;
        return;
    }
#endif
    move (*this, dwStartAddr);
    dwStartAddr += sizeof (*this);
    CallStatus = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\disasmx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif




enum RegIndex {EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP, NONE};
const int NumReg = NONE;
struct Register
{
    DWORD_PTR value;
    BOOL bValid;
    DWORD_PTR stack;
    BOOL bOnStack;
};

// Find the index for a register name
inline RegIndex FindReg (char *ptr)
{
    if (!strncmp (ptr, "eax", 3))
        return EAX;
    else if (!strncmp (ptr, "ebx", 3))
        return EBX;
    else if (!strncmp (ptr, "ecx", 3))
        return ECX;
    else if (!strncmp (ptr, "edx", 3))
        return EDX;
    else if (!strncmp (ptr, "esi", 3))
        return ESI;
    else if (!strncmp (ptr, "edi", 3))
        return EDI;
    else if (!strncmp (ptr, "ebp", 3))
        return EBP;
    else if (!strncmp (ptr, "esp", 3))
        return ESP;
    else
        return NONE;
}

// Find the value of an expression.
inline BOOL FindSrc (char *ptr, Register *reg, INT_PTR &value, BOOL &bDigit)
{
    if (GetValueFromExpr (ptr, value))
    {
        bDigit = TRUE;
        return TRUE;
    }
    
    BOOL bValid = FALSE;
    BOOL bByRef = IsByRef (ptr);
    bDigit = FALSE;

    RegIndex index = FindReg (ptr);
    if (index != NONE)
    {
        if (reg[index].bValid)
        {
            value = reg[index].value;
            ptr += 3;
            // TODO:  consider ecx+edi*4+0x4
            if ((IsTermSep (ptr[0]) && !bByRef)
                || (ptr[0] == ']' && bByRef))
            {
                bValid = TRUE;
                if (bByRef)
                    SafeReadMemory (value, &value, 4, NULL);
            }
        }
    }
    return bValid;
}


enum ADDRESSMODE {REG, DATA, INDIRECT, NODATA, BAD};

struct RegState
{
    RegIndex reg;
    BOOL bFullReg;
    char scale;
};

struct InstData
{
    ADDRESSMODE mode;
    RegState reg[2];
    INT_PTR value;
};

void FindMainReg (char *ptr, RegState &reg)
{
    reg.bFullReg = FALSE;
    if (ptr[0] == 'e' || ptr[0] == 'E')
    {
        reg.bFullReg = TRUE;
        ptr ++;
    }
    
    if (ptr[0] == 'a' || ptr[0] == 'A')
    {
        reg.reg = EAX;
        return;
    }
    else if (ptr[0] == 'c' || ptr[0] == 'C')
    {
        reg.reg = ECX;
        return;
    }
    else if (ptr[0] == 's' || ptr[0] == 'S')
    {
        reg.reg = (ptr[1] == 'p' || ptr[1] == 'P')? ESP: ESI;
        return;
    }
    else if (ptr[0] == 'd' || ptr[0] == 'D')
    {
        reg.reg = (ptr[1] == 'i' || ptr[1] == 'I')? EDI: EDX;
        return;
    }
    else if (ptr[0] == 'b' || ptr[0] == 'B')
    {
        reg.reg = (ptr[1] == 'p' || ptr[1] == 'P')? EBP: EBX;
        return;
    }
    else
    {
        reg.reg = NONE;
        return;
    }
}

static void DecodeAddressIndirect (char *term, InstData& arg)
{
    arg.mode = BAD;
    arg.value = 0;
    arg.reg[0].scale = 0;
    arg.reg[1].scale = 0;
    
    if (!IsByRef (term))
    {
        return;
    }
    
    // first part must be a reg
    arg.reg[0].scale = 1;
    if (term[0] == '+')
        term ++;
    else if (term[0] == '-')
    {
        term ++;
        arg.reg[0].scale = -1;
    }
    if (isdigit(term[0]))
    {
        arg.reg[0].scale *= term[0]-'0';
        term ++;
    }
    FindMainReg (term, arg.reg[0]);
    if (arg.reg[0].reg == NONE)
        return;
    if (arg.reg[0].bFullReg)
        term += 3;
    else
        term += 2;
    if (term[0] == ']')
    {
        // It is [reg]
        arg.mode = INDIRECT;
        arg.value = 0;
        return;
    }

    char sign = (char)((term[0] == '+')?1:-1);
    term ++;
    FindMainReg (term, arg.reg[1]);
    if (arg.reg[1].reg != NONE)
    {
        // It is either [reg+reg*c] or [reg+reg*c+c]
        if (arg.reg[1].bFullReg)
            term += 3;
        else
            term += 2;
        if (term[0] == '*')
        {
            term ++;
            arg.reg[1].scale = sign*(term[0]-'0');
            term ++;
        }
        else
            arg.reg[1].scale = sign;
    
        if (term[0] == ']')
        {
            // It is [reg+reg*c]
            arg.mode = INDIRECT;
            arg.value = 0;
            return;
        }
        sign = (char)((term[0] == '+')?1:-1);
        term ++;
    }
    
    char *endptr;
    arg.value = strtol(term, &endptr, 16);
    if (endptr[0] == ']')
    {
        // It is [reg+reg*c+c]
        arg.value *= sign;
        arg.mode = INDIRECT;
    }
}

void DecodeAddressTerm (char *term, InstData& arg)
{
    arg.mode = BAD;
    arg.reg[0].scale = 0;
    arg.reg[1].scale = 0;
    arg.value = 0;
    INT_PTR value;
    
    if (GetValueFromExpr (term, value))
    {
        arg.value = value;
        arg.mode = DATA;
    }
    else
    {
        FindMainReg (term, arg.reg[0]);
        if (arg.reg[0].reg != NONE)
        {
            arg.mode = REG;
        }
        else
        {
            DecodeAddressIndirect (term, arg);
        }
    }
}

static BOOL DecodeLine (char *line, char *inst, InstData& arg1, InstData& arg2)
{
    char *ptr = line;
    if (inst[0] == '*' || !strncmp (ptr, inst, strlen (inst)))
    {
        arg1.mode = BAD;
        arg2.mode = BAD;
        NextTerm (ptr);
        if (*ptr == '\0')
        {
            arg1.mode = NODATA;
            return TRUE;
        }

        DecodeAddressTerm (ptr, arg1);
        NextTerm (ptr);
        if (*ptr == '\0')
        {
            return TRUE;
        }
        DecodeAddressTerm (ptr, arg2);
        return TRUE;
    }
    else
        return FALSE;
}

// Return 0 for non-managed call.  Otherwise return MD address.
DWORD_PTR MDForCall (DWORD_PTR callee)
{
    // call managed code?
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR IP = callee;
    DWORD_PTR gcinfoAddr;

    if (!GetCalleeSite (callee, IP))
        return 0;

    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        return methodDesc;
    }

    // call stub
    char line[256];
    DisasmAndClean (IP, line, 256);
    char *ptr = line;
    NextTerm (ptr);
    NextTerm (ptr);
    if (!strncmp (ptr, "call ", 5)
        && IsMethodDesc (IP))
    {
        return IP;
    }
    else if (!strncmp (ptr, "jmp ", 4))
    {
        // For EJIT/debugger/profiler
        NextTerm (ptr);
        INT_PTR value;
        methodDesc = 0;
        if (GetValueFromExpr (ptr, value))
        {
            IP2MethodDesc (value, methodDesc, jitType, gcinfoAddr);
        }
        return methodDesc;
    }
    return 0;
}

// Handle a call instruction.
void HandleCall (DWORD_PTR callee)
{
    // call managed code?
    DWORD_PTR methodDesc = MDForCall (callee);
    if (methodDesc)
    {
        MethodDesc vMD;
        vMD.Fill (methodDesc);
        NameForMD (&vMD, g_mdName);
        ExtOut (" (%S)", g_mdName);
        return;
    }

    // call unmanaged code?
    char Symbol[1024];
    if (SUCCEEDED(g_ExtSymbols->GetNameByOffset(callee, Symbol, 1024,
                                                NULL, NULL)
        ))
    {
        if (Symbol[0] != '\0')
        {
            ExtOut (" (%s)", Symbol);
            return;
        }
    }

    // A JitHelper?
    const char* name = HelperFuncName(callee);
    if (name) {
        ExtOut (" (JitHelp: %s)", name);
    }
}

// Determine if a value is MT/MD/Obj
void HandleValue(DWORD_PTR value)
{
    // A MethodTable?
    if (IsMethodTable(value))
    {
        NameForMT (value, g_mdName);
        ExtOut (" (MT: %S)", g_mdName);
        return;
    }
    
    // A Managed Object?
    DWORD_PTR dwMTAddr;
    move (dwMTAddr, value);
    if (dwMTAddr == MTForString())
    {
        ExtOut (" (\"");
        StringObjectContent (value, TRUE);
        ExtOut ("\")");
        return;
    }
    else if (IsMethodTable(dwMTAddr))
    {
        NameForMT (dwMTAddr, g_mdName);
        ExtOut (" (Object: %S)", g_mdName);
        return;
    }
    
    // A MethodDesc?
    if (IsMethodDesc(value))
    {
        MethodDesc vMD;
        vMD.Fill(value);
        NameForMD (&vMD, g_mdName);
        ExtOut (" (MD: %S)", g_mdName);
        return;
    }

    // A JitHelper?
    const char* name = HelperFuncName(value);
    if (name) {
        ExtOut (" (JitHelp: %s)", name);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Unassembly a managed code.  Translating managed object,           *  
*    call.                                                             *
*                                                                      *
\**********************************************************************/
void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd)
{
    ULONG_PTR IP = IPBegin;
    char line[256];
    Register reg [NumReg];
    ZeroMemory (reg, sizeof(reg));
    RegIndex dest;
    INT_PTR value;
    BOOL bDigit;
    char *ptr;
    
    while (IP < IPEnd)
    {
        if (IsInterrupt())
            return;
        DisasmAndClean (IP, line, 256);
        ExtOut (line);
        // look at key word
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "mov ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
            {
                NextTerm (ptr);
                if (FindSrc (ptr, reg, value, bDigit))
                {
                    reg[dest].bValid = TRUE;
                    reg[dest].value = value;
                    // Is it a managed obj
                    if (bDigit)
                        HandleValue (reg[dest].value);
                }
            }
        }
        else if (!strncmp (ptr, "call ", 5))
        {
            NextTerm (ptr);
            if (FindSrc (ptr, reg, value, bDigit))
            {
                HandleCall (value);
                // trash EAX, ECX, EDX
                reg[EAX].bValid = FALSE;
                reg[ECX].bValid = FALSE;
                reg[EDX].bValid = FALSE;
            }
        }
        else if (!strncmp (ptr, "lea ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
            {
                NextTerm (ptr);
                if (FindSrc (ptr, reg, value, bDigit))
                {
                    reg[dest].bValid = TRUE;
                    reg[dest].value = value;
                }
            }
        }
        else if (!strncmp (ptr, "push ", 5))
        {
            // do not do anything
            NextTerm (ptr);
            if (FindSrc (ptr, reg, value, bDigit))
            {
                if (bDigit)
                {
                    HandleValue (value);
                }
            }
        }
        else
        {
            // assume this instruction will trash dest reg
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
                reg[dest].bValid = FALSE;
        }
        ExtOut ("\n");
    }
}

// Return TRUE if we have printed something.
BOOL PrintCallInfo (DWORD_PTR vEBP, DWORD_PTR IP,
                    DumpStackFlag& DSFlag,
                    BOOL bSymbolOnly)
{
    char Symbol[1024];
    char filename[MAX_PATH+1];
    ULONG64 Displacement;
    BOOL bOutput = FALSE;

    DWORD_PTR methodDesc = FunctionType (IP);

    /*
    JitType jitType;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    */
    if (methodDesc > 1)
    {
        bOutput = TRUE;
        if (!bSymbolOnly)
            ExtOut ("%08x %08x ", vEBP, IP);
        ExtOut ("(MethodDesc %#x ", methodDesc);
        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        GetMDIPOffset (IP, &vMD, Displacement);
        if (Displacement != 0 && Displacement != -1)
            ExtOut ("+%#x ", Displacement);
        NameForMD (&vMD, g_mdName);
        ExtOut ("%S)", g_mdName);
    }
    else
    {
        if (!DSFlag.fEEonly)
        {
            bOutput = TRUE;
            const char *name;
            if (!bSymbolOnly)
                ExtOut ("%08x %08x ", vEBP, IP);
            if (methodDesc == 0) {
                HRESULT hr;
                hr = g_ExtSymbols->GetNameByOffset(IP, Symbol, 1024, NULL, &Displacement);
                if (SUCCEEDED(hr) && Symbol[0] != '\0')
                {
                    ExtOut ("%s", Symbol);
                    if (Displacement)
                        ExtOut ("+%#x", Displacement);
                    ULONG line;
                    hr = g_ExtSymbols->GetLineByOffset (IP, &line, filename,
                                                        MAX_PATH+1, NULL, NULL);
                    if (SUCCEEDED (hr))
                        ExtOut (" [%s:%d]", filename, line);
                }
            }
            else if (IsMethodDesc (IP))
            {
                DWORD_PTR dwAddr = IP;
                MethodDesc vMD;
                vMD.Fill (dwAddr);
                NameForMD (&vMD, g_mdName);
                dprintf (" (stub for %S)", g_mdName);
            }
            else if (IsMethodDesc (IP+5)) {
                DWORD_PTR dwAddr = IP+5;
                MethodDesc vMD;
                vMD.Fill (dwAddr);
                NameForMD (&vMD, g_mdName);
                dprintf ("%08x (MethodDesc %#x %S)", IP, IP+5, g_mdName);
            }
            else if ((name = HelperFuncName(IP)) != NULL) {
                ExtOut (" (JitHelp: %s)", name);
            }
            else
                ExtOut ("%08x", IP);
        }
    }
    return bOutput;
}

void ExpFuncStateInit (DWORD_PTR *IPRetAddr)
{
    ULONG64 offset;
    if (FAILED(g_ExtSymbols->GetOffsetByName("ntdll!KiUserExceptionDispatcher", &offset))) {
        return;
    }
    char            line[256];
    int i = 0;
    while (i < 3) {
        g_ExtControl->Disassemble (offset, 0, line, 256, NULL, &offset);
        if (strstr (line, "call")) {
            IPRetAddr[i++] = (DWORD_PTR)offset;
        }
    }
}

BOOL GetExceptionContext (DWORD_PTR stack, DWORD_PTR IP, DWORD_PTR *cxrAddr, PCONTEXT cxr,
                          DWORD_PTR *exrAddr, PEXCEPTION_RECORD exr)
{
    static DWORD_PTR IPRetAddr[3] = {0,0,0};

    if (IPRetAddr[0] == 0) {
        ExpFuncStateInit (IPRetAddr);
    }
    *cxrAddr = 0;
    *exrAddr = 0;
    if (IP == IPRetAddr[0]) {
        *exrAddr = stack + sizeof(DWORD_PTR);
        *cxrAddr = stack + 2*sizeof(DWORD_PTR);
    }
    else if (IP == IPRetAddr[1]) {
        *cxrAddr = stack + sizeof(DWORD_PTR);
    }
    else if (IP == IPRetAddr[2]) {
        *exrAddr = stack + sizeof(DWORD_PTR);
        *cxrAddr = stack + 2*sizeof(DWORD_PTR);
    }
    else
        return FALSE;

    if (FAILED (g_ExtData->ReadVirtual(*cxrAddr, &stack, sizeof(stack), NULL)))
        return FALSE;
    *cxrAddr = stack;

    size_t contextSize = offsetof(CONTEXT, ExtendedRegisters);
    //if ((pContext->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)
    //    contextSize += sizeof(pContext->ExtendedRegisters);
    if (FAILED (g_ExtData->ReadVirtual(stack, cxr, contextSize, NULL))) {
        return FALSE;
    }

    if (*exrAddr) {
        if (FAILED (g_ExtData->ReadVirtual(*exrAddr, &stack, sizeof(stack), NULL)))
        {
            *exrAddr = 0;
            return TRUE;
        }
        *exrAddr = stack;
        size_t erSize = offsetof (EXCEPTION_RECORD, ExceptionInformation);
        if (FAILED (g_ExtData->ReadVirtual(stack, exr, erSize, NULL))) {
            *exrAddr = 0;
            return TRUE;
        }
    }
    return TRUE;
}

void DumpStackDummy (DumpStackFlag &DSFlag)
{
    DWORD_PTR eip;
    ULONG64 Offset;
    g_ExtRegisters->GetInstructionOffset (&Offset);
    eip = (DWORD_PTR)Offset;
    
    ExtOut("Current frame: ");
    PrintCallInfo (0, eip, DSFlag, TRUE);
    ExtOut ("\n");

    DWORD_PTR ptr = DSFlag.top & ~3;  // make certain dword aligned
    ExtOut ("ChildEBP RetAddr  Caller,Callee\n");
    while (ptr < DSFlag.end)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR retAddr;
        DWORD_PTR whereCalled;
        move (retAddr, ptr);
        isRetAddr(retAddr, &whereCalled);
        if (whereCalled)
        {
            BOOL bOutput = PrintCallInfo (ptr-4, retAddr, DSFlag, FALSE);
            if (!DSFlag.fEEonly)
            {
                if (whereCalled != 0xFFFFFFFF)
                {
                    ExtOut (", calling ");
                    PrintCallInfo (0, whereCalled, DSFlag, TRUE);
                }
            }
            if (bOutput)
                ExtOut ("\n");
            
            DWORD_PTR cxrAddr;
            CONTEXT cxr;
            DWORD_PTR exrAddr;
            EXCEPTION_RECORD exr;

            if (GetExceptionContext(ptr,retAddr,&cxrAddr,&cxr,&exrAddr,&exr)) {
                bOutput = PrintCallInfo (cxr.Esp,cxr.Eip,DSFlag, FALSE);
                if (bOutput) {
                    ExtOut (" ====> Exception ");
                    if (exrAddr)
                        ExtOut ("Code %x ", exr.ExceptionCode);
                    ExtOut ("cxr@%x", cxrAddr);
                    if (exrAddr)
                        ExtOut (" exr@%x", exrAddr);
                    ExtOut ("\n");
                }
            }
        }
        ptr += sizeof (DWORD_PTR);
    }
}

void DumpRegObjectHelper (const char *regName)
{
    ULONG IREG;
    DEBUG_VALUE value;
    DWORD_PTR reg;
    
    g_ExtRegisters->GetIndexByName(regName, &IREG);
    g_ExtRegisters->GetValue(IREG, &value);
    reg = value.I32;
    if (IsObject(reg)) {
        ExtOut ("%-8s %p ", regName, reg);
        DWORD_PTR mtAddr;
        move (mtAddr, reg);
        NameForMT (mtAddr,g_mdName);
        ExtOut ("%S", g_mdName);
        if (mtAddr == MTForString()) {
            ExtOut ("    ");
            StringObjectContent(reg, FALSE, 40);
        }
        ExtOut ("\n");
    }
}

void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom)
{
    // Registers:ECX, EDX, ESI, EBX, EBP
    ExtOut ("ESP/REG  Object   Name\n");

    DumpRegObjectHelper ("eax");
    DumpRegObjectHelper ("ebx");
    DumpRegObjectHelper ("ecx");
    DumpRegObjectHelper ("edx");
    DumpRegObjectHelper ("esi");
    DumpRegObjectHelper ("edi");
    DumpRegObjectHelper ("ebp");

    DWORD_PTR ptr = StackTop & ~3;  // make certain dword aligned
    for (;ptr < StackBottom; ptr += sizeof(DWORD_PTR))
    {
        if (IsInterrupt())
            return;
        DWORD_PTR objAddr;
        move (objAddr, ptr);
        DWORD_PTR mtAddr;
        if (SUCCEEDED(g_ExtData->ReadVirtual((ULONG64)objAddr, &mtAddr, sizeof(mtAddr), NULL))) {
            if (IsMethodTable(mtAddr)) {
                ExtOut ("%p %p ", (ULONG64)ptr, (ULONG64)objAddr);
                NameForMT (mtAddr,g_mdName);
                ExtOut ("%S", g_mdName);
                if (mtAddr == MTForString()) {
                    ExtOut ("    ");
                    StringObjectContent(objAddr, FALSE, 40);
                }
                ExtOut ("\n");
            }
        }
    }
}


void PrintReg (Register *reg)
{
    ExtOut ("[EBX=%08x ESI=%08x EDI=%08x EBP=%08x ESP=%08x]\n",
             reg[EBX].value, reg[ESI].value, reg[EDI].value, reg[EBP].value,
             reg[ESP].value);
}


// Find the real callee site.  Handle JMP instruction.
// Return TRUE if we get the address, FALSE if not.
BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee)
{
    while (TRUE) {
        unsigned char inst[2];
        if (g_ExtData->ReadVirtual(IP,inst,sizeof(inst),NULL) != S_OK)
        {
            return FALSE;
        }
        if (inst[0] == 0xEB) {
            IP += 2+(char)inst[1];
        }
        else if (inst[0] == 0xE9) {
            int displace;
            if (g_ExtData->ReadVirtual(IP+1,&displace,sizeof(displace),NULL) != S_OK)
            {
                return FALSE;
            }
            else
            {
                IP += 5+displace;
            }
        }
        else if (inst[0] == 0xFF && (inst[1] & 070) == 040) {
            if (inst[1] == 0x25) {
                DWORD displace;
                if (g_ExtData->ReadVirtual(IP+2,&displace,sizeof(displace),NULL) != S_OK)
                {
                    return FALSE;
                }
                if (g_ExtData->ReadVirtual(displace,&displace,sizeof(displace),NULL) != S_OK)
                {
                    return FALSE;
                }
                else
                {
                    IP = displace;
                }
            }
            else
                // Target for jmp is determined from register values.
                return FALSE;
        }
        else
        {
            IPCallee = IP;
            return TRUE;
        }
    }
}


// Find the number of bytes that ret will pop off stack
static BOOL FuncRetSizeDirect (DWORD_PTR IP, DWORD_PTR &retSize)
{
    retSize = 0;
    DWORD_PTR IPCallee;
    if (GetCalleeSite(IP, IPCallee))
    {
        if (IP != IPCallee)
            IP = IPCallee;
    }
    else
        return FALSE;
    
    // UnManaged Code?
    ULONG64 handle;
    g_ExtSystem->GetCurrentProcessHandle(&handle);
    PFPO_DATA data =
        (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle, IP);
    if (data != NULL)
    {
        retSize = data->cdwParams * 4;
        return TRUE;
    }

    // Managed code?
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        MethodDesc MD;
        MD.Fill (methodDesc);
        CodeInfo codeInfo;
        CodeInfoForMethodDesc (MD, codeInfo, FALSE);
        if (codeInfo.IPBegin)
        {
            retSize = codeInfo.argCount;
            return TRUE;
        }
    }

    return FALSE;
}

static BOOL FuncRetSize (DWORD_PTR IP, DWORD_PTR &retSize)
{
    retSize = 0;
    
    DWORD_PTR IPCallee;
    if (GetCalleeSite(IP, IPCallee))
    {
        if (IP != IPCallee)
            IP = IPCallee;
    }
    else
    {
        // It is a jmp, but we can not determine the target
        return FALSE;
    }

    if (FuncRetSizeDirect (IP, retSize))
        return TRUE;
    
    if (IsMethodDesc (IP+5))
    {
        // We are calling a stub
        return FALSE;
    }
    
    // What left are our stub, or unmanaged code without debug info.
    DWORD_PTR IPNow = IP;
    char line[256];
    char *ptr;
    InstData arg1;
    InstData arg2;
        
    while (1)
    {
        DisasmAndClean (IPNow, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "ret", arg1, arg2))
        {
            if (arg1.mode == NODATA)
            {
                retSize = 0;
                return TRUE;
            }
            else if (arg1.mode == DATA)
            {
                retSize = arg1.value;
                return TRUE;
            }
            else
                return FALSE;
        }
    }

    return FALSE;
}

struct FrameRegInfo
{
    int Saved[NumReg];
    int Restored[NumReg];
};

// The only things that a call can change is ESP and EBP value,
// such as in _EH_prolog:
// push 0xff
// push eax
// mov eax,fs:[0]
// push eax
// mov eax,[esp+0xc]
// mov fs:[0],esp
// mov [esp+c],ebp
// lea ebp,[esp+0xc]
// push eax
// ret

// We will try to be conservative.
// If a line is using EBX/ESI/EDI except push, we are outside of Prolog.
// If a line is using EBP, we are also outside of Prolog.
BOOL TraceCall (DWORD_PTR IPBegin, INT_PTR& ESPChange)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP;
    DWORD_PTR retSize;

    if (FuncRetSizeDirect (IPBegin, retSize))
    {
        ESPChange = retSize+4;  // Plus the ret address.
        return TRUE;
    }

    ESPChange = 0;
    if (!GetCalleeSite (IPBegin, IP))
        return FALSE;
    
    InstData arg1;
    InstData arg2;
    BOOL bCorrectStack = TRUE;
    
    while (1)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "ret", arg1, arg2))
        {
            ESPChange += 4;
            if (arg1.mode == DATA)
                ESPChange += arg1.value;
            return bCorrectStack;
        }
        else if (DecodeLine (ptr, "sub ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    ESPChange -= arg1.value;
                else
                    bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "add ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    ESPChange += arg1.value;
                else
                    bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "and ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP
                && arg2.mode == DATA)
            {
                bCorrectStack = FALSE;

                // Be conservative.
                INT_PTR offset = 0;
                INT_PTR remain;
                remain = arg2.value;
                while (remain)
                {
                    offset = (offset << 8) + (0x100 - (remain & 0xff));
                    remain = remain >> 8;
                }
                ESPChange -= offset;
            }
        }
        else if (DecodeLine (ptr, "push ", arg1, arg2))
        {
            ESPChange -= 4;
        }
        else if (DecodeLine (ptr, "pop ", arg1, arg2))
        {
            ESPChange += 4;
        }
        else if (DecodeLine (ptr, "lea ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == EBP
                && arg2.mode == INDIRECT && arg2.reg[0].reg == ESP
                && arg2.reg[0].bFullReg && arg2.reg[0].scale == 1
                && arg2.reg[1].scale == 0)
            {
                ;//ESPChange += 4;
            }
        }
        else if (DecodeLine (ptr, "call ", arg1, arg2))
        {
            if (arg1.mode == DATA)
            {
                DWORD_PTR retSize;
                if (FuncRetSize (arg1.value, retSize))
                    ESPChange += retSize;
                else
                {
                    bCorrectStack = FALSE;
                }
            }
            else
            {
                // We lose track of stack.
                // consider ret only.
                bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "*", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
                bCorrectStack = FALSE;
        }
    }
}

#if 0
DWORD_PTR UnmanagedFrameBase (HANDLE PFPO_DATA data,
                              Register *reg,
                              DWORD_PTR CurIP, DWORD_PTR IPBegin)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP;
    if (data->cbFrame == FRAME_NONFPO)
    {
        // EBP Frame

        // Have we done "mov ebp, esp"?
        IP = IPBegin;
        BOOL fMOVEBPESP = FALSE;
        DWORD dwPush = 0;
        while (IP < CurIP && IP - IPBegin <= data->cbProlog)
        {
            DisasmAndClean (IP, line, 256);
            ptr = line;
            NextTerm (ptr);
            NextTerm (ptr);
            if (!strncmp (ptr, "mov ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "ebp", 3))
                {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "esp", 3))
                    {
                        fMOVEBPESP = TRUE;
                        break;
                    }
                }
            }
            else if (!strncmp (ptr, "push ", 5))
                dwPush += 4;
            else if (!strncmp (ptr, "call ", 5))
            {
                NextTerm (ptr);
                DWORD_PTR value;
                if (GetValueFromExpr(ptr, value))
                    dwPush -= FuncRetSize (value);
                else
                    ExtOut ("Can not call the callee site\n");
            }
            else if (!strncmp (ptr, "sub ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "esp", 3))
                {
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    dwPush += value;
                }
            }
            else if (!strncmp (ptr, "add ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "esp", 3))
                {
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    dwPush -= value;
                }
            }
        }

        if (fMOVEBPESP)
        {
            return reg[EBP].value + dwPush;
        }
        else
        {
            return reg[ESP].value + dwPush;
        }
    }
    return -1;
}
#endif

struct CallInfo
{
    DWORD_PTR stackPos;
    DWORD_PTR retAddr;
    DWORD_PTR whereCalled;
};

// Search for a Return address on stack.
BOOL GetNextRetAddr (DWORD_PTR stackBegin, DWORD_PTR stackEnd,
                     CallInfo &callInfo)
{
    for (callInfo.stackPos = stackBegin;
         callInfo.stackPos <= stackEnd;
         callInfo.stackPos += 4)
    {
        if (!SafeReadMemory (callInfo.stackPos, &callInfo.retAddr, 4, NULL))
            continue;
        
        isRetAddr(callInfo.retAddr, &callInfo.whereCalled);
        if (callInfo.whereCalled)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

struct FrameInfo
{
    DWORD_PTR IPStart;
    DWORD_PTR Prolog;
    DWORD_PTR FrameBase;   // The value of ESP at the entry.
    DWORD_PTR StackEnd;
    DWORD_PTR argCount;
    BOOL bEBPFrame;
};

// if a EBP frame, return TRUE if EBP has been setup
void GetFrameBaseHelper (DWORD_PTR IPBegin, DWORD_PTR IPEnd,
                         INT_PTR &StackChange)
{
    char line[256];
    char *ptr;
    InstData arg1;
    InstData arg2;
    DWORD_PTR IP = IPBegin;
    StackChange = 0;
    while (IP < IPEnd)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "push ", arg1, arg2))
        {
            StackChange += 4;
        }
        else if (DecodeLine (ptr, "pop ", arg1, arg2))
        {
            StackChange -= 4;
        }
        else if (DecodeLine (ptr, "sub ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    StackChange -= arg2.value;
            }
        }
        else if (DecodeLine (ptr, "add ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    StackChange += arg2.value;
            }
        }
        else if (!strncmp (ptr, "ret", 3)) {
            return;
        }
    }
}

enum IPSTATE {IPPROLOG1 /*Before EBP set*/, IPPROLOG2 /*After EBP set*/, IPCODE, IPEPILOG, IPEND};

IPSTATE GetIpState (DWORD_PTR IP, FrameInfo* pFrame)
{
    char line[256];
    char *ptr;
    
    if (IP >= pFrame->IPStart && IP < pFrame->IPStart + pFrame->Prolog)
    {
        if (pFrame->bEBPFrame) {
            DWORD_PTR pIP = pFrame->IPStart;
            while (pIP < IP) {
                DisasmAndClean (IP,line, 256);
                ptr = line;
                NextTerm (ptr);
                NextTerm (ptr);
                if (!strncmp (ptr, "mov ", 4)) {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "ebp", 3)) {
                        NextTerm (ptr);
                        if (!strncmp (ptr, "esp", 3)) {
                            return IPPROLOG2;
                        }
                    }
                }
                else if (!strncmp (ptr, "call ", 5)) {
                    NextTerm (ptr);
                    if (strstr (ptr, "__EH_prolog")) {
                        return IPPROLOG2;
                    }
                }
            }
            pIP = IP;
            while (pIP < pFrame->IPStart + pFrame->Prolog) {
                DisasmAndClean (IP,line, 256);
                ptr = line;
                NextTerm (ptr);
                NextTerm (ptr);
                if (!strncmp (ptr, "mov ", 4)) {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "ebp", 3)) {
                        NextTerm (ptr);
                        if (!strncmp (ptr, "esp", 3)) {
                            return IPPROLOG1;
                        }
                    }
                }
                else if (!strncmp (ptr, "call ", 5)) {
                    NextTerm (ptr);
                    if (strstr (ptr, "__EH_prolog")) {
                        return IPPROLOG1;
                    }
                }
            }

            ExtOut ("Fail to find where EBP is saved\n");
            return IPPROLOG2;
        }
        else
        {
            return IPPROLOG1;
        }
    }
    
    int nline = 0;
    while (1) {
        DisasmAndClean (IP,line, 256);
        nline ++;
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "ret", 3)) {
            return (nline==1)?IPEND:IPEPILOG;
        }
        else if (!strncmp (ptr, "leave", 5)) {
            return IPEPILOG;
        }
        else if (!strncmp (ptr, "call", 4)) {
            return IPCODE;
        }
        else if (ptr[0] == 'j') {
            return IPCODE;
        }
    }
}

// FrameBase is the ESP value at the entry of a function.
BOOL GetFrameBase (Register callee[], FrameInfo* pFrame)
{
    //char line[256];
    //char *ptr;
    INT_PTR dwpushed = 0;
    //DWORD_PTR IP;
    
    IPSTATE IpState = GetIpState (callee[EIP].value, pFrame);

    if (pFrame->bEBPFrame)
    {
        if (IpState == IPEND || IpState == IPPROLOG1) {
            pFrame->FrameBase = callee[ESP].value;
        }
        else
        {
            pFrame->FrameBase = callee[EBP].value+4;
        }
        return TRUE;
    }
    else
    {
        if (IpState == IPEND) {
            pFrame->FrameBase = callee[ESP].value;
            return TRUE;
        }

        DWORD_PTR IPBegin, IPEnd;
        if (IpState == IPEPILOG) {
            IPBegin = callee[EIP].value;
            IPEnd = -1;
        }
        else if (IpState == IPPROLOG1) {
            IPBegin = pFrame->IPStart;
            IPEnd = callee[EIP].value;
        }
        else
        {
            IPBegin = pFrame->IPStart;
            IPEnd = IPBegin + pFrame->Prolog;
        }
        GetFrameBaseHelper (IPBegin, IPEnd, dwpushed);

        if (IpState == IPEPILOG) {
            ExtOut ("stack %d\n", dwpushed);
            pFrame->FrameBase = callee[ESP].value - dwpushed;
            return TRUE;
        }

        CallInfo callInfo;
        if (GetNextRetAddr (callee[ESP].value + dwpushed,
                            pFrame->StackEnd, callInfo))
        {
            pFrame->FrameBase = callInfo.stackPos;
            return TRUE;
        }

        return FALSE;
    }
}

// caller[ESP]: the ESP value when we return to caller.
void RestoreCallerRegister (Register callee[], Register caller[],
                            FrameInfo *pFrame)
{
    if (pFrame->bEBPFrame)
    {
        if (callee[ESP].value < pFrame->FrameBase)
        {
            SafeReadMemory (pFrame->FrameBase-4, &caller[EBP].value, 4, NULL);
        }
        else
            caller[EBP].value = callee[EBP].value;
    }
    else
        caller[EBP].value = callee[EBP].value;
    
    caller[EBP].bValid = TRUE;
    caller[ESP].value = pFrame->FrameBase + 4 + pFrame->argCount;
    callee[EBP].value = pFrame->FrameBase - sizeof(void*);
    SafeReadMemory (pFrame->FrameBase, &caller[EIP].value, 4, NULL);
}

BOOL GetFrameInfoHelper (Register callee[], Register caller[],
                         FrameInfo *pFrame)
{
    if (GetFrameBase (callee, pFrame))
    {
        RestoreCallerRegister (callee, caller, pFrame);
        return TRUE;
    }
    else
        return FALSE;
}

// Return TRUE if Frame Info is OK, otherwise FALSE.
BOOL GetUnmanagedFrameInfo (Register callee[], Register caller[],
                            DumpStackFlag &DSFlag, PFPO_DATA data)
{
    FrameInfo Frame;
    ULONG64 base;
    g_ExtSymbols->GetModuleByOffset (callee[EIP].value, 0, NULL, &base);
    Frame.IPStart = data->ulOffStart + (ULONG_PTR)base;
    Frame.Prolog = data->cbProlog;
    // Why do we have to do this to make it work?
    if (Frame.Prolog == 1) {
        Frame.Prolog = 0;
    }
    Frame.bEBPFrame = (data->cbFrame == FRAME_NONFPO);
    Frame.StackEnd = DSFlag.end;
    Frame.argCount = data->cdwParams*4;

    return GetFrameInfoHelper (callee, caller, &Frame);
}

BOOL GetManagedFrameInfo (Register callee[], Register caller[],
                          DumpStackFlag &DSFlag, CodeInfo *pcodeInfo)
{
    FrameInfo Frame;
    Frame.IPStart = pcodeInfo->IPBegin;
    Frame.Prolog = pcodeInfo->prologSize;
    Frame.bEBPFrame = pcodeInfo->ebpFrame;
    Frame.StackEnd = DSFlag.end;
    Frame.argCount = pcodeInfo->argCount;
    
    return GetFrameInfoHelper (callee, caller, &Frame);
}

#if 0
class IPInfo
{
public:
private:
    struct Range {
        size_t begin;
        size_t end;
    };
    IPRange m_Range[8];
    IPRange *nextRange;
};
#endif

// offsetEBP: offset of stack position where EBP is saved.
// If EBP is not saved, *offsetEBP = -1;
BOOL IPReachable (DWORD_PTR IPBegin, DWORD_PTR IP, DWORD *offsetEBP)
{
    *offsetEBP = -1;
    return FALSE;
}
    
BOOL HandleEEStub (Register callee[], Register caller[], 
                   DumpStackFlag &DSFlag)
{
    // EEStub can only be called by IP directory.  Let's look for possible caller.
    CallInfo callInfo;
    DWORD_PTR stackPos = callee[ESP].value;
    while (stackPos < DSFlag.end) {
        if (GetNextRetAddr (stackPos,
                            DSFlag.end, callInfo))
        {
            if (callInfo.whereCalled != -1) {
                DWORD offsetEBP;
                if (IPReachable (callInfo.whereCalled, callee[EIP].value, &offsetEBP)) {
                    caller[EIP].value = callInfo.retAddr;
                    // TODO: We may have saved EBP.
                    if (offsetEBP == -1) {
                        caller[EBP].value = callee[EBP].value;
                    }
                    else
                        SafeReadMemory (callInfo.stackPos-sizeof(PVOID)-offsetEBP,&caller[EBP].value, sizeof(PVOID), NULL);
                    caller[ESP].value = callInfo.stackPos+sizeof(PVOID);
                    return TRUE;
                }
            }
            stackPos = callInfo.stackPos+sizeof(PVOID);
        }
        else
            return FALSE;
    }

    return FALSE;
}


BOOL HandleByEpilog (Register callee[], Register caller[], 
                    DumpStackFlag &DSFlag)
{
    return FALSE;
}



BOOL GetFrameInfo (Register callee[], Register caller[],
                   DumpStackFlag &DSFlag)
{
    size_t function = FunctionType (callee[EIP].value);

    if (function == 0) {
        ULONG64 handle;
        g_ExtSystem->GetCurrentProcessHandle(&handle);
        PFPO_DATA data =
            (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle,
                                              callee[EIP].value);
        if (data)
            return GetUnmanagedFrameInfo (callee, caller, DSFlag, data);
        else
        {
            return HandleByEpilog (callee, caller, DSFlag);
        }
    }
    else if (function == 1) {
        // Stub
        if (IsMethodDesc (callee[EIP].value+5))
        {
            // We are about to call a Stub.
            memcpy (caller, callee, sizeof(Register)*NumReg);
            caller[ESP].value += 4;
            SafeReadMemory (callee[ESP].value, &caller[EIP].value, 4, NULL);
            return TRUE;
        }
        else if (IsMethodDesc (callee[EIP].value))
        {
            // We are calling a Stub.
            memcpy (caller, callee, sizeof(Register)*NumReg);
            caller[ESP].value += 8;
            SafeReadMemory (callee[ESP].value, &caller[EIP].value, 4, NULL);
            return TRUE;
        }
        else
        {
            // Stub
            return HandleEEStub (callee, caller, DSFlag);
        }
    }
    else
    {
        // Managed code
        DWORD_PTR methodDesc = function;
        MethodDesc MD;
        MD.Fill (methodDesc);
        CodeInfo codeInfo;
        CodeInfoForMethodDesc (MD, codeInfo, FALSE);
        if (codeInfo.IPBegin)
        {
            return GetManagedFrameInfo (callee, caller, DSFlag, &codeInfo);
        }
    }

    return FALSE;
}

void RestoreFrameUnmanaged (Register *reg, DWORD_PTR CurIP)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP = CurIP;
    INT_PTR value;
    BOOL bDigit;
    BOOL bGoodESP = true;
    RegIndex dest;

    ULONG64 base;
    g_ExtSymbols->GetModuleByOffset (CurIP, 0, NULL, &base);
    ULONG64 handle;
    g_ExtSystem->GetCurrentProcessHandle(&handle);
    PFPO_DATA data =
        (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle, CurIP);
    DWORD_PTR IPBegin = data->ulOffStart + (ULONG_PTR)base;

    if (CurIP - IPBegin <= data->cbProlog)
    {
        // We are inside a prolog.
        // See where we save the callee saved register.
        // Also how many DWORD's we pushd
        IP = IPBegin;
        reg[ESP].stack = 0;
        reg[ESP].bOnStack = FALSE;
        reg[EBP].stack = 0;
        reg[EBP].bOnStack = FALSE;
        reg[ESI].stack = 0;
        reg[ESI].bOnStack = FALSE;
        reg[EDI].stack = 0;
        reg[EDI].bOnStack = FALSE;
        reg[EBX].stack = 0;
        reg[EBX].bOnStack = FALSE;

        while (IP < CurIP)
        {
            DisasmAndClean (IP, line, 256);
            ptr = line;
            NextTerm (ptr);
            NextTerm (ptr);
            if (!strncmp (ptr, "push ", 5))
            {
                reg[ESP].stack += 4;
                NextTerm (ptr);
                dest = FindReg(ptr);
                if (dest == EBP || dest == EBX || dest == ESI || dest == EDI)
                {
                    reg[dest].bOnStack = TRUE;
                    reg[dest].stack = reg[ESP].stack;
                }
            }
            else if (!strncmp (ptr, "sub ", 4))
            {
                NextTerm (ptr);
                dest = FindReg(ptr);
                if (dest == ESP)
                {
                    NextTerm (ptr);
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    reg[ESP].stack += value;
                }
            }
        }
        
        DWORD_PTR baseESP = reg[ESP].value + reg[ESP].stack;
        if (reg[EBP].bOnStack)
        {
            move (reg[EBP].value, baseESP-reg[EBP].stack);
        }
        if (reg[EBX].bOnStack)
        {
            move (reg[EBX].value, baseESP-reg[EBX].stack);
        }
        if (reg[ESI].bOnStack)
        {
            move (reg[ESI].value, baseESP-reg[ESI].stack);
        }
        if (reg[EDI].bOnStack)
        {
            move (reg[EDI].value, baseESP-reg[EDI].stack);
        }
        move (reg[EIP].value, baseESP);
        reg[ESP].value = baseESP + 4;
        return;
    }

    if (data->cbFrame == FRAME_NONFPO)
    {
        // EBP Frame
    }
    
    // Look for epilog
    while (1)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "mov ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == ESP)
            {
                NextTerm (ptr);
                if (FindReg(ptr) == EBP)
                {
                    // We have a EBP frame
                    bGoodESP = true;
                    reg[ESP].value = reg[EBP].value;
                }
            }
        }
        else if (!strncmp (ptr, "ret", 3))
        {
            NextTerm (ptr);
            // check the value on stack is a return address.
            DWORD_PTR retAddr;
            DWORD_PTR whereCalled;
            move (retAddr, reg[ESP].value);
            int ESPAdjustCount = 0;
            while (1)
            {
                isRetAddr(retAddr, &whereCalled);
                if (whereCalled)
                    break;
                ESPAdjustCount ++;
                reg[ESP].value += 4;
                move (retAddr, reg[ESP].value);
            }
            reg[EIP].value = retAddr;
            if (ESPAdjustCount)
            {
                ESPAdjustCount *= 4;
            }
            if (reg[EBX].bOnStack)
            {
                reg[EBX].stack += ESPAdjustCount;
                move (reg[EBX].value, reg[EBX].stack);
            }
            if (reg[ESI].bOnStack)
            {
                reg[ESI].stack += ESPAdjustCount;
                move (reg[ESI].value, reg[EBX].stack);
            }
            if (reg[EDI].bOnStack)
            {
                reg[EDI].stack += ESPAdjustCount;
                move (reg[EDI].value, reg[EBX].stack);
            }
            
            reg[ESP].value += 4;
            if (ptr[0] != '\0')
            {
                FindSrc (ptr, reg, value, bDigit);
                reg[ESP].value += value;
            }
            break;
        }
        else if (!strncmp (ptr, "pop ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == EBP || dest == EBX || dest == ESI || dest == EDI)
            {
                reg[dest].stack = reg[ESP].value;
                reg[dest].bOnStack = TRUE;
            }
            reg[ESP].value += 4;
        }
        else if (!strncmp (ptr, "add ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == ESP)
            {
                NextTerm (ptr);
                FindSrc (ptr, reg, value, bDigit);
                reg[ESP].value += value;
            }
        }
        else if (!strncmp (ptr, "call ", 5))
        {
            // assume we do not have a good value on ESP.
            // We could go into the call and find out number of pushed args.
            bGoodESP = FALSE;
        }
    }
    
    // Look for prolog
}

void DumpStackSmart (DumpStackFlag &DSFlag)
{
    DWORD_PTR ptr = DSFlag.top & ~3;  // make certain dword aligned

    Register callee[NumReg];
    Register caller[NumReg];
    ZeroMemory (callee, sizeof(callee));
    ZeroMemory (caller, sizeof(caller));

    ULONG IEBX;
    g_ExtRegisters->GetIndexByName("ebx", &IEBX);
    ULONG IESI;
    g_ExtRegisters->GetIndexByName("esi", &IESI);
    ULONG IEDI;
    g_ExtRegisters->GetIndexByName("edi", &IEDI);

    DEBUG_VALUE value;
    g_ExtRegisters->GetValue(IEBX, &value);
    callee[EBX].value = value.I32;

    g_ExtRegisters->GetValue(IEDI, &value);
    callee[EDI].value = value.I32;
    
    g_ExtRegisters->GetValue(IESI, &value);
    callee[ESI].value = value.I32;

    ULONG64 Offset;
    g_ExtRegisters->GetStackOffset (&Offset);
    callee[ESP].value = (DWORD_PTR)Offset;
    
    g_ExtRegisters->GetFrameOffset (&Offset);
    callee[EBP].value = (DWORD_PTR)Offset;

    g_ExtRegisters->GetInstructionOffset (&Offset);
    callee[EIP].value = (DWORD_PTR)Offset;

    ExtOut("Current frame: ");
    PrintCallInfo (0, callee[EIP].value, DSFlag, TRUE);
    ExtOut ("\n");
    ptr = caller[ESP].value;
    ExtOut ("ChildEBP RetAddr  Caller,Callee\n");
    BOOL fUseDumb = FALSE;
    while (ptr < DSFlag.end)
    {
        if (IsInterrupt())
            return;
        ExtOut ("EIP:%x EBP:%x ESP:%x -- ", callee[EIP].value, callee[EBP].value, callee[ESP].value);
        ExtOut ("EIP:%x EBP:%x ESP:%x\n", caller[EIP].value, caller[EBP].value, caller[ESP].value);
        if (!GetFrameInfo (callee, caller, DSFlag)) {
            fUseDumb = TRUE;
            DSFlag.top = callee[ESP].value;
            break;
        }
        ExtOut ("EIP:%x EBP:%x ESP:%x -- ", callee[EIP].value, callee[EBP].value, callee[ESP].value);
        ExtOut ("EIP:%x EBP:%x ESP:%x\n", caller[EIP].value, caller[EBP].value, caller[ESP].value);
        DWORD_PTR whereCalled;
        isRetAddr(caller[EIP].value, &whereCalled);
        if (whereCalled) {
            PrintCallInfo (callee[EBP].value, caller[EIP].value, DSFlag, FALSE);
            if (whereCalled != 0xFFFFFFFF) {
                ExtOut (", calling ");
                PrintCallInfo (0,whereCalled,DSFlag,TRUE);
            }
            ExtOut ("\n");
        }
        else
            break;
        memcpy (callee, caller, sizeof (caller));
        if (ptr >= caller[ESP].value) {
            break;
        }
        ptr = caller[ESP].value;
    }

    if (fUseDumb) {
        // TODO: Add back;
        // DumpStackDummy (DSFlag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\exts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning(disable:4245)   // signed/unsigned mismatch
#pragma warning(disable:4100)   // unreferenced formal parameter
#pragma warning(disable:4201)   // nonstandard extension used : nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant
#include <wdbgexts.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MINIDUMP

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

extern BOOL ControlC;

inline BOOL IsInterrupt() 
{
    if (ControlC) {
        return ControlC;
    }
    if (g_ExtControl->GetInterrupt() == S_OK)
        ControlC = TRUE;
    return ControlC;
}
    
//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

class __ExtensionCleanUp
{
public:
    __ExtensionCleanUp(){}
    ~__ExtensionCleanUp(){ExtRelease();}
};
    
#define INIT_API()                                           \
    HRESULT Status;                                          \
    __ExtensionCleanUp __extensionCleanUp;                   \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;  \
    ControlC = FALSE;                                        \
    CheckEEDll ();
    

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) ((LONG64) (LONG) PageSize - 1))))

extern ULONG PageSize;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;

extern ULONG g_VDbgEng;

#define moveN(dst, src)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, sizeof(dst), NULL);  \
    if (FAILED(ret)) return ret;                                        \
}

#define moveBlockN(dst, src, size)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, size, NULL);         \
    if (FAILED(ret)) return ret;                                        \
}

#define move(dst, src)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, sizeof(dst), NULL);  \
    if (FAILED(ret)) return;                                            \
}

#define moveBlock(dst, src, size)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, size, NULL);         \
    if (FAILED(ret)) return;                                            \
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)

#ifndef UNDER_CE
#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif
#endif //!UNDER_CE

//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\gcdumpia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                               GCDumpX86.cpp
 */

/*****************************************************************************/
#ifdef _IA64_
/*****************************************************************************/

#include "GCDump.h"
#include "Endian.h"


/*****************************************************************************/

/*****************************************************************************/

/*****************************************************************************/

unsigned    GCDump::DumpInfoHdr (const BYTE *   table,
                                 InfoHdr*       header,
                                 unsigned*      methodSize,
                                 bool           verifyGCTables)
{
    _ASSERTE(!"NYI");
    return 0;
}

/*****************************************************************************/

unsigned    GCDump::DumpGCTable(const BYTE *   table,
                                const InfoHdr& header,
                                unsigned       methodSize,
                                bool           verifyGCTables)
{
    _ASSERTE(!"NYI");
    return 0;
}


/*****************************************************************************/

void    GCDump::DumpPtrsInFrame(const void *infoBlock,
                                const void *codeBlock,
                                unsigned    offs,
                                bool        verifyGCTables)
{
    _ASSERTE(!"NYI");
}

/*****************************************************************************/
#endif // _IA64_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\ntinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _ntinfo_h__
#define _ntinfo_h__

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx
class  ContextStackNode;
//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
    // jsimmons 5/23/2001
    // Alert Alert:  nefarious folks (eg, URT) are looking in our TLS at
    // various stuff.   They expect that pCurrentCtx will be at a certain
    // offset from the beginning of the tls struct. So don't add, delete, or 
    // move any members within this block.

/////////////////////////////////////////////////////////////////////////////////////////
// ********* BEGIN "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator

    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
/////////////////////////////////////////////////////////////////////////////////////////
//  ********* END "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////

    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    ULONGLONG           ContextId;          // Uniquely identifies the current context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    IUnknown           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

    IUnknown           *punkActiveXSafetyProvider;

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

    ContextStackNode* pContextStack;

} SOleTlsData;

#endif //_ntinfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\metadata.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a TypeDef using       *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
// Caller should guard against exception
// !!! mdName should have at least mdNameLen WCHAR
static HRESULT NameForTypeDef(mdTypeDef tkTypeDef, IMetaDataImport *pImport,
                              WCHAR *mdName)
{
    DWORD flags;
    ULONG nameLen;
    HRESULT hr = pImport->GetTypeDefProps(tkTypeDef, mdName,
                                          mdNameLen, &nameLen,
                                          &flags, NULL);
    if (hr != S_OK) {
        return hr;
    }

    if (!IsTdNested(flags)) {
        return hr;
    }
    mdTypeDef tkEnclosingClass;
    hr = pImport->GetNestedClassProps(tkTypeDef, &tkEnclosingClass);
    if (hr != S_OK) {
        return hr;
    }
    WCHAR *name = (WCHAR*)_alloca((nameLen+1)*sizeof(WCHAR));
    wcscpy (name, mdName);
    hr = NameForTypeDef(tkEnclosingClass,pImport,mdName);
    if (hr != S_OK) {
        return hr;
    }
    ULONG Len = wcslen (mdName);
    if (Len < mdNameLen-2) {
        mdName[Len++] = L'/';
        mdName[Len] = L'\0';
    }
    Len = mdNameLen-1 - Len;
    if (Len > nameLen) {
        Len = nameLen;
    }
    wcsncat (mdName,name,Len);
    return hr;
}

MDImportSet mdImportSet;

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the Module MD Importer given the name of the Module.         *
*                                                                      *
\**********************************************************************/
IMetaDataImport* MDImportForModule (Module* pModule)
{
    return mdImportSet.GetImport(pModule);
}
    

// Release memory
void MDImportSet::Destroy()
{
    DestroyInternal(root);
}

void MDImportSet::DestroyInternal(MDIMPORT *node)
{
    if (node == NULL)
        return;
    DestroyInternal(node->left);
    DestroyInternal(node->right);

    if (node->name)
        free (node->name);
    if (node->pImport)
        node->pImport->Release();
    if (node->metaData) {
        free (node->metaData);
    }
    free (node);
}

BOOL GetDllMetaData (size_t base, PVOID *ppMetaData, long *pcbMetaData)
{
    IMAGE_DOS_HEADER DosHeader;
    if (g_ExtData->ReadVirtual(base, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
        return FALSE;
    IMAGE_NT_HEADERS32 Header32;
    if (g_ExtData->ReadVirtual(base + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
        return FALSE;
    // If there is no COMHeader, this can not be managed code.
    if (Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress == 0)
        return FALSE;

    size_t CorHeaderAddr = base + Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress;
    size_t nSize = Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].Size;
    if (nSize != sizeof(IMAGE_COR20_HEADER)) {
        return FALSE;
    }
    IMAGE_COR20_HEADER CorHeader;
    if (g_ExtData->ReadVirtual(CorHeaderAddr, &CorHeader, nSize, NULL) != S_OK) {
        return FALSE;
    }
    *ppMetaData = (PVOID)(base + CorHeader.MetaData.VirtualAddress);
    *pcbMetaData = CorHeader.MetaData.Size;
    return TRUE;
}


// Search the BST to get IMetaDataImport for a module.
// If not exist yet, add node and create one.
IMetaDataImport *MDImportSet::GetImport(Module *pModule)
{
    if (pDisp == NULL)
        return NULL;
    
    WCHAR moduleName[MAX_PATH+1] = L"\0";
    FileNameForModule (pModule, moduleName);
    BOOL fDynamic = FALSE;
    if (moduleName[0] == L'\0' && pModule->m_ilBase != 0) {
        fDynamic = TRUE;
        wsprintfW(moduleName, L"%x", pModule->m_ilBase);
    }
    if (moduleName[0] == L'\0' && pModule->m_ilBase == 0) {
        // ToDo: Support dynamic module
        return NULL;
    }

    MDIMPORT **pNode = &root;
    while (*pNode)
    {
        int value = _wcsicmp(moduleName, (*pNode)->name);
        if (value < 0)
            pNode = &((*pNode)->left);
        else if (value > 0)
            pNode = &((*pNode)->right);
        else {
            if ((*pNode)->pImport) {
                return (*pNode)->pImport;
            }
            else if ((*pNode)->type == MDIMPORT::Dynamic) {
                // TODO: We have dynamic module.
                return NULL;
            }
            else
                break;
        }
    }
    MDIMPORT *curNode;
    if (*pNode == 0) {
        *pNode = (MDIMPORT *)malloc (sizeof (MDIMPORT));
        if (*pNode == NULL)
        {
            dprintf ("Not enough memory\n");
            return NULL;
        }
        curNode = *pNode;
        curNode->left = NULL;
        curNode->right = NULL;
        curNode->pImport = NULL;
        curNode->name = (WCHAR *)malloc ((wcslen(moduleName)+1)*sizeof(WCHAR));
        curNode->metaData = NULL;
        if (curNode->name == NULL)
        {
            free (*pNode);
            *pNode = NULL;
            dprintf ("Not enough memory\n");
            return NULL;
        }
        wcscpy (curNode->name, moduleName);
        
        if (pModule->m_ilBase) {
            curNode->base = (size_t)pModule->m_ilBase;
        }
        else
        {
            WCHAR *pwch = wcschr(moduleName,L'\\');
            if (pwch == NULL) {
                pwch = moduleName;
            }
            size_t length = wcslen(pwch);
            char *name = (char *)_alloca(length+1);
            WideCharToMultiByte(CP_ACP,0,pwch,0,name,length,NULL,NULL);
            ULONG64 Base;
            if (g_ExtSymbols->GetModuleByModuleName(name,0,NULL,&Base) == S_OK)
                curNode->base = (size_t)Base;
        }

        if (curNode->base == 0) {
            DWORD_PTR dwAddr = (DWORD_PTR)pModule->m_file;
            if (dwAddr == 0)
                dwAddr = (DWORD_PTR)pModule->m_zapFile;
            if (dwAddr) {
                PEFile vPEFile;
                vPEFile.Fill (dwAddr);
                curNode->base = (size_t)vPEFile.m_base;
            }
        }

        // First see if MetaData exists in memory
        PVOID pMetaData;
        long cbMetaData;
        if (GetDllMetaData(curNode->base, &pMetaData, &cbMetaData)) {
            curNode->metaDataSize = cbMetaData;
            curNode->metaData = (char *)malloc (cbMetaData);
            if (curNode->metaData == NULL) {
                dprintf ("Not enough memory\n");
                free (curNode->name);
                free (*pNode);
                *pNode = NULL;
                return NULL;
            }
            if (g_ExtData->ReadVirtual((ULONG64)pMetaData, curNode->metaData, curNode->metaDataSize,NULL) != S_OK) {
                free (curNode->metaData);
                curNode->metaData = NULL;
            }
        }
        if (curNode->metaData) {
            curNode->type = MDIMPORT::InMemory;
        }
        if ((pModule->m_dwFlags & (Module::IS_IN_MEMORY|Module::IS_REFLECTION))
            == (Module::IS_IN_MEMORY|Module::IS_REFLECTION)) {
            curNode->type = MDIMPORT::Dynamic;
        }
        else
            curNode->type = MDIMPORT::InFile;
    }
    else
        curNode = *pNode;

    // open scope and get import pointer
    IMetaDataImport *pImport;
    HRESULT hr;
    if (curNode->metaData) {
        hr = pDisp->OpenScopeOnMemory(curNode->metaData, curNode->metaDataSize,
                                      ofRead,
                                      IID_IMetaDataImport,
                                      (IUnknown**)&pImport);
    }
    else  if (curNode->type == MDIMPORT::InFile) {
        WCHAR fileName[MAX_PATH+1];
        if (IsMiniDumpFile()) {
            // Find a match Dll
            MatchDllsName(moduleName, fileName, (ULONG64)pModule->m_ilBase);
        }
        else {
            wcscpy (fileName, curNode->name);
        }
        hr = pDisp->OpenScope(fileName, ofRead, IID_IMetaDataImport,
                              (IUnknown**)&pImport);
    }
    else
        return NULL;
    
    if (FAILED (hr))
        return NULL;
    
    curNode->pImport = pImport;
    
    return curNode->pImport;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the name for a metadata token given an importer.             *
*                                                                      *
\**********************************************************************/
HRESULT NameForToken(mdTypeDef mb, IMetaDataImport *pImport, WCHAR *mdName,
                     bool bClassName)
{
    mdName[0] = L'\0';
    if ((mb & 0xff000000) != mdtTypeDef
        && (mb & 0xff000000) != mdtFieldDef
        && (mb & 0xff000000) != mdtMethodDef)
    {
        //dprintf ("unsupported\n");
        return E_FAIL;
    }
    
    HRESULT hr;
    
    __try
        {
            static WCHAR name[MAX_CLASSNAME_LENGTH];
            if ((mb & 0xff000000) == mdtTypeDef)
            {
                hr = NameForTypeDef (mb, pImport, mdName);
            }
            else if ((mb & 0xff000000) ==  mdtFieldDef)
            {
                mdTypeDef mdClass;
                ULONG size;
                hr = pImport->GetMemberProps(mb, &mdClass,
                                             name, sizeof(name)/sizeof(WCHAR)-1, &size,
                                             NULL, NULL, NULL, NULL,
                                             NULL, NULL, NULL, NULL);
                if (SUCCEEDED (hr))
                {
                    if (mdClass != mdTypeDefNil && bClassName)
                    {
                        hr = NameForTypeDef (mdClass, pImport, mdName);
                        wcscat (mdName, L".");
                    }
                    name[size] = L'\0';
                    wcscat (mdName, name);
                }
            }
            else if ((mb & 0xff000000) ==  mdtMethodDef)
            {
                mdTypeDef mdClass;
                ULONG size;
                hr = pImport->GetMethodProps(mb, &mdClass,
                                             name, sizeof(name)/sizeof(WCHAR)-1, &size,
                                             NULL, NULL, NULL, NULL, NULL);
                if (SUCCEEDED (hr))
                {
                    if (mdClass != mdTypeDefNil && bClassName)
                    {
                        hr = NameForTypeDef (mdClass, pImport, mdName);
                        wcscat (mdName, L".");
                    }
                    name[size] = L'\0';
                    wcscat (mdName, name);
                }
            }
            else
            {
                ExtOut ("Unsupported token type\n");
                hr = E_FAIL;
            }
        }
    __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //dprintf ("Metadata operation failure\n");
            hr = E_FAIL;
        }
    return hr;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a metadata token      *  
*    using metadata API.                                               *
*                                                                      *
\**********************************************************************/
void NameForToken(Module *pModule, mdTypeDef mb, WCHAR *mdName,
                  bool bClassName)
{
    mdName[0] = L'\0';
    HRESULT hr = 0;
    IMetaDataImport *pImport = MDImportForModule(pModule);
    if (pImport)
    {
        hr = NameForToken (mb, pImport, mdName, bClassName);
    }
    
    if (!pImport || !SUCCEEDED (hr))
    {
        WCHAR moduleName[MAX_PATH+1];
        FileNameForModule(pModule,moduleName);
        if (moduleName[0] == L'\0') {
            Assembly assembly;
            DWORD_PTR addr = (DWORD_PTR)pModule->m_pAssembly;
            assembly.Fill(addr);
            if (assembly.m_isDynamic) {
                wcscpy(moduleName, L"Dynamic ");
            }
            wcscat (moduleName, L"Module in ");
            WCHAR *ptr = moduleName + wcslen(moduleName);
            if (assembly.m_pwsFullName) {
                PrintString((DWORD_PTR)assembly.m_pwsFullName,TRUE,-1,ptr);
            }
            else if (assembly.m_psName) {
                PrintString((DWORD_PTR)assembly.m_psName,FALSE,-1,ptr);
            }

        }
        wsprintfW (mdName,
                   L" mdToken: %08x (%ws)",
                   mb,
                   moduleName[0] ? moduleName : L"Unknown Module" );
    }
}

#define STRING_BUFFER_LEN 1024

class MDInfo
{
public:
    MDInfo (Module *pModule)
    {
        m_pImport = MDImportForModule(pModule);
        m_pSigBuf = NULL;
    }

    void GetMethodName(mdTypeDef token, CQuickBytes *fullName);

    LPCWSTR TypeDefName(mdTypeDef inTypeDef);
    LPCWSTR TypeRefName(mdTypeRef tr);
    LPCWSTR TypeDeforRefName(mdToken inToken);
private:
    // helper to init signature buffer
    void InitSigBuffer()
    {
        ((LPWSTR)m_pSigBuf->Ptr())[0] = L'\0';
    }

    HRESULT AddToSigBuffer(LPCWSTR string);

    void GetFullNameForMD(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob);
    HRESULT GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb);

    IMetaDataImport *m_pImport;
	// Signature buffer.
	CQuickBytes		*m_pSigBuf;

	// temporary buffer for TypeDef or TypeRef name. Consume immediately
	// because other functions may overwrite it.
	static WCHAR			m_szTempBuf[MAX_CLASSNAME_LENGTH];

    static WCHAR            m_szName[MAX_CLASSNAME_LENGTH];
};

WCHAR MDInfo::m_szTempBuf[MAX_CLASSNAME_LENGTH];
WCHAR MDInfo::m_szName[MAX_CLASSNAME_LENGTH];

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the signiture of a metadata token *  
*    using metadata API.                                               *
*                                                                      *
\**********************************************************************/
void FullNameForMD(MethodDesc *pMD, CQuickBytes *fullName)
{
    DWORD_PTR dwAddr = pMD->m_MTAddr;

    MethodTable MT;
    MT.Fill (dwAddr);
    if (!CallStatus)
    {
        return;
    }
    
    Module vModule;
    dwAddr = (DWORD_PTR)MT.m_pModule;
    vModule.Fill (dwAddr);
    if (!CallStatus) {
        return;
    }

    MDInfo mdInfo(&vModule);

    mdInfo.GetMethodName(pMD->m_dwToken, fullName);
}

// Tables for mapping element type to text
WCHAR *g_wszMapElementType[] = 
{
    L"End",          // 0x0
    L"Void",         // 0x1
    L"Boolean",
    L"Char", 
    L"I1",
    L"UI1",
    L"I2",           // 0x6
    L"UI2",
    L"I4",
    L"UI4",
    L"I8",
    L"UI8",
    L"R4",
    L"R8",
    L"String",
    L"Ptr",          // 0xf
    L"ByRef",        // 0x10
    L"ValueClass",
    L"Class",
    L"CopyCtor",
    L"MDArray",      // 0x14
    L"GENArray",
    L"TypedByRef",
    L"VALUEARRAY",
    L"I",
    L"U",
    L"R",            // 0x1a
    L"FNPTR",
    L"Object",
    L"SZArray",
    L"GENERICArray",
    L"CMOD_REQD",
    L"CMOD_OPT",
    L"INTERNAL",
};
 
WCHAR *g_wszCalling[] = 
{   
    L"[DEFAULT]",
    L"[C]",
    L"[STDCALL]",
    L"[THISCALL]",
    L"[FASTCALL]",
    L"[VARARG]",
    L"[FIELD]",
    L"[LOCALSIG]",
    L"[PROPERTY]",
    L"[UNMANAGED]",
};

void MDInfo::GetMethodName(mdTypeDef token, CQuickBytes *fullName)
{
    if (m_pImport == NULL) {
        return;
    }

    HRESULT hr;
    mdTypeDef memTypeDef;
    ULONG nameLen;
    DWORD flags;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG ulSigBlob;
    ULONG ulCodeRVA;
    ULONG ulImplFlags;

    m_pSigBuf = fullName;
    InitSigBuffer();

    hr = m_pImport->GetMethodProps(token, &memTypeDef, 
                                   m_szTempBuf, MAX_CLASSNAME_LENGTH, &nameLen, 
                                   &flags, &pbSigBlob, &ulSigBlob, &ulCodeRVA, &ulImplFlags);
    if (FAILED (hr))
    {
        return;
    }
    
    m_szTempBuf[nameLen] = L'\0';
    m_szName[0] = L'\0';
    if (memTypeDef != mdTypeDefNil)
    {
        hr = NameForTypeDef (memTypeDef, m_pImport, m_szName);
        if (SUCCEEDED (hr)) {
            wcscat (m_szName, L".");
        }
    }
    wcscat (m_szName, m_szTempBuf);

    GetFullNameForMD(pbSigBlob, ulSigBlob);
}

inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv); 
}

#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)
#endif

#ifndef _ASSERTE
#define _ASSERTE(expr)
#endif

void MDInfo::GetFullNameForMD(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob)
{
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulArgs;
    HRESULT     hr = NOERROR;

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    AddToSigBuffer (g_wszCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]);
    if (cb>ulSigBlob) 
        goto ErrExit;
    cbCur += cb;
    ulSigBlob -= cb;

    if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
        AddToSigBuffer ( L" [hasThis]");
    if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
        AddToSigBuffer ( L" [explicit]");

    AddToSigBuffer (L" ");
    if ( isCallConv(ulData,IMAGE_CEE_CS_CALLCONV_FIELD) )
    {
        // display field type
        if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
            goto ErrExit;
        AddToSigBuffer ( L" ");
        AddToSigBuffer ( m_szName);
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;
    }
    else 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulArgs);
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;

        if (ulData != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG)
        {
            // display return type when it is not a local varsig
            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;
            AddToSigBuffer (L" ");
            AddToSigBuffer (m_szName);
            AddToSigBuffer ( L"(");
            if (cb>ulSigBlob) 
                goto ErrExit;
            cbCur += cb;
            ulSigBlob -= cb;
        }

        ULONG       i = 0;
        while (i < ulArgs && ulSigBlob > 0)
        {
            ULONG       ulData;

            // Handle the sentinal for varargs because it isn't counted in the args.
            CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
            ++i;

            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;
            if (i != ulArgs) {
                AddToSigBuffer ( L",");
            }
            if (cb>ulSigBlob) 
                goto ErrExit;

            cbCur += cb;
            ulSigBlob -= cb;
        }
        AddToSigBuffer ( L")");
    }

    // Nothing consumed but not yet counted.
    cb = 0;

ErrExit:
    // We should have consumed all signature blob.  If not, dump the sig in hex.
    //  Also dump in hex if so requested.
    if (ulSigBlob != 0)
    {
        // Did we not consume enough, or try to consume too much?
        if (cb > ulSigBlob)
            ExtOut("ERROR IN SIGNATURE:  Signature should be larger.\n");
        else
        if (cb < ulSigBlob)
        {
            ExtOut("ERROR IN SIGNATURE:  Not all of signature blob was consumed.  %d byte(s) remain\n", ulSigBlob);
        }
    }
    if (FAILED(hr))
        ExtOut("ERROR!! Bad signature blob value!");
    return;
}

LPCWSTR MDInfo::TypeDefName(mdTypeDef inTypeDef)
{
    if (m_pImport == NULL) {
        return L"";
    }

    HRESULT hr;

    hr = m_pImport->GetTypeDefProps(
                            // [IN] The import scope.
        inTypeDef,              // [IN] TypeDef token for inquiry.
        m_szTempBuf,            // [OUT] Put name here.
        MAX_CLASSNAME_LENGTH,      // [IN] size of name buffer in wide chars.
        NULL,                   // [OUT] put size of name (wide chars) here.
        NULL,                   // [OUT] Put flags here.
        NULL);                  // [OUT] Put base class TypeDef/TypeRef here.

    if (FAILED(hr)) return (L"NoName");
    return (m_szTempBuf);
} // LPCWSTR MDInfo::TypeDefName()
LPCWSTR MDInfo::TypeRefName(mdTypeRef tr)
{
    if (m_pImport == NULL) {
        return L"";
    }

    HRESULT hr;
    
    hr = m_pImport->GetTypeRefProps(           
        tr,                 // The class ref token.
        NULL,               // Resolution scope.
        m_szTempBuf,             // Put the name here.
        MAX_CLASSNAME_LENGTH,             // Size of the name buffer, wide chars.
        NULL);              // Put actual size of name here.
    if (FAILED(hr)) return (L"NoName");

    return (m_szTempBuf);
} // LPCWSTR MDInfo::TypeRefName()

LPCWSTR MDInfo::TypeDeforRefName(mdToken inToken)
{
    if (RidFromToken(inToken))
    {
        if (TypeFromToken(inToken) == mdtTypeDef)
            return (TypeDefName((mdTypeDef) inToken));
        else if (TypeFromToken(inToken) == mdtTypeRef)
            return (TypeRefName((mdTypeRef) inToken));
        else
            return (L"[InvalidReference]");
    }
    else
        return (L"");
} // LPCWSTR MDInfo::TypeDeforRefName()


HRESULT MDInfo::AddToSigBuffer(LPCWSTR string)
{
    HRESULT     hr;
    IfFailRet(m_pSigBuf->ReSize((wcslen((LPWSTR)m_pSigBuf->Ptr()) + wcslen(string) + 1) * sizeof(WCHAR)));
    wcscat((LPWSTR)m_pSigBuf->Ptr(), string);
    return NOERROR;
}

HRESULT MDInfo::GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iTemp;
    mdToken     tk;

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    cbCur += cb;

    // Handle the modifiers.
    if (ulData & ELEMENT_TYPE_MODIFIER)
    {
        if (ulData == ELEMENT_TYPE_SENTINEL)
            IfFailGo(AddToSigBuffer(L"<ELEMENT_TYPE_SENTINEL> "));
        else if (ulData == ELEMENT_TYPE_PINNED)
            IfFailGo(AddToSigBuffer(L"PINNED "));
        else
        {
            hr = E_FAIL;
            goto ErrExit;
        }
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }

    // Handle the underlying element types.
    if (ulData >= ELEMENT_TYPE_MAX) 
    {
        hr = E_FAIL;
        goto ErrExit;
    }
    while (ulData == ELEMENT_TYPE_PTR || ulData == ELEMENT_TYPE_BYREF)
    {
        IfFailGo(AddToSigBuffer(g_wszMapElementType[ulData]));
        IfFailGo(AddToSigBuffer(L" "));
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
    }
    IfFailGo(AddToSigBuffer(g_wszMapElementType[ulData]));
    if (CorIsPrimitiveType((CorElementType)ulData) || 
        ulData == ELEMENT_TYPE_TYPEDBYREF ||
        ulData == ELEMENT_TYPE_OBJECT ||
        ulData == ELEMENT_TYPE_I ||
        ulData == ELEMENT_TYPE_U ||
        ulData == ELEMENT_TYPE_R)
    {
        // If this is a primitive type, we are done
        goto ErrExit;
    }

    AddToSigBuffer(L" ");
    if (ulData == ELEMENT_TYPE_VALUETYPE || 
        ulData == ELEMENT_TYPE_CLASS || 
        ulData == ELEMENT_TYPE_CMOD_REQD ||
        ulData == ELEMENT_TYPE_CMOD_OPT)
    {
        cb = CorSigUncompressToken(&pbSigBlob[cbCur], &tk);
        cbCur += cb;

        // get the name of type ref. Don't care if truncated
        if (TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtTypeRef)
        {
            IfFailGo(AddToSigBuffer(TypeDeforRefName(tk)));
        }
        else
        {
            _ASSERTE(TypeFromToken(tk) == mdtTypeSpec);
            WCHAR buffer[9];
            _itow (tk, buffer, 16);
            IfFailGo(AddToSigBuffer(buffer));
        }
        if (ulData == ELEMENT_TYPE_CMOD_REQD ||
            ulData == ELEMENT_TYPE_CMOD_OPT)
        {
            IfFailGo(AddToSigBuffer(L" "));
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
        }

        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_VALUEARRAY)
    {
        // display the base type of SDARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        // display the size of SDARRAY
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        WCHAR buffer[9];
        _itow (ulData,buffer,10);
        IfFailGo(AddToSigBuffer(L" "));
        IfFailGo(AddToSigBuffer(buffer));
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_SZARRAY)
    {
        // display the base type of SZARRAY or GENERICARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_FNPTR) 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
            IfFailGo(AddToSigBuffer(L"[explicit] "));
        if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
            IfFailGo(AddToSigBuffer(L"[hasThis] "));

        IfFailGo(AddToSigBuffer(g_wszCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]));

            // Get number of args
        ULONG numArgs;
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &numArgs);
        cbCur += cb;

            // do return type
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        IfFailGo(AddToSigBuffer(L"("));
        while (numArgs > 0) 
        {
            if (cbCur > ulSigBlob)
                goto ErrExit;
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
            --numArgs;
            if (numArgs > 0) 
                IfFailGo(AddToSigBuffer(L","));
        }
        IfFailGo(AddToSigBuffer(L")"));
        goto ErrExit;
    }

    if(ulData != ELEMENT_TYPE_ARRAY) return E_FAIL;

    // display the base type of SDARRAY
    if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
        goto ErrExit;
    cbCur += cb;

    IfFailGo(AddToSigBuffer(L" "));
    // display the rank of MDARRAY
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    WCHAR buffer[9];
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    if (ulData == 0)
        // we are done if no rank specified
        goto ErrExit;

    IfFailGo(AddToSigBuffer(L" "));
    // how many dimensions have size specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    if (ulData == 0) {
        IfFailGo(AddToSigBuffer(L" "));
    }
    while (ulData)
    {

        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulTemp);
        _itow (ulTemp, buffer, 10);
        IfFailGo(AddToSigBuffer(buffer));
        IfFailGo(AddToSigBuffer(L" "));
        cbCur += cb;
        ulData--;
    }
    // how many dimensions have lower bounds specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    while (ulData)
    {

        cb = CorSigUncompressSignedInt(&pbSigBlob[cbCur], &iTemp);
        _itow (iTemp, buffer, 10);
        IfFailGo(AddToSigBuffer(buffer));
        IfFailGo(AddToSigBuffer(L" "));
        cbCur += cb;
        ulData--;
    }
    
ErrExit:
    if (cbCur > ulSigBlob)
        hr = E_FAIL;
    *pcb = cbCur;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\miniee.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// !!! Do not include any other header files here.

#include "..\..\inc\corhdr.h"
#include "..\..\inc\cor.h"

// !!!CLR Minidump includes this file.  If you make a change in this file,
// !!!be sure to build ..\minidump

typedef LPCSTR  LPCUTF8;
typedef LPSTR   LPUTF8;

DECLARE_HANDLE(OBJECTHANDLE);

// This will need ifdefs for 64 bit!
#define SLOT    DWORD
#define METHOD_HASH_BYTES  8

class EEClass;
class MethodTable;
class InterfaceInfo_t;
class ClassLoader;
class FieldDesc;
class SecurityProperties;
class Module;
class PEFile;
class Assembly;
class Crst;
class ISymUnmanagedReader;
struct LoaderHeapBlock;

typedef void* OpaqueCtxInfo;
typedef void* IMDInternalImport;
typedef DWORD_PTR IMetaDataDebugImport;
typedef DWORD_PTR IMetaDataHelper;
typedef DWORD_PTR VASigCookieBlock;
typedef DWORD_PTR RangeList;
typedef DWORD_PTR Compare;

#ifndef STRIKE
// Max length in WCHAR for a buffer to store metadata name
const int mdNameLen = 2048;
extern WCHAR g_mdName[mdNameLen];

#ifdef _X86_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
    unsigned char ediSaved   :1;
    unsigned char esiSaved   :1;
    unsigned char ebxSaved   :1;
    unsigned char ebpSaved   :1;
    unsigned char ebpFrame;
    unsigned short argCount;
};

#endif // _X86_

#ifdef _IA64_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
//    unsigned char ediSaved   :1;
//    unsigned char esiSaved   :1;
//    unsigned char ebxSaved   :1;
//    unsigned char ebpSaved   :1;
//    unsigned char ebpFrame;
    unsigned short argCount;
};


#endif // _IA64_
#endif // STRIKE

enum MethodClassification
{
    mcIL        = 0, // IL
    mcECall     = 1, // ECall
    mcNDirect   = 2, // N/Direct
    mcEEImpl    = 3, // special method; implementation provided by EE
    mcArray     = 4, // Array ECall
    mcComInterop  = 5, 
};

enum MethodDescClassification
{
    
    // Method is IL, ECall etc., see MethodClassification above.
    mdcClassification                   = 0x0007,
    mdcClassificationShift              = 0,
};

class MethodDesc
{
public :
    enum
    {
#ifdef _IA64_
        ALIGNMENT_SHIFT = 4,
#else
        ALIGNMENT_SHIFT = 3,
#endif

        ALIGNMENT       = (1<<ALIGNMENT_SHIFT),
        ALIGNMENT_MASK  = (ALIGNMENT-1)
    };
    
//#ifdef _DEBUG

    // These are set only for MethodDescs but every time I want to use the debugger
    // to examine these fields, the code has the silly thing stored in a MethodDesc*.
    // So...
    LPCUTF8         m_pszDebugMethodName;
    LPUTF8          m_pszDebugClassName;
    LPUTF8          m_pszDebugMethodSignature;
    EEClass        *m_pDebugEEClass;
    MethodTable    *m_pDebugMethodTable;
    DWORD           m_alignpad1;             // unused field to keep things 8-byte aligned

//#ifdef STRESS_HEAP
    class GCCoverageInfo* m_GcCover;
    DWORD           m_alignpad2;             // unused field to keep things 8-byte aligned
//#endif
//#endif  // _DEBUG

    // Returns the slot number of this MethodDesc in the vtable array.
    WORD           m_wSlotNumber;

    // Flags.
    WORD           m_wFlags;

//#ifndef TOKEN_IN_PREPAD
    // Lower three bytes are method def token, upper byte is a combination of
    // offset (in method descs) from a pointer to the method table or module and
    // a flag bit (upper bit) that's 0 for a method and 1 for a global function.
    // The value of the type flag is chosen carefully so that GetMethodTable can
    // ignore it and remain fast, pushing the extra effort on the lesser used
    // GetModule for global functions.
    DWORD          m_dwToken;
//#endif

    // Stores either a native code address or an IL RVA (the high bit is set to
    // indicate IL). If an IL RVA is held, native address is assumed to be the
    // prestub address.
    size_t      m_CodeOrIL;

    DWORD_PTR   m_MTAddr;

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

#define METHOD_PREPAD 8

#pragma pack(push,1)

struct StubCallInstrs
{
    unsigned __int16 m_wTokenRemainder;      //a portion of the methoddef token. The rest is stored in the chunk
    BYTE        m_chunkIndex;           //index to recover chunk

// This is a stable and efficient entrypoint for the method
    BYTE        m_op;                   //this is either a jump (0xe9) or a call (0xe8)
    UINT32      m_target;               //pc-relative target for jump or call
    void Fill (DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

#pragma pack(pop)

class MethodDescChunk
{
public:
        // This must be at the beginning for the asm routines to work.
        MethodTable *m_methodTable;

        MethodDescChunk     *m_next;
        USHORT               m_count;
        BYTE                 m_kind;
        BYTE                 m_tokrange;
        UINT32               m_alignpad;

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class MethodTable
{
public:
    enum
    {
        //
        // DO NOT use flags that have bits set in the low 2 bytes.
        // These flags are DWORD sized so that our atomic masking
        // operations can operate on the entire 4-byte aligned DWORD
        // inestead of the logical non-aligned WORD of flags.  This
        // is also the reason for the union around m_ComponentSize
        // and m_wFlags below.
        //
        enum_flag_Array                 =    0x10000,
        enum_flag_large_Object          =    0x20000,
        enum_flag_ContainsPointers      =    0x40000,
        enum_flag_ClassInited           =    0x80000, // definitely ran vs. maybe not ran <clinit>
        enum_flag_HasFinalizer          =   0x100000, // instances require finalization
        enum_flag_Sparse                =   0x200000, // vtables for this interface are sparse
        enum_flag_Shared                =   0x400000, // This method table is shared among multiple logical classes
        enum_flag_Unrestored            =   0x800000, // Preloaded class needs to be restored

        enum_TransparentProxy           =  0x1000000, // tranparent proxy
        enum_flag_SharedAssembly        =  0x2000000, // Class is in a shared assembly
        enum_ComEmulateMask             =  0x4000000, // class is a COM view of managed class
        enum_ServicedComponentMask      =  0x8000000, // class is ServicedComponent

        enum_CtxProxyMask               = 0x10000000, // class is a context proxy
        enum_ComObjectMask              = 0x40000000, // class is a com object
        enum_InterfaceMask              = 0x80000000, // class is a interface
    };


    union
    {
        WORD            m_ComponentSize;            // Component size for array objects or value classes, zero otherwise    
        DWORD           m_wFlags;
    };

    DWORD               m_BaseSize;                 // Base size of instance of this class
    EEClass*            m_pEEClass;                 // class object

    LPVOID*             m_pInterfaceVTableMap;      // pointer to subtable for interface/vtable mapping

    WORD                m_wNumInterface;           // number of interfaces in the interface map
    BYTE                m_NormType;                 // The CorElementType for this class (most classes = ELEMENT_TYPE_CLASS)

    Module*             m_pModule;

    WORD                m_wCCtorSlot;               // slot of class constructor
    WORD                m_wDefaultCtorSlot;         // slot of default constructor

    InterfaceInfo_t*    m_pIMap;                    // pointer interface map

    union
    {
        // valid only if EEClass::IsBlittable() or EEClass::HasLayout() is true
        UINT32      m_cbNativeSize; // size of fixed portion in bytes

        // valid only for interfaces.
        UINT32      m_cbNumImpls; // for interfaces number of implementations

        // valid only for ArrayClasses
        // THIS IS REALLY AN EMBEDDED ARRAYCRACKER CLASS WHICH CONTAINS ONLY A
        // C++ VPTR.
        LPVOID      m_ArrayCracker;

        // For COM+ wrapper objects that extend an unmanaged class, this field
        // may contain a delegate to be called to allocate the aggregated
        // unmanaged class (instead of using CoCreateInstance).
        OBJECTHANDLE    m_ohDelegate;
    };

    DWORD   m_cbSlots; // total slots in this vtable

    SLOT    m_Vtable[1];
/*
    static MethodDesc  *m_FinalizerMD;
    static MetaSig     *m_FinalizerSig;
*/
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class EEClass
{
public :
//#ifdef _DEBUG
    LPUTF8  m_szDebugClassName; // This is the *fully qualified* class name
//#endif

    UINT32 m_dwInterfaceId;
    EEClass *m_pParentClass;
    WORD   m_wNumVtableSlots;  // Includes only vtable methods (which come first in the table)
    WORD   m_wNumMethodSlots;  // Includes vtable + non-vtable methods, but NOT duplicate interface methods
    WORD   m_wDupSlots;         // value classes have some duplicate slots at the end

    WORD   m_wNumInterfaces;

    // We have the parent pointer above.  In order to efficiently backpatch, we need
    // to find all the children of the current type.  This is achieved with a chain of
    // children.  The SiblingsChain is used as the linkage of that chain.
    //
    // Strictly speaking, we could remove m_pParentClass and put it at the end of the
    // sibling chain.  But the perf would really suffer for casting, so we burn the space.
    EEClass *m_SiblingsChain;
    EEClass *m_ChildrenChain;

        // Number of fields in the class, including inherited fields (includes
    WORD   m_wNumInstanceFields;
    WORD   m_wNumStaticFields;

    // Number of pointer series
    WORD    m_wNumGCPointerSeries;

    // TODO: There is a free WORD here 

    // # of bytes of instance fields stored in GC object
    DWORD   m_dwNumInstanceFieldBytes;  // Warning, this can be any number, it is NOT rounded up to DWORD alignment etc

    ClassLoader *m_pLoader;

    // includes all methods in the vtable
    MethodTable *m_pMethodTable;

    // a pointer to a list of FieldDescs declared in this class
    // There are (m_wNumInstanceFields - m_pParentClass->m_wNumInstanceFields + m_wNumStaticFields) entries
    // in this array
    FieldDesc *m_pFieldDescList;


    // Number of elements in pInterfaces or pBuildingInterfaceList (depending on whether the class
    DWORD   m_dwAttrClass;
    DWORD   m_VMFlags;

    BYTE    m_MethodHash[METHOD_HASH_BYTES];

    SecurityProperties *m_pSecProps ;

    mdTypeDef m_cl; // CL is valid only in the context of the module (and its scope)
    

	MethodDescChunk		*m_pChunks;

    WORD    m_wThreadStaticOffset;  // Offset which points to the TLS storage
    WORD    m_wContextStaticOffset; // Offset which points to the CLS storage
    WORD    m_wThreadStaticsSize;   // Size of TLS fields 
    WORD    m_wContextStaticsSize;  // Size of CLS fields

    OBJECTHANDLE   m_ExposedClassObject;
    LPVOID         m_pComData;  // com specific data

    // If a class has special attribute declarations that affect how (where) it
    // should be instantiated, they are stored here.  This is opaque unless you
    // compiler ctxmgr.h
    OpaqueCtxInfo  m_OpaqueCtxInfo;

    void Fill(DWORD_PTR & dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class Crst
{
    public:

        CRITICAL_SECTION    m_criticalsection;
//#ifdef _DEBUG
        char                m_tag[20];          // descriptive string
        enum CrstLevel { Low };
        CrstLevel           m_crstlevel;        // what level is the crst in?
        DWORD               m_holderthreadid;   // current holder (or NULL)
        UINT                m_entercount;       // # of unmatched Enters
        BOOL                m_fAllowReentrancy; // can m_entercount > 1?
        Crst               *m_next;             // link for global linked list
        Crst               *m_prev;             // link for global linked list
//#endif //_DEBUG

//#ifdef _DEBUG
        // This Crst serves as a head-node for double-linked list of crsts.
        // We use its embedded critical-section to guard insertion and
        // deletion into this list.
        //static Crst m_DummyHeadCrst;
//#endif
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class UnlockedLoaderHeap
{
public:
    DWORD_PTR vtbl;
    // Linked list of VirtualAlloc'd pages
    LoaderHeapBlock *   m_pFirstBlock;

    // Allocation pointer in current block
    BYTE *              m_pAllocPtr;

    // Points to the end of the committed region in the current block
    BYTE *              m_pPtrToEndOfCommittedRegion;
    BYTE *              m_pEndReservedRegion;

    LoaderHeapBlock *   m_pCurBlock;

    // When we need to VirtualAlloc() MEM_RESERVE a new set of pages, number of bytes to reserve
    DWORD               m_dwReserveBlockSize;

    // When we need to commit pages from our reserved list, number of bytes to commit at a time
    DWORD               m_dwCommitBlockSize;

    //static DWORD        m_dwSystemPageSize;

    // Created by in-place new?
    BOOL                m_fInPlace;
    // Release memory on destruct
    BOOL                m_fReleaseMemory;

    // Range list to record memory ranges in
    RangeList *         m_pRangeList;

    DWORD               m_dwTotalAlloc;
public:
//#ifdef _DEBUG
    DWORD               m_dwDebugWastedBytes;
//#endif

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

typedef struct LookupMap
{
    // This is not actually a pointer to the beginning of the allocated memory, but instead a pointer
    // to &pTable[-MinIndex].  Thus, if we know that this LookupMap is the correct one, simply index
    // into it.
    void **             pTable;
    struct LookupMap *  pNext;
    DWORD               dwMaxIndex;
    DWORD *             pdwBlockSize; // These all point to the same block size
    
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
} LookupMap_t;

struct LoaderHeap : public UnlockedLoaderHeap
{
public:
    CRITICAL_SECTION    m_CriticalSection;
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class Bucket
{
public:
    ULONG_PTR m_rgKeys[4];
    ULONG_PTR m_rgValues[4];
#define VALUE_MASK (sizeof(LPVOID) == 4 ? 0x7FFFFFFF : 0x7FFFFFFFFFFFFFFF)
    
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

class HashMap
{
public:
	#ifdef PROFILE
		unsigned	m_cbRehash;    // number of times rehashed
		unsigned	m_cbRehashSlots; // number of slots that were rehashed
		unsigned	m_cbObsoleteTables;
		unsigned	m_cbTotalBuckets;
		unsigned	m_cbInsertProbesGt8; // inserts that needed more than 8 probes
		LONG		m_rgLookupProbes[20]; // lookup probes
		UPTR		maxFailureProbe; // cost of failed lookup

	#endif

	//#ifdef _DEBUG
		bool			m_fInSyncCode; // test for non-synchronus access
	//#endif

	Bucket*			m_pObsoleteTables;	// list of obsolete tables
	Compare*		m_pCompare;			// compare object to be used in lookup
	unsigned		m_iPrimeIndex;		// current size (index into prime array)
	Bucket*			m_rgBuckets;		// array of buckets

	// track the number of inserts and deletes
	unsigned		m_cbPrevSlotsInUse;
	unsigned		m_cbInserts;
	unsigned		m_cbDeletes;
	// mode of operation, synchronus or single user
	unsigned		m_fSyncMode;

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

struct PtrHashMap
{
    HashMap m_HashMap;
    
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

#define JUMP_ALLOCATE_SIZE 8

class Module
{
 public:

    WCHAR                   m_wszSourceFile[MAX_PATH];
    DWORD                   m_dwSourceFile;

//#ifdef _DEBUG
	// Force verification even if it's turned off
    BOOL                    m_fForceVerify;
//#endif

	PEFile					*m_file;
	PEFile					*m_zapFile;

	BYTE					*m_ilBase;

    IMDInternalImport       *m_pMDImport;
    IMetaDataEmit           *m_pEmitter;
    IMetaDataImport         *m_pImporter;
    IMetaDataDebugImport    *m_pDebugImport;
    IMetaDataHelper         *m_pHelper;
    IMetaDataDispenserEx    *m_pDispenser;

    MethodDesc              *m_pDllMain;

    enum {
        INITIALIZED					= 0x0001,
        HAS_CRITICAL_SECTION		= 0x0002,
		IS_IN_MEMORY				= 0x0004,
		IS_REFLECTION				= 0x0008,
		IS_PRELOAD					= 0x0010,
		SUPPORTS_UPDATEABLE_METHODS	= 0x0020,
		CLASSES_FREED				= 0x0040,
		IS_PEFILE					= 0x0080,
		IS_PRECOMPILE				= 0x0100,
		IS_EDIT_AND_CONTINUE		= 0x0200,
    };

    DWORD                   m_dwFlags;

    // Linked list of VASig cookie blocks: protected by m_pStubListCrst
    VASigCookieBlock        *m_pVASigCookieBlock;

    Assembly                *m_pAssembly;
	mdFile					m_moduleRef;
	int						m_dwModuleIndex;

    Crst                   *m_pCrst;
    BYTE                    m_CrstInstance[sizeof(Crst)];

    // If a TypeLib is ever required for this module, cache the pointer here.
    ITypeLib                *m_pITypeLib;
    ITypeLib                *m_pITypeLibTCE;

    // May point to the default instruction decoding table, in which
    // case we should not free it
    void *                  m_pInstructionDecodingTable;

    MethodDescChunk         *m_pChunks;

    MethodTable             *m_pMethodTable;

	// Debugging symbols reader interface. This will only be
	// initialized if needed, either by the debugging subsystem or for
	// an exception.
	ISymUnmanagedReader     *m_pISymUnmanagedReader;

    // Next module loaded by the same classloader (all modules loaded by the same classloader
    // are linked through this field).
    Module *				m_pNextModule;

	// Base DLS index for classes in this module
	DWORD					m_dwBaseClassIndex;

	// Range of preloaded image, to facilitate proper cleanup
	void					*m_pPreloadRangeStart;
	void					*m_pPreloadRangeEnd;

	// Table of thunks for unmanaged vtables
    BYTE *					m_pThunkTable;

    // Exposed object of Class object for the module
    OBJECTHANDLE            m_ExposedModuleObject;

    LoaderHeap *			m_pLookupTableHeap;
    BYTE					m_LookupTableHeapInstance[sizeof(LoaderHeap)]; // For in-place new()

    // For protecting additions to the heap
    Crst                   *m_pLookupTableCrst;
    BYTE                    m_LookupTableCrstInstance[sizeof(Crst)];

    // Linear mapping from TypeDef token to MethodTable *
    LookupMap 				m_TypeDefToMethodTableMap;
    DWORD					m_dwTypeDefMapBlockSize;

    // Linear mapping from TypeRef token to TypeHandle *
    LookupMap 				m_TypeRefToMethodTableMap;

    DWORD					m_dwTypeRefMapBlockSize;

    // Linear mapping from MethodDef token to MethodDesc *
    LookupMap 				m_MethodDefToDescMap;
    DWORD					m_dwMethodDefMapBlockSize;

    // Linear mapping from FieldDef token to FieldDesc*
    LookupMap 				m_FieldDefToDescMap;
    DWORD					m_dwFieldDefMapBlockSize;

    // Linear mapping from MemberRef token to MethodDesc*, FieldDesc*
    LookupMap 				m_MemberRefToDescMap;
    DWORD					m_dwMemberRefMapBlockSize;

    // Mapping from File token to Module *
    LookupMap 				m_FileReferencesMap;
    DWORD					m_dwFileReferencesMapBlockSize;

    // Mapping of AssemblyRef token to Assembly *
    LookupMap 				m_AssemblyReferencesMap;
    DWORD					m_dwAssemblyReferencesMapBlockSize;

    // Object handle cache for declarative demands
    PtrHashMap              m_LinktimeDemandsHashMap;

    // This buffer is used to jump to the prestub in preloaded modules
    BYTE					m_PrestubJumpStub[JUMP_ALLOCATE_SIZE];

    // This buffer is used to jump to the ndirect import stub in preloaded modules
    BYTE					m_NDirectImportJumpStub[JUMP_ALLOCATE_SIZE];

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

typedef struct _dummyCOR { BYTE b; } *HCORMODULE;

class PEFile
{
  public:

    WCHAR               m_wszSourceFile[MAX_PATH];

	HMODULE				m_hModule;
	HCORMODULE			m_hCorModule;
	BYTE				*m_base;
    IMAGE_NT_HEADERS	*m_pNT;
	IMAGE_COR20_HEADER	*m_pCOR;

	PEFile				*m_pNext;
	BOOL				m_orphan;
    LPCWSTR             m_pLoadersFileName;

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};

typedef struct _rangesection
{
    DWORD_PTR    LowAddress;
    DWORD_PTR    HighAddress;

    DWORD_PTR    pjit;
    DWORD_PTR    ptable;

    DWORD_PTR    pright;
    DWORD_PTR    pleft;
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
} RangeSection;

typedef struct _heapList {
    DWORD_PTR hpNext;
    DWORD_PTR pHeap;
    DWORD   startAddress;
    DWORD   endAddress;
    volatile DWORD  changeStart;
    volatile DWORD  changeEnd;
    DWORD   mapBase;
    DWORD   pHdrMap;
    DWORD   cBlocks;
    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
} HeapList;

struct COR_ILMETHOD_SECT_EH_FAT;
struct CORCOMPILE_METHOD_HEADER
{
    BYTE                        *gcInfo;
    COR_ILMETHOD_SECT_EH_FAT    *exceptionInfo;
    void                        *methodDesc;
    BYTE                        *fixupList;

    void Fill(DWORD_PTR &dwStartAddr);
#ifdef STRIKE
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\strike.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __strike_h__
#define __strike_h__

#pragma warning(disable:4245)   // signed/unsigned mismatch
#pragma warning(disable:4100)   // unreferenced formal parameter
#pragma warning(disable:4201)   // nonstandard extension used : nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant

#ifndef UNDER_CE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
//#include <heap.h>
//#include <ntsdexts.h>
#endif

#include <windows.h>

//#define NOEXTAPI
#define KDEXT_64BIT
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <malloc.h>
#include <stddef.h>

#include <basetsd.h>  

#define  CORHANDLE_MASK 0x1

// C_ASSERT() can be used to perform many compile-time assertions:
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#include "exts.h"

extern BOOL CallStatus;

#endif // __strike_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\strike.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
* STRIKE.C                                                                  *
*   Routines for the NTSD extension - STRIKE                                *
*                                                                           *
* History:                                                                  *
*   09/07/99  larrysu     Created                                           *
*                                                                           *
*                                                                           *
\***************************************************************************/

#ifndef UNDER_CE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
//#include <heap.h>
//#include <ntsdexts.h>
#endif // UNDER_CE

#include <windows.h>

#define NOEXTAPI
#define KDEXT_64BIT
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <malloc.h>
#include <stddef.h>

#include "strike.h"

#define STRESS_LOG
#include "stresslog.h"

#ifndef UNDER_CE
#include <dbghelp.h>
#endif

#include "..\..\inc\corhdr.h"
#include "..\..\inc\cor.h"

#define  CORHANDLE_MASK 0x1

#include "eestructs.h"

#define DEFINE_EXT_GLOBALS

#include "data.h"
#include "disasm.h"

BOOL CallStatus;
DWORD_PTR EEManager = NULL;
int DebugVersionDll = -1;
BOOL ControlC = FALSE;

IMetaDataDispenserEx *pDisp = NULL;
WCHAR g_mdName[mdNameLen];

#include "util.h"
#include "..\..\inc\gcdump.h"
#pragma warning(disable:4244)   // conversion from 'unsigned int' to 'unsigned short', possible loss of data
#pragma warning(disable:4189)   // local variable is initialized but not referenced
#define assert(a)
#include "..\..\inc\gcdecoder.cpp"
#define _ASSERTE(a) {;}
#include "..\..\gcdump\gcdump.cpp"

#ifdef _X86_
#include "..\..\gcdump\i386\gcdumpx86.cpp"
#endif
#ifdef _IA64_
#include "GCDumpIA64.cpp"
#endif
#undef assert
#pragma warning(default:4244)
#pragma warning(default:4189)

#include <ntpsapi.h>
#include "ntinfo.h"

#ifndef UNDER_CE
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CoInitialize(0);
        CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, IID_IMetaDataDispenserEx, (void**)&pDisp);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpReserved == 0)
        {
            mdImportSet.Destroy();
        }
		if (pDisp)
        	pDisp->Release();
        if (DllPath) {
            delete DllPath;
        }
        CoUninitialize();
    }
    return true;
}
#endif


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the MethodDesc for a given eip     *  
*                                                                      *
\**********************************************************************/
DECLARE_API (IP2MD)
{
    INIT_API ();
    DWORD_PTR IP = GetExpression(args);
    if (IP == 0)
    {
        ExtOut("%s is not IP\n", args);
        return Status;
    }
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        ExtOut("MethodDesc: 0x%p\n", (ULONG64)methodDesc);
        if (jitType == EJIT)
            ExtOut ("Jitted by EJIT\n");
        else if (jitType == JIT)
            ExtOut ("Jitted by normal JIT\n");
        else if (jitType == PJIT)
            ExtOut ("Jitted by PreJIT\n");
        DumpMDInfo (methodDesc);
    }
    else
    {
        ExtOut("%p not in jit code range\n", (ULONG64)IP);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the stack trace.  It looks at each DWORD   *  
*    on stack.  If the DWORD is a return address, the symbol name or
*    managed function name is displayed.                               *
*                                                                      *
\**********************************************************************/
void DumpStackInternal(PCSTR args)
{
    DumpStackFlag DSFlag;
    BOOL bSmart = FALSE;
    DSFlag.fEEonly = FALSE;
    DSFlag.top = 0;
    DSFlag.end = 0;

    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-EE", &DSFlag.fEEonly, COBOOL, FALSE},
        {"-smart", &bSmart, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&DSFlag.top, COHEX},
        {&DSFlag.end, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return;
    }
    
    ReloadSymbolWithLineInfo();
    
    ULONG64 StackOffset;
    g_ExtRegisters->GetStackOffset (&StackOffset);
    if (nArg == 0) {
        DSFlag.top = (DWORD_PTR)StackOffset;
    }
    size_t value;
    while (g_ExtData->ReadVirtual(DSFlag.top,&value,sizeof(size_t),NULL) != S_OK) {
        if (IsInterrupt())
            return;
        DSFlag.top = NextOSPageAddress (DSFlag.top);
    }
    
    if (nArg < 2) {
        // Find the current stack range
        NT_TIB teb;
        ULONG64 dwTebAddr=0;

        g_ExtSystem->GetCurrentThreadTeb (&dwTebAddr);
        if (SafeReadMemory ((ULONG_PTR)dwTebAddr, &teb, sizeof (NT_TIB), NULL))
        {
            if (DSFlag.top > (DWORD_PTR)teb.StackLimit
            && DSFlag.top <= (DWORD_PTR)teb.StackBase)
            {
                if (DSFlag.end == 0 || DSFlag.end > (DWORD_PTR)teb.StackBase)
                    DSFlag.end = (DWORD_PTR)teb.StackBase;
            }
        }
    }

    
    if (DSFlag.end == 0)
        DSFlag.end = DSFlag.top + 0xFFFF;
    
    if (DSFlag.end < DSFlag.top)
    {
        ExtOut ("Wrong optione: stack selection wrong\n");
        return;
    }

    if (!bSmart || DSFlag.top != (DWORD_PTR)StackOffset)
        DumpStackDummy (DSFlag);
    else
        DumpStackSmart (DSFlag);
}


DECLARE_API (DumpStack)
{
    INIT_API();
    DumpStackInternal (args);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the stack trace for threads that EE knows  *  
*    from ThreadStore.                                                 *
*                                                                      *
\**********************************************************************/
DECLARE_API (EEStack)
{
    INIT_API();
    
    CHAR control[80] = "\0";
    BOOL bEEOnly = FALSE;
    BOOL bDumb = TRUE;
    BOOL bAllEEThread = TRUE;

    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-EE", &bEEOnly, COBOOL, FALSE},
        {"-smart", &bDumb, COBOOL, FALSE},
        {"-short", &bAllEEThread, COBOOL, FALSE}
    };

    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),NULL,0,NULL)) {
        return Status;
    }

    if (bEEOnly) {
        strcat (control," -EE");
    }
    if (!bDumb) {
        strcat (control," -smart");
    }
    ULONG Tid;
    g_ExtSystem->GetCurrentThreadId(&Tid);

    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    int i;
    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        ULONG id=0;
        if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) != S_OK)
            continue;
        ExtOut ("---------------------------------------------\n");
        ExtOut ("Thread %3d\n", id);
        BOOL doIt = FALSE;
        if (bAllEEThread) {
            doIt = TRUE;
        }
        else if (vThread.m_dwLockCount > 0 || (int)vThread.m_pFrame != -1 || (vThread.m_State & Thread::TS_Hijacked)) {
            doIt = TRUE;
        }
        else {
            ULONG64 IP;
            g_ExtRegisters->GetInstructionOffset (&IP);
            JitType jitType;
            DWORD_PTR methodDesc;
            DWORD_PTR gcinfoAddr;
            IP2MethodDesc ((DWORD_PTR)IP, methodDesc, jitType, gcinfoAddr);
            if (methodDesc)
            {
                doIt = TRUE;
            }
        }
        if (doIt) {
            g_ExtSystem->SetCurrentThreadId(id);
            DumpStackInternal (control);
        }
    }

    g_ExtSystem->SetCurrentThreadId(Tid);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the address and name of all       *
*    Managed Objects on the stack.                                     *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpStackObjects)
{
    INIT_API();
    
    size_t StackTop = 0;
    size_t StackBottom = 0;

    while (isspace (args[0]))
        args ++;
    PCSTR pch = args;
    char* endptr;
    
    if (pch[0] == '\0')
    {
        ULONG64 StackOffset;
        g_ExtRegisters->GetStackOffset (&StackOffset);

        StackTop = (DWORD_PTR)StackOffset;
    }
    else
    {
        char buffer[80];
        StackTop = strtoul (pch, &endptr, 16);
        if (endptr[0] != '\0' && !isspace (endptr[0]))
        {
            strncpy (buffer,pch,79);
            buffer[79] = '\0';
            char * tmp = buffer;
            while (tmp[0] != '\0' && !isspace (tmp[0]))
                tmp ++;
            tmp[0] = '\0';
            StackTop = GetExpression(buffer);
            if (StackTop == 0)
            {
                ExtOut ("wrong option: %s\n", pch);
                return Status;
            }
            pch += strlen(buffer);
        }
        else
            pch = endptr;
        while (pch[0] != '\0' && isspace (pch[0]))
            pch ++;
        if (pch[0] != '\0')
        {
            StackBottom = strtoul (pch, &endptr, 16);
            if (endptr[0] != '\0' && !isspace (endptr[0]))
            {
                strncpy (buffer,pch,79);
                buffer[79] = '\0';
                char * tmp = buffer;
                while (tmp[0] != '\0' && !isspace (tmp[0]))
                    tmp ++;
                tmp[0] = '\0';
                StackBottom = GetExpression(buffer);
                if (StackBottom == 0)
                {
                    ExtOut ("wrong option: %s\n", pch);
                    return Status;
                }
            }
        }
    }
    
    NT_TIB teb;
    ULONG64 dwTebAddr=0;
    g_ExtSystem->GetCurrentThreadTeb (&dwTebAddr);
    if (SafeReadMemory ((ULONG_PTR)dwTebAddr, &teb, sizeof (NT_TIB), NULL))
    {
        if (StackTop > (DWORD_PTR)teb.StackLimit
        && StackTop <= (DWORD_PTR)teb.StackBase)
        {
            if (StackBottom == 0 || StackBottom > (DWORD_PTR)teb.StackBase)
                StackBottom = (DWORD_PTR)teb.StackBase;
        }
    }
    if (StackBottom == 0)
        StackBottom = StackTop + 0xFFFF;
    
    if (StackBottom < StackTop)
    {
        ExtOut ("Wrong optione: stack selection wrong\n");
        return Status;
    }

    DumpStackObjectsHelper (StackTop, StackBottom);
    return Status;
}




/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodDesc      *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpMD)
{
    DWORD_PTR dwStartAddr;

    INIT_API();
    
    dwStartAddr = GetExpression(args);
    DumpMDInfo (dwStartAddr);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an EEClass from   *  
*    a given address
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpClass)
{
    DWORD_PTR dwStartAddr;
    EEClass EECls;
    EEClass *pEECls = &EECls;
    
    INIT_API();

    BOOL bDumpChain = FALSE;
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-chain", &bDumpChain, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwStartAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (nArg == 0) {
        ExtOut ("Missing EEClass address\n");
        return Status;
    }
    DWORD_PTR dwAddr = dwStartAddr;
    if (!IsEEClass (dwAddr))
    {
        ExtOut ("%p is not an EEClass\n", (ULONG64)dwStartAddr);
        return Status;
    }
    pEECls->Fill (dwStartAddr);
    if (!CallStatus)
    {
	    ExtOut( "DumpClass : ReadProcessMemory failed.\r\n" );
	    return Status;
    }
    
    ExtOut("Class Name : ");
    NameForEEClass (pEECls, g_mdName);
    ExtOut("%S", g_mdName);
    ExtOut ("\n");

    MethodTable vMethTable;
    moveN (vMethTable, pEECls->m_pMethodTable);
    WCHAR fileName[MAX_PATH+1];
    FileNameForMT (&vMethTable, fileName);
    ExtOut("mdToken : %p (%S)\n",(ULONG64)pEECls->m_cl, fileName);

    ExtOut("Parent Class : %p\r\n",(ULONG64)pEECls->m_pParentClass);

    ExtOut("ClassLoader : %p\r\n",(ULONG64)pEECls->m_pLoader);

    ExtOut("Method Table : %p\r\n",(ULONG64)pEECls->m_pMethodTable);

    ExtOut("Vtable Slots : %x\r\n",pEECls->m_wNumVtableSlots);

    ExtOut("Total Method Slots : %x\r\n",pEECls->m_wNumMethodSlots);

    ExtOut("Class Attributes : %x : ",pEECls->m_dwAttrClass);
#if 0
    if (IsTdValueType(pEECls->m_dwAttrClass))
    {
        ExtOut ("Value Class, ");
    }
    if (IsTdEnum(pEECls->m_dwAttrClass))
    {
        ExtOut ("Enum type, ");
    }
    if (IsTdUnmanagedValueType(pEECls->m_dwAttrClass))
    {
        ExtOut ("Unmanaged Value Class, ");
    }
#endif
    if (IsTdInterface(pEECls->m_dwAttrClass))
    {
        ExtOut ("Interface, ");
    }
    if (IsTdAbstract(pEECls->m_dwAttrClass))
    {
        ExtOut ("Abstract, ");
    }
    if (IsTdImport(pEECls->m_dwAttrClass))
    {
        ExtOut ("ComImport, ");
    }
    
    ExtOut ("\n");
    
    
    ExtOut("Flags : %x\r\n",pEECls->m_VMFlags);

    ExtOut("NumInstanceFields: %x\n", pEECls->m_wNumInstanceFields);
    ExtOut("NumStaticFields: %x\n", pEECls->m_wNumStaticFields);
    ExtOut("ThreadStaticOffset: %x\n", pEECls->m_wThreadStaticOffset);
    ExtOut("ThreadStaticsSize: %x\n", pEECls->m_wThreadStaticsSize);
    ExtOut("ContextStaticOffset: %x\n", pEECls->m_wContextStaticOffset);
    ExtOut("ContextStaticsSize: %x\n", pEECls->m_wContextStaticsSize);
    
    if (pEECls->m_wNumInstanceFields + pEECls->m_wNumStaticFields > 0)
    {
        ExtOut ("FieldDesc*: %p\n", (ULONG64)pEECls->m_pFieldDescList);
        DisplayFields(pEECls);
    }

    if (bDumpChain) {
    }
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodTable     *  
*    from a given address                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpEEHash)
{
    INIT_API();
    
    DWORD_PTR dwTableAddr;
    size_t nitem = 1;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-length", &nitem, COSIZE_T, TRUE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwTableAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (dwTableAddr == 0) {
        goto Exit;
    }
    EEHashTable vTable;
    vTable.Fill(dwTableAddr);
    ExtOut ("NumBuckets: %d\n", vTable.m_dwNumBuckets);
    ExtOut ("NumEntries: %d\n", vTable.m_dwNumEntries);
    DWORD n;
    size_t dwBucketAddr;
    EEHashEntry vEntry;
    ULONG offsetKey = EEHashEntry::GetFieldOffset("Key");
    ExtOut ("Bucket   Data     Key\n");
    for (n = 0; n < vTable.m_dwNumBuckets; n ++) {
        if (IsInterrupt())
            break;
        dwBucketAddr = (size_t)vTable.m_pBuckets + n * sizeof(PVOID);
        moveN (dwBucketAddr, dwBucketAddr);
        while (dwBucketAddr) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwAddr = dwBucketAddr;
            vEntry.Fill(dwAddr);
            size_t Key;
            ExtOut ("%p %p ", (ULONG64)dwBucketAddr, (ULONG64)vEntry.Data);
            dwAddr = dwBucketAddr + offsetKey;
            for (size_t i = 0; i < nitem; i ++) {
                moveN (Key, dwAddr+i*sizeof(size_t));
                ExtOut ("%p ", (ULONG64)Key);
            }
            ExtOut ("\n");
            dwBucketAddr = (size_t)vEntry.pNext;
        }
    }

Exit:
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodTable     *  
*    from a given address                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpMT)
{
    DWORD_PTR dwStartAddr;
    MethodTable vMethTable;
    
    INIT_API();
    
    BOOL bDumpMDTable = FALSE;
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-MD", &bDumpMDTable, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwStartAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (nArg == 0) {
        ExtOut ("Missing MethodTable address\n");
        return Status;
    }

    dwStartAddr = dwStartAddr&~3;
    
    if (!IsMethodTable (dwStartAddr))
    {
        ExtOut ("%p is not a MethodTable\n", (ULONG64)dwStartAddr);
        return Status;
    }
    if (dwStartAddr == MTForFreeObject()) {
        ExtOut ("Free MethodTable\n");
        return Status;
    }
    
    vMethTable.Fill (dwStartAddr);
    if (!CallStatus)
        return Status;
    
    ExtOut("EEClass : %p\r\n",(ULONG64)vMethTable.m_pEEClass);

    ExtOut("Module : %p\r\n",(ULONG64)vMethTable.m_pModule);

    EEClass eeclass;
    DWORD_PTR dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    eeclass.Fill (dwAddr);
    if (!CallStatus)
        return Status;
    WCHAR fileName[MAX_PATH+1];
    if (eeclass.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        ExtOut("Array: Rank %d, Type %s\n", vArray.m_dwRank,
                ElementTypeName(vArray.m_ElementType));
        //ExtOut ("Name: ");
        //ExtOut ("\n");
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        while (dwAddr&2) {
            if (IsInterrupt())
                return Status;
            ParamTypeDesc param;
            DWORD_PTR dwTDAddr = dwAddr&~2;
            param.Fill(dwTDAddr);
            dwAddr = (DWORD_PTR)param.m_Arg.m_asMT;
        }
        NameForMT (dwAddr, g_mdName);
        ExtOut ("Element Type: %S\n", g_mdName);
    }
    else
    {
        DWORD_PTR dwTmp = (DWORD_PTR)vMethTable.m_pModule;
        Module module;
        module.Fill (dwTmp);
        NameForToken(&module, eeclass.m_cl, g_mdName);
        ExtOut ("Name: %S\n", g_mdName);
        FileNameForMT (&vMethTable, fileName);
        ExtOut("mdToken: %08x ", eeclass.m_cl);
        ExtOut( " (%ws)\n",
                 fileName[0] ? fileName : L"Unknown Module" );
        ExtOut("MethodTable Flags : %x\r\n",vMethTable.m_wFlags & 0xFFFF0000); // low WORD is m_ComponentSize
        if (vMethTable.m_ComponentSize)
            ExtOut ("Number of elements in array: %x\n",
                     vMethTable.m_ComponentSize);
        ExtOut("Number of IFaces in IFaceMap : %x\r\n",
                vMethTable.m_wNumInterface);
        
        ExtOut("Interface Map : %p\r\n",(ULONG64)vMethTable.m_pIMap);
        
        ExtOut("Slots in VTable : %d\r\n",vMethTable.m_cbSlots);
    }

    if (bDumpMDTable)
    {
        ExtOut ("--------------------------------------\n");
        ExtOut ("MethodDesc Table\n");
#ifdef _IA64_
        ExtOut ("     Entry          MethodDesc     JIT   Name\n");
//                123456789abcdef0 123456789abcdef0 PreJIT xxxxxxxx
#else
        ExtOut ("  Entry  MethodDesc   JIT   Name\n");
//                12345678 12345678    PreJIT xxxxxxxx
#endif
        DWORD_PTR dwAddr = vMethTable.m_Vtable[0];
        for (DWORD n = 0; n < vMethTable.m_cbSlots; n ++)
        {
            DWORD_PTR entry;
            moveN (entry, dwAddr);
            JitType jitType;
            DWORD_PTR methodDesc=0;
            DWORD_PTR gcinfoAddr;
            IP2MethodDesc (entry, methodDesc, jitType, gcinfoAddr);
            if (!methodDesc)
            {
                methodDesc = entry + 5;
            }
#ifdef _IA64_
            ExtOut ("%p %p ", (ULONG64)entry, (ULONG64)methodDesc);
#else
            ExtOut ("%p %p    ", (ULONG64)entry, (ULONG64)methodDesc);
#endif
            if (jitType == EJIT)
                ExtOut ("EJIT  ");
            else if (jitType == JIT)
                ExtOut ("JIT   ");
            else if (jitType == PJIT)
                ExtOut ("PreJIT");
            else
                ExtOut ("None  ");
            
            MethodDesc vMD;
            DWORD_PTR dwMDAddr = methodDesc;
            vMD.Fill (dwMDAddr);
            
            CQuickBytes fullname;
            FullNameForMD (&vMD, &fullname);
            ExtOut (" %S\n", (WCHAR*)fullname.Ptr());
            dwAddr += sizeof(PVOID);
        }
    }
    return Status;
}

extern size_t Align (size_t nbytes);

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an object from a  *  
*    given address
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpObj)    
{
    INIT_API();
    DWORD_PTR p_Object = GetExpression (args);
    if (p_Object == 0)
        return Status;
    DWORD_PTR p_MT;
    moveN (p_MT, p_Object);
    p_MT = p_MT&~3;

    if (!IsMethodTable (p_MT))
    {
        ExtOut ("%s is not a managed object\n", args);
        return Status;
    }

    if (p_MT == MTForFreeObject()) {
        ExtOut ("Free Object\n");
        DWORD size = ObjectSize (p_Object);
        ExtOut ("Size %d(0x%x) bytes\n", size, size);
        return Status;
    }

    DWORD_PTR size = 0;
    MethodTable vMethTable;
    DWORD_PTR dwAddr = p_MT;
    vMethTable.Fill (dwAddr);
    NameForMT (vMethTable, g_mdName);
    ExtOut ("Name: %S\n", g_mdName);
    ExtOut ("MethodTable 0x%p\n", (ULONG64)p_MT);
    ExtOut ("EEClass 0x%p\n", (ULONG64)vMethTable.m_pEEClass);
    size = ObjectSize (p_Object);
    ExtOut ("Size  %d(0x%x) bytes\n", size,size);
    EEClass vEECls;
    dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    vEECls.Fill (dwAddr);
    if (!CallStatus)
        return Status;
    if (vEECls.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        ExtOut("Array: Rank %d, Type %s\n", vArray.m_dwRank,
                ElementTypeName(vArray.m_ElementType));
        //ExtOut ("Name: ");
        //ExtOut ("\n");
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        NameForMT (dwAddr, g_mdName);
        ExtOut ("Element Type: %S\n", g_mdName);
        if (vArray.m_ElementType == 3)
        {
            ExtOut ("Content:\n");
            dwAddr = p_Object + 4;
            DWORD_PTR num;
            moveN (num, dwAddr);
            PrintString (dwAddr+4, TRUE, num);
            ExtOut ("\n");
        }
    }
    else
    {
        FileNameForMT (&vMethTable, g_mdName);
        ExtOut("mdToken: %08x ", vEECls.m_cl);
        ExtOut( " (%ws)\n",
                 g_mdName[0] ? g_mdName : L"Unknown Module" );
    }
    
    if (p_MT == MTForString())
    {
        ExtOut ("String: ");
        StringObjectContent (p_Object);
        ExtOut ("\n");
    }
    else if (p_MT == MTForObject())
    {
        ExtOut ("Object\n");
    }

    if (vEECls.m_wNumInstanceFields + vEECls.m_wNumStaticFields > 0)
    {
        ExtOut ("FieldDesc*: %p\n", (ULONG64)vEECls.m_pFieldDescList);
        DisplayFields(&vEECls, p_Object, TRUE);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps GC heap size.                                 *  
*                                                                      *
\**********************************************************************/
DECLARE_API(EEHeap)
{
#ifdef UNDER_CE
    ExtOut ("Not yet implemented\n");
    return Status;
#else
    INIT_API();

#define GC_HEAP_ONLY          0x00000001
#define LOADER_HEAP_ONLY      0x00000002
#define WIN32_HEAP_ONLY       0x00000004
#define EE_HEAP_MASK          0x00000007

    BOOL bEEHeapFlags = EE_HEAP_MASK;

    if (_stricmp (args, "-gc") == 0)
        bEEHeapFlags = GC_HEAP_ONLY;

    if (_stricmp (args, "-win32") == 0)
        bEEHeapFlags = WIN32_HEAP_ONLY;

    if (_stricmp (args, "-loader") == 0)
        bEEHeapFlags = LOADER_HEAP_ONLY;

    if (bEEHeapFlags & LOADER_HEAP_ONLY)
    {
        // Loader heap.
        LoaderHeap v_LoaderHeap;
        DWORD_PTR p_DomainAddr;
        AppDomain v_AppDomain;

        DWORD_PTR allHeapSize = 0;
        DWORD_PTR domainHeapSize;
    
        int numDomain;
        DWORD_PTR *domainList = NULL;
        GetDomainList (domainList, numDomain);
        ToDestroy des0 ((void**) &domainList);
        
        // The first one is the system domain.
        p_DomainAddr = domainList[0];
        ExtOut ("Loader Heap:\n");
        ExtOut ("--------------------------------------\n");
        ExtOut ("System Domain: %p\n", (ULONG64)p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        domainHeapSize = 0;
        ExtOut ("LowFrequencyHeap:");
        DWORD_PTR dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("HighFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("StubHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
        allHeapSize += domainHeapSize;

        ExtOut ("--------------------------------------\n");
        p_DomainAddr = domainList[1];
        ExtOut ("Shared Domain: %x\n", p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        domainHeapSize = 0;
        ExtOut ("LowFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("HighFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("StubHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
        allHeapSize += domainHeapSize;

        int n;
        int n0 = 2;
        for (n = n0; n < numDomain; n++)
        {
            if (IsInterrupt())
                break;

            p_DomainAddr = domainList[n];
            // Check if this domain already appears.
            int i;
            for (i = 0; i < n; i ++)
            {
                if (domainList[i] == p_DomainAddr)
                    break;
            }
            if (i == n)
            {
                ExtOut ("--------------------------------------\n");
                ExtOut ("Domain %d: %x\n", n-n0, p_DomainAddr);
                v_AppDomain.Fill (p_DomainAddr);
                domainHeapSize = 0;
                ExtOut ("LowFrequencyHeap:");
                DWORD_PTR dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("HighFrequencyHeap:");
                dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("StubHeap:");
                dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
                allHeapSize += domainHeapSize;
            }
        }
    
        // Jit code heap
        ExtOut ("--------------------------------------\n");
        ExtOut ("Jit code heap:\n");
        allHeapSize += JitHeapInfo();
    
        ExtOut ("--------------------------------------\n");
        ExtOut ("Total LoaderHeap size: 0x%x(%d)bytes\n", allHeapSize, allHeapSize);
        ExtOut ("=======================================\n");
    }

    if (bEEHeapFlags & WIN32_HEAP_ONLY)
    {
        DWORD bIsInit = GetValueFromExpression("MSCOREE!PerfUtil__g_PerfAllocHeapInitialized");
        if (bIsInit)
        {
            PerfAllocVars v_perfVars;
            DWORD dwStartAddr = GetValueFromExpression("MSCOREE!PerfUtil__g_PerfAllocVariables");
            v_perfVars.Fill (dwStartAddr);
            if (!v_perfVars.g_PerfEnabled)
                ExtOut ("Win32 heap allocation stats not collected, enable by setting reg key Complus\\EnablePerfAllocStats to 1\n");
            else
            {
                ExtOut ("--------------------------------------\n");
                ExtOut ("Win32 Process Heap (Verbose)\n");
                ExtOut ("--------------------------------------\n");
        
                PerfAllocHeader h;
                DWORD dwNextNodeAddr = (DWORD)v_perfVars.g_AllocListFirst;
                
                ExtOut ("Alloc Addr\tSize\tSymbol\n");
                while(1)
                {
                    h.Fill (dwNextNodeAddr);
                    ExtOut ("%x\t%u\t%x\n", dwNextNodeAddr, h.m_Length, h.m_AllocEIP);   
                    if (h.m_Next == NULL)
                        break;
                    dwNextNodeAddr = (DWORD)h.m_Next;
                }
            }
        }
    }
    
    if (bEEHeapFlags & GC_HEAP_ONLY)
    {   
        // GC Heap
        DWORD_PTR dwNHeaps = 1;
        if (IsServerBuild())
        {
            static DWORD_PTR dwAddrNHeaps = 0;
            if (dwAddrNHeaps == 0)
                dwAddrNHeaps = GetValueFromExpression("MSCOREE!gc_heap__n_heaps");
            moveN (dwNHeaps, dwAddrNHeaps);
        }

        ExtOut ("Number of GC Heaps: %d\n", dwNHeaps);
    
        gc_heap heap = {0};
        DWORD_PTR totalSize = 0;
        if (!IsServerBuild())
        {
            DWORD_PTR dwAddr = 0;
            heap.Fill (dwAddr);
            if (!CallStatus)
                return Status;
            GCHeapInfo (heap, totalSize);
        }
        else
        {
            DWORD_PTR dwAddrGHeaps =
                GetValueFromExpression("MSCOREE!gc_heap__g_heaps");
            moveN (dwAddrGHeaps, dwAddrGHeaps);
            DWORD n;
            for (n = 0; n < dwNHeaps; n ++)
            {
                DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
                moveN (dwAddrGCHeap, dwAddrGCHeap);

                ExtOut ("------------------------------\n");
                ExtOut ("Heap %d (%p)\n", n, (ULONG64)dwAddrGCHeap);
                heap.Fill (dwAddrGCHeap);
                DWORD_PTR heapSize = 0;
                GCHeapInfo (heap, heapSize);
                totalSize += heapSize;
            }
        }
        ExtOut ("------------------------------\n");
        ExtOut ("large block  %#8x(%d)\n", heap.large_blocks_size,
                 heap.large_blocks_size);
        static DWORD_PTR dwLargeNPAddr = 0;
        if (dwLargeNPAddr == 0)
            dwLargeNPAddr =
                GetValueFromExpression("mscoree!gc_heap__large_np_objects");
        DWORD_PTR dwLargeAddr;
        moveN (dwLargeAddr, dwLargeNPAddr);
        ExtOut ("large_np_objects start at %p\n", (ULONG64)dwLargeAddr);
        static DWORD_PTR dwLargePAddr = 0;
        if (dwLargePAddr == 0)
            dwLargePAddr =
                GetValueFromExpression("mscoree!gc_heap__large_p_objects");
        moveN (dwLargeAddr, dwLargePAddr);
        ExtOut ("large_p_objects start  at %p\n", (ULONG64)dwLargeAddr);
        ExtOut ("------------------------------\n");
        totalSize += heap.large_blocks_size;
        ExtOut ("GC Heap Size  %#8x(%d)\n", totalSize, totalSize);
    }
#endif
    return Status;
}

HeapStat *stat = NULL;

void PrintGCStat ()
{
    if (stat)
    {
        ExtOut ("Statistics:\n");
        ExtOut ("%8s %8s %9s %s\n",
                 "MT", "Count", "TotalSize", "Class Name");
        __try 
        {
            stat->Sort();
        } __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ExtOut ("exception during sorting\n");
            stat->Delete();
            return;
        }        
        __try 
        {
            stat->Print();
        } __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ExtOut ("exception during printing\n");
            stat->Delete();
            return;
        }        
        stat->Delete();
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps all objects on GC heap. It also displays      *  
*    statistics of objects.  If GC heap is corrupted, it will stop at 
*    the bad place.  (May not work if GC is in progress.)              *
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpHeap)
{
    INIT_API();

    DumpHeapFlags flags;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-min", &flags.min_size, COSIZE_T, TRUE},
        {"-max", &flags.max_size, COSIZE_T, TRUE},
        {"-mt", &flags.MT, COHEX, TRUE},
        {"-stat", &flags.bStatOnly, COBOOL, FALSE},
        {"-fix", &flags.bFixRange, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&flags.startObject, COHEX},
        {&flags.endObject, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (flags.min_size > flags.max_size)
    {
        ExtOut ("wrong argument\n");
        return Status;
    }
    
    if (flags.endObject == 0)
        flags.endObject = -1;

    if (stat == NULL)
    {
        stat = (HeapStat *)malloc(sizeof (HeapStat));
        stat = new(stat) HeapStat;
    }

    ToDestroy des2 ((void**) &stat);
    
    // Obtain allocation context for each managed thread.
    DWORD_PTR *threadList = NULL;
    ToDestroy des0 ((void**)&threadList);
    int numThread = 0;
    GetThreadList (threadList, numThread);
    
    AllocInfo allocInfo;
    allocInfo.num = 0;
    allocInfo.array = NULL;

    
    if (numThread)
    {
        allocInfo.array =
            (alloc_context*)malloc(numThread * sizeof(alloc_context));
    }
    ToDestroy des1 ((void**)&allocInfo.array);
    
    Thread vThread;
    int i;

    for (i = 0; i < numThread; i ++)
    {
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_alloc_context.alloc_ptr == 0)
            continue;
        
        int j;
        for (j = 0; j < allocInfo.num; j ++)
        {
            if (allocInfo.array[j].alloc_ptr ==
                vThread.m_alloc_context.alloc_ptr)
                break;
        }
        if (j == allocInfo.num)
        {
            allocInfo.num ++;
            allocInfo.array[j].alloc_ptr =
                vThread.m_alloc_context.alloc_ptr;
            allocInfo.array[j].alloc_limit =
                vThread.m_alloc_context.alloc_limit;
        }
    }
    
    gc_heap heap;
    DWORD_PTR nObj = 0;
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return Status;
        if (!flags.bStatOnly)
            ExtOut ("%8s %8s %8s\n", "Address", "MT", "Size");
        GCHeapDump (heap, nObj, flags,
                    &allocInfo);
    }
    else
    {
        DWORD_PTR dwNHeaps = 1;
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetValueFromExpression("MSCOREE!gc_heap__n_heaps");
        safemove_ret (dwNHeaps, dwAddrNHeaps);
        
        static DWORD_PTR dwAddrGHeaps0 = 0;
        if (dwAddrGHeaps0 == 0)
            dwAddrGHeaps0 = GetValueFromExpression("MSCOREE!gc_heap__g_heaps");
        DWORD_PTR dwAddrGHeaps;
        safemove_ret (dwAddrGHeaps, dwAddrGHeaps0);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            safemove_ret (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            DWORD_PTR cObj = 0;
            ExtOut ("------------------------------\n");
            ExtOut ("Heap %d\n", n);
            if (!flags.bStatOnly)
                ExtOut ("%8s %8s %8s\n", "Address", "MT", "Size");
            GCHeapDump (heap, cObj, flags,
                        &allocInfo);
            ExtOut ("total %d objects\n", cObj);
            nObj += cObj;
        }
        ExtOut ("------------------------------\n");
    }
    
    ExtOut ("total %d objects\n", nObj);

    PrintGCStat();

    ExtOut ("large objects\n");
    ExtOut ("%8s %8s %8s\n", "Address", "MT", "Size");
    static DWORD_PTR dwLargeNPAddr = 0;
    if (dwLargeNPAddr == 0)
        dwLargeNPAddr =
            GetValueFromExpression("mscoree!gc_heap__large_np_objects");
    DWORD_PTR dwLargeAddr;
    safemove_ret (dwLargeAddr, dwLargeNPAddr);
    large_object_block large_object;
    nObj = 0;
    DWORD_PTR dwAddrCurrObj;
    DWORD_PTR dwAddrMethTable;
    MethodTable vMethTable;
    while (dwLargeAddr)
    {
        if (IsInterrupt())
            break;
        dwAddrCurrObj = dwLargeAddr;
        large_object.Fill(dwAddrCurrObj);

        safemove_ret (dwAddrMethTable, dwAddrCurrObj);
        dwAddrMethTable = dwAddrMethTable & ~3;
        if (flags.MT == 0 || dwAddrMethTable == flags.MT)
        {
            DWORD_PTR dwAddrTmp = dwAddrMethTable;
            vMethTable.Fill (dwAddrTmp);
            if (!CallStatus)
            {
                ExtOut ("Fail to read MethodTable\n");
                break;
            }
            
            size_t s = ObjectSize (dwAddrCurrObj);
            if (s == 0)
            {
                ExtOut ("curr_object : %x size=0\n", dwAddrCurrObj);
                break;
            }
            {
                nObj ++;
                ExtOut ("%8x %8x %8d ", dwAddrCurrObj, dwAddrMethTable, s);
                if (dwAddrMethTable == MTForFreeObj())
                {
                    ExtOut ("%9s\n","Free");
                }
                else
                {
                    NameForMT (dwAddrMethTable, g_mdName);
                    ExtOut ("%S\n", g_mdName);
                }
            }
        }

        dwLargeAddr = (DWORD_PTR)large_object.next;
    }
    
    static DWORD_PTR dwLargePAddr = 0;
    if (dwLargePAddr == 0)
        dwLargePAddr =
            GetValueFromExpression("mscoree!gc_heap__large_p_objects");
    safemove_ret (dwLargeAddr, dwLargePAddr);
    while (dwLargeAddr)
    {
        if (IsInterrupt())
            break;

        dwAddrCurrObj = dwLargeAddr;
        large_object.Fill(dwAddrCurrObj);

        safemove_ret (dwAddrMethTable, dwAddrCurrObj);
        dwAddrMethTable = dwAddrMethTable & ~3;
        if (flags.MT == 0 || dwAddrMethTable == flags.MT)
        {
            DWORD_PTR dwAddrTmp = dwAddrMethTable;
            vMethTable.Fill (dwAddrTmp);
            if (!CallStatus)
            {
                ExtOut ("Fail to read MethodTable\n");
                break;
            }
            
            size_t s = ObjectSize (dwAddrCurrObj);
            if (s == 0)
            {
                ExtOut ("curr_object : %x size=0\n", dwAddrCurrObj);
                break;
            }
            else
            {
                nObj ++;
                
                ExtOut ("%8x %8x %8d ", dwAddrCurrObj, dwAddrMethTable, s);
                
                if (dwAddrMethTable == MTForFreeObj())
                {
                    ExtOut ("%9s\n","Free");
                }
                else
                {
                    NameForMT (dwAddrMethTable, g_mdName);
                    ExtOut ("%S\n", g_mdName);
                }
            }
        }
        
        dwLargeAddr = (DWORD_PTR)large_object.next;
    }
    ExtOut ("total %d large objects\n", nObj);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps what is in the syncblock cache.  By default   *  
*    it dumps all active syncblocks.  Using -all to dump all syncblocks
*                                                                      *
\**********************************************************************/
DECLARE_API(SyncBlk)
{
    INIT_API();

    BOOL bDumpAll = FALSE;
    size_t nbAsked = 0;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-all", &bDumpAll, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&nbAsked, COSIZE_T}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    DWORD_PTR p_s_pSyncBlockCache = GetValueFromExpression ("mscoree!g_SyncBlockCacheInstance");
    SyncBlockCache s_pSyncBlockCache;
    s_pSyncBlockCache.Fill (p_s_pSyncBlockCache);
    if (!CallStatus)
    {
        ExtOut ("Can not get mscoree!g_SyncBlockCacheInstance\n");
        return Status;
    }
    
    DWORD_PTR p_g_pSyncTable = GetValueFromExpression ("mscoree!g_pSyncTable");
    DWORD_PTR pSyncTable;
    moveN (pSyncTable, p_g_pSyncTable);
    pSyncTable += SyncTableEntry::size();
    SyncTableEntry v_SyncTableEntry;
    if (s_pSyncBlockCache.m_FreeSyncTableIndex < 2)
        return Status;
    DWORD_PTR dwAddr;
    SyncBlock vSyncBlock;
    ULONG offsetHolding = AwareLock::GetFieldOffset("m_HoldingThread");
    ULONG offsetLinkSB = WaitEventLink::GetFieldOffset("m_LinkSB");
    ExtOut ("Index SyncBlock MonitorHeld Recursion   Thread  ThreadID     Object Waiting\n");
    ULONG freeCount = 0;
    ULONG CCWCount = 0;
    ULONG RCWCount = 0;
    ULONG CFCount = 0;
    for (DWORD nb = 1; nb < s_pSyncBlockCache.m_FreeSyncTableIndex; nb++)
    {
        if (IsInterrupt())
            return Status;
        if (nbAsked && nb != nbAsked) {
            pSyncTable += SyncTableEntry::size();
            continue;
        }
        dwAddr = (DWORD_PTR)pSyncTable;
        v_SyncTableEntry.Fill(dwAddr);
        if (v_SyncTableEntry.m_SyncBlock == 0) {
            if (bDumpAll || nbAsked == nb) {
                ExtOut ("%5d ", nb);
                ExtOut ("%08x  ", 0);
                ExtOut ("%11s ", " ");
                ExtOut ("%9s ", " ");
                ExtOut ("%8s ", " ");
                ExtOut ("%10s" , " ");
                ExtOut ("  %08x", (v_SyncTableEntry.m_Object));
                ExtOut ("\n");
            }
            pSyncTable += SyncTableEntry::size();
            continue;
        }
        dwAddr = v_SyncTableEntry.m_SyncBlock;
        vSyncBlock.Fill (dwAddr);
        BOOL bPrint = (bDumpAll || nb == nbAsked);
        if (!bPrint && v_SyncTableEntry.m_SyncBlock != 0
            && vSyncBlock.m_Monitor.m_MonitorHeld > 0
            && (v_SyncTableEntry.m_Object & 0x1) == 0)
            bPrint = TRUE;
        if (bPrint)
        {
            ExtOut ("%5d ", nb);
            ExtOut ("%08x  ", v_SyncTableEntry.m_SyncBlock);
            ExtOut ("%11d ", vSyncBlock.m_Monitor.m_MonitorHeld);
            ExtOut ("%9d ", vSyncBlock.m_Monitor.m_Recursion);
        }
        DWORD_PTR p_thread;
        p_thread = v_SyncTableEntry.m_SyncBlock + offsetHolding;
        DWORD_PTR thread = vSyncBlock.m_Monitor.m_HoldingThread;
        if (bPrint)
            ExtOut ("%8x ", thread);
        DWORD_PTR threadID = 0;
        if (thread != 0)
        {
            Thread vThread;
            threadID = thread;
            vThread.Fill (threadID);
            if (bPrint)
            {
                ExtOut ("%5x", vThread.m_ThreadId);
                ULONG id;
                if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
                {
                    ExtOut ("%4d ", id);
                }
                else
                {
                    ExtOut (" XXX ");
                }
            }
        }
        else
        {
            if (bPrint)
                ExtOut ("    none  ");
        }
        if (bPrint) {
            if (v_SyncTableEntry.m_Object & 0x1) {
                ExtOut ("  %8d", (v_SyncTableEntry.m_Object & ~0x1)>>1);
            }
            else {
                ExtOut ("  %p", (ULONG64)v_SyncTableEntry.m_Object);
                NameForObject((DWORD_PTR)v_SyncTableEntry.m_Object, g_mdName);
                ExtOut (" %S", g_mdName);
            }
        }
        if (v_SyncTableEntry.m_Object & 0x1) {
            freeCount ++;
            if (bPrint) {
                ExtOut (" Free");
            }
        }
        else {
            if (vSyncBlock.m_pComData) {
                switch (vSyncBlock.m_pComData & 3) {
                case 0:
                    CCWCount ++;
                    break;
                case 1:
                    RCWCount ++;
                    break;
                case 3:
                    CFCount ++;
                    break;
                }
            }
        }

        if (v_SyncTableEntry.m_SyncBlock != 0
            && vSyncBlock.m_Monitor.m_MonitorHeld > 1
            && vSyncBlock.m_Link.m_pNext > 0)
        {
            ExtOut (" ");
            DWORD_PTR pHead = (DWORD_PTR)vSyncBlock.m_Link.m_pNext;
            DWORD_PTR pNext = pHead;
            Thread vThread;
    
            while (1)
            {
                if (IsInterrupt())
                    return Status;
                DWORD_PTR pWaitEventLink = pNext - offsetLinkSB;
                WaitEventLink vWaitEventLink;
                vWaitEventLink.Fill(pWaitEventLink);
                if (!CallStatus) {
                    break;
                }
                DWORD_PTR dwAddr = (DWORD_PTR)vWaitEventLink.m_Thread;
                ExtOut ("%x ", dwAddr);
                vThread.Fill (dwAddr);
                if (!CallStatus) {
                    break;
                }
                if (bPrint)
                    ExtOut ("%x,", vThread.m_ThreadId);
                pNext = (DWORD_PTR)vWaitEventLink.m_LinkSB.m_pNext;
                if (pNext == 0)
                    break;
            }            
        }
        if (bPrint)
            ExtOut ("\n");
        pSyncTable += SyncTableEntry::size();
    }
    
    ExtOut ("-----------------------------\n");
    ExtOut ("Total           %d\n", s_pSyncBlockCache.m_FreeSyncTableIndex);
    ExtOut ("ComCallWrapper  %d\n", CCWCount);
    ExtOut ("ComPlusWrapper  %d\n", RCWCount);
    ExtOut ("ComClassFactory %d\n", CFCount);
    ExtOut ("Free            %d\n", freeCount);

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Module          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(FinalizeQueue)
{
    INIT_API();
    BOOL bDetail = FALSE;

    if (_stricmp (args,"-detail") == 0) {
        bDetail = TRUE;
    }
    
    DWORD_PTR p_s_pSyncBlockCache = GetValueFromExpression ("mscoree!g_SyncBlockCacheInstance");
    SyncBlockCache s_pSyncBlockCache;
    s_pSyncBlockCache.Fill (p_s_pSyncBlockCache);
    if (!CallStatus)
    {
        ExtOut ("Can not get mscoree!g_SyncBlockCacheInstance\n");
        return Status;
    }
    
    // Get cleanup list
    ULONG cleanCount = 0;
    DWORD_PTR cleanAddr = s_pSyncBlockCache.m_pCleanupBlockList;
    SyncBlock vSyncBlock;
    ULONG offsetLink = SyncBlock::GetFieldOffset("m_Link");
    DWORD_PTR dwAddr;
    if (bDetail) {
        ExtOut ("To be cleaned Com Data\n");
    }
    while (cleanAddr) {
        dwAddr = cleanAddr - offsetLink;
        vSyncBlock.Fill (dwAddr);
        if (bDetail) {
            ExtOut ("%p  ", (ULONG64)(vSyncBlock.m_pComData&~3));
            switch (vSyncBlock.m_pComData & 3) {
            case 0:
                ExtOut ("ComCallWrapper\n");
                break;
            case 1:
                ExtOut ("ComPlusWrapper\n");
                break;
            case 3:
                ExtOut ("ComClassFactory\n");
                break;
            }
        }
        cleanCount ++;
        cleanAddr = (DWORD_PTR)vSyncBlock.m_Link.m_pNext;
    }
    ExtOut ("SyncBlock to be cleaned up: %d\n", cleanCount);

    static DWORD_PTR addrRCWCleanup = 0;
    if (addrRCWCleanup == 0) {
        addrRCWCleanup = GetValueFromExpression("MSCOREE!g_pRCWCleanupList");
    }
    if (addrRCWCleanup == 0) {
        goto noRCW;
    }
    moveN (dwAddr, addrRCWCleanup);
    if (dwAddr == 0) {
        goto noRCW;
    }
    ExtOut ("----------------------------------\n");
    ComPlusWrapperCleanupList wrapperList;
    wrapperList.Fill (dwAddr);
    ComPlusApartmentCleanupGroup group;
    // Com Interfaces already in queue
    if (wrapperList.m_pMTACleanupGroup) {
        dwAddr = (DWORD_PTR)wrapperList.m_pMTACleanupGroup;
        group.Fill (dwAddr);
        DWORD count = ComPlusAptCleanupGroupInfo(&group, bDetail);
        ExtOut ("MTA interfaces to be released: %d\n", count);
    }

    // STA interfaces
    EEHashTable *pTable = &wrapperList.m_STAThreadToApartmentCleanupGroupMap;

    DWORD n;
    DWORD STACount = 0;
    if (pTable->m_dwNumEntries > 0) {
        for (n = 0; n < pTable->m_dwNumBuckets; n ++) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwBucketAddr = (size_t)pTable->m_pBuckets + n * sizeof(PVOID);
            moveN (dwBucketAddr, dwBucketAddr);
            while (dwBucketAddr) {
                if (IsInterrupt())
                    break;
                DWORD_PTR dwAddr = dwBucketAddr;
                EEHashEntry vEntry;
                vEntry.Fill(dwAddr);
                dwBucketAddr = (DWORD_PTR)vEntry.pNext;
                dwAddr = (DWORD_PTR)vEntry.Data;
                group.Fill (dwAddr);
                dwAddr = (DWORD_PTR)group.m_pSTAThread;
                Thread vThread;
                vThread.Fill (dwAddr);
                ULONG id=0;
                ExtOut ("Thread ");
                if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
                {
                    ExtOut ("%3d", id);
                }
                else
                {
                    ExtOut ("XXX");
                }
                ExtOut ("(%#3x) ", vThread.m_ThreadId);
                DWORD count = ComPlusAptCleanupGroupInfo(&group, bDetail);
                ExtOut ("STA interfaces to be released: %d\n", count);
                STACount += count;
            }
        }
    }
    ExtOut ("Total STA interfaces to be released: %d\n", STACount);

noRCW:
    ExtOut ("----------------------------------\n");
    // GC Heap
    DWORD_PTR dwNHeaps = 1;
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetValueFromExpression("MSCOREE!gc_heap__n_heaps");
        moveN (dwNHeaps, dwAddrNHeaps);
    }


    if (stat == NULL)
    {
        stat = (HeapStat *)malloc(sizeof (HeapStat));
        stat = new(stat) HeapStat;
    }

    ToDestroy des1 ((void**) &stat);
    
	CFinalize finalize;
    gc_heap heap = {0};
    int m;
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return Status;
        dwAddr = (DWORD_PTR)heap.finalize_queue;
        finalize.Fill(dwAddr);
        for (m = 0; m <= heap.g_max_generation; m ++)
        {
            if (IsInterrupt())
                return Status;
             
            ExtOut ("generation %d has %d finalizable objects (%p->%p)\n",
                    m, finalize.m_FillPointers[NUMBERGENERATIONS-m-1] 
                    - finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
					(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
					(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-1]
					);
        }
        ExtOut ("Ready for finalization %d objects (%p->%p)\n",
                finalize.m_FillPointers[NUMBERGENERATIONS]
                - finalize.m_FillPointers[NUMBERGENERATIONS-1],
                (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-1],
                (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS]
                );
        for (dwAddr = (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS - heap.g_max_generation - 2];
             dwAddr <= (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS];
             dwAddr += sizeof (dwAddr)) {
            if (IsInterrupt())
                return Status;
            DWORD_PTR objAddr;
            if (g_ExtData->ReadVirtual(dwAddr, &objAddr, sizeof(objAddr), NULL) != S_OK) {
                continue;
            }
            DWORD_PTR MTAddr;
            if (g_ExtData->ReadVirtual(objAddr, &MTAddr, sizeof(MTAddr), NULL) != S_OK) {
                continue;
            }
            if (MTAddr) {
                size_t s = ObjectSize (objAddr);
                stat->Add (MTAddr, (DWORD)s);
            }
        }
    }
    else
    {
        DWORD_PTR dwAddrGHeaps =
            GetValueFromExpression("MSCOREE!gc_heap__g_heaps");
        moveN (dwAddrGHeaps, dwAddrGHeaps);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            moveN (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            ExtOut ("------------------------------\n");
            ExtOut ("Heap %d\n", n);
            DWORD_PTR dwAddr = (DWORD_PTR)heap.finalize_queue;
            finalize.Fill(dwAddr);
            for (m = 0; m <= heap.g_max_generation; m ++)
            {
                if (IsInterrupt())
                    return Status;
                ExtOut ("generation %d has %d finalizable objects (%p->%p)\n",
                         m, finalize.m_FillPointers[NUMBERGENERATIONS-m-1] 
                         - finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
						(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
						(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-1]
						);
            }
            ExtOut ("Ready for finalization %d objects (%p->%p)\n",
                    finalize.m_FillPointers[NUMBERGENERATIONS]
                    - finalize.m_FillPointers[NUMBERGENERATIONS-1],
                    (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-1],
                    (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS]);
            for (dwAddr = (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS - heap.g_max_generation - 2];
                 dwAddr <= (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS];
                 dwAddr += sizeof (dwAddr)) {
                if (IsInterrupt())
                    return Status;
                DWORD_PTR objAddr;
                if (g_ExtData->ReadVirtual(dwAddr, &objAddr, sizeof(objAddr), NULL) != S_OK) {
                    continue;
                }
				DWORD_PTR MTAddr;
                if (g_ExtData->ReadVirtual(objAddr, &MTAddr, sizeof(MTAddr), NULL) != S_OK) {
                    continue;
                }
                if (MTAddr) {
                    size_t s = ObjectSize (objAddr);
                    stat->Add (MTAddr, (DWORD)s);
                }
            }
        }
    }
    
	PrintGCStat();

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Module          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpModule)
{
    INIT_API();
    DWORD_PTR p_ModuleAddr = GetExpression (args);
    if (p_ModuleAddr == 0)
        return Status;
    Module v_Module;
    v_Module.Fill (p_ModuleAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill Module\n");
        return Status;
    }
    WCHAR FileName[MAX_PATH+1];
    FileNameForModule (&v_Module, FileName);
    ExtOut ("Name %ws\n", FileName[0] ? FileName : L"Unknown Module");
    ExtOut ("dwFlags %08x\n", v_Module.m_dwFlags);
    ExtOut ("Attribute ");
    if (v_Module.m_dwFlags & Module::IS_IN_MEMORY)
        ExtOut ("%s", "InMemory ");
    if (v_Module.m_dwFlags & Module::IS_PRELOAD)
        ExtOut ("%s", "Preload ");
    if (v_Module.m_dwFlags & Module::IS_PEFILE)
        ExtOut ("%s", "PEFile ");
    if (v_Module.m_dwFlags & Module::IS_REFLECTION)
        ExtOut ("%s", "Reflection ");
    if (v_Module.m_dwFlags & Module::IS_PRECOMPILE)
        ExtOut ("%s", "PreCompile ");
    if (v_Module.m_dwFlags & Module::IS_EDIT_AND_CONTINUE)
        ExtOut ("%s", "Edit&Continue ");
    if (v_Module.m_dwFlags & Module::SUPPORTS_UPDATEABLE_METHODS)
        ExtOut ("%s", "SupportsUpdateableMethods");
    ExtOut ("\n");
    ExtOut ("Assembly %p\n", (ULONG64)v_Module.m_pAssembly);

    ExtOut ("LoaderHeap* %p\n", (ULONG64)v_Module.m_pLookupTableHeap);
    ExtOut ("TypeDefToMethodTableMap* %p\n",
             (ULONG64)v_Module.m_TypeDefToMethodTableMap.pTable);
    ExtOut ("TypeRefToMethodTableMap* %p\n",
             (ULONG64)v_Module.m_TypeRefToMethodTableMap.pTable);
    ExtOut ("MethodDefToDescMap* %p\n",
             (ULONG64)v_Module.m_MethodDefToDescMap.pTable);
    ExtOut ("FieldDefToDescMap* %p\n",
             (ULONG64)v_Module.m_FieldDefToDescMap.pTable);
    ExtOut ("MemberRefToDescMap* %p\n",
             (ULONG64)v_Module.m_MemberRefToDescMap.pTable);
    ExtOut ("FileReferencesMap* %p\n",
             (ULONG64)v_Module.m_FileReferencesMap.pTable);
    ExtOut ("AssemblyReferencesMap* %p\n",
             (ULONG64)v_Module.m_AssemblyReferencesMap.pTable);

    PVOID pMetaData;
    long cbMetaData;
    if (v_Module.m_ilBase && GetDllMetaData((size_t)v_Module.m_ilBase, &pMetaData, &cbMetaData)) {
        ExtOut ("MetaData starts at %p (0x%x bytes)\n", (ULONG64)pMetaData, cbMetaData);
    }
    
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Domain          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpDomain)
{
    INIT_API();
    DWORD_PTR p_DomainAddr = GetExpression (args);
    
    AppDomain v_AppDomain;
    if (p_DomainAddr)
    {
        ExtOut ("Domain: %p\n", (ULONG64)p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        if (!CallStatus)
        {
            ExtOut ("Fail to fill AppDomain\n");
            return Status;
        }
        DomainInfo (&v_AppDomain);
        return Status;
    }
    
    // List all domain
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    
    // The first one is the system domain.
    p_DomainAddr = domainList[0];
    ExtOut ("--------------------------------------\n");
    ExtOut ("System Domain: %p\n", (ULONG64)p_DomainAddr);
    v_AppDomain.Fill (p_DomainAddr);
    DomainInfo (&v_AppDomain);

    // The second one is the shared domain.
    p_DomainAddr = domainList[1];
    ExtOut ("--------------------------------------\n");
    ExtOut ("Shared Domain: %x\n", p_DomainAddr);
    SharedDomainInfo (p_DomainAddr);

    int n;
    int n0 = 2;
    for (n = n0; n < numDomain; n++)
    {
        if (IsInterrupt())
            break;

        p_DomainAddr = domainList[n];
        ExtOut ("--------------------------------------\n");
        ExtOut ("Domain %d: %x\n", n-n0+1, p_DomainAddr);
        if (p_DomainAddr == 0) {
            continue;
        }
        // Check if this domain already appears.
        int i;
        for (i = 0; i < n; i ++)
        {
            if (domainList[i] == p_DomainAddr)
                break;
        }
        if (i < n)
        {
            ExtOut ("Same as Domain %d\n", i-n0);
        }
        else
        {
            v_AppDomain.Fill (p_DomainAddr);
            DomainInfo (&v_AppDomain);
        }
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a RWLock          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(RWLock)
{
    INIT_API();
    DWORD_PTR pAddr = 0;
    BOOL bDumpAll = FALSE;
    if (_stricmp (args, "-all") == 0)
        bDumpAll = TRUE;
    else
    {
        pAddr = GetExpression (args);
        if (pAddr == 0)
        {
            return Status;
        }
    }
    
    CRWLock v_RWLock = {0};
    if (!bDumpAll)
    {
        v_RWLock.Fill(pAddr);
        ExtOut ("MethodTable: %p\n", (ULONG64)v_RWLock._pMT);
        ExtOut ("WriterEvent=%x, ReaderEvent=%x\n",
                 v_RWLock._hWriterEvent, v_RWLock._hReaderEvent);
        ExtOut ("State: %x\n", v_RWLock._dwState);
        ExtOut ("ULockID=%x, LLockID=%x, WriterID=%x\n",
                 v_RWLock._dwULockID, v_RWLock._dwLLockID,
                 v_RWLock._dwWriterID);
        ExtOut ("WriterSeqNum=%x\n", v_RWLock._dwWriterSeqNum);
        ExtOut ("Flags=%x, WriterLevel=%x\n", v_RWLock._wFlags,
                 v_RWLock._wWriterLevel);
    }

    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    Thread vThread;
    int i;

    for (i = 0; i < numThread; i++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_pHead != NULL)
        {
            BOOL bNeedsHeader = TRUE;
            LockEntry vLockEntry;
            dwAddr = (DWORD_PTR)vThread.m_pHead;
            vLockEntry.Fill (dwAddr);
            if (!CallStatus)
                break;
            while (1)
            {
                if (vLockEntry.dwULockID || vLockEntry.dwLLockID)
                {
                    if (bDumpAll)
                    {
                        if (bNeedsHeader)
                        {
                            bNeedsHeader = FALSE;
                            ExtOut ("Thread: %8x   %p\n",
                                     vThread.m_ThreadId, (ULONG64)threadList[i]);
                        }
                        ExtOut ("ID %x:%x, ReaderLevel %d\n",
                                 vLockEntry.dwULockID,
                                 vLockEntry.dwLLockID,
                                 vLockEntry.wReaderLevel);
                    }
                    else if (v_RWLock._dwULockID == vLockEntry.dwULockID &&
                         v_RWLock._dwLLockID == vLockEntry.dwLLockID)
                        ExtOut ("Thread: %8x   %p\n", vThread.m_ThreadId,
                                 (ULONG64)threadList[i]);
                }
                if (vLockEntry.pNext == vThread.m_pHead)
                    break;
                dwAddr = (DWORD_PTR)vLockEntry.pNext;
                vLockEntry.Fill(dwAddr);
                if (!CallStatus)
                    break;
            }
        }
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Assembly        *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpAssembly)
{
    INIT_API();
    DWORD_PTR p_AssemblyAddr = GetExpression (args);
    if (p_AssemblyAddr == 0)
        return Status;
    Assembly v_Assembly;
    v_Assembly.Fill (p_AssemblyAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill Assembly\n");
        return Status;
    }
    ExtOut ("Parent Domain: %p\n", (ULONG64)v_Assembly.m_pDomain);
    ExtOut ("Name: ");
    PrintString ((DWORD_PTR) v_Assembly.m_psName);
    ExtOut ("\n");
    AssemblyInfo (&v_Assembly);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a ClassLoader     *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpLoader)
{
    INIT_API();
    DWORD_PTR p_ClassLoaderAddr = GetExpression (args);
    if (p_ClassLoaderAddr == 0)
        return Status;
    ClassLoader v_ClassLoader;
    v_ClassLoader.Fill (p_ClassLoaderAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill ClassLoader\n");
        return Status;
    }
    ExtOut ("Assembly: %p\n", (ULONG64)v_ClassLoader.m_pAssembly);
    ExtOut ("Next ClassLoader: %p\n", (ULONG64)v_ClassLoader.m_pNext);
    ClassLoaderInfo(&v_ClassLoader);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the managed threads               *
*                                                                      *
\**********************************************************************/
DECLARE_API(Threads)
{
    INIT_API();

    DWORD_PTR p_g_pThreadStore = GetValueFromExpression ("mscoree!g_pThreadStore");
    DWORD_PTR g_pThreadStore;
    HRESULT hr;
    if (FAILED (hr = g_ExtData->ReadVirtual (p_g_pThreadStore, &g_pThreadStore,
                                             sizeof (DWORD_PTR), NULL)))
        return hr;
    if (g_pThreadStore == 0)
        return S_FALSE;
    
    ThreadStore vThreadStore;
    DWORD_PTR dwAddr = g_pThreadStore;
    vThreadStore.Fill (dwAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill ThreadStore\n");
        return Status;
    }

    ExtOut ("ThreadCount: %d\n", vThreadStore.m_ThreadCount);
    ExtOut ("UnstartedThread: %d\n", vThreadStore.m_UnstartedThreadCount);
    ExtOut ("BackgroundThread: %d\n", vThreadStore.m_BackgroundThreadCount);
    ExtOut ("PendingThread: %d\n", vThreadStore.m_PendingThreadCount);
    ExtOut ("DeadThread: %d\n", vThreadStore.m_DeadThreadCount);
    
    
    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    static DWORD_PTR FinalizerThreadAddr = 0;
    if (FinalizerThreadAddr == 0)
    {
        FinalizerThreadAddr = GetValueFromExpression ("mscoree!GCHeap__FinalizerThread");
    }
    DWORD_PTR finalizerThread;
    moveN (finalizerThread, FinalizerThreadAddr);

    static DWORD_PTR GcThreadAddr = 0;
    if (GcThreadAddr == 0)
    {
        GcThreadAddr = GetValueFromExpression ("mscoree!GCHeap__GcThread");
    }
    DWORD_PTR GcThread;
    moveN (GcThread, GcThreadAddr);

    // Due to a bug in dbgeng.dll of v1, getting debug thread id
    // more than once leads to deadlock.
    
    ExtOut ("                             PreEmptive   GC Alloc               Lock     \n");
    ExtOut ("       ID ThreadOBJ    State     GC       Context       Domain   Count APT Exception\n");
    int i;
    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (!IsKernelDebugger()) {
            ULONG id=0;
            if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
            {
                ExtOut ("%3d ", id);
            }
            else
            {
                ExtOut ("XXX ");
            }
        }
        else
            ExtOut ("    ");
        
        ExtOut ("%5x %p  %8x", vThread.m_ThreadId, (ULONG64)threadList[i],
                vThread.m_State);
        if (vThread.m_fPreemptiveGCDisabled == 1)
            ExtOut (" Disabled");
        else
            ExtOut (" Enabled ");

        ExtOut (" %p:%p", (ULONG64)vThread.m_alloc_context.alloc_ptr, (ULONG64)vThread.m_alloc_context.alloc_limit);

        Context vContext;
        DWORD_PTR dwAddrTmp = (DWORD_PTR)vThread.m_Context;
        vContext.Fill (dwAddrTmp);
        if (vThread.m_pDomain)
            ExtOut (" %p", (ULONG64)vThread.m_pDomain);
        else
        {
            ExtOut (" %p", (ULONG64)vContext.m_pDomain);
        }
        ExtOut (" %5d", vThread.m_dwLockCount);

        // Apartment state
        DWORD_PTR OleTlsDataAddr;
        if (SafeReadMemory((size_t)vThread.m_pTEB + offsetof(TEB,ReservedForOle),
                            &OleTlsDataAddr,
                            sizeof(OleTlsDataAddr), NULL) && OleTlsDataAddr != 0) {
            DWORD AptState;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwFlags),
                               &AptState,
                               sizeof(AptState), NULL)) {
                if (AptState & OLETLS_APARTMENTTHREADED) {
                    ExtOut (" STA");
                }
                else if (AptState & OLETLS_MULTITHREADED) {
                    ExtOut (" MTA");
                }
                else if (AptState & OLETLS_INNEUTRALAPT) {
                    ExtOut (" NTA");
                }
                else {
                    ExtOut (" Ukn");
                }
            }
            else
                ExtOut (" Ukn");
        }
        else
            ExtOut (" Ukn");
#if 0
        DWORD_PTR tmp = (DWORD_PTR)vThread.m_pSharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        tmp = (DWORD_PTR)vThread.m_pUnsharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        
        tmp = (DWORD_PTR)vContext.m_pSharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        tmp = (DWORD_PTR)vContext.m_pUnsharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
#endif
        if (threadList[i] == finalizerThread)
            ExtOut (" (Finalizer)");
        if (threadList[i] == GcThread)
            ExtOut (" (GC)");
        if (vThread.m_State & Thread::TS_ThreadPoolThread) {
            if (vThread.m_State & Thread::TS_TPWorkerThread) {
                ExtOut (" (Threadpool Worker)");
            }
            else
                ExtOut (" (Threadpool Completion Port)");
        }
        if (!SafeReadMemory((DWORD_PTR)vThread.m_LastThrownObjectHandle,
                            &dwAddr,
                            sizeof(dwAddr), NULL))
            goto end_of_loop;
        if (dwAddr)
        {
            DWORD_PTR MTAddr;
            if (!SafeReadMemory(dwAddr, &MTAddr, sizeof(MTAddr), NULL))
                goto end_of_loop;
            MethodTable vMethTable;
            vMethTable.Fill (MTAddr);
            NameForMT (vMethTable, g_mdName);
            ExtOut (" %S", g_mdName);
        }
end_of_loop:
        ExtOut ("\n");
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the managed threadpool            *
*                                                                      *
\**********************************************************************/
DECLARE_API(ThreadPool)
{
    INIT_API();

    static DWORD_PTR cpuUtilizationAddr = 0;
    if (cpuUtilizationAddr == 0) {
        cpuUtilizationAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__cpuUtilization");
    }
    long lValue;
    if (g_ExtData->ReadVirtual(cpuUtilizationAddr,&lValue,sizeof(lValue),NULL) == S_OK
        && lValue != 0) {
        ExtOut ("CPU utilization %d%%\n", lValue);
    }
    
    ExtOut ("Worker Thread:");
    static DWORD_PTR NumWorkerThreadsAddr = 0;
    if (NumWorkerThreadsAddr == 0) {
        NumWorkerThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumWorkerThreads");
    }
    int iValue;
    if (g_ExtData->ReadVirtual(NumWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Total: %d", iValue);
    }
    
    static DWORD_PTR NumRunningWorkerThreadsAddr = 0;
    if (NumRunningWorkerThreadsAddr == 0) {
        NumRunningWorkerThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumRunningWorkerThreads");
    }
    if (g_ExtData->ReadVirtual(NumRunningWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Running: %d", iValue);
    }
    
    static DWORD_PTR NumIdleWorkerThreadsAddr = 0;
    if (NumIdleWorkerThreadsAddr == 0) {
        NumIdleWorkerThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumIdleWorkerThreads");
    }
    if (g_ExtData->ReadVirtual(NumIdleWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Idle: %d", iValue);
    }
    
    static DWORD_PTR MaxLimitTotalWorkerThreadsAddr = 0;
    if (MaxLimitTotalWorkerThreadsAddr == 0) {
        MaxLimitTotalWorkerThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__MaxLimitTotalWorkerThreads");
    }
    if (g_ExtData->ReadVirtual(MaxLimitTotalWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxLimit: %d", iValue);
    }
    
    static DWORD_PTR MinLimitTotalWorkerThreadsAddr = 0;
    if (MinLimitTotalWorkerThreadsAddr == 0) {
        MinLimitTotalWorkerThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__MinLimitTotalWorkerThreads");
    }
    if (g_ExtData->ReadVirtual(MinLimitTotalWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MinLimit: %d", iValue);
    }
    ExtOut ("\n");
    
    static DWORD_PTR NumQueuedWorkRequestsAddr = 0;
    if (NumQueuedWorkRequestsAddr == 0) {
        NumQueuedWorkRequestsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumQueuedWorkRequests");
    }
    if (g_ExtData->ReadVirtual(NumQueuedWorkRequestsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut ("Work Request in Queue: %d\n", iValue);
    }

    if (iValue > 0) {
        // Display work request
        static DWORD_PTR FQueueUserWorkItemCallback = 0;
        static DWORD_PTR FtimerDeleteWorkItem = 0;
        static DWORD_PTR FAsyncCallbackCompletion = 0;
        static DWORD_PTR FAsyncTimerCallbackCompletion = 0;

        if (FQueueUserWorkItemCallback == 0) {
            FQueueUserWorkItemCallback = GetValueFromExpression ("mscoree!QueueUserWorkItemCallback");
        }
        if (FtimerDeleteWorkItem == 0) {
            FtimerDeleteWorkItem = GetValueFromExpression ("mscoree!TimerNative__timerDeleteWorkItem");
        }
        if (FAsyncCallbackCompletion == 0) {
            FAsyncCallbackCompletion = GetValueFromExpression ("mscoree!ThreadpoolMgr__AsyncCallbackCompletion");
        }
        if (FAsyncTimerCallbackCompletion == 0) {
            FAsyncTimerCallbackCompletion = GetValueFromExpression ("mscoree!ThreadpoolMgr__AsyncTimerCallbackCompletion");
        }

        static DWORD_PTR headAddr = 0;
        static DWORD_PTR tailAddr = 0;
        if (headAddr == 0) {
            headAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__WorkRequestHead");
        }
        if (tailAddr == 0) {
            tailAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__WorkRequestTail");
        }
        DWORD_PTR head;
        g_ExtData->ReadVirtual(headAddr,&head,sizeof(head),NULL);
        DWORD_PTR dwAddr = head;
        WorkRequest work;
        while (dwAddr) {
            if (IsInterrupt())
                break;
            work.Fill(dwAddr);
            if ((DWORD_PTR)work.Function == FQueueUserWorkItemCallback)
                ExtOut ("QueueUserWorkItemCallback DelegateInfo@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FtimerDeleteWorkItem)
                ExtOut ("timerDeleteWorkItem TimerDeleteInfo@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FAsyncCallbackCompletion)
                ExtOut ("AsyncCallbackCompletion AsyncCallback@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FAsyncTimerCallbackCompletion)
                ExtOut ("AsyncTimerCallbackCompletion TimerInfo@%p\n", (ULONG64)work.Context);
            else
                ExtOut ("Unknown %p\n", (ULONG64)work.Context);
            
            dwAddr = (DWORD_PTR)work.next;
        }
    }
    ExtOut ("--------------------------------------\n");

    static DWORD_PTR NumTimersAddr = 0;
    if (NumTimersAddr == 0) {
        NumTimersAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumTimers");
    }
    DWORD dValue;
    if (g_ExtData->ReadVirtual(NumTimersAddr,&dValue,sizeof(dValue),NULL) == S_OK) {
        ExtOut ("Number of Timers: %d\n", dValue);
    }

    ExtOut ("--------------------------------------\n");
    
    ExtOut ("Completion Port Thread:");
    
    static DWORD_PTR NumCPThreadsAddr = 0;
    if (NumCPThreadsAddr == 0) {
        NumCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumCPThreads");
    }
    if (g_ExtData->ReadVirtual(NumCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Total: %d", iValue);
    }

    static DWORD_PTR NumFreeCPThreadsAddr = 0;
    if (NumFreeCPThreadsAddr == 0) {
        NumFreeCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__NumFreeCPThreads");
    }
    if (g_ExtData->ReadVirtual(NumFreeCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Free: %d", iValue);
    }

    static DWORD_PTR MaxFreeCPThreadsAddr = 0;
    if (MaxFreeCPThreadsAddr == 0) {
        MaxFreeCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__MaxFreeCPThreads");
    }
    if (g_ExtData->ReadVirtual(MaxFreeCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxFree: %d", iValue);
    }

    static DWORD_PTR CurrentLimitTotalCPThreadsAddr = 0;
    if (CurrentLimitTotalCPThreadsAddr == 0) {
        CurrentLimitTotalCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__CurrentLimitTotalCPThreads");
    }
    if (g_ExtData->ReadVirtual(CurrentLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" CurrentLimit: %d", iValue);
    }

    static DWORD_PTR MaxLimitTotalCPThreadsAddr = 0;
    if (MaxLimitTotalCPThreadsAddr == 0) {
        MaxLimitTotalCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__MaxLimitTotalCPThreads");
    }
    if (g_ExtData->ReadVirtual(MaxLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxLimit: %d", iValue);
    }

    static DWORD_PTR MinLimitTotalCPThreadsAddr = 0;
    if (MinLimitTotalCPThreadsAddr == 0) {
        MinLimitTotalCPThreadsAddr = GetValueFromExpression ("mscoree!ThreadpoolMgr__MinLimitTotalCPThreads");
    }
    if (g_ExtData->ReadVirtual(MinLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MinLimit: %d", iValue);
    }

    ExtOut ("\n");

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the COM state (e.g. APT,contexe    *
*    activity.                                                         *  
*                                                                      *
\**********************************************************************/
DECLARE_API(COMState)
{
    INIT_API();

    ULONG numThread;
    ULONG maxId;
    g_ExtSystem->GetTotalNumberThreads(&numThread,&maxId);

    ULONG curId;
    g_ExtSystem->GetCurrentThreadId(&curId);

    ULONG *ids = (ULONG*)alloca(sizeof(ULONG)*numThread);
    ULONG *sysIds = (ULONG*)alloca(sizeof(ULONG)*numThread);
    g_ExtSystem->GetThreadIdsByIndex(0,numThread,ids,sysIds);

    ExtOut ("     ID     TEB   APT    APTId CallerTID Context\n");
    for (ULONG i = 0; i < numThread; i ++) {
        g_ExtSystem->SetCurrentThreadId(ids[i]);
        ULONG64 tebAddr;
        g_ExtSystem->GetCurrentThreadTeb(&tebAddr);
        ExtOut ("%3d %4x %p", ids[i], sysIds[i], tebAddr);
        // Apartment state
        DWORD_PTR OleTlsDataAddr;
        if (SafeReadMemory((ULONG_PTR)tebAddr + offsetof(TEB,ReservedForOle),
                            &OleTlsDataAddr,
                            sizeof(OleTlsDataAddr), NULL) && OleTlsDataAddr != 0) {
            DWORD AptState;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwFlags),
                               &AptState,
                               sizeof(AptState), NULL)) {
                if (AptState & OLETLS_APARTMENTTHREADED) {
                    ExtOut (" STA");
                }
                else if (AptState & OLETLS_MULTITHREADED) {
                    ExtOut (" MTA");
                }
                else if (AptState & OLETLS_INNEUTRALAPT) {
                    ExtOut (" NTA");
                }
                else {
                    ExtOut (" Ukn");
                }
            }
            else
                ExtOut (" Ukn");
            
            DWORD dwApartmentID;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwApartmentID),
                               &dwApartmentID,
                               sizeof(dwApartmentID), NULL)) {
                ExtOut (" %8x", dwApartmentID);
            }
            else
                ExtOut (" %8x", 0);
            
            DWORD dwTIDCaller;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwTIDCaller),
                               &dwTIDCaller,
                               sizeof(dwTIDCaller), NULL)) {
                ExtOut ("  %8x", dwTIDCaller);
            }
            else
                ExtOut ("  %8x", 0);
            
            size_t Context;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,pCurrentCtx),
                               &Context,
                               sizeof(Context), NULL)) {
                ExtOut (" %p", (ULONG64)Context);
            }
            else
                ExtOut (" %p", (ULONG64)0);
        }
        else
            ExtOut (" Ukn");
        ExtOut ("\n");
    }

    g_ExtSystem->SetCurrentThreadId(curId);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the GC encoding of a managed      *
*    function.                                                         *  
*                                                                      *
\**********************************************************************/
DECLARE_API(GCInfo)
{
    DWORD_PTR dwStartAddr;
    MethodDesc MD;

    INIT_API();

    dwStartAddr = GetExpression(args);
    DWORD_PTR tmpAddr = dwStartAddr;
    if (!IsMethodDesc(dwStartAddr)) {
        JitType jitType;
        DWORD_PTR methodDesc;
        DWORD_PTR gcinfoAddr;
        IP2MethodDesc (dwStartAddr, methodDesc, jitType, gcinfoAddr);
        if (methodDesc) {
            tmpAddr = methodDesc;
        }
        else
            tmpAddr = 0;
    }

    if (tmpAddr == 0)
    {
        ExtOut("not a valid MethodDesc\n");
        return Status;
    }

    MD.Fill (tmpAddr);
    if (!CallStatus)
        return Status;
    
    if(MD.m_CodeOrIL & METHOD_IS_IL_FLAG)
    {
        ExtOut("No GC info available\n");
        return Status;
    }

    CodeInfo codeInfo;
    CodeInfoForMethodDesc (MD, codeInfo);
    if (codeInfo.jitType == UNKNOWN)
    {
        ExtOut ("unknown Jit\n");
        return Status;
    }
    else if (codeInfo.jitType == EJIT)
    {
        ExtOut ("GCinfo for EJIT not supported\n");
        return Status;
    }
    else if (codeInfo.jitType == JIT)
    {
        ExtOut ("Normal JIT generated code\n");
    }
    else if (codeInfo.jitType == PJIT)
    {
        ExtOut ("preJIT generated code\n");
    }
    
    DWORD_PTR vAddr = codeInfo.gcinfoAddr;
    GCDump gcDump;
    gcDump.gcPrintf = ExtOut;

    // assume that GC encoding table is never more than
    // 40 + methodSize * 2
    int tableSize = 40 + codeInfo.methodSize*2;
    BYTE *table = (BYTE*) _alloca (tableSize);
    memset (table, 0, tableSize);
    // We avoid using move here, because we do not want to return
    if (!SafeReadMemory(vAddr, table, tableSize, NULL))
    {
        ExtOut ("Could not read memory %p\n", (ULONG64)vAddr);
        return Status;
    }
    
    InfoHdr header;
    ExtOut ("Method info block:\n");
    table += gcDump.DumpInfoHdr(table, &header, &codeInfo.methodSize, 0);
    ExtOut ("\n");
    ExtOut ("Pointer table:\n");
    table += gcDump.DumpGCTable(table, header, codeInfo.methodSize, 0);    
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to unassembly a managed function.         *
*    It tries to print symbolic info for function call, contants...    *  
*                                                                      *
\**********************************************************************/
DECLARE_API(u)
{
    DWORD_PTR dwStartAddr;
    MethodDesc MD;

    INIT_API();

    dwStartAddr = GetExpression (args);
    
    DWORD_PTR tmpAddr = dwStartAddr;
    CodeInfo codeInfo;
    DWORD_PTR methodDesc = tmpAddr;
    if (!IsMethodDesc (tmpAddr))
    {
        tmpAddr = dwStartAddr;
        IP2MethodDesc (tmpAddr, methodDesc, codeInfo.jitType,
                       codeInfo.gcinfoAddr);
        if (!methodDesc || codeInfo.jitType == UNKNOWN)
        {
            // It is not managed code.
            ExtOut ("Unmanaged code\n");
            UnassemblyUnmanaged(dwStartAddr);
            return Status;
        }
        tmpAddr = methodDesc;
    }
    MD.Fill (tmpAddr);
    if (!CallStatus)
        return Status;
    

    if(MD.m_CodeOrIL & METHOD_IS_IL_FLAG)
    {
        ExtOut("Not jitted yet\n");
        return Status;
    }

    CodeInfoForMethodDesc (MD, codeInfo);
    if (codeInfo.IPBegin == 0)
    {
        ExtOut("not a valid MethodDesc\n");
        return Status;
    }
    if (codeInfo.jitType == UNKNOWN)
    {
        ExtOut ("unknown Jit\n");
        return Status;
    }
    else if (codeInfo.jitType == EJIT)
    {
        ExtOut ("EJIT generated code\n");
    }
    else if (codeInfo.jitType == JIT)
    {
        ExtOut ("Normal JIT generated code\n");
    }
    else if (codeInfo.jitType == PJIT)
    {
        ExtOut ("preJIT generated code\n");
    }
    CQuickBytes fullname;
    FullNameForMD (&MD, &fullname);
    ExtOut ("%S\n", (WCHAR*)fullname.Ptr());
    
    ExtOut ("Begin %p, size %x\n", (ULONG64)codeInfo.IPBegin, codeInfo.methodSize);

    Unassembly (codeInfo.IPBegin, codeInfo.IPBegin+codeInfo.methodSize);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to search a DWORD on stack                *
*                                                                      *
\**********************************************************************/
DECLARE_API (SearchStack)
{
    INIT_API();

    DWORD_PTR num[2];
    int index = 0;
    
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    while (pch[0] != '\0')
    {
        if (IsInterrupt())
            return Status;
        while (isspace (pch[0]))
            pch ++;
        char *endptr;
        num[index] = strtoul (pch, &endptr, 16);
        if (pch == endptr)
        {
            ExtOut ("wrong argument\n");
            return Status;
        }
        index ++;
        if (index == 2)
            break;
        pch = endptr;
    }

    DWORD_PTR top;
    ULONG64 StackOffset;
    g_ExtRegisters->GetStackOffset (&StackOffset);
    if (index <= 1)
    {
        top = (DWORD_PTR)StackOffset;
    }
    else
    {
        top = num[1];
    }
    
    DWORD_PTR end = top + 0xFFFF;
    DWORD_PTR ptr = top & ~3;  // make certain dword aligned
    while (ptr < end)
    {
        if (IsInterrupt())
            return Status;
        DWORD_PTR value;
        moveN (value, ptr);
        if (value == num[0])
            ExtOut ("%p\n", (ULONG64)ptr);
        ptr += sizeof (DWORD_PTR);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a CrawlFrame      *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpCrawlFrame)
{
    INIT_API();
    DWORD_PTR dwStartAddr = GetExpression(args);
    if (dwStartAddr == 0)
        return Status;
    
    CrawlFrame crawlFrame;
    moveN (crawlFrame, dwStartAddr);
    ExtOut ("MethodDesc: %p\n", (ULONG64)crawlFrame.pFunc);
    REGDISPLAY RD;
    moveN (RD, crawlFrame.pRD);
    DWORD_PTR Edi, Esi, Ebx, Edx, Ecx, Eax, Ebp, PC;
    moveN (Edi, RD.pEdi);
    moveN (Esi, RD.pEsi);
    moveN (Ebx, RD.pEbx);
    moveN (Edx, RD.pEdx);
    moveN (Ecx, RD.pEcx);
    moveN (Eax, RD.pEax);
    moveN (Ebp, RD.pEbp);
    moveN (PC, RD.pPC);
    
    ExtOut ("EDI=%8x ESI=%8x EBX=%8x EDX=%8x ", Edi, Esi, Ebx, Edx);
    ExtOut ("ECX=%8x EAX=%8x\n", Ecx, Eax);
    ExtOut ("EBP=%8x ESP=%8x PC=%8x\n", Ebp, RD.Esp, PC);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the build number and type of the  *  
*    mscoree.dll                                                       *
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpLog)
{
    INIT_API();

    if (GetEEFlavor() == UNKNOWNEE) {
        ExtOut("CLR not loaded\n");
        return Status;
    }

	const char* fileName = "StressLog.txt";

    while (isspace (*args))
        args ++;

	if (*args != 0)
		fileName = args;
    
    DWORD_PTR dwg_StressLog = GetValueFromExpression("mscoree!StressLog__theLog");
	if (dwg_StressLog == 0) {
		ExtOut("Could not find Stress log symbol!\n");
		return E_FAIL;
	}

	ExtOut("Attempting to dump Stress log to file '%s'\n", fileName);

	Status = StressLog::Dump(dwg_StressLog, fileName, g_ExtData);

	if (Status == S_OK)
        ExtOut("SUCCESS: Stress log dumped\n");
	else if (Status == S_FALSE)
        ExtOut("No Stress log in the image, no file written\n");
	else
        ExtOut("FAILURE: Stress log not dumped\n");

	return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the build number and type of the  *  
*    mscoree.dll                                                       *
*                                                                      *
\**********************************************************************/
DECLARE_API (EEVersion)
{
    INIT_API();

    if (GetEEFlavor() == UNKNOWNEE) {
        ExtOut("CLR not loaded\n");
        return Status;
    }

    static DWORD_PTR dwg_Version = GetValueFromExpression("mscoree!g_Version");
    static DWORD_PTR dwg_ProbeGolden = GetValueFromExpression("mscoree!gc_heap__verify_heap");
    BOOL bGolden = (dwg_ProbeGolden == 0);
    WCHAR buffer[100];
    
    if (g_ExtSymbols2) {
        static VS_FIXEDFILEINFO version;
        static DWORD fDone = 0;
        if (fDone == 0) {
            if (g_ExtSymbols2->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                           moduleInfo[GetEEFlavor()].baseAddr,
                                                           "\\", &version, sizeof(VS_FIXEDFILEINFO), NULL)
                == S_OK)
                fDone = 1;
            else
                fDone = 2;
        }
        if (fDone == 1) {
            if(version.dwFileVersionMS != (DWORD)-1)
            {
                ExtOut("%u.%u.%u.%u",
                       HIWORD(version.dwFileVersionMS),
                       LOWORD(version.dwFileVersionMS),
                       HIWORD(version.dwFileVersionLS),
                       LOWORD(version.dwFileVersionLS));
                if (version.dwFileFlags & VS_FF_DEBUG) {
                    GetVersionString (buffer);
                    if (wcsstr(buffer, L"Debug")) {
                        ExtOut (" checked");
                    }
                    else if (wcsstr(buffer, L"fastchecked")) {
                        ExtOut (" fastchecked");
                    }
                    else {
                        ExtOut (" unknown debug build\n");
                    }
                }
                else
                { 
                    static BOOL fRet = IsRetailBuild ((size_t)moduleInfo[GetEEFlavor()].baseAddr);
                    if (fRet) {
                        ExtOut (" retail");
                    }
                    else
                        ExtOut (" free");
                }

                if (bGolden) {
                    ExtOut (" Golden");
                }
                ExtOut ("\n");

                goto BuildType;
            }
        }
    }

    GetVersionString (buffer);
    if (buffer[0] != L'\0') {
        WCHAR *pt = wcsstr(buffer, L"Debug");
        if (pt == NULL)
            pt = wcsstr(buffer, L"fastchecked");
        if ((DebugVersionDll == 1 && pt == NULL)
            || (DebugVersionDll == 0 && pt != NULL))
        {
            ExtOut ("mismatched mscoree.dll and symbol file\n");
        }
        ExtOut ("%S", buffer);


        if (DebugVersionDll == 0)
        {
            static BOOL fRet = IsRetailBuild ((size_t)moduleInfo[GetEEFlavor()].baseAddr);
            if (fRet) {
                ExtOut (" retail");
            }
            else
                ExtOut (" free");
        }

        if (bGolden)
            ExtOut (" Golden");

        ExtOut ("\n");
    }
    
BuildType:
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps =
                GetValueFromExpression("MSCOREE!gc_heap__n_heaps");
        DWORD_PTR dwNHeaps;
        moveN (dwNHeaps, dwAddrNHeaps);
        ExtOut ("Server build with %d gc heaps\n", dwNHeaps);
    }
    else
        ExtOut ("Workstation build\n");

    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the symbol and source path         *  
*                                                                      *
\**********************************************************************/
DECLARE_API (EEDebug)
{
    INIT_API();
    while (isspace (args[0]))
        args ++;
    if (args[0] == '\0') {
        ExtOut ("Usage: EEDebug 2204\n");
        return Status;
    }
    char buffer[100];
    strcpy (buffer, args);
    LPSTR version = buffer;
    LPSTR flavor = buffer;
    while (flavor[0] != '\0' && !isspace(flavor[0])) {
        flavor ++;
    }
    if (flavor[0] != '\0') {
        flavor[0] = '\0';
        flavor++;
        while (isspace (flavor[0])) {
            flavor ++;
        }
    }
    
    if (flavor[0] != '\0') {
        ExtOut ("Usage: EEDebug 2204\n");
        return Status;
    }
    
    char *EESymbol="symsrv*symsrv.dll*\\\\urtdist\\builds\\symbols";
    char *NTSymbol="symsrv*symsrv.dll*\\\\symbols\\symbols";
    char symbol[2048];
    g_ExtSymbols->GetSymbolPath(symbol,2048,NULL);
    char Final[2048] = "\0";
    char *pt = symbol;
    BOOL fExist = FALSE;
    BOOL fCopy;
    BOOL fServer = FALSE;
    while (pt) {
        char *sep = strchr (pt, ';');
        if (sep) {
            sep[0] = '\0';
        }
        char *server = NULL;
        if (_strnicmp(pt,"symsrv*symsrv.dll*",sizeof("symsrv*symsrv.dll*")-1) == 0) {
            server = pt + sizeof("symsrv*symsrv.dll*")-1;
        }
        else if (_strnicmp(pt,"srv*",sizeof("srv*")-1) == 0) {
            server = pt + sizeof("srv*")-1;
        }
        if (server)
        {        
            char *tmp = strstr (server, "\\\\");
            if (tmp) {
                server = tmp;
            }
            if (!fExist && _stricmp (server, "\\\\urtdist\\builds\\symbols") == 0) {
                fExist = TRUE;
            }
            else if (!fServer && _stricmp (server, "\\\\symbols\\symbols") == 0) {
                fServer = TRUE;
            }
        }
        if (sep == NULL) {
            break;
        }
        else
        {
            sep[0] = ';';
            pt = sep + 1;
        }
        if (fExist && fServer) {
            break;
        }
    }

    if (!fExist || !fServer) {
        strcpy (Final,symbol);
    }
    if (!fExist) {
        if (Final[0] != '\0') {
            strcat (Final, ";");
        }
        strcat (Final, EESymbol);
    }

    if (!fServer) {
        // Add symbol server path.
        if (Final[0] != '\0') {
            strcat (Final, ";");
        }
        strcat (Final, NTSymbol);
    }
    if (!fExist || !fServer) {
        g_ExtSymbols->SetSymbolPath(Final);
    }
    // g_ExtSymbols->AddSymbolOptions(SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_NO_CPP);
    const char *EEFileRoot = "\\\\urtdist\\builds\\src\\";
    const char *EEFileTail = "\\lightning\\src\\vm";
    char EEFile[MAX_PATH];
    strcpy (EEFile, EEFileRoot);
    strcat (EEFile, version);
    strcat (EEFile, EEFileTail);
    strcpy (symbol, EEFile);
    strcat (symbol, "\\ceemain.cpp");
    
    //strcpy (Final,".lsrcpath ");
    //strcat (Final,EEFile);
    //g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,"$<R:\temp\test.txt",DEBUG_EXECUTE_DEFAULT);
    
    if (!FileExist (symbol)) {
        ExtOut ("%s not exist\n", EEFile);
        return Status;
    }
    g_ExtSymbols->GetSourcePath(symbol,2048,NULL);
    pt = symbol;
    strcpy (Final, EEFile);
    strcat (Final, ";");
    while (pt) {
        fCopy = TRUE;
        char *sep = strchr (pt, ';');
        if (sep) {
            sep[0] = '\0';
        }
        if (_strnicmp (pt, EEFileRoot, strlen(EEFileRoot)) == 0) {
            if (_stricmp (pt, EEFile) == 0) {
                fCopy = FALSE;
            }
            else {
                char *tmp = pt + strlen(EEFileRoot);
                tmp = strchr (tmp, '\\');
                if (tmp) {
                    tmp++;
                    tmp = strchr (tmp, '\\');
                    if (tmp) {
                        if (_strnicmp (tmp, EEFileTail, strlen(EEFileTail)) == 0) {
                            fCopy = FALSE;
                        }
                    }
                }
            }
        }
        if (fCopy) {
            strcat (Final, pt);
            if (sep) {
                strcat (Final, ";");
            }
        }
        if (sep == NULL) {
            break;
        }
        else
        {
            pt = sep + 1;
        }
    }
    if (Final[strlen(Final)-1] == ';') {
        Final[strlen(Final)-1] = '\0';
    }
    g_ExtSymbols->SetSourcePath(Final);

    return Status;
}


EEDllPath *DllPath = NULL;

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the path for managed dlls          *
*    for dumps.  
*                                                                      *
\**********************************************************************/
DECLARE_API (EEDLLPath)
{
    INIT_API();

    if (!IsDumpFile() && !IsKernelDebugger()) {
        ExtOut ("Can not set path for managed dll for live user debugging\n");
        return Status;
    }

    if (DllPath == NULL) {
        DllPath = new EEDllPath;
    }

    while (isspace (args[0]))
        args ++;

    char EEPath[MAX_PATH];
    if (args[0] == '\0') {
        DllPath->DisplayPath();
    }
    else if (_strnicmp (args, "-reset", sizeof("-reset")-1) == 0) {
        DllPath->Reset();
    }
    else if (_strnicmp (args, "-std", sizeof("-std")-1) == 0) {
        args += sizeof("-std")-1;
        if (!isspace(args[0])) {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }
        while (isspace(args[0])) {
            args ++;
        }
        char *buffer = (char *)_alloca(strlen(args));
        strcpy (buffer, args);
        LPSTR version = buffer;
        LPSTR flavor = buffer;
        while (flavor[0] != '\0' && !isspace(flavor[0])) {
            flavor ++;
        }
        if (flavor[0] == '\0') {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }
        flavor[0] = '\0';
        flavor++;
        while (isspace (flavor[0])) {
            flavor ++;
        }
        if (flavor[0] == '\0') {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }

        const char *URTRoot = "\\\\urtdist\\builds\\bin\\";
        strcpy (EEPath, URTRoot);
        strcat (EEPath, version);
        strcat (EEPath, "\\");
        strcat (EEPath, flavor);
        strcat (EEPath, "\\");
        char *ptr = EEPath + strlen(EEPath);
        char *end;
        strcpy (ptr, "NDP");
        end = EEPath + strlen(EEPath);
        strcpy (end, "\\mscorlib.dll");
        if (FileExist(EEPath)) {
            end[0] = '\0';
            DllPath->AddPath(EEPath);
        }
        else
        {
            strcpy (ptr, "DNA");
            end = EEPath + strlen(EEPath);
            strcpy (end, "\\System.Dll");
            if (!FileExist(EEPath)) {
                ExtOut ("%s not exist\n", EEPath);
            }
            else
            {
                end[0] = '\0';
                DllPath->AddPath(EEPath);
            }

            strcpy (ptr, "lightning\\workstation");
            end = EEPath + strlen(EEPath);
            strcpy (end, "\\mscorlib.dll");
            if (!FileExist(EEPath)) {
                ExtOut ("%s not exist\n", EEPath);
            }
            else {
                end[0] = '\0';
                DllPath->AddPath(EEPath);
            }

            strcpy (ptr, "config");
            end = EEPath + strlen(EEPath);
            strcpy (end, "\\System.Management.dll");
            if (!FileExist(EEPath)) {
                ExtOut ("%s not exist\n", EEPath);
            }
            else {
                end[0] = '\0';
                DllPath->AddPath(EEPath);
            }
        }
    }
    else
    {
        const char *ptr = args;
        char *sep;
        while (ptr) {
            sep = strchr (ptr, ';');
            if (sep) {
                int length = sep-ptr;
                strncpy (EEPath,ptr,length);
                EEPath[length] = '\0';
                DllPath->AddPath(EEPath);
            }
            else {
                DllPath->AddPath(ptr);
                break;
            }

        }
    }
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the symbol option suitable for     *  
*    strike.                                                           *
*                                                                      *
\**********************************************************************/
DECLARE_API (SymOpt)
{
    INIT_API();

    ULONG Options;
    g_ExtSymbols->GetSymbolOptions(&Options);
    ULONG NewOptions = Options | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_NO_CPP;
    ExtOut ("%x\n", Options);
    if (Options != NewOptions)
        g_ExtSymbols->SetSymbolOptions(Options);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print the environment setting for      *  
*    the current process.                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (ProcInfo)
{
    INIT_API();

#define INFO_ENV        0x00000001
#define INFO_TIME       0x00000002
#define INFO_MEM        0x00000004
#define INFO_ALL        0xFFFFFFFF

    DWORD fProcInfo = INFO_ALL;

    if (_stricmp (args, "-env") == 0) {
        fProcInfo = INFO_ENV;
    }

    if (_stricmp (args, "-time") == 0) {
        fProcInfo = INFO_TIME;
    }

    if (_stricmp (args, "-mem") == 0) {
        fProcInfo = INFO_MEM;
    }

    if (fProcInfo & INFO_ENV) {
        ExtOut ("---------------------------------------\n");
        ExtOut ("Environment\n");
        ULONG64 pPeb;
        g_ExtSystem->GetCurrentProcessPeb(&pPeb);

        static ULONG Offset_ProcessParam = -1;
        static ULONG Offset_Environment = -1;
        if (Offset_ProcessParam == -1)
        {
            ULONG TypeId;
            ULONG64 NtDllBase;
            if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                               &NtDllBase)))
            {
                if (SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB", &TypeId)))
                {
                    if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                         "ProcessParameters", &Offset_ProcessParam)))
                        Offset_ProcessParam = -1;
                }
                if (SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "_RTL_USER_PROCESS_PARAMETERS", &TypeId)))
                {
                    if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                         "Environment", &Offset_Environment)))
                        Offset_Environment = -1;
                }
            }
        }
        // We can not get it from PDB.  Use the fixed one.
        if (Offset_ProcessParam == -1)
            Offset_ProcessParam = offsetof (PEB, ProcessParameters);

        if (Offset_Environment == -1)
            Offset_Environment = offsetof (_RTL_USER_PROCESS_PARAMETERS, Environment);


        ULONG64 addr = pPeb + Offset_ProcessParam;
        DWORD_PTR value;
        g_ExtData->ReadVirtual(addr, &value, sizeof(PVOID), NULL);
        addr = value + Offset_Environment;
        g_ExtData->ReadVirtual(addr, &value, sizeof(PVOID), NULL);

        static WCHAR buffer[OS_PAGE_SIZE/2];
        static ULONG readBytes = 0;
        if (readBytes == 0) {
            ULONG64 Page;
            readBytes = OS_PAGE_SIZE;
            if ((g_ExtData->ReadDebuggerData( DEBUG_DATA_MmPageSize, &Page, sizeof(Page), NULL)) == S_OK
                && Page > 0)
            {
                ULONG PageSize = (ULONG)(ULONG_PTR)Page;
                if (readBytes > PageSize) {
                    readBytes = PageSize;
                }
            }        
        }
        addr = value;
        while (1) {
            if (IsInterrupt())
                return Status;
            if (FAILED(g_ExtData->ReadVirtual(addr, &buffer, readBytes, NULL)))
                break;
            addr += readBytes;
            WCHAR *pt = buffer;
            WCHAR *end = pt;
            while (pt < &buffer[OS_PAGE_SIZE/2]) {
                end = wcschr (pt, L'\0');
                if (end == NULL) {
                    char format[20];
                    sprintf (format, "%dS", &buffer[OS_PAGE_SIZE/2] - pt);
                    ExtOut (format, pt);
                    break;
                }
                else if (end == pt) {
                    break;
                }
                ExtOut ("%S\n", pt);
                pt = end + 1;
            }
            if (end == pt) {
                break;
            }
        }
    }
    
    HANDLE hProcess = INVALID_HANDLE_VALUE;
    if (fProcInfo & (INFO_TIME | INFO_MEM)) {
        ULONG64 handle;
        g_ExtSystem->GetCurrentProcessHandle(&handle);
        hProcess = (HANDLE)handle;
    }
    
    if (!IsDumpFile() && fProcInfo & INFO_TIME) {
        FILETIME CreationTime;
        FILETIME ExitTime;
        FILETIME KernelTime;
        FILETIME UserTime;

        typedef BOOL (WINAPI *FntGetProcessTimes)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
        static FntGetProcessTimes pFntGetProcessTimes = (FntGetProcessTimes)-1;
        if (pFntGetProcessTimes == (FntGetProcessTimes)-1) {
            HINSTANCE hstat = LoadLibrary ("Kernel32.dll");
            if (hstat != 0)
            {
                pFntGetProcessTimes = (FntGetProcessTimes)GetProcAddress (hstat, "GetProcessTimes");
                FreeLibrary (hstat);
            }
            else
                pFntGetProcessTimes = NULL;
        }

        if (pFntGetProcessTimes && pFntGetProcessTimes (hProcess,&CreationTime,&ExitTime,&KernelTime,&UserTime)) {
            ExtOut ("---------------------------------------\n");
            ExtOut ("Process Times\n");
            static char *Month[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
                        "Oct", "Nov", "Dec"};
            SYSTEMTIME SystemTime;
            FILETIME LocalFileTime;
            if (FileTimeToLocalFileTime (&CreationTime,&LocalFileTime)
                && FileTimeToSystemTime (&LocalFileTime,&SystemTime)) {
                ExtOut ("Process Started at: %4d %s %2d %d:%d:%d.%02d\n",
                        SystemTime.wYear, Month[SystemTime.wMonth-1], SystemTime.wDay,
                        SystemTime.wHour, SystemTime.wMinute,
                        SystemTime.wSecond, SystemTime.wMilliseconds/10);
            }
        
            DWORD nDay = 0;
            DWORD nHour = 0;
            DWORD nMin = 0;
            DWORD nSec = 0;
            DWORD nHundred = 0;
            
            ULONG64 totalTime;
             
            totalTime = KernelTime.dwLowDateTime + (((ULONG64)KernelTime.dwHighDateTime) << 32);
            nDay = (DWORD)(totalTime/(24*3600*10000000ui64));
            totalTime %= 24*3600*10000000ui64;
            nHour = (DWORD)(totalTime/(3600*10000000ui64));
            totalTime %= 3600*10000000ui64;
            nMin = (DWORD)(totalTime/(60*10000000));
            totalTime %= 60*10000000;
            nSec = (DWORD)(totalTime/10000000);
            totalTime %= 10000000;
            nHundred = (DWORD)(totalTime/100000);
            ExtOut ("Kernel CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    nDay, nHour, nMin, nSec, nHundred);
            
            DWORD sDay = nDay;
            DWORD sHour = nHour;
            DWORD sMin = nMin;
            DWORD sSec = nSec;
            DWORD sHundred = nHundred;
            
            totalTime = UserTime.dwLowDateTime + (((ULONG64)UserTime.dwHighDateTime) << 32);
            nDay = (DWORD)(totalTime/(24*3600*10000000ui64));
            totalTime %= 24*3600*10000000ui64;
            nHour = (DWORD)(totalTime/(3600*10000000ui64));
            totalTime %= 3600*10000000ui64;
            nMin = (DWORD)(totalTime/(60*10000000));
            totalTime %= 60*10000000;
            nSec = (DWORD)(totalTime/10000000);
            totalTime %= 10000000;
            nHundred = (DWORD)(totalTime/100000);
            ExtOut ("User   CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    nDay, nHour, nMin, nSec, nHundred);
        
            sDay += nDay;
            sHour += nHour;
            sMin += nMin;
            sSec += nSec;
            sHundred += nHundred;
            if (sHundred >= 100) {
                sSec += sHundred/100;
                sHundred %= 100;
            }
            if (sSec >= 60) {
                sMin += sSec/60;
                sSec %= 60;
            }
            if (sMin >= 60) {
                sHour += sMin/60;
                sMin %= 60;
            }
            if (sHour >= 24) {
                sDay += sHour/24;
                sHour %= 24;
            }
            ExtOut ("Total  CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    sDay, sHour, sMin, sSec, sHundred);
        }
    }

    if (!IsDumpFile() && fProcInfo & INFO_MEM) {
        typedef
        NTSTATUS
        (NTAPI
         *FntNtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

        static FntNtQueryInformationProcess pFntNtQueryInformationProcess = (FntNtQueryInformationProcess)-1;
        if (pFntNtQueryInformationProcess == (FntNtQueryInformationProcess)-1) {
            HINSTANCE hstat = LoadLibrary ("ntdll.dll");
            if (hstat != 0)
            {
                pFntNtQueryInformationProcess = (FntNtQueryInformationProcess)GetProcAddress (hstat, "NtQueryInformationProcess");
                FreeLibrary (hstat);
            }
            else
                pFntNtQueryInformationProcess = NULL;
        }
        VM_COUNTERS memory;
        if (pFntNtQueryInformationProcess &&
            NT_SUCCESS (pFntNtQueryInformationProcess (hProcess,ProcessVmCounters,&memory,sizeof(memory),NULL))) {
            ExtOut ("---------------------------------------\n");
            ExtOut ("Process Memory\n");
            ExtOut ("WorkingSetSize: %8d KB       PeakWorkingSetSize: %8d KB\n",
                    memory.WorkingSetSize/1024, memory.PeakWorkingSetSize/1024);
            ExtOut ("VirtualSize:    %8d KB       PeakVirtualSize:    %8d KB\n", 
                    memory.VirtualSize/1024, memory.PeakVirtualSize/1024);
            ExtOut ("PagefileUsage:  %8d KB       PeakPagefileUsage:  %8d KB\n", 
                    memory.PagefileUsage/1024, memory.PeakPagefileUsage/1024);
        }

        MEMORYSTATUS stat;
        GlobalMemoryStatus (&stat);
        ExtOut ("---------------------------------------\n");
        ExtOut ("%ld percent of memory is in use.\n\n",
                stat.dwMemoryLoad);
        ExtOut ("Memory Availability (Numbers in MB)\n\n");
        ExtOut ("                  %8s     %8s\n", "Total", "Avail");
        ExtOut ("Physical Memory   %8d     %8d\n", stat.dwTotalPhys/1024/1024, stat.dwAvailPhys/1024/1024);
        ExtOut ("Page File         %8d     %8d\n", stat.dwTotalPageFile/1024/1024, stat.dwAvailPageFile/1024/1024);
        ExtOut ("Virtual Memory    %8d     %8d\n", stat.dwTotalVirtual/1024/1024, stat.dwAvailVirtual/1024/1024);
    }

    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of EE data for a      *  
*    metadata token.                                                   *
*                                                                      *
\**********************************************************************/
DECLARE_API (Token2EE)
{
    INIT_API();
#ifdef UNDER_CE
    ExtOut ("not implemented\n");
#else
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    LPSTR mName = buffer;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    if (pch[0] == '\0')
    {
        ExtOut ("Usage: Token2EE module_name mdToken\n");
        return Status;
    }
    pch[0] = '\0';
    pch ++;
    char *endptr;
    ULONG token = strtoul (pch, &endptr, 16);
    pch = endptr;
    while (isspace (pch[0]))
        pch ++;
    if (pch[0] != '\0')
    {
        ExtOut ("Usage: Token2EE module_name mdToken\n");
        return Status;
    }

    int numModule;
    DWORD_PTR *moduleList = NULL;
    ModuleFromName(moduleList, mName, numModule);
    ToDestroy des0 ((void**)&moduleList);
    
    for (int i = 0; i < numModule; i ++)
    {
        if (IsInterrupt())
            break;

        Module vModule;
        DWORD_PTR dwAddr = moduleList[i];
        vModule.Fill (dwAddr);
        ExtOut ("--------------------------------------\n");
        GetInfoFromModule (vModule, token);
    }
#endif
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of EE data for a      *  
*    metadata token.
*                                                                      *
\**********************************************************************/
DECLARE_API (Name2EE)
{
    INIT_API();
#ifdef UNDER_CE
    ExtOut ("not implemented\n");
#else
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    LPSTR mName = buffer;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    if (pch[0] == '\0')
    {
        ExtOut ("Usage: Name2EE module_name item_name\n");
        ExtOut ("Example: Name2EE  mscorlib.dll System.String.ToString");
        return Status;
    }
    pch[0] = '\0';
    pch ++;
    char *name = pch;
    while (isspace (name[0]))
        name ++;
    pch = name;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    pch[0] = '\0';

    int numModule;
    DWORD_PTR *moduleList = NULL;
    ModuleFromName(moduleList, mName, numModule);
    ToDestroy des0 ((void**)&moduleList);
    
    for (int i = 0; i < numModule; i ++)
    {
        if (IsInterrupt())
            break;

        Module vModule;
        DWORD_PTR dwAddr = moduleList[i];
        vModule.Fill (dwAddr);
        ExtOut ("--------------------------------------\n");
        GetInfoFromName(vModule, name);
    }
#endif
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function finds all roots (on stack or in handles) for a      *  
*    given object.
*                                                                      *
\**********************************************************************/
DECLARE_API(GCRoot)
{
    INIT_API();

    DWORD_PTR obj = GetExpression (args);
    if (obj == 0)
        return Status;
    
    FindGCRoot (obj);
    return Status;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function finds the size of an object or all roots.           *  
*                                                                      *
\**********************************************************************/
DECLARE_API(ObjSize)
{
    INIT_API();

    DWORD_PTR obj = GetExpression (args);
    if (obj == 0)
        FindAllRootSize();
    else
        FindObjSize (obj);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function saves a dll to a file.                              *  
*                                                                      *
\**********************************************************************/
DECLARE_API(SaveModule)
{
    INIT_API();
    DWORD_PTR moduleAddr;
    while (isspace(*args)) {
        args ++;
    }
    char *sbuffer = (char *)_alloca(strlen(args)+1);
    strcpy(sbuffer,args);
    char* ptr = sbuffer;
    moduleAddr = strtoul(sbuffer,&ptr,16);
    if (moduleAddr == 0) {
        ExtOut ("Invalid arg");
        return Status;
    }
    DWORD_PTR dllBase = 0;
    ULONG64 base;
    if (g_ExtSymbols->GetModuleByOffset(moduleAddr,0,NULL,&base) == S_OK) {
        dllBase = (DWORD_PTR) base;
    }
    else if (IsModule (moduleAddr)) {
        Module vModule;
        vModule.Fill(moduleAddr);
        dllBase = (DWORD_PTR)vModule.m_ilBase;
        if (dllBase == 0) {
            ExtOut ("Module does not have base address\n");
            return Status;
        }
    }
    else
    {
        ExtOut ("%p is not a Module or base address\n", (ULONG64)dllBase);
        return Status;
    }

    IMAGE_DOS_HEADER DosHeader;
    if (g_ExtData->ReadVirtual(dllBase, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
        return FALSE;
    IMAGE_NT_HEADERS32 Header32;
    if (g_ExtData->ReadVirtual(dllBase + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
        return FALSE;
    DWORD_PTR sectionAddr = dllBase + DosHeader.e_lfanew + offsetof(IMAGE_NT_HEADERS32,OptionalHeader)
            + Header32.FileHeader.SizeOfOptionalHeader;
    IMAGE_SECTION_HEADER section;
    struct MemLocation
    {
        DWORD_PTR VAAddr;
        DWORD_PTR VASize;
        DWORD_PTR FileAddr;
        DWORD_PTR FileSize;
    };
    int nSection = Header32.FileHeader.NumberOfSections;
    MemLocation *memLoc = (MemLocation*)_alloca(nSection*sizeof(MemLocation));
    int indxSec = -1;
    int slot;
    for (int n = 0; n < nSection; n++) {
        if (g_ExtData->ReadVirtual(sectionAddr,&section,sizeof(section),NULL) == S_OK) {
            for (slot = 0; slot <= indxSec; slot ++) {
                if (section.PointerToRawData < memLoc[slot].FileAddr) {
                    break;
                }
            }
            for (int k = indxSec; k >= slot; k --) {
                memcpy(&memLoc[k+1], &memLoc[k], sizeof(MemLocation));
            }
            memLoc[slot].VAAddr = section.VirtualAddress;
            memLoc[slot].VASize = section.Misc.VirtualSize;
            memLoc[slot].FileAddr = section.PointerToRawData;
            memLoc[slot].FileSize = section.SizeOfRawData;
            indxSec ++;
        }
        else
        {
            ExtOut("Fail to read PE section info\n");
            return Status;
        }
        sectionAddr += sizeof(section);
    }

    while (isspace(*ptr)) {
        ptr ++;
    }
    if (ptr[0] == '\0') {
        ExtOut ("File not specified\n");
        return Status;
    }
    PCSTR file = ptr;
    ptr += strlen(ptr)-1;
    if (isspace(*ptr)) {
        *ptr = '\0';
        ptr --;
    }
    HANDLE hFile = CreateFileA(file,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        ExtOut ("Fail to create file %s\n", file);
        return Status;
    }
    size_t pageSize = OSPageSize();
    char *buffer = (char *)_alloca(pageSize);
    ULONG nRead;
    ULONG nWrite;
    
    // NT PE Headers
    ULONG64 dwAddr = dllBase;
    ULONG64 dwEnd = dllBase + Header32.OptionalHeader.SizeOfHeaders;
    while (dwAddr < dwEnd) {
        nRead = pageSize;
        if (dwEnd - dwAddr < nRead) {
            nRead = (ULONG)(dwEnd - dwAddr);
        }
        if (g_ExtData->ReadVirtual(dwAddr,buffer,nRead,&nRead) == S_OK) {
            WriteFile(hFile,buffer,nRead,&nWrite,NULL);
        }
        else
        {
            ExtOut ("Fail to read memory\n");
            goto end;
        }
        dwAddr += nRead;
    }

    for (slot = 0; slot <= indxSec; slot ++) {
        dwAddr = dllBase + memLoc[slot].VAAddr;
        dwEnd = memLoc[slot].FileSize + dwAddr - 1;
        while (dwAddr <= dwEnd) {
            nRead = pageSize;
            if (dwEnd - dwAddr + 1 < pageSize) {
                nRead = (ULONG)(dwEnd - dwAddr + 1);
            }
            if (g_ExtData->ReadVirtual(dwAddr,buffer,nRead,&nRead) == S_OK) {
                WriteFile(hFile,buffer,nRead,&nWrite,NULL);
            }
            else {
                ExtOut ("Fail to read memory\n");
                goto end;
            }
            dwAddr += pageSize;
        }
    }
end:
    CloseHandle (hFile);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the commands available in strike and the   *  
*    arguments passed into each.
*                                                                      *
\**********************************************************************/
extern "C" HRESULT CALLBACK
Help(PDEBUG_CLIENT Client, PCSTR Args)
{
    INIT_API();

    ExtOut( "Strike : Help\n" );
    ExtOut( "IP2MD <addr>         | Find MethodDesc from IP\n" );
    ExtOut( "DumpMD <addr>        | Dump MethodDesc info\n" );
    ExtOut( "DumpMT [-MD] <addr>  | Dump MethodTable info\n" );
    ExtOut( "DumpClass <addr>     | Dump EEClass info\n" );
    ExtOut( "DumpModule <addr>    | Dump EE Module info\n" );
    ExtOut( "DumpObj <addr>       | Dump an object on GC heap\n" );
    ExtOut( "u [<MD>] [IP]        | Unassembly a managed code\n" );
    ExtOut( "Threads              | List managed threads\n" );
    ExtOut( "ThreadPool           | Display CLR threadpool state\n" );
    ExtOut( "COMState             | List COM state for each thread\n");
    ExtOut( "DumpStack [-EE] [-smart] [top stack [bottom stack]\n" );
    ExtOut( "DumpStackObjects [top stack [bottom stack]\n" );
    ExtOut( "EEStack [-short] [-EE] | List all stacks EE knows\n" );
    ExtOut( "SyncBlk [-all|#]     | List syncblock\n" );
    ExtOut( "FinalizeQueue [-detail]     | Work queue for finalize thread\n" );
    ExtOut( "EEHeap [-gc] [-win32] [-loader] | List GC/Loader heap info\n" );
    ExtOut( "DumpHeap [-stat] [-min 100] [-max 2000] [-mt 0x3000000] [-fix] [start [end]] | Dump GC heap contents\n" );
    ExtOut( "GCRoot <addr>        | Find roots on stack/handle for object\n");
    ExtOut( "ObjSize [<addr>]     | Find number of bytes that a root or all roots keep alive on GC heap.\n");
    ExtOut( "DumpDomain [<addr>]  | List assemblies and modules in a domain\n" );
    ExtOut( "GCInfo [<MD>] [IP]   | Dump GC encoding info for a managed method\n" );
    ExtOut( "RWLock [-all] <addr> | List info for a Read/Write lock\n");
    ExtOut( "Token2EE             | Find memory address of EE data for metadata token\n");
    ExtOut( "Name2EE              | Find memory address of EE data given a class/method name\n");
    ExtOut( "DumpEEHash [-length 2] <addr> | Dump content of EEHashTable\n");
    ExtOut( "EEVersion            | List mscoree.dll version\n");
    ExtOut( "EEDebug 2204         | Setup symbol and source path\n");
    ExtOut( "EEDLLPath [-std 2204 x86fstchk] [-reset] [path] | Setup path for managed Dll to debug dump file\n");
    ExtOut( "ProcInfo [-env] [-time] [-mem] | Display the process info\n");
    ExtOut( "SaveModule moduleAddr|base filename  | Save a module to disk\n");
    ExtOut( "DumpLog [<fileName>] | prints the stress log to a file (def = StressLog.txt)\n");
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\gcroot.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"

#define _ASSERTE(a) {;}
#include "..\..\vm\gcdesc.h"

struct OBJSTATE
{
    enum ROOTSTATE {IsRoot, NotRoot, InProcess, Unknown};
};

static const int BITSIZE = sizeof(size_t)*8;
static const int BITWORD = sizeof(size_t);

// 1 bit corresponds to 4 byte (32bit platform).
// We use 2 bits to mark the state of an object: IsRoot/NotRoot/InProcess/Unknown
// since each object has at least 12 bytes.
class SegmentInfo
{
    size_t m_start;     // begin of a segment
    size_t m_end;       // end of a segment
    size_t*  m_bitMap;  // mask

public:
    SegmentInfo *m_next;    // for next segment on the gc heap

    SegmentInfo (size_t start, size_t end)
        : m_start(start), m_end(end)
    {
        m_next = NULL;
        size_t nelem = (end-start)/BITSIZE/BITWORD;
        if ((end-start)%(BITSIZE*sizeof(size_t))) {
            nelem ++;
        }
        m_bitMap = new size_t[nelem];
        memset (m_bitMap, 0, nelem*sizeof(size_t));
    }
    ~SegmentInfo ()
    {
        if (m_bitMap) {
            delete[] m_bitMap;
            m_bitMap = NULL;
        }
        if (m_next) {
            delete m_next;
            m_next = NULL;
        }
    }

    BOOL HasObject(size_t obj)
    {
        return obj >= m_start && obj <= m_end;
    }

    OBJSTATE::ROOTSTATE GetObjectState(size_t obj)
    {
        //assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);

        if (m_bitMap[knownPos] & knownMask) {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::IsRoot;
            }
            else {
                return OBJSTATE::NotRoot;
            }
        }
        else
        {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::InProcess;
            }
            else {
                return OBJSTATE::Unknown;
            }
        }
    }

    OBJSTATE::ROOTSTATE AddObject(size_t obj)
    {
        //assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        if (m_bitMap[knownPos] & knownMask) {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::IsRoot;
            }
            else {
                return OBJSTATE::NotRoot;
            }
        }
        else
        {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::InProcess;
            }
            else {
                m_bitMap[statePos] |= stateMask;
                return OBJSTATE::Unknown;
            }
        }
    }
    
    void MarkObject(size_t obj, BOOL fIsRoot)
    {
        // assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        m_bitMap[knownPos] |= knownMask;
        if (fIsRoot) {
            m_bitMap[statePos] |= stateMask;
        }
        else {
            m_bitMap[statePos] &= ~stateMask;
        }
    }

    void ResetObject(size_t obj)
    {
        // assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        m_bitMap[knownPos] &= ~knownMask;
        m_bitMap[statePos] &= ~stateMask;
    }

    void Reset()
    {
        size_t nelem = (m_end-m_start)/BITSIZE/BITWORD;
        if ((m_end-m_start)%(BITSIZE*sizeof(size_t))) {
            nelem ++;
        }
        memset (m_bitMap, 0, nelem*sizeof(size_t));
    }

    BOOL MatchRange (size_t start, size_t end)
    {
        return m_start == start && m_end == end;
    }
};

// For large object heap
class LargeHeapInfo
{
    struct LargeObj
    {
        size_t obj;
        OBJSTATE::ROOTSTATE state;
    };
    LargeObj largeObj[20];
    size_t index;
    LargeHeapInfo *next;

public:
    LargeHeapInfo()
    {
        next = NULL;
        index = 0;
        for (size_t i = 0; i < 20; i ++) {
            largeObj[i].obj = 0;
            largeObj[i].state = OBJSTATE::Unknown;
        }
    }
    ~LargeHeapInfo()
    {
        if (next) {
            delete next;
            next = NULL;
        }
    }

    void AddToLargeHeap (size_t obj, OBJSTATE::ROOTSTATE state)
    {
        LargeHeapInfo *walk = this;
        while (walk->next) {
            if (IsInterrupt())
                return;
            walk = walk->next;
        }
        if (walk->index == 20) {
            walk->next = new LargeHeapInfo;
            walk = walk->next;
        }
        walk->largeObj[walk->index].obj = obj;
        walk->largeObj[walk->index].state = state;
        walk->index ++;
    }

    OBJSTATE::ROOTSTATE AddObject (size_t obj)
    {
        LargeObj* slot = SlotForObject (obj);
        if (slot == NULL) {
            // It is not a large object.
            // Let's skip it.
            return OBJSTATE::InProcess;
        }

        if (slot->state == OBJSTATE::Unknown) {
            slot->state = OBJSTATE::InProcess;
            return OBJSTATE::Unknown;
        }
        else
            return slot->state;
    }

    OBJSTATE::ROOTSTATE GetObjectState(size_t obj)
    {
        LargeObj* slot = SlotForObject (obj);
        if (slot == NULL) {
            // It is not a large object.
            // Let's skip it.
            return OBJSTATE::InProcess;
        }
        return slot->state;
    }

    void MarkObject(size_t obj, BOOL fIsRoot)
    {
        LargeObj* slot = SlotForObject (obj);
        if (slot == NULL) {
            // It is not a large object.
            // Let's skip it.
            return;
        }
        if (fIsRoot) {
            slot->state = OBJSTATE::IsRoot;
        }
        else
            slot->state = OBJSTATE::NotRoot;
    }

    void ResetObject(size_t obj)
    {
        LargeObj* slot = SlotForObject (obj);
        if (slot == NULL) {
            // It is not a large object.
            // Let's skip it.
            return;
        }
        slot->state = OBJSTATE::Unknown;
    }

    void Reset()
    {
        size_t i = 0;
        LargeHeapInfo *walk = this;
        while (walk) {
            if (IsInterrupt())
                break;
            walk->largeObj[i].state = OBJSTATE::Unknown;
            walk = walk->next;
        }
    }

    BOOL HasObject(size_t obj)
    {
        return SlotForObject (obj) != NULL;
    }

private:
    LargeObj* SlotForObject (size_t obj)
    {
        size_t i;
        LargeHeapInfo *walk = this;
        while (walk) {
            if (IsInterrupt())
                break;
            for (i = 0; i < walk->index; i ++) {
                if (walk->largeObj[i].obj == obj) {
                    return &walk->largeObj[i];
                }
            }
            walk = walk->next;
        }
        return NULL;
    }
};


class GCRootInfo
{
public:

    GCRootInfo()
    {
        pSegmentInfo = NULL;
        pLarge = NULL;
    }
    ~GCRootInfo()
    {
        if (pSegmentInfo) {
            delete pSegmentInfo;
            pSegmentInfo = NULL;
        }
        if (pLarge) {
            delete pLarge;
            pLarge = NULL;
        }
    }
    void AddGCSegment(size_t start, size_t end)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->MatchRange(start, end)) {
                return;
            }
            walk = walk->m_next;
        }
        SegmentInfo *pSegInfo = new SegmentInfo (start, end);
        pSegInfo->m_next = pSegmentInfo;
        pSegmentInfo = pSegInfo;
    }

    void AddToLargeHeap(size_t obj, OBJSTATE::ROOTSTATE state)
    {
        if (pLarge == NULL) {
            pLarge = new LargeHeapInfo;
        }
        pLarge->AddToLargeHeap(obj, state);
    }

    OBJSTATE::ROOTSTATE GetObjectState (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return OBJSTATE::InProcess;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            return walk->GetObjectState(obj);
        }
        else if (pLarge) {
            return pLarge->GetObjectState(obj);
        } else {
            return OBJSTATE::InProcess;
        }
    }
    
    OBJSTATE::ROOTSTATE AddObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return OBJSTATE::InProcess;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            return walk->AddObject(obj);
        } else if (pLarge) {
            return pLarge->AddObject(obj);
        } else {
            return OBJSTATE::InProcess;
        }
    }

    void MarkObject (size_t obj, BOOL fIsRoot)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            walk->MarkObject(obj, fIsRoot);
        } else if (pLarge) {
            pLarge->MarkObject(obj,fIsRoot);
        }
    }

    BOOL HasObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return FALSE;
            if (walk->HasObject(obj)) {
                return TRUE;
            }
            walk = walk->m_next;
        }

        if (pLarge) {
            return pLarge->HasObject(obj);
        }
        return FALSE;
    }

    void ResetObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            walk->ResetObject(obj);
        }
        else if (pLarge) {
            pLarge->ResetObject(obj);
        }
    }

    void Reset ()
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            walk->Reset();
            walk = walk->m_next;
        }
        if (pLarge) {
            pLarge->Reset();
        }
    }

    void Release ()
    {
        if (pSegmentInfo) {
            delete pSegmentInfo;
            pSegmentInfo = NULL;
        }
        if (pLarge) {
            delete pLarge;
            pLarge = NULL;
        }
    }

private:
    SegmentInfo *pSegmentInfo;
    LargeHeapInfo *pLarge;
};

GCRootInfo gcRootInfo;

class Entry
{
    size_t m_obj;
    size_t m_root;
    DWORD index;
    DWORD length;
    OBJSTATE::ROOTSTATE state;
    size_t *member;
public:
    Entry()
    {
        m_obj = 0;
        m_root = 0;
        index = 0;
        length = 0;
        state = OBJSTATE::Unknown;
        member = NULL;
    }
    ~Entry()
    {
        if (member) {
            delete [] member;
        }
        member = NULL;
    }
    
    void SetObject (size_t obj)
    {
        m_obj = obj;
    }

    size_t GetObject ()
    {
        return m_obj;
    }

    DWORD NumberOfMember ()
    {
        return index;
    }

    size_t PopMember ()
    {
        if (index > 0) {
            index --;
            return member[index];
        }
        else
            return 0;
    }

    size_t LastMember ()
    {
        if (index == 0) {
            return 0;
        }
        else
            return member[index-1];
    }

    void PushMember (size_t obj)
    {
        if (member == NULL) {
            length = 10;
            member = new size_t[length];
        }
        else if (index == length) {
            length += 10;
            size_t *tmp = new size_t[length];
            memcpy (tmp, member, index*sizeof(size_t));
            delete [] member;
            member = tmp;
        }
        member[index++] = obj;
    }

    void Reset()
    {
        if (member)
        {
            for (size_t i = 0; i < index; i ++) {
                gcRootInfo.ResetObject(member[i]);
            }
            delete [] member;
        }
        member = NULL;
        m_obj = 0;
        index = 0;
        length = 0;
        state = OBJSTATE::Unknown;
    }
    void SetState (BOOL bIsRoot)
    {
        if (bIsRoot) {
            state = OBJSTATE::IsRoot;
        }
        else
            state = OBJSTATE::NotRoot;
    }

    OBJSTATE::ROOTSTATE GetState ()
    {
        return state;
    }

    void SetRoot (size_t root)
    {
        m_root = root;
    }

    size_t GetRoot ()
    {
        return m_root;
    }
};

#define plug_skew           sizeof(DWORD)   // syncblock size. 


void GetListOfRefs (Entry *pEntry)
{
    DWORD_PTR dwAddr;
    size_t obj = pEntry->GetObject();
    OBJSTATE::ROOTSTATE state = gcRootInfo.GetObjectState(obj);
    if (state == OBJSTATE::IsRoot) {
        pEntry->SetState(TRUE);
        return;
    }
    else if (state == OBJSTATE::NotRoot) {
        pEntry->SetState(FALSE);
        return;
    }
    move (dwAddr, obj);

    if (dwAddr == MTForString()) {
        return;
    }

    static int MT_wFlagsOffset = 0x7fffffff;
    if (MT_wFlagsOffset == 0x7fffffff)
    {
        MT_wFlagsOffset = MethodTable::GetFieldOffset("m_wFlags");
    }
    
    DWORD wFlags;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+MT_wFlagsOffset), &wFlags, sizeof(wFlags), NULL))) {
        return;
    }
    if ((wFlags & MethodTable::enum_flag_ContainsPointers) == 0) {
        return;
    }

    INT_PTR nEntries;
    move (nEntries, dwAddr-sizeof(PVOID));
    if (nEntries<0) {
        nEntries = -nEntries;
    }

    DWORD nSlots = 1+nEntries*sizeof(CGCDescSeries)/sizeof(DWORD_PTR);
    DWORD_PTR *buffer = (DWORD_PTR*) malloc(sizeof(DWORD_PTR)*nSlots);
    ToDestroy des0((void**)&buffer);

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr - nSlots*sizeof(DWORD_PTR)),
                                      buffer, nSlots*sizeof(DWORD_PTR), NULL))) {
        return;
    }
    CGCDesc *map = (CGCDesc *)(buffer+nSlots);
    size_t size = ObjectSize (obj);
    
    CGCDescSeries* cur = map->GetHighestSeries();                           
    CGCDescSeries* last = map->GetLowestSeries();                           
                                                                            
    const size_t bufferSize = 512;
    size_t objBuffer[bufferSize/sizeof(size_t)];
    size_t dwBeginAddr = obj;
    size_t bytesInBuffer = bufferSize;
    if (size < bytesInBuffer) {
        bytesInBuffer = size;
    }
    if (FAILED(g_ExtData->ReadVirtual(dwBeginAddr, objBuffer, bytesInBuffer,NULL))) {
        return;
    }

    if (cur >= last)                                                        
    {                                                                       
        do                                                                  
        {                                                                   
            BYTE** parm = (BYTE**)((obj) + cur->GetSeriesOffset());           
            BYTE** ppstop =                                                 
                (BYTE**)((BYTE*)parm + cur->GetSeriesSize() + (size));      
            while (parm < ppstop)                                           
            {                                                               
                if (IsInterrupt())
                    return;
                {
                     size_t dwAddr;
                     // Do we run out of cache?
                     if ((size_t)parm >= dwBeginAddr+bytesInBuffer) {
                         dwBeginAddr += bytesInBuffer;
                         if (dwBeginAddr >= obj + size) {
                             return;
                         }
                         bytesInBuffer = bufferSize;
                         if (obj+size-dwBeginAddr < bytesInBuffer) {
                             bytesInBuffer = obj+size-dwBeginAddr;
                         }
                         if (FAILED(g_ExtData->ReadVirtual(dwBeginAddr, objBuffer, bytesInBuffer, NULL))) {
                             return;
                         }
                     }
                     dwAddr = objBuffer[((size_t)parm-dwBeginAddr)/sizeof(size_t)];
                     if (dwAddr && IsObject(dwAddr)) {
                         OBJSTATE::ROOTSTATE status = gcRootInfo.AddObject (dwAddr);
                         if (status == OBJSTATE::Unknown) {
                             // add to list
                             pEntry->PushMember(dwAddr);
                         }
                         else if (status == OBJSTATE::IsRoot) {
                             pEntry->SetRoot (dwAddr);
                             gcRootInfo.MarkObject(pEntry->GetObject(), TRUE);
                             pEntry->SetState(TRUE);
                             return;
                         }
                     }
                }
                parm++;                                                     
            }                                                               
            cur--;                                                          
            if (IsInterrupt())
                return;
                                                                            
        } while (cur >= last);                                              
    }                                                                       
    else                                                                    
    {                                                                       
        int cnt = map->GetNumSeries();                                      
        BYTE** parm = (BYTE**)((obj) + cur->startoffset);                     
        while ((BYTE*)parm < (BYTE*)((obj)+(size)-plug_skew))                 
        {                                                                   
            if (IsInterrupt())
                return;
            for (int __i = 0; __i > cnt; __i--)                             
            {                                                               
                if (IsInterrupt())
                    return;
                unsigned skip =  cur->val_serie[__i].skip;                  
                unsigned nptrs = cur->val_serie[__i].nptrs;                 
                BYTE** ppstop = parm + nptrs;                               
                do                                                          
                {                                                           
                    {
                         size_t dwAddr;
                         move (dwAddr, (size_t)parm);
                         if (dwAddr && IsObject(dwAddr)) {
                             OBJSTATE::ROOTSTATE status = gcRootInfo.AddObject (dwAddr);
                             if (status == OBJSTATE::Unknown) {
                                 // add to list
                                 pEntry->PushMember(dwAddr);
                             }
                             else if (status == OBJSTATE::IsRoot) {
                                 gcRootInfo.MarkObject(pEntry->GetObject(), TRUE);
                                 pEntry->SetState(TRUE);
                                 return;
                             }
                         }
                    }
                   parm++;                                                  
                   if (IsInterrupt())
                       return;
                } while (parm < ppstop);                                    
                parm = (BYTE**)((BYTE*)parm + skip);                        
            }                                                               
        }                                                                   
    }                                                                       

    if (pEntry->NumberOfMember() == 0) {
        pEntry->SetState(FALSE);
    }
}


void ProcessSmallHeap(gc_heap &heap)
{
    DWORD_PTR dwAddrSeg = (DWORD_PTR)heap.generation_table[heap.g_max_generation].start_segment;

    int n = 0;
    DWORD_PTR dwAddr;
    heap_segment segment;
    while (dwAddrSeg != (DWORD_PTR)heap.generation_table[0].start_segment)
    {
        if (IsInterrupt())
            return;
        dwAddr = dwAddrSeg;
        segment.Fill (dwAddr);
        gcRootInfo.AddGCSegment((size_t)segment.mem, (size_t)segment.allocated);
        dwAddrSeg = (DWORD_PTR)segment.next;
        n ++;
        if (n > 20)
            break;
    }

    dwAddr = (DWORD_PTR)heap.generation_table[0].start_segment;
    segment.Fill (dwAddr);
    gcRootInfo.AddGCSegment((size_t)segment.mem, (size_t)heap.alloc_allocated);
}

void ProcessLargeHeap(size_t obj)
{
    static DWORD_PTR dwLargeNPAddr = 0;
    if (dwLargeNPAddr == 0)
        dwLargeNPAddr =
            GetValueFromExpression("mscoree!gc_heap__large_np_objects");
    DWORD_PTR dwLargeAddr;
    move (dwLargeAddr, dwLargeNPAddr);
    large_object_block large_object;
    while (dwLargeAddr)
    {
        if (IsInterrupt())
            return;
        large_object.Fill(dwLargeAddr);

        gcRootInfo.AddToLargeHeap(dwLargeAddr,
                              (dwLargeAddr == obj)?OBJSTATE::IsRoot
                                  :((obj == 0)?OBJSTATE::Unknown:OBJSTATE::NotRoot));
        dwLargeAddr = (DWORD_PTR)large_object.next;
    }
    
    static DWORD_PTR dwLargePAddr = 0;
    if (dwLargePAddr == 0)
        dwLargePAddr =
            GetValueFromExpression("mscoree!gc_heap__large_p_objects");
    move (dwLargeAddr, dwLargePAddr);
    while (dwLargeAddr)
    {
        if (IsInterrupt())
            return;
        large_object.Fill(dwLargeAddr);

        gcRootInfo.AddToLargeHeap(dwLargeAddr,
                              (dwLargeAddr == obj)?OBJSTATE::IsRoot
                                  :((obj == 0)?OBJSTATE::Unknown:OBJSTATE::Unknown));
        dwLargeAddr = (DWORD_PTR)large_object.next;
    }
    
}

void InitGCRoot (size_t obj)
{
    // GC Heap
    DWORD_PTR dwNHeaps = 1;
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetValueFromExpression("MSCOREE!gc_heap__n_heaps");
        move (dwNHeaps, dwAddrNHeaps);
    }

    gc_heap heap = {0};
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return;
        ProcessSmallHeap (heap);
    }
    else
    {
        DWORD_PTR dwAddrGHeaps =
            GetValueFromExpression("MSCOREE!gc_heap__g_heaps");
        move (dwAddrGHeaps, dwAddrGHeaps);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            move (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            ProcessSmallHeap (heap);
        }
    }
    
    ProcessLargeHeap (obj);
    gcRootInfo.MarkObject(obj, TRUE);
}

class WorkQueue
{
    struct Node{
        Entry entry[8];
        size_t index;
        Node *next;
        Node ()
        {
            next = 0;
            index = 0;
        }
        ~Node ()
        {
        }
        void Release ()
        {
            Node *walk = next;
            if (walk) {
                Node *tmp = walk;
                walk = walk->next;
                delete tmp;
            }
            next = NULL;
            index = 0;
        }
    };
    Node head;
    Entry *top;

public:
    WorkQueue ()
    {
        top = NULL;
    }

    ~WorkQueue ()
    {
        Release ();
    }

    void Release ()
    {
        head.Release();
        top = NULL;
    }

    Entry* Top()
    {
        return top;
    }

    Entry* GetEntry ()
    {
        Node *walk = &head;
        while (walk->index == 8 && walk->next) {
            if (IsInterrupt())
                return NULL;
            walk = walk->next;
        }
        if (walk->index == 8) {
            walk->next = new Node;
            walk = walk->next;
        }
        Entry *pEntry = &walk->entry[walk->index];
        pEntry->Reset();
        top = pEntry;
        walk->index ++;
        return pEntry;
    }

    Entry* PopEntry ()
    {
        top->Reset();
        if (head.index == 1) {
            head.index --;
            top = NULL;
            return top;
        }
        top = NULL;
        Node *walk = &head;
        while (walk->index == 8 && walk->next) {
            if (IsInterrupt())
                return NULL;
            if (walk->next->index == 0) {
                break;
            }
            else if (walk->next->index == 1) {
                top = &walk->entry[7];
                walk->next->index = 0;
                return top;
            }
            walk = walk->next;
        }

        walk->index --;
        top = &walk->entry[walk->index-1];
        return top;
    }

    void Print ()
    {
        Node *walk =&head;
        ExtOut ("Root:");
        size_t lastObj=0;

        while (walk && walk->index > 0) {
            if (IsInterrupt())
                return;
            size_t iEnd = walk->index;
            if (walk->next == NULL || walk->index < 8) {
                lastObj = walk->entry[iEnd-1].GetRoot();
                if (lastObj == 0) {
                    lastObj = walk->entry[iEnd-1].GetObject();
                    iEnd --;
                }
            }
            for (size_t i = 0; i < iEnd; i ++) {
                if (IsInterrupt())
                    break;
                size_t obj = walk->entry[i].GetObject();
                NameForObject (obj, g_mdName);
                ExtOut ("%p(%S)->", (ULONG64)obj, g_mdName);
            }
            walk = walk->next;
        }
        NameForObject (lastObj, g_mdName);
        ExtOut ("%p(%S)\n", (ULONG64)lastObj, g_mdName);
    }
};

WorkQueue wq;

void TraceObjectGraph (size_t obj, const char* name=NULL)
{
    if (!IsObject (obj)) {
        return;
    }

    Entry *pEntry = wq.GetEntry();
    pEntry->SetObject(obj);
    GetListOfRefs (pEntry);
    switch (pEntry->GetState()) {
    case OBJSTATE::IsRoot:
        if (name) {
            ExtOut ("%s:", name);
        }
        wq.Print();
        wq.PopEntry();
        return;
    case OBJSTATE::NotRoot:
        wq.PopEntry();
        return;
    }

    while (1) {
        if (IsInterrupt())
            return;
        size_t nextobj = pEntry->PopMember();
        if (nextobj == 0) {
            gcRootInfo.MarkObject(pEntry->GetObject(),FALSE);
            pEntry = wq.PopEntry();
            if (pEntry == NULL) {
                return;
            }
            continue;
        }
        pEntry = wq.GetEntry();
        pEntry->SetObject(nextobj);
        GetListOfRefs (pEntry);
        switch (pEntry->GetState()) {
        case OBJSTATE::IsRoot:
            if (name) {
                ExtOut ("%s:", name);
            }
            wq.Print();
            while (wq.PopEntry())
            {
                if (IsInterrupt())
                    return;
            }
            return;
        case OBJSTATE::NotRoot:
            gcRootInfo.MarkObject(pEntry->GetObject(), FALSE);
            pEntry = wq.PopEntry();
            if (pEntry == NULL) {
                break;
            }
        }
    }
}

typedef void (*GCInfoCallback)(size_t obj, const char* name);

void FindGCRootInReg (const char* regName, GCInfoCallback callback)
{
    ULONG IREG;
    DEBUG_VALUE value;
    DWORD_PTR reg;
    
    g_ExtRegisters->GetIndexByName(regName, &IREG);
    g_ExtRegisters->GetValue(IREG, &value);
    reg = value.I32;
    if (IsObject(reg)) {
        callback (reg, regName);
    }
}

void FindGCRootOnOneStack (size_t StackTop, size_t StackBottom, GCInfoCallback callback)
{
    // Registers:ECX, EDX, ESI, EBX, EBP
    FindGCRootInReg ("eax", callback);
    FindGCRootInReg ("ebx", callback);
    FindGCRootInReg ("ecx", callback);
    FindGCRootInReg ("edx", callback);
    FindGCRootInReg ("esi", callback);
    FindGCRootInReg ("edi", callback);
    FindGCRootInReg ("ebp", callback);

    char name[20] = "ESP:";
    DWORD_PTR ptr = StackTop & ~3;  // make certain dword aligned
    for (;ptr < StackBottom; ptr += sizeof(DWORD_PTR))
    {
        if (IsInterrupt())
            return;
        DWORD_PTR objAddr;
        move (objAddr, ptr);
        DWORD_PTR mtAddr;
        if (SUCCEEDED(g_ExtData->ReadVirtual((ULONG64)objAddr, &mtAddr, sizeof(mtAddr), NULL))) {
            if (IsMethodTable(mtAddr)) {
                _itoa (ptr, &name[4], 16);
                callback (objAddr, name);
            }
        }
    }
}

void FindGCRootOnStacks (GCInfoCallback callback)
{
    ULONG CurrentThreadId;
    g_ExtSystem->GetCurrentThreadId (&CurrentThreadId);
    
    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    int i;
/*
    static ULONG OffsetToStackBase = -1;
    if (OffsetToStackBase == -1)
    {
        ULONG64 modBase;
        g_ExtSymbols->GetSymbolModule ("TEB", &modBase);
        ULONG TypeId;
        g_ExtSymbols->GetTypeId (modBase, "TEB", &TypeId);
        g_ExtSymbols->GetFieldOffset (modBase, TypeId, "StackBase",
                                      &OffsetToStackBase);
    }
*/
    ULONG ProcessId;
    g_ExtSystem->GetCurrentProcessSystemId (&ProcessId);

    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        ULONG id=0;
        if (FAILED(g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id)))
        {
            continue;
        }
        
        g_ExtSystem->SetCurrentThreadId (id);
        
        ULONG64 StackOffset;
        g_ExtRegisters->GetStackOffset (&StackOffset);

        ULONG64 Offset;
        g_ExtSystem->GetCurrentThreadTeb (&Offset);
#if 0
        size_t stackBase;
        g_ExtData->ReadVirtual (Offset+OffsetToStackBase, &stackBase, sizeof(stackBase), NULL);
#endif
        
        NT_TIB teb;
        if (SafeReadMemory ((ULONG_PTR)Offset, &teb, sizeof (NT_TIB), NULL))
        {
            ExtOut ("Scan Thread %d (%x)\n", id, vThread.m_ThreadId);
            FindGCRootOnOneStack ((size_t)StackOffset, (size_t)teb.StackBase, callback);
        }
    }

    g_ExtSystem->SetCurrentThreadId (CurrentThreadId);
}

/*
 * HANDLES
 *
 * The default type of handle is a strong handle.
 *
 */
#define HNDTYPE_DEFAULT                         HNDTYPE_STRONG


/*
 * WEAK HANDLES
 *
 * Weak handles are handles that track an object as long as it is alive,
 * but do not keep the object alive if there are no strong references to it.
 *
 * The default type of weak handle is 'long-lived' weak handle.
 *
 */
#define HNDTYPE_WEAK_DEFAULT                    HNDTYPE_WEAK_LONG


/*
 * SHORT-LIVED WEAK HANDLES
 *
 * Short-lived weak handles are weak handles that track an object until the
 * first time it is detected to be unreachable.  At this point, the handle is
 * severed, even if the object will be visible from a pending finalization
 * graph.  This further implies that short weak handles do not track
 * across object resurrections.
 *
 */
#define HNDTYPE_WEAK_SHORT                      (0)


/*
 * LONG-LIVED WEAK HANDLES
 *
 * Long-lived weak handles are weak handles that track an object until the
 * object is actually reclaimed.  Unlike short weak handles, long weak handles
 * continue to track their referents through finalization and across any
 * resurrections that may occur.
 *
 */
#define HNDTYPE_WEAK_LONG                       (1)


/*
 * STRONG HANDLES
 *
 * Strong handles are handles which function like a normal object reference.
 * The existence of a strong handle for an object will cause the object to
 * be promoted (remain alive) through a garbage collection cycle.
 *
 */
#define HNDTYPE_STRONG                          (2)


/*
 * PINNED HANDLES
 *
 * Pinned handles are strong handles which have the added property that they
 * prevent an object from moving during a garbage collection cycle.  This is
 * useful when passing a pointer to object innards out of the runtime while GC
 * may be enabled.
 *
 * NOTE:  PINNING AN OBJECT IS EXPENSIVE AS IT PREVENTS THE GC FROM ACHIEVING
 *        OPTIMAL PACKING OF OBJECTS DURING EPHEMERAL COLLECTIONS.  THIS TYPE
 *        OF HANDLE SHOULD BE USED SPARINGLY!
 */
#define HNDTYPE_PINNED                          (3)


/*
 * VARIABLE HANDLES
 *
 * Variable handles are handles whose type can be changed dynamically.  They
 * are larger than other types of handles, and are scanned a little more often,
 * but are useful when the handle owner needs an efficient way to change the
 * strength of a handle on the fly.
 * 
 */
#define HNDTYPE_VARIABLE                        (4)


/*
 * REFCOUNTED HANDLES
 *
 * Refcounted handles are handles that behave as strong handles while the
 * refcount on them is greater than 0 and behave as weak handles otherwise.
 *
 * N.B. These are currently NOT general purpose.
 *      The implementation is tied to COM Interop.
 *
 */
#define HNDTYPE_REFCOUNTED                      (5)


void FindGCRootOnOneHandleTable(DWORD_PTR tableAddr, GCInfoCallback callback)
{
    ExtOut ("Scan HandleTable %x\n", tableAddr);

    HandleTable table;
    table.Fill (tableAddr);

    TableSegment segment;
    DWORD_PTR dwAddr = (DWORD_PTR)table.pSegmentList;
    static char nameS[30] = "HANDLE(Strong):";
    static char nameP[30] = "HANDLE(Pinned):";
    static char nameR[30] = "HANDLE(RefCnt):";
    static char nameU[30] = "HANDLE(Unknwn):";

    while (dwAddr) {
        if (IsInterrupt())
            return;
        segment.Fill(dwAddr);
        if (!CallStatus) {
            break;
        }

        for (BYTE i = 0; i < segment.bEmptyLine; i ++) {
            if (IsInterrupt())
                return;
            if (segment.rgBlockType[i] == HNDTYPE_PINNED
                || segment.rgBlockType[i] == HNDTYPE_REFCOUNTED
                || segment.rgBlockType[i] == HNDTYPE_STRONG) {
                int start=i*HANDLE_HANDLES_PER_BLOCK;
                for (int j = 0; j < HANDLE_HANDLES_PER_BLOCK; j ++)
                {
                    if (segment.rgValue[start+j]) {
                        char *name;
                        if (segment.rgBlockType[i] == HNDTYPE_PINNED) {
                            name = nameP;
                        }
                        else if (segment.rgBlockType[i] == HNDTYPE_REFCOUNTED) {
                            name = nameR;
                        }
                        else if (segment.rgBlockType[i] == HNDTYPE_STRONG) {
                            name = nameS;
                        }
                        else
                            name = nameU;
                        _itoa (segment.firstHandle+(start+j)*HANDLE_SIZE, &name[15], 16);
                        callback (segment.rgValue[start+j], name);
                    }
                }
            }
        }
        dwAddr = (DWORD_PTR)segment.pNextSegment;
    }
}

void FindGCRootOnHandleTables1(GCInfoCallback callback)
{
    // For old handle table code
    static DWORD_PTR sHandleTableAddr = -1;
    if (sHandleTableAddr == -1)
    {
        sHandleTableAddr = GetValueFromExpression("MSCOREE!g_pHandleTableArray");
    }
    if (sHandleTableAddr == 0) {
        return;
    }

    static DWORD_PTR handleTableCountAddr = 0;
    if (handleTableCountAddr == 0)
    {
        handleTableCountAddr = GetValueFromExpression("MSCOREE!g_cHandleTableArray");
    }

    size_t handleTableAddr;
    move (handleTableAddr, sHandleTableAddr);
    if (handleTableAddr == 0) {
        return;
    }
    UINT handleTableCount;
    move (handleTableCount, handleTableCountAddr);

    size_t tableAddr;
    for (UINT i = 0; i < handleTableCount; i++) {
        if (IsInterrupt())
            return;
        move (tableAddr, handleTableAddr+i*sizeof(size_t));
        if (tableAddr) {
            FindGCRootOnOneHandleTable (tableAddr, callback);
        }
    }
}

void FindGCRootOnHandleTables2(GCInfoCallback callback)
{
    // For old handle table code
    static DWORD_PTR sHandleTableMapAddr = -1;
    if (sHandleTableMapAddr == -1)
    {
        sHandleTableMapAddr = GetValueFromExpression("MSCOREE!g_HandleTableMap");
    }

    if (sHandleTableMapAddr == 0) {
        return;
    }

    DWORD_PTR handleTableMapAddr = sHandleTableMapAddr;
    HandleTableMap map;
    DWORD offset = 0;

    size_t tableAddr;
    while (handleTableMapAddr) {
        if (IsInterrupt())
            return;
        map.Fill (handleTableMapAddr);
        for (DWORD i = 0; i < map.dwMaxIndex-offset; i++) {
            if (IsInterrupt())
                return;
            move (tableAddr, map.pTable+i*sizeof(size_t));
            if (tableAddr) {
                FindGCRootOnOneHandleTable (tableAddr, callback);
            }
        }
        offset = map.dwMaxIndex;
        handleTableMapAddr = (DWORD_PTR)map.pNext;
    }
}

void FindGCRootOnHandleTables(GCInfoCallback callback)
{
    FindGCRootOnHandleTables1(callback);
    FindGCRootOnHandleTables2(callback);
}

class GCRootCleanUp {
public:
    GCRootCleanUp(){}
    ~GCRootCleanUp()
    {
        gcRootInfo.Release();
        wq.Release();
    }
};

void FindGCRoot (size_t obj)
{
    GCRootCleanUp cleanup;

    InitGCRoot (obj);

    FindGCRootOnStacks (TraceObjectGraph);

    FindGCRootOnHandleTables(TraceObjectGraph);
}

class ObjSizeInfo: public HeapStat
{
private:
    Node *curNode;

public:
    ObjSizeInfo ()
    {
    }

    DWORD GetSize (DWORD_PTR obj)
    {
        curNode = NULL;
        if (head == 0)
        {
            head = (Node*)malloc(sizeof(Node));
            if (head == NULL)
            {
                dprintf ("Not enough memory\n");
                ControlC = TRUE;
                return -1;
            }
            head = new (head) Node;
            head->MT = obj;
            curNode = head;
            return 0;
        }
        Node *walk = head;
        while (walk->MT != obj)
        {
            if (IsInterrupt())
                return -1;
            if (obj < walk->MT)
            {
                if (walk->left == NULL)
                    break;
                walk = walk->left;
            }
            else
            {
                if (walk->right == NULL)
                    break;
                walk = walk->right;
            }
        }

        if (obj == walk->MT)
        {
            curNode = NULL;
            return walk->totalSize;
        }
        else
        {
            Node *node = (Node*)malloc(sizeof(Node));
            if (node == NULL)
            {
                dprintf ("Not enough memory\n");
                ControlC = TRUE;
                return -1;
            }
            node = new (node) Node;
            node->MT = obj;

            if (obj < walk->MT)
            {
                walk->left = node;
            }
            else
            {
                walk->right = node;
            }
        
            curNode = node;
            return 0;
        }
    }

    void SetSize (DWORD aSize)
    {
        if (curNode) {
            curNode->totalSize = aSize;
        }
    }
};

ObjSizeInfo objSizeInfo;

void TraceObjectGraphForSize (size_t obj, const char *name=NULL)
{
    if (!IsObject (obj)) {
        return;
    }
    gcRootInfo.Reset();
    DWORD size = objSizeInfo.GetSize(obj);

    if (size == -1) {
        return;
    }
    else if (size == 0) {
        Entry *pEntry = wq.GetEntry();
        pEntry->SetObject(obj);
        GetListOfRefs (pEntry);

        while (1) {
            if (IsInterrupt())
                return;
            size_t nextobj = pEntry->PopMember();
            if (nextobj == 0) {
                size += ObjectSize(pEntry->GetObject());
                pEntry = wq.PopEntry();
                if (pEntry == NULL) {
                    objSizeInfo.SetSize(size);
                    break;
                }
                continue;
            }
            pEntry = wq.GetEntry();
            pEntry->SetObject(nextobj);
            GetListOfRefs (pEntry);
        }
    }

    if (name) {
        ExtOut ("%s: ", name);
    }
    ExtOut ("sizeof(%p) = %8d (%#8x) bytes", (ULONG64)obj, size, size);
    NameForObject (obj, g_mdName);
    ExtOut (" (%S)\n", g_mdName);
}

void FindObjSize (size_t obj)
{
    GCRootCleanUp cleanup;

    InitGCRoot (0);

    TraceObjectGraphForSize(obj, NULL);
}

void FindAllRootSize ()
{
    GCRootCleanUp cleanup;

    InitGCRoot (0);

    class ObjSizeCleanUp {
    public:
        ~ObjSizeCleanUp ()
        {
            objSizeInfo.Delete();
        }
    };
    ObjSizeCleanUp cleanup1;

    FindGCRootOnStacks (TraceObjectGraphForSize);

    FindGCRootOnHandleTables(TraceObjectGraphForSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\utilcode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// An empty file so that gcdump.cpp does not include the one from other
// places.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\stresslogdump.cpp ===
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include <stdio.h>		
#include <ctype.h>

#define STRESS_LOG
#include "StressLog.h"

/*********************************************************************************/
ThreadStressLog* ThreadStressLog::FindLatestThreadLog() const {
	const ThreadStressLog* ptr = this;
	const ThreadStressLog* latestLog = 0;
	while (ptr) {
		if (ptr->readPtr != ptr->curPtr)
			if (latestLog == 0 || ptr->readPtr->timeStamp > latestLog->readPtr->timeStamp)
				latestLog = ptr;
		ptr = ptr->next;
	}
	return const_cast<ThreadStressLog*>(latestLog);
}

__int64 ts;

/*********************************************************************************/
/* recognise sepcial pretty printing instructions in the format string */
void formatOutput(FILE* file, char* format, unsigned threadId, __int64 timeStamp, void** args)
{
	fprintf(file, "%4x %08x%08x: ", threadId, unsigned(timeStamp >> 32), unsigned(timeStamp));

	CQuickBytes fullname;
	char* ptr = format;
	void** argsPtr = args;
	wchar_t buff[2048];
	static char formatCopy[256];
	strcpy(formatCopy, format);
	ts = timeStamp;
	for(;;) {
		char c = *ptr++;
		if (c == 0)
			break;
		if (c == '{') 			// Reverse the '{' 's because the log is displayed backwards
			ptr[-1] = '}';
		else if (c == '}')
			ptr[-1] = '{';
		else if (c == '%') {
			argsPtr++;			// This format will consume one of the args
			if (*ptr == '%') {
				ptr++;			// skip the whole %%
				--argsPtr;		// except for a %% 
			}
			else if (*ptr == 'p') {	// It is a %p
				ptr++;
				if (isalpha(*ptr)) {	// It is a special %p formatter
						// Print the string up to that point
					c = *ptr;
					*ptr = 0;		// Terminate the string temporarily
					fprintf(file, format, args[0], args[1], args[2], args[3]);
					*ptr = c;		// Put it back	

						// move the argument pointers past the part the was printed
					format = ptr + 1;
					args = argsPtr;	
					DWORD_PTR arg = DWORD_PTR(argsPtr[-1]);

					switch (c) {
						case 'M':	// format as a method Desc
							if (!IsMethodDesc(arg)) {
								if (arg != 0) 
									fprintf(file, " (BAD Method)");
							}
							else {
								MethodDesc *pMD = (MethodDesc*)_alloca(sizeof(MethodDesc));
								if (!pMD) return;

								DWORD_PTR mdAddr = arg;
								pMD->Fill(mdAddr);
								if (!CallStatus) return;

								FullNameForMD (pMD,&fullname);
								wcscpy(buff, (WCHAR*)fullname.Ptr());
								fprintf(file, " (%S)", (WCHAR*)fullname.Ptr());
							}
							break;

						case 'T': 		// format as a MethodDesc
							if (arg & 3) {
								arg &= ~3;		// GC steals the lower bits for its own use during GC.  
								fprintf(file, " Low Bit(s) Set");
							}
							if (!IsMethodTable(arg))
								fprintf(file, " (BAD MethodTable)");
							else {
								NameForMT (arg, g_mdName);
								fprintf(file, " (%S)", g_mdName);
							}
							break;

						case 'V': {		// format as a C vtable pointer 
							char Symbol[1024];
							ULONG64 Displacement;
							HRESULT hr = g_ExtSymbols->GetNameByOffset(arg, Symbol, 1024, NULL, &Displacement);
							if (SUCCEEDED(hr) && Symbol[0] != '\0' && Displacement == 0) 
								fprintf(file, " (%s)", Symbol);
							else 
								fprintf(file, " (Unknown VTable)");
							}
							break;
						default:
							format = ptr;	// Just print the character. 
					}
				}
			}
		}
	}
		// Print anything after the last special format instruction.
	fprintf(file, format, args[0], args[1], args[2], args[3]);
}


/*********************************************************************************/
HRESULT StressLog::Dump(ULONG64 outProcLog, const char* fileName, struct IDebugDataSpaces* memCallBack) {

		// Fetch the circular buffer bookeeping data 
	StressLog inProcLog;
	HRESULT hr = memCallBack->ReadVirtual(outProcLog, &inProcLog, sizeof(StressLog), 0);
	if (hr != S_OK) return hr;

		// Fetch the circular buffers for each thread into the 'logs' list
	ThreadStressLog* logs = 0;

	ULONG64 outProcPtr = ULONG64(inProcLog.logs);
	ThreadStressLog* inProcPtr;
	ThreadStressLog** logsPtr = &logs;
	int threadCtr = 0;
	while(outProcPtr != 0) {
		inProcPtr = (ThreadStressLog*) new byte[inProcLog.size];
		hr = memCallBack->ReadVirtual(outProcPtr, inProcPtr, inProcLog.size, 0);
		if (hr != S_OK) return hr;

			// TODO fix on 64 bit
		ULONG64 delta = ULONG64(inProcPtr) - outProcPtr;
		inProcPtr->endPtr = (StressMsg*) ((char*) inProcPtr->endPtr + size_t(delta));
		inProcPtr->curPtr = (StressMsg*) ((char*) inProcPtr->curPtr + size_t(delta));
		inProcPtr->readPtr = inProcPtr->Prev(inProcPtr->curPtr);

		outProcPtr = ULONG64(inProcPtr->next);

		*logsPtr = inProcPtr;
		logsPtr = &inProcPtr->next;
		threadCtr++;
	}

	FILE* file = fopen(fileName, "w");
	if (file == 0) {
		hr = GetLastError();
		goto FREE_MEM;
	}
	hr = S_FALSE;		// return false if there are no message to print to the log

	fprintf(file, "STRESS LOG:\n    facilitiesToLog=0x%x\n    sizePerThread=0x%x (%d)\n    ThreadsWithLogs = %d\n\n",
		inProcLog.facilitiesToLog, inProcLog.size, inProcLog.size, threadCtr);

	fprintf(file, " TID   TIMESTAMP                            Message\n");
	fprintf(file, "--------------------------------------------------------------------------\n");
	char format[257];
	format[256] = format[0] = 0;
	void* args[8];
	unsigned msgCtr = 0;
	for (;;) {
		ThreadStressLog* latestLog = logs->FindLatestThreadLog();

		if (IsInterrupt()) {
			fprintf(file, "----- Interrupted by user -----\n");
			break;
		}

		if (latestLog == 0)
			break;

		StressMsg* latestMsg = latestLog->readPtr;
		if (latestMsg->format != 0) {
			hr = memCallBack->ReadVirtual(ULONG64(latestMsg->format), format, 256, 0);
			if (hr != S_OK) 
				strcpy(format, "Could not read address of format string");

			if (strcmp(format, ThreadStressLog::continuationMsg()) == 0) {
				StressMsg* firstPart = latestLog->Prev(latestMsg);

					// if we don't have the first part of this continued message, Don't print anything
				if (firstPart == latestLog->curPtr) 
					goto SKIP_PRINT;

				hr = memCallBack->ReadVirtual(ULONG64(firstPart->format), format, 256, 0);
				if (hr != S_OK) 
					strcpy(format, "Could not read address of format string");

				args[0] = firstPart->data;
				args[1] = firstPart->moreData.data2;
				args[2] = firstPart->moreData.data3; 
				args[3] = latestMsg->data;
				formatOutput(file, format, latestLog->threadId, latestMsg->timeStamp, args);
				latestMsg = firstPart;
			}
			else {
				args[0] = latestMsg->data;
				formatOutput(file, format, latestLog->threadId, latestMsg->timeStamp, args);
			}
			msgCtr++;
		}
		SKIP_PRINT:

		latestLog->readPtr = latestLog->Prev(latestMsg);
		if (latestLog->readPtr == latestLog->curPtr)
			fprintf(file, "------------ Last message from thread %x -----------\n", latestLog->threadId);

		if (msgCtr % 64 == 0) 
		{
			ExtOut(".");		// to indicate progress
			if (msgCtr % (64*64) == 0) 
				ExtOut("\n");	
		}
	}
	ExtOut("\n");

	fprintf(file, "---------------------------- %d total entries ------------------------------------\n", msgCtr);
	fclose(file);

FREE_MEM:
	// clean up the 'logs' list
	while (logs) {
		ThreadStressLog* temp = logs;
		logs = logs->next;
		delete [] temp;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\strikeee.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _strikeEE_h
#define _strikeEE_h

//typedef ULONG32 mdTypeDef;              // TypeDef in this scope
//typedef ULONG32 mdFieldDef;             // Field in this scope  
//typedef ULONG32 mdMethodDef;            // Method in this scope 

class Module;
class MethodTable;
class MethodDescChunk;
class InterfaceHintCache;
class Frame;
class Context;
class AppDomain;
class GCCoverageInfo;

#ifdef _IA64_
#define METHOD_IS_IL_FLAG   0x8000000000000000
#else
#define METHOD_IS_IL_FLAG   0x80000000
#endif

class BaseObject
{
    MethodTable    *m_pMethTab;
};

class Object : public BaseObject
{
    BYTE            m_Data[1];
};

class StringObject : public BaseObject
{
    DWORD   m_ArrayLength;
    DWORD   m_StringLength;
    WCHAR   m_Characters[1];
};


class TypeDesc {
public:
    // !!!! keep this for bit field;
    void* preBit1;
    CorElementType  m_Type    : 8;          // This is used to discriminate what kind of TypeDesc we are
    
    void Fill(DWORD_PTR & dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class TypeHandle 
{
public:
    union 
    {
        INT_PTR         m_asInt;        // we look at the low order bits 
        void*           m_asPtr;
        TypeDesc*       m_asTypeDesc;
        MethodTable*    m_asMT;
    };
};

class ReflectClass;

class ParamTypeDesc : public TypeDesc {
public:
        // the m_Type field in TypeDesc tell what kind of parameterized type we have
    MethodTable*    m_TemplateMT;       // The shared method table, some variants do not use this field (it is null)
    TypeHandle      m_Arg;              // The type that is being modifiedj
    ReflectClass    *m_ReflectClassObject;    // pointer back to the internal reflection Type object
    
    void Fill(DWORD_PTR & dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// Dynamically generated array class structure
class ArrayClass
{
public:
    ArrayClass *    m_pNext;            // next array class loaded by the same classloader
    // !!!! keep this for bit field;
    void* preBit1;
    unsigned        m_dwRank      : 8;
    CorElementType  m_ElementType : 8;  // Cache of element type in m_ElementTypeHnd
    TypeHandle      m_ElementTypeHnd;
    MethodDesc*     m_elementCtor; // if is a value class array and has a default constructor, this is it

    void Fill(DWORD_PTR & dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct SLink
{
    SLink* m_pNext;
};

struct SList
{
    SLink m_link;
    SLink* m_pHead;
    SLink* m_pTail;
};

struct SyncBlock;
class Thread;

struct WaitEventLink;

struct AwareLock
{
    HANDLE          m_SemEvent;
    LONG   m_MonitorHeld;
    ULONG           m_Recursion;
    DWORD_PTR       m_HoldingThread;

        //static Crst *AllocLockCrst;
        //static BYTE AllocLockCrstInstance[sizeof(Crst)];
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct SyncBlock
{
    AwareLock  m_Monitor;                    // the actual monitor

    // If this object is exposed to COM, or it is a proxy over a COM object,
    // we keep some extra info here:
    DWORD_PTR       m_pComData;

    // Likewise, if this object has been exposed through a context boundary, we
    // keep a backpointer to its proxy.
    DWORD_PTR m_CtxProxy;

#ifndef UNDER_CE
    // And if the object has new fields added via EnC, this is a list of them
    DWORD_PTR m_pEnCInfo;
#endif

    // We thread two different lists through this link.  When the SyncBlock is
    // active, we create a list of waiting threads here.  When the SyncBlock is
    // released (we recycle them), the SyncBlockCache maintains a free list of
    // SyncBlocks here.
    //
    // We can't afford to use an SList<> here because we only want to burn
    // space for the minimum, which is the pointer within an SLink.
    SLink       m_Link;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


struct SyncTableEntry
{
    DWORD_PTR   m_SyncBlock;
    DWORD_PTR   m_Object;
        //static SyncTableEntry* s_pSyncTableEntry;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


// this class stores free sync blocks after they're allocated and
// unused

struct SyncBlockCache
{
	DWORD_PTR	m_pCleanupBlockList;	// list of sync blocks that need cleanup
    DWORD_PTR	m_FreeBlockList;        // list of free sync blocks
    Crst        m_CacheLock;            // cache lock
    DWORD       m_FreeCount;            // count of active sync blocks
    DWORD       m_ActiveCount;          // number active
    DWORD_PTR   m_SyncBlocks;       // Array of new SyncBlocks.
    DWORD       m_FreeSyncBlock;        // Next Free Syncblock in the array
    DWORD       m_FreeSyncTableIndex;   // free index in the SyncBlocktable
    DWORD       m_FreeSyncTableList;    // index of the free list of SyncBlock
                                        // Table entry
    DWORD       m_SyncTableSize;
    DWORD_PTR   m_OldSyncTables;    // Next old SyncTable

        //static SyncBlockCache* s_pSyncBlockCache;
        //static SyncBlockCache*& GetSyncBlockCache();
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct ThreadStore
{
    enum ThreadStoreState
    {
        TSS_Normal       = 0,
        TSS_ShuttingDown = 1,

    }              m_StoreState;
    HANDLE          m_TerminationEvent;

    // Critical section for adding and removing threads to the store
    Crst        m_Crst;

    // List of all the threads known to the ThreadStore (started & unstarted).
    SList  m_ThreadList;

    LONG        m_ThreadCount;
    LONG        m_UnstartedThreadCount;
    LONG        m_BackgroundThreadCount;
    LONG        m_PendingThreadCount;
    LONG        m_DeadThreadCount;

    // Space for the lazily-created GUID.
    GUID        m_EEGuid;
    BOOL        m_GuidCreated;

    DWORD_PTR     m_HoldingThread;
    void Fill (DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

typedef HANDLE CorHandle;

//typedef DWORD_PTR IMetaDataEmit;
//typedef DWORD_PTR IMetaDataImport;
//typedef DWORD_PTR IMetaDataDispenserEx;
typedef DWORD_PTR ModuleSecurityDesc;
typedef DWORD_PTR Stub;

class Bucket;

struct LoaderHeapBlock
{
    struct LoaderHeapBlock *pNext;
    void *                  pVirtualAddress;
    DWORD                   dwVirtualSize;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


class GCHeap;
struct alloc_context 
{
	BYTE*   alloc_ptr;
	BYTE*   alloc_limit;
    _int64  alloc_bytes;
	GCHeap* heap;
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct plug
{
	BYTE *	skew[sizeof(DWORD) / sizeof(BYTE *)];
};

class gc_heap;

class heap_segment
{
public:
    BYTE*           allocated;
    BYTE*           committed;
    BYTE*           reserved;
	BYTE* 			used;
    BYTE*           mem;
    heap_segment*   next;
    BYTE*           plan_allocated;
	int				status;
	BYTE*			aliased;
	BYTE*			padx;

	gc_heap*        heap;

	BYTE*			pad0;
#if (SIZEOF_OBJHEADER % 8) != 0
	BYTE			pad1[8 - (SIZEOF_OBJHEADER % 8)];	// Must pad to quad word
#endif
	plug            plug;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

//no constructors because we initialize in make_generation
class generation
{
public:
	// Don't move these first two fields without adjusting the references
	// from the __asm in jitinterface.cpp.
	alloc_context   allocation_context;
    heap_segment*   allocation_segment;
    BYTE*           free_list;
    heap_segment*   start_segment;
    BYTE*           allocation_start;
    BYTE*           plan_allocation_start;
    BYTE*           last_gap;
    size_t          free_list_space;
    size_t          allocation_size;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


#define NUMBERGENERATIONS 5

class CFinalize
{
public:

    Object** m_Array;
    Object** m_FillPointers[NUMBERGENERATIONS+2];
    Object** m_EndArray;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class gc_heap
{
public:
    DWORD_PTR alloc_allocated;
    generation generation_table [NUMBERGENERATIONS];
    heap_segment* ephemeral_heap_segment;
    size_t large_blocks_size;
    int g_max_generation;
    CFinalize* finalize_queue;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

#define SIZEOF_OBJHEADER 4
class large_object_block
{
public:
    large_object_block*    next;      // Points to the next block
    large_object_block**   prev;      // Points to &(prev->next) where prev is the previous block
#if (SIZEOF_OBJHEADER % 8) != 0
	BYTE				   pad1[8 - (SIZEOF_OBJHEADER % 8)];	// Must pad to quad word
#endif
	plug				   plug;      // space for ObjHeader
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class FieldDesc
{
public:
    MethodTable *m_pMTOfEnclosingClass; // Note, 2 bits of info are stolen from this pointer

    // !!!! Keep this for bit field
    void *preBit1;
    unsigned m_mb               : 24; 

    // 8 bits...
    unsigned m_isStatic         : 1;
    unsigned m_isThreadLocal    : 1;
    unsigned m_isContextLocal   : 1;
    unsigned m_isRVA            : 1;
    unsigned m_prot             : 3;
    unsigned m_isDangerousAppDomainAgileField : 1; // Note: this is used in checked only

    void *preBit2;
    // Note: this has been as low as 22 bits in the past & seemed to be OK.
    // we can steal some more bits here if we need them.
    unsigned m_dwOffset         : 27;
    unsigned m_type             : 5;

    const char* m_debugName;
    
	void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

extern char *CorElementTypeName[];

typedef struct tagLockEntry
{
    tagLockEntry *pNext;    // next entry
    tagLockEntry *pPrev;    // prev entry
    DWORD dwULockID;
    DWORD dwLLockID;        // owning lock
    WORD wReaderLevel;      // reader nesting level
    
	void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
} LockEntry;

class StackingAllocator
{
public:

    enum {
        MinBlockSize    = 128,
        MaxBlockSize    = 4096,
        InitBlockSize   = 512
    };

    // Blocks from which allocations are carved. Size is determined dynamically,
    // with upper and lower bounds of MinBlockSize and MaxBlockSize respectively
    // (though large allocation requests will cause a block of exactly the right
    // size to be allocated).
    struct Block
    {
        Block      *m_Next;         // Next oldest block in list
        unsigned    m_Length;       // Length of block excluding header
        char        m_Data[1];       // Start of user allocation space
    };

    // Whenever a checkpoint is requested, a checkpoint structure is allocated
    // (as a normal allocation) and is filled with information about the state
    // of the allocator prior to the checkpoint. When a Collapse request comes
    // in we can therefore restore the state of the allocator.
    // It is the address of the checkpoint structure that we hand out to the
    // caller of GetCheckpoint as an opaque checkpoint marker.
    struct Checkpoint
    {
        Block      *m_OldBlock;     // Head of block list before checkpoint
        unsigned    m_OldBytesLeft; // Number of free bytes before checkpoint
    };

    Block      *m_FirstBlock;       // Pointer to head of allocation block list
    char       *m_FirstFree;        // Pointer to first free byte in head block
    unsigned    m_BytesLeft;        // Number of free bytes left in head block
    Block      *m_InitialBlock;     // The first block is special, we never free it

//#ifdef _DEBUG
    unsigned    m_CheckpointDepth;
    unsigned    m_Allocs;
    unsigned    m_Checkpoints;
    unsigned    m_Collapses;
    unsigned    m_BlockAllocs;
    unsigned    m_MaxAlloc;
//#endif
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


class Thread
{
public:

    enum ThreadState
    {
        TS_Unknown                = 0x00000000,    // threads are initialized this way

        TS_StopRequested          = 0x00000001,    // process stop at next opportunity
        TS_GCSuspendPending       = 0x00000002,    // waiting to get to safe spot for GC
        TS_UserSuspendPending     = 0x00000004,    // user suspension at next opportunity
        TS_DebugSuspendPending    = 0x00000008,    // Is the debugger suspending threads?
        TS_GCOnTransitions        = 0x00000010,    // Force a GC on stub transitions (GCStress only)

        TS_LegalToJoin            = 0x00000020,    // Is it now legal to attempt a Join()
        TS_Hijacked               = 0x00000080,    // Return address has been hijacked

        TS_Background             = 0x00000200,    // Thread is a background thread
        TS_Unstarted              = 0x00000400,    // Thread has never been started
        TS_Dead                   = 0x00000800,    // Thread is dead

        TS_WeOwn                  = 0x00001000,    // Exposed object initiated this thread
        TS_CoInitialized          = 0x00002000,    // CoInitialize has been called for this thread
        TS_InSTA                  = 0x00004000,    // Thread hosts an STA
        TS_InMTA                  = 0x00008000,    // Thread is part of the MTA

        // Some bits that only have meaning for reporting the state to clients.
        TS_ReportDead             = 0x00010000,    // in WaitForOtherThreads()

        TS_SyncSuspended          = 0x00080000,    // Suspended via WaitSuspendEvent
        TS_DebugWillSync          = 0x00100000,    // Debugger will wait for this thread to sync
        TS_RedirectingEntryPoint  = 0x00200000,    // Redirecting entrypoint. Do not call managed entrypoint when set 

        TS_SuspendUnstarted       = 0x00400000,    // latch a user suspension on an unstarted thread

        TS_ThreadPoolThread       = 0x00800000,    // is this a threadpool thread?
        TS_TPWorkerThread         = 0x01000000,    // is this a threadpool worker thread? (if not, it is a threadpool completionport thread)

        TS_Interruptible          = 0x02000000,    // sitting in a Sleep(), Wait(), Join()
        TS_Interrupted            = 0x04000000,    // was awakened by an interrupt APC

        TS_AbortRequested         = 0x08000000,    // same as TS_StopRequested in order to trip the thread
        TS_AbortInitiated         = 0x10000000,    // set when abort is begun
        TS_UserStopRequested      = 0x20000000,    // set when a user stop is requested. This is different from TS_StopRequested
        TS_GuardPageGone          = 0x40000000,    // stack overflow, not yet reset.
        TS_Detached               = 0x80000000,    // Thread was detached by DllMain

        // @TODO: We need to reclaim the bits that have no concurrency issues (i.e. they are only 
        //         manipulated by the owning thread) and move them off to a different DWORD

        // We require (and assert) that the following bits are less than 0x100.
        TS_CatchAtSafePoint = (TS_UserSuspendPending | TS_StopRequested |
                               TS_GCSuspendPending | TS_DebugSuspendPending | TS_GCOnTransitions),
    };

    // Offsets for the following variables need to fit in 1 byte, so keep near
    // the top of the object.
    volatile ThreadState m_State;   // Bits for the state of the thread

    // If TRUE, GC is scheduled cooperatively with this thread.
    // NOTE: This "byte" is actually a boolean - we don't allow
    // recursive disables.
    volatile ULONG       m_fPreemptiveGCDisabled;

    DWORD                m_dwLockCount;
    
    Frame               *m_pFrame;  // The Current Frame

    DWORD       m_dwCachePin;

    // RWLock state 
    BOOL                 m_fNativeFrameSetup;
    LockEntry           *m_pHead;
    LockEntry            m_embeddedEntry;

    // on MP systems, each thread has its own allocation chunk so we can avoid
    // lock prefixes and expensive MP cache snooping stuff
    alloc_context        m_alloc_context;

    // Allocator used during marshaling for temporary buffers, much faster than
    // heap allocation.
    StackingAllocator    m_MarshalAlloc;
    INT32 m_ctxID;
    OBJECTHANDLE    m_LastThrownObjectHandle;
    
    struct HandlerInfo {
        // Note: the debugger assumes that m_pThrowable is a strong
        // reference so it can check it for NULL with preemptive GC
        // enabled.
	    OBJECTHANDLE    m_pThrowable;	// thrown exception
        Frame  *m_pSearchBoundary;		// topmost frame for current managed frame group
		union {
			EXCEPTION_REGISTRATION_RECORD *m_pBottomMostHandler; // most recent EH record registered
			EXCEPTION_REGISTRATION_RECORD *m_pCatchHandler;      // reg frame for catching handler
		};

        // for building stack trace info
        void *m_pStackTrace;              // pointer to stack trace storage (of type SystemNative::StackTraceElement)
        unsigned m_cStackTrace;           // size of stack trace storage
        unsigned m_dFrameCount;           // current frame in stack trace

        HandlerInfo *m_pPrevNestedInfo; // pointer to nested info if are handling nested exception

        DWORD * m_pShadowSP;            // Zero this after endcatch

        // pointer to original exception info for rethrow
        EXCEPTION_RECORD *m_pExceptionRecord;   
        CONTEXT *m_pContext;

#ifdef _X86_
        DWORD   m_dEsp;         // Esp when  fault occured, OR esp to restore on endcatch
#endif
    };
        
    DWORD          m_ResumeControlEIP;

    // The ThreadStore manages a list of all the threads in the system.  I
    // can't figure out how to expand the ThreadList template type without
    // making m_LinkStore public.
    SLink       m_LinkStore;

    // For N/Direct calls with the "setLastError" bit, this field stores
    // the errorcode from that call.
    DWORD       m_dwLastError;
    
    VOID          *m_pvHJRetAddr;             // original return address (before hijack)
    VOID         **m_ppvHJRetAddrPtr;         // place we bashed a new return address
    MethodDesc  *m_HijackedFunction;        // remember what we hijacked


    DWORD       m_Win32FaultAddress;
    DWORD       m_Win32FaultCode;


    LONG         m_UserInterrupt;

public:


//#ifdef _DEBUG
    ULONG  m_ulGCForbidCount;
//#endif

//#ifdef _DEBUG
#ifdef _X86_
#ifdef _MSC_VER
    // fs:[0] that was current at the time of the last COMPLUS_TRY
    // entry (fs:[0] is set on a per-function basis so the value
    // doesn't actually change when execution "crosses" the COMPLUS_TRY.
    LPVOID  m_pComPlusTryEntrySEHRecord;
    __int32 m_pComPlusTryEntryTryLevel;
#endif
#endif
//#endif

    // For suspends:
    HANDLE          m_SafeEvent;
    HANDLE          m_SuspendEvent;

    // For Object::Wait, Notify and NotifyAll, we use an Event inside the
    // thread and we queue the threads onto the SyncBlock of the object they
    // are waiting for.
    HANDLE          m_EventWait;
    SLink           m_LinkSB;
    SyncBlock      *m_WaitSB;

    // We maintain a correspondence between this object, the ThreadId and ThreadHandle
    // in Win32, and the exposed Thread object.
    HANDLE          m_ThreadHandle;
    DWORD           m_ThreadId;
    OBJECTHANDLE    m_ExposedObject;
	OBJECTHANDLE	m_StrongHndToExposedObject;

    DWORD           m_Priority;     // initialized to INVALID_THREAD_PRIORITY, set to actual priority when a 
                                    // thread does a busy wait for GC, reset to INVALID_THREAD_PRIORITY after wait is over 

    // serialize access to the Thread's state
    Crst            m_Crst;
    ULONG           m_ExternalRefCount;

	LONG			m_TraceCallCount;

    // The context within which this thread is executing.  As the thread crosses
    // context boundaries, the context mechanism adjusts this so it's always
    // current.
    // @TODO cwb: When we add COM+ 1.0 Context Interop, this should get moved out
    // of the Thread object and into its own slot in the TLS.
    Context        *m_Context;

    //---------------------------------------------------------------
    // Exception handler info
    //---------------------------------------------------------------
    HandlerInfo m_handlerInfo;

    //-----------------------------------------------------------
    // Inherited code-access security permissions for the thread.
    //-----------------------------------------------------------
    OBJECTHANDLE    m_pSecurityStack;

    //-----------------------------------------------------------
    // If the thread has wandered in from the outside this is
    // its Domain. This is temporary until domains are true contexts
    //-----------------------------------------------------------
    AppDomain      *m_pDomain;

    //---------------------------------------------------------------
    // m_debuggerWord1 is now shared between the CONTEXT * and the
    // lowest bit, which is used as a boolean to indicate whether
    // we want to keep this thread suspended when everything resumes.
    //---------------------------------------------------------------
    void *m_debuggerWord1;

    //---------------------------------------------------------------
    // A word reserved for use by the COM+ Debugging 
    //---------------------------------------------------------------
    DWORD    m_debuggerWord2;
public:

    // Don't allow a thread to be asynchronously stopped or interrupted (e.g. because
    // it is performing a <clinit>)
    int         m_PreventAsync;

    // Access the base and limit of the stack.  (I.e. the memory ranges that
    // the thread has reserved for its stack).
    //
    // Note that the base is at a higher address than the limit, since the stack
    // grows downwards.
    //
    // Note that we generally access the stack of the thread we are crawling, which
    // is cached in the ScanContext
    void       *m_CacheStackBase;
    void       *m_CacheStackLimit;

    // IP cache used by QueueCleanupIP.
    #define CLEANUP_IPS_PER_CHUNK 4
    struct CleanupIPs {
        IUnknown    *m_Slots[CLEANUP_IPS_PER_CHUNK];
        CleanupIPs  *m_Next;
    };
    CleanupIPs   m_CleanupIPs;

    _NT_TIB* m_pTEB;
    
    // The following variables are used to store thread local static data
    STATIC_DATA  *m_pUnsharedStaticData;
    STATIC_DATA  *m_pSharedStaticData;

    STATIC_DATA_LIST *m_pStaticDataList;

    void Fill (DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

const DWORD gElementTypeInfo[] = {
#define TYPEINFO(e,c,s,g,ie,ia,ip,if,im,ial)    s,
#include "cortypeinfo.h"
#undef TYPEINFO
};

typedef SList TypArbitraryPolicyList;

enum WellKnownPolicies;
typedef DWORD_PTR ICtxSynchronize;
typedef DWORD_PTR ICtxHeap;
typedef DWORD_PTR ICtxComContext;
typedef DWORD_PTR ComPlusWrapperCache;

class Context
{
public:
    // @todo rudim: revisit this once we have working thread affinity domains
    ComPlusWrapperCache *m_pComPlusWrapperCache;


    // Non-static Data Members:
    STATIC_DATA* m_pUnsharedStaticData;     // Pointer to native context static data
    STATIC_DATA* m_pSharedStaticData;       // Pointer to native context static data

    // @TODO: CTS. Domains should really be policies on a context and not
    // entry in the context object. When AppDomains become an attribute of
    // a context then add the policy.
    AppDomain*          m_pDomain;

    void Fill(DWORD_PTR &dwStartAddr);    
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class ExposedType
{
public:
    DWORD_PTR vtbl;
    OBJECTHANDLE m_ExposedTypeObject;
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class BaseDomain;
class CorModule;
class AssemblyMetaDataInternal;
class IAssembly;
class IAssemblyName;
class LockedListElement;

class ListLock
{
public:
    CRITICAL_SECTION    m_CriticalSection;
    BOOL                m_fInited;
    LockedListElement * m_pHead;
};

class EEUtf8StringHashTable;

class Assembly : public ExposedType
{
public:
    ListLock     m_ClassInitLock;
    ListLock     m_JITLock;
    short int m_FreeFlag;
    BaseDomain*           m_pDomain;        // Parent Domain

    ClassLoader*          m_pClassLoader;   // Single Loader
    CorModule*            m_pDynamicCode;   // Dynamic writer
    
    mdFile                m_tEntryModule;    // File token indicating the file that has the entry point
    Module*               m_pEntryPoint;     // Module containing the entry point in the COM plus HEasder

    Module*               m_pManifest;
    mdAssembly            m_kManifest;
    IMDInternalImport*    m_pManifestImport;
    PBYTE                 m_pbManifestBlob;
    CorModule*            m_pOnDiskManifest;  // This is the module containing the on disk manifest.
    mdAssembly            m_tkOnDiskManifest;
    bool                  m_fEmbeddedManifest;  

    LPWSTR                m_pwCodeBase;     // Cached code base for the assembly
    DWORD                 m_dwCodeBase;     //  size of code base 
    ULONG                 m_ulHashAlgId;    // Hash algorithm used in the Assembly
    AssemblyMetaDataInternal *m_Context;
    DWORD                 m_dwFlags;

    // Hash of files in manifest by name to File token
    EEUtf8StringHashTable *m_pAllowedFiles;

    LPWSTR                m_pwsFullName;    // Long version of the name (on the heap do not delete)
    
    // Set the appropriate m_FreeFlag bit if you malloc these.
    LPCUTF8               m_psName;         // Name of assembly
    LPCUTF8               m_psAlias;
    LPCUTF8               m_psTitle;
    PBYTE                 m_pbPublicKey;
    DWORD                 m_cbPublicKey;
    LPCUTF8               m_psDescription;
    

    BOOL                  m_fFromFusion;
    bool                  m_isDynamic;
    IAssembly*            m_pFusionAssembly;     // Assembly object to assembly in fusion cache
    IAssemblyName*        m_pFusionAssemblyName; // name of assembly in cache

    IInternetSecurityManager    *m_pSecurityManager;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class EEStringHashTable;
class EEUnicodeStringHashTable;
class EEMarshalingData;
class AssemblySink;
class IApplicationContext;
class AppSecurityBoundary;
class ApplicationSecurityDescriptor;

class ArrayList
{
 public:

	enum
	{
		ARRAY_BLOCK_SIZE_START = 15,
	};

    struct ArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[1];
    };

    struct FirstArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[ARRAY_BLOCK_SIZE_START];
    };

    DWORD               m_count;
    union
    {
          ArrayListBlock        m_block;
          FirstArrayListBlock   m_firstBlock;
    };
    
    void Fill(DWORD_PTR &dwStartAddr);
    void *Get (DWORD index);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class BaseDomain : public ExposedType
{
public:   
    // Hash table that maps a clsid to a EEClass
    PtrHashMap          m_clsidHash;

    BYTE                m_LowFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_HighFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_StubHeapInstance[sizeof(LoaderHeap)];
    LoaderHeap *        m_pLowFrequencyHeap;
    LoaderHeap *        m_pHighFrequencyHeap;
    LoaderHeap *        m_pStubHeap;

    // The domain critical section.
    Crst *m_pDomainCrst;

    // Hash tables that map a UTF8 and a Unicode string to a COM+ string handle.
    EEUnicodeStringHashTable    *m_pUnicodeStringConstToHandleMap;

    // The static container critical section.
    Crst *m_pStaticContainerCrst;

    // The string hash table version.
    int m_StringHashTableVersion;

    // Static container COM+ object that contains the actual COM+ string objects.
    OBJECTHANDLE                m_hndStaticContainer;

    EEMarshalingData            *m_pMarshalingData; 

    ArrayList          m_Assemblies;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


typedef enum AttachAppDomainEventsEnum
{
    SEND_ALL_EVENTS,
    ONLY_SEND_APP_DOMAIN_CREATE_EVENTS,
    DONT_SEND_CLASS_EVENTS,
    ONLY_SEND_CLASS_EVENTS
} AttachAppDomainEventsEnum;


// Forward reference
class SystemDomain;
class ComCallWrapperCache;
class DomainLocalBlock
{
public:
    AppDomain        *m_pDomain;
    SIZE_T            m_cSlots;
    SIZE_T           *m_pSlots;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class AppDomain : public BaseDomain
{
public:
    Assembly*          m_pRootAssembly; // Used by the shell host to set the application (do not delete or release)
    AppDomain*         m_pSibling;    // Sibling

    // GUID to uniquely identify this AppDomain - used by the AppDomain publishing
    // service (to publish the list of all appdomains present in the process), 
    // which in turn is used by, for eg., the debugger (to decide which App-
    // Domain(s) to attach to).
    GUID            m_guid;

    // General purpose flags. 
    DWORD           m_dwFlags;

    // When an application domain is created the ref count is artifically incremented
    // by one. For it to hit zero an explicit close must have happened.
    ULONG       m_cRef;                    // Ref count.

    ApplicationSecurityDescriptor *m_pSecDesc;  // Application Security Descriptor


    OBJECTHANDLE    m_AppDomainProxy;   // Handle to the proxy object for this appdomain

    // The wrapper cache for this domain - it has it's onw CCacheLineAllocator on a per domain basis
    // to allow the domain to go away and eventually kill the memory when all refs are gone
    ComCallWrapperCache *m_pComCallWrapperCache;

    IApplicationContext* m_pFusionContext; // Binding context for the application

    LPWSTR             m_pwzFriendlyName;

    AssemblySink*      m_pAsyncPool;  // asynchronous retrival object pool (only one is kept)

    // The index of this app domain starting from 1
    DWORD m_dwIndex;
    
    DomainLocalBlock   *m_pDomainLocalBlock;
    
    DomainLocalBlock    m_sDomainLocalBlock;

    // The count of the number of threads that have entered this AD
    ULONG m_dwThreadEnterCount;

    // Class loader locks
    // DeadlockAwareListLock     m_ClassInitLock;
    
    // The method table used for unknown COM interfaces. The initial MT is created
    // in the system domain and copied to each active domain.
    MethodTable*    m_pComObjectMT;  // global method table for ComObject class

    Context *m_pDefaultContext;
    
    void Fill(DWORD_PTR & dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class SystemDomain : public BaseDomain
{
public:
    Assembly*   m_pSystemAssembly;  // Single assembly (here for quicker reference);
    AppDomain*  m_pChildren;        // Children domain
    AppDomain*  m_pCOMDomain;       // Default domain for COM+ classes exposed through IClassFactory.
    AppDomain*  m_pPool;            // Created and pooled objects
    EEClass*    m_pBaseComObjectClass; // The default wrapper class for COM
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class SharedDomain : public BaseDomain
{
    public:
    
    struct DLSRecord
    {
      Module *pModule;
      DWORD   DLSBase;
    };
    
    SIZE_T                  m_nextClassIndex;
    HashMap                 m_assemblyMap;
    
    DLSRecord               *m_pDLSRecords;
    DWORD                   m_cDLSRecords;
    DWORD                   m_aDLSRecords;
    
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class EEScopeClassHashTable;
class EEClassHashTable;
class ArrayClass;

class ClassLoader
{
public:
    // Classes for which load is in progress
    EEScopeClassHashTable * m_pUnresolvedClassHash;
    CRITICAL_SECTION    m_UnresolvedClassLock;

    // Protects linked list of Modules loaded by this loader
    CRITICAL_SECTION    m_ModuleListCrst; 

    // Hash of available classes by name to Module or EEClass
    EEClassHashTable  * m_pAvailableClasses;

    // Cannoically-cased hashtable of the available class names for 
    // case insensitive lookup.  Contains pointers into 
    // m_pAvailableClasses.
    EEStringHashTable * m_pAvailableClassesCaseIns;

    // Protects addition of elements to m_pAvailableClasses
    CRITICAL_SECTION    m_AvailableClassLock;

    // Converter module for this loader (may be NULL if we haven't converted a file yet)
    CorModule   *   m_pConverterModule;

    // Have we created all of the critical sections yet?
    BOOL                m_fCreatedCriticalSections;

    // Hash table that maps a clsid to a EEClass
    PtrHashMap*         m_pclsidHash;

    // List of ArrayClasses loaded by this loader
    // This list is protected by m_pAvailableClassLock
    ArrayClass *        m_pHeadArrayClass;

    // Back reference to the assembly
    Assembly*           m_pAssembly;
    
    // Converter module needs to access these - enforces single-threaded conversion of class files
    // within this loader (and instance of the ClassConverter)
    CRITICAL_SECTION    m_ConverterModuleLock;

    // Next classloader in global list
    ClassLoader *       m_pNext; 

    // Head of list of modules loaded by this loader
    Module *            m_pHeadModule;

#if 0
//#ifdef _DEBUG
    DWORD               m_dwDebugMethods;
    DWORD               m_dwDebugFieldDescs; // Doesn't include anything we don't allocate a FieldDesc for
    DWORD               m_dwDebugClasses;
    DWORD               m_dwDebugDuplicateInterfaceSlots;
    DWORD               m_dwDebugArrayClassRefs;
    DWORD               m_dwDebugArrayClassSize;
    DWORD               m_dwDebugConvertedSigSize;
    DWORD               m_dwGCSize;
    DWORD               m_dwInterfaceMapSize;
    DWORD               m_dwMethodTableSize;
    DWORD               m_dwVtableData;
    DWORD               m_dwStaticFieldData;
    DWORD               m_dwFieldDescData;
    DWORD               m_dwMethodDescData;
    DWORD               m_dwEEClassData;
#endif
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

const int CODEMAN_STATE_SIZE = 256;

struct CodeManState
{
    DWORD       dwIsSet; // Is set to 0 by the stackwalk as appropriate
    BYTE        stateBuf[CODEMAN_STATE_SIZE];
};

class ICodeManager;
typedef struct _REGDISPLAY {
    PCONTEXT pContext;          // points to current Context; either
                                // returned by GetContext or provided
                                // at exception time.

    DWORD * pEdi;
    DWORD * pEsi;
    DWORD * pEbx;
    DWORD * pEdx;
    DWORD * pEcx;
    DWORD * pEax;

    DWORD * pEbp;
    DWORD   Esp;
    DWORD * pPC;                // processor neutral name

} REGDISPLAY;
typedef REGDISPLAY *PREGDISPLAY;
struct _METHODTOKEN {};
typedef struct _METHODTOKEN * METHODTOKEN;
class EE_ILEXCEPTION;
class IJitManager;

class CrawlFrame {
    public:
          CodeManState      codeManState;

          bool              isFrameless;
          bool              isFirst;
          bool              isInterrupted;
          bool              hasFaulted;
          bool              isIPadjusted;
          Frame            *pFrame;
          MethodDesc       *pFunc;
          // the rest is only used for "frameless methods"
          ICodeManager     *codeMgrInstance;
//#if JIT_OR_NATIVE_SUPPORTED
          PREGDISPLAY       pRD; // "thread context"/"virtual register set"
          METHODTOKEN       methodToken;
          unsigned          relOffset;
          //LPVOID            methodInfo;
          EE_ILEXCEPTION   *methodEHInfo;
          IJitManager      *JitManagerInstance;
//#endif

};

class CRWLock
{
public:
    // Private data
    DWORD_PTR _pMT;
    HANDLE _hWriterEvent;
    HANDLE _hReaderEvent;
    volatile DWORD _dwState;
    DWORD _dwULockID;
    DWORD _dwLLockID;
    DWORD _dwWriterID;
    DWORD _dwWriterSeqNum;
    WORD _wFlags;
    WORD _wWriterLevel;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// For FJIT
typedef struct {
    MethodDesc *    pMethodDescriptor;
} CodeHeader;

//Type info not exist in pdb
struct JittedMethodInfo {
    BYTE      JmpInstruction[5]  ;          // this is the start address that is exposed to the EE so it can
                                            // patch all the vtables, etc. It contains a jump to the real start.
    // TODO: adding preBit here.  We need EHInfoExists.
    struct {
        __int8 JittedMethodPitched: 1 ;   // if 1, the jitted method has been pitched
        __int8 MarkedForPitching  : 1 ;   // if 1, the jitted method is scheduled to be pitched, but has not been pitched yet
        __int8 EHInfoExists       : 1 ;   // if 0, no exception info in this method 
        __int8 GCInfoExists       : 1 ;   // if 0, no gc info in this method
        __int8 EHandGCInfoPitched : 1 ;   // (if at least one of EHInfo or GCInfo exists) if 1, the info has been pitched
        __int8 Unused             : 3 ;
    } flags;
    unsigned short EhGcInfo_len;
    union {
        MethodDesc* pMethodDescriptor;      // If code pitched
        CodeHeader* pCodeHeader;            // If not pitched : points to code header which points to the methoddesc. Code begins after the code header
    } u1;
    union {
        BYTE*       pEhGcInfo;        // If code pitched: points to beginning of EH/GC info
        BYTE*       pCodeEnd;               // If not pitched : points to end of jitted code for this method. 
    } u2;
};

struct Fjit_hdrInfo
{
    size_t              methodSize;
    unsigned short      methodFrame;      /* includes all save regs and security obj, units are sizeof(void*) */
    unsigned short      methodArgsSize;   /* amount to pop off in epilog */
    unsigned short      methodJitGeneratedLocalsSize; /* number of jit generated locals in method */
    unsigned char       prologSize;
    unsigned char       epilogSize;
    bool                hasThis;
	bool				EnCMode;		   /* has been compiled in EnC mode */
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class IJitCompiler;

class IJitManager 
{
public:
    // The calls onto the jit!
    IJitCompiler           *m_jit;
    IJitManager           *m_next;

    DWORD           m_CodeType;
    BOOL            m_IsDefaultCodeMan;
    ICodeManager*   m_runtimeSupport;
    HINSTANCE       m_JITCompiler;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};


class EEJitManager :public IJitManager
{
public:
    HeapList    *m_pCodeHeap;
    Crst        *m_pCodeHeapCritSec;
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// Allocation header prepended to allocated memory.
struct PerfAllocHeader {
    unsigned         m_Length;           // Length of user data in packet
    PerfAllocHeader *m_Next;             // Next packet in chain of live allocations
    PerfAllocHeader *m_Prev;             // Previous packet in chain of live allocations
    void            *m_AllocEIP;         // EIP of allocator

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class PerfAllocVars
{
public:
    PerfAllocHeader    *g_AllocListFirst;
    DWORD               g_PerfEnabled;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// The "blob" you get to store in the hash table

typedef void* HashDatum;

// The heap that you want the allocation to be done in

typedef void* AllocationHeap;

// Used inside Thread class to chain all events that a thread is waiting for by Object::Wait
struct WaitEventLink {
    SyncBlock      *m_WaitSB;
    HANDLE          m_EventWait;
    Thread         *m_Thread;       // Owner of this WaitEventLink.
    WaitEventLink  *m_Next;         // Chain to the next waited SyncBlock.
    SLink           m_LinkSB;       // Chain to the next thread waiting on the same SyncBlock.
    DWORD           m_RefCount;     // How many times Object::Wait is called on the same SyncBlock.
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// One of these is present for each element in the table.
// Update the SIZEOF_EEHASH_ENTRY macro below if you change this
// struct

struct EEHashEntry
{
    struct EEHashEntry *pNext;
    DWORD               dwHashValue;
    HashDatum           Data;
    BYTE                Key[1]; // The key is stored inline
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

// The key[1] is a place holder for the key. sizeof(EEHashEntry) 
// return 16 bytes since it packs the struct with 3 bytes. 
#define SIZEOF_EEHASH_ENTRY (sizeof(EEHashEntry) - 4)

struct BucketTable {
    EEHashEntry **  m_pBuckets;
    DWORD           m_dwNumBuckets;
};

class EEHashTable
{
public:
    EEHashEntry   **m_pBuckets;    // Pointer to first entry for each bucket
  
    DWORD           m_dwNumBuckets;
    BucketTable*    m_pVolatileBucketTable;
    DWORD           m_dwNumEntries;
	AllocationHeap  m_Heap;
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

#ifndef _WIN64
    
    // Win32 - 64k reserved per segment with 4k as header
    #define HANDLE_SEGMENT_SIZE     (0x10000)   // MUST be a power of 2
    #define HANDLE_HEADER_SIZE      (0x1000)    // SHOULD be <= OS page size

#else

    // Win64 - 128k reserved per segment with 4k as header
    #define HANDLE_SEGMENT_SIZE     (0x20000)   // MUST be a power of 2
    #define HANDLE_HEADER_SIZE      (0x1000)    // SHOULD be <= OS page size

#endif

#define HANDLE_HANDLES_PER_BLOCK    (64)        // segment suballocation granularity

typedef size_t * _UNCHECKED_OBJECTREF;

#define HANDLE_SIZE                     sizeof(_UNCHECKED_OBJECTREF)
#define HANDLE_HANDLES_PER_SEGMENT      ((HANDLE_SEGMENT_SIZE - HANDLE_HEADER_SIZE) / HANDLE_SIZE)
#define HANDLE_BLOCKS_PER_SEGMENT       (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_BLOCK)
//#define HANDLE_CLUMPS_PER_SEGMENT       (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_CLUMP)
//#define HANDLE_CLUMPS_PER_BLOCK         (HANDLE_HANDLES_PER_BLOCK / HANDLE_HANDLES_PER_CLUMP)
//#define HANDLE_BYTES_PER_BLOCK          (HANDLE_HANDLES_PER_BLOCK * HANDLE_SIZE)
//#define HANDLE_HANDLES_PER_MASK         (sizeof(DWORD32) * BITS_PER_BYTE)
#define HANDLE_MASKS_PER_SEGMENT        (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_MASK)
//#define HANDLE_MASKS_PER_BLOCK          (HANDLE_HANDLES_PER_BLOCK / HANDLE_HANDLES_PER_MASK)
//#define HANDLE_CLUMPS_PER_MASK          (HANDLE_HANDLES_PER_MASK / HANDLE_HANDLES_PER_CLUMP)

/*
 * we need byte packing for the handle table layout to work
 */
#pragma pack(push)
#pragma pack(1)

/*
 * Table Segment Header
 *
 * Defines the layout for a segment's header data.
 */
struct _TableSegmentHeader
{
    /*
     * Block Handle Types
     *
     * Each slot holds the handle type of the associated block.
     */
    BYTE rgBlockType[HANDLE_BLOCKS_PER_SEGMENT];

    /*
     * Next Segment
     *
     * Points to the next segment in the chain (if we ran out of space in this one).
     */
    struct TableSegment *pNextSegment;

    /*
     * Empty Line
     *
     * Index of the first KNOWN block of the last group of unused blocks in the segment.
     */
    BYTE bEmptyLine;
};


/*
 * Table Segment
 *
 * Defines the layout for a handle table segment.
 */
struct TableSegment : public _TableSegmentHeader
{
    /*
     * Handles
     */
    size_t rgValue[HANDLE_HANDLES_PER_SEGMENT];
    size_t firstHandle;
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

/*
 * restore default packing
 */
#pragma pack(pop)

/*
 * Handle Table
 *
 * Defines the layout of a handle table object.
 */
struct HandleTable
{
    /*
     * head of segment list for this table
     */
    TableSegment *pSegmentList;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

typedef HANDLE HHANDLETABLE;

struct HandleTableMap
{
    HHANDLETABLE            *pTable;
    struct HandleTableMap   *pNext;
    DWORD                    dwMaxIndex;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

#define EEPtrHashTable EEHashTable

class ComPlusApartmentCleanupGroup
{
public:
    // Hashtable that maps from a context cookie to a list of ctx clean up groups.
    EEPtrHashTable m_CtxCookieToContextCleanupGroupMap;

    Thread *       m_pSTAThread;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class ComPlusWrapper;
enum {CLEANUP_LIST_GROUP_SIZE = 256};
class ComPlusContextCleanupGroup
{
public:
    ComPlusContextCleanupGroup *        m_pNext;
    ComPlusWrapper *                    m_apWrapper[CLEANUP_LIST_GROUP_SIZE];
    DWORD                               m_dwNumWrappers;
    //CtxEntry *                          m_pCtxEntry;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

class ComPlusWrapperCleanupList
{
public:
    // Hashtable that maps from a context cookie to a list of apt clean up groups.
    EEPtrHashTable                  m_STAThreadToApartmentCleanupGroupMap;

    ComPlusApartmentCleanupGroup *  m_pMTACleanupGroup;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct VMHELPDEF
{
public:
    void * pfnHelper;
    
    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

struct WorkRequest {
    WorkRequest*            next;
    LPTHREAD_START_ROUTINE  Function; 
    PVOID                   Context;

    void Fill(DWORD_PTR &dwStartAddr);
    static ULONG GetFieldOffset(const char *field);
    static ULONG SetupTypeOffset (SYM_OFFSET **symoffset, size_t *nEntry);
    static ULONG size();
};

#endif // _strikeEE_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __util_h__
#define __util_h__

#include "eestructs.h"

#define MAX_CLASSNAME_LENGTH    1024

#ifdef _IA64_
#define OS_PAGE_SIZE   8192
#else
#define OS_PAGE_SIZE   4096
#endif

enum JitType {UNKNOWN=0, JIT, EJIT, PJIT};
enum EEFLAVOR {UNKNOWNEE, MSCOREE, MSCORWKS, MSCORSVR,MSCOREND};

void FileNameForModule (Module *pModule, WCHAR *fileName);
void FileNameForHandle (HANDLE handle, WCHAR *fileName);
void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead);
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType,
                    DWORD_PTR &gcinfoAddr);
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset);
char *ElementTypeName (unsigned type);
void DisplayFields (EEClass *pEECls,
                    DWORD_PTR dwStartAddr = 0, BOOL bFirst=TRUE);
void NameForToken(Module *pModule, mdTypeDef mb, WCHAR *mdName,
                  bool bClassName=true);
HRESULT NameForToken(mdTypeDef mb, IMetaDataImport *pImport, WCHAR *mdName,
                     bool bClassName);

#ifndef UNDER_CE
VOID
DllsName(
    ULONG_PTR addrContaining,
    WCHAR *dllName
    );
VOID
MatchDllsName (WCHAR *wname, WCHAR *dllName, ULONG64 base);
#endif

#define safemove(dst, src) \
SafeReadMemory ((ULONG_PTR) (src), &(dst), sizeof(dst), NULL)

#define safemove_ret(dst, src) \
if (safemove(dst, src) == 0)   \
    return 0;

class ToDestroy
{
public:
    ToDestroy(void **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroy()
    {
        if (*mem)
        {
            free (*mem);
            *(DWORD_PTR**)mem = NULL;
        }
    }
private:
    void **mem;
};

template <class A>
class ToDestroyCxx
{
public:
    ToDestroyCxx(A **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroyCxx()
    {
        if (*mem)
        {
            delete *mem;
            *mem = NULL;
        }
    }
private:
    A **mem;
};

template <class A>
class ToDestroyCxxArray
{
public:
    ToDestroyCxxArray(A **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroyCxxArray()
    {
        if (*mem)
        {
            delete[] *mem;
            *mem = NULL;
        }
    }
private:
    A **mem;
};

struct ModuleInfo
{
    ULONG64 baseAddr;
    BOOL hasPdb;
};
extern ModuleInfo moduleInfo[];

BOOL HaveToFixThreadSymbol();
BOOL IsServerBuild ();
BOOL IsDebugBuildEE ();
BOOL IsRetailBuild (size_t base);
EEFLAVOR GetEEFlavor ();
BOOL IsDumpFile ();
BOOL IsMiniDumpFile ();
BOOL SafeReadMemory (ULONG_PTR offset, PVOID lpBuffer, ULONG_PTR cb,
                     PULONG lpcbBytesRead);
void NameForMD (MethodDesc *pMD, WCHAR *mdName);
void NameForMT (DWORD_PTR MTAddr, WCHAR *mdName);
void NameForMT (MethodTable &vMethTable, WCHAR *mdName);
void NameForObject (DWORD_PTR ObjAddr, WCHAR *mdName);
void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled);
void GetMethodTable(DWORD MDAddr, DWORD_PTR &methodTable);
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR = FALSE, DWORD_PTR length=-1,
    WCHAR *buffer = NULL);
void NameForEEClass (EEClass *pEECls, WCHAR *mdName);
void FileNameForMT (MethodTable *pMT, WCHAR *fileName);
DWORD_PTR GetValueFromExpression (char *str);
void* operator new(size_t, void* p);
void DomainInfo (AppDomain *pDomain);
void SharedDomainInfo (DWORD_PTR DomainAddr);
void AssemblyInfo (Assembly *pAssembly);
void ClassLoaderInfo (ClassLoader *pClsLoader);

DWORD_PTR LoaderHeapInfo (LoaderHeap *pLoaderHeap);
DWORD_PTR JitHeapInfo ();

class HeapStat
{
protected:
    struct Node
    {
        DWORD_PTR MT;
        DWORD count;
        DWORD totalSize;
        Node* left;
        Node* right;
        Node ()
            : MT(0), count(0), totalSize(0), left(NULL), right(NULL)
        {
        }
    };
    Node *head;
public:
    HeapStat ()
        : head(NULL)
    {}
    void Add (DWORD_PTR aMT, DWORD aSize);
    void Sort ();
    void Print ();
    void Delete ();
private:
    void SortAdd (Node *&root, Node *entry);
    void LinearAdd (Node *&root, Node *entry);
    void ReverseLeftMost (Node *root);
};

extern HeapStat *stat;

struct DumpHeapFlags
{
    DWORD_PTR min_size;
    DWORD_PTR max_size;
    BOOL bStatOnly;
    BOOL bFixRange;
    DWORD_PTR startObject;
    DWORD_PTR endObject;
    DWORD_PTR MT;
    
    DumpHeapFlags ()
        : min_size(0), max_size(-1), bStatOnly(FALSE), bFixRange(FALSE),
          startObject(0), endObject(0), MT(0)
    {}
};

struct AllocInfo
{
    alloc_context *array;
    int num;
};

BOOL IsSameModuleName (const char *str1, const char *str2);
BOOL IsModule (DWORD_PTR moduleAddr);
BOOL IsMethodDesc (DWORD_PTR value);
BOOL IsMethodTable (DWORD_PTR value);
BOOL IsEEClass (DWORD_PTR value);
BOOL IsObject (size_t obj);
void ModuleFromName(DWORD_PTR * &vModule, LPSTR mName, int &numModule);
void GetInfoFromName(Module &vModule, const char* name);
void GetInfoFromModule (Module &vModule, ULONG token, DWORD_PTR *ret=NULL);
void GCHeapInfo(gc_heap &heap, DWORD_PTR &total_size);
void GCHeapDump(gc_heap &heap, DWORD_PTR &nObj, DumpHeapFlags &flags,
                AllocInfo* pallocInfo);

void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &codeInfo,
                            BOOL bSimple = TRUE);

DWORD_PTR MTForObject();
DWORD_PTR MTForFreeObject();
DWORD_PTR MTForString();
DWORD_PTR MTForFreeObj();

int MD_IndexOffset ();
int MD_SkewOffset ();

void DumpMDInfo(DWORD_PTR dwStartAddr);
void GetDomainList (DWORD_PTR *&domainList, int &numDomain);
void GetThreadList (DWORD_PTR *&threadList, int &numThread);

void ReloadSymbolWithLineInfo();

JitType GetJitType (DWORD_PTR Jit_vtbl);

size_t FunctionType (size_t EIP);
void GetVersionString (WCHAR *version);

size_t Align (size_t nbytes);

size_t OSPageSize ();
size_t NextOSPageAddress (size_t addr);

size_t ObjectSize (DWORD_PTR obj);
void StringObjectContent (size_t obj, BOOL fLiteral=FALSE, const int length=-1);  // length=-1: dump everything in the string object.

void FindGCRoot (size_t obj);
void FindAllRootSize ();
void FindObjSize (size_t obj);

enum ARGTYPE {COBOOL,COSIZE_T,COHEX};
struct CMDOption
{
    const char* name;
    void *vptr;
    ARGTYPE type;
    BOOL hasValue;
    BOOL hasSeen;
};
struct CMDValue
{
    void *vptr;
    ARGTYPE type;
};
BOOL GetCMDOption(const char *string, CMDOption *option, size_t nOption,
                  CMDValue *arg, size_t maxArg, size_t *nArg);

DWORD ComPlusAptCleanupGroupInfo(ComPlusApartmentCleanupGroup *groupr, BOOL bDetail);

ULONG TargetPlatform();
ULONG DebuggeeType();

inline BOOL IsKernelDebugger ()
{
    return DebuggeeType() == DEBUG_CLASS_KERNEL;
}

typedef enum CorElementTypeInternal
{
    ELEMENT_TYPE_VAR_INTERNAL            = 0x13,     // a type variable VAR <U1>

    ELEMENT_TYPE_VALUEARRAY_INTERNAL     = 0x17,     // VALUEARRAY <type> <bound>

    ELEMENT_TYPE_R_INTERNAL              = 0x1A,     // native real size

    ELEMENT_TYPE_GENERICARRAY_INTERNAL   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

} CorElementTypeInternal;

#define ELEMENT_TYPE_VAR           ((CorElementType) ELEMENT_TYPE_VAR_INTERNAL          )
#define ELEMENT_TYPE_VALUEARRAY    ((CorElementType) ELEMENT_TYPE_VALUEARRAY_INTERNAL   )
#define ELEMENT_TYPE_R             ((CorElementType) ELEMENT_TYPE_R_INTERNAL            )
#define ELEMENT_TYPE_GENERICARRAY  ((CorElementType) ELEMENT_TYPE_GENERICARRAY_INTERNAL )

extern IMetaDataImport* MDImportForModule (Module *pModule);

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
template <DWORD SIZE, DWORD INCREMENT> 
class CQuickBytesBase
{
public:
    CQuickBytesBase() :
        pbBuff(0),
        iSize(0),
        cbTotal(SIZE)
    { }

    void Destroy()
    {
        if (pbBuff)
        {
            free(pbBuff);
            pbBuff = 0;
        }
    }

    void *Alloc(SIZE_T iItems)
    {
        iSize = iItems;
        if (iItems <= SIZE)
        {
            cbTotal = SIZE;
            return (&rgData[0]);
        }
        else
        {
            if (pbBuff) free(pbBuff);
            pbBuff = malloc(iItems);
            cbTotal = pbBuff ? iItems : 0;
            return (pbBuff);
        }
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        void *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return NOERROR;
        }

        pbBuffNew = malloc(iItems + INCREMENT);
        if (!pbBuffNew)
            return E_OUTOFMEMORY;
        if (pbBuff) 
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            free(pbBuff);
        }
        else
        {
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + INCREMENT;
        iSize = iItems;
        pbBuff = pbBuffNew;
        return NOERROR;
        
    }

    operator PVOID()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    void *Ptr()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    SIZE_T Size()
    { return (iSize); }

    SIZE_T MaxSize()
    { return (cbTotal); }

    void Maximize()
    { 
        HRESULT hr = ReSize(MaxSize());
        _ASSERTE(hr == NOERROR);
    }

    void        *pbBuff;
    SIZE_T      iSize;              // number of bytes used
    SIZE_T      cbTotal;            // total bytes allocated in the buffer
    BYTE        rgData[SIZE];
};

#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

class CQuickBytesNoDtor : public CQuickBytesBase<CQUICKBYTES_BASE_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

class CQuickBytes : public CQuickBytesNoDtor
{
public:
    CQuickBytes() { }

    ~CQuickBytes()
    {
        Destroy();
    }
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesNoDtorSpecifySize : public CQuickBytesBase<CQUICKBYTES_BASE_SPECIFY_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesSpecifySize : public CQuickBytesNoDtorSpecifySize<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
public:
    CQuickBytesSpecifySize() { }

    ~CQuickBytesSpecifySize()
    {
        Destroy();
    }
};


#define STRING_SIZE 10
class CQuickString : public CQuickBytesBase<STRING_SIZE, STRING_SIZE> 
{
public:
    CQuickString() { }

    ~CQuickString()
    {
        Destroy();
    }
    
    void *Alloc(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Alloc(iItems*sizeof(WCHAR));
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::ReSize(iItems * sizeof(WCHAR));
    }

    SIZE_T Size()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Size() / sizeof(WCHAR);
    }

    SIZE_T MaxSize()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::MaxSize() / sizeof(WCHAR);
    }

    WCHAR* String()
    {
        return (WCHAR*) Ptr();
    }

};

void FullNameForMD(MethodDesc *pMD, CQuickBytes *fullName);

BOOL IsDebuggeeInNewState ();

BOOL GetDllMetaData (size_t base, PVOID *ppMetaData, long *pcbMetaData);
#endif // __util_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"strike.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft NTSD extension for .NET Runtime\0"
#define VER_ORIGFILENAME_STR    "strike.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\utilia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"


void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &codeInfo, BOOL bSimple)
{
    dprintf("CodeInfoForMethodDesc not yet implemented\n");

    codeInfo.IPBegin    = 0;
    codeInfo.methodSize = 0;
    codeInfo.jitType    = UNKNOWN;
    
    size_t ip = MD.m_CodeOrIL;

    //
    // @todo: handle case where m_CodeOrIL points to the prestub in front 
    //        of the method desc
    //

    DWORD_PTR methodDesc;
    IP2MethodDesc(ip, methodDesc, codeInfo.jitType, codeInfo.gcinfoAddr);
    if (!methodDesc || codeInfo.jitType == UNKNOWN)
    {
        dprintf("Not jitted code\n");
        return;
    }

    if (codeInfo.jitType == JIT || codeInfo.jitType == PJIT)
    {
        
    }
    else if (codeInfo.jitType == EJIT)
    {
    }    

    codeInfo.IPBegin = ip;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\symbol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __symbol_h__
#define __symbol_h__

struct SYM_OFFSET
{
    char *name;
    ULONG offset;
};
    
/* Fill a member of a class if the offset for the symbol exists. */
#define FILLCLASSMEMBER(symOffset, symCount, member, addr)        \
{                                                                 \
    size_t n;                                                     \
    for (n = 0; n < symCount; n ++)                               \
    {                                                             \
        if (strcmp (#member, symOffset[n].name) == 0)             \
        {                                                         \
            if (symOffset[n].offset == -1)                        \
            {                                                     \
                /*dprintf ("offset not exist for %s\n", #member);*/   \
                break;                                            \
            }                                                     \
            memset(&member,sizeof(member),0);                                           \
            move (member, addr+symOffset[n].offset);              \
            break;                                                \
        }                                                         \
    }                                                             \
                                                                  \
    if (n == symCount)                                            \
    {                                                             \
        dprintf ("offset not found for %s\n", #member);           \
        /*return;*/                                               \
    }                                                             \
}

/* Fill a member of a class if the offset for the symbol exists. */
#define FILLCLASSBITMEMBER(symOffset, symCount, preBit, member, addr, size) \
{                                                                 \
    size_t n;                                                     \
    for (n = 0; n < symCount; n ++)                               \
    {                                                             \
        if (strcmp (#member, symOffset[n].name) == 0)             \
        {                                                         \
            if (symOffset[n].offset == -1)                        \
            {                                                     \
                dprintf ("offset not exist for %s\n", #member);   \
                break;                                            \
            }                                                     \
            int csize = size/8;                                   \
            if ((size % 8) != 0) {                                \
                 csize += 1;                                      \
            }                                                     \
            memset ((BYTE*)&preBit+sizeof(void*),csize,0);        \
            g_ExtData->ReadVirtual(                               \
                (ULONG64)addr+symOffset[n].offset,                \
                (BYTE*)&preBit+sizeof(void*),                     \
                csize, NULL);                                     \
            break;                                                \
        }                                                         \
    }                                                             \
                                                                  \
    if (n == symCount)                                            \
    {                                                             \
        dprintf ("offset not found for %s\n", #member);           \
        /*return;*/                                               \
    }                                                             \
}

DWORD_PTR GetSymbolType (const char* name, SYM_OFFSET *offset, int count);
ULONG Get1DArrayLength (const char *name);

// Get Name in a enum type for a constant.
// Will allocate buffer in EnumName if succeeds
void NameForEnumValue (const char *EnumType, DWORD_PTR EnumValue, char ** EnumName);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"
#include "gcinfo.h"
#include "disasm.h"
#include <dbghelp.h>

#define MAX_SYMBOL_LEN 4096
#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL) + MAX_SYMBOL_LEN)
char symBuffer[SYM_BUFFER_SIZE];
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;

JitType GetJitType (DWORD_PTR Jit_vtbl);

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the memory address given a symbol  *  
*    name.  It handles difference in symbol name between ntsd and      *
*    windbg.                                                           *
*                                                                      *
\**********************************************************************/
DWORD_PTR GetValueFromExpression (char *instr)
{
    ULONG64 dwAddr;
    char *str;
    char name[256];

    EEFLAVOR flavor = GetEEFlavor ();
    if (flavor == MSCOREE)
        str = instr;
    else if (flavor == UNKNOWNEE)
        return 0;
    else
    {
        if (_strnicmp (instr, "mscoree!", sizeof ("mscoree!")-1) != 0)
        {
            str = instr;
        }
        else
        {
            if (flavor == MSCORWKS)
            {
                strcpy (name, "mscorwks!");
            }
            else
            {
                strcpy (name, "mscorsvr!");
            }
            strcat (name, instr+sizeof("mscoree!")-1);
            str = name;
        }
    }

    dwAddr = 0;
    HRESULT hr = g_ExtSymbols->GetOffsetByName (str, &dwAddr);
    if (SUCCEEDED(hr))
        return (DWORD_PTR)dwAddr;
    else if (hr == S_FALSE && dwAddr)
        return (DWORD_PTR)dwAddr;

    strcpy (name, str);
    char *ptr;
    if ((ptr = strstr (name, "__")) != NULL)
    {
        ptr[0] = ':';
        ptr[1] = ':';
        ptr += 2;
        while ((ptr = strstr(ptr, "__")) != NULL)
        {
            ptr[0] = ':';
            ptr[1] = ':';
            ptr += 2;
        }
        dwAddr = 0;
        hr = g_ExtSymbols->GetOffsetByName (name, &dwAddr);
        if (SUCCEEDED(hr))
            return (DWORD_PTR)dwAddr;
        else if (hr == S_FALSE && dwAddr)
            return (DWORD_PTR)dwAddr;
    }
    else if ((ptr = strstr (name, "::")) != NULL)
    {
        ptr[0] = '_';
        ptr[1] = '_';
        ptr += 2;
        while ((ptr = strstr(ptr, "::")) != NULL)
        {
            ptr[0] = '_';
            ptr[1] = '_';
            ptr += 2;
        }
        dwAddr = 0;
        hr = g_ExtSymbols->GetOffsetByName (name, &dwAddr);
        if (SUCCEEDED(hr))
            return (DWORD_PTR)dwAddr;
        else if (hr == S_FALSE && dwAddr)
            return (DWORD_PTR)dwAddr;
    }
    return 0;
}

ModuleInfo moduleInfo[MSCOREND] = {{0,FALSE},{0,FALSE},{0,FALSE},{0,FALSE}};

BOOL CheckEEDll ()
{
    DEBUG_MODULE_PARAMETERS Params;

    static BOOL MscoreeDone = FALSE;
    static BOOL MscorwksDone = FALSE;
    static BOOL MscorsvrDone = FALSE;

#if 0
    if (!MscoreeDone) {
        MscoreeDone = TRUE;
    
        // Do we have mscoree.dll loaded?
        if (moduleInfo[MSCOREE].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscoree",0,NULL,
                                                     &moduleInfo[MSCOREE].baseAddr);
        if (moduleInfo[MSCOREE].baseAddr == 0)
            return TRUE;

        if (moduleInfo[MSCOREE].baseAddr != 0 && moduleInfo[MSCOREE].hasPdb == FALSE)
        {
            g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCOREE].baseAddr, 0, &Params);
            if (Params.SymbolType == SymDeferred)
            {
                g_ExtSymbols->Reload("/f mscoree.dll");
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCOREE].baseAddr, 0, &Params);
            }

            if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
            {
                moduleInfo[MSCOREE].hasPdb = TRUE;
            }
        }
        if (moduleInfo[MSCOREE].baseAddr != 0 && moduleInfo[MSCOREE].hasPdb == FALSE)
            dprintf ("PDB symbol for mscoree.dll not loaded\n");
    }
#endif
    
    if (!MscorwksDone) {
        MscorwksDone = TRUE;
    
        // Do we have mscorwks.dll or mscorsvr.dll
        if (moduleInfo[MSCORSVR].baseAddr == 0)
        {
            if (moduleInfo[MSCORWKS].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscorwks",0,NULL,
                                                     &moduleInfo[MSCORWKS].baseAddr);
            if (moduleInfo[MSCORWKS].baseAddr != 0 && moduleInfo[MSCORWKS].hasPdb == FALSE)
            {
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORWKS].baseAddr, 0, &Params);
                if (Params.SymbolType == SymDeferred)
                {
                    g_ExtSymbols->Reload("/f mscorwks.dll");
                    g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORWKS].baseAddr, 0, &Params);
                }

                if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
                {
                    moduleInfo[MSCORWKS].hasPdb = TRUE;
                }
            }
            if (moduleInfo[MSCORWKS].baseAddr != 0 && moduleInfo[MSCORWKS].hasPdb == FALSE)
                dprintf ("PDB symbol for mscorwks.dll not loaded\n");
            if (moduleInfo[MSCORWKS].baseAddr)
                return TRUE;
        }
    }

    if (!MscorsvrDone) {
        MscorsvrDone = TRUE;
    
        if (moduleInfo[MSCORWKS].baseAddr == 0)
        {
            if (moduleInfo[MSCORSVR].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscorsvr",0,NULL,
                                                     &moduleInfo[MSCORSVR].baseAddr);
            if (moduleInfo[MSCORSVR].baseAddr != 0 && moduleInfo[MSCORSVR].hasPdb == FALSE)
            {
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORSVR].baseAddr, 0, &Params);
                if (Params.SymbolType == SymDeferred)
                {
                    g_ExtSymbols->Reload("/f mscorsvr.dll");
                    g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORSVR].baseAddr, 0, &Params);
                }

                if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
                {
                    moduleInfo[MSCORSVR].hasPdb = TRUE;
                }
            }
            if (moduleInfo[MSCORSVR].baseAddr != 0 && moduleInfo[MSCORSVR].hasPdb == FALSE)
                dprintf ("PDB symbol for mscorsvr.dll not loaded\n");
        }
    }
    
    return TRUE;
}

EEFLAVOR GetEEFlavor ()
{
    static EEFLAVOR flavor = UNKNOWNEE;
    if (flavor != UNKNOWNEE)
        return flavor;
    
    if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName("mscorwks",0,NULL,NULL))) {
        flavor = MSCORWKS;
    }
    else if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName("mscorsvr",0,NULL,NULL))) {
        flavor = MSCORSVR;
    }
#if 0
    ULONG64 addr;
    if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscorwks!_CorExeMain", &addr)))
        flavor = MSCORWKS;
    else if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscorsvr!_CorExeMain", &addr)))
        flavor = MSCORSVR;
    else if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscoree!_CorExeMain", &addr)))
        flavor = MSCOREE;
#endif
    return flavor;
}

BOOL IsDumpFile ()
{
    static int g_fDumpFile = -1;
    if (g_fDumpFile == -1) {
        ULONG Class;
        ULONG Qualifier;
        g_ExtControl->GetDebuggeeType(&Class,&Qualifier);
        if (Qualifier)
            g_fDumpFile = 1;
        else
            g_fDumpFile = 0;
    }
    return g_fDumpFile != 0;
}

BOOL IsMiniDumpFile ()
{
    static int g_fMiniDumpFile = -1;
    if (g_fMiniDumpFile == -1) {
        ULONG Class;
        ULONG Qualifier;
        g_ExtControl->GetDebuggeeType(&Class,&Qualifier);
        if (Qualifier == DEBUG_DUMP_SMALL) {
            g_fMiniDumpFile = 1;
        }
        else
            g_fMiniDumpFile = 0;
    }
    return g_fMiniDumpFile != 0;
}

ULONG TargetPlatform()
{
    static ULONG platform = -1;
    if (platform == -1) {
        ULONG major;
        ULONG minor;
        ULONG SPNum;
        g_ExtControl->GetSystemVersion(&platform,&major,&minor,NULL,0,NULL,&SPNum,NULL,0,NULL);
    }
    return platform;
}

ULONG DebuggeeType()
{
    static ULONG Class = DEBUG_CLASS_UNINITIALIZED;
    if (Class == DEBUG_CLASS_UNINITIALIZED) {
        ULONG Qualifier;
        g_ExtControl->GetDebuggeeType(&Class,&Qualifier);
    }
    return Class;
}

// Check if a file exist
BOOL FileExist (const char *filename)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE handle = FindFirstFile (filename, &FindFileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose (handle);
        return TRUE;
    }
    else
        return FALSE;
}


BOOL FileExist (const WCHAR *filename)
{
    if (TargetPlatform() == VER_PLATFORM_WIN32_WINDOWS) {
        char filenameA[MAX_PATH+1];
        WideCharToMultiByte (CP_ACP,0,filename,-1,filenameA,MAX_PATH,0,NULL);
        filenameA[MAX_PATH] = '\0';
        return FileExist (filenameA);
    }
    WIN32_FIND_DATAW FindFileData;
    HANDLE handle = FindFirstFileW (filename, &FindFileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose (handle);
        return TRUE;
    }
    else
        return FALSE;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if runtime is checked build   *  
*                                                                      *
\**********************************************************************/
BOOL IsDebugBuildEE ()
{
    static int DebugVersionDll = -1;
    if (DebugVersionDll == -1)
    {
        if (GetValueFromExpression("mscoree!g_DbgEnabled") == 0)
            DebugVersionDll = 0;
        else
            DebugVersionDll = 1;
    }    
    return DebugVersionDll == 1;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if runtime is server build    *  
*                                                                      *
\**********************************************************************/
BOOL IsServerBuild ()
{
    return GetEEFlavor () == MSCORSVR;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if a dll is bbt-ized          *  
*                                                                      *
\**********************************************************************/
BOOL IsRetailBuild (size_t base)
{
    IMAGE_DOS_HEADER DosHeader;
    if (g_ExtData->ReadVirtual(base, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
        return FALSE;
    IMAGE_NT_HEADERS32 Header32;
    if (g_ExtData->ReadVirtual(base + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
        return FALSE;
    // If there is no COMHeader, this can not be managed code.
    if (Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress == 0)
        return FALSE;

    size_t debugDirAddr = base + Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    size_t nSize = Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    IMAGE_DEBUG_DIRECTORY debugDir;
    size_t nbytes = 0;
    while (nbytes < nSize) {
        if (g_ExtData->ReadVirtual(debugDirAddr+nbytes, &debugDir, sizeof(debugDir), NULL) != S_OK)
            return FALSE;
        if (debugDir.Type == 0xA) {
            return TRUE;
        }
        nbytes += sizeof(debugDir);
    }
    return FALSE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to read memory from the debugee's         *  
*    address space.  If the initial read fails, it attempts to read    *
*    only up to the edge of the page containing "offset".              *
*                                                                      *
\**********************************************************************/
BOOL SafeReadMemory (ULONG_PTR offset, PVOID lpBuffer, ULONG_PTR cb,
                     PULONG lpcbBytesRead)
{
    BOOL bRet = FALSE;

    bRet = SUCCEEDED(g_ExtData->ReadVirtual(offset, lpBuffer, cb,
                                            lpcbBytesRead));
    
    if (!bRet)
    {
        cb   = NextOSPageAddress(offset) - offset;
        bRet = SUCCEEDED(g_ExtData->ReadVirtual(offset, lpBuffer, cb,
                                                lpcbBytesRead));
    }
    return bRet;
}

size_t OSPageSize ()
{
    static ULONG pageSize = 0;
    if (pageSize == 0)
        g_ExtControl->GetPageSize(&pageSize);

    return pageSize;
}

size_t NextOSPageAddress (size_t addr)
{
    size_t pageSize = OSPageSize();
    return (addr+pageSize)&(~(pageSize-1));
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the address of MethodDesc          *  
*    given an ip address                                               *
*                                                                      *
\**********************************************************************/
// @todo - The following static was moved to file global to avoid the VC7
//         compiler problem with statics in functions containing trys.
//         When the next VC7 LKG comes out, these can be returned to the function
static DWORD_PTR pJMIT = 0;
// jitType: 1 for normal JIT generated code, 2 for EJIT, 0 for unknown
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType,
                    DWORD_PTR &gcinfoAddr)
{
    jitType = UNKNOWN;
    DWORD_PTR dwAddrString;
    methodDesc = 0;
    gcinfoAddr = 0;
    if (EEManager == NULL)
    {
        dwAddrString = GetValueFromExpression("MSCOREE!ExecutionManager__m_RangeTree");
        move(EEManager, dwAddrString);
    }
    RangeSection RS = {0};

    DWORD_PTR RSAddr = EEManager;
    while (RSAddr)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR dwAddr = RSAddr;
        RS.Fill (dwAddr);
        if (IP < RS.LowAddress)
            RSAddr = RS.pleft;
        else if (IP > RS.HighAddress)
            RSAddr = RS.pright;
        else
            break;
    }
    
    if (RSAddr == 0)
    {
        return;
    }

    DWORD_PTR JitMan = RS.pjit;

    DWORD_PTR vtbl;
    move (vtbl, JitMan);
    jitType = GetJitType (vtbl);
    
    // for EEJitManager
    if (jitType == JIT)
    {
        dwAddrString = JitMan + sizeof(DWORD_PTR)*7;
        DWORD_PTR HeapListAddr;
        move (HeapListAddr, dwAddrString);
        HeapList Hp;
        move (Hp, HeapListAddr);
        DWORD_PTR pCHdr = 0;
        while (1)
        {
            if (IsInterrupt())
                return;
            if (Hp.startAddress < IP && Hp.endAddress >= IP)
            {
                DWORD_PTR codeHead;
                FindHeader(Hp.pHdrMap, IP-Hp.mapBase, codeHead);
                if (codeHead == 0)
                {
                    dprintf ("fail in FindHeader\n");
                    return;
                }
                pCHdr = codeHead + Hp.mapBase;
                break;
            }
            if (Hp.hpNext == 0)
                break;
            move (Hp, Hp.hpNext);
        }
        if (pCHdr == 0)
        {
            return;
        }
        pCHdr += 2*sizeof(PVOID);
        move (methodDesc, pCHdr);

        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        dwAddr = vMD.m_CodeOrIL;

        // for EJit and Profiler, m_CodeOrIL has the address of a stub
        unsigned char ch;
        move (ch, dwAddr);
        if (ch == 0xe9)
        {
            int offsetValue;
            move (offsetValue, dwAddr + 1);
            dwAddr = dwAddr + 5 + offsetValue;
        }
        dwAddr = dwAddr - 3*sizeof(void*);
        move(gcinfoAddr, dwAddr);
    }
    else if (jitType == EJIT)
    {
        // First see if IP is the stub address

        if (pJMIT == 0)
            pJMIT = GetValueFromExpression ("MSCOREE!EconoJitManager__m_JittedMethodInfoHdr");

        DWORD_PTR vJMIT;
        // static for pJMIT moved to file static
        move (vJMIT, pJMIT);
#define PAGE_SIZE 0x1000
#define JMIT_BLOCK_SIZE PAGE_SIZE           // size of individual blocks of JMITs that are chained together                     
        while (vJMIT)
        {
            if (IsInterrupt())
                return;
            if (IP >= vJMIT && IP < vJMIT + JMIT_BLOCK_SIZE)
            {
                DWORD_PTR u1 = IP + 8;
                DWORD_PTR MD;
                move (u1, u1);
                if (u1 & 1)
                    MD = u1 & ~1;
                else
                    move (MD, u1);
                methodDesc = MD;
                return;
            }
            move (vJMIT, vJMIT);
        }
        
        signed low, mid, high;
        low = 0;
        static DWORD_PTR m_PcToMdMap_len = 0;
        static DWORD_PTR m_PcToMdMap = 0;
        if (m_PcToMdMap_len == 0)
        {
            m_PcToMdMap_len =
                GetValueFromExpression ("MSCOREE!EconoJitManager__m_PcToMdMap_len");
            m_PcToMdMap =
                GetValueFromExpression ("MSCOREE!EconoJitManager__m_PcToMdMap");
        }
        DWORD_PTR v_m_PcToMdMap_len;
        DWORD_PTR v_m_PcToMdMap;
        move (v_m_PcToMdMap_len, m_PcToMdMap_len);
        move (v_m_PcToMdMap, m_PcToMdMap);

        typedef struct {
            MethodDesc*     pMD;
            BYTE*           pCodeEnd;
        } PCToMDMap;
        high = (int)((v_m_PcToMdMap_len/ sizeof(PCToMDMap)) - 1);
        PCToMDMap vPCToMDMap;
        
        while (low < high) {
            if (IsInterrupt())
                return;
            mid = (low+high)/2;
            move (vPCToMDMap, v_m_PcToMdMap+mid*sizeof(PCToMDMap));
            if ( (unsigned) vPCToMDMap.pCodeEnd < IP ) {
                low = mid+1;
            }
            else {
                high = mid;
            }
        }
        move (vPCToMDMap, v_m_PcToMdMap+low*sizeof(PCToMDMap));
        methodDesc =  (DWORD_PTR)vPCToMDMap.pMD;
    }
    else if (jitType == PJIT)
    {
        DWORD_PTR codeHead;
        FindHeader (RS.ptable, IP-RS.LowAddress, codeHead);
        DWORD_PTR pCHdr = codeHead + RS.LowAddress;
        CORCOMPILE_METHOD_HEADER head;
        head.Fill(pCHdr);
        methodDesc = (DWORD_PTR)head.methodDesc;
        gcinfoAddr = (DWORD_PTR)head.gcInfo;
    }
    return;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Get the offset of curIP relative to the beginning of a MD method  *
*    considering if we JMP to the body of MD from m_CodeOrIL,        *  
*    e.g.  EJIT or Profiler                                            *
*                                                                      *
\**********************************************************************/
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset)
{
    DWORD_PTR IPBegin = pMD->m_CodeOrIL;
    GetCalleeSite (pMD->m_CodeOrIL, IPBegin);
    
    // If we have ECall, Array ECall, special method
    int mdType = (pMD->m_wFlags & mdcClassification)
        >> mdcClassificationShift;
    if (mdType == mcECall || mdType == mcArray || mdType == mcEEImpl)
    {
        offset = -1;
        return;
    }
    
    CodeInfo codeInfo;
    CodeInfoForMethodDesc (*pMD, codeInfo);

    offset = curIP - IPBegin;
    if (!(curIP >= IPBegin && offset <= codeInfo.methodSize))
        offset = -1;
}

#define NPDW  (sizeof(DWORD)*2)
#define ADDR2POS(x) ((x) >> 5)
#define ADDR2OFFS(x) ((((x)&0x1f)>> 2)+1)
#define POS2SHIFTCOUNT(x) (28 - (((x)%NPDW)<< 2))
#define POSOFF2ADDR(pos, of) (((pos) << 5) + (((of)-1)<< 2))

void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead)
{
    DWORD_PTR tmp;

    DWORD_PTR startPos = ADDR2POS(addr);    // align to 32byte buckets
                                            // ( == index into the array of nibbles)
    codeHead = 0;
    DWORD_PTR offset = ADDR2OFFS(addr);     // this is the offset inside the bucket + 1


    pMap += (startPos/NPDW)*sizeof(DWORD*);        // points to the proper DWORD of the map
                                    // get DWORD and shift down our nibble

    move (tmp, pMap);
    tmp = tmp >> POS2SHIFTCOUNT(startPos);


    // don't allow equality in the next check (tmp&0xf == offset)
    // there are code blocks that terminate with a call instruction
    // (like call throwobject), i.e. their return address is
    // right behind the code block. If the memory manager allocates
    // heap blocks w/o gaps, we could find the next header in such
    // cases. Therefore we exclude the first DWORD of the header
    // from our search, but since we call this function for code
    // anyway (which starts at the end of the header) this is not
    // a problem.
    if ((tmp&0xf) && ((tmp&0xf) < offset) )
    {
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // is there a header in the remainder of the DWORD ?
    tmp = tmp >> 4;

    if (tmp)
    {
        startPos--;
        while (!(tmp&0xf))
        {
            if (IsInterrupt())
                return;
            tmp = tmp >> 4;
            startPos--;
        }
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // we skipped the remainder of the DWORD,
    // so we must set startPos to the highest position of
    // previous DWORD

    startPos = (startPos/NPDW) * NPDW - 1;

    // skip "headerless" DWORDS

    pMap -= sizeof(DWORD*);
    move (tmp, pMap);
    while (!tmp)
    {
        if (IsInterrupt())
            return;
        startPos -= NPDW;
        pMap -= sizeof(DWORD*);
        move (tmp, pMap);
    }
    
    while (!(tmp&0xf))
    {
        if (IsInterrupt())
            return;
        tmp = tmp >> 4;
        startPos--;
    }

    codeHead = POSOFF2ADDR(startPos, tmp&0xf);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print a string beginning at strAddr.   *  
*    If buffer is non-NULL, print to buffer; Otherwise to screen.
*    If bWCHAR is true, treat the memory contents as WCHAR.            *
*    If length is not -1, it specifies the number of CHAR/WCHAR to be  *
*    read; Otherwise the string length is determined by NULL char.     *
*                                                                      *
\**********************************************************************/
// if buffer is not NULL, always convert to WCHAR
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR, DWORD_PTR length, WCHAR *buffer)
{
    if (buffer)
        buffer[0] = L'\0';
    DWORD len = 0;
    char name[256];
    DWORD totallen = 0;
    int gap;
    if (bWCHAR)
    {
        gap = 2;
        if (length != -1)
            length *= 2;
    }
    else
    {
        gap = 1;
    }
    while (1)
    {
        if (IsInterrupt())
            return;
        ULONG readLen = 256;
        if (IsInterrupt())
            return;
        if (!SafeReadMemory ((ULONG_PTR)strAddr + totallen, name, readLen,
                             &readLen))
            return;
            
        // move might return
        // move (name, (BYTE*)strAddr + totallen);
        if (length == -1)
        {
            for (len = 0; len <= 256u-gap; len += gap)
                if (name[len] == '\0' && (!bWCHAR || name[len+1] == '\0'))
                    break;
        }
        else
            len = 256;
        if (len == 256)
        {
            len -= gap;
            for (int n = 0; n < gap; n ++)
                name[255-n] = '\0';
        }
        if (bWCHAR)
        {
            if (buffer)
            {
                wcscat (buffer, (WCHAR*)name);
            }
            else
                dprintf ("%S", name);
        }
        else
        {
            if (buffer)
            {
                WCHAR temp[256];
                for (int n = 0; name[n] != '\0'; n ++)
                    temp[n] = name[n];
                temp[n] = L'\0';
                wcscat (buffer, temp);
            }
            else
                dprintf ("%s", name);
        }
        totallen += len;
        if (length != -1)
        {
            if (totallen >= length)
            {
                break;
            }
        }
        else if (len < 255 || totallen > 1024)
        {
            break;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the module name given a method    *  
*    table.  The name is stored in StringData.                         *
*                                                                      *
\**********************************************************************/
void FileNameForMT (MethodTable *pMT, WCHAR *fileName)
{
    fileName[0] = L'\0';
    DWORD_PTR addr = (DWORD_PTR)pMT->m_pModule;
    Module vModule;
    vModule.Fill (addr);
    FileNameForModule (&vModule, fileName);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of Methodtable for    *  
*    a given MethodDesc.                                               *
*                                                                      *
\**********************************************************************/
void GetMethodTable(DWORD_PTR MDAddr, DWORD_PTR &methodTable)
{
    methodTable = 0;
    DWORD_PTR pMT = MDAddr + MD_IndexOffset();
    char ch;
    move (ch, pMT);
    pMT = MDAddr + ch*MethodDesc::ALIGNMENT + MD_SkewOffset();
    move (methodTable, pMT);
    return;
}

void DisplayDataMember (FieldDesc* pFD, DWORD_PTR dwAddr, BOOL fAlign=TRUE)
{
    if (dwAddr > 0)
    {
        DWORD_PTR dwTmp = dwAddr;
        if (gElementTypeInfo[pFD->m_type] != -1)
        {
            union Value
            {
                char ch;
                short Short;
                DWORD_PTR ptr;
                int Int;
                unsigned int UInt;
                __int64 Int64;
                unsigned __int64 UInt64;
                float Float;
                double Double;
            } value;

            moveBlock (value, dwTmp, gElementTypeInfo[pFD->m_type]);
            switch (pFD->m_type) 
            {
                case ELEMENT_TYPE_I1:
                    if (fAlign)
                        dprintf ("%8d", value.ch);
                    else
                        dprintf ("%d", value.ch);
                    break;
                case ELEMENT_TYPE_I2:
                    if (fAlign)
                        dprintf ("%8d", value.Short);
                    else
                        dprintf ("%d", value.Short);
                    break;
                case ELEMENT_TYPE_I4:
                case ELEMENT_TYPE_I:
                    if (fAlign)
                        dprintf ("%8d", value.Int);
                    else
                        dprintf ("%d", value.Int);
                    break;
                case ELEMENT_TYPE_I8:
                    dprintf ("%I64d", value.Int64);
                    break;
                case ELEMENT_TYPE_U1:
                case ELEMENT_TYPE_BOOLEAN:
                    if (fAlign)
                        dprintf ("%8u", value.ch);
                    else
                        dprintf ("%u", value.ch);
                    break;
                case ELEMENT_TYPE_U2:
                    if (fAlign)
                        dprintf ("%8u", value.Short);
                    else
                        dprintf ("%u", value.Short);
                    break;
                case ELEMENT_TYPE_U4:
                case ELEMENT_TYPE_U:
                    if (fAlign)
                        dprintf ("%8u", value.UInt);
                    else
                        dprintf ("%u", value.UInt);
                    break;
                case ELEMENT_TYPE_U8:
                    dprintf ("%I64u", value.UInt64);
                    break;
                case ELEMENT_TYPE_R4:
                    dprintf ("%f", value.Float);
                    break;
                // case ELEMENT_TYPE_R:
                case ELEMENT_TYPE_R8:
                    dprintf ("%f", value.Double);
                    break;
                case ELEMENT_TYPE_CHAR:
                    if (fAlign)
                        dprintf ("%8x", value.Short);
                    else
                        dprintf ("%x", value.Short);
                    break;
                default:
                    dprintf ("%p", (ULONG64)value.ptr);
                    break;
            }
        }
        else
        {
            dprintf ("start at %p", (ULONG64)dwTmp);
        }
    }
    else
        dprintf ("%8s", " ");
}

void DisplaySharedStatic (FieldDesc *pFD, int offset)
{
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    AppDomain v_AppDomain;

    dprintf ("    >> Domain:Value");
    // Skip the SystemDomain and SharedDomain
    for (int i = 2; i < numDomain; i ++)
    {
        DWORD_PTR dwAddr = domainList[i];
        if (dwAddr == 0) {
            continue;
        }
        v_AppDomain.Fill (dwAddr);
        dwAddr = (DWORD_PTR)v_AppDomain.m_sDomainLocalBlock.m_pSlots;
        if (dwAddr == 0)
            continue;
        dwAddr += offset;
        
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if ((dwAddr&1) == 0) {
            // We have not initialized this yet.
            dprintf (" %p:NotInit ", (ULONG64)domainList[i]);
            continue;
        }
        else if (dwAddr & 2) {
            // We have not initialized this yet.
            dprintf (" %p:FailInit", (ULONG64)domainList[i]);
            continue;
        }
        dwAddr &= ~3;
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
        {
            // We have not initialized this yet.
            dprintf (" %p:UnInit2 ", (ULONG64)domainList[i]);
            continue;
        }
        dprintf (" %p:", (ULONG64)domainList[i]);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

void DisplayContextStatic (FieldDesc *pFD, int offset, BOOL fIsShared)
{
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    AppDomain vAppDomain;
    Context vContext;
    
    dprintf ("    >> Domain:Value");
    for (int i = 0; i < numDomain; i ++)
    {
        DWORD_PTR dwAddr = domainList[i];
        if (dwAddr == 0) {
            continue;
        }
        vAppDomain.Fill (dwAddr);
        if (vAppDomain.m_pDefaultContext == 0)
            continue;
        dwAddr = (DWORD_PTR)vAppDomain.m_pDefaultContext;
        vContext.Fill (dwAddr);
        
        if (fIsShared)
            dwAddr = (DWORD_PTR)vContext.m_pSharedStaticData;
        else
            dwAddr = (DWORD_PTR)vContext.m_pUnsharedStaticData;
        if (dwAddr == 0)
            continue;
        dwAddr += offsetof(STATIC_DATA, dataPtr);
        dwAddr += offset;
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        dprintf (" %p:", (ULONG64)domainList[i]);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

void DisplayThreadStatic (FieldDesc *pFD, int offset, BOOL fIsShared)
{
    int numThread;
    DWORD_PTR *threadList = NULL;
    GetThreadList (threadList, numThread);
    ToDestroy des0 ((void**)&threadList);
    Thread vThread;

    dprintf ("    >> Thread:Value");
    for (int i = 0; i < numThread; i ++)
    {
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_ThreadId == 0)
            continue;
        
        if (fIsShared)
            dwAddr = (DWORD_PTR)vThread.m_pSharedStaticData;
        else
            dwAddr = (DWORD_PTR)vThread.m_pUnsharedStaticData;
        if (dwAddr == 0)
            continue;
        dwAddr += offsetof(STATIC_DATA, dataPtr);
        dwAddr += offset;
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        dprintf (" %x:", vThread.m_ThreadId);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

char *ElementTypeName (unsigned type)
{
    switch (type) {
    case ELEMENT_TYPE_PTR:
        return "PTR";
        break;
    case ELEMENT_TYPE_BYREF:
        return "BYREF";
        break;
    case ELEMENT_TYPE_VALUETYPE:
        return "VALUETYPE";
        break;
    case ELEMENT_TYPE_CLASS:
        return "CLASS";
        break;
    case ELEMENT_TYPE_VAR:
        return "VAR";
        break;
    case ELEMENT_TYPE_ARRAY:
        return "ARRAY";
        break;
    case ELEMENT_TYPE_VALUEARRAY:
        return "VALUEARRAY";
        break;
    case ELEMENT_TYPE_R:
        return "Native Real";
        break;
    case ELEMENT_TYPE_FNPTR:
        return "FNPTR";
        break;
    case ELEMENT_TYPE_SZARRAY:
        return "SZARRAY";
        break;
    case ELEMENT_TYPE_GENERICARRAY:
        return "GENERICARRAY";
        break;
    default:
        if (CorElementTypeName[type] == NULL) {
            return "";
        }
        return CorElementTypeName[type];
        break;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump all fields of a managed object.   *  
*    pEECls specifies the type of object.                              *
*    dwStartAddr specifies the beginning memory address.               *
*    bFirst is used to avoid printing header everytime.                *
*                                                                      *
\**********************************************************************/
void DisplayFields (EEClass *pEECls, DWORD_PTR dwStartAddr, BOOL bFirst)
{
    static DWORD numInstanceFields = 0;
    if (bFirst)
    {
        dprintf ("%8s %8s %8s %20s %10s %8s %s\n", "MT", "Field",
                 "Offset", "Type", "Attr", "Value", "Name");
        numInstanceFields = 0;
    }
    
    if (pEECls->m_pParentClass)
    {
        EEClass vEEClass;
        DWORD_PTR dwAddr = (DWORD_PTR)pEECls->m_pParentClass;
        vEEClass.Fill (dwAddr);
        if (!CallStatus)
            return;
        DisplayFields (&vEEClass, dwStartAddr, FALSE);
    }
    DWORD numStaticFields = 0;

    DWORD_PTR dwAddr = (DWORD_PTR)pEECls->m_pFieldDescList;
    FieldDesc vFieldDesc;

    // Get the module name
    MethodTable vMethTable;
    DWORD_PTR dwTmp = (DWORD_PTR)pEECls->m_pMethodTable;
    vMethTable.Fill (dwTmp);
    BOOL fIsShared = vMethTable.m_wFlags & MethodTable::enum_flag_SharedAssembly;
    dwTmp = (DWORD_PTR)vMethTable.m_pModule;
    Module module;
    module.Fill (dwTmp);
    IMetaDataImport *pImport = MDImportForModule(&module);
    while (numInstanceFields < pEECls->m_wNumInstanceFields
           || numStaticFields < pEECls->m_wNumStaticFields)
    {
        if (IsInterrupt())
            return;
        vFieldDesc.Fill (dwAddr);
        if (vFieldDesc.m_type >= ELEMENT_TYPE_MAX)
        {
            dprintf ("something is bad\n");
            return;
        }
        dprintf ("%p %8x %8x ",
                 ((ULONG64)vFieldDesc.m_pMTOfEnclosingClass & ~0x3),
                 TokenFromRid(vFieldDesc.m_mb, mdtFieldDef),
                 vFieldDesc.m_dwOffset+
                 (((vFieldDesc.m_isThreadLocal || vFieldDesc.m_isContextLocal || fIsShared)
                  && vFieldDesc.m_isStatic)?0:sizeof(BaseObject)));
        dprintf ("%20s ", ElementTypeName(vFieldDesc.m_type));
        if (vFieldDesc.m_isStatic && (vFieldDesc.m_isThreadLocal || vFieldDesc.m_isContextLocal))
        {
            numStaticFields ++;
            if (fIsShared)
                dprintf ("Shared ");
            
            NameForToken (TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), pImport, g_mdName, false);
            dprintf (" %S\n", g_mdName);
            
            if (vFieldDesc.m_isThreadLocal)
                DisplayThreadStatic(&vFieldDesc,
                                    pEECls->m_wThreadStaticOffset,
                                    fIsShared);
            else if (vFieldDesc.m_isContextLocal)
                DisplayContextStatic(&vFieldDesc,
                                     pEECls->m_wContextStaticOffset,
                                     fIsShared);
            continue;
        }
        else if (vFieldDesc.m_isStatic)
        {
            numStaticFields ++;
            if (fIsShared)
            {
                dprintf ("%10s %8s", "shared", "static");
                Module vModule;
                DWORD_PTR dwAddrTmp = (DWORD_PTR)vMethTable.m_pModule;
                vModule.Fill (dwAddrTmp);
                int offset = vModule.m_dwBaseClassIndex;
                EEClass vEEClass;
                dwAddrTmp = (DWORD_PTR)vMethTable.m_pEEClass;
                vEEClass.Fill (dwAddrTmp);
                offset += RidFromToken(vEEClass.m_cl) - 1;
                offset *= 4;
                NameForToken (TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), pImport, g_mdName, false);
                dprintf (" %S\n", g_mdName);
                DisplaySharedStatic (&vFieldDesc, offset);
                continue;
            }
            else
            {
                dprintf ("%10s", "static");
                DWORD_PTR dwTmp = (DWORD_PTR)vFieldDesc.m_pMTOfEnclosingClass
                    + vMethTable.size() - sizeof (SLOT*)
                    + vFieldDesc.m_dwOffset;
                // Get the handle address
                move (dwTmp, dwTmp);
                if (vFieldDesc.m_type == ELEMENT_TYPE_VALUETYPE
                    || vFieldDesc.m_type == ELEMENT_TYPE_CLASS)
                    // get the object the handle pointing to
                    move (dwTmp, dwTmp);
                dprintf (" %p", (ULONG64)dwTmp);
            }
        }
        else
        {
            numInstanceFields ++;
            dprintf ("%10s ", "instance");
            if (dwStartAddr > 0)
            {
                DWORD_PTR dwTmp = dwStartAddr + vFieldDesc.m_dwOffset
                    + sizeof(BaseObject);
                DisplayDataMember (&vFieldDesc, dwTmp);
            }
            else
                dprintf (" %8s", " ");
        }
        NameForToken (TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), pImport, g_mdName, false);
        dprintf (" %S\n", g_mdName);
    }
    
    return;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a Module.     *  
*                                                                      *
\**********************************************************************/
void FileNameForModule (Module *pModule, WCHAR *fileName)
{
    DWORD_PTR dwAddr = (DWORD_PTR)pModule->m_file;
    if (dwAddr == 0)
        dwAddr = (DWORD_PTR)pModule->m_zapFile;
    if (dwAddr == 0) {
        // ToDo:  We have dynamic module
        fileName[0] = L'\0';
        return;
    }
    PEFile vPEFile;
    vPEFile.Fill (dwAddr);
    if (vPEFile.m_wszSourceFile[0] != L'\0') {
        wcscpy (fileName, vPEFile.m_wszSourceFile);
    }
#if 0
    else if (vPEFile.m_pLoadersFileName) {
        PrintString((DWORD_PTR)vPEFile.m_pLoadersFileName,TRUE,-1,fileName);
    }
#endif
    else if (vPEFile.m_base) {
        FileNameForHandle (vPEFile.m_base, fileName);
    }
    else
        // This should be a dynamic module.
        fileName[0] = L'\0';
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a file        *  
*    handle.                                                           *
*                                                                      *
\**********************************************************************/
void FileNameForHandle (HANDLE handle, WCHAR *fileName)
{
    fileName[0] = L'\0';
    if (((UINT_PTR)handle & CORHANDLE_MASK) != 0)
    {
        handle = (HANDLE)(((UINT_PTR)handle) & ~CORHANDLE_MASK);
        DWORD_PTR addr = (DWORD_PTR)(((PBYTE) handle) - sizeof(LPSTR*));
        DWORD_PTR first;
        move (first, addr);
        if (first == 0)
        {
            return;
        }
        DWORD length = (DWORD)(((UINT_PTR) handle - (UINT_PTR)first) - sizeof(LPSTR*));
        char name[4*MAX_PATH+1];
        if (length > 4*MAX_PATH+1)
            length = 4*MAX_PATH+1;
        moveBlock (name, first, length);
        MultiByteToWideChar(CP_UTF8, 0, name, length, fileName, MAX_PATH);
    }
    else
    {
        DllsName ((INT_PTR)handle, fileName);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a class loader.   *  
*                                                                      *
\**********************************************************************/
void ClassLoaderInfo (ClassLoader *pClsLoader)
{
    dprintf ("  Module Name\n");
    DWORD_PTR dwModuleAddr = (DWORD_PTR)pClsLoader->m_pHeadModule;
    while (dwModuleAddr)
    {
        if (IsInterrupt())
            return;
        Module vModule;
        dprintf ("%p ", (ULONG64)dwModuleAddr);
        vModule.Fill (dwModuleAddr);
        if (!CallStatus)
            return;
        WCHAR fileName[MAX_PATH+1];
        FileNameForModule (&vModule, fileName);
        dprintf ("%ws\n", fileName[0] ? fileName :
            (vModule.m_dwFlags& (Module::IS_IN_MEMORY|Module::IS_REFLECTION))
            == (Module::IS_IN_MEMORY|Module::IS_REFLECTION)?
            L"Dynamic Module":L"Unknown Module");
        dwModuleAddr = (DWORD_PTR)vModule.m_pNextModule;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an assembly.      *  
*                                                                      *
\**********************************************************************/
void AssemblyInfo (Assembly *pAssembly)
{
    dprintf ("ClassLoader: %p\n", (ULONG64)pAssembly->m_pClassLoader);
    ClassLoader vClsLoader;
    DWORD_PTR dwAddr = (DWORD_PTR)pAssembly->m_pClassLoader;
    vClsLoader.Fill (dwAddr);
    ClassLoaderInfo (&vClsLoader);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a domain.         *  
*                                                                      *
\**********************************************************************/
void DomainInfo (AppDomain *pDomain)
{
    dprintf ("LowFrequencyHeap: %p\n", (ULONG64)pDomain->m_pLowFrequencyHeap);
    dprintf ("HighFrequencyHeap: %p\n", (ULONG64)pDomain->m_pHighFrequencyHeap);
    dprintf ("StubHeap: %p\n", (ULONG64)pDomain->m_pStubHeap);
    dprintf ("Name: ");
    if (pDomain->m_pwzFriendlyName)
    {
        PrintString((DWORD_PTR)pDomain->m_pwzFriendlyName, TRUE);
        dprintf ("\n");
    }
    else
        dprintf ("None\n");

    DWORD_PTR dwAssemAddr;

    DWORD n;
    Assembly vAssembly;
    for (n = 0; n < pDomain->m_Assemblies.m_count; n ++)
    {
        if (IsInterrupt())
            return;
        dwAssemAddr = (DWORD_PTR)pDomain->m_Assemblies.Get(n);
        if (n != 0) {
            dprintf ("\n");
        }
        dprintf ("Assembly: %p", (ULONG64)dwAssemAddr);
        vAssembly.Fill (dwAssemAddr);
        if (!CallStatus)
            return;
        if (vAssembly.m_isDynamic) {
            dprintf (" (Dynamic)");
        }
        dprintf (" [");
        if (vAssembly.m_pwsFullName) {
            PrintString((DWORD_PTR)vAssembly.m_pwsFullName,TRUE,-1,NULL);
        }
        else if (vAssembly.m_psName) {
            PrintString((DWORD_PTR)vAssembly.m_psName,FALSE,-1,NULL);
        }
        dprintf ("]\n");
        AssemblyInfo (&vAssembly);
    }
    
    // dprintf ("AsyncPool: %8x\n", pDomain->m_pAsyncPool);
    //dprintf ("RootAssembly: %8x\n", pDomain->m_pRootAssembly);
    //dprintf ("Sibling: %8x\n", pDomain->m_pSibling);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a shared domain.  *  
*                                                                      *
\**********************************************************************/
void SharedDomainInfo (DWORD_PTR DomainAddr)
{
    SharedDomain v_SharedDomain;
    v_SharedDomain.Fill (DomainAddr);
    
    dprintf ("LowFrequencyHeap: %p\n", (ULONG64)v_SharedDomain.m_pLowFrequencyHeap);
    dprintf ("HighFrequencyHeap: %p\n", (ULONG64)v_SharedDomain.m_pHighFrequencyHeap);
    dprintf ("StubHeap: %p\n", (ULONG64)v_SharedDomain.m_pStubHeap);

    Assembly vAssembly;
    DWORD_PTR dwAssemblyAddr;

    Bucket vBucket;
    size_t nBucket;
    DWORD_PTR dwBucketAddr = (DWORD_PTR)v_SharedDomain.m_assemblyMap.m_rgBuckets;
    vBucket.Fill (dwBucketAddr);
    nBucket = vBucket.m_rgKeys[0];
    BOOL firstTime = TRUE;

    while (nBucket > 0) {
        if (IsInterrupt())
            return;
        vBucket.Fill (dwBucketAddr);
        if (!CallStatus) {
            return;
        }
        for (int i = 0; i < 4; i ++) {
            dwAssemblyAddr = vBucket.m_rgValues[i];
            if (dwAssemblyAddr) {
                if (!firstTime) {
                    dprintf ("\n");
                }
                else
                    firstTime = FALSE;
                dprintf ("Assembly: %p", (ULONG64)dwAssemblyAddr);
                vAssembly.Fill (dwAssemblyAddr);
                if (!CallStatus) {
                    continue;
                }
                if (vAssembly.m_isDynamic) {
                    dprintf (" (Dynamic)");
                }
                dprintf (" [");
                if (vAssembly.m_pwsFullName) {
                    PrintString((DWORD_PTR)vAssembly.m_pwsFullName,TRUE,-1,NULL);
                }
                else if (vAssembly.m_psName) {
                    PrintString((DWORD_PTR)vAssembly.m_psName,FALSE,-1,NULL);
                }
                dprintf ("]\n");
                AssemblyInfo (&vAssembly);
            }
        }
        nBucket --;
    }
}


void EEDllPath::DisplayPath ()
{
    if (path[0][0] == L'\0') {
        ExtOut ("No path is set for managed dll\n");
        return;
    }

    ExtOut ("Path to Managed Dll:\n");
    EEDllPath *ptr = this;
    while (ptr) {
        for (int i = 0; i < NumEEDllPath; i ++) {
            if (ptr->path[i][0] == '\0') {
                return;
            }
            ExtOut ("%S\n", ptr->path[i]);
        }
        ptr = ptr->next;
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a MethodDesc using    *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForMD (MethodDesc *pMD, WCHAR *mdName)
{
    mdName[0] = L'\0';
    if (CallStatus)
    {
        if (IsDebugBuildEE())
        {
            DWORD_PTR EEClassAddr;
            move (EEClassAddr, pMD->m_pDebugEEClass);
            PrintString (EEClassAddr, FALSE, -1, mdName);
            wcscat (mdName, L".");
            static WCHAR name[2048];
            name[0] = L'\0';
            PrintString ((DWORD_PTR)pMD->m_pszDebugMethodName,
                         FALSE, -1, name);
            wcscat (mdName, name);
        }
        else
        {
            DWORD_PTR pMT = pMD->m_MTAddr;
                    
            MethodTable MT;
            MT.Fill (pMT);
            if (CallStatus)
            {
                DWORD_PTR dwTmp = (DWORD_PTR)MT.m_pModule;
                Module module;
                module.Fill (dwTmp);
                NameForToken(&module,
                             (pMD->m_dwToken & 0x00ffffff)|0x06000000,
                             mdName);
            }
        }
    }
}

void NameForObject (DWORD_PTR ObjAddr, WCHAR *mdName)
{
    mdName[0] = L'\0';
    DWORD_PTR dwAddr;
    move(dwAddr, ObjAddr);
    NameForMT (dwAddr,mdName);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a MethodTable using   *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForMT (DWORD_PTR MTAddr, WCHAR *mdName)
{
    MethodTable vMethTable;
    vMethTable.Fill (MTAddr);
    NameForMT (vMethTable, mdName);
}


void NameForMT (MethodTable &vMethTable, WCHAR *mdName)
{
    mdName[0] = L'\0';
    EEClass eeclass;
    DWORD_PTR dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    eeclass.Fill (dwAddr);
    if (!CallStatus)
        return;
    if (eeclass.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        size_t count = 1;
        while (dwAddr&2) {
            if (IsInterrupt())
                return;
            ParamTypeDesc param;
            DWORD_PTR dwTDAddr = dwAddr&~2;
            param.Fill(dwTDAddr);
            dwAddr = (DWORD_PTR)param.m_Arg.m_asMT;
            count ++;
        }
        NameForMT (dwAddr, mdName);
        while (count > 0) {
            count --;
            wcscat (mdName, L"[]");
        }
    }
    else
    {
        DWORD_PTR dwTmp = (DWORD_PTR)vMethTable.m_pModule;
        Module module;
        module.Fill (dwTmp);
        NameForToken (&module, eeclass.m_cl, mdName);
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a EEClass using       *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForEEClass (EEClass *pEECls, WCHAR *mdName)
{
    mdName[0] = L'\0';
    if (IsDebugBuildEE())
    {
        PrintString ((DWORD_PTR)pEECls->m_szDebugClassName,
                     FALSE, -1, mdName);
    }
    else
    {
        NameForMT ((DWORD_PTR)pEECls->m_pMethodTable, mdName);
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if str2 is a substring of str1 and str1 and str2      *  
*    share the same file path.
*                                                                      *
\**********************************************************************/
BOOL IsSameModuleName (const char *str1, const char *str2)
{
    if (strlen (str1) < strlen (str2))
        return FALSE;
    const char *ptr1 = str1 + strlen(str1)-1;
    const char *ptr2 = str2 + strlen(str2)-1;
    while (ptr2 >= str2)
    {
        if (tolower(*ptr1) != tolower(*ptr2))
            return FALSE;
        ptr2 --;
        ptr1 --;
    }
    if (ptr1 >= str1 && *ptr1 != '\\' && *ptr1 != ':')
        return FALSE;
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if moduleAddr is the address of a module.             *  
*                                                                      *
\**********************************************************************/
BOOL IsModule (DWORD_PTR moduleAddr)
{
    // Decide EEJitManager/EconoJitManager
    static DWORD_PTR Module_vtbl = 0;
    static DWORD_PTR InMemoryModule_vtbl = 0;
    static DWORD_PTR ReflectionModule_vtbl = 0;
    static DWORD_PTR EditAndContinueModule_vtbl = 0;

    if (Module_vtbl == 0)                 
    {
        Module_vtbl =
            GetValueFromExpression ("mscoree!Module__`vftable'");
    }
    if (InMemoryModule_vtbl == 0)
    {
        InMemoryModule_vtbl =
            GetValueFromExpression ("mscoree!InMemoryModule__`vftable'");
    }
    if (ReflectionModule_vtbl == 0)
    {
        ReflectionModule_vtbl =
            GetValueFromExpression ("mscoree!ReflectionModule__`vftable'");
    }
    if (EditAndContinueModule_vtbl == 0)
    {
        EditAndContinueModule_vtbl =
            GetValueFromExpression ("mscoree!EditAndContinueModule__`vftable'");
    }

    DWORD_PTR vtbl;
    if (g_ExtData->ReadVirtual(moduleAddr,&vtbl,sizeof(vtbl),NULL) != S_OK) {
        return FALSE;
    }
    if (vtbl == 0) {
        return FALSE;
    }
    if (vtbl == Module_vtbl
        || vtbl == InMemoryModule_vtbl
        || vtbl == ReflectionModule_vtbl
        || vtbl == EditAndContinueModule_vtbl) {
        return TRUE;
    }
    return FALSE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodTable.             *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsMethodTable (DWORD_PTR value)
{
    if (value == MTForFreeObject()) {
        return TRUE;
    }

    static int MT_EEClassOffset = 0x7fffffff;
    if (MT_EEClassOffset == 0x7fffffff)
    {
        MT_EEClassOffset = MethodTable::GetFieldOffset("m_pEEClass");
    }
    
    static int EEClass_MTOffset = 0x7fffffff;
    if (EEClass_MTOffset == 0x7fffffff)
    {
        EEClass_MTOffset = EEClass::GetFieldOffset ("m_pMethodTable");
    }
    
    DWORD_PTR dwAddr;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(value+MT_EEClassOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+EEClass_MTOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (dwAddr != value) {
        return FALSE;
    }
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of an EEClass.                *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsEEClass (DWORD_PTR value)
{
    static int MT_EEClassOffset = 0x7fffffff;
    if (MT_EEClassOffset == 0x7fffffff)
    {
        MT_EEClassOffset = MethodTable::GetFieldOffset("m_pEEClass");
    }
    
    static int EEClass_MTOffset = 0x7fffffff;
    if (EEClass_MTOffset == 0x7fffffff)
    {
        EEClass_MTOffset = EEClass::GetFieldOffset ("m_pMethodTable");
    }
    
    DWORD_PTR dwAddr;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(value+EEClass_MTOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+MT_EEClassOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (dwAddr != value) {
        return FALSE;
    }
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodDesc.              *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsMethodDesc (DWORD_PTR value)
{
    DWORD_PTR dwAddr;
    GetMethodTable(value, dwAddr);
    if (dwAddr == 0)
        return FALSE;
    return IsMethodTable (dwAddr);
}


BOOL IsObject (size_t obj)
{
    DWORD_PTR dwAddr;

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(obj), &dwAddr, sizeof(dwAddr), NULL))) {
        return 0;
    }
    
    dwAddr &= ~3;
    return IsMethodTable (dwAddr);
}


void AddToModuleList(DWORD_PTR * &moduleList, int &numModule, int &maxList,
                     DWORD_PTR dwModuleAddr)
{
    int i;
    for (i = 0; i < numModule; i ++)
    {
        if (moduleList[i] == dwModuleAddr)
            break;
    }
    if (i == numModule)
    {
        moduleList[numModule] = dwModuleAddr;
        numModule ++;
        if (numModule == maxList)
        {
            DWORD_PTR *list = (DWORD_PTR *)
                malloc (2*maxList * sizeof(PVOID));
            if (list == NULL)
            {
                numModule = 0;
                ControlC = 1;
            }
            memcpy (list, moduleList, maxList * sizeof(PVOID));
            free (moduleList);
            moduleList = list;
            maxList *= 2;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the list of Module address given the name of the Module.     *  
*                                                                      *
\**********************************************************************/
void ModuleFromName(DWORD_PTR * &moduleList, LPSTR mName, int &numModule)
{
    moduleList = NULL;
    numModule = 0;
    // List all domain
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    if (numDomain == 0)
        return;

    int maxList = numDomain;
    moduleList = (DWORD_PTR *) malloc (maxList * sizeof(PVOID));
    if (moduleList == NULL)
        return;
    
    WCHAR StringData[MAX_PATH+1];
    char fileName[sizeof(StringData)/2];
    // Search all domains to find a module
    for (int n = 0; n < numDomain; n++)
    {
        if (IsInterrupt())
            break;

        int i;
        for (i = 0; i < n; i ++)
        {
            if (IsInterrupt())
                break;
            if (domainList[i] == domainList[n])
                break;
        }
        if (i < n)
        {
            continue;
        }

        if (n == 1)  
        {
            //Shared Domain.
            SharedDomain v_SharedDomain;
            DWORD_PTR dwAddr = domainList[1];
            v_SharedDomain.Fill (dwAddr);
            
            DWORD_PTR dwModuleAddr;

            SharedDomain::DLSRecord vDLSRecord;
            DWORD_PTR dwDLSAddr = (DWORD_PTR)v_SharedDomain.m_pDLSRecords;
            for (size_t k = 0; k < v_SharedDomain.m_cDLSRecords; k ++)
            {
                if (IsInterrupt())
                    return;
                move (vDLSRecord, dwDLSAddr);
                dwDLSAddr += sizeof (vDLSRecord);
                Module vModule;
                dwModuleAddr = (DWORD_PTR)vDLSRecord.pModule;
                vModule.Fill (dwModuleAddr);
                if (!CallStatus)
                {
                    continue;
                }
                FileNameForModule (&vModule, StringData);
                for (int m = 0; StringData[m] != L'\0'; m ++)
                {
                    fileName[m] = (char)StringData[m];
                }
                fileName[m] = '\0';
                if (IsSameModuleName (fileName, mName))
                {
                    dwModuleAddr = (DWORD_PTR)vDLSRecord.pModule;
                    AddToModuleList (moduleList, numModule, maxList,
                                     dwModuleAddr);
                }
            }
            continue;
        }
        
        AppDomain v_AppDomain;
        DWORD_PTR dwAddr = domainList[n];
        if (dwAddr == 0) {
            continue;
        }
        v_AppDomain.Fill (dwAddr);
        if (!CallStatus) {
            continue;
        }
        DWORD nAssem;
        Assembly vAssembly;
        for (nAssem = 0;
             nAssem < v_AppDomain.m_Assemblies.m_count;
             nAssem ++)
        {
            if (IsInterrupt())
                break;

            DWORD_PTR dwAssemAddr =
                (DWORD_PTR)v_AppDomain.m_Assemblies.Get(nAssem);
            vAssembly.Fill (dwAssemAddr);
            ClassLoader vClsLoader;
            DWORD_PTR dwLoaderAddr = (DWORD_PTR)vAssembly.m_pClassLoader;
            vClsLoader.Fill (dwLoaderAddr);
            
            DWORD_PTR dwModuleAddr = (DWORD_PTR)vClsLoader.m_pHeadModule;
            while (dwModuleAddr)
            {
                if (IsInterrupt())
                    break;
                DWORD_PTR dwAddr = dwModuleAddr;
                Module vModule;
                vModule.Fill (dwAddr);
                FileNameForModule (&vModule, StringData);
                for (int m = 0; StringData[m] != L'\0'; m ++)
                {
                    fileName[m] = (char)StringData[m];
                }
                fileName[m] = '\0';
                if (IsSameModuleName (fileName, mName))
                {
                    AddToModuleList (moduleList, numModule, maxList,
                                     dwModuleAddr);
                }
                
                dwModuleAddr = (DWORD_PTR)vModule.m_pNextModule;
            }
        }
    }
    
    if (domainList)
        free (domainList);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the EE data given a name.                                    *  
*                                                                      *
\**********************************************************************/
void GetInfoFromName(Module &vModule, const char* name)
{
    IMetaDataImport* pImport = MDImportForModule (&vModule);
    if (pImport == 0)
        return;

    static WCHAR wszName[MAX_CLASSNAME_LENGTH];
    size_t n;
    size_t length = strlen (name);
    for (n = 0; n <= length; n ++)
        wszName[n] = name[n];

    mdTypeDef cl;
    mdToken tkEnclose = mdTokenNil;
    WCHAR *pName;
    WCHAR *pHead = wszName;
    while ((pName = wcschr (pHead,L'/')) != NULL) {
        pName[0] = L'\0';
        if (FAILED(pImport->FindTypeDefByName(pHead,tkEnclose,&tkEnclose)))
            return;
        pHead = pName+1;
    }

    pName = pHead;

    // @todo:  Handle Nested classes correctly.
    if (SUCCEEDED (pImport->FindTypeDefByName (pName, tkEnclose, &cl)))
    {
        GetInfoFromModule(vModule, cl);
        return;
    }
    
    // See if it is a method
    WCHAR *pwzMethod;
    if ((pwzMethod = wcsrchr(pName, L'.')) == NULL)
        return;

    if (pwzMethod[-1] == L'.')
        pwzMethod --;
    pwzMethod[0] = L'\0';
    pwzMethod ++;
    
    // @todo:  Handle Nested classes correctly.
    if (SUCCEEDED (pImport->FindTypeDefByName (pName, tkEnclose, &cl)))
    {
        mdMethodDef token;
        ULONG cTokens;
        HCORENUM henum = NULL;
        BOOL fStatus = FALSE;
        while (SUCCEEDED (pImport->EnumMethodsWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
               && cTokens == 1)
        {
            fStatus = TRUE;
            GetInfoFromModule (vModule, token);
            dprintf ("-----------------------\n");
        }
        if (fStatus)
            return;

        // is Member?
        henum = NULL;
        if (SUCCEEDED (pImport->EnumMembersWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
            && cTokens == 1)
        {
            dprintf ("Member (mdToken token) of\n");
            GetInfoFromModule (vModule, cl);
            return;
        }

        // is Field?
        henum = NULL;
        if (SUCCEEDED (pImport->EnumFieldsWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
            && cTokens == 1)
        {
            dprintf ("Field (mdToken token) of\n");
            GetInfoFromModule (vModule, cl);
            return;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the EE data given a token.                                   *  
*                                                                      *
\**********************************************************************/
void GetInfoFromModule (Module &vModule, ULONG token, DWORD_PTR *ret)
{
    LookupMap_t *pMap;
    LookupMap_t vMap;
    DWORD rid = token & 0xffffff;
    switch (token & 0xff000000)
    {
        case mdtMethodDef:
            pMap = &vModule.m_MethodDefToDescMap;
            break;
        case mdtTypeDef:
            pMap = &vModule.m_TypeDefToMethodTableMap;
            break;
        case mdtTypeRef:
            pMap = &vModule.m_TypeRefToMethodTableMap;
            break;
        default:
            dprintf ("not supported\n");
            return;
            break;
    }
    
    DWORD_PTR addr = 0;
    while (1)
    {
        if (IsInterrupt())
            return;
        if (rid < pMap->dwMaxIndex)
        {
            addr = (DWORD_PTR)(pMap->pTable)+rid*sizeof(PVOID);
            move (addr, addr);
            break;
        }
        if (pMap->pNext == NULL)
            break;
        DWORD_PTR dwAddr = (DWORD_PTR)pMap->pNext;
        vMap.Fill(dwAddr);
        pMap = &vMap;
    }
    if (ret != NULL)
    {
        *ret = addr;
        return;
    }
    
    if (addr == 0)
    {
        dprintf ("not created yet\n");
        return;
    }

    switch (token & 0xff000000)
    {
        case mdtMethodDef:
            {
                dprintf ("MethodDesc: %x\n", addr);
                MethodDesc vMD;
                vMD.Fill (addr);
                CQuickBytes fullname;
                FullNameForMD (&vMD, &fullname);
                dprintf ("Name: %S\n", (WCHAR*)fullname.Ptr());
                break;
            }
        case mdtTypeDef:
        case mdtTypeRef:
            dprintf ("MethodTable: %p\n", (ULONG64)addr);
            MethodTable vMethTable;
            vMethTable.Fill (addr);
            addr = (DWORD_PTR)vMethTable.m_pEEClass;
            dprintf ("EEClass: %p\n", (ULONG64)addr);
            EEClass eeclass;
            eeclass.Fill (addr);
            NameForToken(&vModule, eeclass.m_cl, g_mdName);
            dprintf ("Name: %S\n", g_mdName);
            break;
        default:
            break;
    }
    return;
}

DWORD_PTR MTForObject()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetValueFromExpression("mscoree!g_pObjectClass");
        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForFreeObject()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetValueFromExpression("mscoree!g_pFreeObjectMethodTable");
        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForString()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetValueFromExpression("mscoree!g_pStringClass");
        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForFreeObj()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetValueFromExpression("mscoree!g_pFreeObjectMethodTable");
        SafeReadMemory (dwMTAddr, &dwMT, 4, NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

int MD_IndexOffset ()
{
    static int MD_IndexOffset = 0x7fffffff;
    if (MD_IndexOffset == 0x7fffffff)
    {
#ifndef UNDER_CE
        MD_IndexOffset = StubCallInstrs::GetFieldOffset("m_chunkIndex") - METHOD_PREPAD;
#endif
    }
    return MD_IndexOffset;
}

int MD_SkewOffset ()
{
    static int MD_SkewOffset = 0x7fffffff;
    if (MD_SkewOffset == 0x7fffffff)
    {
#ifndef UNDER_CE
        MD_SkewOffset = MethodDescChunk::size();
#endif
        MD_SkewOffset = - (METHOD_PREPAD + MD_SkewOffset);
    }
    return MD_SkewOffset;
}

void DumpMDInfo(DWORD_PTR dwStartAddr)
{
    if (!IsMethodDesc (dwStartAddr))
    {
        dprintf ("%p is not a MethodDesc\n", (ULONG64)dwStartAddr);
        return;
    }
    
    MethodDesc *pMD = NULL;
    pMD = (MethodDesc*)_alloca(sizeof(MethodDesc));
    if (!pMD)
        return;

    DWORD_PTR tmpAddr = dwStartAddr;
    pMD->Fill (tmpAddr);
    if (!CallStatus)
        return;

    DWORD_PTR pMT = pMD->m_MTAddr;
    if (pMT == 0)
    {
        dprintf ("Fail in GetMethodTable\n");
        return;
    }

    CQuickBytes fullname;
    FullNameForMD (pMD,&fullname);
    dprintf ("Method Name : %S\n", (WCHAR*)fullname.Ptr());
    if (IsDebugBuildEE())
    {
        dprintf ("Class : %x\r\n",pMD->m_pDebugEEClass);
        dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
        dprintf ("mdToken: %08x\n",
                 (pMD->m_dwToken & 0x00ffffff)|0x06000000);
    }
    else
    {
        MethodTable MT;
        ULONG_PTR dwAddr = pMT;
        MT.Fill(dwAddr);
        
        if (((pMD->m_wFlags & 0x10) == 0)
            && (MT.m_wFlags & MethodTable::enum_flag_Array) != 0)
        {
            DWORD_PTR *addr = (DWORD_PTR*)((BYTE*)pMD + MethodDesc::size()
                                           + 3*sizeof(DWORD_PTR));
            DWORD_PTR pname = *addr;

            PrintString (pname);
            dprintf ("\n");
            dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
        }
        else
        {
            dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
            dprintf ("Module: %x\n", (DWORD_PTR)MT.m_pModule);
            dprintf ("mdToken: %08x",
                     (pMD->m_dwToken & 0x00ffffff)|0x06000000);
            WCHAR fileName[MAX_PATH+1];
            FileNameForMT (&MT, fileName);
            dprintf( " (%ws)\n",
                     fileName[0] ? fileName : L"Unknown Module" );
            /*
              dprintf (" (Do !dlls -c %08x to find the module name)\n",
              module_addr);
            */
        }
    }
    

    dprintf("Flags : %x\r\n",pMD->m_wFlags);
    if (pMD->m_CodeOrIL & METHOD_IS_IL_FLAG)
    {
        dprintf("IL RVA : %p\r\n",pMD->m_CodeOrIL);
    }
    else
    {
        dprintf("Method VA : %p\r\n",(pMD->m_CodeOrIL & ~METHOD_IS_IL_FLAG));
    }
}

void GetDomainList (DWORD_PTR *&domainList, int &numDomain)
{
    static DWORD_PTR    p_SystemDomainAddr = 0;
    static DWORD_PTR    p_SharedDomainAddr = 0;
    DWORD_PTR           domainListAddr;
    ArrayList           appDomainIndexList;

    numDomain = 0;

    //
    // do not cache this value, it may change
    //
    domainListAddr = GetValueFromExpression ("mscoree!SystemDomain__m_appDomainIndexList");

    appDomainIndexList.Fill(domainListAddr);
    if (!CallStatus)
    {
        return;
    }

    domainList = (DWORD_PTR*) malloc ((appDomainIndexList.m_count + 2)*sizeof(PVOID));
    if (domainList == NULL)
    {
        return;
    }

    if (p_SystemDomainAddr == 0)
        p_SystemDomainAddr = GetValueFromExpression ("mscoree!SystemDomain__m_pSystemDomain");

    if (!SafeReadMemory(p_SystemDomainAddr, &domainList[numDomain],
                        sizeof(PVOID), NULL))
    {
        return;
    }
    numDomain ++;
    
    if (0 == p_SharedDomainAddr)
        p_SharedDomainAddr = GetValueFromExpression ("mscoree!SharedDomain__m_pSharedDomain");

    if (p_SharedDomainAddr)
    {
        if (!SafeReadMemory(p_SharedDomainAddr, &domainList[numDomain],
                            sizeof(PVOID), NULL))
        {
            return;
        }
        numDomain ++;
    }

    unsigned int i;
    for (i = 0; i < appDomainIndexList.m_count; i ++)
    {
        if (IsInterrupt())
            break;

        domainList[numDomain] = (DWORD_PTR)appDomainIndexList.Get(i);
        numDomain++;
    }
}

//@TODO: get rid of this function and remove all calls to it
BOOL HaveToFixThreadSymbol()
{
    return FALSE;
#if 0
    static ULONG bFixBadSymbols=-1;
    if (bFixBadSymbols != -1) {
        return bFixBadSymbols;
    }
    if (bFixBadSymbols == -1) {
        if (!IsServerBuild ()) {
            bFixBadSymbols = 0;
        }
        else
        {
            if (alloc_context::GetFieldOffset ("heap") == -1)
                bFixBadSymbols = 1;
            else
            {
                bFixBadSymbols = 0;
                ExtOut ("Remove this hack.  Symbol problem has been fixed.\n");
            }
        }
    }

    return bFixBadSymbols;
#endif
}


void GetThreadList (DWORD_PTR *&threadList, int &numThread)
{
    numThread = 0;
    static DWORD_PTR p_g_pThreadStore = 0;
    if (p_g_pThreadStore == 0)
        p_g_pThreadStore = GetValueFromExpression ("mscoree!g_pThreadStore");
    DWORD_PTR g_pThreadStore;
    move (g_pThreadStore, p_g_pThreadStore);
    ThreadStore vThreadStore;
    DWORD_PTR dwAddr = g_pThreadStore;
    vThreadStore.Fill (dwAddr);
    if (!CallStatus)
    {
        dprintf ("Fail to fill ThreadStore\n");
        return;
    }

    threadList = (DWORD_PTR*) malloc (vThreadStore.m_ThreadCount * sizeof(PVOID));
    
    if (threadList == NULL)
        return;
    
    DWORD_PTR pHead = (DWORD_PTR)vThreadStore.m_ThreadList.m_pHead;
    DWORD_PTR pNext;
    move (pNext, pHead);
    DWORD_PTR pThread;

#ifndef UNDER_CE
    static int offset_LinkStore = -1;
    if (offset_LinkStore == -1)
    {
        offset_LinkStore = Thread::GetFieldOffset("m_LinkStore");
    }
#endif

    BOOL bFixThreadSymbol = HaveToFixThreadSymbol ();
    while (1)
    {
        if (IsInterrupt())
            return;
#ifndef UNDER_CE
        if (offset_LinkStore != -1)
        {
            pThread = pNext - offset_LinkStore;
        }
        else
#endif
            return;

        threadList[numThread++] = pThread - (bFixThreadSymbol?8:0);

        move (pNext, pNext);
        if (pNext == 0)
            return;
    }

}

JitType GetJitType (DWORD_PTR Jit_vtbl)
{
    // Decide EEJitManager/EconoJitManager
    static DWORD_PTR EEJitManager_vtbl = 0;
    static DWORD_PTR EconoJitManager_vtbl = 0;
    static DWORD_PTR MNativeJitManager_vtbl = 0;

    if (EEJitManager_vtbl == 0)
    {
        EEJitManager_vtbl =
            GetValueFromExpression ("mscoree!EEJitManager__`vftable'");
    }
    if (EconoJitManager_vtbl == 0)
    {
        EconoJitManager_vtbl =
            GetValueFromExpression ("mscoree!EconoJitManager__`vftable'");
    }
    if (MNativeJitManager_vtbl == 0)
    {
        MNativeJitManager_vtbl =
            GetValueFromExpression ("mscoree!MNativeJitManager__`vftable'");
    }

    if (Jit_vtbl == EEJitManager_vtbl)
        return JIT;
    else if (Jit_vtbl == EconoJitManager_vtbl)
        return EJIT;
    else if (Jit_vtbl == MNativeJitManager_vtbl)
        return PJIT;
    else
        return UNKNOWN;
}

void ReloadSymbolWithLineInfo()
{
    static BOOL bLoadSymbol = FALSE;
    if (!bLoadSymbol)
    {
        ULONG Options;
        g_ExtSymbols->GetSymbolOptions (&Options);
        if (!(Options & SYMOPT_LOAD_LINES))
        {
            g_ExtSymbols->AddSymbolOptions (SYMOPT_LOAD_LINES);
            g_ExtSymbols->Reload ("/f mscoree.dll");
            EEFLAVOR flavor = GetEEFlavor ();
            if (flavor == MSCORWKS)
                g_ExtSymbols->Reload ("/f mscorwks.dll");
            else if (flavor == MSCORSVR)
                g_ExtSymbols->Reload ("/f mscorsvr.dll");
            //g_ExtSymbols->Reload ("mscorjit.dll");
        }
        
        // reload mscoree.pdb and mscorjit.pdb to get line info
        bLoadSymbol = TRUE;
    }
}

#ifndef _WIN64
// Return 1 if the function is our stub
// Return MethodDesc if the function is managed
// Otherwise return 0
size_t FunctionType (size_t EIP)
{
    ULONG64 base = 0;
    if (SUCCEEDED(g_ExtSymbols->GetModuleByOffset(EIP, 0, NULL, &base)) && base != 0)
    {
        IMAGE_DOS_HEADER DosHeader;
        if (g_ExtData->ReadVirtual(base, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
            return 0;
        IMAGE_NT_HEADERS32 Header32;
        if (g_ExtData->ReadVirtual(base + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
            return 0;
        // If there is no COMHeader, this can not be managed code.
        if (Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress == 0)
            return 0;
        
        IMAGE_COR20_HEADER ComPlusHeader;
        if (g_ExtData->ReadVirtual(base + Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
                                   &ComPlusHeader, sizeof(ComPlusHeader), NULL))
            return 0;
        
        // If there is no Precompiled image info, it can not be prejit code
        if (ComPlusHeader.ManagedNativeHeader.VirtualAddress == 0) {
            return 0;
        }
    }

    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (EIP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc) {
        return methodDesc;
    }
    else
        return 1;

#if 0
    IMAGE_COR20_HEADER *pComPlusHeader = (IMAGE_COR20_HEADER*) (pImage + 
                pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);

    if (pComPlusHeader->MajorRuntimeVersion < 2) {
        return 0;
    }

    // For IJW, if EIP is within the code range
    if (EIP >= base+pHeader32->OptionalHeader.BaseOfCode 
        && EIP < base+pHeader32->OptionalHeader.BaseOfCode+pHeader32->OptionalHeader.SizeOfCode) {
        return TRUE;
    }

    return FALSE;
#endif
}
#endif

void GetVersionString (WCHAR *version)
{
    static WCHAR buffer[100] = L"\0";
    version[0] = L'\0';

    if (buffer[0] == L'\0') {
        memset (buffer, 0, sizeof(buffer));
        DWORD_PTR dwStartAddr = GetValueFromExpression("mscoree!g_Version");
        if (dwStartAddr)
        {
            PrintString (dwStartAddr, FALSE, -1, buffer);
        }
        else
        {
            char code[100];
            dwStartAddr =
                GetValueFromExpression("mscoree!SystemNative__GetVersionString");

            if (dwStartAddr == 0)
                return;
            move (code, dwStartAddr);
            int n;
            for (n = 0; n < 100; n ++)
            {
                if (code[n] == 0x68)
                {
                    DWORD_PTR verAddr;
                    memcpy (&verAddr, &code[n+1], sizeof(DWORD_PTR));
                    PrintString (verAddr, TRUE, -1, buffer);
                    break;
                }
            }
        }
    }

    if (buffer[0] != L'\0') {
        wcsncpy (version, buffer, wcslen(buffer)+1);
    }
}


size_t ObjectSize (DWORD_PTR obj)
{
    DWORD_PTR dwAddr;

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(obj), &dwAddr, sizeof(dwAddr), NULL))) {
        return 0;
    }
    
    dwAddr &= ~3;
    if (!IsMethodTable (dwAddr)) {
        return 0;
    }

    MethodTable vMT;
    vMT.Fill (dwAddr);
    size_t size = vMT.m_BaseSize;
    if (vMT.m_ComponentSize > 0)
    {
        DWORD_PTR pComp = obj + 4;
        DWORD_PTR numComp;
        moveN (numComp, pComp);
        size += vMT.m_ComponentSize*numComp;
    }
    size = Align (size);
    return size;
}

void StringObjectContent (size_t obj, BOOL fLiteral, const int length)
{
    DWORD_PTR dwAddr = obj + 2*sizeof(PVOID);
    DWORD_PTR count;
    move (count, dwAddr);
    count &= (sizeof(PVOID)==4)?0xfffffff:0xfffffffffffffff;
    if (length != -1 && (int)count > length) {
        count = length;
    }
    dwAddr += sizeof(PVOID);
    
    WCHAR buffer[256];
    WCHAR out[512];
    while (count) {
        DWORD toRead = 255;
        if (count < toRead) {
            toRead = count;
        }
        ULONG bytesRead;
        if (FAILED(g_ExtData->ReadVirtual(dwAddr, buffer, toRead*sizeof(WCHAR), &bytesRead)) || bytesRead == 0) {
            break;
        }
        DWORD wcharsRead = bytesRead/2;
        buffer[wcharsRead] = L'\0';
        
        if (!fLiteral) {
            ExtOut ("%S", buffer);
        }
        else
        {
            ULONG j,k=0;
            for (j = 0; j < wcharsRead; j ++) {
                if (iswprint (buffer[j])) {
                    out[k] = buffer[j];
                    k ++;
                }
                else
                {
                    out[k++] = L'\\';
                    switch (buffer[j]) {
                    case L'\n':
                        out[k++] = L'n';
                        break;
                    case L'\0':
                        out[k++] = L'0';
                        break;
                    case L'\t':
                        out[k++] = L't';
                        break;
                    case L'\v':
                        out[k++] = L'v';
                        break;
                    case L'\b':
                        out[k++] = L'b';
                        break;
                    case L'\r':
                        out[k++] = L'r';
                        break;
                    case L'\f':
                        out[k++] = L'f';
                        break;
                    case L'\a':
                        out[k++] = L'a';
                        break;
                    case L'\\':
                        break;
                    case L'\?':
                        out[k++] = L'?';
                        break;
                    default:
                        out[k++] = L'?';
                        break;
                    }
                }
            }

            out[k] = L'\0';
            ExtOut ("%S", out);
        }

        count -= wcharsRead;
        dwAddr += bytesRead;
    }
}

BOOL GetValueForCMD (const char *ptr, const char *end, ARGTYPE type, size_t *value)
{
    char *last;
    if (type == COHEX) {
        *value = strtoul(ptr,&last,16);
    }
    else
        *value = strtoul(ptr,&last,10);
    if (last != end) {
        return FALSE;
    }

    return TRUE;
}

void SetValueForCMD (void *vptr, ARGTYPE type, size_t value)
{
    switch (type) {
    case COBOOL:
        *(BOOL*)vptr = value;
        break;
    case COSIZE_T:
    case COHEX:
        *(SIZE_T*)vptr = value;
        break;
    }
}

BOOL GetCMDOption(const char *string, CMDOption *option, size_t nOption,
                  CMDValue *arg, size_t maxArg, size_t *nArg)
{
    const char *end;
    const char *ptr = string;
    BOOL endofOption = FALSE;

    for (size_t n = 0; n < nOption; n ++) {
        option[n].hasSeen = FALSE;
    }
    if (nArg) {
        *nArg = 0;
    }

    while (ptr[0] != '\0') {
        if (IsInterrupt())
            return FALSE;
        
        // skip any space
        if (isspace (ptr[0])) {
            while (isspace (ptr[0]))
                ptr ++;
            continue;
        }
        end = ptr;
        while (!isspace(end[0]) && end[0] != '\0') {
            end ++;
        }

        if (ptr[0] != '-') {
            if (maxArg == 0) {
                ExtOut ("Incorrect option: %s\n", ptr);
                return FALSE;
            }
            endofOption = TRUE;
            if (*nArg >= maxArg) {
                ExtOut ("Incorrect option: %s\n", ptr);
                return FALSE;
            }
            
            size_t value;
            if (!GetValueForCMD (ptr,end,arg[*nArg].type,&value)) {
                char buffer[80];
                if (end-ptr > 79) {
                    ExtOut ("Invalid option %s\n", ptr);
                    return FALSE;
                }
                strncpy (buffer, ptr, end-ptr);
                buffer[end-ptr] = '\0';
                value = (size_t)GetExpression (buffer);
                if (value == 0) {
                    ExtOut ("Invalid option: %s\n", ptr);
                    return FALSE;
                }
            }

            SetValueForCMD (arg[*nArg].vptr, arg[*nArg].type, value);

            (*nArg) ++;
        }
        else if (endofOption) {
            ExtOut ("Wrong option: %s\n", ptr);
            return FALSE;
        }
        else {
            char buffer[80];
            if (end-ptr > 79) {
                ExtOut ("Invalid option %s\n", ptr);
                return FALSE;
            }
            strncpy (buffer, ptr, end-ptr);
            buffer[end-ptr] = '\0';
            size_t n;
            for (n = 0; n < nOption; n ++) {
                if (_stricmp (buffer, option[n].name) == 0) {
                    if (option[n].hasSeen) {
                        ExtOut ("Invalid option: option specified multiple times: %s\n", buffer);
                        return FALSE;
                    }
                    option[n].hasSeen = TRUE;
                    if (option[n].hasValue) {
                        // skip any space
                        ptr = end;
                        if (isspace (ptr[0])) {
                            while (isspace (ptr[0]))
                                ptr ++;
                        }
                        if (ptr[0] == '\0') {
                            ExtOut ("Missing value for option %s\n", buffer);
                            return FALSE;
                        }
                        end = ptr;
                        while (!isspace(end[0]) && end[0] != '\0') {
                            end ++;
                        }

                        size_t value;
                        if (!GetValueForCMD (ptr,end,option[n].type,&value)) {
                            ExtOut ("Invalid option: %s\n", ptr);
                            return FALSE;
                        }

                        SetValueForCMD (option[n].vptr,option[n].type,value);
                    }
                    else {
                        SetValueForCMD (option[n].vptr,option[n].type,TRUE);
                    }
                    break;
                }
            }
            if (n == nOption) {
                ExtOut ("Unknown option: %s\n", buffer);
                return FALSE;
            }
        }

        ptr = end;
    }
    return TRUE;
}

DWORD ComPlusAptCleanupGroupInfo(ComPlusApartmentCleanupGroup *group, BOOL bDetail)
{
    size_t count = 0;

    EEHashTable *pTable = &group->m_CtxCookieToContextCleanupGroupMap;
    if (pTable->m_dwNumEntries == 0) {
        return 0;
    }

    DWORD n;
    size_t dwBucketAddr;
    EEHashEntry vEntry;
    for (n = 0; n < pTable->m_dwNumBuckets; n ++) {
        if (IsInterrupt())
            break;
        dwBucketAddr = (size_t)pTable->m_pBuckets + n * sizeof(PVOID);
        moveN (dwBucketAddr, dwBucketAddr);
        while (dwBucketAddr) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwAddr = dwBucketAddr;
            vEntry.Fill(dwAddr);
            dwAddr = (DWORD_PTR)vEntry.Data;
            ComPlusContextCleanupGroup ctxGroup;
            while (dwAddr) {
                ctxGroup.Fill (dwAddr);
                if (bDetail) {
                    for (DWORD i = 0; i < ctxGroup.m_dwNumWrappers; i++) {
                        ExtOut ("%p\n", (ULONG64)ctxGroup.m_apWrapper[i]);
                    }
                }
                count += ctxGroup.m_dwNumWrappers;
                dwAddr = (DWORD_PTR)ctxGroup.m_pNext;
            }
            dwBucketAddr = (size_t)vEntry.pNext;
        }
    }

    return count;
}

BOOL IsDebuggeeInNewState ()
{
    if (IsDumpFile()) {
        return FALSE;
    }

    if (TargetPlatform() == VER_PLATFORM_WIN32_WINDOWS)
        return TRUE;

    typedef BOOL (WINAPI *FntGetProcessTimes)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
    static FntGetProcessTimes pFntGetProcessTimes = (FntGetProcessTimes)-1;
    if (pFntGetProcessTimes == (FntGetProcessTimes)-1) {
        HINSTANCE hstat = LoadLibrary ("Kernel32.dll");
        if (hstat != 0)
        {
            pFntGetProcessTimes = (FntGetProcessTimes)GetProcAddress (hstat, "GetProcessTimes");
            FreeLibrary (hstat);
        }
        else
            pFntGetProcessTimes = NULL;
    }

    if (pFntGetProcessTimes == NULL) {
        return TRUE;
    }

    static FILETIME s_KernelTime = {0,0};
    static FILETIME s_UserTime = {0,0};
    
    FILETIME CreationTime;
    FILETIME ExitTime;
    FILETIME KernelTime;
    FILETIME UserTime;

    ULONG64 value;
    if (FAILED(g_ExtSystem->GetCurrentProcessHandle(&value)))
        return 0;
    HANDLE hProcess = (HANDLE)value;
    
    if (pFntGetProcessTimes && pFntGetProcessTimes (hProcess,&CreationTime,&ExitTime,&KernelTime,&UserTime)) {
        if (s_UserTime.dwHighDateTime == 0 && s_UserTime.dwLowDateTime == 0
            && s_KernelTime.dwHighDateTime == 0 && s_KernelTime.dwLowDateTime == 0) {
            memcpy (&s_KernelTime, &KernelTime, sizeof(FILETIME));
            memcpy (&s_UserTime, &UserTime, sizeof(FILETIME));
            return FALSE;
        }
        BOOL status = FALSE;
        if (memcmp (&s_KernelTime, &KernelTime, sizeof(FILETIME))) {
            status = TRUE;
            memcpy (&s_KernelTime, &KernelTime, sizeof(FILETIME));
        }
        if (memcmp (&s_UserTime, &UserTime, sizeof(FILETIME))) {
            status = TRUE;
            memcpy (&s_UserTime, &UserTime, sizeof(FILETIME));
        }
        return status;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\utilx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"
#include "gcinfo.h"
#include "disasm.h"

size_t FASTCALL decodeUnsigned(const BYTE *src, unsigned* val);
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the begin and end of the code for a managed function.        *  
*                                                                      *
\**********************************************************************/
void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &codeInfo, BOOL bSimple)
{
    codeInfo.IPBegin = 0;
    codeInfo.methodSize = 0;
    
    size_t ip = MD.m_CodeOrIL;

    // for EJit and Profiler, m_CodeOrIL has the address of a stub
    unsigned char ch;
    move (ch, ip);
    if (ch == 0xe9)
    {
        int offsetValue;
        move (offsetValue, ip + 1);
        ip = ip + 5 + offsetValue;
    }
    
    DWORD_PTR methodDesc;
    IP2MethodDesc (ip, methodDesc, codeInfo.jitType, codeInfo.gcinfoAddr);
    if (!methodDesc || codeInfo.jitType == UNKNOWN)
    {
        dprintf ("Not jitted code\n");
        return;
    }

    if (codeInfo.jitType == JIT || codeInfo.jitType == PJIT)
    {
        DWORD_PTR vAddr = codeInfo.gcinfoAddr;
        BYTE tmp[8];
        // We avoid using move here, because we do not want to return
        if (!SafeReadMemory (vAddr, &tmp, 8, NULL))
        {
            dprintf ("Fail to read memory at %x\n", vAddr);
            return;
        }
        decodeUnsigned(tmp, &codeInfo.methodSize);
        if (!bSimple)
        {
            // assume that GC encoding table is never more than
            // 40 + methodSize * 2
            int tableSize = 40 + codeInfo.methodSize*2;
            BYTE *table = (BYTE*) _alloca (tableSize);
            memset (table, 0, tableSize);
            // We avoid using move here, because we do not want to return
            if (!SafeReadMemory(vAddr, table, tableSize, NULL))
            {
                dprintf ("Could not read memory %x\n", vAddr);
                return;
            }
        
            InfoHdr vheader;
            InfoHdr *header = &vheader;
            unsigned count;
        
            table += decodeUnsigned(table, &codeInfo.methodSize);

            BYTE headerEncoding = *table++;

            decodeHeaderFirst(headerEncoding, header);
            while (headerEncoding & 0x80)
            {
                headerEncoding = *table++;
                decodeHeaderNext(headerEncoding, header);
            }

            if (header->untrackedCnt == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->untrackedCnt = (unsigned short)count;
            }

            if (header->varPtrTableSize == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->varPtrTableSize = (unsigned short)count;
            }

            codeInfo.prologSize = header->prologSize;
            codeInfo.epilogStart = header->epilogSize;
            codeInfo.epilogCount = header->epilogCount;
            codeInfo.epilogAtEnd = header->epilogAtEnd;
            codeInfo.ediSaved = header->ediSaved;
            codeInfo.esiSaved = header->esiSaved;
            codeInfo.ebxSaved = header->ebxSaved;
            codeInfo.ebpSaved = header->ebpSaved;
            codeInfo.ebpFrame = header->ebpFrame;
            codeInfo.argCount = header->argCount * sizeof(void*);
            
            if  (header->epilogCount > 1 || (header->epilogCount != 0 &&
                                             header->epilogAtEnd == 0))
            {
                unsigned offs = 0;

                //for (unsigned i = 0; i < header->epilogCount; i++)
                {
                    table += decodeUDelta(table, &offs, offs);
                    codeInfo.epilogStart = (unsigned char)offs;
                    //break;
                }
            }
            else
            {
                if  (header->epilogCount)
                    codeInfo.epilogStart = (unsigned char)(codeInfo.methodSize
                        - codeInfo.epilogStart);
            }
        }
    }
    else if (codeInfo.jitType == EJIT)
    {
        JittedMethodInfo jittedMethodInfo;
        move (jittedMethodInfo, MD.m_CodeOrIL);
        BYTE* pEhGcInfo = jittedMethodInfo.u2.pEhGcInfo;
        if ((unsigned)pEhGcInfo & 1)
            pEhGcInfo = (BYTE*) ((unsigned) pEhGcInfo & ~1);       // lose the mark bit
        else    // code has not been pitched, and it is guaranteed to not be pitched while we are here
        {
            CodeHeader* pCodeHeader = jittedMethodInfo.u1.pCodeHeader;
            move (pEhGcInfo, pCodeHeader-1);
        }
        
        if (jittedMethodInfo.flags.EHInfoExists)
        {
            short cEHbytes;
            move (cEHbytes, pEhGcInfo);
            pEhGcInfo = (pEhGcInfo + cEHbytes);
        }
        Fjit_hdrInfo hdrInfo;
        DWORD_PTR dwAddr = (DWORD_PTR)pEhGcInfo;
        hdrInfo.Fill(dwAddr);
        codeInfo.methodSize = (unsigned)hdrInfo.methodSize;
        if (!bSimple)
        {
            codeInfo.prologSize = hdrInfo.prologSize;
            codeInfo.epilogStart = (unsigned char)(codeInfo.methodSize - hdrInfo.epilogSize);
            codeInfo.epilogCount = 1;
            codeInfo.epilogAtEnd = 1;
            codeInfo.ediSaved = 1;
            codeInfo.esiSaved = 1;
            codeInfo.ebxSaved = 1;
            codeInfo.ebpSaved = 1;
            codeInfo.ebpFrame = 1;
            codeInfo.argCount = hdrInfo.methodArgsSize;
        }
    }
    
    codeInfo.IPBegin = ip;
}





/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to determine if a DWORD on the stack is   *  
*    a return address.
*    It does this by checking several bytes before the DWORD to see if *
*    there is a call instruction.                                      *
*                                                                      *
\**********************************************************************/
void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled)
{
    *whereCalled = 0;
    // don't waste time values clearly out of range
    if (retAddr < 0x1000 || retAddr > 0x80000000)   
        return;

    unsigned char spotend[6];
    move (spotend, retAddr-6);
    unsigned char *spot = spotend+6;
    DWORD_PTR addr;
    
    // Note this is possible to be spoofed, but pretty unlikely
    // call XXXXXXXX
    if (spot[-5] == 0xE8) {
        move (*whereCalled, retAddr-4);
        *whereCalled += retAddr;
        //*whereCalled = *((int*) (retAddr-4)) + retAddr;
        if (*whereCalled < 0x80000000 && *whereCalled > 0x1000
            && g_ExtData->ReadVirtual(*whereCalled,&addr,sizeof(addr),NULL) == S_OK)
        {
            DWORD_PTR callee;
            if (GetCalleeSite(*whereCalled,callee)) {
                *whereCalled = callee;
            }
            return;
        }
        else
            *whereCalled = 0;
    }

    // call [XXXXXXXX]
    if (spot[-6] == 0xFF && (spot[-5] == 025))  {
        move (addr, retAddr-4);
        if (g_ExtData->ReadVirtual(addr,whereCalled,sizeof(*whereCalled),NULL) == S_OK) {
            move (*whereCalled, addr);
            //*whereCalled = **((unsigned**) (retAddr-4));
            if (*whereCalled < 0x80000000 && *whereCalled > 0x1000
                && g_ExtData->ReadVirtual(*whereCalled,&addr,sizeof(addr),NULL) == S_OK) 
            {
                DWORD_PTR callee;
                if (GetCalleeSite(*whereCalled,callee)) {
                    *whereCalled = callee;
                }
                return;
            }
            else
                *whereCalled = 0;
        }
        else
            *whereCalled = 0;
    }

    // call [REG+XX]
    if (spot[-3] == 0xFF && (spot[-2] & ~7) == 0120 && (spot[-2] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-4] == 0xFF && spot[-3] == 0124)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }

    // call [REG+XXXX]
    if (spot[-6] == 0xFF && (spot[-5] & ~7) == 0220 && (spot[-5] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-7] == 0xFF && spot[-6] == 0224)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call [REG]
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0020 && (spot[-1] & 7) != 4 && (spot[-1] & 7) != 5)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call REG
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0320 && (spot[-1] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // There are other cases, but I don't believe they are used.
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\symbol.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef UNDER_CE
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "symbol.h"
#include <dbghelp.h>

#if 0
static ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN DWORD_PTR ModBaseAddress
    );

//
// Callback routine to find if any symbol has type info
//
BOOL CheckIndexedType (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    PULONG pTypeInfoPresent = (PULONG) ctxt;
    
    if (pSym->TypeIndex) {
        *pTypeInfoPresent = TRUE;
        return FALSE;
    }
    return TRUE;
}


static ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN ULONG64 ModBaseAddress
    )
/*
  This routines checks whether the given module referred by ModBaseAddress has
  any type info or not. This is done by trying to get type info for a basic type 
  like PVOID/ULONG which would always be present in a pdb.
*/
{
    ULONG TypeInfoPresent = FALSE;

    SymEnumTypes(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    SymEnumSym(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    return FALSE;
}
#endif

DWORD_PTR GetSymbolType (const char *name, SYM_OFFSET *symOffset,
                    int symCount)
{
    // Initialize all offset to -1
    int n;
    for (n = 0; n < symCount; n ++) {
        if (symOffset[n].offset == -2) {
            if (IsDebugBuildEE()){
                symOffset[n].offset = -1;
            }
        }
        else
            symOffset[n].offset = -1;
    }

    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return 0;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return 0;
    }

#if 0
    static bTypeInfo = FALSE;
    if (!bTypeInfo)
    {
        if (!CheckForTypeInfo(g_hCurrentProcess,moduleInfo[flavor].baseAddr))
        {
            ExtOut ("Symbol type info not exist\n");
            return 0;
        }
    }
    bTypeInfo = TRUE;
#endif
    
    ULONG TypeId;
    const char *pt = strchr(name, '!');
    if (pt == NULL)
        pt = name;
    else
        pt ++;
    if (FAILED(g_ExtSymbols->GetTypeId (moduleInfo[flavor].baseAddr,
                                        pt, &TypeId)))
        return 0;
    
    for (n = 0; n < symCount; n++) {
        if (symOffset[n].offset != -2) {
            g_ExtSymbols->GetFieldOffset(moduleInfo[flavor].baseAddr, TypeId,
                                         symOffset[n].name, &symOffset[n].offset);
            if (symOffset[n].offset == -1)
                ExtOut ("offset not exist for %s\n", symOffset[n].name);
        }
        else
            symOffset[n].offset = -1;
    }

    ULONG Size;
    if (SUCCEEDED(g_ExtSymbols->GetTypeSize (moduleInfo[flavor].baseAddr,
                                             TypeId, &Size)))
        return Size;
    else
        return 0;
}

ULONG WStrlen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL) {
        result++;
    }

    return result;
}

LPSTR
UnicodeToAnsi(BSTR wStr)
{
    ULONG len = WStrlen(wStr);
    LPSTR str = (LPSTR) malloc(len + 1);

    if (str) {
        sprintf(str,"%ws", wStr);
    }
    return str;
}

BOOL
GetConstantNameAndVal(
    HANDLE hProcess,
    DWORD64 baseAddress,
    ULONG typeId,
    PCHAR *pName,
    PULONG64 pValue
    )
{
    PWCHAR pWname;
    VARIANT var;
    ULONG len;

    *pName = NULL;
    if (!SymGetTypeInfo(hProcess, baseAddress, typeId, TI_GET_SYMNAME, (PVOID) &pWname) ||
        !SymGetTypeInfo(hProcess, baseAddress, typeId, TI_GET_VALUE, (PVOID) &var)) {
        return FALSE;
    }
    
    if (pWname) {
        *pName = UnicodeToAnsi(pWname);
        LocalFree (pWname);
    } else {
        *pName = NULL;
        return FALSE;
    }

    switch (var.vt) { 
    case VT_UI2: 
    case VT_I2:
        *pValue = var.iVal;
        len = 2;
        break;
    case VT_R4:
        *pValue = (ULONG64) var.fltVal;
        len=4;
        break;
    case VT_R8:
        *pValue = (ULONG64) var.dblVal;
        len=8;
        break;
    case VT_BOOL:
        *pValue = var.lVal;
        len=4;
        break;
    case VT_I1:
    case VT_UI1: 
        *pValue = var.bVal;
        len=1;
        break;
    case VT_I8:
    case VT_UI8:
        *pValue = var.ullVal;
        len=8;
        break;
    case VT_UI4:
    case VT_I4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        *pValue = var.lVal;
        len=4;
        break;
    default:
//        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    return TRUE;
}

struct Exam1dArrayInfo
{
    HANDLE hProcess;
    ULONG64 baseAddr;
    ULONG length;
};

BOOL CALLBACK
Parse1DArraySymbolInfo(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           ArrayInfoArg
    )
{
    Exam1dArrayInfo *pInfo = (Exam1dArrayInfo *)ArrayInfoArg;
    
    if (Size == 0) {
        return TRUE;
    }
    
    ULONG BaseId;
    ULONGLONG BaseSz;

    if (!SymGetTypeInfo(pInfo->hProcess, pInfo->baseAddr, SymInfo->TypeIndex, TI_GET_TYPEID, &BaseId))
        return FALSE;
    if (!SymGetTypeInfo(pInfo->hProcess, pInfo->baseAddr, BaseId, TI_GET_LENGTH, (PVOID) &BaseSz))
        return FALSE;

    pInfo->length = (ULONG)(BaseSz ? (Size / (ULONG)(ULONG_PTR)BaseSz) : 1);
    return FALSE;
}

ULONG Get1DArrayLength (const char *name)
{
    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return 0;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return 0;
    }

    ULONG64 value;
    if (FAILED(g_ExtSystem->GetCurrentProcessHandle(&value)))
        return 0;
    HANDLE hProcess = (HANDLE)value;
    
    Exam1dArrayInfo arrayInfo = {hProcess, moduleInfo[flavor].baseAddr, 0};

    SymEnumSymbols (hProcess, moduleInfo[flavor].baseAddr, name, Parse1DArraySymbolInfo, &arrayInfo);
    return arrayInfo.length;
}

void NameForEnumValue (const char *EnumType, DWORD_PTR EnumValue, char **EnumName)
{
    *EnumName = NULL;
    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return;
    }

    ULONG TypeId;
    const char *pt = strchr(EnumType, '!');
    if (pt == NULL)
        pt = EnumType;
    else
        pt ++;
    if (FAILED(g_ExtSymbols2->GetTypeId (moduleInfo[flavor].baseAddr,
                                        pt, &TypeId)))
        return;
    
    ULONG size;
    if (FAILED(g_ExtSymbols2->GetConstantName(moduleInfo[flavor].baseAddr,TypeId,EnumValue,NULL,0,&size))) {
        return;
    }
    size ++;
    *EnumName = (char *)malloc (size*sizeof(char));;
    if (FAILED(g_ExtSymbols2->GetConstantName(moduleInfo[flavor].baseAddr,TypeId,EnumValue,*EnumName,size,NULL))) {
        free (*EnumName);
        *EnumName = NULL;
        return;
    }
}
#endif  // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\inc\dbgeng.h ===
//----------------------------------------------------------------------------
//
// Debugger engine interfaces.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//----------------------------------------------------------------------------

#ifndef __DBGENG_H__
#define __DBGENG_H__

#include <stdarg.h>
#include <objbase.h>

#ifndef _WDBGEXTS_
typedef struct _WINDBG_EXTENSION_APIS32* PWINDBG_EXTENSION_APIS32;
typedef struct _WINDBG_EXTENSION_APIS64* PWINDBG_EXTENSION_APIS64;
#endif

#ifndef _CRASHLIB_
typedef struct _MEMORY_BASIC_INFORMATION64* PMEMORY_BASIC_INFORMATION64;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//
// GUIDs and interface forward declarations.
//
//----------------------------------------------------------------------------

/* f2df5f53-071f-47bd-9de6-5734c3fed689 */
DEFINE_GUID(IID_IDebugAdvanced, 0xf2df5f53, 0x071f, 0x47bd,
            0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89);
/* 5bd9d474-5975-423a-b88b-65a8e7110e65 */
DEFINE_GUID(IID_IDebugBreakpoint, 0x5bd9d474, 0x5975, 0x423a,
            0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65);
/* 27fe5639-8407-4f47-8364-ee118fb08ac8 */
DEFINE_GUID(IID_IDebugClient, 0x27fe5639, 0x8407, 0x4f47,
            0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8);
/* edbed635-372e-4dab-bbfe-ed0d2f63be81 */
DEFINE_GUID(IID_IDebugClient2, 0xedbed635, 0x372e, 0x4dab,
        0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81);
/* dd492d7f-71b8-4ad6-a8dc-1c887479ff91 */
DEFINE_GUID(IID_IDebugClient3, 0xdd492d7f, 0x71b8, 0x4ad6,
            0xa8, 0xdc, 0x1c, 0x88, 0x74, 0x79, 0xff, 0x91);
/* 5182e668-105e-416e-ad92-24ef800424ba */
DEFINE_GUID(IID_IDebugControl, 0x5182e668, 0x105e, 0x416e,
            0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba);
/* d4366723-44df-4bed-8c7e-4c05424f4588 */
DEFINE_GUID(IID_IDebugControl2, 0xd4366723, 0x44df, 0x4bed,
            0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88);
/* 88f7dfab-3ea7-4c3a-aefb-c4e8106173aa */
DEFINE_GUID(IID_IDebugDataSpaces, 0x88f7dfab, 0x3ea7, 0x4c3a,
            0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa);
/* 7a5e852f-96e9-468f-ac1b-0b3addc4a049 */
DEFINE_GUID(IID_IDebugDataSpaces2, 0x7a5e852f, 0x96e9, 0x468f,
            0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49);
/* 337be28b-5036-4d72-b6bf-c45fbb9f2eaa */
DEFINE_GUID(IID_IDebugEventCallbacks, 0x337be28b, 0x5036, 0x4d72,
            0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa);
/* 9f50e42c-f136-499e-9a97-73036c94ed2d */
DEFINE_GUID(IID_IDebugInputCallbacks, 0x9f50e42c, 0xf136, 0x499e,
            0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d);
/* 4bf58045-d654-4c40-b0af-683090f356dc */
DEFINE_GUID(IID_IDebugOutputCallbacks, 0x4bf58045, 0xd654, 0x4c40,
            0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc);
/* ce289126-9e84-45a7-937e-67bb18691493 */
DEFINE_GUID(IID_IDebugRegisters, 0xce289126, 0x9e84, 0x45a7,
            0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93);
/* f2528316-0f1a-4431-aeed-11d096e1e2ab */
DEFINE_GUID(IID_IDebugSymbolGroup, 0xf2528316, 0x0f1a, 0x4431,
            0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab);
/* 8c31e98c-983a-48a5-9016-6fe5d667a950 */
DEFINE_GUID(IID_IDebugSymbols, 0x8c31e98c, 0x983a, 0x48a5,
            0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50);
/* 3a707211-afdd-4495-ad4f-56fecdf8163f */
DEFINE_GUID(IID_IDebugSymbols2, 0x3a707211, 0xafdd, 0x4495,
            0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f);
/* 6b86fe2c-2c4f-4f0c-9da2-174311acc327 */
DEFINE_GUID(IID_IDebugSystemObjects, 0x6b86fe2c, 0x2c4f, 0x4f0c,
            0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27);
/* 0ae9f5ff-1852-4679-b055-494bee6407ee */
DEFINE_GUID(IID_IDebugSystemObjects2, 0x0ae9f5ff, 0x1852, 0x4679,
            0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee);

typedef interface DECLSPEC_UUID("f2df5f53-071f-47bd-9de6-5734c3fed689")
    IDebugAdvanced* PDEBUG_ADVANCED;
typedef interface DECLSPEC_UUID("5bd9d474-5975-423a-b88b-65a8e7110e65")
    IDebugBreakpoint* PDEBUG_BREAKPOINT;
typedef interface DECLSPEC_UUID("27fe5639-8407-4f47-8364-ee118fb08ac8")
    IDebugClient* PDEBUG_CLIENT;
typedef interface DECLSPEC_UUID("edbed635-372e-4dab-bbfe-ed0d2f63be81")
    IDebugClient2* PDEBUG_CLIENT2;
typedef interface DECLSPEC_UUID("dd492d7f-71b8-4ad6-a8dc-1c887479ff91")
    IDebugClient3* PDEBUG_CLIENT3;
typedef interface DECLSPEC_UUID("5182e668-105e-416e-ad92-24ef800424ba")
    IDebugControl* PDEBUG_CONTROL;
typedef interface DECLSPEC_UUID("d4366723-44df-4bed-8c7e-4c05424f4588")
    IDebugControl2* PDEBUG_CONTROL2;
typedef interface DECLSPEC_UUID("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa")
    IDebugDataSpaces* PDEBUG_DATA_SPACES;
typedef interface DECLSPEC_UUID("7a5e852f-96e9-468f-ac1b-0b3addc4a049")
    IDebugDataSpaces2* PDEBUG_DATA_SPACES2;
typedef interface DECLSPEC_UUID("337be28b-5036-4d72-b6bf-c45fbb9f2eaa")
    IDebugEventCallbacks* PDEBUG_EVENT_CALLBACKS;
typedef interface DECLSPEC_UUID("9f50e42c-f136-499e-9a97-73036c94ed2d")
    IDebugInputCallbacks* PDEBUG_INPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("4bf58045-d654-4c40-b0af-683090f356dc")
    IDebugOutputCallbacks* PDEBUG_OUTPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("ce289126-9e84-45a7-937e-67bb18691493")
    IDebugRegisters* PDEBUG_REGISTERS;
typedef interface DECLSPEC_UUID("f2528316-0f1a-4431-aeed-11d096e1e2ab")
    IDebugSymbolGroup* PDEBUG_SYMBOL_GROUP;
typedef interface DECLSPEC_UUID("8c31e98c-983a-48a5-9016-6fe5d667a950")
    IDebugSymbols* PDEBUG_SYMBOLS;
typedef interface DECLSPEC_UUID("3a707211-afdd-4495-ad4f-56fecdf8163f")
    IDebugSymbols2* PDEBUG_SYMBOLS2;
typedef interface DECLSPEC_UUID("6b86fe2c-2c4f-4f0c-9da2-174311acc327")
    IDebugSystemObjects* PDEBUG_SYSTEM_OBJECTS;
typedef interface DECLSPEC_UUID("0ae9f5ff-1852-4679-b055-494bee6407ee")
    IDebugSystemObjects2* PDEBUG_SYSTEM_OBJECTS2;

//----------------------------------------------------------------------------
//
// Macros.
//
//----------------------------------------------------------------------------

// Extends a 32-bit address into a 64-bit address.
#define DEBUG_EXTEND64(Addr) ((ULONG64)(LONG64)(LONG)(Addr))
    
//----------------------------------------------------------------------------
//
// Client creation functions.
//
//----------------------------------------------------------------------------

// RemoteOptions specifies connection types and
// their parameters.  Supported strings are:
//    npipe:Server=<Machine>,Pipe=<Pipe name>
//    tcp:Server=<Machine>,Port=<IP port>
STDAPI
DebugConnect(
    IN PCSTR RemoteOptions,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );

STDAPI
DebugCreate(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );
    
//----------------------------------------------------------------------------
//
// IDebugAdvanced.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugAdvanced
DECLARE_INTERFACE_(IDebugAdvanced, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugAdvanced.

    // Get/SetThreadContext offer control over
    // the full processor context for a thread.
    // Higher-level functions, such as the
    // IDebugRegisters interface, allow similar
    // access in simpler and more generic ways.
    // Get/SetThreadContext are useful when
    // large amounts of thread context must
    // be changed and processor-specific code
    // is not a problem.
    STDMETHOD(GetThreadContext)(
        THIS_
        OUT /* align_is(16) */ PVOID Context,
        IN ULONG ContextSize
        ) PURE;
    STDMETHOD(SetThreadContext)(
        THIS_
        IN /* align_is(16) */ PVOID Context,
        IN ULONG ContextSize
        ) PURE;
};
    
//----------------------------------------------------------------------------
//
// IDebugBreakpoint.
//
//----------------------------------------------------------------------------

// Types of breakpoints.
#define DEBUG_BREAKPOINT_CODE 0
#define DEBUG_BREAKPOINT_DATA 1

// Breakpoint flags.
// Go-only breakpoints are only active when
// the engine is in unrestricted execution
// mode.  They do not fire when the engine
// is stepping.
#define DEBUG_BREAKPOINT_GO_ONLY    0x00000001
// A breakpoint is flagged as deferred as long as
// its offset expression cannot be evaluated.
// A deferred breakpoint is not active.
#define DEBUG_BREAKPOINT_DEFERRED   0x00000002
#define DEBUG_BREAKPOINT_ENABLED    0x00000004
// The adder-only flag does not affect breakpoint
// operation.  It is just a marker to restrict
// output and notifications for the breakpoint to
// the client that added the breakpoint.  Breakpoint
// callbacks for adder-only breaks will only be delivered
// to the adding client.  The breakpoint can not
// be enumerated and accessed by other clients.
#define DEBUG_BREAKPOINT_ADDER_ONLY 0x00000008

// Data breakpoint access types.
// Different architectures support different
// sets of these bits.
#define DEBUG_BREAK_READ    0x00000001
#define DEBUG_BREAK_WRITE   0x00000002
#define DEBUG_BREAK_EXECUTE 0x00000004
#define DEBUG_BREAK_IO      0x00000008

// Structure for querying breakpoint information
// all at once.
typedef struct _DEBUG_BREAKPOINT_PARAMETERS
{
    ULONG64 Offset;
    ULONG Id;
    ULONG BreakType;
    ULONG ProcType;
    ULONG Flags;
    ULONG DataSize;
    ULONG DataAccessType;
    ULONG PassCount;
    ULONG CurrentPassCount;
    ULONG MatchThread;
    ULONG CommandSize;
    ULONG OffsetExpressionSize;
} DEBUG_BREAKPOINT_PARAMETERS, *PDEBUG_BREAKPOINT_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugBreakpoint
DECLARE_INTERFACE_(IDebugBreakpoint, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugBreakpoint.
    
    // Retrieves debugger engine unique ID
    // for the breakpoint.  This ID is
    // fixed as long as the breakpoint exists
    // but after that may be reused.
    STDMETHOD(GetId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Retrieves the type of break and
    // processor type for the breakpoint.
    STDMETHOD(GetType)(
        THIS_
        OUT PULONG BreakType,
        OUT PULONG ProcType
        ) PURE;
    // Returns the client that called AddBreakpoint.
    STDMETHOD(GetAdder)(
        THIS_
        OUT PDEBUG_CLIENT* Adder
        ) PURE;
        
    STDMETHOD(GetFlags)(
        THIS_
        OUT PULONG Flags
        ) PURE;
    // Only certain flags can be changed.  Flags
    // are: GO_ONLY, ENABLE.
    // Sets the given flags.
    STDMETHOD(AddFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Clears the given flags.
    STDMETHOD(RemoveFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Sets the flags.
    STDMETHOD(SetFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
        
    // Controls the offset of the breakpoint.  The
    // interpretation of the offset value depends on
    // the type of breakpoint and its settings.  It
    // may be a code address, a data address, an
    // I/O port, etc.
    STDMETHOD(GetOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;

    // Data breakpoint methods will fail is the
    // target platform does not support the
    // parameters used.
    // These methods only function for breakpoints
    // created as data breakpoints.
    STDMETHOD(GetDataParameters)(
        THIS_
        OUT PULONG Size,
        OUT PULONG AccessType
        ) PURE;
    STDMETHOD(SetDataParameters)(
        THIS_
        IN ULONG Size,
        IN ULONG AccessType
        ) PURE;
                    
    // Pass count defaults to one.
    STDMETHOD(GetPassCount)(
        THIS_
        OUT PULONG Count
        ) PURE;
    STDMETHOD(SetPassCount)(
        THIS_
        IN ULONG Count
        ) PURE;
    // Gets the current number of times
    // the breakpoint has been hit since
    // it was last triggered.
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        OUT PULONG Count
        ) PURE;

    // If a match thread is set this breakpoint will
    // only trigger if it occurs on the match thread.
    // Otherwise it triggers for all threads.
    // Thread restrictions are not currently supported
    // in kernel mode.
    STDMETHOD(GetMatchThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetMatchThreadId)(
        THIS_
        IN ULONG Thread
        ) PURE;

    // The command for a breakpoint is automatically
    // executed by the engine before the event
    // is propagated.  If the breakpoint continues
    // execution the event will begin with a continue
    // status.  If the breakpoint does not continue
    // the event will begin with a break status.
    // This allows breakpoint commands to participate
    // in the normal event status voting.
    // Breakpoint commands are only executed until
    // the first command that alters the execution
    // status, such as g, p and t.
    // Breakpoint commands are removed when the
    // current syntax changes.
    STDMETHOD(GetCommand)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetCommand)(
        THIS_
        IN PCSTR Command
        ) PURE;

    // Offset expressions are evaluated immediately
    // and at module load and unload events.  If the
    // evaluation is successful the breakpoints
    // offset is updated and the breakpoint is
    // handled normally.  If the expression cannot
    // be evaluated the breakpoint is deferred.
    // Currently the only offset expression
    // supported is a module-relative symbol
    // of the form <Module>!<Symbol>.
    STDMETHOD(GetOffsetExpression)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExpressionSize
        ) PURE;
    STDMETHOD(SetOffsetExpression)(
        THIS_
        IN PCSTR Expression
        ) PURE;

    STDMETHOD(GetParameters)(
        THIS_
        OUT PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
};


//----------------------------------------------------------------------------
//
// IDebugClient.
//
//----------------------------------------------------------------------------

// Kernel attach flags.
#define DEBUG_ATTACH_KERNEL_CONNECTION 0x00000000
// Attach to the local machine.  If this flag is not set
// a connection is made to a separate target machine using
// the given connection options.
#define DEBUG_ATTACH_LOCAL_KERNEL      0x00000001
// Attach to an eXDI driver.
#define DEBUG_ATTACH_EXDI_DRIVER       0x00000002

// GetRunningProcessSystemIdByExecutableName flags.
// By default the match allows a tail match on
// just the filename.  The match returns the first hit
// even if multiple matches exist.
#define DEBUG_GET_PROC_DEFAULT    0x00000000
// The name must match fully.
#define DEBUG_GET_PROC_FULL_MATCH 0x00000001
// The match must be the only match.
#define DEBUG_GET_PROC_ONLY_MATCH 0x00000002

// GetRunningProcessDescription flags.
#define DEBUG_PROC_DESC_DEFAULT  0x00000000
// Return only filenames, not full paths.
#define DEBUG_PROC_DESC_NO_PATHS 0x00000001

//
// Attach flags.
//

// Call DebugActiveProcess when attaching.
#define DEBUG_ATTACH_DEFAULT     0x00000000
// When attaching to a process just examine
// the process state and suspend the threads.
// DebugActiveProcess is not called so the process
// is not actually being debugged.  This is useful
// for debugging processes holding locks which
// interfere with the operation of DebugActiveProcess
// or in situations where it is not desirable to
// actually set up as a debugger.
#define DEBUG_ATTACH_NONINVASIVE 0x00000001
// Attempt to attach to a process that was abandoned
// when being debugged.  This is only supported in
// some system versions.
// This flag also allows multiple debuggers to
// attach to the same process, which can result
// in numerous problems unless very carefully
// managed.
#define DEBUG_ATTACH_EXISTING    0x00000002

//
// Process creation flags.
//

// On Windows XP this flag prevents the debug
// heap from being used in the new process.
#define DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP CREATE_UNICODE_ENVIRONMENT
// Indicates that the native NT RTL process creation
// routines should be used instead of Win32.  This
// is only meaningful for special processes that run
// as NT native processes.
#define DEBUG_CREATE_PROCESS_THROUGH_RTL   STACK_SIZE_PARAM_IS_A_RESERVATION

//
// Process options.
//

// Indicates that the debuggee process should be
// automatically detached when the debugger exits.
// A debugger can explicitly detach on exit or this
// flag can be set so that detach occurs regardless
// of how the debugger exits.
// This is only supported on some system versions.
#define DEBUG_PROCESS_DETACH_ON_EXIT    0x00000001
// Indicates that processes created by the current
// process should not be debugged.
// Modifying this flag is only supported on some
// system versions.
#define DEBUG_PROCESS_ONLY_THIS_PROCESS 0x00000002

// ConnectSession flags.
// Default connect.
#define DEBUG_CONNECT_SESSION_DEFAULT     0x00000000
// Do not output the debugger version.
#define DEBUG_CONNECT_SESSION_NO_VERSION  0x00000001
// Do not announce the connection.
#define DEBUG_CONNECT_SESSION_NO_ANNOUNCE 0x00000002

// OutputServers flags.
// Debugger servers from StartSever.
#define DEBUG_SERVERS_DEBUGGER 0x00000001
// Process servers from StartProcessServer.
#define DEBUG_SERVERS_PROCESS  0x00000002
#define DEBUG_SERVERS_ALL      0x00000003

// EndSession flags.
// Perform cleanup for the session.
#define DEBUG_END_PASSIVE          0x00000000
// Actively terminate the session and then perform cleanup.
#define DEBUG_END_ACTIVE_TERMINATE 0x00000001
// If possible, detach from all processes and then perform cleanup.
#define DEBUG_END_ACTIVE_DETACH    0x00000002
// Perform whatever cleanup is possible that doesn't require
// acquiring any locks.  This is useful for situations where
// a thread is currently using the engine but the application
// needs to exit and still wants to give the engine
// the opportunity to clean up as much as possible.
// This may leave the engine in an indeterminate state so
// further engine calls should not be made.
// When making a reentrant EndSession call from a remote
// client it is the callers responsibility to ensure
// that the server can process the request.  It is best
// to avoid making such calls.
#define DEBUG_END_REENTRANT        0x00000003

// Output mask bits.
// Normal output.
#define DEBUG_OUTPUT_NORMAL            0x00000001
// Error output.
#define DEBUG_OUTPUT_ERROR             0x00000002
// Warnings.
#define DEBUG_OUTPUT_WARNING           0x00000004
// Additional output.
#define DEBUG_OUTPUT_VERBOSE           0x00000008
// Prompt output.
#define DEBUG_OUTPUT_PROMPT            0x00000010
// Register dump before prompt.
#define DEBUG_OUTPUT_PROMPT_REGISTERS  0x00000020
// Warnings specific to extension operation.
#define DEBUG_OUTPUT_EXTENSION_WARNING 0x00000040
// Debuggee debug output, such as from OutputDebugString.
#define DEBUG_OUTPUT_DEBUGGEE          0x00000080
// Debuggee-generated prompt, such as from DbgPrompt.
#define DEBUG_OUTPUT_DEBUGGEE_PROMPT   0x00000100

// Internal debugger output, used mainly
// for debugging the debugger.  Output
// may only occur in debug builds.
// KD protocol output.
#define DEBUG_IOUTPUT_KD_PROTOCOL      0x80000000
// Remoting output.
#define DEBUG_IOUTPUT_REMOTING         0x40000000
// Breakpoint output.
#define DEBUG_IOUTPUT_BREAKPOINT       0x20000000
// Event output.
#define DEBUG_IOUTPUT_EVENT            0x10000000

// OutputIdentity flags.
#define DEBUG_OUTPUT_IDENTITY_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient
DECLARE_INTERFACE_(IDebugClient, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.
    
    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        ) PURE;
        
    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        ) PURE;
    
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;
    
    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;
};

// Per-dump-format control flags.
#define DEBUG_FORMAT_DEFAULT 0x00000000

#define DEBUG_FORMAT_USER_SMALL_FULL_MEMORY 0x00000001
#define DEBUG_FORMAT_USER_SMALL_HANDLE_DATA 0x00000002

//
// Dump information file types.
//

// Single file containing packed page file information.
#define DEBUG_DUMP_FILE_PAGE_FILE_DUMP 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient2
DECLARE_INTERFACE_(IDebugClient2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.
    
    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        ) PURE;
        
    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        ) PURE;
    
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;
    
    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        IN PCSTR InfoFile,
        IN ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        IN ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugClient3
DECLARE_INTERFACE_(IDebugClient3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.
    
    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        ) PURE;
        
    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        ) PURE;
    
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;
    
    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        IN PCSTR InfoFile,
        IN ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        IN ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;

    // IDebugClient3.

    STDMETHOD(GetRunningProcessSystemIdByExecutableNameWide)(
        THIS_
        IN ULONG64 Server,
        IN PCWSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescriptionWide)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PWSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PWSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    STDMETHOD(CreateProcessWide)(
        THIS_
        IN ULONG64 Server,
        IN PWSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    STDMETHOD(CreateProcessAndAttachWide)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PWSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugControl.
//
//----------------------------------------------------------------------------

// Execution status codes used for waiting,
// for returning current status and for
// event method return values.
#define DEBUG_STATUS_NO_CHANGE      0
#define DEBUG_STATUS_GO             1
#define DEBUG_STATUS_GO_HANDLED     2
#define DEBUG_STATUS_GO_NOT_HANDLED 3
#define DEBUG_STATUS_STEP_OVER      4
#define DEBUG_STATUS_STEP_INTO      5
#define DEBUG_STATUS_BREAK          6
#define DEBUG_STATUS_NO_DEBUGGEE    7
#define DEBUG_STATUS_STEP_BRANCH    8
#define DEBUG_STATUS_IGNORE_EVENT   9

#define DEBUG_STATUS_MASK           0xf

// This bit is added in DEBUG_CES_EXECUTION_STATUS
// notifications when the engines execution status
// is changing due to operations performed during
// a wait, such as making synchronous callbacks.  If
// the bit is not set the execution status is changing
// due to a wait being satisfied.
#define DEBUG_STATUS_INSIDE_WAIT 0x100000000

// Output control flags.
// Output generated by methods called by this
// client will be sent only to this clients
// output callbacks.
#define DEBUG_OUTCTL_THIS_CLIENT       0x00000000
// Output will be sent to all clients.
#define DEBUG_OUTCTL_ALL_CLIENTS       0x00000001
// Output will be sent to all clients except
// the client generating the output.
#define DEBUG_OUTCTL_ALL_OTHER_CLIENTS 0x00000002
// Output will be discarded immediately and will not
// be logged or sent to callbacks.
#define DEBUG_OUTCTL_IGNORE            0x00000003
// Output will be logged but not sent to callbacks.
#define DEBUG_OUTCTL_LOG_ONLY          0x00000004
// All send control bits.
#define DEBUG_OUTCTL_SEND_MASK         0x00000007
// Do not place output from this client in
// the global log file.
#define DEBUG_OUTCTL_NOT_LOGGED        0x00000008
// Send output to clients regardless of whether the
// mask allows it or not.
#define DEBUG_OUTCTL_OVERRIDE_MASK     0x00000010

// Special value which means leave the output settings
// unchanged.
#define DEBUG_OUTCTL_AMBIENT           0xffffffff

// Interrupt types.
// Force a break in if the debuggee is running.
#define DEBUG_INTERRUPT_ACTIVE  0
// Notify but do not force a break in.
#define DEBUG_INTERRUPT_PASSIVE 1
// Try and get the current engine operation to
// complete so that the engine will be available
// again.  If no wait is active this is the same
// as a passive interrupt.  If a wait is active
// this will try to cause the wait to fail without
// breaking in to the debuggee.  There is
// no guarantee that issuing an exit interrupt
// will cause the engine to become available
// as not all operations are arbitrarily
// interruptible.
#define DEBUG_INTERRUPT_EXIT    2

// OutputCurrentState flags.  These flags
// allow a particular type of information
// to be displayed but do not guarantee
// that it will be displayed.  Other global
// settings may override these flags or
// the particular state may not be available.
// For example, source line information may
// not be present so source line information
// may not be displayed.
#define DEBUG_CURRENT_DEFAULT     0x0000000f
#define DEBUG_CURRENT_SYMBOL      0x00000001
#define DEBUG_CURRENT_DISASM      0x00000002
#define DEBUG_CURRENT_REGISTERS   0x00000004
#define DEBUG_CURRENT_SOURCE_LINE 0x00000008

// Disassemble flags.
// Compute the effective address from current register
// information and display it.
#define DEBUG_DISASM_EFFECTIVE_ADDRESS 0x00000001
// If the current disassembly offset has an exact
// symbol match output the symbol.
#define DEBUG_DISASM_MATCHING_SYMBOLS  0x00000002

// Code interpretation levels for stepping
// and other operations.
#define DEBUG_LEVEL_SOURCE   0
#define DEBUG_LEVEL_ASSEMBLY 1

// Engine control flags.
#define DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION      0x00000001
#define DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS   0x00000002
// If neither allow nor disallow is specified
// the engine will pick one based on what kind
// of debugging is going on.
#define DEBUG_ENGOPT_ALLOW_NETWORK_PATHS         0x00000004
#define DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS      0x00000008
#define DEBUG_ENGOPT_NETWORK_PATHS               (0x00000004 | 0x00000008)
// Ignore loader-generated first-chance exceptions.
#define DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS    0x00000010
// Break in on a debuggees initial event.  In user-mode
// this will break at the initial system breakpoint
// for every created process.  In kernel-mode it
// will attempt break in on the target at the first
// WaitForEvent.
#define DEBUG_ENGOPT_INITIAL_BREAK               0x00000020
// Break in on the first module load for a debuggee.
#define DEBUG_ENGOPT_INITIAL_MODULE_BREAK        0x00000040
// Break in on a debuggees final event.  In user-mode
// this will break on process exit for every process.
// In kernel-mode it currently does nothing.
#define DEBUG_ENGOPT_FINAL_BREAK                 0x00000080
// By default Execute will repeat the last command
// if it is given an empty string.  The flags to
// Execute can override this behavior for a single
// command or this engine option can be used to
// change the default globally.
#define DEBUG_ENGOPT_NO_EXECUTE_REPEAT           0x00000100
// Disable places in the engine that have fallback
// code when presented with incomplete information.
//   1. Fails minidump module loads unless matching
//      executables can be mapped.
#define DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION 0x00000200
// Allow the debugger to manipulate page protections
// in order to insert code breakpoints on pages that
// do not have write access.  This option is not on
// by default as it allows breakpoints to be set
// in potentially hazardous memory areas.
#define DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS 0x00000400
// When using a software (bp/bu) breakpoint in code
// that will be executed by multiple threads it is
// possible for breakpoint management to cause the
// breakpoint to be missed or for spurious single-step
// exceptions to be generated.  This flag suspends
// all but the active thread when doing breakpoint
// management and thereby avoids multithreading
// problems.  Care must be taken when using it, though,
// as the suspension of threads can cause deadlocks
// if the suspended threads are holding resources that
// the active thread needs.  Additionally, there
// are still rare situations where problems may
// occur, but setting this flag corrects nearly
// all multithreading issues with software breakpoints.
// Thread-restricted stepping and execution supersedes
// this flags effect.
// This flag is ignored in kernel sessions as there
// is no way to restrict processor execution.
#define DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS     0x00000800
// Disallows executing shell commands through the
// engine with .shell (!!).
#define DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS     0x00001000
#define DEBUG_ENGOPT_ALL                         0x00001FFF

// General unspecified ID constant.
#define DEBUG_ANY_ID 0xffffffff

typedef struct _DEBUG_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[6];
    BOOL    Virtual;
    ULONG   FrameNumber;
} DEBUG_STACK_FRAME, *PDEBUG_STACK_FRAME;

// OutputStackTrace flags.
// Display a small number of arguments for each call.
// These may or may not be the actual arguments depending
// on the architecture, particular function and
// point during the execution of the function.
// If the current code level is assembly arguments
// are dumped as hex values.  If the code level is
// source the engine attempts to provide symbolic
// argument information.
#define DEBUG_STACK_ARGUMENTS               0x00000001
// Displays information about the functions
// frame such as __stdcall arguments, FPO
// information and whatever else is available.
#define DEBUG_STACK_FUNCTION_INFO           0x00000002
// Displays source line information for each
// frame of the stack trace.
#define DEBUG_STACK_SOURCE_LINE             0x00000004
// Show return, previous frame and other relevant address
// values for each frame.
#define DEBUG_STACK_FRAME_ADDRESSES         0x00000008
// Show column names.
#define DEBUG_STACK_COLUMN_NAMES            0x00000010
// Show non-volatile register context for each
// frame.  This is only meaningful for some platforms.
#define DEBUG_STACK_NONVOLATILE_REGISTERS   0x00000020
// Show frame numbers
#define DEBUG_STACK_FRAME_NUMBERS           0x00000040
// Show parameters with type name
#define DEBUG_STACK_PARAMETERS              0x00000080
// Show just return address in stack frame addresses
#define DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY 0x00000100

// Classes of debuggee.  Each class
// has different qualifiers for specific
// kinds of debuggees.
#define DEBUG_CLASS_UNINITIALIZED 0
#define DEBUG_CLASS_KERNEL        1
#define DEBUG_CLASS_USER_WINDOWS  2

// Generic dump types.  These can be used
// with either user or kernel sessions.
// Session-type-specific aliases are also
// provided.
#define DEBUG_DUMP_SMALL   1024
#define DEBUG_DUMP_DEFAULT 1025
#define DEBUG_DUMP_FULL    1026

// Specific types of kernel debuggees.
#define DEBUG_KERNEL_CONNECTION  0
#define DEBUG_KERNEL_LOCAL       1
#define DEBUG_KERNEL_EXDI_DRIVER 2
#define DEBUG_KERNEL_SMALL_DUMP  DEBUG_DUMP_SMALL
#define DEBUG_KERNEL_DUMP        DEBUG_DUMP_DEFAULT
#define DEBUG_KERNEL_FULL_DUMP   DEBUG_DUMP_FULL

// Specific types of Windows user debuggees.
#define DEBUG_USER_WINDOWS_PROCESS        0
#define DEBUG_USER_WINDOWS_PROCESS_SERVER 1
#define DEBUG_USER_WINDOWS_SMALL_DUMP     DEBUG_DUMP_SMALL
#define DEBUG_USER_WINDOWS_DUMP           DEBUG_DUMP_DEFAULT

// Extension flags.
#define DEBUG_EXTENSION_AT_ENGINE 0x00000000

// Execute and ExecuteCommandFile flags.
// These flags only apply to the command
// text itself; output from the executed
// command is controlled by the output
// control parameter.
// Default execution.  Command is logged
// but not output.
#define DEBUG_EXECUTE_DEFAULT    0x00000000
// Echo commands during execution.  In
// ExecuteCommandFile also echoes the prompt
// for each line of the file.
#define DEBUG_EXECUTE_ECHO       0x00000001
// Do not log or output commands during execution.
// Overridden by DEBUG_EXECUTE_ECHO.
#define DEBUG_EXECUTE_NOT_LOGGED 0x00000002
// If this flag is not set an empty string
// to Execute will repeat the last Execute
// string.
#define DEBUG_EXECUTE_NO_REPEAT  0x00000004

// Specific event filter types.  Some event
// filters have optional arguments to further
// qualify their operation.
#define DEBUG_FILTER_CREATE_THREAD       0x00000000
#define DEBUG_FILTER_EXIT_THREAD         0x00000001
#define DEBUG_FILTER_CREATE_PROCESS      0x00000002
#define DEBUG_FILTER_EXIT_PROCESS        0x00000003
// Argument is the name of a module to break on.
#define DEBUG_FILTER_LOAD_MODULE         0x00000004
// Argument is the base address of a specific module to break on.
#define DEBUG_FILTER_UNLOAD_MODULE       0x00000005
#define DEBUG_FILTER_SYSTEM_ERROR        0x00000006
// Initial breakpoint and initial module load are one-shot
// events that are triggered at the appropriate points in
// the beginning of a session.  Their commands are executed
// and then further processing is controlled by the normal
// exception and load module filters.
#define DEBUG_FILTER_INITIAL_BREAKPOINT  0x00000007
#define DEBUG_FILTER_INITIAL_MODULE_LOAD 0x00000008
// The debug output filter allows the debugger to stop
// when output is produced so that the code causing
// output can be tracked down or synchronized with.
// This filter is not supported for live dual-machine
// kernel debugging.
#define DEBUG_FILTER_DEBUGGEE_OUTPUT     0x00000009

// Event filter execution options.
// Break in always.
#define DEBUG_FILTER_BREAK               0x00000000
// Break in on second-chance exceptions.  For events
// that are not exceptions this is the same as BREAK.
#define DEBUG_FILTER_SECOND_CHANCE_BREAK 0x00000001
// Output a message about the event but continue.
#define DEBUG_FILTER_OUTPUT              0x00000002
// Continue the event.
#define DEBUG_FILTER_IGNORE              0x00000003
// Used to remove general exception filters.
#define DEBUG_FILTER_REMOVE              0x00000004

// Event filter continuation options.  These options are
// only used when DEBUG_STATUS_GO is used to continue
// execution.  If a specific go status such as
// DEBUG_STATUS_GO_NOT_HANDLED is used it controls
// the continuation.
#define DEBUG_FILTER_GO_HANDLED          0x00000000
#define DEBUG_FILTER_GO_NOT_HANDLED      0x00000001

// Specific event filter settings.
typedef struct _DEBUG_SPECIFIC_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    // If ArgumentSize is zero this filter does
    // not have an argument.  An empty argument for
    // a filter which does have an argument will take
    // one byte for the terminator.
    ULONG ArgumentSize;
} DEBUG_SPECIFIC_FILTER_PARAMETERS, *PDEBUG_SPECIFIC_FILTER_PARAMETERS;

// Exception event filter settings.
typedef struct _DEBUG_EXCEPTION_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    ULONG SecondCommandSize;
    ULONG ExceptionCode;
} DEBUG_EXCEPTION_FILTER_PARAMETERS, *PDEBUG_EXCEPTION_FILTER_PARAMETERS;

// Wait flags.
#define DEBUG_WAIT_DEFAULT 0x00000000

// Last event information structures.
typedef struct _DEBUG_LAST_EVENT_INFO_BREAKPOINT
{
    ULONG Id;
} DEBUG_LAST_EVENT_INFO_BREAKPOINT, *PDEBUG_LAST_EVENT_INFO_BREAKPOINT;

typedef struct _DEBUG_LAST_EVENT_INFO_EXCEPTION
{
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DEBUG_LAST_EVENT_INFO_EXCEPTION, *PDEBUG_LAST_EVENT_INFO_EXCEPTION;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_THREAD
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_THREAD, *PDEBUG_LAST_EVENT_INFO_EXIT_THREAD;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_PROCESS
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_PROCESS, *PDEBUG_LAST_EVENT_INFO_EXIT_PROCESS;

typedef struct _DEBUG_LAST_EVENT_INFO_LOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_LOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_LOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_UNLOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR
{
    ULONG Error;
    ULONG Level;
} DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR, *PDEBUG_LAST_EVENT_INFO_SYSTEM_ERROR;

// DEBUG_VALUE types.
#define DEBUG_VALUE_INVALID      0
#define DEBUG_VALUE_INT8         1
#define DEBUG_VALUE_INT16        2
#define DEBUG_VALUE_INT32        3
#define DEBUG_VALUE_INT64        4
#define DEBUG_VALUE_FLOAT32      5
#define DEBUG_VALUE_FLOAT64      6
#define DEBUG_VALUE_FLOAT80      7
#define DEBUG_VALUE_FLOAT82      8
#define DEBUG_VALUE_FLOAT128     9
#define DEBUG_VALUE_VECTOR64     10
#define DEBUG_VALUE_VECTOR128    11
// Count of type indices.
#define DEBUG_VALUE_TYPES        12

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif

// Force the compiler to align DEBUG_VALUE.Type on a four-byte
// boundary so that it comes out to 32 bytes total.
#include <pshpack4.h>

typedef struct _DEBUG_VALUE
{
    union
    {
        UCHAR I8;
        USHORT I16;
        ULONG I32;
        struct
        {
            // Extra NAT indicator for IA64
            // integer registers.  NAT will
            // always be false for other CPUs.
            ULONG64 I64;
            BOOL Nat;
        };
        float F32;
        double F64;
        UCHAR F80Bytes[10];
        UCHAR F82Bytes[11];
        UCHAR F128Bytes[16];
        // Vector interpretations.  The actual number
        // of valid elements depends on the vector length.
        UCHAR VI8[16];
        USHORT VI16[8];
        ULONG VI32[4];
        ULONG64 VI64[2];
        float VF32[4];
        double VF64[2];
        struct
        {
            ULONG LowPart;
            ULONG HighPart;
        } I64Parts32;
        struct
        {
            ULONG64 LowPart;
            LONG64 HighPart;
        } F128Parts64;
        // Allows raw byte access to content.  Array
        // can be indexed for as much data as Type
        // describes.  This array also serves to pad
        // the structure out to 32 bytes and reserves
        // space for future members.
        UCHAR RawBytes[28];
    };
    ULONG Type;
} DEBUG_VALUE, *PDEBUG_VALUE;

#include <poppack.h>

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif
#endif

#undef INTERFACE
#define INTERFACE IDebugControl
DECLARE_INTERFACE_(IDebugControl, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.
    
    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
            
    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        ) PURE;
    
    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
            
    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
        
    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT OPTIONAL PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        ) PURE;
    
    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        ) PURE;
                
    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;
        
    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        ) PURE;
    
    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        ) PURE;
    
    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        ) PURE;
    
    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        ) PURE;
        
    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // _EFN_ is automatically prepended to
    // the name string given.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        OUT PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        ) PURE;
};

// OutputTextReplacements flags.
#define DEBUG_OUT_TEXT_REPL_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugControl2
DECLARE_INTERFACE_(IDebugControl2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.
    
    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
            
    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        ) PURE;
    
    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
            
    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
        
    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT OPTIONAL PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        ) PURE;
    
    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        ) PURE;
                
    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;
        
    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        ) PURE;
    
    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        ) PURE;
    
    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        ) PURE;
    
    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        ) PURE;
        
    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        OUT PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        ) PURE;

    // IDebugControl2.

    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        OUT PULONG TimeDate
        ) PURE;
    // Retrieves the number of seconds since the
    // machine started running.
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        OUT PULONG UpTime
        ) PURE;

    // If the current session is a dump session,
    // retrieves any extended format information.
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        OUT PULONG FormatFlags
        ) PURE;

    // The debugger has been enhanced to allow
    // arbitrary text replacements in addition
    // to the simple $u0-$u9 text macros.
    // Text replacement takes a given source
    // text in commands and converts it to the
    // given destination text.  Replacements
    // are named by their source text so that
    // only one replacement for a source text
    // string can exist.
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        OUT PULONG NumRepl
        ) PURE;
    // If SrcText is non-NULL the replacement
    // is looked up by source text, otherwise
    // Index is used to get the Nth replacement.
    STDMETHOD(GetTextReplacement)(
        THIS_
        IN OPTIONAL PCSTR SrcText,
        IN ULONG Index,
        OUT OPTIONAL PSTR SrcBuffer,
        IN ULONG SrcBufferSize,
        OUT OPTIONAL PULONG SrcSize,
        OUT OPTIONAL PSTR DstBuffer,
        IN ULONG DstBufferSize,
        OUT OPTIONAL PULONG DstSize
        ) PURE;
    // Setting the destination text to
    // NULL removes the alias.
    STDMETHOD(SetTextReplacement)(
        THIS_
        IN PCSTR SrcText,
        IN OPTIONAL PCSTR DstText
        ) PURE;
    STDMETHOD(RemoveTextReplacements)(
        THIS
        ) PURE;
    // Outputs the complete list of current
    // replacements.
    STDMETHOD(OutputTextReplacements)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugDataSpaces.
//
//----------------------------------------------------------------------------

// Data space indices for callbacks and other methods.
#define DEBUG_DATA_SPACE_VIRTUAL       0
#define DEBUG_DATA_SPACE_PHYSICAL      1
#define DEBUG_DATA_SPACE_CONTROL       2
#define DEBUG_DATA_SPACE_IO            3
#define DEBUG_DATA_SPACE_MSR           4
#define DEBUG_DATA_SPACE_BUS_DATA      5
#define DEBUG_DATA_SPACE_DEBUGGER_DATA 6
// Count of data spaces.
#define DEBUG_DATA_SPACE_COUNT         7

// Indices for ReadDebuggerData interface
#define DEBUG_DATA_KernBase                              24
#define DEBUG_DATA_BreakpointWithStatusAddr              32
#define DEBUG_DATA_SavedContextAddr                      40
#define DEBUG_DATA_KiCallUserModeAddr                    56
#define DEBUG_DATA_KeUserCallbackDispatcherAddr          64
#define DEBUG_DATA_PsLoadedModuleListAddr                72
#define DEBUG_DATA_PsActiveProcessHeadAddr               80
#define DEBUG_DATA_PspCidTableAddr                       88
#define DEBUG_DATA_ExpSystemResourcesListAddr            96
#define DEBUG_DATA_ExpPagedPoolDescriptorAddr           104
#define DEBUG_DATA_ExpNumberOfPagedPoolsAddr            112
#define DEBUG_DATA_KeTimeIncrementAddr                  120
#define DEBUG_DATA_KeBugCheckCallbackListHeadAddr       128
#define DEBUG_DATA_KiBugcheckDataAddr                   136
#define DEBUG_DATA_IopErrorLogListHeadAddr              144
#define DEBUG_DATA_ObpRootDirectoryObjectAddr           152
#define DEBUG_DATA_ObpTypeObjectTypeAddr                160
#define DEBUG_DATA_MmSystemCacheStartAddr               168
#define DEBUG_DATA_MmSystemCacheEndAddr                 176
#define DEBUG_DATA_MmSystemCacheWsAddr                  184
#define DEBUG_DATA_MmPfnDatabaseAddr                    192
#define DEBUG_DATA_MmSystemPtesStartAddr                200
#define DEBUG_DATA_MmSystemPtesEndAddr                  208
#define DEBUG_DATA_MmSubsectionBaseAddr                 216
#define DEBUG_DATA_MmNumberOfPagingFilesAddr            224
#define DEBUG_DATA_MmLowestPhysicalPageAddr             232
#define DEBUG_DATA_MmHighestPhysicalPageAddr            240
#define DEBUG_DATA_MmNumberOfPhysicalPagesAddr          248
#define DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr     256
#define DEBUG_DATA_MmNonPagedSystemStartAddr            264
#define DEBUG_DATA_MmNonPagedPoolStartAddr              272
#define DEBUG_DATA_MmNonPagedPoolEndAddr                280
#define DEBUG_DATA_MmPagedPoolStartAddr                 288
#define DEBUG_DATA_MmPagedPoolEndAddr                   296
#define DEBUG_DATA_MmPagedPoolInformationAddr           304
#define DEBUG_DATA_MmPageSize                           312
#define DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr         320
#define DEBUG_DATA_MmTotalCommitLimitAddr               328
#define DEBUG_DATA_MmTotalCommittedPagesAddr            336
#define DEBUG_DATA_MmSharedCommitAddr                   344
#define DEBUG_DATA_MmDriverCommitAddr                   352
#define DEBUG_DATA_MmProcessCommitAddr                  360
#define DEBUG_DATA_MmPagedPoolCommitAddr                368
#define DEBUG_DATA_MmExtendedCommitAddr                 376
#define DEBUG_DATA_MmZeroedPageListHeadAddr             384
#define DEBUG_DATA_MmFreePageListHeadAddr               392
#define DEBUG_DATA_MmStandbyPageListHeadAddr            400
#define DEBUG_DATA_MmModifiedPageListHeadAddr           408
#define DEBUG_DATA_MmModifiedNoWritePageListHeadAddr    416
#define DEBUG_DATA_MmAvailablePagesAddr                 424
#define DEBUG_DATA_MmResidentAvailablePagesAddr         432
#define DEBUG_DATA_PoolTrackTableAddr                   440
#define DEBUG_DATA_NonPagedPoolDescriptorAddr           448
#define DEBUG_DATA_MmHighestUserAddressAddr             456
#define DEBUG_DATA_MmSystemRangeStartAddr               464
#define DEBUG_DATA_MmUserProbeAddressAddr               472
#define DEBUG_DATA_KdPrintCircularBufferAddr            480
#define DEBUG_DATA_KdPrintCircularBufferEndAddr         488
#define DEBUG_DATA_KdPrintWritePointerAddr              496
#define DEBUG_DATA_KdPrintRolloverCountAddr             504
#define DEBUG_DATA_MmLoadedUserImageListAddr            512
#define DEBUG_DATA_NtBuildLabAddr                       520
#define DEBUG_DATA_KiNormalSystemCall                   528
#define DEBUG_DATA_KiProcessorBlockAddr                 536
#define DEBUG_DATA_MmUnloadedDriversAddr                544
#define DEBUG_DATA_MmLastUnloadedDriverAddr             552
#define DEBUG_DATA_MmTriageActionTakenAddr              560
#define DEBUG_DATA_MmSpecialPoolTagAddr                 568
#define DEBUG_DATA_KernelVerifierAddr                   576
#define DEBUG_DATA_MmVerifierDataAddr                   584
#define DEBUG_DATA_MmAllocatedNonPagedPoolAddr          592
#define DEBUG_DATA_MmPeakCommitmentAddr                 600
#define DEBUG_DATA_MmTotalCommitLimitMaximumAddr        608
#define DEBUG_DATA_CmNtCSDVersionAddr                   616
#define DEBUG_DATA_MmPhysicalMemoryBlockAddr            624

#define DEBUG_DATA_PaeEnabled                        100000
#define DEBUG_DATA_SharedUserData                    100008

//
// Processor information structures.
//

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_ALPHA
{
    ULONG Type;
    ULONG Revision;
} DEBUG_PROCESSOR_IDENTIFICATION_ALPHA, *PDEBUG_PROCESSOR_IDENTIFICATION_ALPHA;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_AMD64
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_AMD64, *PDEBUG_PROCESSOR_IDENTIFICATION_AMD64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_IA64
{
    ULONG Model;
    ULONG Revision;
    ULONG Family;
    ULONG ArchRev;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_IA64, *PDEBUG_PROCESSOR_IDENTIFICATION_IA64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_X86
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_X86, *PDEBUG_PROCESSOR_IDENTIFICATION_X86;

typedef union _DEBUG_PROCESSOR_IDENTIFICATION_ALL
{
    DEBUG_PROCESSOR_IDENTIFICATION_ALPHA Alpha;
    DEBUG_PROCESSOR_IDENTIFICATION_AMD64 Amd64;
    DEBUG_PROCESSOR_IDENTIFICATION_IA64  Ia64;
    DEBUG_PROCESSOR_IDENTIFICATION_X86   X86;
} DEBUG_PROCESSOR_IDENTIFICATION_ALL, *PDEBUG_PROCESSOR_IDENTIFICATION_ALL;

// Indices for ReadProcessorSystemData.
#define DEBUG_DATA_KPCR_OFFSET                          0
#define DEBUG_DATA_KPRCB_OFFSET                         1
#define DEBUG_DATA_KTHREAD_OFFSET                       2
#define DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET      3
#define DEBUG_DATA_PROCESSOR_IDENTIFICATION             4
#define DEBUG_DATA_PROCESSOR_SPEED                      5

#undef INTERFACE
#define INTERFACE IDebugDataSpaces
DECLARE_INTERFACE_(IDebugDataSpaces, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
};

//
// Handle data types and structures.
//

#define DEBUG_HANDLE_DATA_TYPE_BASIC        0
#define DEBUG_HANDLE_DATA_TYPE_TYPE_NAME    1
#define DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME  2
#define DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT 3

typedef struct _DEBUG_HANDLE_DATA_BASIC
{
    ULONG TypeNameSize;
    ULONG ObjectNameSize;
    ULONG Attributes;
    ULONG GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
} DEBUG_HANDLE_DATA_BASIC, *PDEBUG_HANDLE_DATA_BASIC;

#undef INTERFACE
#define INTERFACE IDebugDataSpaces2
DECLARE_INTERFACE_(IDebugDataSpaces2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    // IDebugDataSpaces2.

    STDMETHOD(VirtualToPhysical)(
        THIS_
        IN ULONG64 Virtual,
        OUT PULONG64 Physical
        ) PURE;
    // Returns the physical addresses for the
    // N levels of the systems paging structures.
    // Level zero is the starting base physical
    // address for virtual translations.
    // Levels one-(N-1) will point to the appropriate
    // paging descriptor for the virtual address at
    // the given level of the paging hierarchy.  The
    // exact number of levels depends on many factors.
    // The last level will be the fully translated
    // physical address, matching what VirtualToPhysical
    // returns.  If the address can only be partially
    // translated S_FALSE is returned.
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        IN ULONG64 Virtual,
        OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
        IN ULONG OffsetsSize,
        OUT OPTIONAL PULONG Levels
        ) PURE;

    // System handle data is accessible in certain
    // debug sessions.  The particular data available
    // varies from session to session and platform
    // to platform.
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    // Fills memory with the given pattern.
    // The fill stops at the first non-writable byte.
    STDMETHOD(FillVirtual)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        ) PURE;
    STDMETHOD(FillPhysical)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        ) PURE;

    // Queries virtual memory mapping information given
    // an address similarly to the Win32 API VirtualQuery.
    // MEMORY_BASIC_INFORMATION64 is defined in crash.h.
    // This method currently only works for user-mode sessions.
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PMEMORY_BASIC_INFORMATION64 Info
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugEventCallbacks.
//
//----------------------------------------------------------------------------

// Interest mask bits.
#define DEBUG_EVENT_BREAKPOINT              0x00000001
#define DEBUG_EVENT_EXCEPTION               0x00000002
#define DEBUG_EVENT_CREATE_THREAD           0x00000004
#define DEBUG_EVENT_EXIT_THREAD             0x00000008
#define DEBUG_EVENT_CREATE_PROCESS          0x00000010
#define DEBUG_EVENT_EXIT_PROCESS            0x00000020
#define DEBUG_EVENT_LOAD_MODULE             0x00000040
#define DEBUG_EVENT_UNLOAD_MODULE           0x00000080
#define DEBUG_EVENT_SYSTEM_ERROR            0x00000100
#define DEBUG_EVENT_SESSION_STATUS          0x00000200
#define DEBUG_EVENT_CHANGE_DEBUGGEE_STATE   0x00000400
#define DEBUG_EVENT_CHANGE_ENGINE_STATE     0x00000800
#define DEBUG_EVENT_CHANGE_SYMBOL_STATE     0x00001000

// SessionStatus flags.
// A debuggee has been discovered for the session.
#define DEBUG_SESSION_ACTIVE                       0x00000000
// The session has been ended by EndSession.
#define DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE 0x00000001
#define DEBUG_SESSION_END_SESSION_ACTIVE_DETACH    0x00000002
#define DEBUG_SESSION_END_SESSION_PASSIVE          0x00000003
// The debuggee has run to completion.  User-mode only.
#define DEBUG_SESSION_END                          0x00000004
// The target machine has rebooted.  Kernel-mode only.
#define DEBUG_SESSION_REBOOT                       0x00000005
// The target machine has hibernated.  Kernel-mode only.
#define DEBUG_SESSION_HIBERNATE                    0x00000006
// The engine was unable to continue the session.
#define DEBUG_SESSION_FAILURE                      0x00000007

// ChangeDebuggeeState flags.
// The debuggees state has changed generally, such
// as when the debuggee has been executing.
// Argument is zero.
#define DEBUG_CDS_ALL       0xffffffff
// Registers have changed.  If only a single register
// changed, argument is the index of the register.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_REGISTERS 0x00000001
// Data spaces have changed.  If only a single
// space was affected, argument is the data
// space.  Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_DATA      0x00000002

// ChangeEngineState flags.
// The engine state has changed generally.
// Argument is zero.
#define DEBUG_CES_ALL                 0xffffffff
// Current thread changed.  This may imply a change
// of process also.  Argument is the ID of the new
// current thread.
#define DEBUG_CES_CURRENT_THREAD      0x00000001
// Effective processor changed.  Argument is the
// new processor type.
#define DEBUG_CES_EFFECTIVE_PROCESSOR 0x00000002
// Breakpoints changed.  If only a single breakpoint
// changed, argument is the ID of the breakpoint.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_BREAKPOINTS         0x00000004
// Code interpretation level changed.  Argument is
// the new level.
#define DEBUG_CES_CODE_LEVEL          0x00000008
// Execution status changed.  Argument is the new
// execution status.
#define DEBUG_CES_EXECUTION_STATUS    0x00000010
// Engine options have changed.  Argument is the new
// options value.
#define DEBUG_CES_ENGINE_OPTIONS      0x00000020
// Log file information has changed.  Argument
// is TRUE if a log file was opened and FALSE if
// a log file was closed.
#define DEBUG_CES_LOG_FILE            0x00000040
// Default number radix has changed.  Argument
// is the new radix.
#define DEBUG_CES_RADIX               0x00000080
// Event filters changed.  If only a single filter
// changed the argument is the filter's index,
// otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_EVENT_FILTERS       0x00000100
// Process options have changed.  Argument is the new
// options value.
#define DEBUG_CES_PROCESS_OPTIONS     0x00000200
// Extensions have been added or removed.
#define DEBUG_CES_EXTENSIONS          0x00000400

// ChangeSymbolState flags.
// Symbol state has changed generally, such
// as after reload operations.  Argument is zero.
#define DEBUG_CSS_ALL            0xffffffff
// Modules have been loaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_LOADS          0x00000001
// Modules have been unloaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_UNLOADS        0x00000002
// Current symbol scope changed.
#define DEBUG_CSS_SCOPE          0x00000004
// Paths have changed.
#define DEBUG_CSS_PATHS          0x00000008
// Symbol options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_SYMBOL_OPTIONS 0x00000010
// Type options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_TYPE_OPTIONS   0x00000020

#undef INTERFACE
#define INTERFACE IDebugEventCallbacks
DECLARE_INTERFACE_(IDebugEventCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugEventCallbacks.
    
    // The engine calls GetInterestMask once when
    // the event callbacks are set for a client.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;

    // A breakpoint event is generated when
    // a breakpoint exception is received and
    // it can be mapped to an existing breakpoint.
    // The callback method is given a reference
    // to the breakpoint and should release it when
    // it is done with it.
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Exceptions include breaks which cannot
    // be mapped to an existing breakpoint
    // instance.
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    // Currently the kernel does not return thread
    // or process change events.
    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        ) PURE;

    // Any of these values may be zero.
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        ) PURE;
    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        ) PURE;

    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        ) PURE;

    // Session status is synchronous like the other
    // wait callbacks but it is called as the state
    // of the session is changing rather than at
    // specific events so its return value does not
    // influence waiting.  Implementations should just
    // return DEBUG_STATUS_NO_CHANGE.
    // Also, because some of the status
    // notifications are very early or very
    // late in the session lifetime there may not be
    // current processes or threads when the notification
    // is generated.
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;

    // The following callbacks are informational
    // callbacks notifying the provider about
    // changes in debug state.  The return value
    // of these callbacks is ignored.  Implementations
    // can not call back into the engine.
    
    // Debuggee state, such as registers or data spaces,
    // has changed.
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
    // Engine state has changed.
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
    // Symbol state has changed.
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugInputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugInputCallbacks
DECLARE_INTERFACE_(IDebugInputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugInputCallbacks.
    
    // A call to the StartInput method is a request for
    // a line of input from any client.  The returned input
    // should always be zero-terminated.  The buffer size
    // provided is only a guideline.  A client can return
    // more if necessary and the engine will truncate it
    // before returning from IDebugControl::Input.
    // The return value is ignored.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        ) PURE;
    // The return value is ignored.
    STDMETHOD(EndInput)(
        THIS
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugOutputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugOutputCallbacks
DECLARE_INTERFACE_(IDebugOutputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugOutputCallbacks.
    
    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugRegisters.
//
//----------------------------------------------------------------------------

#define DEBUG_REGISTER_SUB_REGISTER 0x00000001

#define DEBUG_REGISTERS_DEFAULT 0x00000000
#define DEBUG_REGISTERS_INT32   0x00000001
#define DEBUG_REGISTERS_INT64   0x00000002
#define DEBUG_REGISTERS_FLOAT   0x00000004
#define DEBUG_REGISTERS_ALL     0x00000007

typedef struct _DEBUG_REGISTER_DESCRIPTION
{
    // DEBUG_VALUE type.
    ULONG Type;
    ULONG Flags;

    // If this is a subregister the full
    // registers description index is
    // given in SubregMaster.  The length, mask
    // and shift describe how the subregisters
    // bits fit into the full register.
    ULONG SubregMaster;
    ULONG SubregLength;
    ULONG64 SubregMask;
    ULONG SubregShift;

    ULONG Reserved0;
} DEBUG_REGISTER_DESCRIPTION, *PDEBUG_REGISTER_DESCRIPTION;

#undef INTERFACE
#define INTERFACE IDebugRegisters
DECLARE_INTERFACE_(IDebugRegisters, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugRegisters.
    STDMETHOD(GetNumberRegisters)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetDescription)(
        THIS_
        IN ULONG Register,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
        ) PURE;
    STDMETHOD(GetIndexByName)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        ) PURE;

    STDMETHOD(GetValue)(
        THIS_
        IN ULONG Register,
        OUT PDEBUG_VALUE Value
        ) PURE;
    // SetValue makes a best effort at coercing
    // the given value into the given registers
    // value type.  If the given value is larger
    // than the register can hold the least
    // significant bits will be dropped.  Float
    // to int and int to float will be done
    // if necessary.  Subregister bits will be
    // inserted into the master register.
    STDMETHOD(SetValue)(
        THIS_
        IN ULONG Register,
        IN PDEBUG_VALUE Value
        ) PURE;
    // Gets Count register values.  If Indices is
    // non-NULL it must contain Count register
    // indices which control the registers affected.
    // If Indices is NULL the registers from Start
    // to Start + Count  1 are retrieved.
    STDMETHOD(GetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Indices,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(SetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Indices,
        IN ULONG Start,
        IN /* size_is(Count) */ PDEBUG_VALUE Values
        ) PURE;
        
    // Outputs a group of registers in a well-formatted
    // way thats specific to the platforms register set.
    // Uses the line prefix.
    STDMETHOD(OutputRegisters)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;

    // Abstracted pieces of processor information.
    // The mapping of these values to architectural
    // registers is architecture-specific and their
    // interpretation and existence may vary.  They
    // are intended to be directly compatible with
    // calls which take this information, such as
    // stack walking.
    STDMETHOD(GetInstructionOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetStackOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetFrameOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbolGroup
//
//----------------------------------------------------------------------------

// OutputSymbols flags.
// Default output contains <Name>**NAME**<Offset>**OFF**<Value>**VALUE**
// per symbol.
#define DEBUG_OUTPUT_SYMBOLS_DEFAULT    0x00000000
#define DEBUG_OUTPUT_SYMBOLS_NO_NAMES   0x00000001
#define DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS 0x00000002
#define DEBUG_OUTPUT_SYMBOLS_NO_VALUES  0x00000004
#define DEBUG_OUTPUT_SYMBOLS_NO_TYPES   0x00000010

#define DEBUG_OUTPUT_NAME_END           "**NAME**"
#define DEBUG_OUTPUT_OFFSET_END         "**OFF**"
#define DEBUG_OUTPUT_VALUE_END          "**VALUE**"
#define DEBUG_OUTPUT_TYPE_END           "**TYPE**"

// DEBUG_SYMBOL_PARAMETERS flags.
// Cumulative expansion level, takes four bits.
#define DEBUG_SYMBOL_EXPANSION_LEVEL_MASK 0x0000000f
// Symbols subelements follow.
#define DEBUG_SYMBOL_EXPANDED             0x00000010
// Symbols value is read-only.
#define DEBUG_SYMBOL_READ_ONLY            0x00000020
// Symbol subelements are array elements.
#define DEBUG_SYMBOL_IS_ARRAY             0x00000040
// Symbol is a float value.
#define DEBUG_SYMBOL_IS_FLOAT             0x00000080
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_ARGUMENT          0x00000100
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_LOCAL             0x00000200

typedef struct _DEBUG_SYMBOL_PARAMETERS
{
    ULONG64 Module;
    ULONG TypeId;
    // ParentSymbol may be DEBUG_ANY_ID when unknown.
    ULONG ParentSymbol;
    // A subelement of a symbol can be a field, such
    // as in structs, unions or classes; or an array
    // element count for arrays.
    ULONG SubElements;
    ULONG Flags;
    ULONG64 Reserved;
} DEBUG_SYMBOL_PARAMETERS, *PDEBUG_SYMBOL_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugSymbolGroup
DECLARE_INTERFACE_(IDebugSymbolGroup, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbolGroup.
    STDMETHOD(GetNumberSymbols)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(AddSymbol)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        ) PURE;
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        IN PCSTR Name
        ) PURE;
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        IN ULONG Index
        ) PURE;
    STDMETHOD(GetSymbolName)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
        ) PURE;
    STDMETHOD(ExpandSymbol)(
        THIS_
        IN ULONG Index,
        IN BOOL Expand
        ) PURE;
    // Uses the line prefix.
    STDMETHOD(OutputSymbols)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN ULONG Start,
        IN ULONG Count
        ) PURE;
    STDMETHOD(WriteSymbol)(
        THIS_
        IN ULONG Index,
        IN PCSTR Value
        ) PURE;
    STDMETHOD(OutputAsType)(
        THIS_
        IN ULONG Index,
        IN PCSTR Type
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbols.
//
//----------------------------------------------------------------------------

//
// Information about a module.
//

// Flags.
#define DEBUG_MODULE_LOADED   0x00000000
#define DEBUG_MODULE_UNLOADED 0x00000001

// Symbol types.
#define DEBUG_SYMTYPE_NONE     0
#define DEBUG_SYMTYPE_COFF     1
#define DEBUG_SYMTYPE_CODEVIEW 2
#define DEBUG_SYMTYPE_PDB      3
#define DEBUG_SYMTYPE_EXPORT   4
#define DEBUG_SYMTYPE_DEFERRED 5
#define DEBUG_SYMTYPE_SYM      6
#define DEBUG_SYMTYPE_DIA      7

typedef struct _DEBUG_MODULE_PARAMETERS
{
    ULONG64 Base;
    ULONG Size;
    ULONG TimeDateStamp;
    ULONG Checksum;
    ULONG Flags;
    ULONG SymbolType;
    ULONG ImageNameSize;
    ULONG ModuleNameSize;
    ULONG LoadedImageNameSize;
    ULONG SymbolFileNameSize;
    ULONG MappedImageNameSize;
    ULONG64 Reserved[2];
} DEBUG_MODULE_PARAMETERS, *PDEBUG_MODULE_PARAMETERS;

// Scope arguments are function arguments
// and thus only change when the scope
// crosses functions.
#define DEBUG_SCOPE_GROUP_ARGUMENTS 0x00000001
// Scope locals are locals declared in a particular
// scope and are only defined within that scope.
#define DEBUG_SCOPE_GROUP_LOCALS    0x00000002
// All symbols in the scope.
#define DEBUG_SCOPE_GROUP_ALL       0x00000003

// Typed data output control flags.
#define DEBUG_OUTTYPE_DEFAULT              0x00000000
#define DEBUG_OUTTYPE_NO_INDENT            0x00000001
#define DEBUG_OUTTYPE_NO_OFFSET            0x00000002
#define DEBUG_OUTTYPE_VERBOSE              0x00000004
#define DEBUG_OUTTYPE_COMPACT_OUTPUT       0x00000008
#define DEBUG_OUTTYPE_RECURSION_LEVEL(Max) (((Max) & 0xf) << 4)
#define DEBUG_OUTTYPE_ADDRESS_OF_FIELD     0x00010000
#define DEBUG_OUTTYPE_ADDRESS_AT_END       0x00020000
#define DEBUG_OUTTYPE_BLOCK_RECURSE        0x00200000

// FindSourceFile flags.
#define DEBUG_FIND_SOURCE_DEFAULT    0x00000000
// Returns fully-qualified paths only.  If this
// is not set the path returned may be relative.
#define DEBUG_FIND_SOURCE_FULL_PATH  0x00000001
// Scans all the path elements for a match and
// returns the one that has the most similarity
// between the given file and the matching element.
#define DEBUG_FIND_SOURCE_BEST_MATCH 0x00000002

// A special value marking an offset that should not
// be treated as a valid offset.  This is only used
// in special situations where it is unlikely that
// this value would be a valid offset.
#define DEBUG_INVALID_OFFSET ((ULONG64)-1)

#undef INTERFACE
#define INTERFACE IDebugSymbols
DECLARE_INTERFACE_(IDebugSymbols, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
            
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
            
    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    
    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL /* size_is(BufferLines) */ PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        ) PURE;
};

//
// GetModuleNameString strings.
//

#define DEBUG_MODNAME_IMAGE        0x00000000
#define DEBUG_MODNAME_MODULE       0x00000001
#define DEBUG_MODNAME_LOADED_IMAGE 0x00000002
#define DEBUG_MODNAME_SYMBOL_FILE  0x00000003
#define DEBUG_MODNAME_MAPPED_IMAGE 0x00000004

//
// Type options, used with Get/SetTypeOptions.
//

// Display PUSHORT and USHORT arrays in UNICODE
#define DEBUG_TYPEOPTS_UNICODE_DISPLAY 0x00000001

#undef INTERFACE
#define INTERFACE IDebugSymbols2
DECLARE_INTERFACE_(IDebugSymbols2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
            
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
            
    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    
    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL /* size_is(BufferLines) */ PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        ) PURE;

    // IDebugSymbols2.

    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // Item is specified as in VerQueryValue.
    // Module version information is only
    // available for loaded modules and may
    // not be available in all debug sessions.
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        ) PURE;
    // Retrieves any available module name string
    // such as module name or symbol file name.
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // If symbols are deferred an error will
    // be returned.
    // E_NOINTERFACE may be returned, indicating
    // no information exists.
    STDMETHOD(GetModuleNameString)(
        THIS_
        IN ULONG Which,
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;

    // Returns the string name of a constant type.
    STDMETHOD(GetConstantName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG64 Value,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    
    // Gets name of a field in a struct
    // FieldNumber is 0 based index of field in a struct
    // Method fails with E_INVALIDARG if FieldNumber is
    // too high for the struct fields
    STDMETHOD(GetFieldName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG FieldIndex,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;

    // Control options for typed values.
    STDMETHOD(GetTypeOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSystemObjects
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugSystemObjects
DECLARE_INTERFACE_(IDebugSystemObjects, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.
    
    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.
    
    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        ) PURE;
    
    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    
    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugSystemObjects2
DECLARE_INTERFACE_(IDebugSystemObjects2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.
    
    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.
    
    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        ) PURE;
    
    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    
    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        ) PURE;

    // IDebugSystemObjects2.

    // Return the number of seconds that the current
    // process has been running.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        OUT PULONG UpTime
        ) PURE;

    // During kernel sessions the debugger retrieves
    // some information from the system thread and process
    // running on the current processor.  For example,
    // the debugger will retrieve virtual memory translation
    // information for when the debugger needs to
    // carry out its own virtual to physical translations.
    // Occasionally it can be interesting to perform
    // similar operations but on a process which isnt
    // currently running.  The follow methods allow a caller
    // to override the data offsets used by the debugger
    // so that other system threads and processes can
    // be used instead.  These values are defaulted to
    // the thread and process running on the current
    // processor each time the debuggee executes or
    // the current processor changes.
    // The thread and process settings are independent so
    // it is possible to refer to a thread in a process
    // other than the current process and vice versa.
    // Setting an offset of zero will reload the
    // default value.
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;
};

//----------------------------------------------------------------------------
//
// Extension callbacks.
//
//----------------------------------------------------------------------------

// Returns a version with the major version in
// the high word and the minor version in the low word.
#define DEBUG_EXTENSION_VERSION(Major, Minor) \
    ((((Major) & 0xffff) << 16) | ((Minor) & 0xffff))

// Initialization routine.  Called once when the extension DLL
// is loaded.  Returns a version and returns flags detailing
// overall qualities of the extension DLL.
// A session may or may not be active at the time the DLL
// is loaded so initialization routines should not expect
// to be able to query session information.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_INITIALIZE)
    (OUT PULONG Version, OUT PULONG Flags);
// Exit routine.  Called once just before the extension DLL is
// unloaded.  As with initialization, a session may or
// may not be active at the time of the call.
typedef void (CALLBACK* PDEBUG_EXTENSION_UNINITIALIZE)
    (void);

// A debuggee has been discovered for the session.  It
// is not necessarily halted.
#define DEBUG_NOTIFY_SESSION_ACTIVE       0x00000000
// The session no longer has a debuggee.
#define DEBUG_NOTIFY_SESSION_INACTIVE     0x00000001
// The debuggee is halted and accessible.
#define DEBUG_NOTIFY_SESSION_ACCESSIBLE   0x00000002
// The debuggee is running or inaccessible.
#define DEBUG_NOTIFY_SESSION_INACCESSIBLE 0x00000003

typedef void (CALLBACK* PDEBUG_EXTENSION_NOTIFY)
    (IN ULONG Notify, IN ULONG64 Argument);

// A PDEBUG_EXTENSION_CALL function can return this code
// to indicate that it was unable to handle the request
// and that the search for an extension function should
// continue down the extension DLL chain.
// Taken from STATUS_VALIDATE_CONTINUE

#define DEBUG_EXTENSION_CONTINUE_SEARCH \
    HRESULT_FROM_NT(0xC0000271L)

// Every routine in an extension DLL has the following prototype.
// The extension may be called from multiple clients so it
// should not cache the client value between calls.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_CALL)
    (IN PDEBUG_CLIENT Client, IN OPTIONAL PCSTR Args);

//----------------------------------------------------------------------------
//
// Extension functions.
//
// Extension functions differ from extension callbacks in that
// they are arbitrary functions exported from an extension DLL
// for other code callers instead of for human invocation from
// debugger commands.  Extension function pointers are retrieved
// for an extension DLL with IDebugControl::GetExtensionFunction.
//
// Extension function names must begin with _EFN_.  Other than that
// they can have any name and prototype.  Extension functions
// must be public exports of their extension DLL.  They should
// have a typedef for their function pointer prototype in an
// extension header so that callers have a header file to include
// with a type that allows a correctly-formed invocation of the
// extension function.
//
// The engine does not perform any validation of calls to
// extension functions.  Once the extension function pointer
// is retrieved with GetExtensionFunction all calls go
// directly between the caller and the extension function and
// are not mediated by the engine.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
};

//----------------------------------------------------------------------------
//
// C++ implementation helper classes.
//
//----------------------------------------------------------------------------

#ifndef DEBUG_NO_IMPLEMENTATION

//
// DebugBaseEventCallbacks provides a do-nothing base implementation
// of IDebugEventCallbacks.  A program can derive their own
// event callbacks class from DebugBaseEventCallbacks and implement
// only the methods they are interested in.  Programs must be
// careful to implement GetInterestMask appropriately.
//
class DebugBaseEventCallbacks : public IDebugEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        )
    {
        *Interface = NULL;

#if _MSC_VER >= 1100
        if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
            IsEqualIID(InterfaceId, __uuidof(IDebugEventCallbacks)))
#else
        if (IsEqualIID(InterfaceId, IID_IUnknown) ||
            IsEqualIID(InterfaceId, IID_IDebugEventCallbacks))
#endif
        {
            *Interface = (IDebugEventCallbacks *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    // IDebugEventCallbacks.
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        )
    {
        UNREFERENCED_PARAMETER(Bp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        )
    {
        UNREFERENCED_PARAMETER(Exception);
        UNREFERENCED_PARAMETER(FirstChance);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(DataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        UNREFERENCED_PARAMETER(InitialThreadHandle);
        UNREFERENCED_PARAMETER(ThreadDataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageBaseName);
        UNREFERENCED_PARAMETER(BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        )
    {
        UNREFERENCED_PARAMETER(Error);
        UNREFERENCED_PARAMETER(Level);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        )
    {
        UNREFERENCED_PARAMETER(Status);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
};

#endif // #ifndef DEBUG_NO_IMPLEMENTATION

#endif // #ifdef __cplusplus

#endif // #ifndef __DBGENG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\dbgcommands.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DbgCommands.h
//
// Public header definitions for commands and helpers.
//
//*****************************************************************************
#ifndef __dbgcommands_h__
#define __dbgcommands_h__

// Helper code.
HRESULT InitDebuggerHelper();
void TerminateDebuggerHelper();

// Commands.
void DisplayPatchTable();
BOOL LaunchAndAttachCordbg(PCSTR Args);

#endif // __dbgcommands_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\cordbg.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <engexts.h>
#include "Dbgwork.h"
#include "DbgCommands.h"
#define MAX_CLASSNAME_LENGTH    1024

STDMETHODIMP_(ULONG)
StaticEventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StaticEventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
ExcepCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXCEPTION;
    return S_OK;
}
    
STDMETHODIMP
ExcepCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    g_ExtAdvanced = m_Advanced;
    g_ExtControl = m_Control;
    g_ExtData = m_Data;
    g_ExtRegisters = m_Registers;
    g_ExtSymbols = m_Symbols;
    g_ExtSystem = m_System;
    
    return _CorExtDealWithExceptionEvent (THIS_ Exception, FirstChance);
#if 0
    m_Control->Output(DEBUG_OUTPUT_NORMAL, "Exception %X at %p, chance %d\n",
                      Exception->ExceptionCode, Exception->ExceptionAddress,
                      FirstChance ? 1 : 2);
    return DEBUG_STATUS_GO_HANDLED;
#endif
}

ExcepCallbacks g_ExcepCallbacks;
BOOL bWatchOn = FALSE;
BOOL bDebuggerOn = FALSE;

//----------------------------------------------------------------------------
//
// Extension entry points.
//
//----------------------------------------------------------------------------

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    InitDebuggerHelper();
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    TerminateDebuggerHelper();
    g_ExcepCallbacks.Uninitialize();
}

#if 0
extern "C" HRESULT CALLBACK
teb(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    ULONG64 DataOffset;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }
    
    if (*Args)
    {
        sscanf(Args, "%I64x", &DataOffset);
    }
    else
    {
        g_ExtSystem->GetCurrentThreadDataOffset(&DataOffset);
    }
    
    ExtOut("TEB at %I64x\n", DataOffset);

    TEB Teb;

    Status = g_ExtData->ReadVirtual(DataOffset, &Teb, sizeof(Teb), NULL);
    if (Status != S_OK)
    {
        ExtErr("* Unable to read TEB\n");
    }
    else
    {
        ExtOut("    ExceptionList:    %x\n", Teb.NtTib.ExceptionList);
        ExtOut("    Stack Base:       %x\n", Teb.NtTib.StackBase);
        ExtOut("    Stack Limit:      %x\n", Teb.NtTib.StackLimit);
        ExtOut("    SubSystemTib:     %x\n", Teb.NtTib.SubSystemTib);
        ExtOut("    FiberData:        %x\n", Teb.NtTib.FiberData);
        ExtOut("    ArbitraryUser:    %x\n", Teb.NtTib.ArbitraryUserPointer);
        ExtOut("    Self:             %x\n", Teb.NtTib.Self);
        ExtOut("    EnvironmentPtr:   %x\n", Teb.EnvironmentPointer);
        ExtOut("    ClientId:         %x.%x\n",
               Teb.ClientId.UniqueProcess, Teb.ClientId.UniqueThread);
        if (Teb.ClientId.UniqueProcess != Teb.RealClientId.UniqueProcess ||
            Teb.ClientId.UniqueThread != Teb.RealClientId.UniqueThread)
        {
            ExtOut("    Real ClientId:    %x.%x\n",
                   Teb.RealClientId.UniqueProcess,
                   Teb.RealClientId.UniqueThread);
        }
        ExtOut("    Real ClientId:    %x.%x\n",
               Teb.RealClientId.UniqueProcess,
               Teb.RealClientId.UniqueThread);
        ExtOut("    RpcHandle:        %x\n", Teb.ActiveRpcHandle);
        ExtOut("    Tls Storage:      %x\n", Teb.ThreadLocalStoragePointer);
        ExtOut("    PEB Address:      %x\n", Teb.ProcessEnvironmentBlock);
        ExtOut("    LastErrorValue:   %u\n", Teb.LastErrorValue);
        ExtOut("    LastStatusValue:  %x\n", Teb.LastStatusValue);
        ExtOut("    Count Owned Locks:%u\n", Teb.CountOfOwnedCriticalSections);
        ExtOut("    HardErrorsMode:   %u\n", Teb.HardErrorsAreDisabled);

        Status = S_OK;
    }

    ExtRelease();
    return Status;
}
#endif

extern "C" HRESULT CALLBACK
outreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    g_ExtRegisters->OutputRegisters(DEBUG_OUTCTL_ALL_CLIENTS,
                                    DEBUG_REGISTERS_ALL);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
enumreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Num;

    g_ExtRegisters->GetNumberRegisters(&Num);
    ExtOut("%d registers\n", Num);

    ULONG i;
    char Name[64];
    DEBUG_REGISTER_DESCRIPTION Desc;
    ULONG Reax, Rebx, Refl, Rsf, Rst0;
    ULONG RegFound = 0;

    for (i = 0; i < Num; i++)
    {
        g_ExtRegisters->GetDescription(i, Name, sizeof(Name), NULL, &Desc);

        ExtOut("  %2d: \"%s\", type %d, flags %X\n",
               i, Name, Desc.Type, Desc.Flags);
        if (Desc.Flags & DEBUG_REGISTER_SUB_REGISTER)
        {
            ExtOut("      sub to %d, len %d, mask %I64X, shift %d\n",
                   Desc.SubregMaster, Desc.SubregLength,
                   Desc.SubregMask, Desc.SubregShift);
        }
        
        // XXX drewb - Hack for testing purposes.
        if (!_strcmpi(Name, "eax"))
        {
            Reax = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "ebx"))
        {
            Rebx = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "efl"))
        {
            Refl = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "sf"))
        {
            Rsf = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "st0"))
        {
            Rst0 = i;
            RegFound++;
        }
    }

    ULONG ProcType;

    g_ExtControl->GetExecutingProcessorType(&ProcType);
    ExtOut("Processor type %d\n", ProcType);
    
    if (ProcType == IMAGE_FILE_MACHINE_I386)
    {
        DEBUG_VALUE Val;
        DEBUG_VALUE Coerce;

        if (RegFound != 5)
        {
            ExtErr("** Only found %d registers\n", RegFound);
        }
        
        Val.Type = DEBUG_VALUE_INT32;
        Val.I32 = 0x12345678;
        g_ExtRegisters->SetValue(Reax, &Val);
        Val.I32 = 12345678;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,st0", DEBUG_EXECUTE_NOT_LOGGED);

        Val.Type = DEBUG_VALUE_FLOAT32;
        Val.F32 = 1.2345f;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r st0", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rst0, &Val);
        ExtOut("st0 type is %d\n", Val.Type);
        
        g_ExtControl->CoerceValue(&Val, DEBUG_VALUE_FLOAT32, &Coerce);
        Coerce.F32 *= 2.0f;
        ExtOut("coerce type is %d, val*2 %hf\n", Coerce.Type, Coerce.F32);
        
        g_ExtRegisters->SetValue(Reax, &Val);
        g_ExtRegisters->SetValue(Rebx, &Coerce);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,ebx", DEBUG_EXECUTE_NOT_LOGGED);

        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
symnear(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    LONG Delta;

    Delta = 0;
    sscanf(Args, "%d", &Delta);
    
    ULONG64 Instr;
    char Name[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetNearNameByOffset(Instr, Delta,
                                          Name, sizeof(Name), NULL,
                      &Disp) == S_OK)
    {
        ExtOut("Symbol %d away from %p is:\n  %s + 0x%I64x\n",
               Delta, Instr, Name, Disp);
        
        if (g_ExtSymbols->GetOffsetByName(Name, &Instr) == S_OK)
        {
            ExtOut("Symbol %s has offset %p\n", Name, Instr);
        }
        else
        {
            ExtOut("Symbol %s has no offset\n", Name);
        }
    }
    else
    {
        ExtOut("No symbol %d away from %p\n", Delta, Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
line(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Instr;
    ULONG Line;
    char File[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetLineByOffset(Instr, &Line,
                                      File, sizeof(File), NULL, &Disp) == S_OK)
    {
        ExtOut("Line at %p is:\n  %s(%d) + 0x%I64x\n",
               Instr, File, Line, Disp);

        if (g_ExtSymbols->GetOffsetByLine(Line, File, &Instr) == S_OK)
        {
            ExtOut("Line %s(%d) has offset %p\n", File, Line, Instr);
        }
        else
        {
            ExtOut("Line %s(%d) has no offset\n", File, Line);
        }
    }
    else
    {
        ExtOut("No line information for %p\n", Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
sympat(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Match;
    char Name[128];
    ULONG64 Offset;
    PCSTR Pattern;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        Pattern = Args;
    }
    else
    {
        Pattern = "*";
    }

    Status = g_ExtSymbols->StartSymbolMatch(Pattern, &Match);
    if (Status != S_OK)
    {
        ExtErr("Unable to match on '%s'\n", Pattern);
    }
    else
    {
        for (;;)
        {
            Status = g_ExtSymbols->
                GetNextSymbolMatch(Match, Name, sizeof(Name), NULL, &Offset);
            if (Status != S_OK)
            {
                break;
            }

            ExtOut("%p - %s\n", Offset, Name);

            if (g_ExtControl->GetInterrupt() == S_OK)
            {
                ExtOut("** interrupt\n");
                break;
            }
        }

        g_ExtSymbols->EndSymbolMatch(Match);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
stack(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Flags;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        sscanf(Args, "%d", &Flags);
    }
    else
    {
        Flags = 0;
    }
    
    DEBUG_STACK_FRAME Frames[4];
    ULONG64 FrameOff, StackOff, InstrOff;
    ULONG Filled;

    g_ExtRegisters->GetFrameOffset(&FrameOff);
    g_ExtRegisters->GetStackOffset(&StackOff);
    g_ExtRegisters->GetInstructionOffset(&InstrOff);
    
    if (g_ExtControl->GetStackTrace(FrameOff, StackOff, InstrOff,
                                    Frames, sizeof(Frames) / sizeof(Frames[0]),
                                    &Filled) != S_OK)
    {
        ExtErr("Unable to get stack trace\n");
    }
    else
    {
        ExtOut("Filled %d frames at %p\n", Filled, InstrOff);
        g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                       Frames, Filled, Flags);
    }

    ExtOut("\nDirect:\n");
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                   NULL, 20, Flags);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tyid(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }

    if (Status == S_OK)
    {
        ExtOut("Type ID of '%s' is %d\n", Args, TypeId);
    }
    else
    {
        ExtErr("Unable to get type ID, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
typeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[MAX_CLASSNAME_LENGTH];
    ULONG TypeSize;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }
    if (Status == S_OK)
    {
        Status = g_ExtSymbols->GetTypeName(Module, TypeId, Type, sizeof(Type),
                                           &TypeSize);
    }

    if (Status == S_OK)
    {
        ExtOut("Type of '%s' is '%s':%d (%d chars)\n",
               Args, Type, TypeId, TypeSize);
    }
    else
    {
        ExtErr("Unable to get type, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tsizeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    PCSTR TypeName;
    ULONG TypeId;
    ULONG TypeSize;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    TypeName = strchr(Args, '!');
    if (TypeName == NULL)
    {
        ExtErr("Must specify Module!Type\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, TypeName, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeSize(Module, TypeId, &TypeSize);
        }
    
        if (Status == S_OK)
        {
            ExtOut("Type '%s':%d is %d bytes\n",
                   Args, TypeId, TypeSize);
        }
        else
        {
            ExtErr("Unable to get type size, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
foff(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[MAX_CLASSNAME_LENGTH];
    PCSTR Bang, Dot;
    ULONG Offset;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Dot = strchr(Bang + 1, '.');
    }
    if (Bang == NULL || Dot == NULL)
    {
        ExtErr("Syntax is Module!Type.Field\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        memcpy(Type, Bang + 1, Dot - (Bang + 1));
        Type[Dot - (Bang + 1)] = 0;
        Dot++;

        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetFieldOffset(Module, TypeId, Dot,
                                                  &Offset);
        }
        
        if (Status == S_OK)
        {
            ExtOut("Offset of %s is %d bytes\n",
                   Args, Offset);
        }
        else
        {
            ExtErr("Unable to get field offset, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
otype(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[MAX_CLASSNAME_LENGTH];
    PCSTR Bang, Space;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Space = strchr(Bang + 1, ' ');
    }
    if (Bang == NULL || Space == NULL)
    {
        ExtErr("Syntax is Module!Type Address\n");
        Status = E_INVALIDARG;
    }
    else
    {
        memcpy(Type, Bang + 1, Space - (Bang + 1));
        Type[Space - (Bang + 1)] = 0;
        Space++;

        ULONG64 Module;
        ULONG Flags = DEBUG_OUTTYPE_RECURSION_LEVEL(15);
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Space, DEBUG_VALUE_INT64, &IntVal, NULL);
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->
                OutputTypedDataVirtual(DEBUG_OUTCTL_ALL_CLIENTS,
                                       IntVal.I64, Module, TypeId, Flags);
            if (Status != S_OK)
            {
                ExtErr("Unable to output data, %X\n", Status);
            }
        }
        else
        {
            ExtErr("Unable to get type ID, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vsearch(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    ULONG Chars;
    
    sscanf(Args, "%x %x%n", &Start, &Len, &Chars);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len Byte+\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Pattern[32];
        ULONG PatLen;

        Args += Chars;
        PatLen = 0;
        for (;;)
        {
            while (*Args == ' ' || *Args == '\t')
            {
                Args++;
            }

            if (*Args == 0)
            {
                break;
            }

            sscanf(Args, "%x", &Pattern[PatLen]);
            PatLen++;

            while (*Args != 0 && *Args != ' ' && *Args != '\t')
            {
                Args++;
            }
        }

        ULONG64 Match;
        
        Status = g_ExtData->SearchVirtual(Start, Len, Pattern, PatLen, 1,
                                          &Match);
        if (Status == S_OK)
        {
            ExtOut("Match at %p\n", Match);
        }
        else
        {
            ExtErr("Search failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vread(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    
    sscanf(Args, "%x %x", &Start, &Len);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Buffer[16384];
        ULONG Read;

        if (Len > sizeof(Buffer))
        {
            ExtWarn("Buffer is only %X bytes, clamping\n", sizeof(Buffer));
            Len = sizeof(Buffer);
        }
        
        Status = g_ExtData->ReadVirtual(Start, Buffer, Len, &Read);
        if (Status == S_OK)
        {
            ExtOut("Read %X bytes\n", Read);
        }
        else
        {
            ExtErr("Read failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Dumps the debugger patch table (ie: breakpoint list).             *  
*                                                                      *
\**********************************************************************/
extern "C" HRESULT CALLBACK
DumpPatchTable(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    DisplayPatchTable();

    ExtRelease();
    return S_OK;
}


HRESULT CALLBACK
initwatch(PDEBUG_CLIENT Client, PCSTR Args)
{
    if (bWatchOn)
        return S_OK;
    
    HRESULT Status;
    PDEBUG_CLIENT Watcher = NULL;

    if ((Status = Client->CreateClient(&Watcher)) != S_OK)
    {
        goto Exit;
    }

    if ((Status = Watcher->SetEventCallbacks(&g_ExcepCallbacks)) != S_OK)
    {
        goto Exit;
    }

    Status = g_ExcepCallbacks.Initialize(Watcher);

 Exit:
    EXT_RELEASE(Watcher);
    if (Status != S_OK)
    {
        ExtErr("Unable to watch, 0x%X\n", Status);
        g_ExcepCallbacks.Uninitialize();
    }
    else
        bWatchOn = TRUE;
    
    return Status;
}

extern "C" HRESULT CALLBACK
watch(PDEBUG_CLIENT Client, PCSTR Args)
{
    return initwatch (Client, Args);
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Launch cordbg and have it automatically attach to the process     *  
*    currently being debugged.                                         *
*                                                                      *
\**********************************************************************/
extern "C" HRESULT CALLBACK
cordbg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    
    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    if (bDebuggerOn)
    {
        ExtWarn ("Debugger already launched\n");
        ExtRelease();
        return S_OK;
    }
    
    Status = initwatch (Client, Args);
    if (Status != S_OK)
    {
        ExtErr ("Fail to initialize a thread for debuger\n");
    }
    else
    {
        if (LaunchAndAttachCordbg(Args))
            bDebuggerOn = TRUE;
    }
    
    ExtRelease();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\inc\wdbgexts.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wdbgexts.h

Abstract:

    This file contains the necessary prototypes and data types for a user
    to write a debugger extension DLL.  This header file is also included
    by the NT debuggers (WINDBG & KD).

    This header file must be included after "windows.h" and "dbghelp.h".

    Please see the NT DDK documentation for specific information about
    how to write your own debugger extension DLL.

Environment:

    Win32 only.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(WDBGAPI)
#define WDBGAPI __stdcall
#endif

#if !defined(WDBGAPIV)
#define WDBGAPIV __cdecl
#endif

#ifndef _WINDEF_
typedef CONST void *LPCVOID;
#endif

#ifndef _ULONGLONG_
typedef unsigned __int64 ULONGLONG;
typedef ULONGLONG *PULONGLONG;
#endif


typedef
VOID
(WDBGAPIV*PWINDBG_OUTPUT_ROUTINE)(
    PCSTR lpFormat,
    ...
    );

typedef
ULONG_PTR
(WDBGAPI*PWINDBG_GET_EXPRESSION)(
    PCSTR lpExpression
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_EXPRESSION32)(
    PCSTR lpExpression
    );

typedef
ULONG64
(WDBGAPI*PWINDBG_GET_EXPRESSION64)(
    PCSTR lpExpression
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL)(
    PVOID      offset,
    PCHAR      pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL32)(
    ULONG      offset,
    PCHAR      pchBuffer,
    PULONG     pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL64)(
    ULONG64    offset,
    PCHAR      pchBuffer,
    PULONG64   pDisplacement
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM)(
    ULONG_PTR *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM32)(
    ULONG     *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM64)(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            count,
    PULONG           bytesread
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            length,
    PULONG           byteswritten
    );


typedef struct _EXTSTACKTRACE {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;

typedef struct _EXTSTACKTRACE32 {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE32, *PEXTSTACKTRACE32;

typedef struct _EXTSTACKTRACE64 {
    ULONG64     FramePointer;
    ULONG64     ProgramCounter;
    ULONG64     ReturnAddress;
    ULONG64     Args[4];
} EXTSTACKTRACE64, *PEXTSTACKTRACE64;


typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE32)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE64)(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE             lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;

typedef struct _WINDBG_EXTENSION_APIS32 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE32           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS32, *PWINDBG_EXTENSION_APIS32;

typedef struct _WINDBG_EXTENSION_APIS64 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION64               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL64                   lpGetSymbolRoutine;
    PWINDBG_DISASM64                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE64  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE64           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS64, *PWINDBG_EXTENSION_APIS64;


typedef struct _WINDBG_OLD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
} WINDBG_OLD_EXTENSION_APIS, *PWINDBG_OLD_EXTENSION_APIS;

typedef struct _WINDBG_OLDKD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadVirtualMemRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteVirtualMemRoutine;
    PWINDBG_OLDKD_READ_PHYSICAL_MEMORY     lpReadPhysicalMemRoutine;
    PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY    lpWritePhysicalMemRoutine;
} WINDBG_OLDKD_EXTENSION_APIS, *PWINDBG_OLDKD_EXTENSION_APIS;

typedef
VOID
(WDBGAPI*PWINDBG_OLD_EXTENSION_ROUTINE)(
    ULONG                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE32)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE64)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG64                 dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_OLDKD_EXTENSION_ROUTINE)(
    ULONG                        dwCurrentPc,
    PWINDBG_OLDKD_EXTENSION_APIS lpExtensionApis,
    PCSTR                        lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT32)(
    PWINDBG_EXTENSION_APIS32 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT64)(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_VERSION)(
    VOID
    );

#define EXT_API_VERSION_NUMBER   5
#define EXT_API_VERSION_NUMBER32 5
#define EXT_API_VERSION_NUMBER64 6

typedef struct EXT_API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} EXT_API_VERSION, *LPEXT_API_VERSION;

typedef
LPEXT_API_VERSION
(WDBGAPI*PWINDBG_EXTENSION_API_VERSION)(
    VOID
    );

#define IG_KD_CONTEXT                  1
#define IG_READ_CONTROL_SPACE          2
#define IG_WRITE_CONTROL_SPACE         3
#define IG_READ_IO_SPACE               4
#define IG_WRITE_IO_SPACE              5
#define IG_READ_PHYSICAL               6
#define IG_WRITE_PHYSICAL              7
#define IG_READ_IO_SPACE_EX            8
#define IG_WRITE_IO_SPACE_EX           9
#define IG_KSTACK_HELP                10   // obsolete
#define IG_SET_THREAD                 11
#define IG_READ_MSR                   12
#define IG_WRITE_MSR                  13
#define IG_GET_DEBUGGER_DATA          14
#define IG_GET_KERNEL_VERSION         15
#define IG_RELOAD_SYMBOLS             16
#define IG_GET_SET_SYMPATH            17
#define IG_GET_EXCEPTION_RECORD       18
#define IG_IS_PTR64                   19
#define IG_GET_BUS_DATA               20
#define IG_SET_BUS_DATA               21
#define IG_DUMP_SYMBOL_INFO           22
#define IG_LOWMEM_CHECK               23
#define IG_SEARCH_MEMORY              24
#define IG_GET_CURRENT_THREAD         25
#define IG_GET_CURRENT_PROCESS        26
#define IG_GET_TYPE_SIZE              27
#define IG_GET_CURRENT_PROCESS_HANDLE 28
#define IG_GET_INPUT_LINE             29
#define IG_GET_EXPRESSION_EX          30
#define IG_TRANSLATE_VIRTUAL_TO_PHYSICAL 31
#define IG_GET_CACHE_SIZE             32
#define IG_READ_PHYSICAL_WITH_FLAGS   33
#define IG_WRITE_PHYSICAL_WITH_FLAGS  34
#define IG_READ_PHYSICAL_WITH_FLAGS   33
#define IG_WRITE_PHYSICAL_WITH_FLAGS  34
#define IG_POINTER_SEARCH_PHYSICAL    35

#define IG_GET_TEB_ADDRESS           128
#define IG_GET_PEB_ADDRESS           129

typedef struct _PROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _READCONTROLSPACE {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _READCONTROLSPACE32 {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE32, *PREADCONTROLSPACE32;

typedef struct _READCONTROLSPACE64 {
    USHORT      Processor;
    ULONG64     Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE64, *PREADCONTROLSPACE64;

typedef struct _IOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _IOSPACE32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE32, *PIOSPACE32;

typedef struct _IOSPACE64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE64, *PIOSPACE64;

typedef struct _IOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _IOSPACE_EX32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX32, *PIOSPACE_EX32;

typedef struct _IOSPACE_EX64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX64, *PIOSPACE_EX64;

typedef struct _GETSETBUSDATA {
    ULONG       BusDataType;
    ULONG       BusNumber;
    ULONG       SlotNumber;
    PVOID       Buffer;
    ULONG       Offset;
    ULONG       Length;
} BUSDATA, *PBUSDATA;

typedef struct _SEARCHMEMORY {
    ULONG64 SearchAddress;
    ULONG64 SearchLength;
    ULONG64 FoundAddress;
    ULONG   PatternLength;
    PVOID   Pattern;
} SEARCHMEMORY, *PSEARCHMEMORY;

typedef struct _PHYSICAL {
    ULONGLONG              Address;
    ULONG                  BufLen;
    UCHAR                  Buf[1];
} PHYSICAL, *PPHYSICAL;

#define PHYS_FLAG_DEFAULT        0
#define PHYS_FLAG_CACHED         1
#define PHYS_FLAG_UNCACHED       2
#define PHYS_FLAG_WRITE_COMBINED 3

typedef struct _PHYSICAL_WITH_FLAGS {
    ULONGLONG              Address;
    ULONG                  BufLen;
    ULONG                  Flags;
    UCHAR                  Buf[1];
} PHYSICAL_WITH_FLAGS, *PPHYSICAL_WITH_FLAGS;

typedef struct _READ_WRITE_MSR {
    ULONG       Msr;
    LONGLONG    Value;
} READ_WRITE_MSR, *PREAD_WRITE_MSR;

typedef struct _GET_SET_SYMPATH {
    PCSTR       Args;       // args to !reload command
    PSTR        Result;     // returns new path
    int         Length;     // Length of result buffer
} GET_SET_SYMPATH, *PGET_SET_SYMPATH;

typedef struct _GET_TEB_ADDRESS {
    ULONGLONG   Address;
} GET_TEB_ADDRESS, *PGET_TEB_ADDRESS;

typedef struct _GET_PEB_ADDRESS {
    ULONG64     CurrentThread;
    ULONGLONG   Address;
} GET_PEB_ADDRESS, *PGET_PEB_ADDRESS;

typedef struct _GET_CURRENT_THREAD_ADDRESS {
    ULONG       Processor;
    ULONG64     Address;
} GET_CURRENT_THREAD_ADDRESS, *PGET_CURRENT_THREAD_ADDRESS;

typedef struct _GET_CURRENT_PROCESS_ADDRESS {
    ULONG       Processor;
    ULONG64     CurrentThread;
    ULONG64     Address;
} GET_CURRENT_PROCESS_ADDRESS, *PGET_CURRENT_PROCESS_ADDRESS;

typedef struct _GET_INPUT_LINE {
    PCSTR       Prompt;
    PSTR        Buffer;
    ULONG       BufferSize;
    ULONG       InputSize;
} GET_INPUT_LINE, *PGET_INPUT_LINE;

typedef struct _GET_EXPRESSION_EX {
    PCSTR       Expression;
    PCSTR       Remainder;
    ULONG64     Value;
} GET_EXPRESSION_EX, *PGET_EXPRESSION_EX;

typedef struct _TRANSLATE_VIRTUAL_TO_PHYSICAL {
    ULONG64     Virtual;
    ULONG64     Physical;
} TRANSLATE_VIRTUAL_TO_PHYSICAL, *PTRANSLATE_VIRTUAL_TO_PHYSICAL;

#define PTR_SEARCH_PHYS_ALL_HITS 0x00000001
#define PTR_SEARCH_PHYS_PTE      0x00000002

typedef struct _POINTER_SEARCH_PHYSICAL {
    IN ULONG64 Offset;
    IN ULONG64 Length;
    IN ULONG64 PointerMin;
    IN ULONG64 PointerMax;
    IN ULONG Flags;
    OUT PULONG64 MatchOffsets;
    IN ULONG MatchOffsetsSize;
    OUT ULONG MatchOffsetsCount;
} POINTER_SEARCH_PHYSICAL, *PPOINTER_SEARCH_PHYSICAL;

//
// If DBGKD_VERS_FLAG_DATA is set in Flags, info should be retrieved from
// the KDDEBUGGER_DATA block rather than from the DBGKD_GET_VERSION
// packet.  The data will remain in the version packet for a while to
// reduce compatibility problems.
//

#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built
#define DBGKD_VERS_FLAG_DATA    0x0002      // DebuggerDataList is valid
#define DBGKD_VERS_FLAG_PTR64   0x0004      // native pointers are 64 bits
#define DBGKD_VERS_FLAG_NOMM    0x0008      // No MM - don't decode PTEs
#define DBGKD_VERS_FLAG_HSS     0x0010      // hardware stepping support

#define KDBG_TAG    'GBDK'


// **********************************************************************
// DO NOT CHANGE THESE 32 BIT STRUCTURES!
// ONLY MAKE CHAGES TO THE 64 BIT VERSION BELOW!!
// **********************************************************************

//
// The following structure has changed in more than pointer size.
//
// This is the version packet for pre-NT5 Beta 2 systems.
// For now, it is also still used on x86
//
typedef struct _DBGKD_GET_VERSION32 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    ULONG   KernBase;
    ULONG   PsLoadedModuleList;

    USHORT  MachineType;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    //
    // DbgBreakPointWithStatus is a function which takes a ULONG argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //

    ULONG   DebuggerDataList;

} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;


//
// This is the debugger data packet for pre NT5 Beta 2 systems.
// For now, it is still used on x86
//

typedef struct _DBGKD_DEBUG_DATA_HEADER32 {

    LIST_ENTRY32 List;
    ULONG           OwnerTag;
    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER32, *PDBGKD_DEBUG_DATA_HEADER32;

typedef struct _KDDEBUGGER_DATA32 {

    DBGKD_DEBUG_DATA_HEADER32 Header;
    ULONG   KernBase;
    ULONG   BreakpointWithStatus;       // address of breakpoint
    ULONG   SavedContext;
    USHORT  ThCallbackStack;            // offset in thread data
    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer
    USHORT  PaeEnabled:1;
    ULONG   KiCallUserMode;             // kernel routine
    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    ULONG   PsLoadedModuleList;
    ULONG   PsActiveProcessHead;
    ULONG   PspCidTable;

    ULONG   ExpSystemResourcesList;
    ULONG   ExpPagedPoolDescriptor;
    ULONG   ExpNumberOfPagedPools;

    ULONG   KeTimeIncrement;
    ULONG   KeBugCheckCallbackListHead;
    ULONG   KiBugcheckData;

    ULONG   IopErrorLogListHead;

    ULONG   ObpRootDirectoryObject;
    ULONG   ObpTypeObjectType;

    ULONG   MmSystemCacheStart;
    ULONG   MmSystemCacheEnd;
    ULONG   MmSystemCacheWs;

    ULONG   MmPfnDatabase;
    ULONG   MmSystemPtesStart;
    ULONG   MmSystemPtesEnd;
    ULONG   MmSubsectionBase;
    ULONG   MmNumberOfPagingFiles;

    ULONG   MmLowestPhysicalPage;
    ULONG   MmHighestPhysicalPage;
    ULONG   MmNumberOfPhysicalPages;

    ULONG   MmMaximumNonPagedPoolInBytes;
    ULONG   MmNonPagedSystemStart;
    ULONG   MmNonPagedPoolStart;
    ULONG   MmNonPagedPoolEnd;

    ULONG   MmPagedPoolStart;
    ULONG   MmPagedPoolEnd;
    ULONG   MmPagedPoolInformation;
    ULONG   MmPageSize;

    ULONG   MmSizeOfPagedPoolInBytes;

    ULONG   MmTotalCommitLimit;
    ULONG   MmTotalCommittedPages;
    ULONG   MmSharedCommit;
    ULONG   MmDriverCommit;
    ULONG   MmProcessCommit;
    ULONG   MmPagedPoolCommit;
    ULONG   MmExtendedCommit;

    ULONG   MmZeroedPageListHead;
    ULONG   MmFreePageListHead;
    ULONG   MmStandbyPageListHead;
    ULONG   MmModifiedPageListHead;
    ULONG   MmModifiedNoWritePageListHead;
    ULONG   MmAvailablePages;
    ULONG   MmResidentAvailablePages;

    ULONG   PoolTrackTable;
    ULONG   NonPagedPoolDescriptor;

    ULONG   MmHighestUserAddress;
    ULONG   MmSystemRangeStart;
    ULONG   MmUserProbeAddress;

    ULONG   KdPrintCircularBuffer;
    ULONG   KdPrintCircularBufferEnd;
    ULONG   KdPrintWritePointer;
    ULONG   KdPrintRolloverCount;

    ULONG   MmLoadedUserImageList;

} KDDEBUGGER_DATA32, *PKDDEBUGGER_DATA32;

// **********************************************************************
//
// DO NOT CHANGE KDDEBUGGER_DATA32!!
// ONLY MAKE CHANGES TO KDDEBUGGER_DATA64!!!
//
// **********************************************************************


enum
{
    DBGKD_SIMULATION_NONE,
    DBGKD_SIMULATION_EXDI
};

typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    USHORT  MachineType;

    //
    // Protocol command support descriptions.
    // These allow the debugger to automatically
    // adapt to different levels of command support
    // in different kernels.
    //

    // One beyond highest packet type understood, zero based.
    UCHAR   MaxPacketType;
    // One beyond highest state change understood, zero based.
    UCHAR   MaxStateChange;
    // One beyond highest state manipulate message understood, zero based.
    UCHAR   MaxManipulate;

    // Kind of execution environment the kernel is running in,
    // such as a real machine or a simulator.  Written back
    // by the simulation if one exists.
    UCHAR   Simulation;

    USHORT  Unused[1];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;


//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 QFE addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;



/************************************

   Type Dump Ioctl

*************************************/


//
// Fields are not indented if this is set
//
#define DBG_DUMP_NO_INDENT                0x00000001
//
// Offsets are not printed if this is set
//
#define DBG_DUMP_NO_OFFSET                0x00000002
//
// Verbose output
//
#define DBG_DUMP_VERBOSE                  0x00000004
//
// Callback is done for each of fields
//
#define DBG_DUMP_CALL_FOR_EACH            0x00000008
//
// A list of type is dumped, listLink should have info about next element pointer
//
#define DBG_DUMP_LIST                     0x00000020
//
// Nothing is printed if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_NO_PRINT                 0x00000040
//
// Ioctl returns the size as usual, but will not do field prints/callbacks if this is set
//
#define DBG_DUMP_GET_SIZE_ONLY            0x00000080
//
// Specifies how much deep into structs we can go
//
#define DBG_DUMP_RECUR_LEVEL(l)           ((l & 0xf) << 8)
//
// No newlines are printed after each field
//
#define DBG_DUMP_COMPACT_OUT              0x00002000
//
// An array of type is dumped, number of elements can be specified in listLink->size
//
#define DBG_DUMP_ARRAY                    0x00008000
//
// The specified addr value is actually the address of field listLink->fName
//
#define DBG_DUMP_ADDRESS_OF_FIELD         0x00010000

//
// The specified addr value is actually the adress at the end of type
//
#define DBG_DUMP_ADDRESS_AT_END           0x00020000

//
// This could be used to copy only the primitive types like ULONG, PVOID etc.
//    - will not work with structures/unions
//
#define DBG_DUMP_COPY_TYPE_DATA           0x00040000
//
// Flag to allow read directly from physical memory
//
#define DBG_DUMP_READ_PHYSICAL            0x00080000
//
// This causes a function type to be dumped in format function(arg1, arg2, ...)
//
#define DBG_DUMP_FUNCTION_FORMAT          0x00100000
//
// This recurses on a struct but doesn't expand pointers
//
#define DBG_DUMP_BLOCK_RECURSE            0x00200000

//
// Obsolete defs
//
#define DBG_RETURN_TYPE                   0
#define DBG_RETURN_SUBTYPES               0
#define DBG_RETURN_TYPE_VALUES            0

//
// Dump and callback optons for fields - Options used in FIELD_INFO.fOptions
//

//
// Callback is done before printing the field if this is set
//
#define DBG_DUMP_FIELD_CALL_BEFORE_PRINT  0x00000001
//
// No callback is done
//
#define DBG_DUMP_FIELD_NO_CALLBACK_REQ    0x00000002
//
// Subfields of the fields are processesed
//
#define DBG_DUMP_FIELD_RECUR_ON_THIS      0x00000004
//
// fName must match completely for the field to be dumped instead just a prefix
//  match by default
//
#define DBG_DUMP_FIELD_FULL_NAME          0x00000008
//
// This causes array elements of an array field to be printed
//
#define DBG_DUMP_FIELD_ARRAY              0x00000010
//
// The data of the field is copied into fieldCallBack
//
#define DBG_DUMP_FIELD_COPY_FIELD_DATA    0x00000020
//
// In callback or when Ioctl returns, the FIELD_INFO.address has the address of field.
//  If no address is supplied for the type, it contains total offset of the field.
//
#define DBG_DUMP_FIELD_RETURN_ADDRESS     0x00001000
//
// Return the offset and size in bits instead of bytes is case of Bitfield
//
#define DBG_DUMP_FIELD_SIZE_IN_BITS       0x00002000
//
// Nothing is printed  for field if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_FIELD_NO_PRINT           0x00004000
//
// If the field is a pointer, it is dumped as a string, ANSI, WCHAR, MULTI or GUID
// depending on following options
//
#define DBG_DUMP_FIELD_DEFAULT_STRING     0x00010000
#define DBG_DUMP_FIELD_WCHAR_STRING       0x00020000
#define DBG_DUMP_FIELD_MULTI_STRING       0x00040000
#define DBG_DUMP_FIELD_GUID_STRING        0x00080000


//
// Error status returned on TYPE DUMP Ioctl failure
//
#define MEMORY_READ_ERROR            0x01
#define SYMBOL_TYPE_INDEX_NOT_FOUND  0x02
#define SYMBOL_TYPE_INFO_NOT_FOUND   0x03
#define FIELDS_DID_NOT_MATCH         0x04
#define NULL_SYM_DUMP_PARAM          0x05
#define NULL_FIELD_NAME              0x06
#define INCORRECT_VERSION_INFO       0x07
#define EXIT_ON_CONTROLC             0x08
#define CANNOT_ALLOCATE_MEMORY       0x09
#define INSUFFICIENT_SPACE_TO_COPY   0x0a


//////////////////////////////////////////////////////////////////////////*/

typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK)(
    struct _FIELD_INFO *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO {
   PUCHAR  fName;          // Name of the field
   PUCHAR  printName;      // Name to be printed at dump
   ULONG   size;           // Size of the field
   ULONG   fOptions;       // Dump Options for the field
   ULONG64 address;        // address of the field
   PVOID   fieldCallBack;  // Return info or callBack routine for the field
} FIELD_INFO, *PFIELD_INFO;

typedef struct _SYM_DUMP_PARAM {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO         listLink;      // fName here would be used to do list dump
   PVOID               Context;       // Usercontext passed to CallbackRoutine
   PSYM_DUMP_FIELD_CALLBACK CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO         Fields;        // Used to return information about field
} SYM_DUMP_PARAM, *PSYM_DUMP_PARAM;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#ifndef NOEXTAPI

#if   defined(KDEXT_64BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS64
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS64
#define DECLARE_API(s) DECLARE_API64(s)
#elif defined(KDEXT_32BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS32
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS32
#define DECLARE_API(s) DECLARE_API32(s)
#else
#define DECLARE_API(s)                             \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )
#endif

#define DECLARE_API32(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )

#define DECLARE_API64(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG64                dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )


extern WINDBG_EXTENSION_APIS   ExtensionApis;


#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define Disasm           (ExtensionApis.lpDisasmRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)


#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (PVOID)ppi, sizeof(*ppi) )


//
// BOOL
// GetDebuggerData(
//     ULONG Tag,
//     PVOID Buf,
//     ULONG Size
//     )
//

#define GetDebuggerData(TAG, BUF, SIZE)                             \
      ( (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->OwnerTag = (TAG)),      \
        (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->Size = (SIZE)),         \
        Ioctl( IG_GET_DEBUGGER_DATA, (PVOID)(BUF), (SIZE) ) )

// Check if LocalAlloc is prototyped
//#ifdef _WINBASE_

__inline VOID
ReadPhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizer
    )
{
    PPHYSICAL phy;
    *sizer = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR,  sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        Ioctl( IG_READ_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizer = phy->BufLen;
        CopyMemory( buf, phy->Buf, *sizer );
        LocalFree( phy );
    }
}

__inline VOID
WritePhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizew
    )
{
    PPHYSICAL phy;
    *sizew = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR, sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        CopyMemory( phy->Buf, buf, size );
        Ioctl( IG_WRITE_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizew = phy->BufLen;
        LocalFree( phy );
    }
}

__inline VOID
ReadPhysicalWithFlags(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    ULONG               flags,
    PULONG              sizer
    )
{
    PPHYSICAL_WITH_FLAGS phy;
    *sizer = 0;
    phy = (PPHYSICAL_WITH_FLAGS)LocalAlloc(LPTR,  sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        phy->Flags = flags;
        Ioctl( IG_READ_PHYSICAL_WITH_FLAGS, (PVOID)phy, sizeof(*phy) + size );
        *sizer = phy->BufLen;
        CopyMemory( buf, phy->Buf, *sizer );
        LocalFree( phy );
    }
}

__inline VOID
WritePhysicalWithFlags(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    ULONG               flags,
    PULONG              sizew
    )
{
    PPHYSICAL_WITH_FLAGS phy;
    *sizew = 0;
    phy = (PPHYSICAL_WITH_FLAGS)LocalAlloc(LPTR, sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        phy->Flags = flags;
        CopyMemory( phy->Buf, buf, size );
        Ioctl( IG_WRITE_PHYSICAL_WITH_FLAGS, (PVOID)phy, sizeof(*phy) + size );
        *sizew = phy->BufLen;
        LocalFree( phy );
    }
}

__inline VOID
ReadMsr(
    ULONG       MsrReg,
    ULONGLONG   *MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    Ioctl( IG_READ_MSR, (PVOID)&msr, sizeof(msr) );

    *MsrValue = msr.Value;
}

__inline VOID
WriteMsr(
    ULONG       MsrReg,
    ULONGLONG   MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    msr.Value = MsrValue;
    Ioctl( IG_WRITE_MSR, (PVOID)&msr, sizeof(msr) );
}

__inline VOID
SetThreadForOperation(
    ULONG_PTR * Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}

__inline VOID
SetThreadForOperation32(
    ULONG Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)LongToPtr(Thread), sizeof(ULONG));
}

__inline VOID
SetThreadForOperation64(
    PULONG64 Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(ULONG64));
}


__inline VOID
ReadControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE prc;
    prc = (PREADCONTROLSPACE)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

__inline VOID
ReadControlSpace32(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE32 prc;
    prc = (PREADCONTROLSPACE32)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace32( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
ReadControlSpace64(
    USHORT  processor,
    ULONG64 address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace64( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG64)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
WriteControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        CopyMemory( prc->Buf, buf, size );
        Ioctl( IG_WRITE_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        LocalFree( prc );
    }
}

// #endif //  _WINBASE_

__inline VOID
ReadIoSpace(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace32(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace64(
    ULONG64 address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
WriteIoSpace(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace32(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace64(
    ULONG64 address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx32(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx64(
    ULONG64 address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx32(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx64(
    ULONG64 address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReloadSymbols(
    IN PSTR Arg OPTIONAL
    )
/*++

Routine Description:

    Calls the debugger to reload symbols.

Arguments:

    Args - Supplies the tail of a !reload command string.

        !reload [flags] [module[=address]]
        flags:   /n  do not load from usermode list
                 /u  unload symbols, no reload
                 /v  verbose

        A value of NULL is equivalent to an empty string

Return Value:

    None

--*/
{
    Ioctl(IG_RELOAD_SYMBOLS, (PVOID)Arg, Arg?((ULONG)strlen(Arg)+1):0);
}

__inline VOID
GetSetSympath(
    IN PSTR Arg,
    OUT PSTR Result OPTIONAL,
    IN int Length
    )
/*++

Routine Description:

    Calls the debugger to set or retrieve symbol search path.

Arguments:

    Arg - Supplies new search path.  If Arg is NULL or string is empty,
            the search path is not changed and the current setting is
            returned in Result.  When the symbol search path is changed,
            a call to ReloadSymbols is made implicitly.

    Result - OPTIONAL Returns the symbol search path setting.

    Length - Supplies the size of the buffer supplied by Result.

Return Value:

    None

--*/
{
    GET_SET_SYMPATH gss;
    gss.Args = Arg;
    gss.Result = Result;
    gss.Length = Length;
    Ioctl(IG_GET_SET_SYMPATH, (PVOID)&gss, sizeof(gss));
}

#if   defined(KDEXT_64BIT)

__inline
ULONG
IsPtr64(
    void
    )
{
    static ULONG flag = (ULONG)-1;
    ULONG dw;
    if (flag == (ULONG)-1) {
        if (Ioctl(IG_IS_PTR64, &dw, sizeof(dw))) {
            flag = ((dw != 0) ? 1 : 0);
        } else {
            flag = 0;
        }
    }
    return flag;
}

__inline
ULONG
ReadListEntry(
    ULONG64 Address,
    PLIST_ENTRY64 List
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)List, sizeof(*List), &cb) && cb == sizeof(*List));
    } else {
        LIST_ENTRY32 List32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&List32,
                            sizeof(List32),
                            &cb);
        if (Status && cb == sizeof(List32)) {
            List->Flink = (ULONG64)(LONG64)(LONG)List32.Flink;
            List->Blink = (ULONG64)(LONG64)(LONG)List32.Blink;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
ReadPointer(
    ULONG64 Address,
    PULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)Pointer, sizeof(*Pointer), &cb) && cb == sizeof(*Pointer));
    } else {
        ULONG Pointer32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&Pointer32,
                            sizeof(Pointer32),
                            &cb);
        if (Status && cb == sizeof(Pointer32)) {
            *Pointer = (ULONG64)(LONG64)(LONG)Pointer32;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
WritePointer(
    ULONG64 Address,
    ULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (WriteMemory(Address, &Pointer, sizeof(Pointer), &cb) && cb == sizeof(Pointer));
    } else {
        ULONG Pointer32 = (ULONG)Pointer;
        ULONG Status;
        Status = WriteMemory(Address,
                             &Pointer32,
                             sizeof(Pointer32),
                             &cb);
        return (Status && cb == sizeof(Pointer32)) ? 1 : 0;
    }
}

/**
   This does Ioctl call for type info and returns size of the type on success.

 **/
__inline
ULONG
GetTypeSize (
   IN LPCSTR    Type
   )
{
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
      NULL, NULL, NULL, 0, NULL
   };

   return Ioctl( IG_GET_TYPE_SIZE, &Sym, Sym.size );
}

/**
    GetFieldData

   Copies the value of the specified field into pOutValue assuming TypeAddress
   points to start of the type in debugee.

   If the Field is NULL and the size of Type is <= 8 Whole type value is read into
   pOutValue. This is to allow to read in primitive types suchas ULONG, PVOID etc.

   If address is zero this considers Type a global variable.

   It raises an exception if OutSize is less than size to be copied.

   Returns 0 on success, errorvalue (defined with SYM_DUMP_PARAM) otherwise.

 **/
__inline
ULONG
GetFieldData (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Type,
    IN  LPCSTR  Field,
    IN  ULONG   OutSize,
    OUT PVOID   pOutValue
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, pOutValue};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, TypeAddress,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG RetVal;

   if (!Field) {
       Sym.nFields =0; Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
       Sym.Context = pOutValue;
   }

   ZeroMemory(pOutValue, OutSize);
   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   if (OutSize < ((Field == NULL) ? 8 : flds.size)) {
       // Fail
       dprintf("Not enough space to read %s-%s\n", Type, Field);
       RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL);
       return 0;
   }
   return RetVal;
}

//
// Typecast the buffer where value is to be read
//
#define GetFieldValue(Addr, Type, Field, OutValue)         \
     GetFieldData(Addr, Type, Field, sizeof(OutValue), (PVOID) &(OutValue))

//
// Used to read in value of a short (<= 8 bytes) fields
//
__inline
ULONG64
GetShortField (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Name,
    IN  USHORT  StoreAddress
   )
{
    static ULONG64 SavedAddress;
    static PUCHAR  SavedName;
    static ULONG   ReadPhysical;
    FIELD_INFO flds = {(PUCHAR) Name, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), SavedName, DBG_DUMP_NO_PRINT | ((StoreAddress & 2) ? DBG_DUMP_READ_PHYSICAL : 0),
       SavedAddress, NULL, NULL, NULL, 1, &flds
    };
      

    if (StoreAddress) {
        Sym.sName = (PUCHAR) Name;
        Sym.nFields = 0;
        SavedName = (PUCHAR) Name;
        Sym.addr = SavedAddress = TypeAddress;
        ReadPhysical = (StoreAddress & 2);
        return SavedAddress ? Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size ) : MEMORY_READ_ERROR; // zero on success
    } else {
        Sym.Options |= ReadPhysical ? DBG_DUMP_READ_PHYSICAL : 0;
    }

    if (!Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size )) {
        return flds.address;
    }
    return 0;
}

//
// Stores the address and type name for future reads
//
#define InitTypeRead(Addr, Type)  GetShortField(Addr, #Type, 1)

//
// Stores the address and type name for future reads
//
#define InitTypeReadPhysical(Addr, Type)  GetShortField(Addr, #Type, 3)
//
// Returns the field's value as ULONG64 if size of field is <= sizeof (ULONG64)
//
#define ReadField(Field)          GetShortField(0, #Field, 0)

//
// Read in a pointer value
//
__inline
ULONG
ReadPtr(
    ULONG64 Addr,
    PULONG64 pPointer
    )
{
    return GetFieldData(Addr, "PVOID", NULL, sizeof(ULONG64), (PVOID) pPointer);
}

/*
 * ListType
 *
 *  Routine ListType gives a callback on each element in the list of Type.
 *
 *   Type  :  Name of the type to be listed
 *
 *   NextPointer : Name of field which gives address of next element in list
 *
 *   Context, CallbackRoutine :
 *            Context and the callback routine. The address field in PFIELD_INFO
 *            parameter of callback contains the address of next Type element in list.
 *
 *   Address, ListByFieldAddress :
 *      if ListByFieldAddress is 0, Adress is the address of first element of Type List.
 *
 *   Lists by LIST_ENTRY are also handled implicitly (by Ioctl). If the NextPointer
 *   is a pointer to LIST_ENTRY type, the type address is properly calculated by
 *   subtracting the offsets.
 *
 *      If ListByFieldAddress is 1, the Address is considered to be the address of field
 *   "NextPointer" of the first Type element and first element address is derived
 *   from it.
 *
 */

__inline
ULONG
ListType (
    IN LPCSTR  Type,
    IN ULONG64 Address,
    IN USHORT  ListByFieldAddress,
    IN LPCSTR  NextPointer,
    IN PVOID   Context,
    IN PSYM_DUMP_FIELD_CALLBACK CallbackRoutine
    )
{
    FIELD_INFO flds = {(PUCHAR)NextPointer, NULL, 0, 0, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), (PUCHAR) Type, DBG_DUMP_NO_PRINT | DBG_DUMP_LIST, Address,
       &flds, Context, CallbackRoutine, 0, NULL
    };

    if (ListByFieldAddress==1) {
        //
        // Address is the address of "NextPointer"
        //
        Sym.Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
}


/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}


#endif // defined(KDEXT_64BIT)

__inline VOID
 GetCurrentProcessHandle(
    PHANDLE hp
    )
{
    Ioctl(IG_GET_CURRENT_PROCESS_HANDLE, hp, sizeof(HANDLE));
}

__inline VOID
 GetTebAddress(
    PULONGLONG Address
    )
{
    GET_TEB_ADDRESS gpt;
    gpt.Address = 0;
    Ioctl(IG_GET_TEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetPebAddress(
    ULONG64 CurrentThread,
    PULONGLONG Address
    )
{
    GET_PEB_ADDRESS gpt;
    gpt.CurrentThread = CurrentThread;
    gpt.Address = 0;
    Ioctl(IG_GET_PEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetCurrentThreadAddr(
    DWORD    Processor,
    PULONG64  Address
    )
{
    GET_CURRENT_THREAD_ADDRESS ct;
    ct.Processor = Processor;
    Ioctl(IG_GET_CURRENT_THREAD, (PVOID)&ct, sizeof(ct));
    *Address = ct.Address;
}

__inline VOID
 GetCurrentProcessAddr(
    DWORD    Processor,
    ULONG64  CurrentThread,
    PULONG64 Address
    )
{
    GET_CURRENT_PROCESS_ADDRESS cp;
    cp.Processor = Processor;
    cp.CurrentThread = CurrentThread;
    Ioctl(IG_GET_CURRENT_PROCESS, (PVOID)&cp, sizeof(cp));
    *Address = cp.Address;
}

__inline VOID
SearchMemory(
    ULONG64  SearchAddress,
    ULONG64  SearchLength,
    ULONG    PatternLength,
    PVOID    Pattern,
    PULONG64 FoundAddress
    )
{
    SEARCHMEMORY sm;
    sm.SearchAddress = SearchAddress;
    sm.SearchLength  = SearchLength;
    sm.FoundAddress  = 0;
    sm.PatternLength = PatternLength;
    sm.Pattern       = Pattern;
    Ioctl(IG_SEARCH_MEMORY, (PVOID)&sm, sizeof(sm));
    *FoundAddress = sm.FoundAddress;
}

__inline ULONG
GetInputLine(
    PCSTR Prompt,
    PSTR Buffer,
    ULONG BufferSize
    )
{
    GET_INPUT_LINE InLine;
    InLine.Prompt = Prompt;
    InLine.Buffer = Buffer;
    InLine.BufferSize = BufferSize;
    if (Ioctl(IG_GET_INPUT_LINE, (PVOID)&InLine, sizeof(InLine)))
    {
        return InLine.InputSize;
    }
    else
    {
        return 0;
    }
}

__inline BOOL
GetExpressionEx(
    PCSTR Expression,
    ULONG64* Value,
    PCSTR* Remainder
    )
{
    GET_EXPRESSION_EX Expr;
    Expr.Expression = Expression;
    if (Ioctl(IG_GET_EXPRESSION_EX, (PVOID)&Expr, sizeof(Expr)))
    {
        *Value = Expr.Value;

        if (Remainder != NULL)
        {
            *Remainder = Expr.Remainder;
        }

        return TRUE;
    }

    return FALSE;
}

__inline BOOL
TranslateVirtualToPhysical(
    ULONG64 Virtual,
    ULONG64* Physical
    )
{
    TRANSLATE_VIRTUAL_TO_PHYSICAL VToP;
    VToP.Virtual = Virtual;
    if (Ioctl(IG_TRANSLATE_VIRTUAL_TO_PHYSICAL, (PVOID)&VToP, sizeof(VToP)))
    {
        *Physical = VToP.Physical;
        return TRUE;
    }

    return FALSE;
}

__inline BOOL
GetDebuggerCacheSize(
    OUT PULONG64 CacheSize
    )
{
    return Ioctl(IG_GET_CACHE_SIZE, (PVOID) CacheSize, sizeof(ULONG64));
}

#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\dbgwork.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DbgWork.h
//
// Debugger implementation for strike commands.
//
//*****************************************************************************
#ifndef __dbgwork_h__
#define __dbgwork_h__

#include "DebugMacros.h"
#include "DbgIPCEvents.h"
#include "engexts.h"

//----------------------------------------------------------------------------
//
// StaticEventCallbacks.
//
//----------------------------------------------------------------------------

class StaticEventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

//----------------------------------------------------------------------------
//
// ExcepCallbacks.
//
//----------------------------------------------------------------------------

class ExcepCallbacks : public StaticEventCallbacks
{
public:
    ExcepCallbacks(void)
    {
        m_Advanced = NULL;
        m_Client = NULL;
        m_Control = NULL;
        m_Data = NULL;
        m_Registers = NULL;
        m_Symbols = NULL;
        m_System = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        );

    HRESULT Initialize(PDEBUG_CLIENT Client);
    void Uninitialize(void);
    
private:
    PDEBUG_ADVANCED       m_Advanced;
    PDEBUG_CLIENT         m_Client;
    PDEBUG_CONTROL        m_Control;
    PDEBUG_DATA_SPACES    m_Data;
    PDEBUG_REGISTERS      m_Registers;
    PDEBUG_SYMBOLS        m_Symbols;
    PDEBUG_SYSTEM_OBJECTS m_System;
};

STDMETHODIMP
_CorExtDealWithExceptionEvent (
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    );

bool DbgReadProcessMemory(
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead);



// Find the runtime offsets struct in the target process.  This struct
// is used by the cor debugger to find other key data structures.
DebuggerIPCRuntimeOffsets *GetRuntimeOffsets(void);


//*****************************************************************************
// This class wraps the patch table that lives in a com+ debuggee.
//*****************************************************************************
class CPatchTableWrapper
{
public:
    CPatchTableWrapper(DebuggerIPCRuntimeOffsets *pRuntimeOffsets);
    ~CPatchTableWrapper();

    // Reload the patch table snapshot based on the current state.
    HRESULT RefreshPatchTable();

    // Free up the current patch table snapshot.
    void ClearPatchTable();

    // Prints the current snapshot of patches.
    void PrintPatchTable();

    // Returns true if the address given contains a patch.
//    int IsAddressPatched(DWORD_PTR dwAddress);

    // Given a local copy of memory and the address that this copy came
    // from, examine it for patches that may have been placed and replace
    // the patch with the real instruction.  This must be done before
    // dissasembling code or dumping memory.
//    void UnpatchMemory(
//        DWORD_PTR   dwAddress,              // The base address in the process.
//        void        *rgMemory,              // The local copy of memory.
//        ULONG       cbMemory);              // How big is the copy.

    // Return the first patch in the table, or 0 if none.
    CORDB_ADDRESS GetFirstPatch(
        USHORT      &index,
        BYTE        *pinstruction);
    // Get the next patch based on index.
    CORDB_ADDRESS GetNextPatch(
        USHORT      &index,
        BYTE        *pinstruction);

private:
    DebuggerIPCRuntimeOffsets *m_pRuntimeOffsets;

    BYTE*                   m_pPatchTable;  // If we haven't gotten the table,
                                            // then m_pPatchTable is NULL
    BYTE                    *m_rgData;      // so we know where to write the
                                            // changes patchtable back to
    USHORT                  *m_rgNextPatch;
    UINT                    m_cPatch;

    DWORD                   *m_rgUncommitedOpcode;
    
#define MAX_ADDRESS     (0xFFFFFFFFFFFFFFFF)
#define MIN_ADDRESS     (0x0)
    CORDB_ADDRESS           m_minPatchAddr; //smallest patch in table
    CORDB_ADDRESS           m_maxPatchAddr;

    USHORT                  m_iFirstPatch;
};

#ifndef DPT_TERMINATING_INDEX
#define DPT_TERMINATING_INDEX (0xFFFF)
#endif



#endif // __dbgwork_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\inc\dbghelp.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#define DBHLP_DEPRECIATED DECLSPEC_DEPRECATED
#endif
#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACK)(
    PSTR  filename,
    PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server exports

typedef BOOL (WINAPI *PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, PVOID, DWORD, DWORD, LPSTR);
typedef BOOL (WINAPI *PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI *PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI *PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (WINAPI *PSYMBOLSERVERGETOPTIONSPROC)();

#define SSRVOPT_CALLBACK    0x001
#define SSRVOPT_DWORD       0x002
#define SSRVOPT_DWORDPTR    0x004
#define SSRVOPT_GUIDPTR     0x008
#define SSRVOPT_OLDGUIDPTR  0x010
#define SSRVOPT_UNATTENDED  0x020
#define SSRVOPT_NOCOPY      0x040
#define SSRVOPT_PARENTWIN   0x080
#define SSRVOPT_PARAMTYPE   0x100
#define SSRVOPT_RESET    ((ULONG_PTR)-1)

#define SSRVACTION_TRACE 1


#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );


//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1

typedef struct _DBGHELP_MODLOAD_DATA {
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
 #define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE {
    DWORD64                     ModBase;                // base address of loaded module
    PCHAR                       FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum {
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

typedef struct _IMAGEHLP_CBA_EVENT {
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
    HANDLE                      hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
    HANDLE                      hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
SymSetParentWindow(
    HWND hwnd
    );

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE         0x00000001
#define SYMOPT_UNDNAME                  0x00000002
#define SYMOPT_DEFERRED_LOADS           0x00000004
#define SYMOPT_NO_CPP                   0x00000008
#define SYMOPT_LOAD_LINES               0x00000010
#define SYMOPT_OMAP_FIND_NEAREST        0x00000020
#define SYMOPT_LOAD_ANYTHING            0x00000040
#define SYMOPT_IGNORE_CVREC             0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS     0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS     0x00000200
#define SYMOPT_EXACT_SYMBOLS            0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS   0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH        0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES    0x00002000
#define SYMOPT_PUBLICS_ONLY             0x00004000

#define SYMOPT_DEBUG                    0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymMatchString(
    IN LPSTR string,
    IN LPSTR expression,
    IN BOOL  fCase
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSOURCFILES_CALLBACK)(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    );

BOOL
IMAGEAPI
SymEnumSourceFiles(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN LPSTR   Mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID   UserContext
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#define SLMFLAG_VIRTUAL 0x1

DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE         hProcess,
    IN  HANDLE         hFile,
    IN  PSTR           ImageName,
    IN  PSTR           ModuleName,
    IN  DWORD64        BaseOfDll,
    IN  DWORD          DllSize,
    IN  PMODLOAD_DATA  Data,
    IN  DWORD          Flags
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC {
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Reserved2;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


ULONG
IMAGEAPI
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    );

BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    );

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    IN HANDLE                       hProcess,
    IN DWORD64                      Address,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO {
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS {
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

BOOL
IMAGEAPI
SymAddSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Size,
    IN DWORD                        Flags
    );

BOOL
IMAGEAPI
SymDeleteSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Flags
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      Data,
    LPDWORD     DataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    IN LPSTR                              FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    IN LPWSTR                             FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif


// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    );

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    USHORT Reserved0;              // Reserved for future use. Must be zero.

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    ULONG32 Reserved1;             // Reserved for future use.

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal         = 0x0000,
    MiniDumpWithDataSegs   = 0x0001,
    MiniDumpWithFullMemory = 0x0002,
    MiniDumpWithHandleData = 0x0004,
    MiniDumpFilterMemory   = 0x0008,
    MiniDumpScanMemory     = 0x0010,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\engexts.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
//----------------------------------------------------------------------------

#define DEBUG_NO_IMPLEMENTATION
#include <engexts.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\dbgwork.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DbgWork.cpp
//
// Debugger implementation for strike commands.
//
//*****************************************************************************
#ifndef UNDER_CE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "engexts.h"
#include "dbgwork.h"
#include "IPCManagerInterface.h"
#include "WinWrap.h"

#if 0
#ifdef _DEBUG
#define LOGGING_ENABLED
#endif
#endif

#ifdef LOGGING_ENABLED
void DoLog(const char *sz, ...);
#define LOGSTRIKE(x)  do { DoLog x; } while (0)
#else
#define LOGSTRIKE(x)
#endif

//********** globals. *********************************************************
DebuggerIPCControlBlock *g_pDCB = 0;        // Out-of-proc pointer to control block.
DebuggerIPCRuntimeOffsets g_RuntimeOffsets; // Offsets of key data.
bool                      g_RuntimeOffsetsLoaded = false;
IPCReaderInterface *g_pIPCReader = 0;       // Open IPC block for a process.


//********** Code. ************************************************************



//*****************************************************************************
//
// ----------
// COMMANDS
// ----------
//
//*****************************************************************************
void DisplayPatchTable()
{
    HRESULT     hr;
    
    DebuggerIPCRuntimeOffsets *pRuntimeOffsets = GetRuntimeOffsets();
    if (!pRuntimeOffsets)
        return;

    CPatchTableWrapper PatchTable(pRuntimeOffsets);
    hr = PatchTable.RefreshPatchTable();
    if (SUCCEEDED(hr))
        PatchTable.PrintPatchTable();
}

//*****************************************************************************
//
// ----------
// SETUP/SHUTDOWN
// ----------
//
//*****************************************************************************

void CloseIPCBlock()
{
    // Terminate the IPC handler.
    if (g_pIPCReader)
    {
        g_pIPCReader->ClosePrivateBlock();
        delete g_pIPCReader;
    }
    g_pIPCReader = 0;
}

HRESULT OpenIPCBlock()
{
    HRESULT     hr = S_OK;

    // If not currently open, create it and open it.
    if (!g_pIPCReader)
    {
        g_pIPCReader = new IPCReaderInterface;
        if (!g_pIPCReader)
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }
    
        ULONG PId;
        g_ExtSystem->GetCurrentProcessSystemId (&PId);
        hr = g_pIPCReader->OpenPrivateBlockOnPid(PId);
    }
    
ErrExit:
    if (FAILED(hr))
    {
        CloseIPCBlock();
    }
    return (hr);
}

HRESULT InitDebuggerHelper()
{
    OnUnicodeSystem();
    return S_OK;
}

void TerminateDebuggerHelper()
{
    CloseIPCBlock();
}



//*****************************************************************************
//
// ----------
// HELPER CODE
// ----------
//
//*****************************************************************************


//*****************************************************************************
// spews logging data using the printf routine.
//*****************************************************************************
#ifdef LOGGING_ENABLED
#define DoLog  ExtOut
#endif


//*****************************************************************************
// This is a friendly wrapper for the ntsd extension for reading memory.  It
// allows us to cut/paste code from the debugger DI project more redily.
//*****************************************************************************
bool DbgReadProcessMemory(
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead)
{
    HRESULT Status;
    
    Status = g_ExtData->ReadVirtual((ULONG64)lpBaseAddress, lpBuffer,
                                    nSize, lpNumberOfBytesRead);
    if (Status != S_OK)
        ExtErr ("DbgReadMemory failed to read %p for %d bytes.\n",
                lpBaseAddress, nSize);
    return (Status == S_OK);
}


//*****************************************************************************
// Read the IPC block header from the left side and return a pointer to a local
// copy of the debugger control block.
//*****************************************************************************
DebuggerIPCControlBlock *GetIPCDCB()
{
    if (g_pDCB)
        return (g_pDCB);
    
    // Fault in an IPC reader if need be.
    if (FAILED(OpenIPCBlock()))
        return (0);

    // The EE may not be loaded yet, but if it is, return the private
    // IPC block.
    g_pDCB = g_pIPCReader->GetDebugBlock();

    return (g_pDCB);
}


//*****************************************************************************
// Find the runtime offsets struct in the target process.  This struct
// is used by the cor debugger to find other key data structures.
//*****************************************************************************
DebuggerIPCRuntimeOffsets *GetRuntimeOffsets()
{
    if (g_RuntimeOffsetsLoaded)
        return &g_RuntimeOffsets;
    
    DebuggerIPCControlBlock *pDCB = GetIPCDCB();
    if (!pDCB)
        return 0;

    // Copy it every time, it may have changed.
    if (DbgReadProcessMemory(pDCB->m_runtimeOffsets, &g_RuntimeOffsets,
                             sizeof(DebuggerIPCRuntimeOffsets), NULL) == 0)
        return (NULL);
    
    LOGSTRIKE(("dbgwork: Runtime offsets:\n"));
    LOGSTRIKE((
         "    m_firstChanceHijackFilterAddr=  0x%08x\n"
         "    m_genericHijackFuncAddr=        0x%08x\n"
         "    m_excepForRuntimeBPAddr=        0x%08x\n"
         "    m_excepNotForRuntimeBPAddr=     0x%08x\n"
         "    m_notifyRSOfSyncCompleteBPAddr= 0x%08x\n"
         "    m_TLSIndex=                     0x%08x\n"
         "    m_EEThreadStateOffset=          0x%08x\n"
         "    m_EEThreadPGCDisabledOffset=    0x%08x\n"
         "    m_EEThreadDebuggerWordOffset=   0x%08x\n"
         "    m_EEThreadMaxNeededSize=        0x%08x\n"
         "    m_EEThreadSteppingStateMask=    0x%08x\n"
         "    m_pPatches=                     0x%08x\n"
         "    m_offRgData=                    0x%08x\n"
         "    m_offCData=                     0x%08x\n"
         "    m_cbPatch=                      0x%08x\n"
         "    m_offAddr=                      0x%08x\n"
         "    m_offOpcode=                    0x%08x\n"
         "    m_cbOpcode=                     0x%08x\n"
         "    m_verMajor=                     0x%08x\n"
         "    m_verMinor=                     0x%08x\n",
         g_RuntimeOffsets.m_firstChanceHijackFilterAddr,
         g_RuntimeOffsets.m_genericHijackFuncAddr,
         g_RuntimeOffsets.m_excepForRuntimeBPAddr,
         g_RuntimeOffsets.m_excepNotForRuntimeBPAddr,
         g_RuntimeOffsets.m_notifyRSOfSyncCompleteBPAddr,
         g_RuntimeOffsets.m_TLSIndex,
         g_RuntimeOffsets.m_EEThreadStateOffset,
         g_RuntimeOffsets.m_EEThreadPGCDisabledOffset,
         g_RuntimeOffsets.m_EEThreadDebuggerWordOffset,
         g_RuntimeOffsets.m_EEThreadMaxNeededSize,
         g_RuntimeOffsets.m_EEThreadSteppingStateMask,
         g_RuntimeOffsets.m_pPatches,          
         g_RuntimeOffsets.m_offRgData,         
         g_RuntimeOffsets.m_offCData,          
         g_RuntimeOffsets.m_cbPatch,           
         g_RuntimeOffsets.m_offAddr,           
         g_RuntimeOffsets.m_offOpcode,         
         g_RuntimeOffsets.m_cbOpcode,          
         g_RuntimeOffsets.m_verMajor,          
         g_RuntimeOffsets.m_verMinor));

    g_RuntimeOffsetsLoaded = true;
    
    return (&g_RuntimeOffsets);
}


//*****************************************************************************
//
//---------- CPatchTableWrapper
//
//*****************************************************************************


CPatchTableWrapper::CPatchTableWrapper(DebuggerIPCRuntimeOffsets *pRuntimeOffsets) :
    m_pPatchTable(NULL),
    m_rgNextPatch(NULL),
    m_rgUncommitedOpcode(NULL),
    m_iFirstPatch(DPT_TERMINATING_INDEX),
    m_minPatchAddr(MAX_ADDRESS),
    m_maxPatchAddr(MIN_ADDRESS),
    m_rgData(NULL),
    m_cPatch(0),
    m_pRuntimeOffsets(pRuntimeOffsets)
{
}

CPatchTableWrapper::~CPatchTableWrapper()
{
    ClearPatchTable();
}


//*****************************************************************************
// Reload the patch table snapshot based on the current state.
//*****************************************************************************
HRESULT CPatchTableWrapper::RefreshPatchTable()
{
    BYTE        *rgb = NULL;    
    BOOL        fOk = false;
    DWORD       dwRead = 0;
    SIZE_T      offStart = 0;
    SIZE_T      offEnd = 0;
    UINT        cbTableSlice = 0;
    UINT        cbRgData = 0;
    USHORT      iPatch;
    USHORT      iDebuggerControllerPatchPrev;
    UINT        cbPatchTable;
    HRESULT     hr = S_OK;

    //grab the patch table info
    offStart = min(  m_pRuntimeOffsets->m_offRgData,
                     m_pRuntimeOffsets->m_offCData);
    offEnd   = max(  m_pRuntimeOffsets->m_offRgData,
                     m_pRuntimeOffsets->m_offCData)+sizeof(SIZE_T);
    cbTableSlice = offEnd - offStart;

    rgb = new BYTE[cbTableSlice];
    if (rgb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    fOk = DbgReadProcessMemory(
                            (BYTE*)m_pRuntimeOffsets->m_pPatches+offStart,
                            rgb,
                            cbTableSlice,
                            &dwRead );

    if ( !fOk || (dwRead != cbTableSlice ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto LExit;
    }

    //note that rgData is a pointer in the left side address space
    m_rgData  =  *(BYTE **)
       (rgb + m_pRuntimeOffsets->m_offRgData - offStart);
    m_cPatch = *(USHORT*)
       (rgb + m_pRuntimeOffsets->m_offCData - offStart);

    delete []  rgb;
    rgb = NULL;

    //grab the patch table
    cbPatchTable = m_cPatch * m_pRuntimeOffsets->m_cbPatch;
    m_pPatchTable = new BYTE[ cbPatchTable ];
    m_rgNextPatch = new USHORT[m_cPatch];
    //@todo port: is opcode field in DebuggerControllerPatch still a
    //DWORD?
    m_rgUncommitedOpcode = new DWORD[m_cPatch];
    if (   m_pPatchTable == NULL
        || m_rgNextPatch ==NULL
        || m_rgUncommitedOpcode == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    fOk = DbgReadProcessMemory(
                            m_rgData,
                            m_pPatchTable,
                            cbPatchTable,
                            &dwRead );

    if ( !fOk || (dwRead != cbPatchTable ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto LExit;
    }

    //As we go through the patch table we do three things:
    // 1. collect min,max address seen for quick fail check
    // 2. Link all valid entries into a linked list, the first
    //      entry of which is m_iFirstPatch
    // 3. Initialize m_rgUncommitedOpcode, so that
    //      we can undo local patch table changes if WriteMemory
    //      can't write atomically.
    // 4. If the patch is in the memory we grabbed, unapply it.

    iDebuggerControllerPatchPrev = DPT_TERMINATING_INDEX;

    m_minPatchAddr = MAX_ADDRESS;
    m_maxPatchAddr = MIN_ADDRESS;
    m_iFirstPatch = DPT_TERMINATING_INDEX;

    for (iPatch = 0; iPatch < m_cPatch;iPatch++)
    {
        //@todo port: we're making assumptions about the size
        // of opcodes,address pointers, etc
        BYTE *DebuggerControllerPatch = m_pPatchTable +
            m_pRuntimeOffsets->m_cbPatch*iPatch;
        DWORD opcode = *(DWORD *)
            (DebuggerControllerPatch + m_pRuntimeOffsets->m_offOpcode);
        BYTE *patchAddress = *(BYTE**)
            (DebuggerControllerPatch + m_pRuntimeOffsets->m_offAddr);

        if (opcode != 0 ) //&& patchAddress != 0)
        {
            _ASSERTE( patchAddress != 0 );

            // (1), above
            if (m_minPatchAddr > (CORDB_ADDRESS)patchAddress )
                m_minPatchAddr = (CORDB_ADDRESS)patchAddress;
            if (m_maxPatchAddr < (CORDB_ADDRESS)patchAddress )
                m_maxPatchAddr = (CORDB_ADDRESS)patchAddress;

            // (2), above
            if ( m_iFirstPatch == DPT_TERMINATING_INDEX)
            {
                m_iFirstPatch = iPatch;
                _ASSERTE( iPatch != DPT_TERMINATING_INDEX);
            }

            if (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)
            {
                m_rgNextPatch[iDebuggerControllerPatchPrev] = iPatch;
            }
            iDebuggerControllerPatchPrev = iPatch;

#if 0
            // (3), above
#ifdef _X86_
            m_rgUncommitedOpcode[iPatch] = 0xCC;
#endif _X86_

            // (4), above
            if  (address != NULL && 
                (CORDB_ADDRESS)patchAddress >= address &&
                (CORDB_ADDRESS)patchAddress <= address+(size-1))
            {
                _ASSERTE( buffer != NULL );
                _ASSERTE( size != NULL );
                //unapply the patch here.
               CORDbgSetInstruction(buffer+((CORDB_ADDRESS)patchAddress
                                            -address), opcode);
            }
#endif        
        }
    }
    
    if (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)
        m_rgNextPatch[iDebuggerControllerPatchPrev] =
            DPT_TERMINATING_INDEX;

LExit:
   if (FAILED( hr ))
   {
       if (rgb != NULL)
           delete [] rgb;

       ClearPatchTable();
   }

   return hr;
}

//*****************************************************************************
// Free up the current patch table snapshot.
//*****************************************************************************
void CPatchTableWrapper::ClearPatchTable(void )
{
    if (m_pPatchTable != NULL )
    {
        delete [] m_pPatchTable;
        m_pPatchTable = NULL;

        delete [] m_rgNextPatch;
        m_rgNextPatch = NULL;

        delete [] m_rgUncommitedOpcode;
        m_rgUncommitedOpcode = NULL;

        m_iFirstPatch = DPT_TERMINATING_INDEX;
        m_minPatchAddr = MAX_ADDRESS;
        m_maxPatchAddr = MIN_ADDRESS;
        m_rgData = NULL;
        m_cPatch = 0;
    }
}


//*****************************************************************************
// Prints the current snapshot of patches.
//*****************************************************************************
void CPatchTableWrapper::PrintPatchTable()
{
    USHORT      index;
    CORDB_ADDRESS address;
    BYTE        instruction;

    ExtOut("Debugger Patch Table:\n");
    ExtOut(" Address        Instruction\n");
    
    for (address = GetFirstPatch(index, &instruction);  
         address;  
         address = GetNextPatch(index, &instruction))
    {
        // Cast address to void* becuase a CORDB_ADDRESS is 64bit but
        // dprintf is expecting a 32bit value here. Otherwise,
        // instruction prints as 0.
        ExtOut(" 0x%08x         %02x\n", (void*)address, instruction);
    }
}


//*****************************************************************************
// Return the first patch in the table, or 0 if none.
//*****************************************************************************
CORDB_ADDRESS CPatchTableWrapper::GetFirstPatch(
    USHORT      &index,
    BYTE        *pinstruction)
{
    index = m_iFirstPatch;
    return (GetNextPatch(index, pinstruction));
}


//*****************************************************************************
// Get the next patch based on index.
//*****************************************************************************
CORDB_ADDRESS CPatchTableWrapper::GetNextPatch(
    USHORT      &index,
    BYTE        *pinstruction)
{
    CORDB_ADDRESS addr = 0;
    
    if (index != DPT_TERMINATING_INDEX)
    {
        BYTE *DebuggerControllerPatch = m_pPatchTable +
            m_pRuntimeOffsets->m_cbPatch*index;
        *pinstruction = *(BYTE *)(DebuggerControllerPatch +
                                  m_pRuntimeOffsets->m_offOpcode);
        addr = (CORDB_ADDRESS) *(BYTE**)(DebuggerControllerPatch +
                                       m_pRuntimeOffsets->m_offAddr);

        index = m_rgNextPatch[index];
    }
    return (addr);
}

//*****************************************************************************
//
// ----------
// COR EXT CODE
// ----------
//
//*****************************************************************************

//
// Compute the TLS Array base for the given thread.
//
#define WINNT_TLS_OFFSET    0xe10     // TLS[0] at fs:[WINNT_TLS_OFFSET]
#define WINNT5_TLSEXPANSIONPTR_OFFSET 0xf94 // TLS[64] at [fs:[WINNT5_TLSEXPANSIONPTR_OFFSET]]
#define WIN95_TLSPTR_OFFSET 0x2c      // TLS[0] at [fs:[WIN95_TLSPTR_OFFSET]]

//
// Grab the EE Tls value for a given thread.
//
HRESULT _CorExtGetEETlsValue(DebuggerIPCRuntimeOffsets *pRO,
                             void **pEETlsValue)
{
    // Assume we're on NT and that the index is small.
    _ASSERTE(pRO->m_TLSIndex < 64);

    *pEETlsValue = NULL;
    
    ULONG64 DataOffset;

    g_ExtSystem->GetCurrentThreadDataOffset(&DataOffset);

    /*
    TEB Teb;

    HRESULT Status;
    Status = g_ExtData->ReadVirtual(DataOffset, &Teb, sizeof(Teb), NULL);
    if (Status != S_OK)
    {
        ExtErr("* Unable to read TEB\n");
        return E_FAIL;
    }

    void *pEEThreadTLS =
        Teb.ThreadLocalStoragePointer
        + (pRO->m_TLSIndex * sizeof(void*));
    */
    ULONG64 EEThreadTLS = DataOffset + WINNT_TLS_OFFSET
        + (pRO->m_TLSIndex * sizeof(void*));
    void *pEEThreadTLS = (void*) EEThreadTLS;
    
    // Read the thread's TLS value.
    BOOL succ = DbgReadProcessMemory(pEEThreadTLS,
                                     pEETlsValue,
                                     sizeof(void*),
                                     NULL);

    if (!succ)
    {
        LOGSTRIKE(("CUT::GEETV: failed to read TLS value: "
                   "computed addr=0x%08x index=%d, err=%d\n",
                   pEEThreadTLS, pRO->m_TLSIndex, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ULONG ThreadId;
    g_ExtSystem->GetCurrentThreadSystemId (&ThreadId);
    LOGSTRIKE(("CUT::GEETV: EE Thread TLS value is 0x%08x for thread 0x%x\n",
               *pEETlsValue, threadId));

    return S_OK;
}

HRESULT _CorExtGetEEThreadState(DebuggerIPCRuntimeOffsets *pRO,
                                void *EETlsValue,
                                bool *pThreadStepping)
{
    *pThreadStepping = false;
    
    // Compute the address of the thread's state
    void *pEEThreadState = (BYTE*) EETlsValue + pRO->m_EEThreadStateOffset;
    
    // Grab the thread state out of the EE Thread.
    DWORD EEThreadState;
    BOOL succ = DbgReadProcessMemory(pEEThreadState,
                                     &EEThreadState,
                                     sizeof(EEThreadState),
                                     NULL);

    if (!succ)
    {
        LOGSTRIKE(("CUT::GEETS: failed to read thread state: "
                   "0x%08x + 0x%x = 0x%08x, err=%d\n",
                   EETlsValue, pRO->m_EEThreadStateOffset,
                   pEEThreadState, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOGSTRIKE(("CUT::GEETS: EE Thread state is 0x%08x\n", EEThreadState));

    // Looks like we've got the state of the thread.
    *pThreadStepping =
        ((EEThreadState & pRO->m_EEThreadSteppingStateMask) != 0);

    // If we're marked for stepping, then turn the thing off...
    if (*pThreadStepping)
    {
        EEThreadState &= ~(pRO->m_EEThreadSteppingStateMask);
        g_ExtData->WriteVirtual((ULONG64)pEEThreadState,
                                &EEThreadState,
                                sizeof(EEThreadState),
                                NULL);
    }
    
    return S_OK;
}

//
// Figure out if an exception event should be ignored and passed on to
// the Runtime.
//
STDMETHODIMP
_CorExtDealWithExceptionEvent(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    BOOL eventHandled = FALSE;
    DebuggerIPCRuntimeOffsets *pRuntimeOffsets = GetRuntimeOffsets();

    // If the Runtime hasn't event been initialize yet, then we know
    // the event doesn't belong to us.
    // We certinally only ever care about first chance exceptions.
    if (pRuntimeOffsets == NULL || !FirstChance)
    {
        if (Exception->ExceptionCode == STATUS_BREAKPOINT)
            return DEBUG_STATUS_BREAK;
        else if (Exception->ExceptionCode == STATUS_SINGLE_STEP)
            return DEBUG_STATUS_STEP_INTO;
#if 0
        else if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION)
            return DEBUG_STATUS_BREAK;
#endif
        else
            return DEBUG_STATUS_NO_CHANGE;
    }

    //ExtOut("Exception %x in handle\n", Exception->ExceptionCode);
    
    // If this is a single step exception, does it belong to the Runtime?
    if (Exception->ExceptionCode == STATUS_SINGLE_STEP)
    {
        // Try to grab the Thread* for this thread. If there is one,
        // then it means that there is a managed thread for this
        // unmanaged thread, and therefore we need to look more
        // closely at the exception.
        
        void *EETlsValue;
        HRESULT hr = _CorExtGetEETlsValue(pRuntimeOffsets, &EETlsValue);

        if (SUCCEEDED(hr) && (EETlsValue != NULL))
        {
            bool threadStepping;
                
            hr = _CorExtGetEEThreadState(pRuntimeOffsets,
                                         EETlsValue,
                                         &threadStepping);

            if (SUCCEEDED(hr) && (threadStepping))
            {
                // Yup, its the Left Side that was stepping the thread...
                LOGSTRIKE(("W32ET::W32EL: single step "
                           "exception belongs to the runtime.\n"));
                return DEBUG_STATUS_GO_NOT_HANDLED;
            }
        }
        return DEBUG_STATUS_STEP_INTO;
    }
    // If this is a breakpoint exception, does it belong to the Runtime?
    else if (Exception->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Refresh the patch table.
        CPatchTableWrapper PatchTable(pRuntimeOffsets);
        
        HRESULT hr = PatchTable.RefreshPatchTable();

        // If there isn't a valid patch table, then it can't be ours.
        if (SUCCEEDED(hr))
        {
            // See if the fault address is in the patch table. If it
            // is, then the breakpoint belongs to the Runtime.
            CORDB_ADDRESS address;
            USHORT index;
            BYTE instruction;

            for (address = PatchTable.GetFirstPatch(index, &instruction);  
                 address;  
                 address = PatchTable.GetNextPatch(index, &instruction))
            {
                if (address == Exception->ExceptionAddress)
                {
                    return DEBUG_STATUS_GO_NOT_HANDLED;
                }
            }
        }
        return DEBUG_STATUS_BREAK;
    }
#if 0
    else if (Exception->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
    {
        ULONG ThreadId;
        g_ExtSystem->GetCurrentThreadSystemId (&ThreadId);
        if (g_pDCB->m_helperThreadId == ThreadId
            || g_pDCB->m_temporaryHelperThreadId == ThreadId)
        {
            return DEBUG_STATUS_GO_NOT_HANDLED;
        }
        return DEBUG_STATUS_BREAK;
    }
#endif
    return DEBUG_STATUS_NO_CHANGE;
}

//
// Launch cordbg against the current process. Cordbg will begin the
// attach. The user of this command needs to continue the process
// afterwards to let cordbg attach.
//
BOOL LaunchAndAttachCordbg(PCSTR Args)
{
    STARTUPINFOA startupInfo = {0};
    startupInfo.cb = sizeof(STARTUPINFOA);
    PROCESS_INFORMATION processInfo = {0};

    ULONG PId;
    g_ExtSystem->GetCurrentProcessSystemId (&PId);
    char tmp[MAX_PATH];
    if (Args[0] != '\0')
    {
        const char *ptr = Args + strlen (Args) - 1;
        while (ptr > Args && isspace (ptr[0]))
            ptr --;
        while (ptr > Args && !isspace (ptr[0]))
            ptr --;
        if (isspace (ptr[0]))
            ptr ++;
        if (!_strnicmp (Args, "cordbg", 6))
        {
            if (!_strnicmp (ptr, "!a", 2))
                sprintf (tmp, "%s %d", Args, PId);
            else
                sprintf (tmp, "%s !a %d", Args, PId);
        }
        else
        {
            if (!_strnicmp (ptr, "-p", 2))
                sprintf (tmp, "%s %d", Args, PId);
            else
                sprintf (tmp, "%s -p %d", Args, PId);
        }
    }
    else
        sprintf(tmp, "cordbg !a %d", PId);
    
    ExtOut("%s\n", tmp);
    
    BOOL succ = CreateProcessA(NULL, tmp, NULL, NULL, TRUE,
                               CREATE_NEW_CONSOLE,
                               NULL, NULL, &startupInfo,
                               &processInfo);


    if (!succ)
        ExtErr ("Failed to launch cordbg: %d\n", GetLastError());
    return succ;
}

HRESULT ExcepCallbacks::Initialize(PDEBUG_CLIENT Client)
{
    HRESULT Status;
        
    m_Client = Client;
    m_Client->AddRef();
        
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&m_Advanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&m_Control)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&m_Data)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&m_Registers)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&m_Symbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&m_System)) != S_OK)
    {
        goto Fail;
    }
        
    // Turn off default breakin on breakpoint exceptions.
    Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                "sxd bpe", DEBUG_EXECUTE_DEFAULT);
    // Turn off default breakin on single step exceptions.
    Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                "sxd sse", DEBUG_EXECUTE_DEFAULT);
    // Turn off default breakin on access violation.
    //Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
    //                            "sxd av", DEBUG_EXECUTE_DEFAULT);

  Fail:
    return Status;
}

void ExcepCallbacks::Uninitialize(void)
{
    EXT_RELEASE(m_Advanced);
    EXT_RELEASE(m_Control);
    EXT_RELEASE(m_Data);
    EXT_RELEASE(m_Registers);
    EXT_RELEASE(m_Symbols);
    EXT_RELEASE(m_System);
    EXT_RELEASE(m_Client);
}
#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\engexts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
//----------------------------------------------------------------------------

#ifndef __ENGEXTS_H__
#define __ENGEXTS_H__
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define STDMETHODV(method)       virtual HRESULT STDMETHODVCALLTYPE method
#define STDMETHODV_(type,method) virtual type STDMETHODVCALLTYPE method

#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

//typedef struct _EXCEPTION_RECORD64 {
//    NTSTATUS ExceptionCode;
//    ULONG ExceptionFlags;
//    ULONG64 ExceptionRecord;
//    ULONG64 ExceptionAddress;
//    ULONG NumberParameters;
//    ULONG __unusedAlignment;
//    ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
//} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Prototype just to force the extern "C".
// The implementation of these functions are not provided.
HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags);
void CALLBACK DebugExtensionUninitialize(void);

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

#ifdef __cplusplus
}
#endif

#endif // #ifndef __ENGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strikeng\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"strike.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft NTSD extension for COR\0"
#define VER_ORIGFILENAME_STR    "strike.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strongname\resources.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define SN_ALL_USERS                      1
#define SN_ASSEMBLY_RESIGNED              2
#define SN_ASSEMBLY_VALID                 3
#define SN_CONTAINERS_MACHINE             4
#define SN_CONTAINERS_USER                5
#define SN_CONTAINER_DELETED              6
#define SN_CSP_RESET                      7
#define SN_CSP_SET                        8
#define SN_DIFFER_MORE                    9
#define SN_DIFFER_NOT                     10
#define SN_DIFFER_ONLY                    11
#define SN_EMPTY                          12
#define SN_FAILED_ALLOCATE                13
#define SN_FAILED_CLIPBOARD_EMPTY         14
#define SN_FAILED_CLIPBOARD_OPEN          15
#define SN_FAILED_CLIPBOARD_WRITE         16
#define SN_FAILED_COMPARE                 17
#define SN_FAILED_COM_STARTUP             18
#define SN_FAILED_CONVERT                 19
#define SN_FAILED_CREATE                  20
#define SN_FAILED_DELETE                  21
#define SN_FAILED_EXTRACT                 22
#define SN_FAILED_INSTALL                 23
#define SN_FAILED_KEYPAIR_GEN             24
#define SN_FAILED_MD_ACCESS               25
#define SN_FAILED_MD_ASSEMBLY             26
#define SN_FAILED_MD_OPEN                 27
#define SN_FAILED_READ                    28
#define SN_FAILED_READ_TOKEN              29
#define SN_FAILED_REG_DELETE              30
#define SN_FAILED_REG_DELETE_KEY          31
#define SN_FAILED_REG_DELETE_KEY_EX       32
#define SN_FAILED_REG_OPEN                33
#define SN_FAILED_REG_READ                34
#define SN_FAILED_REG_WRITE               35
#define SN_FAILED_RESIGN                  36
#define SN_FAILED_STRONGNAME              37
#define SN_FAILED_VERIFY                  38
#define SN_INTERNAL_1                     39
#define SN_INVALID_OPTION                 40
#define SN_INVALID_SVR_FORMAT             41
#define SN_INVALID_V_OPT                  42
#define SN_KEYPAIR_INSTALLED              43
#define SN_KEYPAIR_WRITTEN                44
#define SN_NOT_STRONG_NAMED               45
#define SN_NO_SVR                         46
#define SN_OPTIONS                        47
#define SN_OPT_ARG_RANGE                  48
#define SN_OPT_C_1                        49
#define SN_OPT_C_2                        50
#define SN_OPT_D_1                        51
#define SN_OPT_D_2                        52
#define SN_OPT_E_1                        53
#define SN_OPT_E_2                        54
#define SN_OPT_H_1                        55
#define SN_OPT_H_2                        56
#define SN_OPT_H_3                        57
#define SN_OPT_I_1                        58
#define SN_OPT_I_2                        59
#define SN_OPT_K_1                        60
#define SN_OPT_K_2                        61
#define SN_OPT_M_1                        62
#define SN_OPT_M_2                        63
#define SN_OPT_M_3                        64
#define SN_OPT_NO_ARGS                    65
#define SN_OPT_N_ARGS                     66
#define SN_OPT_ONE_ARG                    67
#define SN_OPT_O_1                        68
#define SN_OPT_O_2                        69
#define SN_OPT_O_3                        70
#define SN_OPT_O_4                        71
#define SN_OPT_PC_1                       72
#define SN_OPT_PC_2                       73
#define SN_OPT_P_1                        74
#define SN_OPT_P_2                        75
#define SN_OPT_Q_1                        76
#define SN_OPT_Q_2                        77
#define SN_OPT_Q_3                        78
#define SN_OPT_TP_1                       79
#define SN_OPT_TP_2                       80
#define SN_OPT_TP_3                       81
#define SN_OPT_UD_1                       82
#define SN_OPT_UD_2                       83
#define SN_OPT_URC_1                      84
#define SN_OPT_URC_2                      85
#define SN_OPT_URC_3                      86
#define SN_OPT_UR_1                       87
#define SN_OPT_UR_2                       88
#define SN_OPT_UTP_1                      89
#define SN_OPT_UTP_2                      90
#define SN_OPT_UTP_3                      91
#define SN_OPT_VF_1                       92
#define SN_OPT_VF_2                       93
#define SN_OPT_VF_3                       94
#define SN_OPT_VL_1                       95
#define SN_OPT_VL_2                       96
#define SN_OPT_VR_1                       97
#define SN_OPT_VR_2                       98
#define SN_OPT_VR_3                       99
#define SN_OPT_VR_4                       100
#define SN_OPT_VR_5                       101
#define SN_OPT_VR_6                       102
#define SN_OPT_VU_1                       103
#define SN_OPT_VU_2                       104
#define SN_OPT_VU_3                       105
#define SN_OPT_VX_1                       106
#define SN_OPT_VX_2                       107
#define SN_OUT_OF_MEMORY                  108
#define SN_PUBLICKEY                      109
#define SN_PUBLICKEYTOKEN                 110
#define SN_PUBLICKEY_EXTRACTED            111
#define SN_PUBLICKEY_WRITTEN              112
#define SN_PUBLICKEY_WRITTEN_CLIPBOARD    113
#define SN_PUBLICKEY_WRITTEN_CSV          114
#define SN_SVR_ADDED                      115
#define SN_SVR_ALL_REMOVED                116
#define SN_SVR_REMOVED                    117
#define SN_SVR_TITLE_1                    118
#define SN_SVR_TITLE_2                    119
#define SN_TITLE                          120
#define SN_USAGE                          121
#define SN_TRUNCATED_OUTPUT               122
#define SN_NO_ERROR_MESSAGE               123
#define SN_OPT_ONLY_ONE                   124
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strongnamesign\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "StrongNameSign.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Strong Name Signing Utility\0"
#define VER_ORIGFILENAME_STR    "StrongNameSign.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strongname\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "sn.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Strong Name Utility\0"
#define VER_ORIGFILENAME_STR    "sn.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strongnamesign\strongnamesign.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//

#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <StrongName.h>
#include <cor.h>
#include <corver.h>
#include <__file__.ver>


bool g_fQuiet = false;


#define CONVERT_TO_WIDE(_sz, _wsz) do {                             \
    DWORD dwLength = strlen(_sz);                                   \
    (_wsz) = (WCHAR*)_alloca((dwLength + 1) * sizeof(WCHAR));       \
    mbstowcs((_wsz), (_sz), dwLength);                              \
    (_wsz)[dwLength] = L'\0';                                       \
} while (0)


void Title()
{
    printf("\nMicrosoft (R) .NET Strong Name Signing Utility.  Version " VER_FILEVERSION_STR);
    printf("\n" VER_LEGALCOPYRIGHT_DOS_STR);
    printf("\n\n");
}


void Usage()
{
    printf("Usage: StrongNameSign [options] [<assembly> ...]\n");
    printf(" Options:\n");
    printf("  /C <csp>\n");
    printf("    Set the name of the CSP to use.\n");
    printf("  /K <key container name>\n");
    printf("    Set the name of the key container holding the signing key pair.\n");
    printf("  /Q\n");
    printf("    Quiet operation -- no output except on failure.\n");
}


// We late bind mscorsn.dll so we can initialize registry settings before
// loading it.

DWORD (*LB_StrongNameErrorInfo)();
BOOLEAN (*LB_StrongNameSignatureGeneration)(LPCWSTR, LPCWSTR, BYTE, ULONG, BYTE, ULONG);
BOOLEAN (*LB_StrongNameTokenFromAssembly)(LPCWSTR, BYTE**, ULONG*);


bool BindMscorsn()
{
    HMODULE hMod = LoadLibrary("mscorsn.dll");
    if (!hMod) {
        printf("Failed to load mscorsn.dll, error %u\n", GetLastError());
        return false;
    }

    *(FARPROC*)&LB_StrongNameErrorInfo = GetProcAddress(hMod, "StrongNameErrorInfo");
    if (LB_StrongNameErrorInfo == NULL) {
        printf("Failed to locate StrongNameErrorInfo entrypoint within mscorsn.dll\n");
        return false;
    }

    *(FARPROC*)&LB_StrongNameSignatureGeneration = GetProcAddress(hMod, "StrongNameSignatureGeneration");
    if (LB_StrongNameSignatureGeneration == NULL) {
        printf("Failed to locate StrongNameSignatureGeneration entrypoint within mscorsn.dll\n");
        return false;
    }

    *(FARPROC*)&LB_StrongNameTokenFromAssembly = GetProcAddress(hMod, "StrongNameTokenFromAssembly");
    if (LB_StrongNameTokenFromAssembly == NULL) {
        printf("Failed to locate StrongNameTokenFromAssembly entrypoint within mscorsn.dll\n");
        return false;
    }

    return true;
}


// Check that the given file represents a strongly named assembly.
bool IsStronglyNamedAssembly(char *szAssembly)
{
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    HANDLE                      hMap = NULL;
    BYTE                       *pbBase  = NULL;
    IMAGE_NT_HEADERS           *pNtHeaders;
    IMAGE_COR20_HEADER         *pCorHeader;
    bool                        bIsStrongNamedAssembly = false;

    // Open the file.
    hFile = CreateFileA(szAssembly,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    // Create a file mapping.
    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMap == NULL)
        goto Cleanup;

    // Map the file into memory.
    pbBase = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (pbBase == NULL)
        goto Cleanup;

    // Locate the standard file headers.
    pNtHeaders = ImageNtHeader(pbBase);
    if (pNtHeaders == NULL)
        goto Cleanup;

    // See if we can find a COM+ header extension.
    pCorHeader = (IMAGE_COR20_HEADER*)ImageRvaToVa(pNtHeaders,
                                                   pbBase, 
                                                   pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
                                                   NULL);
    if (pCorHeader == NULL)
        goto Cleanup;

    // Check that space has been allocated in the PE for a signature. For now
    // assume that the signature is generated from a 1024-bit RSA signing key.
    if ((pCorHeader->StrongNameSignature.VirtualAddress == 0) ||
        (pCorHeader->StrongNameSignature.Size != 128))
        goto Cleanup;

    bIsStrongNamedAssembly = true;

 Cleanup:

    // Cleanup all resources we used.
    if (pbBase)
        UnmapViewOfFile(pbBase);
    if (hMap)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!bIsStrongNamedAssembly)
        printf("  Not a valid assembly\n");

    return bIsStrongNamedAssembly;
}


// Sign an assembly with a key pair from a given key container.
bool SignAssembly(char *szAssembly, char *szContainer)
{
    LPWSTR  wszAssembly;
    LPWSTR  wszContainer;

    CONVERT_TO_WIDE(szAssembly, wszAssembly);
    CONVERT_TO_WIDE(szContainer, wszContainer);

    // Compute the signature in the assembly file.
    if (!LB_StrongNameSignatureGeneration(wszAssembly, wszContainer,
                                          NULL, NULL, NULL, NULL)) {
        printf("  Failed to sign %s, error %08X\n", szAssembly, LB_StrongNameErrorInfo());
        return false;
    }

    if (!g_fQuiet) {
        BYTE   *pbToken;
        DWORD   cbToken;
        char   *szToken;
        DWORD   i;

        if (!LB_StrongNameTokenFromAssembly(wszAssembly, &pbToken, &cbToken)) {
            printf("  Failed to retrieve public key token from %s, error %08X\n", szAssembly, LB_StrongNameErrorInfo());
            return false;
        }

        szToken = (char*)_alloca((cbToken * 2) + 1);
        for (i = 0; i < cbToken; i++)
            sprintf(&szToken[i * 2], "%02x", pbToken[i]);

        printf("  Successfully signed %s (public key token %s)\n", szAssembly, szToken);
    }

    return true;
}


// Set the CSP used for mscorsn operations on this machine.
bool SetCSP(char *szCSP)
{
    HKEY    hKey;
    DWORD   dwError;

    // Open MSCORSN.DLL's registry configuration key.
    if ((dwError = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY, 0,
                                   NULL, 0, KEY_WRITE, NULL, &hKey, NULL)) != ERROR_SUCCESS) {
        printf("Failed to open registry, error %u\n", dwError);
        return false;
    }

    // Write the new CSP value.
    if ((dwError = RegSetValueExA(hKey, SN_CONFIG_CSP, 0, REG_SZ,
                                  (BYTE*)szCSP, strlen(szCSP) + 1)) != ERROR_SUCCESS) {
        printf("Failed to write registry value, error %u\n", dwError);
        return false;
    }

    RegCloseKey(hKey);

    return true;
}


// Make sure mscorsn is using per-user key containers.
bool SetUserKeyContainers()
{
    DWORD   dwError;
    HKEY    hKey;
    DWORD   dwUseMachineKeyset = FALSE;

    // Open MSCORSN.DLL's registry configuration key.
    if ((dwError = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY, 0,
                                   NULL, 0, KEY_WRITE, NULL, &hKey, NULL)) != ERROR_SUCCESS) {
        printf("Failed to open registry, error %u\n", dwError);
        return false;
    }

    // Write the new value.
    if ((dwError = RegSetValueExA(hKey, SN_CONFIG_MACHINE_KEYSET, 0, REG_DWORD,
                                  (BYTE*)&dwUseMachineKeyset, sizeof(dwUseMachineKeyset))) != ERROR_SUCCESS) {
        printf("Failed to write registry value, error %u\n", dwError);
        return false;
    }

    RegCloseKey(hKey);

    return true;
}

int __cdecl main(int argc, char **argv)
{
    int     iAssemblies = argc - 1;
    int     iAsmOffset = 1;
    char   *szCSP = "Atalla Base Cryptographic Provider v1.2";
    char   *szKeyContainer = "MSBinarySig";
    bool    fSuccess;

    // Parse out options.
    while (iAssemblies) {
        if (argv[iAsmOffset][0] == '/' || argv[iAsmOffset][0] == '-') {
            switch (argv[iAsmOffset][1]) {
            case 'c':
            case 'C':
                iAsmOffset++;
                iAssemblies--;
                if (iAssemblies == 0) {
                    Title();
                    printf("/C option requires an argument\n\n");
                    Usage();
                    return 1;
                }
                szCSP = argv[iAsmOffset];
                break;
            case 'k':
            case 'K':
                iAsmOffset++;
                iAssemblies--;
                if (iAssemblies == 0) {
                    Title();
                    printf("/K option requires an argument\n\n");
                    Usage();
                    return 1;
                }
                szKeyContainer = argv[iAsmOffset];
                break;
            case 'q':
            case 'Q':
                g_fQuiet = true;
                break;
            case '?':
            case 'h':
            case 'H':
                Title();
                Usage();
                return 0;
            default:
                Title();
                printf("Unknown option: %s\n\n", argv[iAsmOffset]);
                Usage();
                return 1;
            }
            iAsmOffset++;
            iAssemblies--;
        } else
            break;
    }

    if (!g_fQuiet)
        Title();

    // Check we've been given at least one assembly to process.
    if (iAssemblies == 0) {
        printf("At least one assembly must be specified\n\n");
        Usage();
        return 1;
    }

    // Set CSP for crypto operations.
    if (!SetCSP(szCSP))
        return 1;

    // Make sure we're using per-user key containers.
    if (!SetUserKeyContainers())
        return 1;

    // Bind to mscorsn.dll (now we initialized registry settings).
    if (!BindMscorsn())
        return 1;

    // Process each assembly.
    fSuccess = true;
    while (iAssemblies) {
        char *szAssembly = argv[iAsmOffset];

        iAssemblies--;
        iAsmOffset++;

        // Check that the input file exists, is an assembly and has space
        // allocated for a strong name signature.
        if (!IsStronglyNamedAssembly(szAssembly)) {
            fSuccess = false;
            continue;
        }

        // Sign the assembly.
        if (!SignAssembly(szAssembly, szKeyContainer))
            fSuccess = false;
    }

    if (!g_fQuiet)
        if (fSuccess)
            printf("\nAll assemblies successfully signed\n");
        else
            printf("\nAt least one error was encountered signing assemblies\n");

    return fSuccess ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strongname\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//

#include <utilcode.h>
#include <winwrap.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <StrongName.h>
#include <cor.h>
#include <corver.h>
#include <__file__.ver>
#include <resources.h>


bool g_bQuiet = false;


// Various routines for formatting and writing messages to the console.
void Output(LPWSTR szFormat, va_list pArgs)
{
    DWORD   dwLength;
    LPSTR   szMessage;
    DWORD   dwWritten;

    if (OnUnicodeSystem()) {
        WCHAR  szBuffer[8192];
        if (_vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), szFormat, pArgs) == -1) {
            WCHAR   szWarning[256];
            if (WszLoadString(NULL, SN_TRUNCATED_OUTPUT, szWarning, sizeof(szWarning) / sizeof(WCHAR)))
                wcscpy(&szBuffer[(sizeof(szBuffer) / sizeof(WCHAR)) - wcslen(szWarning) - 1], szWarning);
        }
        szBuffer[(sizeof(szBuffer) / sizeof(WCHAR)) - 1] = L'\0';

        dwLength = (wcslen(szBuffer) + 1) * 3;
        szMessage = (LPSTR)_alloca(dwLength);
        WszWideCharToMultiByte(GetConsoleOutputCP(), 0, szBuffer, -1, szMessage, dwLength - 1, NULL, NULL);
    } else {
        char   *szAnsiFormat;
        size_t  i;

        // Win9X has broken _vsnwprintf support. Sigh. Narrow the format string
        // and convert any %s format specifiers to %S. Ack.
        dwLength = (wcslen(szFormat) + 1) * 3;
        szAnsiFormat = (char*)_alloca(dwLength);
        WszWideCharToMultiByte(GetConsoleOutputCP(), 0, szFormat, -1, szAnsiFormat, dwLength - 1, NULL, NULL);
        for (i = 0; i < strlen(szAnsiFormat); i++)
            if (szAnsiFormat[i] == '%' && szAnsiFormat[i + 1] == 's')
                szAnsiFormat[i + 1] = 'S';

        szMessage = (LPSTR)_alloca(1024);

        _vsnprintf(szMessage, 1024, szAnsiFormat, pArgs);
        szMessage[1023] = '\0';
    }

    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szMessage, strlen(szMessage), &dwWritten, NULL);
}

void Output(LPWSTR szFormat, ...)
{
    va_list pArgs;

    va_start(pArgs, szFormat);
    Output(szFormat, pArgs);
    va_end(pArgs);
}

void Output(DWORD dwResId, ...)
{
    va_list pArgs;
    WCHAR   szFormat[1024];

    if (WszLoadString(NULL, dwResId, szFormat, sizeof(szFormat)/sizeof(WCHAR))) {
        va_start(pArgs, dwResId);
        Output(szFormat, pArgs);
        va_end(pArgs);
    }
}


// Get the text for a given error code (inserts not supported). Note that the
// returned string is static (not need to deallocate, but calling this routine a
// second time will obliterate the result of the first call).
LPWSTR GetErrorString(ULONG ulError)
{
    static WCHAR szOutput[1024];

    if (!WszFormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                          NULL,
                          ulError,
                          0,
                          szOutput,
                          sizeof(szOutput) / sizeof(WCHAR),
                          NULL)) {
        if (!WszLoadString(NULL, SN_NO_ERROR_MESSAGE, szOutput, sizeof(szOutput) / sizeof(WCHAR)))
            wcscpy(szOutput, L"Unable to format error message ");

        // Tack on the error number in hex. Build this in 8-bit (because
        // wsprintf doesn't work on Win9X) and explode it out into 16-bit as a
        // post processing step.
        WCHAR szErrorNum[9];
        sprintf((char*)szErrorNum, "%08X", ulError);
        for (int i = 7; i >= 0; i--)
            szErrorNum[i] = (WCHAR)((char*)szErrorNum)[i];
        szErrorNum[8] = L'\0';

        wcscat(szOutput, szErrorNum);
    }

    return szOutput;
}


void Title()
{
    Output(SN_TITLE, VER_FILEVERSION_WSTR);
    Output(L"\r\n" VER_LEGALCOPYRIGHT_DOS_STR);
    Output(L"\r\n\r\n");
}


void Usage()
{
    Output(SN_USAGE);
    Output(SN_OPTIONS);
    Output(SN_OPT_C_1);
    Output(SN_OPT_C_2);
    Output(SN_OPT_D_1);
    Output(SN_OPT_D_2);
    Output(SN_OPT_UD_1);
    Output(SN_OPT_UD_2);
    Output(SN_OPT_E_1);
    Output(SN_OPT_E_2);
    Output(SN_OPT_I_1);
    Output(SN_OPT_I_2);
    Output(SN_OPT_K_1);
    Output(SN_OPT_K_2);
    Output(SN_OPT_M_1);
    Output(SN_OPT_M_2);
    Output(SN_OPT_M_3);
    Output(SN_OPT_O_1);
    Output(SN_OPT_O_2);
    Output(SN_OPT_O_3);
    Output(SN_OPT_O_4);
    Output(SN_OPT_P_1);
    Output(SN_OPT_P_2);
    Output(SN_OPT_PC_1);
    Output(SN_OPT_PC_2);
    Output(SN_OPT_Q_1);
    Output(SN_OPT_Q_2);
    Output(SN_OPT_Q_3);
    Output(SN_OPT_UR_1);
    Output(SN_OPT_UR_2);
    Output(SN_OPT_URC_1);
    Output(SN_OPT_URC_2);
    Output(SN_OPT_URC_3);
    Output(SN_OPT_TP_1);
    Output(SN_OPT_TP_2);
    Output(SN_OPT_TP_3);
    Output(SN_OPT_UTP_1);
    Output(SN_OPT_UTP_2);
    Output(SN_OPT_UTP_3);
    Output(SN_OPT_VF_1);
    Output(SN_OPT_VF_2);
    Output(SN_OPT_VF_3);
    Output(SN_OPT_VL_1);
    Output(SN_OPT_VL_2);
    Output(SN_OPT_VR_1);
    Output(SN_OPT_VR_2);
    Output(SN_OPT_VR_3);
    Output(SN_OPT_VR_4);
    Output(SN_OPT_VR_5);
    Output(SN_OPT_VR_6);
    Output(SN_OPT_VU_1);
    Output(SN_OPT_VU_2);
    Output(SN_OPT_VU_3);
    Output(SN_OPT_VX_1);
    Output(SN_OPT_VX_2);
    Output(SN_OPT_H_1);
    Output(SN_OPT_H_2);
    Output(SN_OPT_H_3);
}


// Read the entire contents of a file into a buffer. This routine allocates the
// buffer (which should be freed with delete []).
DWORD ReadFileIntoBuffer(LPWSTR szFile, BYTE **ppbBuffer, DWORD *pcbBuffer)
{
    // Open the file.
    HANDLE hFile = WszCreateFile(szFile,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    // Determine file size and allocate an appropriate buffer.
    DWORD dwHigh;
    *pcbBuffer = GetFileSize(hFile, &dwHigh);
    if (dwHigh != 0) {
        CloseHandle(hFile);
        return E_FAIL;
    }
    *ppbBuffer = new BYTE[*pcbBuffer];
    if (!*ppbBuffer) {
        CloseHandle(hFile);
        return ERROR_OUTOFMEMORY;
    }

    // Read the file into the buffer.
    DWORD dwBytesRead;
    if (!ReadFile(hFile, *ppbBuffer, *pcbBuffer, &dwBytesRead, NULL)) {
        CloseHandle(hFile);
        return GetLastError();
    }

    CloseHandle(hFile);

    return ERROR_SUCCESS;
}


// Write the contents of a buffer into a file.
DWORD WriteFileFromBuffer(LPCWSTR szFile, BYTE *pbBuffer, DWORD cbBuffer)
{
    // Create the file (overwriting if necessary).
    HANDLE hFile = WszCreateFile(szFile,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    // Write the buffer contents.
    DWORD dwBytesWritten;
    if (!WriteFile(hFile, pbBuffer, cbBuffer, &dwBytesWritten, NULL)) {
        CloseHandle(hFile);
        return GetLastError();
    }

    CloseHandle(hFile);

    return ERROR_SUCCESS;
}


// Generate a temporary key container name based on process ID.
LPWSTR GetKeyContainerName()
{
    char            szName[32];
    static WCHAR    wszName[32] = { 0 };

    if (wszName[0] == L'\0') {
        sprintf(szName, "SN[%08X]", GetCurrentProcessId());
        mbstowcs(wszName, szName, strlen(szName));
        wszName[strlen(szName)] = L'\0';
    }

    return wszName;
}

// Helper to format an 8-bit integer as a two character hex string.
void PutHex(BYTE bValue, WCHAR *szString)
{
    static const WCHAR szHexDigits[] = L"0123456789abcdef";
    szString[0] = szHexDigits[bValue >> 4];
    szString[1] = szHexDigits[bValue & 0xf];
}


// Generate a hex string for a public key token.
LPWSTR GetTokenString(BYTE *pbToken, DWORD cbToken)
{
    LPWSTR  szString;
    DWORD   i;

    szString = new WCHAR[(cbToken * 2) + 1];
    if (szString == NULL)
        return L"<out of memory>";

    for (i = 0; i < cbToken; i++)
        PutHex(pbToken[i], &szString[i * 2]);
    szString[cbToken * 2] = L'\0';

    return szString;
}


// Generate a hex string for a public key.
LPWSTR GetPublicKeyString(BYTE *pbKey, DWORD cbKey)
{
    LPWSTR  szString;
    DWORD   i, j, src, dst;

    szString = new WCHAR[(cbKey * 2) + (((cbKey + 38) / 39) * 2) + 1];
    if (szString == NULL)
        return L"<out of memory>";

    dst = 0;
    for (i = 0; i < (cbKey + 38) / 39; i++) {
        for (j = 0; j < 39; j++) {
            src = i * 39 + j;
            if (src == cbKey)
                break;
            PutHex(pbKey[src], &szString[dst]);
            dst += 2;
        }
        szString[dst++] = L'\r';
        szString[dst++] = L'\n';
    }
    szString[dst] = L'\0';

    return szString;
}


// Check that the given file represents a strongly named assembly.
bool IsStronglyNamedAssembly(LPWSTR szAssembly)
{
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    HANDLE                      hMap = NULL;
    BYTE                       *pbBase  = NULL;
    IMAGE_NT_HEADERS           *pNtHeaders;
    IMAGE_COR20_HEADER         *pCorHeader;
    bool                        bIsStrongNamedAssembly = false;

    // Open the file.
    hFile = WszCreateFile(szAssembly,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    // Create a file mapping.
    hMap = WszCreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMap == NULL)
        goto Cleanup;

    // Map the file into memory.
    pbBase = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (pbBase == NULL)
        goto Cleanup;

    // Locate the standard file headers.
    pNtHeaders = ImageNtHeader(pbBase);
    if (pNtHeaders == NULL)
        goto Cleanup;

    // See if we can find a COM+ header extension.
    pCorHeader = (IMAGE_COR20_HEADER*)ImageRvaToVa(pNtHeaders,
                                                   pbBase, 
                                                   pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
                                                   NULL);
    if (pCorHeader == NULL)
        goto Cleanup;

    // Check that space has been allocated in the PE for a signature. For now
    // assume that the signature is generated from a 1024-bit RSA signing key.
    if ((pCorHeader->StrongNameSignature.VirtualAddress == 0) ||
        (pCorHeader->StrongNameSignature.Size != 128))
        goto Cleanup;

    bIsStrongNamedAssembly = true;

 Cleanup:

    // Cleanup all resources we used.
    if (pbBase)
        UnmapViewOfFile(pbBase);
    if (hMap)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!bIsStrongNamedAssembly)
        Output(SN_NOT_STRONG_NAMED, szAssembly);

    return bIsStrongNamedAssembly;
}


// Verify a strongly named assembly for self consistency.
bool VerifyAssembly(LPWSTR szAssembly, bool bForceVerify)
{
    if (!IsStronglyNamedAssembly(szAssembly))
        return false;

    if (!StrongNameSignatureVerificationEx(szAssembly, bForceVerify, NULL)) {
        Output(SN_FAILED_VERIFY, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    if (!g_bQuiet) Output(SN_ASSEMBLY_VALID, szAssembly);
    return true;
}


// Generate a random public/private key pair and write it to a file.
bool GenerateKeyPair(LPWSTR szKeyFile)
{
    BYTE   *pbKey;
    DWORD   cbKey;
    DWORD   dwError;

    // Delete any old container with the same name.
    StrongNameKeyDelete(GetKeyContainerName());

    // Write a new public/private key pair to memory.
    if (!StrongNameKeyGen(GetKeyContainerName(), 0, &pbKey, &cbKey)) {
        Output(SN_FAILED_KEYPAIR_GEN, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Persist the key pair to disk.
    if ((dwError = WriteFileFromBuffer(szKeyFile, pbKey, cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_CREATE, szKeyFile, GetErrorString(dwError));
        return false;
    }

    if (!g_bQuiet) Output(SN_KEYPAIR_WRITTEN, szKeyFile);
    return true;
}


// Extract the public portion of a public/private key pair.
bool ExtractPublicKey(LPWSTR szInFile, LPWSTR szOutFile)
{
    BYTE   *pbKey;
    DWORD   cbKey;
    BYTE   *pbPublicKey;
    DWORD   cbPublicKey;
    DWORD   dwError;

    // Delete any old container with the same name.
    StrongNameKeyDelete(GetKeyContainerName());

    // Read the public/private key pair into memory.
    if ((dwError = ReadFileIntoBuffer(szInFile, &pbKey, &cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_READ, szInFile, GetErrorString(dwError));
        return false;
    }

    // Extract the public portion into a buffer.
    if (!StrongNameGetPublicKey(GetKeyContainerName(), pbKey, cbKey, &pbPublicKey, &cbPublicKey)) {
        Output(SN_FAILED_EXTRACT, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Write the public portion to disk.
    if ((dwError = WriteFileFromBuffer(szOutFile, pbPublicKey, cbPublicKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_CREATE, szOutFile, GetErrorString(dwError));
        return false;
    }

    if (!g_bQuiet) Output(SN_PUBLICKEY_WRITTEN, szOutFile);
    return true;
}


// Extract the public portion of a public/private key pair stored in a container.
bool ExtractPublicKeyFromContainer(LPWSTR szContainer, LPWSTR szOutFile)
{
    BYTE   *pbPublicKey;
    DWORD   cbPublicKey;
    DWORD   dwError;

    // Extract the public portion into a buffer.
    if (!StrongNameGetPublicKey(szContainer, NULL, 0, &pbPublicKey, &cbPublicKey)) {
        Output(SN_FAILED_EXTRACT, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Write the public portion to disk.
    if ((dwError = WriteFileFromBuffer(szOutFile, pbPublicKey, cbPublicKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_CREATE, szOutFile, GetErrorString(dwError));
        return false;
    }

    if (!g_bQuiet) Output(SN_PUBLICKEY_WRITTEN, szOutFile);
    return true;
}


// Read a public/private key pair from disk and install it into a key container.
bool InstallKeyPair(LPWSTR szKeyFile, LPWSTR szContainer)
{
    BYTE   *pbKey;
    DWORD   cbKey;
    DWORD   dwError;

    // Read the key pair from a file.
    if ((dwError = ReadFileIntoBuffer(szKeyFile, &pbKey, &cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_READ, szKeyFile, GetErrorString(dwError));
        return false;
    }

    // Install the key pair into the named container.
    if (!StrongNameKeyInstall(szContainer, pbKey, cbKey)) {
        Output(SN_FAILED_INSTALL, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    if (!g_bQuiet) Output(SN_KEYPAIR_INSTALLED, szContainer);
    return true;
}


// Delete a named key container.
bool DeleteContainer(LPWSTR szContainer)
{
    if (!StrongNameKeyDelete(szContainer)) {
        Output(SN_FAILED_DELETE, szContainer, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    if (!g_bQuiet) Output(SN_CONTAINER_DELETED, szContainer);
    return true;
}


// Display the token form of a public key read from a file.
bool DisplayTokenFromKey(LPWSTR szFile, BOOL bShowPublic)
{
    BYTE   *pbKey;
    DWORD   cbKey;
    BYTE   *pbToken;
    DWORD   cbToken;
    DWORD   dwError;

    // Read the public key from a file.
    if ((dwError = ReadFileIntoBuffer(szFile, &pbKey, &cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_READ, szFile, GetErrorString(dwError));
        return false;
    }

    // Convert the key into a token.
    if (!StrongNameTokenFromPublicKey(pbKey, cbKey, &pbToken, &cbToken)) {
        Output(SN_FAILED_CONVERT, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Display public key if requested.
    if (bShowPublic)
        Output(SN_PUBLICKEY, GetPublicKeyString(pbKey, cbKey));

    // And display it.
    Output(SN_PUBLICKEYTOKEN, GetTokenString(pbToken, cbToken));

    return true;
}


// Display the token form of a public key used to sign an assembly.
bool DisplayTokenFromAssembly(LPWSTR szAssembly, BOOL bShowPublic)
{
    BYTE   *pbToken;
    DWORD   cbToken;
    BYTE   *pbKey;
    DWORD   cbKey;

    if (!IsStronglyNamedAssembly(szAssembly))
        return false;

    // Read the token direct from the assembly.
    if (!StrongNameTokenFromAssemblyEx(szAssembly, &pbToken, &cbToken, &pbKey, &cbKey)) {
        Output(SN_FAILED_READ_TOKEN, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Display public key if requested.
    if (bShowPublic)
        Output(SN_PUBLICKEY, GetPublicKeyString(pbKey, cbKey));

    // And display it.
    Output(SN_PUBLICKEYTOKEN, GetTokenString(pbToken, cbToken));

    return true;
}


// Write a public key to a file as a comma separated value list.
bool WriteCSV(LPWSTR szInFile, LPWSTR szOutFile)
{
    BYTE   *pbKey;
    DWORD   cbKey;
    DWORD   dwError;
    BYTE   *pbBuffer;
    DWORD   cbBuffer;
    DWORD   i;
    HANDLE  hMem;
    BYTE   *pbClipBuffer;

    // Read the public key from a file.
    if ((dwError = ReadFileIntoBuffer(szInFile, &pbKey, &cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_READ, szInFile, GetErrorString(dwError));
        return false;
    }

    // Check for non-empty file.
    if (cbKey == 0) {
        Output(SN_EMPTY, szInFile);
        return false;
    }

    // Calculate the size of the text output buffer:
    //    Each byte -> 3 chars (space prefixed decimal) + 2 (", ")
    //  + 2 chars ("\r\n")
    //  - 2 chars (final ", " not needed)
    cbBuffer = (cbKey * (3 + 2)) + 2 - 2;

    // Allocate buffer (plus an extra couple of characters for the temporary
    // slop-over from writing a trailing ", " we don't need).
    pbBuffer = new BYTE[cbBuffer + 2];
    if (pbBuffer == NULL) {
        Output(SN_FAILED_ALLOCATE);
        return false;
    }

    // Convert the byte stream into a CSV (Comma Seperated Value) list.
    for (i = 0; i < cbKey; i++)
        sprintf((char*)&pbBuffer[i * 5], "% 3u, ", pbKey[i]);
    pbBuffer[cbBuffer - 2] = '\r';
    pbBuffer[cbBuffer - 1] = '\n';

    // If an output filename was provided write the CSV list to it.
    if (szOutFile) {
        if ((dwError = WriteFileFromBuffer(szOutFile, pbBuffer, cbBuffer)) != ERROR_SUCCESS) {
            Output(SN_FAILED_CREATE, szOutFile, GetErrorString(dwError));
            return false;
        }
        if (!g_bQuiet) Output(SN_PUBLICKEY_WRITTEN_CSV, szOutFile);
    } else {
        // Copy the text to the clipboard instead. Need to copy into memory
        // allocated via GlobalAlloc with the correct flags (and add a nul
        // terminator) for clipboard compatability.

        hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cbBuffer + 1);
        if (hMem == NULL) {
            Output(SN_FAILED_ALLOCATE);
            return false;
        }

        pbClipBuffer = (BYTE*)GlobalLock(hMem);
        memcpy(pbClipBuffer, pbBuffer, cbBuffer);
        pbClipBuffer[cbBuffer + 1] = '\0';
        GlobalUnlock(hMem);

        if (!OpenClipboard(NULL)) {
            Output(SN_FAILED_CLIPBOARD_OPEN, GetErrorString(GetLastError()));
            return false;
        }

        if (!EmptyClipboard()) {
            Output(SN_FAILED_CLIPBOARD_EMPTY, GetErrorString(GetLastError()));
            return false;
        }

        if (SetClipboardData(CF_TEXT, hMem) == NULL) {
            Output(SN_FAILED_CLIPBOARD_WRITE, GetErrorString(GetLastError()));
            return false;
        }

        CloseClipboard();
        GlobalFree(hMem);

        if (!g_bQuiet) Output(SN_PUBLICKEY_WRITTEN_CLIPBOARD);
    }

    return true;
}


// Extract the public key from an assembly and place it in a file.
bool ExtractPublicKeyFromAssembly(LPWSTR szAssembly, LPWSTR szFile)
{
    BYTE   *pbToken;
    DWORD   cbToken;
    BYTE   *pbKey;
    DWORD   cbKey;
    DWORD   dwError;

    if (!IsStronglyNamedAssembly(szAssembly))
        return false;

    // Read the public key from the assembly.
    if (!StrongNameTokenFromAssemblyEx(szAssembly, &pbToken, &cbToken, &pbKey, &cbKey)) {
        Output(SN_FAILED_READ_TOKEN, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // And write it to disk.
    if ((dwError = WriteFileFromBuffer(szFile, pbKey, cbKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_CREATE, szFile, GetErrorString(dwError));
        return false;
    }

    if (!g_bQuiet) Output(SN_PUBLICKEY_EXTRACTED, szFile);

    return true;
}


// Check that two assemblies differ only by their strong name signature.
bool DiffAssemblies(LPWSTR szAssembly1, LPWSTR szAssembly2)
{
    DWORD   dwResult;

    if (!IsStronglyNamedAssembly(szAssembly1))
        return false;

    if (!IsStronglyNamedAssembly(szAssembly2))
        return false;

    // Compare the assembly images.
    if (!StrongNameCompareAssemblies(szAssembly1, szAssembly2, &dwResult)) {
        Output(SN_FAILED_COMPARE, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Print a message describing how similar they are.
    if (!g_bQuiet)
        switch (dwResult) {
        case SN_CMP_DIFFERENT:
            Output(SN_DIFFER_MORE);
            break;
        case SN_CMP_IDENTICAL:
            Output(SN_DIFFER_NOT);
            break;
        case SN_CMP_SIGONLY:
            Output(SN_DIFFER_ONLY);
            break;
        default:
            Output(SN_INTERNAL_1, dwResult);
            return false;
        }

    // Return a failure code on differences.
    return dwResult != SN_CMP_DIFFERENT;
}


// Re-sign a previously signed assembly with a key pair from a file or a key
// container.
bool ResignAssembly(LPWSTR szAssembly, LPWSTR szFileOrContainer, bool bContainer)
{
    LPWSTR  szContainer;
    BYTE   *pbKey;
    DWORD   cbKey;
    DWORD   dwError;

    if (!IsStronglyNamedAssembly(szAssembly))
        return false;

    if (bContainer) {
        // Key is provided in container.
        szContainer = szFileOrContainer;
    } else {
        // Key is provided in file.

        // Get a temporary container name.
        szContainer = GetKeyContainerName();

        // Delete any old container with the same name.
        StrongNameKeyDelete(szContainer);

        // Read the public/private key pair into memory.
        if ((dwError = ReadFileIntoBuffer(szFileOrContainer, &pbKey, &cbKey)) != ERROR_SUCCESS) {
            Output(SN_FAILED_READ, szFileOrContainer, GetErrorString(dwError));
            return false;
        }

        // Install the key pair into the temporary container.
        if (!StrongNameKeyInstall(szContainer, pbKey, cbKey)) {
            Output(SN_FAILED_INSTALL, GetErrorString(StrongNameErrorInfo()));
            return false;
        }
    }

    // Recompute the signature in the assembly file.
    if (!StrongNameSignatureGeneration(szAssembly, szContainer,
                                       NULL, NULL, NULL, NULL)) {
        Output(SN_FAILED_RESIGN, GetErrorString(StrongNameErrorInfo()));
        return false;
    }

    // Delete the temporary container, if we created one.
    if (!bContainer)
        StrongNameKeyDelete(szContainer);

    if (!g_bQuiet) Output(SN_ASSEMBLY_RESIGNED, szAssembly);

    return true;
}


// Set or reset the default CSP used for mscorsn operations on this machine.
bool SetCSP(LPWSTR szCSP)
{
    HKEY    hKey;
    DWORD   dwError;

    // Open MSCORSN.DLL's registry configuration key.
    if ((dwError = WszRegCreateKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W, 0,
                                   NULL, 0, KEY_WRITE, NULL, &hKey, NULL)) != ERROR_SUCCESS) {
        Output(SN_FAILED_REG_OPEN, GetErrorString(dwError));
        return false;
    }

    // Write the new CSP value (if provided).
    if (szCSP) {
        if ((dwError = WszRegSetValueEx(hKey, SN_CONFIG_CSP_W, 0, REG_SZ,
                                        (BYTE*)szCSP, (wcslen(szCSP) + 1) * sizeof(WCHAR))) != ERROR_SUCCESS) {
            Output(SN_FAILED_REG_WRITE, GetErrorString(dwError));
            return false;
        }
    } else {
        // No CSP name, delete the old CSP value.
        if (((dwError = WszRegDeleteValue(hKey, SN_CONFIG_CSP_W)) != ERROR_SUCCESS) &&
            (dwError != ERROR_FILE_NOT_FOUND)) {
            Output(SN_FAILED_REG_DELETE, GetErrorString(dwError));
            return false;
        }
    }

    RegCloseKey(hKey);

    if (!g_bQuiet)
        if (szCSP)
            Output(SN_CSP_SET, szCSP);
        else
            Output(SN_CSP_RESET);

    return true;
}


// Enable/disable or read whether key containers are machine wide or user
// specific.
bool SetUseMachineKeyset(LPWSTR szEnable)
{
    DWORD   dwError;
    HKEY    hKey;
    DWORD   dwUseMachineKeyset;
    DWORD   dwLength;

    if (szEnable == NULL) {

        // Read case.

        // Open MSCORSN.DLL's registry configuration key.
        if ((dwError = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W, 0, KEY_READ, &hKey)) != ERROR_SUCCESS) {
            if (dwError == ERROR_FILE_NOT_FOUND) {
                dwUseMachineKeyset = TRUE;
                goto Success;
            } else {
                Output(SN_FAILED_REG_OPEN, GetErrorString(dwError));
                return false;
            }
        }

        // Read value of the flag.
        dwLength = sizeof(DWORD);
        if ((dwError = WszRegQueryValueEx(hKey, SN_CONFIG_MACHINE_KEYSET_W, NULL, NULL,
                                        (BYTE*)&dwUseMachineKeyset, &dwLength)) != ERROR_SUCCESS) {
            if (dwError == ERROR_FILE_NOT_FOUND) {
                dwUseMachineKeyset = TRUE;
                goto Success;
            } else {
                Output(SN_FAILED_REG_READ, GetErrorString(dwError));
                return false;
            }
        }

    Success:
        RegCloseKey(hKey);

        if (!g_bQuiet) Output(dwUseMachineKeyset ? SN_CONTAINERS_MACHINE : SN_CONTAINERS_USER);
        return true;

    } else {

        // Enable/disable case.

        // Determine which way the setting should go.
        dwUseMachineKeyset = szEnable[0] == L'y';

        // Open MSCORSN.DLL's registry configuration key.
        if ((dwError = WszRegCreateKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W, 0,
                                       NULL, 0, KEY_WRITE, NULL, &hKey, NULL)) != ERROR_SUCCESS) {
            Output(SN_FAILED_REG_OPEN, GetErrorString(dwError));
            return false;
        }

        // Write the new value.
        if ((dwError = WszRegSetValueEx(hKey, SN_CONFIG_MACHINE_KEYSET_W, 0, REG_DWORD,
                                      (BYTE*)&dwUseMachineKeyset, sizeof(dwUseMachineKeyset))) != ERROR_SUCCESS) {
            Output(SN_FAILED_REG_WRITE, GetErrorString(dwError));
            return false;
        }

        RegCloseKey(hKey);

        if (!g_bQuiet) Output(dwUseMachineKeyset ? SN_CONTAINERS_MACHINE : SN_CONTAINERS_USER);
        return true;
    }
}


// List state of verification on this machine.
bool VerifyList()
{
    HKEY            hKey;
    DWORD           dwEntries;
    FILETIME        sFiletime;
    DWORD           i, j;
    WCHAR           szSubKey[MAX_PATH + 1];
    DWORD           cchSubKey;
    HKEY            hSubKey;
    WCHAR          *mszUserList;
    DWORD           cbUserList;
    WCHAR          *szUser;
    DWORD           cchPad;
    LPWSTR          szPad;

    // Count entries we find.
    dwEntries = 0;

    // Open the verification subkey in the registry.
    if (WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W L"\\" SN_CONFIG_VERIFICATION_W, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        goto Finished;

    // Assembly specific verification records are represented as subkeys of the
    // key we've just opened.
    for (i = 0; ; i++) {

        // Get the name of the next subkey.
        cchSubKey = MAX_PATH + 1;
        if (WszRegEnumKeyEx(hKey, i, szSubKey, &cchSubKey, NULL, NULL, NULL, &sFiletime) != ERROR_SUCCESS)
            break;

        // Open the subkey.
        if (WszRegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS) {

            dwEntries++;
            if (dwEntries == 1) {
                Output(SN_SVR_TITLE_1);
                Output(SN_SVR_TITLE_2);
            }

            if (wcslen(szSubKey) < 38) {
                cchPad = 38 - wcslen(szSubKey);
                szPad = (LPWSTR)_alloca((cchPad + 1) * sizeof(WCHAR));
                memset(szPad, 0, (cchPad + 1) * sizeof(WCHAR));
                for (j = 0; j < cchPad; j++)
                    szPad[j] = L' ';
                Output(L"%s%s", szSubKey, szPad);
            } else
                Output(L"%s ", szSubKey);

            // Read a list of valid users, if supplied.
            mszUserList = NULL;
            if ((WszRegQueryValueEx(hSubKey, SN_CONFIG_USERLIST_W, NULL, NULL, NULL, &cbUserList) == ERROR_SUCCESS) &&
                (cbUserList > 0) &&
                (mszUserList = new WCHAR[cbUserList])) {

                WszRegQueryValueEx(hSubKey, SN_CONFIG_USERLIST_W, NULL, NULL, (BYTE*)mszUserList, &cbUserList);

                szUser = mszUserList;
                while (*szUser) {
                    Output(L"%s ", szUser);
                    szUser += wcslen(szUser) + 1;
                }
                Output(L"\r\n");

                delete [] mszUserList;

            } else
                Output(SN_ALL_USERS);

            RegCloseKey(hSubKey);
        }
        
    }

    RegCloseKey(hKey);

 Finished:
    if (!g_bQuiet && (dwEntries == 0))
        Output(SN_NO_SVR);

    return true;
}


// Build a name for an assembly that includes the internal name and a hex
// representation of the strong name (public key).
LPWSTR GetAssemblyName(LPWSTR szAssembly)
{
    HRESULT                     hr;
    IMetaDataDispenser         *pDisp;
    IMetaDataAssemblyImport    *pAsmImport;
    mdAssembly                  tkAssembly;
    BYTE                       *pbKey;
    DWORD                       cbKey;
    static WCHAR                szAssemblyName[1024];
    WCHAR                       szStrongName[1024];
    BYTE                       *pbToken;
    DWORD                       cbToken;
    DWORD                       i;

    // Initialize classic COM and get a metadata dispenser.
    if (FAILED(hr = CoInitialize(NULL))) {
        Output(SN_FAILED_COM_STARTUP, GetErrorString(hr));
        return NULL;
    }
    
    if (FAILED(hr = CoCreateInstance(CLSID_CorMetaDataDispenser,
                                     NULL,
                                     CLSCTX_INPROC_SERVER, 
                                     IID_IMetaDataDispenser,
                                     (void**)&pDisp))) {
        Output(SN_FAILED_MD_ACCESS, GetErrorString(hr));
        return NULL;
    }

    // Open a scope on the file.
    if (FAILED(hr = pDisp->OpenScope(szAssembly,
                                     0,
                                     IID_IMetaDataAssemblyImport,
                                     (IUnknown**)&pAsmImport))) {
        Output(SN_FAILED_MD_OPEN, szAssembly, GetErrorString(hr));
        return NULL;
    }

    // Determine the assemblydef token.
    if (FAILED(hr = pAsmImport->GetAssemblyFromScope(&tkAssembly))) {
        Output(SN_FAILED_MD_ASSEMBLY, szAssembly, GetErrorString(hr));
        return NULL;
    }

    // Read the assemblydef properties to get the public key and name.
    if (FAILED(hr = pAsmImport->GetAssemblyProps(tkAssembly,
                                                 (const void **)&pbKey,
                                                 &cbKey,
                                                 NULL,
                                                 szAssemblyName,
                                                 sizeof(szAssemblyName) / sizeof(WCHAR),
                                                 NULL,
                                                 NULL,
                                                 NULL))) {
        Output(SN_FAILED_STRONGNAME, szAssembly, GetErrorString(hr));
        return NULL;
    }

    // Check for strong name.
    if ((pbKey == NULL) || (cbKey == 0)) {
        Output(SN_NOT_STRONG_NAMED, szAssembly);
        return NULL;
    }

    // Compress the strong name down to a token.
    if (!StrongNameTokenFromPublicKey(pbKey, cbKey, &pbToken, &cbToken)) {
        Output(SN_FAILED_CONVERT, GetErrorString(StrongNameErrorInfo()));
        return NULL;
    }

    // Turn the token into hex.
    for (i = 0; i < cbToken; i++)
        swprintf(&szStrongName[i * 2], L"%02X", pbToken[i]);

    // Build the name (in a static buffer).
    wcscat(szAssemblyName, L",");
    wcscat(szAssemblyName, szStrongName);

    StrongNameFreeBuffer(pbToken);
    pAsmImport->Release();
    pDisp->Release();
    CoUninitialize();

    return szAssemblyName;
}


// Parse an assembly an assembly name handed to a register/unregister
// verification skipping function. The input name can be "*" for all assemblies,
// "*,<hex digits>" for all assemblies with a given strong name or the filename
// of a specific assembly. The output is a string of the form:
// "<simple name>,<hex strong name>" where the first or both fields can be
// wildcarded with "*", and the hex strong name is a hexidecimal representation
// of the public key token (as we expect in the "*,<hex digits>" input form).
LPWSTR ParseAssemblyName(LPWSTR szAssembly)
{
    if ((wcscmp(L"*", szAssembly) == 0) ||
        (wcscmp(L"*,*", szAssembly) == 0))
        return L"*,*";
    else if (wcsncmp(L"*,", szAssembly, 2) == 0) {
        DWORD i = wcslen(szAssembly) - 2;
        if ((i == 0) || (i & 1) || (wcsspn(&szAssembly[2], L"0123456789ABCDEFabcdef") != i)) {
            Output(SN_INVALID_SVR_FORMAT);
            return NULL;
        }
        return szAssembly;
    } else
        return GetAssemblyName(szAssembly);
}


// Register an assembly for verification skipping.
bool VerifyRegister(LPWSTR szAssembly, LPWSTR szUserlist)
{
    DWORD   dwError;
    HKEY    hKey;
    LPWSTR  szAssemblyName;
    WCHAR   szKeyName[1024];

    // Get the internal name for the assembly (possibly containing wildcards).
    szAssemblyName = ParseAssemblyName(szAssembly);
    if (szAssemblyName == NULL)
        return false;

    // Build the name of the registry key (qualified by the assembly name) into
    // which we'll write a public key.
    swprintf(szKeyName, SN_CONFIG_KEY_W L"\\" SN_CONFIG_VERIFICATION_W L"\\%s", szAssemblyName);

    // Open or create the above key.
    if ((dwError = WszRegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, 0,
                                   KEY_WRITE, NULL, &hKey, NULL)) != ERROR_SUCCESS) {
        Output(SN_FAILED_REG_OPEN, GetErrorString(dwError));
        return false;
    }

    // Blow away any old user list.
    WszRegDeleteValue(hKey, SN_CONFIG_USERLIST_W);

    // If a list of users is provided, persist it in the registry.
    if (szUserlist && (wcscmp(L"*", szUserlist) != 0)) {
        DWORD   dwLength;
        WCHAR  *mszList;
        WCHAR  *pComma;

        // We persist the user list as a multi-string, i.e. multiple
        // nul-terminated strings packed together and finished off with an
        // additional nul. So we can convert our comma separated list simply by
        // replacing all commas with nul's and adding an additional nul on the
        // end.
        dwLength = (wcslen(szUserlist) + 2) * sizeof(WCHAR);
        mszList = (WCHAR *)_alloca(dwLength);
        wcscpy(mszList, szUserlist);
        pComma = mszList;
        while (*pComma && (pComma = wcschr(pComma, L','))) {
            *pComma = L'\0';
            pComma++;
        }
        mszList[(dwLength / sizeof(WCHAR)) - 1] = '\0';

        // Write the list into the registry.
        if ((dwError = WszRegSetValueEx(hKey, SN_CONFIG_USERLIST_W, 0, REG_MULTI_SZ, (BYTE*)mszList, dwLength)) != ERROR_SUCCESS) {
            Output(SN_FAILED_REG_WRITE, GetErrorString(dwError));
            return false;
        }
    }

    RegCloseKey(hKey);

    if (!g_bQuiet) Output(SN_SVR_ADDED, szAssemblyName);

    return true;
}


// Unregister an assembly for verification skipping.
bool VerifyUnregister(LPWSTR szAssembly)
{
    DWORD   dwError;
    HKEY    hKey;
    LPWSTR  szAssemblyName;

    // Get the internal name for the assembly (possibly containing wildcards).
    szAssemblyName = ParseAssemblyName(szAssembly);
    if (szAssemblyName == NULL)
        return false;

    // Open the developer key subkey.
    if ((dwError = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W L"\\" SN_CONFIG_VERIFICATION_W, 0, KEY_WRITE, &hKey)) != ERROR_SUCCESS) {
        Output(SN_FAILED_REG_OPEN, GetErrorString(dwError));
        return false;
    }

    // Delete the subkey corresponding to the given assembly.
    if ((dwError = WszRegDeleteKey(hKey, szAssemblyName)) != ERROR_SUCCESS) {
        Output(SN_FAILED_REG_DELETE_KEY, GetErrorString(dwError));
        return false;
    }

    RegCloseKey(hKey);

    if (!g_bQuiet) Output(SN_SVR_REMOVED, szAssemblyName);

    return true;
}


// Unregister all verification skipping entries.
bool VerifyUnregisterAll()
{
    HKEY            hKey;
    FILETIME        sFiletime;
    DWORD           i;
    WCHAR           szSubKey[MAX_PATH + 1];
    DWORD           cchSubKey;
    DWORD           dwError;

    // Open the verification subkey in the registry.
    if (WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W L"\\" SN_CONFIG_VERIFICATION_W, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        return true;

    // Assembly specific verification records are represented as subkeys of the
    // key we've just opened.
    for (i = 0; ; i++) {

        // Get the name of the next subkey.
        cchSubKey = MAX_PATH + 1;
        if (WszRegEnumKeyEx(hKey, i, szSubKey, &cchSubKey, NULL, NULL, NULL, &sFiletime) != ERROR_SUCCESS)
            break;

        // Delete the subkey.
        if ((dwError = WszRegDeleteKey(hKey, szSubKey)) != ERROR_SUCCESS)
            Output(SN_FAILED_REG_DELETE_KEY_EX, szSubKey, GetErrorString(dwError));
        else
            i--;
    }

    RegCloseKey(hKey);

    if (!g_bQuiet) Output(SN_SVR_ALL_REMOVED);

    return true;
}


// Check that a given command line option has been given the right number of arguments.
#define OPT_CHECK(_opt, _min, _max) do {                                                                \
    if (wcscmp(L##_opt, &argv[1][1])) {                                                                 \
        Output(SN_INVALID_OPTION, argv[1]);                                                             \
        Usage();                                                                                        \
        return 1;                                                                                       \
    } else if ((argc > ((_max) + 2)) && (argv[2 + (_max)][0] == '-' || argv[2 + (_max)][0] == '/')) {   \
        Output(SN_OPT_ONLY_ONE);                                                                        \
        return 1;                                                                                       \
    } else if ((argc < ((_min) + 2)) || (argc > ((_max) + 2))) {                                        \
        if ((_min) == (_max)) {                                                                         \
            if ((_min) == 0)                                                                            \
                Output(SN_OPT_NO_ARGS, (L##_opt));                                                      \
            else if ((_min) == 1)                                                                       \
                Output(SN_OPT_ONE_ARG, (L##_opt));                                                      \
            else                                                                                        \
                Output(SN_OPT_N_ARGS, (L##_opt), (_min));                                               \
        } else                                                                                          \
            Output(SN_OPT_ARG_RANGE, (L##_opt), (_min), (_max));                                        \
        Usage();                                                                                        \
        return 1;                                                                                       \
    }                                                                                                   \
} while (0)


extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    bool bResult;

    // Initialize Wsz wrappers.
    OnUnicodeSystem();

    // Check for quiet mode.
    if ((argc > 1) &&
        ((argv[1][0] == L'-') || (argv[1][0] == L'/')) &&
        (argv[1][1] == L'q')) {
        g_bQuiet = true;
        argc--;
        argv = &argv[1];
    }

    if (!g_bQuiet)
        Title();

    if ((argc < 2) || ((argv[1][0] != L'-') && (argv[1][0] != L'/'))) {
        Usage();
        return 0;
    }

    switch (argv[1][1]) {
    case 'v':
        if (argv[1][2] == L'f') {
            OPT_CHECK("vf", 1, 1);
            bResult = VerifyAssembly(argv[2], true);
        } else {
            OPT_CHECK("v", 1, 1);
            bResult = VerifyAssembly(argv[2], false);
        }
        break;
    case 'k':
        OPT_CHECK("k", 1, 1);
        bResult = GenerateKeyPair(argv[2]);
        break;
    case 'p':
        if (argv[1][2] == L'c') {
            OPT_CHECK("pc", 2, 2);
            bResult = ExtractPublicKeyFromContainer(argv[2], argv[3]);
        } else {
            OPT_CHECK("p", 2, 2);
            bResult = ExtractPublicKey(argv[2], argv[3]);
        }
        break;
    case 'i':
        OPT_CHECK("i", 2, 2);
        bResult = InstallKeyPair(argv[2], argv[3]);
        break;
    case 'd':
        OPT_CHECK("d", 1, 1);
        bResult = DeleteContainer(argv[2]);
        break;
    case 'V':
        switch (argv[1][2]) {
        case 'l':
            OPT_CHECK("Vl", 0, 0);
            bResult = VerifyList();
            break;
        case 'r':
            OPT_CHECK("Vr", 1, 2);
            bResult = VerifyRegister(argv[2], argc > 3 ? argv[3] : NULL);
            break;
        case 'u':
            OPT_CHECK("Vu", 1, 1);
            bResult = VerifyUnregister(argv[2]);
            break;
        case 'x':
            OPT_CHECK("Vx", 0, 0);
            bResult = VerifyUnregisterAll();
            break;
        default:
            Output(SN_INVALID_V_OPT, argv[1]);
            Usage();
            return 1;
        }
        break;
    case 't':
        if (argv[1][2] == L'p') {
            OPT_CHECK("tp", 1, 1);
            bResult = DisplayTokenFromKey(argv[2], true);
        } else {
            OPT_CHECK("t", 1, 1);
            bResult = DisplayTokenFromKey(argv[2], false);
        }
        break;
    case 'T':
        if (argv[1][2] == L'p') {
            OPT_CHECK("Tp", 1, 1);
            bResult = DisplayTokenFromAssembly(argv[2], true);
        } else {
            OPT_CHECK("T", 1, 1);
            bResult = DisplayTokenFromAssembly(argv[2], false);
        }
        break;
    case 'e':
        OPT_CHECK("e", 2, 2);
        bResult = ExtractPublicKeyFromAssembly(argv[2], argv[3]);
        break;
    case 'o':
        OPT_CHECK("o", 1, 2);
        bResult = WriteCSV(argv[2], argc > 3 ? argv[3] : NULL);
        break;
    case 'D':
        OPT_CHECK("D", 2, 2);
        bResult = DiffAssemblies(argv[2], argv[3]);
        break;
    case 'R':
        if (argv[1][2] == L'c') {
            OPT_CHECK("Rc", 2, 2);
            bResult = ResignAssembly(argv[2], argv[3], true);
        } else {
            OPT_CHECK("R", 2, 2);
            bResult = ResignAssembly(argv[2], argv[3], false);
        }
        break;
    case '?':
    case 'h':
    case 'H':
        Usage();
        bResult = true;
        break;
    case 'c':
        OPT_CHECK("c", 0, 1);
        bResult = SetCSP(argc > 2 ? argv[2] : NULL);
        break;
    case 'm':
        OPT_CHECK("m", 0, 1);
        bResult = SetUseMachineKeyset(argc > 2 ? argv[2] : NULL);
        break;
    default:
        Output(SN_INVALID_OPTION, &argv[1][1]);
        bResult = false;
    }

    return bResult ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\verstamp\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "METAINFO.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Version Stamping Tool\0"
#define VER_ORIGFILENAME_STR    "verstamp.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\verstamp\verstamp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//******************************************************************************
// RELEVANT BACKGROUND INFORMATION:
// *  Assemblies come in two forms, (a) single file assemblies and (b) multi-file
//    assemblies.
// *  Strong Name Hashing is over the entire image byte for byte ignoring the
//    authenticode certificate area.  Strong names can be installed using sn.exe
//    (if one has the CLR installed), or with StrongNameSign.exe (requested by
//    PRS so they don't have any foreign software on their private key boxes).
// *  signcode.exe is used to compute and install authenticode certificates in
//    a PE, and would include the Strong Name Hash section of the PE.  We do
//    this for testing purposes in our development lab, but PRS does it for
//    real (an external customer would use Verisign or whatever).
//
// SINGLE FILE ASSEMBLIES
//  A single file assembly has its own manifest, an AssemblyDef, and
//  AssemblyRef's to types it pulls in externally.  There is no hashing
//  done on a file like this, except the possiblity that someone has strong-
//  named signed the file and possibly included authenticode.  Both are
//  orthoganal to post processing the assembly information.  The steps are:
//  1. Update the AssemblyDef version number in the file.
//  2. Updated the AssemblyRef version numbers as required.
//  3. Once all of this is done, the normal strong name hash/signcode work
//      may be done externally to this tool.
//
// MULTI-FILE ASSEMBLIES
//  A multi-file assembly consists of a PE that has the only manifest for a
//  set of modules, along with those modules.  Each contained module may have
//  AssemblyRef's but will not have an AssemblyDef in it.  The manifest module
//  will have an AssemblyDef, can have AssemblyRef's, and will also have
//  FileRef's to its contained modules.  These FileRef's have a hash that is
//  used to identify their contained modules.  The steps are:
//  1. Update the AssemblyDef version number in the manifest module.
//  2. Update any AssemblyRef's that have changed.
//  3. Re-hash the contents of each contained module using the hash algorithm id
//      to figure it out, then bash the old hash in the FileRef.
//  4. Once all of this is done, the normal strong name hash/signcode work
//      may be done externally to this tool.
//
//******************************************************************************
#include "utilcode.h"
#include "cor.h"
#define _METADATATRACKER_H_
#define METADATATRACKER_ONLY(s)
#include "MetaModelPub.h"
#include "__file__.ver"
#include <corver.h>



//*****************************************************************************
//
//**********  Globals **********
//
//*****************************************************************************
IMetaDataDispenserEx *g_pDisp = NULL;
HINSTANCE   g_hInstMsCorSn = NULL;
typedef DWORD (__stdcall* GETHASHFROMBLOB)(BYTE *, DWORD, unsigned int *, BYTE *, DWORD, unsigned *);
GETHASHFROMBLOB g_GetHashFromBlob = NULL;
#define SZ_VERSION "Version="

//*****************************************************************************
//
//**********  Local Functions **********
//
//*****************************************************************************
PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders, IN PVOID Base, IN ULONG Rva);
PVOID Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders, IN PVOID Base, IN ULONG Rva);
IMAGE_COR20_HEADER * getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT);
IMAGE_NT_HEADERS * FindNTHeader(PBYTE pbMapAddress);

int __cdecl Printf(const wchar_t *szFmt, ...);
int __cdecl PrintError(const wchar_t *szMessage, ...);
int __cdecl PrintWarning(const wchar_t *szMessage, ...);
void PrintMDErrors();


//*****************************************************************************
//
//**********  Local Code **********
//
//*****************************************************************************

#define MAXVER 64

struct VERSIONSTAMP
{
    // Version numbers as stored in the metadata.  These values used to
    // stamp existing binaries with a new value.
    USHORT      m_MajorVersion;
    USHORT      m_MinorVersion;
    USHORT      m_BuildNumber;
    USHORT      m_RevisionNumber;
};


struct VerInfo
{
    VerInfo() :
        m_szVersion(0),
        m_szFromVersion(0)
    { 
    }

    wchar_t     *m_szVersion;               // Version stamp.
    wchar_t     *m_szFromVersion;           // Custom attribute version to replace.

    VERSIONSTAMP m_VerStamp;                // Version stamp.
    VERSIONSTAMP m_FromVerStamp;            // Version we're replacing with.

    char         m_rcAnsiFromVer[MAXVER];   // Ansi replace version.

    wchar_t      m_rcToVer[MAXVER];         // To version wide.
    char         m_rcAnsiToVer[MAXVER];     // To version.

    int          m_cChars;                  // Number of chars to compare.
};


struct TABLEDESC
{
    ULONG       cbRow;
    ULONG       cRows;
    ULONG       cCols;
    ULONG       iKey;
    const char  *szName;
};

struct COLUMNDESC
{
    ULONG       oCol;                   // Offset of column in row.
    ULONG       cbCol;                  // Size of column.
    ULONG       Type;                   // What type is column.
    const char  *szName;                // Name of the column.
};

struct IResolve
{
    virtual unsigned ResolveAssemblyRef(const char *szName, VERSIONSTAMP &newVer) = 0;

    virtual unsigned ResolveFileRef(const char *szName, BYTE *pbHash, ULONG cbHashMax) = 0;
};
struct Command;


struct PeFile
{
    IMetaDataAssemblyImport *m_pAssemblyImport; // Read assembly data.
    IMetaDataTables *m_pTables;             // Internal metadata format api.
    wchar_t         *m_szFile;              // Pointer to file.
    wchar_t         *m_szShortName;         // Short name of the file.
    PBYTE           m_pbMapAddress;         // Mapped in file.
    unsigned        m_cbPEFileSize;         // Size of PE file.
    IMAGE_COR20_HEADER  *m_pICH;            // Our header.
    void            *m_pMetaData;           // Pointer to metadata.
    unsigned        m_cbMetaData;           // How big is that metadata.
    IResolve        *m_pParent;             // Parent command object.

    // Cached descritptions of the tables.
    TABLEDESC       m_tbldescAD;
    COLUMNDESC      *m_rgColumnsAD;
    TABLEDESC       m_tbldescAR;
    COLUMNDESC      *m_rgColumnsAR;
    TABLEDESC       m_tbldescFR;
    COLUMNDESC      *m_rgColumnsFR;

    VERSIONSTAMP    m_VerStamp;             // Version of this assembly.
    const char      *m_szAssemblyName;      // Name of this assembly.

    PeFile() :
        m_pAssemblyImport(0),
        m_pTables(0),
        m_szFile(0),
        m_szShortName(0),
        m_pbMapAddress(0),
        m_cbPEFileSize(0),
        m_pICH(0),
        m_pMetaData(0),
        m_cbMetaData(0),
        m_pParent(0),
        m_rgColumnsAD(0),
        m_rgColumnsAR(0),
        m_rgColumnsFR(0),
        m_szAssemblyName(0)
    {
    }

    ~PeFile()
    {
        if (m_szFile)
            delete [] m_szFile;

        if (m_rgColumnsAD)
            delete [] m_rgColumnsAD;
        if (m_rgColumnsAR)
           delete [] m_rgColumnsAR;
        if (m_rgColumnsFR)
           delete [] m_rgColumnsFR;

        if (m_pbMapAddress)
            UnmapViewOfFile(m_pbMapAddress);
        m_pbMapAddress = 0;
        
        if (m_pAssemblyImport)
            m_pAssemblyImport->Release();
        m_pAssemblyImport = 0;

        if (m_pTables)
            m_pTables->Release();
        m_pTables = 0;
    }

    bool IsManaged()
    {
        if (m_cbMetaData)
            return true;
        else
            return false;
    }

    // This method will map the image into a memory mapped file and parse
    // for the metadata.  When found, cache a pointer to it.
    unsigned CrackFile()
    {
        IMAGE_NT_HEADERS    *pNT;
        HANDLE              hMapFile;
        unsigned            Rtn = 0;
        
        HANDLE hFile = WszCreateFile(m_szFile,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL); 
        if (hFile == INVALID_HANDLE_VALUE)
        {
            WCHAR   rcMsg[1024];
            Rtn = GetLastError();
            PrintError(L"  Error with file %s (%08x)\n", m_szFile, Rtn);
            if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                    0, Rtn, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    rcMsg, NumItems(rcMsg), 0))
            {
                PrintError(L"  %s\n", rcMsg);
            }

            return Rtn;
        }
        
        hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
        Rtn = GetLastError();
        DWORD dwHigh;
        m_cbPEFileSize = GetFileSize(hFile, &dwHigh); 
        if (dwHigh != 0)
        {
            PrintError(L"File too big !\n");
            return E_FAIL;
        }

        CloseHandle(hFile);
        if (!hMapFile) 
        {
            PrintError(L"Error mapping file %s (%08x)\n", m_szFile, Rtn);
            return Rtn;
        }
        
        m_pbMapAddress = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
        Rtn = GetLastError();
        CloseHandle(hMapFile);
        
        if (!m_pbMapAddress)
        {
            PrintError(L"Error mapping file %s (%08x)\n", m_szFile, Rtn);
            return Rtn;
        }
        
        if ((pNT = FindNTHeader(m_pbMapAddress)) &&
            (m_pICH = getCOMHeader((HMODULE) m_pbMapAddress, pNT)) &&
            (m_pICH->MetaData.Size)) 
        {
            m_pMetaData = Cor_RtlImageRvaToVa(pNT, m_pbMapAddress, 
                                     m_pICH->MetaData.VirtualAddress);
            m_cbMetaData = m_pICH->MetaData.Size;
        }
        // Might not be one of our images.
        else
        {
            if (!m_pICH)
                return (1);
        }
        return (0);
    }

    void *GetResourceSection(ULONG &cbItem)
    {
        IMAGE_NT_HEADERS    *pNT;
        pNT = FindNTHeader(m_pbMapAddress);
        if (!pNT || !m_pICH)
            return 0;
        void *p = 0;
        cbItem = m_pICH->Resources.Size;
        if (m_pICH->Resources.VirtualAddress && cbItem)
            p = Cor_RtlImageRvaToVa(pNT, m_pbMapAddress,
                        m_pICH->Resources.VirtualAddress);
        return (p);
    }

    unsigned OpenPeFile(IResolve *pCommand, const wchar_t *szFile)
    {
        unsigned    hr;
        
        // Save off important information.
        m_pParent = pCommand;
        
        // Store full name of dll.
        m_szFile = new wchar_t[wcslen(szFile) + 1];
        if (!m_szFile)
            IfFailGo(E_OUTOFMEMORY);
        wcscpy(m_szFile, szFile);

        // Get short name.
        wchar_t rcFile[_MAX_PATH], rcExt[_MAX_PATH];
        _wsplitpath(m_szFile, 0, 0, rcFile, rcExt);
        int iLen = wcslen(rcFile) + wcslen(rcExt) + 1;
        m_szShortName = new wchar_t[iLen];
        if (!m_szShortName)
            IfFailGo(E_OUTOFMEMORY);
        wcscpy(m_szShortName, rcFile);
        wcscat(m_szShortName, rcExt);

        // Open the file.
        hr = CrackFile();
        if (hr == S_FALSE)
        {
            PrintWarning(L"  %s is not a managed image.\n", m_szFile);
            return (S_FALSE);
        }
        else if (FAILED(hr))
        {
            PrintWarning(L"  %s ignored.\n", m_szFile);
        }
        else if (m_pMetaData && m_cbMetaData)
        {
            // open the metadata so we can go stomp it some.
            hr = g_pDisp->OpenScopeOnMemory(
                    m_pMetaData, m_cbMetaData, 0, 
                    IID_IMetaDataAssemblyImport, (IUnknown **) &m_pAssemblyImport);
            if (FAILED(hr) ||
                FAILED(hr = m_pAssemblyImport->QueryInterface(IID_IMetaDataTables, (void **) &m_pTables)))
            {
                PrintError(L"  Failed to OpenScopeOnMemory %08x\n", hr);
                if (hr == CLDB_E_FILE_CORRUPT)
                {
                    PrintError(L"  File is corrupt, might be obsolete?\n");
                    return S_FALSE;
                }
                return (hr);
            }
        }

    ErrExit:
        if (FAILED(hr))
            PrintError(L"Failed stamping file (%08x).\n", hr);
        return hr;
    }

    unsigned CacheTableData(ULONG tid, TABLEDESC &tbldesc, 
                                      COLUMNDESC *&rgColumns)
    {
        unsigned    hr;
        ULONG       i;
    
        if (!IsManaged())
            return 0;

        // Retrieve a description of this table.  There should only be one
        // record in the assembly table.
        hr = m_pTables->GetTableInfo(tid, &tbldesc.cbRow,
                      &tbldesc.cRows, &tbldesc.cCols, &tbldesc.iKey,
                      &tbldesc.szName);
        IfFailGo(hr);
        rgColumns = new COLUMNDESC[tbldesc.cCols];
        if (!rgColumns)
            IfFailGo(E_OUTOFMEMORY);
        for (i=0;  i<tbldesc.cCols;  i++)
        {
            COLUMNDESC *p = &rgColumns[i];
            hr = m_pTables->GetColumnInfo(tid, i, &p->oCol,
                                           &p->cbCol, &p->Type, &p->szName);
            IfFailGo(hr);
        }

    ErrExit:
        return hr;
    }

    unsigned GetAssemblyDefData()
    {
        HRESULT hr = S_OK;


        if (!IsManaged())
            return hr;

        if (!m_rgColumnsAD)
        {
            hr = CacheTableData(TBL_Assembly, m_tbldescAD, m_rgColumnsAD);
            IfFailGo(hr);
        }

        if (m_tbldescAD.cRows)
        {
            BYTE *pRow;
            hr = m_pTables->GetRow(TBL_Assembly, 1, (void **) &pRow);
            IfFailGo(hr);
            
            USHORT *pMajor = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_MajorVersion].oCol);
            USHORT *pMinor = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_MinorVersion].oCol);
            USHORT *pBuildNum = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_BuildNumber].oCol);
            USHORT *pRevisionNum = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_RevisionNumber].oCol);
    
            m_VerStamp.m_MajorVersion = *pMajor;
            m_VerStamp.m_MinorVersion = *pMinor;
            m_VerStamp.m_BuildNumber = *pBuildNum;
            m_VerStamp.m_RevisionNumber = *pRevisionNum;
    
            ULONG ixString;
            BYTE *pixString = (pRow + m_rgColumnsAD[AssemblyRec::COL_Name].oCol);
            if (m_rgColumnsAD[AssemblyRec::COL_Name].cbCol == sizeof(USHORT))
                ixString = (ULONG) *((USHORT *) pixString);
            else
                ixString = *((ULONG *) pixString);
            hr = m_pTables->GetString(ixString, &m_szAssemblyName);
            IfFailGo(hr);
        }

    ErrExit:
        return hr;
    }

    // used when stamping to update the version stamp for the assemblydef in
    // this module to the new value.
    unsigned UpdateAssemblyDef(VERSIONSTAMP &verstamp)
    {
        unsigned    hr;

        if (!IsManaged())
            return S_FALSE;
        
        if (!m_rgColumnsAD)
        {
            hr = CacheTableData(TBL_Assembly, m_tbldescAD, m_rgColumnsAD);
            IfFailGo(hr);
        }
        
        _ASSERTE(m_tbldescAD.cRows == 0 || m_tbldescAD.cRows == 1);
        // Now armed with the column descriptions, walk each of the records
        // in the table and whack the assembly version.
        if (m_tbldescAD.cRows)
        {
            BYTE *pRow;
            hr = m_pTables->GetRow(TBL_Assembly, 1, (void **) &pRow);
            IfFailGo(hr);

            USHORT *pMajor = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_MajorVersion].oCol);
            USHORT *pMinor = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_MinorVersion].oCol);
            USHORT *pBuildNum = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_BuildNumber].oCol);
            USHORT *pRevisionNum = (USHORT *) (pRow + m_rgColumnsAD[AssemblyRec::COL_RevisionNumber].oCol);

            Printf(L"    Stamping AssemblyDef version %02u.%02u.%02u.%02u with %02u.%02u.%02u.%02u\n",
                    *pMajor, *pMinor, *pBuildNum, *pRevisionNum,
                    verstamp.m_MajorVersion, verstamp.m_MinorVersion, 
                    verstamp.m_BuildNumber, verstamp.m_RevisionNumber);

            *pMajor = verstamp.m_MajorVersion;
            *pMinor = verstamp.m_MinorVersion;
            *pBuildNum = verstamp.m_BuildNumber;
            *pRevisionNum = verstamp.m_RevisionNumber;
        }

        hr = GetAssemblyDefData();

    ErrExit:
        if (FAILED(hr))
            PrintError(L"Failed stamping file (%08x).\n", hr);
        return hr;
    }

    // Find any CA's in this file which were are used for binding to an
    // assembly.  When you find one, if it matches then it needs to get
    // restamped to the new version value.
    unsigned UpdateCA(VerInfo &ver)
    {
        ULONG       ixItem;
        ULONG       cbItem = 0;
        const void  *pbItem;
        ULONG       cbHeapSize;
        unsigned    hr;

        if (!IsManaged())
            return S_FALSE;

        //
        // Do all blobs first.
        //
        hr = m_pTables->GetBlobHeapSize(&cbHeapSize);
        if (FAILED(hr) || cbHeapSize == 0)
            goto ErrExit;

        for (ixItem=0, hr=S_OK;  hr==S_OK && ixItem<cbHeapSize;  )
        {
            hr = m_pTables->GetNextBlob(ixItem, &ixItem);
            if (hr != S_OK)
                break;

            hr = m_pTables->GetBlob(ixItem, &cbItem, &pbItem);
            if (hr != S_OK)
                break;

            hr = UpdateCAData(ixItem, (char *) pbItem, cbItem, ver);
            if (hr != S_OK)
                break;
        }

        
        //
        // Do all heap strings next.
        //
        hr = m_pTables->GetStringHeapSize(&cbHeapSize);
        if (FAILED(hr) || cbHeapSize == 0)
            goto ErrExit;

        for (ixItem=0, hr=S_OK;  hr==S_OK && ixItem<cbHeapSize;  )
        {
            hr = m_pTables->GetNextString(ixItem, &ixItem);
            if (hr != S_OK)
                break;

            hr = m_pTables->GetString(ixItem, (const char **) &pbItem);
            if (hr != S_OK)
                break;

            hr = UpdateCAData(ixItem, (char *) pbItem, strlen((char *) pbItem), ver);
            if (hr != S_OK)
                break;
        }

        
        //
        // Now all user string literals which could have hard coded assembly refs.
        //
        hr = m_pTables->GetUserStringHeapSize(&cbHeapSize);
        if (FAILED(hr) || cbHeapSize == 0)
            goto ErrExit;

        for (ixItem=0, hr=S_OK;  hr==S_OK && ixItem<cbHeapSize;  )
        {
            hr = m_pTables->GetNextUserString(ixItem, &ixItem);
            if (hr != S_OK)
                break;

            hr = m_pTables->GetUserString(ixItem, &cbItem, &pbItem);
            if (hr != S_OK)
                break;

            hr = UpdateCAData(ixItem, (char *) pbItem, cbItem, ver);
            if (hr != S_OK)
                break;
        }
        
        //
        // And now for the resource section of the PE file which may 
        // have localized strings of some sort for binding.
        //
        hr = S_OK;
        pbItem = GetResourceSection(cbItem);
        if (pbItem && cbItem)
            hr = UpdateCAData(0, (char *) pbItem, cbItem, ver);
        
    ErrExit:
        if (FAILED(hr))
            PrintError(L"Failed stamping file (%08x).\n", hr);
        return hr;
    }

    // Scan the given blob and look for "Version=" stamp to see if it needs to
    // get updated.
    unsigned UpdateCAData(ULONG cbOffset, char *pbBlob, ULONG cbBlob, VerInfo &ver)
    {
        while (cbBlob >= (ULONG) ver.m_cChars)
        {
            if (_strnicmp(pbBlob, ver.m_rcAnsiFromVer, ver.m_cChars) == 0)
            {
                strncpy(pbBlob, ver.m_rcAnsiToVer, ver.m_cChars);
                pbBlob += ver.m_cChars;

                Printf(L"      Replacing utf8 offset 0x%08x with %S\n", cbOffset, ver.m_rcAnsiToVer);
            }
            else if (_wcsnicmp((wchar_t *) pbBlob, ver.m_szFromVersion, ver.m_cChars) == 0)
            {
                wcsncpy((wchar_t *) pbBlob, ver.m_rcToVer, ver.m_cChars);
                pbBlob += (ver.m_cChars * sizeof(wchar_t));

                Printf(L"      Replacing unicode offset 0x%08x with %s\n", cbOffset, ver.m_rcToVer);
            }
            else
            {
                ++pbBlob;
                --cbBlob;
            }
        }

        return 0;
    }
    
    
    // Updates the binding from where it currently points into the current
    // version stamp.  This only affects ssemblies in the closure passed in,
    // there is no attempt to resolve external references.
    unsigned UpdateAssemblyRefs(VERSIONSTAMP *fromVerstamp)
    {
        unsigned    hr = S_OK;
        ULONG       i;
        
        if (!IsManaged())
            return S_FALSE;
        
        if (!m_rgColumnsAR)
        {
            hr = CacheTableData(TBL_AssemblyRef, m_tbldescAR, m_rgColumnsAR);
            IfFailGo(hr);
        }

        // Now armed with the column descriptions, walk each of the records
        // in the table and whack the assembly version.
        for (i=0;  i<m_tbldescAR.cRows;  i++)
        {
            BYTE *pRow;
            const char *szName = 0;
            hr = m_pTables->GetRow(TBL_AssemblyRef, i + 1, (void **) &pRow);
            IfFailGo(hr);
            
            ULONG ixString;
            BYTE *pixString = (pRow + m_rgColumnsAR[AssemblyRefRec::COL_Name].oCol);
            if (m_rgColumnsAR[AssemblyRefRec::COL_Name].cbCol == sizeof(USHORT))
                ixString = (ULONG) *((USHORT *) pixString);
            else
                ixString = *((ULONG *) pixString);
            hr = m_pTables->GetString(ixString, &szName);
            IfFailGo(hr);

            USHORT *pMajor = (USHORT *) (pRow + m_rgColumnsAR[AssemblyRefRec::COL_MajorVersion].oCol);
            USHORT *pMinor = (USHORT *) (pRow + m_rgColumnsAR[AssemblyRefRec::COL_MinorVersion].oCol);
            USHORT *pBuildNum = (USHORT *) (pRow + m_rgColumnsAR[AssemblyRefRec::COL_BuildNumber].oCol);
            USHORT *pRevisionNum = (USHORT *) (pRow + m_rgColumnsAR[AssemblyRefRec::COL_RevisionNumber].oCol);

            Printf(L"    AssemblyRef %S\n", szName);

            VERSIONSTAMP newVer;
            hr = m_pParent->ResolveAssemblyRef(szName, newVer);
            if (hr == S_OK)
            {
                if ((!fromVerstamp) ||
                    ((*pMajor == fromVerstamp->m_MajorVersion) && (*pMinor == fromVerstamp->m_MinorVersion) &&
                    (*pBuildNum == fromVerstamp->m_BuildNumber) && (*pRevisionNum == fromVerstamp->m_RevisionNumber)))
                {

                    Printf(L"      Replacing version %02u.%02u.%02u.%02u with %02u.%02u.%02u.%02u\n",
                           *pMajor, *pMinor, *pBuildNum, *pRevisionNum,
                           newVer.m_MajorVersion, newVer.m_MinorVersion, 
                           newVer.m_BuildNumber, newVer.m_RevisionNumber);
                
                    *pMajor = newVer.m_MajorVersion;
                    *pMinor = newVer.m_MinorVersion;
                    *pBuildNum = newVer.m_BuildNumber;
                    *pRevisionNum = newVer.m_RevisionNumber;
                }
            }
            else
            {
                PrintWarning(L"      Assembly not in closure, left with %02u.%02u.%02u.%02u.\n",
                       *pMajor, *pMinor, *pBuildNum, *pRevisionNum);
            }
        }

    ErrExit:
        if (FAILED(hr))
            PrintError(L"Failed stamping file (%08x).\n", hr);
        return hr;
    }

    // When dealing with multi-file assemblies, you need to update the has for
    // the contained assemblies to match -- it's data may have changed if you
    // munged version stamps in the metadata.
    unsigned UpdateFileRefs()
    {
        unsigned    hr = S_OK;
        ULONG       i;
        
        if (!IsManaged())
            return S_FALSE;

        if (!m_rgColumnsFR)
        {
            hr = CacheTableData(TBL_File, m_tbldescFR, m_rgColumnsFR);
            IfFailGo(hr);
        }

        // Now armed with the column descriptions, walk each of the records
        // in the table and whack the assembly version.
        for (i=0;  i<m_tbldescFR.cRows;  i++)
        {
            BYTE *pRow;
            const char *szName = 0;
            hr = m_pTables->GetRow(TBL_File, i + 1, (void **) &pRow);
            IfFailGo(hr);
            
            ULONG ixString;
            BYTE *pixString = (pRow + m_rgColumnsFR[FileRec::COL_Name].oCol);
            if (m_rgColumnsFR[FileRec::COL_Name].cbCol == sizeof(USHORT))
                ixString = (ULONG) *((USHORT *) pixString);
            else
                ixString = *((ULONG *) pixString);
            hr = m_pTables->GetString(ixString, &szName);
            IfFailGo(hr);

            ULONG cbHashMax;
            BYTE *pbHash = (pRow + m_rgColumnsFR[FileRec::COL_HashValue].oCol);
            if (m_rgColumnsFR[FileRec::COL_HashValue].cbCol == sizeof(USHORT))
                ixString = (ULONG) *((USHORT *) pbHash);
            else
                ixString = *((ULONG *) pbHash);
            hr = m_pTables->GetBlob(ixString, &cbHashMax, (const void **) &pbHash);
            IfFailGo(hr);
            Printf(L"    File ref %S\n", szName);

            hr = m_pParent->ResolveFileRef(szName, pbHash, cbHashMax);
            if (hr == S_OK)
                Printf(L"    Replaced hash blob at %08x.\n", ixString);
            else if (hr == S_FALSE)
                PrintWarning(L"    File not in closure, unchanged.\n");
        }

        ErrExit:
            if (FAILED(hr))
                PrintError(L"Failed stamping file (%08x).\n", hr);
            return hr;
    }

    unsigned GetHashOfFile(BYTE *pbHash, ULONG cbHashMax)
    {
        // First time through have to load everything up.
        if (!g_hInstMsCorSn)
        {
            g_hInstMsCorSn = WszLoadLibrary(L"mscorsn.dll");
            if (!g_hInstMsCorSn)
            {
                unsigned rtn = GetLastError();
                PrintError(L"Failed to get mscorsn.dll, 0x%08x\n", rtn);
                return HRESULT_FROM_WIN32(rtn);
            }

            g_GetHashFromBlob = (GETHASHFROMBLOB) GetProcAddress(g_hInstMsCorSn, "GetHashFromBlob");
            if (!g_GetHashFromBlob)
            {
                unsigned rtn = GetLastError();
                PrintError(L"Entry point GetHashFromBlob not found in mscoree.dll! %08x\n", rtn);
                return HRESULT_FROM_WIN32(rtn);
            }
        }

        // now you can compute the hash.
        unsigned cbHash = 0;
        unsigned hashid = 0;
        unsigned rtn = (*g_GetHashFromBlob)(
                            m_pbMapAddress,
                            m_cbPEFileSize,
                            &hashid,
                            pbHash, 
                            cbHashMax,
                            &cbHash);
        _ASSERTE(cbHash <= cbHashMax);
        return rtn;
    }

    unsigned ClearChecksum()
    {
        IMAGE_NT_HEADERS    *pNT;

        pNT = FindNTHeader(m_pbMapAddress);
        if (pNT)
        {
            Printf(L"    Replacing (checksum,size,rva) (%08x,%08x,%08x) with 0.\n",
                            pNT->OptionalHeader.CheckSum,
                            pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size,
                            pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress);
            
            pNT->OptionalHeader.CheckSum = 0;
            pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
            pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
        }
        return 0;
    }

};


struct Command : public IResolve
{
    bool        m_bStamp;                   // True to stamp the target files.
    bool        m_bBind;                    // True to bind to targets.
    bool        m_bStampNoDef;              // True to stamp the target files, except don't change the Assembly Def
    bool        m_bWhackChecksum;           // Clear out signing information. DANGEROUS!
    wchar_t     **m_FileList;               // List of file pointers.
    int         m_FileCnt;                  // How many.
    CDynArray< PeFile * > m_pefiles;        // Array of all files in question.
    VerInfo     m_Ver;                      // All version information.


    Command() :
        m_bStamp(false),
        m_bBind(false),
        m_bStampNoDef(false),
        m_bWhackChecksum(false),
        m_FileList(0),
        m_FileCnt(0)
    {
    }

    ~Command()
    {
        PeFile *p;
        for (int i=0;  i<m_pefiles.Count();  i++)
        {
            p = *m_pefiles.Get(i);
            delete p;
        }
    }

    unsigned __cdecl Run(int argc, wchar_t *argv[])
    {
        unsigned    Rtn = 0;
        wchar_t     *szArg;
        int         i;

        PrintLogo();

        for (i=1;  i<argc;  i++)
        {
            szArg = argv[i];

            if (*szArg == L'-' || *szArg == L'/')
            {
                ++szArg;
                if (_wcsicmp(szArg, L"stamp") == 0)
                    m_bStamp = true;
                else if (_wcsicmp(szArg, L"bind") == 0)
                    m_bBind = true;
                else if (_wcsicmp(szArg, L"stampnodef") == 0)
                    m_bStampNoDef = true;
                else if (_wcsnicmp(szArg, L"version:", 8) == 0)
                {
                    m_Ver.m_szVersion = &szArg[8];
                    if (ParseVersion(m_Ver.m_szVersion, m_Ver.m_VerStamp) != 0)
                        return Usage();
                }
                else if (_wcsnicmp(szArg, L"replace:", 8) == 0)
                {
                    m_Ver.m_szFromVersion = &szArg[8];
                    if (ParseVersion(m_Ver.m_szFromVersion, m_Ver.m_FromVerStamp) != 0)
                        return Usage();
                }
                else if (_wcsnicmp(szArg, L"clearchecksum", 13) == 0)
                    m_bWhackChecksum = true;
                else if (_wcsicmp(szArg, L"?") == 0)
                    return Usage();
            }
            else
            {
                m_FileList = &argv[i];
                m_FileCnt = argc - i;
                break;
            }
        }

        // Must be trying something.
        if (m_bStamp == false && m_bBind == false &&
            m_bStampNoDef == false && m_bWhackChecksum == false)
            return Usage();

        if ((m_bStamp || m_bStampNoDef) && (!m_Ver.m_szVersion))
            return Usage();

        // When not stamping the defs, need to know which version is
        // the one to update, so the rest can be ignored.
        if (m_bStampNoDef && (!m_Ver.m_szFromVersion))
            return Usage();

        // Map all of the candidate files into memory.
        Rtn = InitAllFiles();
        if (FAILED(Rtn))
            goto ErrExit;

        // This option is DANGEROUS!  It'll clear the signing information
        // from an image.  This is undocumented at this point and used in
        // our build process.
        if (m_bWhackChecksum)
        {
            Rtn = ClearAllChecksums();
            if (FAILED(Rtn))
                goto ErrExit;
        }

        // Stamping requires a valid version stamp be passed in using the
        // /version switch.  Parse it and then go for the files.
        if (m_bStamp || m_bStampNoDef)
        {
            if (m_FileCnt == 0 || m_FileList == 0)
                return Usage();

            if (!m_bStampNoDef) {
                Rtn = StampAllFiles();
                if (FAILED(Rtn))
                    goto ErrExit;
            }

            Rtn = StampCustomAttributes();
            if (FAILED(Rtn))
                goto ErrExit;
        }

        // Now bind all of the files as required.
        if (m_bBind)
        {
            Rtn = BindAllFiles();
            if (FAILED(Rtn))
                goto ErrExit;

            Rtn = UpdateAllFileRefs();
            if (FAILED(Rtn))
                goto ErrExit;
        }

    ErrExit:
        return Rtn;
    }

    unsigned AddPeFile(PeFile *p)
    {
        PeFile **pp;
        pp = m_pefiles.Append();
        if (!pp)
            return (E_OUTOFMEMORY);
        *pp = p;
        return S_OK;
    }

    // Open each image for write access.
    unsigned InitAllFiles()
    {
        int         i;
        unsigned    hr = S_OK;
        
        Printf(L"\nScanning files:\n");

        for (i=0;  i<m_FileCnt;  i++)
        {
            Printf(L"  %s\n", m_FileList[i]);

            WIN32_FIND_DATA fdFiles;
            HANDLE hFind;
            wchar_t szSpec[_MAX_PATH];
            wchar_t szDrive[_MAX_DRIVE];
            wchar_t szDir[_MAX_DIR];
            PeFile *p;
            
            // Convert relative paths to full paths.
            wchar_t *szFname;
            *szSpec = 0;
            WszGetFullPathName(m_FileList[i], _MAX_PATH, szSpec, &szFname);
            SplitPath(szSpec, szDrive, szDir, NULL, NULL);
            hFind = WszFindFirstFile(szSpec, &fdFiles);

            if (hFind == INVALID_HANDLE_VALUE)
            {
                p = new PeFile;
                if (!p)
                    IfFailGo(E_OUTOFMEMORY);
                
                // Map this PE into memory.
                hr = p->OpenPeFile(this, m_FileList[i]);
                if (hr == S_OK || hr == S_FALSE)
                    hr = AddPeFile(p);
                else
                    delete p;
            }
            else
            {
                // Convert relative paths to full paths.
                WszGetFullPathName(m_FileList[i], _MAX_PATH, szSpec, &szFname);
                SplitPath(szSpec, szDrive, szDir, NULL, NULL);
                do
                {
                    p = new PeFile;
                    if (!p)
                        IfFailGo(E_OUTOFMEMORY);
                    
                    MakePath(szSpec, szDrive, szDir, fdFiles.cFileName, NULL);
                    Printf(L"  %s\n", szSpec);
                    hr = p->OpenPeFile(this, szSpec);
                    if (hr == S_OK || hr == S_FALSE)
                        hr = AddPeFile(p);
                    else
                        delete p;
                    if (hr == S_FALSE || hr == ERROR_SHARING_VIOLATION || hr == ERROR_ACCESS_DENIED)
                        hr = S_OK;
                } while (hr == S_OK && WszFindNextFile(hFind, &fdFiles)) ;
                FindClose(hFind);
            }
        }

    ErrExit:
        return hr;
    }

    unsigned ClearAllChecksums()
    {
        int         i;
        unsigned    hr = 0;
        
        Printf(L"\nClearing Checksums:\n");

        for (i=0;  i<m_pefiles.Count();  i++)
        {
            PeFile *p = *m_pefiles.Get(i);
            Printf(L"  %s\n", p->m_szFile);
            hr = p->ClearChecksum();
            IfFailGo(hr);
        }

    ErrExit:
        return hr;
    }

    unsigned StampAllFiles()
    {
        int         i;
        unsigned    hr = 0;
        
        Printf(L"\nStamping Assembly Defs:\n");

        for (i=0;  i<m_pefiles.Count();  i++)
        {
            // Update the assembly def table as required.
            PeFile *p = *m_pefiles.Get(i);
            Printf(L"  %s\n", p->m_szFile);
            hr = p->UpdateAssemblyDef(m_Ver.m_VerStamp);
            IfFailGo(hr);
        }

    ErrExit:
        return hr;
    }

    unsigned StampCustomAttributes()
    {
        int         i;
        unsigned    hr = 0;

        if (m_Ver.m_szFromVersion == 0)
            return 0;

        Printf(L"\nStamping Custom Attributes:\n");

        // First create a replacement version string that is going to fit.
        // This includes converting the user string to replace into single byte
        // which is what is in the file format.  Then we format a replacement
        // string which is exactly the same size (this could error out).
        swprintf(m_Ver.m_rcToVer, L"%d.%d.%d.%d", 
                m_Ver.m_VerStamp.m_MajorVersion, m_Ver.m_VerStamp.m_MinorVersion, 
                m_Ver.m_VerStamp.m_BuildNumber, m_Ver.m_VerStamp.m_RevisionNumber);
        wcstombs(m_Ver.m_rcAnsiToVer, m_Ver.m_rcToVer, MAXVER);
        wcstombs(m_Ver.m_rcAnsiFromVer, m_Ver.m_szFromVersion, MAXVER);
        
        int ilen = strlen(m_Ver.m_rcAnsiFromVer);
        int ilen2 = strlen(m_Ver.m_rcAnsiToVer);
        if (ilen2 > ilen)
        {
            PrintError(L"New string value %s is bigger than existing %s.\n"
                       L"Please update the source version to accomodate bigger buffer update.\n",
                       m_Ver.m_szFromVersion, m_Ver.m_rcToVer);
            return E_FAIL;
        }
        // pad out to full length as required.
        else if (ilen2 < ilen)
        {
            char *str = &m_Ver.m_rcAnsiToVer[ilen2];
            wchar_t *strw = &m_Ver.m_rcToVer[ilen2];
            for ( ;  ilen2 < ilen;  ilen2++)
            {
                *str++ = ' ';
                *strw++ = L' ';
            }
            *str = 0;
            *strw = 0;
        }

        m_Ver.m_cChars = ilen;

        Printf(L"  Replacing %s with %s in all custom attributes and user strings\n",
               m_Ver.m_szFromVersion, m_Ver.m_rcToVer);

        for (i=0;  i<m_pefiles.Count();  i++)
        {
            // Update the assembly def table as required.
            PeFile *p = *m_pefiles.Get(i);
            Printf(L"  %s\n", p->m_szFile);
            hr = p->UpdateCA(m_Ver);
            IfFailGo(hr);
        }

    ErrExit:
        return hr;
    }

    unsigned BindAllFiles()
    {
        int         i;
        unsigned    hr;
        
        Printf(L"\nStamping Assembly Refs:\n");
        
        for (i=0;  i<m_pefiles.Count();  i++)
        {
            // Update the assembly def table as required.
            PeFile *p = *m_pefiles.Get(i);
            Printf(L"  %s\n", p->m_szFile);
            hr = p->UpdateAssemblyRefs(m_bStampNoDef ? &m_Ver.m_FromVerStamp : NULL);
            IfFailGo(hr);
        }

    ErrExit:
        return 0;
    }


    unsigned UpdateAllFileRefs()
    {
        int         i;
        unsigned    hr;
        
        Printf(L"\nStamping File Refs:\n");
        
        for (i=0;  i<m_pefiles.Count();  i++)
        {
            // Update the assembly def table as required.
            PeFile *p = *m_pefiles.Get(i);
            Printf(L"  %s\n", p->m_szFile);
            hr = p->UpdateFileRefs();
            IfFailGo(hr);
        }

    ErrExit:
        return 0;
    }


    virtual unsigned ResolveAssemblyRef(const char *szName, VERSIONSTAMP &newVer)
    {
        int         i;
        for (i=0;  i<m_pefiles.Count();  i++)
        {
            PeFile &pe = *m_pefiles[i];

            if (!pe.m_szAssemblyName)
            {
                HRESULT hr;
                hr = pe.GetAssemblyDefData();
                if (FAILED(hr))
                    return hr;
            }

            if (pe.m_szAssemblyName && strcmp(pe.m_szAssemblyName, szName) == 0)
            {
                newVer = m_Ver.m_VerStamp;
                return S_OK;
            }
        }
        return S_FALSE;
    }

    virtual unsigned ResolveFileRef(const char *szName, BYTE *pbHash, ULONG cbHashMax)
    {
        wchar_t     rcName[_MAX_PATH];
        int         i;

        mbstowcs(rcName, szName, NumItems(rcName));

        for (i=0;  i<m_pefiles.Count();  i++)
        {
            PeFile &pe = *m_pefiles[i];

            if (_wcsicmp(pe.m_szShortName, rcName) == 0)
            {
                HRESULT hr;
                hr = pe.GetHashOfFile(pbHash, cbHashMax);
                return hr;
            }
        }
        return S_FALSE;
    }

    
    unsigned ParseVersion(wchar_t *szFrom, VERSIONSTAMP &to)
    {
        if (!szFrom || !*szFrom)
            return (unsigned) -1;

        wchar_t rcVer[64];
        wcsncpy(rcVer, szFrom, NumItems(rcVer));

        wchar_t *sz = rcVer;
        to.m_MajorVersion = ConvertVerItem(sz);
        to.m_MinorVersion = ConvertVerItem(sz);
        to.m_BuildNumber = ConvertVerItem(sz);
        to.m_RevisionNumber = ConvertVerItem(sz);
        return 0;
    }

    void PrintLogo()
    {
        Printf(L"Microsoft (R) .Net Frameworks Runtime Version Stamp Utility   %S\n", VER_FILEVERSION_STR);
        Printf(VER_LEGALCOPYRIGHT_DOS_STR);
        Printf(L"\n");
    }

    unsigned Usage()
    {
        Printf(L"verstamp.exe [options] files\n");
        Printf(L"  /?                   Shows this help.\n");
        Printf(L"  /stamp               Stamp target files with version information.\n");
        Printf(L"  /stampNoDef          Same as /stamp, but do not change Assembly definition.\n");
        Printf(L"  /bind                Bind references to imported assemblies.\n");
        Printf(L"  /version:val         New version string (xx.yy.bbbb.mm).\n");
        Printf(L"  /replace:val         Replace blobs and strings of this value (xx.yy.bbbb.mm).\n");
        Printf(L"\n");
        return (unsigned) -1;
    }

    USHORT ConvertVerItem(wchar_t *&sz)
    {
        wchar_t *szError;
        wchar_t *p=sz;
        if (!*p)
            return (USHORT) -1;
        while (*sz != 0 && *sz != L'.')
            sz++;
        *sz = 0;
        ++sz;
        return ((USHORT) (wcstoul(p, &szError, 10) & 0xFFFF));
    }

};


extern "C" int _cdecl wmain(int argc, wchar_t *argv[])
{
    HRESULT     hr;
    unsigned    Rtn;

    OnUnicodeSystem();
    hr = CoInitialize(0);
    
    hr = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, 
                  IID_IMetaDataDispenserEx, (void **) &g_pDisp);
    if (FAILED(hr))
    {
        PrintError(L"Failed to create meta data dispenser (%08x)\n", hr);
        Rtn = hr;
    }
    else
    {
        Command c;
        Rtn = c.Run(argc, argv);
    }

    if (g_pDisp)
        g_pDisp->Release();

    CoUninitialize();
    return Rtn;
}





//*****************************************************************************
//
//**********  Helper Functions **********
//
//*****************************************************************************


PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders,
                                               IN PVOID Base,
                                               IN ULONG Rva)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;
        
        ++NtSection;
    }

    return NULL;
}


PVOID Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders,
                          IN PVOID Base,
                          IN ULONG Rva)
{
    PIMAGE_SECTION_HEADER NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                                               Base,
                                                               Rva);

    if (NtSection != NULL) {
        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData);
    }
    else
        return NULL;
}

IMAGE_COR20_HEADER * getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT) 
{
    PIMAGE_SECTION_HEADER pSectionHeader;
    
    // Get the image header from the image, then get the directory location
    // of the COM+ header which may or may not be filled out.
    pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pNT, hMod, 
                   pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);
    
    return (IMAGE_COR20_HEADER *) pSectionHeader;
}


IMAGE_NT_HEADERS * FindNTHeader(PBYTE pbMapAddress)
{
    IMAGE_DOS_HEADER   *pDosHeader;
    IMAGE_NT_HEADERS   *pNT;

    pDosHeader = (IMAGE_DOS_HEADER *) pbMapAddress;

    if ((pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) &&
        (pDosHeader->e_lfanew != 0))
    {
        pNT = (IMAGE_NT_HEADERS*) (pDosHeader->e_lfanew + (DWORD) pDosHeader);

        if ((pNT->Signature != IMAGE_NT_SIGNATURE) ||
            (pNT->FileHeader.SizeOfOptionalHeader != 
             IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
            (pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)) {
            return NULL;
        }
    }
    else {
        return NULL;
    }

    return pNT;
}



int DumpStringToHandle(const wchar_t *szString, HANDLE hOutput, WORD wcolor = -1)
{
    CONSOLE_SCREEN_BUFFER_INFO con;
    if (wcolor != (WORD) -1)
    {
        GetConsoleScreenBufferInfo(hOutput, &con);
        SetConsoleTextAttribute(hOutput, wcolor);
    }
    
    ULONG cb;
    int iLen = wcslen(szString);
    char *rcMsg = new char[(iLen + 1) * 2];
    if (!rcMsg)
        return -1;
    *rcMsg = 0;
    iLen = wcstombs(rcMsg, szString, (iLen + 1) * 2);
    const char *sz;
    for (sz=rcMsg;  *sz;  )
    {
        const char *szcrlf = strchr(sz, '\n');
        if (!szcrlf)
            szcrlf = sz + strlen(sz);
        WriteFile(hOutput, sz, szcrlf - sz, &cb, 0);
        sz = szcrlf;
        if (*sz == '\n')
        {
            WriteFile(hOutput, "\r\n", 2, &cb, 0);
            ++sz;
        }
    }
    delete [] rcMsg;
    if (wcolor != (WORD) -1) 
        SetConsoleTextAttribute(hOutput, con.wAttributes);
    return (iLen);
}


int __cdecl Printf(const wchar_t *szFmt, ...)
{
    static HANDLE hOutput = INVALID_HANDLE_VALUE;
    va_list     marker;                 // User text.
    WCHAR       rcMsgw[1024];           // Buffer for format.

    // Get standard output handle.
    if (hOutput == INVALID_HANDLE_VALUE)
    {
        hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        if (hOutput == INVALID_HANDLE_VALUE)
            return (-1);
    }

    // Format the error.
    va_start(marker, szFmt);
    _vsnwprintf(rcMsgw, NumItems(rcMsgw), szFmt, marker);
    rcMsgw[NumItems(rcMsgw) - 1] = 0;
    va_end(marker);
    
    return DumpStringToHandle(rcMsgw, hOutput);
}


int __cdecl PrintError(const wchar_t * szFmt, ...)
{
    static HANDLE hOutput = INVALID_HANDLE_VALUE;
    va_list     marker;                 // User text.
    WCHAR       rcMsgw[1024];           // Buffer for format.

    // Get standard output handle.
    if (hOutput == INVALID_HANDLE_VALUE)
    {
        hOutput = GetStdHandle(STD_ERROR_HANDLE);
        if (hOutput == INVALID_HANDLE_VALUE)
            return (-1);
    }

    // Format the error.
    va_start(marker, szFmt);
    _vsnwprintf(rcMsgw, NumItems(rcMsgw), szFmt, marker);
    rcMsgw[NumItems(rcMsgw) - 1] = 0;
    va_end(marker);
    
    return DumpStringToHandle(rcMsgw, hOutput, 0xC);
}


int __cdecl PrintWarning(const wchar_t *szFmt, ...)
{
    static HANDLE hOutput = INVALID_HANDLE_VALUE;
    va_list     marker;                 // User text.
    WCHAR       rcMsgw[1024];           // Buffer for format.

    // Get standard output handle.
    if (hOutput == INVALID_HANDLE_VALUE)
    {
        hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        if (hOutput == INVALID_HANDLE_VALUE)
            return (-1);
    }

    // Format the error.
    va_start(marker, szFmt);
    _vsnwprintf(rcMsgw, NumItems(rcMsgw), szFmt, marker);
    rcMsgw[NumItems(rcMsgw) - 1] = 0;
    va_end(marker);
    
    return DumpStringToHandle(rcMsgw, hOutput, 0xE);
}


void PrintMDErrors()
{
    IErrorInfo *pErrInfo = 0;
    HRESULT hr;
    while ((hr = GetErrorInfo(0, &pErrInfo)) == S_OK)
    {
        BSTR desc;
        if (pErrInfo->GetDescription(&desc) == S_OK)
        {
            PrintError(L"  %s\n", desc);
            SysFreeString(desc);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\casinghelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CasingHelper
**
** Author: Jay Roxe
**
** Purpose: Provide locale-correct casing operations in a somewhat
**          efficient manner.  Designed to be used by native code
**          (type lookup, reflection, etc).
**
** Date: October 14, 1999
**
============================================================*/
#include "stdafx.h"
#include "UtilCode.h"

INT32 CasingHelper::InvariantToLower(LPUTF8 szOut, int cMaxBytes, LPCUTF8 szIn) {
    _ASSERTE(szOut);
    _ASSERTE(szIn);

    //Figure out the maximum number of bytes which we can copy without
    //running out of buffer.  If cMaxBytes is less than inLength, copy
    //one fewer chars so that we have room for the null at the end;
    int inLength = (int)(strlen(szIn)+1);
    int copyLen  = (inLength<=cMaxBytes)?inLength:(cMaxBytes-1);
    LPUTF8 szEnd;

    //Compute our end point.
    szEnd = szOut + copyLen;

    //Walk the string copying the characters.  Change the case on
    //any character between A-Z.
    for (; szOut<szEnd; szOut++, szIn++) {
        if (*szIn>='A' && *szIn<='Z') {
            *szOut = *szIn | 0x20;
        } else {
            *szOut = *szIn;
        }
    }

    //If we copied everything, tell them how many characters we copied, 
    //and arrange it so that the original position of the string + the returned
    //length gives us the position of the null (useful if we're appending).
    if (copyLen==inLength) {
        return copyLen-1;
    } else {
        *szOut=0;
        return -(inLength - copyLen);
    }
}

BOOL CasingHelper::IsLowerCase(LPCUTF8 szIn) {
    
    if (!szIn) {
        return TRUE;
    }

    for (;*szIn; szIn++) {
        if (*szIn>='A' && *szIn<='Z') {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\arraylist.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include "arraylist.h"

//
// ArrayList is a simple class which is used to contain a growable
// list of pointers, stored in chunks.  Modification is by appending
// only currently.  Access is by index (efficient if the number of
// elements stays small) and iteration (efficient in all cases).
// 
// An important property of an ArrayList is that the list remains
// coherent while it is being modified (appended to). This means that readers
// never need to lock when accessing it. (Locking is necessary among multiple
// writers, however.)
//

void ArrayList::Clear()
{
    ArrayListBlock *block = m_block.m_next;
    while (block != NULL)
    {
        ArrayListBlock *next = block->m_next;
        delete [] block;
        block = next;
    }
    m_block.m_next = 0;
    m_count = 0;
}

void **ArrayList::GetPtr(DWORD index)
{
    _ASSERTE(index < m_count);

    ArrayListBlock *b = &m_block;

    while (index >= b->m_blockSize)
    {
        _ASSERTE(b->m_next != NULL);
        index -= b->m_blockSize;
        b = b->m_next;
    }

    return b->m_array + index;
}


HRESULT ArrayList::Append(void *element)
{
    ArrayListBlock *b = &m_block;
    DWORD           count = m_count;

    while (count >= b->m_blockSize)
    {
        count -= b->m_blockSize;

        if (b->m_next == NULL)
        {
            _ASSERTE(count == 0);

            DWORD nextSize = b->m_blockSize * 2;

            ArrayListBlock *bNew = (ArrayListBlock *) 
              new BYTE [sizeof(ArrayListBlock) + nextSize * sizeof(void*)];

            if (bNew == NULL)
                return E_OUTOFMEMORY;

            bNew->m_next = NULL;
            bNew->m_blockSize = nextSize;

            b->m_next = bNew;
        }

        b = b->m_next;
    }

    b->m_array[count] = element;

    m_count++;

    return S_OK;
}

DWORD ArrayList::FindElement(DWORD start, void *element)
{
    DWORD index = start;

    _ASSERTE(index < m_count);

    ArrayListBlock *b = &m_block;

    //
    // Skip to the block containing start.
    // index should be the index of start in the block.
    //

    while (index >= b->m_blockSize)
    {
        _ASSERTE(b->m_next != NULL);
        index -= b->m_blockSize;
        b = b->m_next;
    }

    //
    // Adjust start to be the index of the start of the block
    //

    start -= index;

    //
    // Compute max number of entries from the start of the block
    //
    
    DWORD max = m_count - start;

    while (b != NULL)
    {
        //
        // Compute end of search in this block - either end of the block
        // or end of the array
        //

        DWORD blockMax;
        if (max < b->m_blockSize)
            blockMax = max;
        else
            blockMax = b->m_blockSize;

        //
        // Scan for element, until the end.
        //

        while (index < blockMax)
        {
            if (b->m_array[index] == element)
                return start + index;
            index++;
        }

        //
        // Otherwise, increment block start index, decrement max count,
        // reset index, and go to the next block (if any)
        //

        start += b->m_blockSize;
        max -= b->m_blockSize;
        index = 0;
        b = b->m_next;
    }

    return NOT_FOUND;
}

BOOL ArrayList::Iterator::Next()
{
    ++m_index;

    if (m_index >= m_remaining)
        return FALSE;

    if (m_index >= m_block->m_blockSize)
    {
        m_remaining -= m_block->m_blockSize;
        m_index -= m_block->m_blockSize;
        m_total += m_block->m_blockSize;
        m_block = m_block->m_next;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\completepath.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
* CompletePathA.c - Takes a relative path name and an absolute path name 
*                   and combines them into a single path. This routine
*                   is used to combine relative filenames with a path.
*
*
*******************************************************************************/
#include "stdafx.h"
#include "WinWrap.h"


#define PATHSEPARATOR '\\'
#define PATHSEPARATORSTR "\\"

static HRESULT RemoveDotsA(LPSTR   szSpec);    /* The spec to remove dots from     */
static void    StripSlashA(LPSTR   szSpec);
static HRESULT ParsePathA(LPCSTR              szPath,             //@parm  Path name to separate
                          LPSTR               szVol,              //@parm  [out] Volume name
                          LPSTR               szDir,              //@parm  [out] Directory name
                          LPSTR               szFname);           //@parm  [Out] Filename
static HRESULT AppendPathA(LPSTR               szPath,             //@parm [out] completed pathname
                           LPCSTR              szDir,              //@parm Volume + Directory name
                           LPCSTR              szFname);           //@parm File name

/*******************************************************************************
********************************************************************************

    MEMBER FUNCTION

        @mfunc      MSFS::CompletePath
        @comm       Build full path from relative path
    
********************************************************************************
*******************************************************************************/

extern "C" HRESULT CompletePathA(         
    LPSTR               szPath,             //@parm  [out] Full Path name   (Must be MAX_PATH in size)
    LPCSTR              szRelPath,          //@parm  Relative Path name
    LPCSTR              szAbsPath           //@parm  Absolute Path name portion (NULL uses current path)
    )
{

    LPSTR   szFile;

    int             iStat;

    // If the spec, starts with PathSeparator, it is by definition complete.
    if (szRelPath[0] == PATHSEPARATOR && szRelPath[1] == PATHSEPARATOR) {
        strcpy(szPath, szRelPath);
        return (S_OK);
    }

    // Get the drive letter.
    if (strchr(szRelPath,':') == NULL) {
        // No drive was specified.
        if (szAbsPath == NULL) {
            GetFullPathNameA(szRelPath, MAX_PATH, szPath, &szFile);
            RemoveDotsA(szPath);
            return S_OK;
        }
        else { // An absolute path was specified.
            // Check if the relative path is relative to '\\'
            if (*szRelPath == PATHSEPARATOR) {
                ParsePathA(szAbsPath,szPath,NULL,NULL);
                strcat(szPath,szRelPath);
            }
            else {
                if ((iStat = AppendPathA(szPath,szAbsPath,szRelPath)) < 0)
                    return (iStat);
            }
            RemoveDotsA (szPath);
            return S_OK;
        }
    }
    else {
        GetFullPathNameA(szRelPath, MAX_PATH, szPath, &szFile);
        RemoveDotsA (szPath);
        return S_OK;
    }

}



/***************************************************************************/
/* Removes all ".", "..", "...",                                           */
/* and so on occurances from an FS spec.  It assumes that the spec is      */
/* already otherwise cleaned and completed; if it isn't, caveat emptor.    */
/***************************************************************************/
HRESULT RemoveDotsA(                      /* Return status                    */
                   LPSTR       szSpec    /* The spec to remove dots from     */
                   )
{
    int         riEntries [64];            /* Where individual entries are     */
    int         n;
    int         i;

    /* We treat the path as a series of fields separated by /'s.  We start at  */
    /* the left, skipping the drive, and traverse through char by char.        */
    /* We store the string position of the first character of each field in    */
    /* riEntries as we come to them.  If we find a field that consists of      */
    /* nothing but .'s, we treat it as a Novell-style parent-directory         */
    /* reference.  If we encounter a string of more dots than we have fields,  */
    /* we return ERS_FILE_BADNAME, otherwise blat the remaining part of the    */
    /* string at the location of the field that the .'s point to and adjust    */
    /* the number of fields we think we have accordingly.  Note that it's      */
    /* possible to end up with a \ on the end of the string when we're done,   */
    /* so if it's there we knock it off.                                       */
    
    /* Nuke the c:\ and initialize the field-beginning array */
    n = 0;
    riEntries[i=0] = 0;
    if(strchr(szSpec, ':'))
        szSpec += 3;
    
    /* Loop until we hit the end of the string */
    /* @todo: The first expression will read the byte after the terminator 
       on the last time through the loop.  If the string itself was precisely
       located on the end of a page, it would crash (admittedly rare). */
    while (szSpec[riEntries[i]] && (riEntries[i] == 0 || szSpec[riEntries[i] - 1])) {
        /* Count up how many dots there are at the beginning of the field */
        while (szSpec[riEntries[i] + n] == '.') n++;
        /* If it's the end, the field was all dots, so we back up the appropriate */
        /* number of fields and blat the rest of the string.                      */
        if (szSpec[riEntries[i] + n] == PATHSEPARATOR || szSpec[riEntries[i] + n] == 0) {
            riEntries[i+1] = n + riEntries[i] + (szSpec[riEntries[i] + n] == PATHSEPARATOR);
            i++;
            if (n > i) return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            strncpy (szSpec + riEntries[i-n], szSpec + riEntries[i],
                     strlen(szSpec + riEntries[i]) + 1);
            i -= n;
        }
        else {
            /* Otherwise it's just a filename, so we go on the the next field. */
            while (szSpec[riEntries[i] + n] && szSpec[riEntries[i] + n] != PATHSEPARATOR) n += 1;
            if (i >= (sizeof (riEntries)/sizeof(int))-1) {
                memcpy ((char *) (riEntries+1), (char *) riEntries, sizeof(riEntries)-sizeof(int));
                --i;
            }
            riEntries[i+1] = n + riEntries[i] + 1;
            i++;
        }
        n = 0;
    }
    
    /* Make sure there's not a \ hanging on the end. */
    StripSlashA (szSpec);
    return (S_OK);
}

/*******************************************************************************
********************************************************************************

    MEMBER FUNCTION

    @mfunc      StripSlash

    @rdesc      

    @comm       Strip the trailing slash or backslash off a spec, but leaves
                it in place if the spec has the form "c:\".
    
********************************************************************************
*******************************************************************************/
void StripSlashA(
                LPSTR   szSpec
                )
{
    char        *pcPtr;                    /* Used to scan for trailing slash. */
    
    /* Empty string, of course means no. */
    if (*szSpec == '\0') return;

    /* Start at the end and work back. */
    pcPtr = szSpec + strlen(szSpec);

    /* Hack off the last char if it is a / or \ unless the spec has the form "c:\" */
    --pcPtr;
    if ((*pcPtr == '/' || *pcPtr == '\\') && !(--pcPtr && *pcPtr == ':' && pcPtr == szSpec+1)) {
        pcPtr++;
        *pcPtr = '\0';
    }
}


/*******************************************************************************
********************************************************************************

    MEMBER FUNCTION

    @mfunc      ParsePath

    @comm       Separate pathname into Volume, Directory, Filename
    
********************************************************************************
*******************************************************************************/

HRESULT ParsePathA(            
    LPCSTR              szPath,             //@parm  Path name to separate
    LPSTR               szVol,              //@parm  [out] Volume name
    LPSTR               szDir,              //@parm  [out] Directory name
    LPSTR               szFname             //@parm  [Out] Filename
    )
{
    if((szPath == NULL) ||
       ((szVol == NULL) && (szDir == NULL) && (szFname == NULL)))
        return E_INVALIDARG;

    const char *szSavedPath = szPath;
    int     iVolSegs = 2;
    char    rcPath[MAX_PATH];

    if (szVol != NULL) {
        *szVol = '\0';
    }
    // Check for UNC syntax.
    if (*szPath == '\\' && *(szPath+1) == '\\') {
        szPath += 2;
        while (*szPath != '\0' && (*szPath != '\\' || --iVolSegs > 0))
            szPath++;
        if (szVol != NULL)
            strncpy(szVol, szSavedPath, (int) (szPath - szSavedPath));
    }
    else {
        // Check for a drive letter.
        szPath++;
        if (*szPath == ':') {
            if (szVol != NULL) {
                *szVol++ = *szSavedPath;
                *szVol++ = *szPath++;
                *szVol = '\0';
            }
            else
                ++szPath;
        }
        else {
            szPath = szSavedPath;
        }
    }
    
    // Handle the path & filename.
    strcpy(rcPath, szPath);
    StripSlashA (rcPath);
    char* pSeparator = strrchr(rcPath, PATHSEPARATOR);
    if (szDir != NULL) {
        if (pSeparator == NULL)
            *szDir = '\0';
        else if (pSeparator == rcPath)
            strcpy(szDir, PATHSEPARATORSTR);
        else {
            // Don't allow an overflow
            if ((pSeparator - rcPath) > MAX_PATH)
                return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            
            strncpy(szDir, rcPath, (pSeparator - rcPath));
        }
    }
    if (szFname != NULL)
        strcpy(szFname, rcPath + (pSeparator - pSeparator) + 1);
    return S_OK;
    
}

/*******************************************************************************
********************************************************************************

    MEMBER FUNCTION

    @mfunc      AppendPath

    @comm       Complete path from Dir + Path
    
********************************************************************************
*******************************************************************************/

HRESULT AppendPathA(           
    LPSTR               szPath,             //@parm [out] completed pathname
    LPCSTR              szDir,              //@parm Volume + Directory name
    LPCSTR              szFname             //@parm File name
    )
{
    char    *pcSlash;
    int     iLen;

    if(szPath == NULL)
        return(E_INVALIDARG);

    if ((iLen = (int)strlen(szDir)) >= MAX_PATH)
       return (HRESULT_FROM_WIN32(ERROR_INVALID_NAME));

    if (szPath != szDir) {                               // Not appending to existing szDir name
        if ((szDir != NULL) &&                           // and we have a szDir name
            iLen != 0)                                   // and szDir is not empty
            strcpy(szPath,szDir);                        // Replace szPath with szDir name
        else
            *szPath = '\0';
    }
    if(szFname != NULL && szFname[0] != '\0')  {        // We have a filename parameter
        if (*szPath != '\0') {
            // Put a directory seperator on the end.
            pcSlash = szPath + iLen;
            --pcSlash;
            if (*pcSlash != PATHSEPARATOR) {
                *++pcSlash = PATHSEPARATOR;
                *++pcSlash = '\0';
                ++iLen;
            }
        }
        if (iLen + strlen(szFname) > MAX_PATH)
           return (HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
        strcat(szPath,szFname);                  // Add filename on
    }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\assemblyfilehash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include <stdlib.h>
#include "UtilCode.h"
#include "imagehlp.h"
#include "AssemblyFileHash.h"

#define IMAGEHLPDLL L"imagehlp.dll"
#define IMAGEHLPFUNCNAME "ImageGetDigestStream"

typedef BOOL (WINAPI *IMAGEHLPFUNC)( HANDLE FileHandle, DWORD DigestLevel, DIGEST_FUNCTION DigestFunction, DIGEST_HANDLE DigestHandle );


BOOLEAN WINAPI DigestCallback(void           *pCtx,
                              BYTE           *pData,
                              DWORD           dwLength)
{
    // All this function does is make a linked list of all the blocks of data
    // and total up the size.

    DigestContext* context = (DigestContext*)pCtx;

    context->cbTotalData += dwLength;

    DigestBlock* block = new DigestBlock( pData, dwLength, context->pHead ); 

    // If we can't create the block, just terminate.

    if (block == NULL)
        return FALSE;

    context->pHead = block;

    return TRUE;
}


HRESULT AssemblyFileHash::GenerateDigest()
{
    IMAGEHLPFUNC lpImageGetDigestStream;
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HMODULE hModule = NULL;

    hFile = WszCreateFile(m_FileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto CLEANUP;
    
    // Now that we have the PEFile struct, we need to grab the bits out of it
    // and copy them into a managed array that we can pass back out for
    // a hash algorithm to use.

    // Load the library, bind the function, and call it.

    hModule = LoadImageHlp ();
        
    if (hModule == NULL)
        goto CLEANUP;
        
    lpImageGetDigestStream = (IMAGEHLPFUNC)GetProcAddress( hModule, IMAGEHLPFUNCNAME );
        
    if (lpImageGetDigestStream == NULL)
        goto CLEANUP;

    if (!lpImageGetDigestStream(hFile,
                                CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO,
                                (DIGEST_FUNCTION)DigestCallback,
                                (DIGEST_HANDLE)&m_Context))
        goto CLEANUP;
        

    if (m_Context.cbTotalData == 0 || m_Context.pHead == NULL)
        goto CLEANUP;

#if TRUE
    // Note: this shouldn't make a difference since we consistently reverse the list.
    // We need to reverse the list due to the way in which the DigestCallback function
    // builds it.

    {
        DigestBlock* prev = m_Context.pHead;
        m_Context.pHead = m_Context.pHead->pNext;
        prev->pNext = NULL;

        if (m_Context.pHead != NULL)
        {
            DigestBlock* next = m_Context.pHead->pNext;

            for (;;)
            {
                m_Context.pHead->pNext = prev;

                if (next == NULL)
                {
                    break;
                }
                else
                {
                    prev = m_Context.pHead;
                    m_Context.pHead = next;
                    next = m_Context.pHead->pNext;
                }
            }
        }
    }
#endif
    
 CLEANUP:
    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle( hFile );
    if(hModule != NULL)
        FreeLibrary( hModule );

    return hr;
}


HRESULT AssemblyFileHash::CopyData(PBYTE memLoc, DWORD cbData)
{
    if(cbData != m_Context.cbTotalData)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    DigestBlock* block = m_Context.pHead;

    while (block != NULL)
    {

        memcpy( memLoc, block->pData, 
                block->cbData );
        
        memLoc += block ->cbData;
        
        block = block->pNext;
        
    }
    return S_OK;
}



HRESULT AssemblyFileHash::HashData(HCRYPTHASH hHash)
{
    DigestBlock* pCurr=m_Context.pHead;
    while ( pCurr!= NULL)
    {
        if(!CryptHashData(hHash, pCurr->pData, pCurr->cbData, 0))
            return HRESULT_FROM_WIN32(GetLastError());

        pCurr = pCurr->pNext;
    }
    return S_OK;
}



HRESULT AssemblyFileHash::CalculateHash(DWORD algid)
{
    HRESULT hr = S_OK;
    HCRYPTPROV pProvider = NULL;
    HCRYPTHASH hHash = NULL;

    if(!WszCryptAcquireContext(&pProvider,
                               NULL,
                               NULL,
                               //PROV_RSA_SIG,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT))
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    
    if(!CryptCreateHash(pProvider,
                        algid,
                        0,
                        0,
                        &hHash))
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    IfFailGo(HashData(hHash));

    DWORD count = sizeof(m_cbHash);
    if(!CryptGetHashParam(hHash, 
                          HP_HASHSIZE,
                          (PBYTE) &m_cbHash,
                          &count,
                          0))
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));
        
    if(m_cbHash > 0) {
        m_pbHash = new BYTE[m_cbHash];
        if(!CryptGetHashParam(hHash, 
                              HP_HASHVAL,
                              m_pbHash,
                              &m_cbHash,
                              0))
            IfFailGo(HRESULT_FROM_WIN32(GetLastError()));
    }

 ErrExit:

    if(hHash) 
        CryptDestroyHash(hHash);
    if(pProvider)
        CryptReleaseContext(pProvider, 0);
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\dbgalloc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//
// DbgAlloc.cpp
//
//  Routines layered on top of allocation primitives to provide debugging
//  support.
//

#include "stdafx.h"
#include "ImageHlp.h"
#include "UtilCode.h"
#include "DbgAlloc.h"
#define LOGGING
#include "Log.h"
#include "clrnt.h"

extern "C" long __cdecl _CrtSetBreakAlloc( long lBreakAlloc );
extern "C" _CRTIMP int __cdecl _flushall(void);

#ifdef _DEBUG


// We used a zero sized array, disable the non-standard extension warning.
#pragma warning(push)
#pragma warning(disable:4200)


// Various patterns written into packet headers and bodies.
#define MAX_CLASSNAME_LENGTH    1024
#define CDA_ALLOC_PATTERN   0xaa        // Pattern to fill newly allocated packets with
#define CDA_DEALLOC_PATTERN 0xdd        // Pattern to fill deallocated packets with
#define CDA_GUARD_PATTERN   0xff        // Guard pattern written after user data
#define CDA_MAGIC_1         0x12345678  // Special tag value at start of alloc header
#define CDA_MAGIC_2         0x87654321  // Special tag value at end of alloc header
#define CDA_INV_PATTERN     0xeeeeeeee  // Used to overwrite tag values of deallocation


// Number of guard bytes allocated after user data.
#define CDA_GUARD_BYTES     16
#define CDA_OPT_GUARD_BYTES (g_AllocGuard ? CDA_GUARD_BYTES : 0)


// Number of entries in a table of the top allocators (by allocation operations)
// that are shown when statistics are reported. This is not the same as the
// number of entries in the table itself (which is dynamically sized and
// unbounded).
#define CDA_TOP_ALLOCATORS  10


// An entry in the top allocators table.
struct DbgAllocTop {
    void           *m_EIP;              // Allocator's EIP
    unsigned        m_Count;            // Number of allocations made so far
    __int64         m_TotalBytes;       // Cumulative total of bytes allocated
};


// Allocation header prepended to allocated memory. This structure varies in
// size (due to allocator/deallocator call stack information that is sized at
// initialization time).
struct DbgAllocHeader {
    unsigned        m_Magic1;           // Tag value used to check for corruption
    unsigned        m_SN;               // Sequence number assigned at allocation time
    unsigned        m_Length;           // Length of user data in packet
    DbgAllocHeader *m_Next;             // Next packet in chain of live allocations
    DbgAllocHeader *m_Prev;             // Previous packet in chain of live allocations
    HMODULE         m_hmod;             // hmod of allocator
    void           *m_AllocStack[1];    // Call stack of allocator
    void           *m_DeallocStack[1];  // Call stack of deallocator
    unsigned        m_Magic2;           // Tag value used to check for corruption
    char            m_Data[];           // Start of user data
};

// Macros to aid in locating fields in/after the variably sized section.
#define CDA_ALLOC_STACK(_h, _n) ((_h)->m_AllocStack[_n])
#define CDA_DEALLOC_STACK(_h, _n) CDA_ALLOC_STACK((_h), g_CallStackDepth + (_n))
#define CDA_MAGIC2(_h) ((unsigned*)&CDA_DEALLOC_STACK(_h, g_CallStackDepth))
#define CDA_DATA(_h, _n)(((char *)(CDA_MAGIC2(_h) + 1))[_n])
#define CDA_HEADER_TO_DATA(_h) (&CDA_DATA(_h, 0))
#define CDA_DATA_TO_HEADER(_d) ((DbgAllocHeader *)((char *)(_d) - CDA_HEADER_TO_DATA((DbgAllocHeader*)0)))
#define CDA_SIZEOF_HEADER() ((unsigned)CDA_HEADER_TO_DATA((DbgAllocHeader*)0))


// Various global allocation statistics.
struct DbgAllocStats {
    __int64         m_Allocs;           // Number of calls to DbgAlloc
    __int64         m_AllocFailures;    // Number of above calls that failed
    __int64         m_ZeroAllocs;       // Number of above calls that asked for zero bytes
    __int64         m_Frees;            // Number of calls to DbgFree
    __int64         m_NullFrees;        // Number of above calls that passed a NULL pointer
    __int64         m_AllocBytes;       // Total number of bytes ever allocated
    __int64         m_FreeBytes;        // Total number of bytes ever freed
    __int64         m_MaxAlloc;         // Largest number of bytes ever allocated simultaneously
};


// Function pointer types for routines in IMAGEHLP.DLL that we late bind to.
typedef bool (__stdcall * SYMPROC_INIT)(HANDLE, LPSTR, BOOL);
typedef bool (__stdcall * SYMPROC_CLEAN)(HANDLE);
typedef bool (__stdcall * SYMPROC_GETSYM)(HANDLE, DWORD, PDWORD, LPVOID);
typedef BOOL (__stdcall * SYMPROC_GETLINE)(HANDLE, DWORD, PDWORD, LPVOID);
typedef DWORD (__stdcall *SYMPROC_SETOPTION)(DWORD);

// Global debugging cells.
bool                g_HeapInitialized = false;
LONG                g_HeapInitializing = 0;
CRITICAL_SECTION    g_AllocMutex;
DbgAllocStats       g_AllocStats;
unsigned            g_NextSN;
DbgAllocHeader     *g_AllocListFirst;
DbgAllocHeader     *g_AllocListLast;
DbgAllocHeader    **g_AllocFreeQueue;       // Don't free memory right away, to allow poisoning to work
unsigned            g_FreeQueueSize;
unsigned            g_AllocFreeQueueCur;
bool                g_SymbolsInitialized;
static HANDLE       g_SymProcessHandle;
HMODULE             g_LibraryHandle;
SYMPROC_INIT        g_SymInitialize;
SYMPROC_CLEAN       g_SymCleanup;
SYMPROC_GETSYM      g_SymGetSymFromAddr;
SYMPROC_GETLINE     g_SymGetLineFromAddr;
static DWORD_PTR    g_ModuleBase = 0;
static DWORD_PTR    g_ModuleTop = 0;
HANDLE              g_HeapHandle;
unsigned            g_PageSize;
DbgAllocTop        *g_TopAllocators;
unsigned            g_TopAllocatorsSlots;
bool                g_DbgEnabled;
bool                g_ConstantRecheck;
bool                g_PoisonPackets;
bool                g_AllocGuard;
bool                g_LogDist;
bool                g_LogStats;
bool                g_DetectLeaks;
bool                g_AssertOnLeaks;
bool                g_BreakOnAlloc;
unsigned            g_BreakOnAllocNumber;
bool                g_UsePrivateHeap;
bool                g_ValidateHeap;
bool                g_PagePerAlloc;
bool                g_UsageByAllocator;
bool                g_DisplayLockInfo;
unsigned            g_CallStackDepth;
HINSTANCE           g_hThisModule;

// Macros to manipulate stats (these are all called with a mutex held).
#define CDA_STATS_CLEAR() memset(&g_AllocStats, 0, sizeof(g_AllocStats))
#define CDA_STATS_INC(_stat) g_AllocStats.m_##_stat++
#define CDA_STATS_ADD(_stat, _n) g_AllocStats.m_##_stat += (_n)


// Mutex macros.
#define CDA_LOCK()      EnterCriticalSection(&g_AllocMutex)
#define CDA_UNLOCK() LeaveCriticalSection(&g_AllocMutex);


// Forward routines.
void DbgAllocInit();


// The number and size range of allocation size distribution buckets we keep.
#define CDA_DIST_BUCKETS        16
#define CDA_DIST_BUCKET_SIZE    16
#define CDA_MAX_DIST_SIZE       ((CDA_DIST_BUCKETS * CDA_DIST_BUCKET_SIZE) - 1)

// Variables and routines to count lock locking
long    g_iLockCount=0;
long    g_iCrstBLCount=0;
long    g_iCrstELCount=0;

long    g_iCrstBULCount=0;
long    g_iCrstEULCount=0;

int     g_fNoMoreCount=0;

void DbgIncBCrstLock()
{
    if (!g_fNoMoreCount)
        InterlockedIncrement(&g_iCrstBLCount);
}

void DbgIncECrstLock()
{
    if (!g_fNoMoreCount)
        InterlockedIncrement(&g_iCrstELCount);
}

void DbgIncBCrstUnLock()
{
    if (!g_fNoMoreCount)
        InterlockedIncrement(&g_iCrstBULCount);
}

void DbgIncECrstUnLock()
{
    if (!g_fNoMoreCount)
        InterlockedIncrement(&g_iCrstEULCount);
}

// Note that since DbgIncLock & DbgDecLock can be called during a stack
// overflow, they must have very small stack usage; 
void DbgIncLock(char *info)
{
    if (!g_fNoMoreCount)
    {
        InterlockedIncrement(&g_iLockCount);
        if (g_DisplayLockInfo)
        {
            LOG((LF_LOCKS, LL_ALWAYS, "Open %s\n", info));
        }
    }
}// DbgIncLock

void DbgDecLock(char *info)
{
    if (!g_fNoMoreCount)
    {
        InterlockedDecrement(&g_iLockCount);
        _ASSERTE (g_iLockCount >= 0);
        if (g_DisplayLockInfo)
        {
            LOG((LF_LOCKS, LL_ALWAYS, "Close %s\n", info));
        }
    }
}// DbgDecLock

void LockLog(char* s)
{
    LOG((LF_LOCKS, LL_ALWAYS, "%s\n",s));
}// LockLog

#ifdef SHOULD_WE_CLEANUP
BOOL isThereOpenLocks()
{
    // Check to see that our lock count is accurate.
    // We can do this by checking to see if our lock count is decrementing properly.
    // There is a chunk of code like this in CRST.h....
    //
    // Increment PreLeaveLockCounter
    // LeaveCriticalSection()
    // Decrement Lock Counter
    // Increment PostLeaveLockCounter
    //
    // If we have open locks and the PreLeaveLockCounter and the PostLeaveLockCounter
    // are not equal, then there is a good probability that our lock counter is not accurate.
    // We know for a fact that the lock was closed (otherwise we would never hit the shutdown code)
    // So we'll rely on the PreLeaveLockCounter as the # of times we've closed this lock and
    // adjust our global lock counter accordingly.

    // There is one lock that's tolerable
    LOG((LF_LOCKS, LL_ALWAYS, "Starting to look at lockcount\n"));
    if (g_iLockCount>1)
    {
        int idiff = g_iCrstBULCount - g_iCrstEULCount;
        g_iLockCount-=idiff;
        if (idiff)
            LOG((LF_LOCKS, LL_ALWAYS, "Adjusting lock count... nums are %d and %d\n",g_iLockCount, idiff));

        // Make sure we don't adjust the global lock counter twice.
        g_iCrstBULCount=g_iCrstEULCount=0;
    }
    LOG((LF_LOCKS, LL_ALWAYS, "Done looking at lockcount\n"));

    return ((g_iLockCount>1) || (g_iLockCount < 0));
}// isThereOpenLocks
#endif /* SHOULD_WE_CLEANUP */


int GetNumLocks()
{
    return g_iLockCount;
}// GetNumLocks

// The buckets themselves (plus a variable to capture the number of allocations
// that wouldn't fit into the largest bucket).
unsigned g_AllocBuckets[CDA_DIST_BUCKETS];
unsigned g_LargeAllocs;


// Routine to check that an allocation header looks valid. Asserts on failure.
void DbgValidateHeader(DbgAllocHeader *h)
{
    _ASSERTE((h->m_Magic1 == CDA_MAGIC_1) &&
             (*CDA_MAGIC2(h) == CDA_MAGIC_2) &&
             ((unsigned)h->m_Next != CDA_INV_PATTERN) &&
             ((unsigned)h->m_Prev != CDA_INV_PATTERN));
    if (g_AllocGuard)
        for (unsigned i = 0; i < CDA_GUARD_BYTES; i++)
            _ASSERTE(CDA_DATA(h, h->m_Length + i) == (char)CDA_GUARD_PATTERN);
    if (g_ValidateHeap)
        _ASSERTE(HeapValidate(g_HeapHandle, 0, h));
}


// Routine to check all active packets to see if they still look valid.
// Optionally, also check that the non-NULL address passed does not lie within
// any of the currently allocated packets.
void DbgValidateActivePackets(void *Start, void *End)
{
    DbgAllocHeader *h = g_AllocListFirst;

    while (h) {
        DbgValidateHeader(h);
        if (Start) {
            void *head = (void *)h;
            void *tail = (void *)&CDA_DATA(h, h->m_Length + CDA_OPT_GUARD_BYTES);
            _ASSERTE((End <= head) || (Start >= tail));
        }
        h = h->m_Next;
    }

    if (g_ValidateHeap)
        _ASSERTE(HeapValidate(g_HeapHandle, 0, NULL));
}

//======================================================================
// This function returns true, if it can determine that the instruction pointer
// refers to a code address that belongs in the range of the given image.
inline BOOL
IsIPInModule(HINSTANCE hModule, BYTE *ip)
{
    __try {
        
        BYTE *pBase = (BYTE *)hModule;
        
        IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER *)pBase;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE ||
            pDOS->e_lfanew == 0) {
            __leave;
        }
        IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)(pBase + pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE ||
            pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER ||
            pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC
            ) 
        {
            __leave;
        }

        if (ip >= pBase && ip < pBase + pNT->OptionalHeader.SizeOfImage) 
        {
            return true;
        }
    
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return false;
}

#ifdef _X86_
#pragma warning (disable:4035)   // disable 4035 (function must return something)
#define PcTeb 0x18
_inline struct _TEB *NtCurrentTeb(void) { __asm mov eax, fs:[PcTeb]}
#pragma warning (default:4025)   // reenable it
#define NtCurrentPeb() ((PPEB)NtCurrentTeb()->ProcessEnvironmentBlock)
#endif

// Routine to retrieve caller's callstack. The output buffer is passed as an
// argument (we have a maximum number of frames we record, CDA_MAX_CALLSTACK).
#if defined(_X86_) && FPO != 1
void __stdcall DbgCallstackWorker(void **EBP, void **ppvCallstack)
{
    // Init subsystem if it's not already done.
    if (!g_HeapInitialized)
        DbgAllocInit();

    // Return immediately if debugging's not enabled.
    if (!g_DbgEnabled)
        return;

    // Fill in callstack output buffer (upto lesser of CDA_MAX_CALLSTACK and
    // g_CallStackDepth slots).
    unsigned maxSlots = min(CDA_MAX_CALLSTACK, g_CallStackDepth);
    void** stackBase = (void**)((struct _NT_TIB*)NtCurrentTeb())->StackBase;
    for (unsigned i = 0; i < maxSlots && EBP < stackBase; i++) {

        // Terminate early if we run out of frames.
        if (EBP == NULL)
            break;

        // Protect indirections through EBP in case we venture into non-EBP
        // frame territory.
        __try {

            // Fill in output slot with current frame's return address.
            ppvCallstack[i] = EBP[1];

            // Move to next frame.
            EBP = (void**)EBP[0];

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            // Terminate stack walk on error.
            break;

        }

        if (!IsIPInModule(g_hThisModule, (BYTE *)ppvCallstack[i]))
            break;
    }

    // If we found the end of the callstack before we ran out of output slots,
    // enter a sentry value of NULL.
    if (i != maxSlots)
        ppvCallstack[i] = NULL;
}

__declspec(naked) void __stdcall DbgCallstack(void **ppvCallstack)
{
#pragma warning(push)
#pragma warning(disable:4035)
    __asm {
        push    [esp+4]                 ; push output buffer addr as 2nd arg to worker routine
        push    ebp                     ; push EBP as 1st arg to worker routine
        call    DbgCallstackWorker      ; Call worker
        ret     4                       ; Return and pop argument
    };
#pragma warning(pop)
}
#else
static DWORD DummyGetIP()
{
    DWORD IP;
  local:
    __asm {
        lea eax, local;
        mov [IP], eax;
    }

    return IP;
}

void DbgInitSymbols();
#ifdef _X86_
static bool isRetAddr(size_t retAddr) 
{
    BYTE* spot = (BYTE*) retAddr;

        // call XXXXXXXX
    if (spot[-5] == 0xE8) {         
        return(true);
        }

        // call [XXXXXXXX]
    if (spot[-6] == 0xFF && (spot[-5] == 025))  {
        return(true);
        }

        // call [REG+XX]
    if (spot[-3] == 0xFF && (spot[-2] & ~7) == 0120 && (spot[-2] & 7) != 4) 
        return(true);
    if (spot[-4] == 0xFF && spot[-3] == 0124)       // call [ESP+XX]
        return(true);

        // call [REG+XXXX]
    if (spot[-6] == 0xFF && (spot[-5] & ~7) == 0220 && (spot[-5] & 7) != 4) 
        return(true);

    if (spot[-7] == 0xFF && spot[-6] == 0224)       // call [ESP+XXXX]
        return(true);

        // call [REG]
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0020 && (spot[-1] & 7) != 4 && (spot[-1] & 7) != 5)
        return(true);

        // call REG
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0320 && (spot[-1] & 7) != 4)
        return(true);

        // There are other cases, but I don't believe they are used.
    return(false);
}
#endif

void DbgCallstack(void **ppvCallstack)
{
#ifdef _X86_
    // Init subsystem if it's not already done.
    if (!g_HeapInitialized)
        DbgAllocInit();

    unsigned maxSlots = min(CDA_MAX_CALLSTACK, g_CallStackDepth);
    ppvCallstack[0] = NULL;
    if (maxSlots > 0 && g_ModuleBase > 0)
    {
        DWORD CurEsp;
        __asm mov [CurEsp], esp;

        CurEsp += 4;
        DWORD stackBase = (DWORD)((struct _NT_TIB*)NtCurrentTeb())->StackBase;
        unsigned i;
        for (i = 0; i < maxSlots && CurEsp < stackBase;) {
            if (CurEsp == (DWORD_PTR)ppvCallstack) {
                CurEsp += sizeof(PVOID) * CDA_MAX_CALLSTACK;
            }
            DWORD_PTR value = *(DWORD*)CurEsp;
            if (
                  // If it is a call instruction, likely it should be larger by offset 7.
                value > g_ModuleBase+7
                && value < g_ModuleTop && isRetAddr (value))
            {
                ppvCallstack[i] = (void*)value;
                i++;
            }
            CurEsp += 4;
        }
        if (i < maxSlots)
            ppvCallstack[i] = NULL;
    }      
#else
    ppvCallstack[0] = NULL;
#endif
}
#endif


// Routine to initialize access to debugging symbols.
void DbgInitSymbols()
{
    char        filename[256];
    HMODULE     hMod;
    char       *p;

    // Attempt to load IMAGHLP.DLL.
    if ((g_LibraryHandle = LoadLibraryA("imagehlp.dll")) == NULL)
        goto Error;

    // Try to find the entrypoints we need.
    g_SymInitialize = (SYMPROC_INIT)GetProcAddress(g_LibraryHandle, "SymInitialize");
    g_SymCleanup = (SYMPROC_CLEAN)GetProcAddress(g_LibraryHandle, "SymCleanup");
    g_SymGetSymFromAddr = (SYMPROC_GETSYM)GetProcAddress(g_LibraryHandle, "SymGetSymFromAddr");
    g_SymGetLineFromAddr = (SYMPROC_GETLINE)GetProcAddress(g_LibraryHandle, "SymGetLineFromAddr");
    
    if ((g_SymInitialize == NULL) ||
        (g_SymCleanup == NULL) ||
        (g_SymGetSymFromAddr == NULL) ||
        (g_SymGetLineFromAddr == NULL))
        goto Error;

    // Locate the full filename of the loaded MSCOREE.DLL.
    if ((hMod = GetModuleHandleA("mscoree.dll")) == NULL)
        goto Error;
    if (!GetModuleFileNameA(hMod, filename, sizeof(filename)))
        goto Error;

    // Strip the filename down to just the directory.
    p = filename + strlen(filename);
    while (p != filename)
        if (*p == '\\') {
            *p = '\0';
            break;
        } else
            p--;

    // Initialize IMAGEHLP.DLLs symbol handling. Use the directory where
    // MSCOREE.DLL was loaded from to initialize the symbol search path.
    if( !DuplicateHandle(GetCurrentProcess(), ::GetCurrentProcess(), GetCurrentProcess(), &g_SymProcessHandle,
                        0 /*ignored*/, FALSE /*inherit*/, DUPLICATE_SAME_ACCESS) )
        goto Error;
    if (!g_SymInitialize(g_SymProcessHandle, filename, TRUE))
        goto Error;

    SYMPROC_SETOPTION g_SymSetOptions = (SYMPROC_SETOPTION) GetProcAddress (g_LibraryHandle, "SymSetOptions");
    if (g_SymSetOptions) {
        g_SymSetOptions (SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);
    }
    g_SymbolsInitialized = true;

    return;

 Error:
    if (g_LibraryHandle)
        FreeLibrary(g_LibraryHandle);
}


// Called to free resources allocated by DbgInitSymbols.
void DbgUnloadSymbols()
{
    if (!g_SymbolsInitialized)
        return;

    // Get rid of symbols.
    g_SymCleanup(g_SymProcessHandle);
    CloseHandle (g_SymProcessHandle);

    // Unload IMAGEHLP.DLL.
    FreeLibrary(g_LibraryHandle);

    g_SymbolsInitialized = false;
}


// Transform an address into a string of the form '(symbol + offset)' if
// possible. Note that the string returned is statically allocated, so don't
// make a second call to this routine until you've finsihed with the results of
// this call.
char *DbgSymbolize(void *Address)
{
    static char         buffer[MAX_CLASSNAME_LENGTH + MAX_PATH + 40];    // allocate more space for offset, line number and  filename	
    CQuickBytes qb;
    DWORD               offset;
    IMAGEHLP_SYMBOL    *syminfo = (IMAGEHLP_SYMBOL *) qb.Alloc(sizeof(IMAGEHLP_SYMBOL) + MAX_CLASSNAME_LENGTH);
    IMAGEHLP_LINE      line;

    // Initialize symbol tables if not done so already.
    if (!g_SymbolsInitialized)
        DbgInitSymbols();

    // If still not initialized, we couldn't get IMAGEHLP.DLL to play ball.
    if (!g_SymbolsInitialized)
        return "(no symbols available)";

    syminfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    syminfo->MaxNameLength = MAX_CLASSNAME_LENGTH;

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE);

    // Ask IMAGEHLP.DLL to do the actual transformation.
    if (g_SymGetSymFromAddr(g_SymProcessHandle, (DWORD)Address, &offset, syminfo))
    {
        if (g_SymGetLineFromAddr(g_SymProcessHandle, (DWORD)Address, &offset, &line)) {
            _snprintf( buffer, sizeof(buffer) - 1, "(%s+0x%x [%s:%d])", syminfo->Name, 
                                    offset, line.FileName, line.LineNumber);        	
        }
        else {
            _snprintf( buffer, sizeof(buffer) - 1, "(%s+0x%x)", syminfo->Name, offset);
        }
        buffer[sizeof(buffer) -1] = '\0';
    }
    else
        sprintf(buffer, "(symbol not found, %u)", GetLastError());

    return buffer;
}


// We need our own registry reading function, since the standard one does an
// allocate and we read the registry during intialization, leading to a
// recursion.
DWORD DbgAllocReadRegistry(char *Name)
{
    DWORD   value;
    DWORD   type = REG_DWORD;
    DWORD   size = sizeof(DWORD);
    HKEY    hKey;
    LONG    status;

    // First check the environment to see if we have something there
    char  szEnvLookup[500];
    _ASSERTE((strlen(Name) + strlen("COMPlus_")) < 500);
    char  szValue[500];
    sprintf(szEnvLookup, "COMPlus_%s", Name);
    int iNumChars = GetEnvironmentVariableA(szEnvLookup, szValue, 499);
    if (iNumChars)
    {
        int iVal = atoi(szValue);
        return iVal;
    }


    // Open the key if it is there.
    if ((status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY, 0, KEY_READ, &hKey)) == ERROR_SUCCESS) 
    {
        // Read the key value if found.
        status = RegQueryValueExA(hKey, Name, NULL, &type, (LPBYTE)&value, &size);
        RegCloseKey(hKey);
    }

    // Try under HKCU if we didn't have any luck under HKLM.
    if ((status != ERROR_SUCCESS) || (type != REG_DWORD))
    {
        if ((status = RegOpenKeyExA(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY, 0, KEY_READ, &hKey)) == ERROR_SUCCESS) 
        {
            status = RegQueryValueExA(hKey, Name, NULL, &type, (LPBYTE)&value, &size);
            RegCloseKey(hKey);
        }
    }

    // Default value to 0 if necessary.
    if ((status != ERROR_SUCCESS) || (type != REG_DWORD))
        value = 0;

    return value;
}


// Called to initialise the allocation subsystem (the first time it's used).
void DbgAllocInit()
{
 retry:

    // Try to get the exclusive right to initialize.
    if (InterlockedExchange(&g_HeapInitializing, 1) == 0) {

        // We're now in a critical section. Check whether the subsystem was
        // initialized in the meantime.
        if (g_HeapInitialized) {
            g_HeapInitializing = 0;
            return;
        }

        // Nobody beat us to it. Initialize the subsystem now (other potential
        // initializors are spinning on g_HeapInitializing).
        
        // Create the mutex used to synchronize all heap debugging operations.
        InitializeCriticalSection(&g_AllocMutex);

        // Reset statistics.
        CDA_STATS_CLEAR();

        // Reset allocation size distribution buckets.
        memset (&g_AllocBuckets, 0, sizeof(g_AllocBuckets));
        g_LargeAllocs = 0;

        // Initialize the global serial number count. This is stamped into newly
        // allocated packet headers and then incremented as a way of uniquely
        // identifying allocations.
        g_NextSN = 1;

        // Initialize the pointers to the first and last packets in a chain of
        // live allocations (used to track all leaked packets at the end of a
        // run).
        g_AllocListFirst = NULL;
        g_AllocListLast = NULL;

        // This is used to help prevent false EBP crawls in DbgCallstackWorker
        g_hThisModule = (HINSTANCE) GetModuleHandleA(NULL);

        // Symbol tables haven't been initialized yet.
        g_SymbolsInitialized = false;

        // See if we should be logging locking stuff
        g_DisplayLockInfo = DbgAllocReadRegistry("DisplayLockInfo") != 0;

        // Get setup from registry.
        g_DbgEnabled = DbgAllocReadRegistry("AllocDebug") != 0;
        if (g_DbgEnabled) {
            g_ConstantRecheck = DbgAllocReadRegistry("AllocRecheck") != 0;
            g_AllocGuard = DbgAllocReadRegistry("AllocGuard") != 0;
            g_PoisonPackets = DbgAllocReadRegistry("AllocPoison") != 0;
            g_FreeQueueSize = DbgAllocReadRegistry("AllocFreeQueueSize") != 0;
            g_LogDist = DbgAllocReadRegistry("AllocDist") != 0;
            g_LogStats = DbgAllocReadRegistry("AllocStats") != 0;
            g_DetectLeaks = DbgAllocReadRegistry("AllocLeakDetect") != 0;
#ifdef SHOULD_WE_CLEANUP
            g_AssertOnLeaks = DbgAllocReadRegistry("AllocAssertOnLeak") != 0;
#else
            g_AssertOnLeaks = 0;
#endif /* SHOULD_WE_CLEANUP */
            g_BreakOnAlloc = DbgAllocReadRegistry("AllocBreakOnAllocEnable") != 0;
            g_BreakOnAllocNumber = DbgAllocReadRegistry("AllocBreakOnAllocNumber");
            g_UsePrivateHeap = DbgAllocReadRegistry("AllocUsePrivateHeap") != 0;
            g_ValidateHeap = DbgAllocReadRegistry("AllocValidateHeap") != 0;
            g_PagePerAlloc = DbgAllocReadRegistry("AllocPagePerAlloc") != 0;
            g_UsageByAllocator = DbgAllocReadRegistry("UsageByAllocator") != 0;
            g_CallStackDepth = DbgAllocReadRegistry("AllocCallStackDepth");
            g_CallStackDepth = g_CallStackDepth ? min(g_CallStackDepth, CDA_MAX_CALLSTACK) : 4;

#if defined (_X86_) && FPO == 1
        	MEMORY_BASIC_INFORMATION mbi;

	        if (VirtualQuery(DbgAllocInit, &mbi, sizeof(mbi))) {
		        g_ModuleBase = (DWORD_PTR)mbi.AllocationBase;
                g_ModuleTop = (DWORD_PTR)mbi.BaseAddress + mbi.RegionSize;
    	    } else {
	    	    // way bad error, probably just assert and exit
                _ASSERTE (!"VirtualQuery failed");
                g_ModuleBase = 0;
                g_ModuleTop = 0;
	        }   
#endif
        }
        DWORD breakNum = DbgAllocReadRegistry("AllocBreakOnCrtAllocNumber");
        if (breakNum)
            _CrtSetBreakAlloc(breakNum);

        // Page per alloc mode isn't compatible with some heap functions and
        // guard bytes don't make any sense.
        if (g_PagePerAlloc) {
            g_UsePrivateHeap = false;
            g_ValidateHeap = false;
            g_AllocGuard = false;
        }

        // Allocate a private heap if that's what the user wants.
        if (g_UsePrivateHeap) {
            g_HeapHandle = HeapCreate(0, 409600, 0);
            if (g_HeapHandle == NULL)
                g_HeapHandle = GetProcessHeap();
        } else
            g_HeapHandle = GetProcessHeap();

        // Get the system page size.
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);
        g_PageSize = sysinfo.dwPageSize;

        // If we have been asked to record the top allocators, initialize the
        // table to its empty state.
        if (g_UsageByAllocator) {
            g_TopAllocators = NULL;
            g_TopAllocatorsSlots = 0;
        }

        if (g_PoisonPackets) {
            if (g_FreeQueueSize == 0)
                g_FreeQueueSize = 8192;     // keep the last 8K free packets around
            g_AllocFreeQueueCur = 0;

            g_AllocFreeQueue = (DbgAllocHeader ** )
                HeapAlloc(g_HeapHandle, HEAP_ZERO_MEMORY, sizeof(DbgAllocHeader*)*g_FreeQueueSize);
            _ASSERTE(g_AllocFreeQueue);
            }

        // Initialization complete. Once we reset g_HeapInitializing to 0, any
        // other potential initializors can get in and see they have no work to
        // do.
        g_HeapInitialized = true;
        g_HeapInitializing = 0;
    } else {
        // Someone else is initializing, wait until they finish.
        Sleep(0);
        goto retry;
    }
}


// Called just before process exit to report stats and check for memory
// leakages etc.
void __stdcall DbgAllocReport(char * pString, BOOL fDone, BOOL fDoPrintf)
{
    if (!g_HeapInitialized)
        return;

    if (g_LogStats || g_LogDist || g_DetectLeaks || g_UsageByAllocator)
        LOG((LF_DBGALLOC, LL_ALWAYS, "------ Allocation Stats ------\n"));

    // Print out basic statistics.
    if (g_LogStats) {
        LOG((LF_DBGALLOC, LL_ALWAYS, "\n"));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Alloc calls    : %u\n", (int)g_AllocStats.m_Allocs));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Alloc failures : %u\n", (int)g_AllocStats.m_AllocFailures));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Alloc 0s       : %u\n", (int)g_AllocStats.m_ZeroAllocs));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Alloc bytes    : %u\n", (int)g_AllocStats.m_AllocBytes));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Free calls     : %u\n", (int)g_AllocStats.m_Frees));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Free NULLs     : %u\n", (int)g_AllocStats.m_NullFrees));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Free bytes     : %u\n", (int)g_AllocStats.m_FreeBytes));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Leaked allocs  : %u\n", (int)(g_AllocStats.m_Allocs - g_AllocStats.m_AllocFailures) -
             (g_AllocStats.m_Frees - g_AllocStats.m_NullFrees)));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Leaked bytes   : %u\n", (int)g_AllocStats.m_AllocBytes - g_AllocStats.m_FreeBytes));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Max allocation : %u\n", (int)g_AllocStats.m_MaxAlloc));
    }

    // Print out allocation size distribution statistics.
    if (g_LogDist) {
        LOG((LF_DBGALLOC, LL_ALWAYS, "\n"));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Alloc distrib  :\n"));
        for (unsigned i = 0; i < CDA_DIST_BUCKETS; i++)
            LOG((LF_DBGALLOC, LL_ALWAYS, "  [%3u,%3u] : %u\n", i * CDA_DIST_BUCKET_SIZE,
                 (i * CDA_DIST_BUCKET_SIZE) + (CDA_DIST_BUCKET_SIZE - 1),
                 (int)g_AllocBuckets[i]));
        LOG((LF_DBGALLOC, LL_ALWAYS, "  [%3u,---] : %u\n", CDA_MAX_DIST_SIZE + 1, (int)g_LargeAllocs));
    }

    // Print out the table of top allocators. Table is pre-sorted, the first
    // NULL entry indicates the end of the valid list.
    if (g_UsageByAllocator && g_TopAllocators) {
        LOG((LF_DBGALLOC, LL_ALWAYS, "\n"));
        LOG((LF_DBGALLOC, LL_ALWAYS, "Top allocators :\n"));
        for (unsigned i = 0; i < min(CDA_TOP_ALLOCATORS, g_TopAllocatorsSlots); i++) {
            if (g_TopAllocators[i].m_EIP == NULL)
                break;
            LOG((LF_DBGALLOC, LL_ALWAYS, "  %2u: %08X %s\n",
                 i + 1,
                 g_TopAllocators[i].m_EIP,
                 DbgSymbolize(g_TopAllocators[i].m_EIP)));
            LOG((LF_DBGALLOC, LL_ALWAYS, "       %u allocations, %u bytes total, %u bytes average size\n",
                 g_TopAllocators[i].m_Count,
                 (unsigned)g_TopAllocators[i].m_TotalBytes,
                 (unsigned)(g_TopAllocators[i].m_TotalBytes / g_TopAllocators[i].m_Count)));
        }
    }

    // Print out info for all leaked packets.
    if (g_DetectLeaks) {

        DbgAllocHeader *h = g_AllocListFirst;
        int fHaveLeaks = (h!=NULL);

        if (h) {

            // Tell the Log we had memory leaks
            LOG((LF_DBGALLOC, LL_ALWAYS, "\n"));
            LOG((LF_DBGALLOC, LL_ALWAYS, "Detected memory leaks!\n"));
            LOG((LF_DBGALLOC, LL_ALWAYS, "Leaked packets :\n"));

            // Tell the console we had memory leaks
            if (fDoPrintf)
            {
                printf("Detected memory leaks!\n");
                if (pString != NULL)
                    printf("%s\n", pString);
                    
                printf("Leaked packets :\n");
            }
        }

        while (h) {
            char buffer1[132];
            char buffer2[32];
            sprintf(buffer1, "#%u %08X:%u ", h->m_SN, CDA_HEADER_TO_DATA(h), h->m_Length);
            for (unsigned i = 0; i < 16; i++) {
                if (i < h->m_Length)
                    sprintf(buffer2, "%02X", (BYTE)CDA_DATA(h, i));
                else
                    strcpy(buffer2, "  ");
                if ((i % 4) == 3)
                    strcat(buffer2, " ");
                strcat(buffer1, buffer2);
            }
            for (i = 0; i < min(16, h->m_Length); i++) {
                sprintf(buffer2, "%c", (CDA_DATA(h, i) < 32) || (CDA_DATA(h, i) > 127) ? '.' : CDA_DATA(h, i));
                strcat(buffer1, buffer2);
            }
            LOG((LF_DBGALLOC, LL_ALWAYS, "%s\n", buffer1));
            if (fDoPrintf)
                printf("%s\n", buffer1);
            
            if (g_CallStackDepth == 1) {
                LOG((LF_DBGALLOC, LL_ALWAYS, " Allocated at %08X %s\n",
                     CDA_ALLOC_STACK(h, 0), DbgSymbolize(CDA_ALLOC_STACK(h, 0))));

            if (fDoPrintf)
                printf(" Allocated at %08X %s\n",
                     CDA_ALLOC_STACK(h, 0), DbgSymbolize(CDA_ALLOC_STACK(h, 0)));
            } else {
                LOG((LF_DBGALLOC, LL_ALWAYS, " Allocation call stack:\n"));
                if (fDoPrintf)
                    printf(" Allocation call stack:\n");
                for (unsigned i = 0; i < g_CallStackDepth; i++) {
                    if (CDA_ALLOC_STACK(h, i) == NULL)
                        break;
                    LOG((LF_DBGALLOC, LL_ALWAYS, "  %08X %s\n",
                         CDA_ALLOC_STACK(h, i), DbgSymbolize(CDA_ALLOC_STACK(h, i))));
                    if (fDoPrintf)
                        printf("  %08X %s\n",
                             CDA_ALLOC_STACK(h, i), DbgSymbolize(CDA_ALLOC_STACK(h, i)));
                }
            }
            wchar_t buf[256];
            GetModuleFileNameW(h->m_hmod, buf, 256);
            LOG((LF_DBGALLOC, LL_ALWAYS, " Base, name: %08X %S\n\n", h->m_hmod, buf));
            if (fDoPrintf)
                printf(" Base, name: %08X %S\n\n", h->m_hmod, buf);
            h = h->m_Next;
        }

        _flushall();

        if (fHaveLeaks && g_AssertOnLeaks)
            _ASSERTE(!"Detected memory leaks!");

    }

    if (g_LogStats || g_LogDist || g_DetectLeaks || g_UsageByAllocator) {
        LOG((LF_DBGALLOC, LL_ALWAYS, "\n"));
        LOG((LF_DBGALLOC, LL_ALWAYS, "------------------------------\n"));
    }

    if (fDone)
    {
        DbgUnloadSymbols();
        DeleteCriticalSection(&g_AllocMutex);
        // We won't be doing any more of our debug allocation stuff
        g_DbgEnabled=0;
    }
}


// Allocate a block of memory at least n bytes big.
void * __stdcall DbgAlloc(unsigned n, void **ppvCallstack)
{
    // Initialize if necessary (DbgAllocInit takes care of the synchronization).
    if (!g_HeapInitialized)
        DbgAllocInit();

    if (!g_DbgEnabled)
        return HeapAlloc(GetProcessHeap(), 0, n);

    CDA_LOCK();

    // Count calls to this routine and the number that specify 0 bytes of
    // allocation. This needs to be done under the lock since the counters
    // themselves aren't synchronized.
    CDA_STATS_INC(Allocs);
    if (n == 0)
        CDA_STATS_INC(ZeroAllocs);

    CDA_UNLOCK();

    // Allocate enough memory for the caller, our debugging header and possibly
    // some guard bytes.
    unsigned        length = CDA_SIZEOF_HEADER() + n + CDA_OPT_GUARD_BYTES;
    DbgAllocHeader *h;

    if (g_PagePerAlloc) {
        // In page per alloc mode we allocate a number of whole pages. The
        // actual packet is placed at the end of the second to last page and the
        // last page is reserved but never commited (so will cause an access
        // violation if touched). This will catch heap crawl real quick.
        unsigned pages = ((length + (g_PageSize - 1)) / g_PageSize) + 1;
        h = (DbgAllocHeader *)VirtualAlloc(NULL, pages * g_PageSize, MEM_RESERVE, PAGE_NOACCESS);
        if (h) {
            VirtualAlloc(h, (pages - 1) * g_PageSize, MEM_COMMIT, PAGE_READWRITE);
            h = (DbgAllocHeader *)((BYTE *)h + (g_PageSize - (length % g_PageSize)));
        }
    } else
        h = (DbgAllocHeader *)HeapAlloc(g_HeapHandle, 0, length);

    CDA_LOCK();
    if (h == NULL) {

        // Whoops, allocation failure. Record it.
        CDA_STATS_INC(AllocFailures);
        LOG((LF_DBGALLOC, LL_ALWAYS, "DbgAlloc: alloc fail for %u bytes\n", n));

    } else {

        // Check all active packets still look OK.
        if (g_ConstantRecheck)
            DbgValidateActivePackets(h, &CDA_DATA(h, n + CDA_OPT_GUARD_BYTES));

        // Count the total number of bytes we've allocated so far.
        CDA_STATS_ADD(AllocBytes, n);

        // Record the largest amount of concurrent allocations we ever see
        // during the life of the process.
        if((g_AllocStats.m_AllocBytes - g_AllocStats.m_FreeBytes) > g_AllocStats.m_MaxAlloc)
            g_AllocStats.m_MaxAlloc = g_AllocStats.m_AllocBytes - g_AllocStats.m_FreeBytes;

        // Fill in the packet debugging header.
        for (unsigned i = 0; i < g_CallStackDepth; i++) {
            CDA_ALLOC_STACK(h, i) = ppvCallstack[i];
            CDA_DEALLOC_STACK(h, i) = NULL;
        }
        h->m_hmod = GetModuleHandleW(NULL);
        h->m_SN = g_NextSN++;
        h->m_Length = n;
        h->m_Prev = g_AllocListLast;
        h->m_Next = NULL;
        h->m_Magic1 = CDA_MAGIC_1;
        *CDA_MAGIC2(h) = CDA_MAGIC_2;

        // If the user wants to breakpoint on the allocation of a specific
        // packet, do it now.
        if (g_BreakOnAlloc && (h->m_SN == g_BreakOnAllocNumber))
            _ASSERTE(!"Hit memory allocation # for breakpoint");

        // Link the packet into the queue of live packets.
        if (g_AllocListLast != NULL) {
            g_AllocListLast->m_Next = h;
            g_AllocListLast = h;
        }
        if (g_AllocListFirst == NULL) {
            _ASSERTE(g_AllocListLast == NULL);
            g_AllocListFirst = h;
            g_AllocListLast = h;
        }

        // Poison the data buffer about to be handed to the caller, in case
        // they're (wrongly) assuming it to be zero initialized.
        if (g_PoisonPackets)
            memset(CDA_HEADER_TO_DATA(h), CDA_ALLOC_PATTERN, n);

        // Write a guard pattern after the user data to trap overwrites.
        if (g_AllocGuard)
            memset(&CDA_DATA(h, n), CDA_GUARD_PATTERN, CDA_GUARD_BYTES);

        // See if our allocator makes the list of most frequent allocators.
        if (g_UsageByAllocator) {
            // Look for an existing entry in the table for our EIP, or for the
            // first empty slot (the table is kept in sorted order, so the first
            // empty slot marks the end of the table).
            for (unsigned i = 0; i < g_TopAllocatorsSlots; i++) {

                if (g_TopAllocators[i].m_EIP == ppvCallstack[0]) {
                    // We already have an entry for this allocator. Incrementing
                    // the count may allow us to move the allocator up the
                    // table.
                    g_TopAllocators[i].m_Count++;
                    g_TopAllocators[i].m_TotalBytes += n;
                    if ((i > 0) &&
                        (g_TopAllocators[i].m_Count > g_TopAllocators[i - 1].m_Count)) {
                        DbgAllocTop tmp = g_TopAllocators[i - 1];
                        g_TopAllocators[i - 1] = g_TopAllocators[i];
                        g_TopAllocators[i] = tmp;
                    }
                    break;
                }

                if (g_TopAllocators[i].m_EIP == NULL) {
                    // We've found an empty slot, we weren't in the table. This
                    // is the right place to put the entry though, since we've
                    // only done a single allocation.
                    g_TopAllocators[i].m_EIP = ppvCallstack[0];
                    g_TopAllocators[i].m_Count = 1;
                    g_TopAllocators[i].m_TotalBytes = n;
                    break;
                }

            }

            if (i == g_TopAllocatorsSlots) {
                // Ran out of space in the table, need to expand it.
                unsigned slots = g_TopAllocatorsSlots ?
                    g_TopAllocatorsSlots * 2 :
                    CDA_TOP_ALLOCATORS;
                DbgAllocTop *newtab = (DbgAllocTop*)LocalAlloc(LMEM_FIXED, sizeof(DbgAllocTop) * slots);
                if (newtab) {

                    // Copy old contents over.
                    if (g_TopAllocatorsSlots) {
                        memcpy(newtab, g_TopAllocators, sizeof(DbgAllocTop) * g_TopAllocatorsSlots);
                        LocalFree(g_TopAllocators);
                    }

                    // Install new table.
                    g_TopAllocators = newtab;
                    g_TopAllocatorsSlots = slots;

                    // Add new entry to tail.
                    g_TopAllocators[i].m_EIP = ppvCallstack[0];
                    g_TopAllocators[i].m_Count = 1;
                    g_TopAllocators[i].m_TotalBytes = n;

                    // And initialize the rest of the entries to empty.
                    memset(&g_TopAllocators[i + 1],
                           0,
                           sizeof(DbgAllocTop) * (slots - (i + 1)));

                }
            }
        }

        // Count how many allocations of each size range we get. Allocations
        // above a certain size are all dumped into one bucket.
        if (g_LogDist) {
            if (n > CDA_MAX_DIST_SIZE)
                g_LargeAllocs++;
            else {
                for (unsigned i = CDA_DIST_BUCKET_SIZE - 1; i <= CDA_MAX_DIST_SIZE; i += CDA_DIST_BUCKET_SIZE)
                    if (n <= i) {
                        g_AllocBuckets[i/CDA_DIST_BUCKET_SIZE]++;
                        break;
                    }
            }
        }

    }
    CDA_UNLOCK();

    return h ? CDA_HEADER_TO_DATA(h) : NULL;
}


// Free a packet allocated with DbgAlloc.
void __stdcall DbgFree(void *b, void **ppvCallstack)
{
    if (!g_DbgEnabled) {
        if (b) // check for null pointer Win98 doesn't like being
                // called to free null pointers.
            HeapFree(GetProcessHeap(), 0, b);
        return;
    }

    // Technically it's possible to get here without having gone through
    // DbgAlloc (since it's legal to deallocate a NULL pointer), so we
    // better check for initializtion to be on the safe side.
    if (!g_HeapInitialized)
        DbgAllocInit();

    CDA_LOCK();

    // Check all active packets still look OK.
    if (g_ConstantRecheck)
        DbgValidateActivePackets(NULL, NULL);

    // Count this call to DbgFree.
    CDA_STATS_INC(Frees);

    // It's legal to deallocate NULL. Count these as they happen so it doesn't
    // screw up our leak detection algorithm.
    if (b == NULL) {
        CDA_STATS_INC(NullFrees);
        CDA_UNLOCK();
        return;
    }

    // Locate the packet header in front of the data packet.
    DbgAllocHeader *h = CDA_DATA_TO_HEADER(b);

    // Check that the header looks OK.
    DbgValidateHeader(h);

    // Count the total number of bytes we've freed so far.
    CDA_STATS_ADD(FreeBytes, h->m_Length);

    // Unlink the packet from the live packet queue.
    if (h->m_Prev)
        h->m_Prev->m_Next = h->m_Next;
    else
        g_AllocListFirst = h->m_Next;
    if (h->m_Next)
        h->m_Next->m_Prev = h->m_Prev;
    else
        g_AllocListLast = h->m_Prev;

    // Zap our link pointers so we'll spot corruption sooner.
    h->m_Next = (DbgAllocHeader *)CDA_INV_PATTERN;
    h->m_Prev = (DbgAllocHeader *)CDA_INV_PATTERN;

    // Zap the tag fields in the header so we'll spot double deallocations
    // straight away.
    h->m_Magic1 = CDA_INV_PATTERN;
    *CDA_MAGIC2(h) = CDA_INV_PATTERN;

    // Poison the user's data area so that continued access to it after the
    // deallocation will likely cause an assertion that much sooner.
    if (g_PoisonPackets)
        memset(b, CDA_DEALLOC_PATTERN, h->m_Length);

    // Record the callstack of the deallocator (handy for debugging double
    // deallocation problems).
    for (unsigned i = 0; i < g_CallStackDepth; i++)
        CDA_DEALLOC_STACK(h, i) = ppvCallstack[i];

    // put the pack on the free list for a while.  Delete the one that it replaces.
    if (g_PoisonPackets) {
        DbgAllocHeader* tmp = g_AllocFreeQueue[g_AllocFreeQueueCur];
        g_AllocFreeQueue[g_AllocFreeQueueCur] = h;
        h = tmp;

        g_AllocFreeQueueCur++;
        if (g_AllocFreeQueueCur >= g_FreeQueueSize)
            g_AllocFreeQueueCur = 0;
    }

    CDA_UNLOCK();

    if (h) {
        if (g_PagePerAlloc) {
            // In page per alloc mode we decommit the pages allocated, but leave
            // them reserved so that we never reuse the same virtual addresses.
            VirtualFree(h, h->m_Length + CDA_SIZEOF_HEADER() + CDA_OPT_GUARD_BYTES, MEM_DECOMMIT);
        } else
            HeapFree(g_HeapHandle, 0, h);
    }
}


// Determine whether an address is part of a live packet, or a live packet
// header. Intended for interactive use in the debugger, outputs to debugger
// console.
DbgAllocHeader *DbgCheckAddress(unsigned ptr)
{
    DbgAllocHeader *h = g_AllocListFirst;
    WCHAR           output[1024];
    void           *p = (void *)ptr;

    while (h) {
        void *head = (void *)h;
        void *start = (void *)CDA_HEADER_TO_DATA(h);
        void *end = (void *)&CDA_DATA(h, h->m_Length);
        void *tail = (void *)&CDA_DATA(h, h->m_Length + CDA_OPT_GUARD_BYTES);
        if ((p >= head) && (p < start)) {
            wsprintfW(output, L"0x%08X is in packet header at 0x%08X\n", p, h);
            WszOutputDebugString(output);
            return h;
        } else if ((p >= start) && (p < end)) {
            wsprintfW(output, L"0x%08X is in data portion of packet at 0x%08X\n", p, h);
            WszOutputDebugString(output);
            return h;
        } else if ((p >= end) && (p < tail)) {
            wsprintfW(output, L"0x%08X is in guard portion of packet at 0x%08X\n", p, h);
            WszOutputDebugString(output);
            return h;
        }
        h = h->m_Next;
    }

    wsprintfW(output, L"%08X not located in any live packet\n", p);
    WszOutputDebugString(output);

    return NULL;
}


#pragma warning(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\ccomprc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"                     // Standard header.
#include <UtilCode.h>                   // Utility helpers.
#include <CorError.h>

// External prototypes.
extern HINSTANCE GetModuleInst();

//*****************************************************************************
// Get the MUI ID, on downlevel platforms where MUI is not supported it
// returns the default system ID.

typedef LANGID (WINAPI *PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage

int GetMUILanguageID()
{
    int langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        PFNGETUSERDEFAULTUILANGUAGE proc = NULL;

        HMODULE hmod = GetModuleHandleA("KERNEL32");
        
        if( hmod )
            proc = (PFNGETUSERDEFAULTUILANGUAGE)
                GetProcAddress(hmod, "GetUserDefaultUILanguage");

        if(proc == NULL)
            proc = (PFNGETUSERDEFAULTUILANGUAGE) -1;
        
        PVOID value = InterlockedExchangePointer((PVOID*) &pfnGetUserDefaultUILanguage,
                                                 proc);
    }

    // We should never get NULL here, the function is -1 or a valid address.
    _ASSERTE(pfnGetUserDefaultUILanguage != NULL);


    if( pfnGetUserDefaultUILanguage == (PFNGETUSERDEFAULTUILANGUAGE) -1)
        langId = GetSystemDefaultLangID();
    else
        langId = pfnGetUserDefaultUILanguage();
    
    return (int) langId;
}

static int BuildMUIDirectory(int langid, LPWSTR szBuffer, int length)
{

    int totalLength = 0;
    WCHAR directory[] = L"MUI\\";
    DWORD dwDirectory = sizeof(directory)/sizeof(WCHAR);
    
    WCHAR buffer[17];
    _snwprintf(buffer, sizeof(buffer)/sizeof(WCHAR), L"%04x", langid);
    DWORD dwBuffer = wcslen(buffer);

    if((DWORD) length > dwDirectory + dwBuffer) {
        wcscpy(szBuffer, directory);
        wcscat(szBuffer, buffer);

        wcscat(szBuffer, L"\\");
        totalLength = wcslen(szBuffer) + 1;
    }

    return totalLength;
}

int GetMUILanguageName(LPWSTR szBuffer, int length)
{
    int langid = GetMUILanguageID();

    _ASSERTE(length > 0);
    return BuildMUIDirectory(langid, szBuffer, length);
}
 
int GetMUIParentLanguageName(LPWSTR szBuffer, int length)
{
    int langid = 1033;

    _ASSERTE(length > 0);
    return BuildMUIDirectory(langid, szBuffer, length);
}


//*****************************************************************************
// Do the mapping from an langId to an hinstance node
//*****************************************************************************
HINSTANCE CCompRC::LookupNode(int langId)
{
    if (m_pHash == NULL) return NULL;

// Linear search
    int i;
    for(i = 0; i < m_nHashSize; i ++) {
        if (m_pHash[i].m_LangId == langId) {
            return m_pHash[i].m_hInst;
        }
    }

    return NULL;
}

//*****************************************************************************
// Add a new node to the map and return it.
//*****************************************************************************
const int MAP_STARTSIZE = 7;
const int MAP_GROWSIZE = 5;

void CCompRC::AddMapNode(int langId, HINSTANCE hInst)
{
    if (m_pHash == NULL) {
        m_pHash = new CCulturedHInstance[MAP_STARTSIZE];        
        m_nHashSize = MAP_STARTSIZE;
    }

// For now, place in first open slot
    int i;
    for(i = 0; i < m_nHashSize; i ++) {
        if (m_pHash[i].m_LangId == 0) {
            m_pHash[i].m_LangId = langId;
            m_pHash[i].m_hInst = hInst;
            return;
        }
    }

// Out of space, regrow
    CCulturedHInstance * pNewHash = new CCulturedHInstance[m_nHashSize + MAP_GROWSIZE];
    if (pNewHash)
    {
        memcpy(pNewHash, m_pHash, sizeof(CCulturedHInstance) * m_nHashSize);
        delete [] m_pHash;
        m_pHash = pNewHash;
        m_pHash[m_nHashSize].m_LangId = langId;
        m_pHash[m_nHashSize].m_hInst = hInst;
        m_nHashSize += MAP_GROWSIZE;
    }
}

//*****************************************************************************
// Initialize
//*****************************************************************************
WCHAR* CCompRC::m_pDefaultResource = L"MSCORRC.DLL";

CCompRC::CCompRC()
{
    m_pHash = NULL;
    m_nHashSize = 0;
    m_pResourceFile = m_pDefaultResource;

    m_fpGetThreadUICultureName = NULL;
    m_fpGetThreadUICultureId = NULL;

    InitializeCriticalSection (&m_csMap);
}

CCompRC::CCompRC(WCHAR* pResourceFile)
{
    m_pHash = NULL;
    m_nHashSize = 0;
    if(pResourceFile) {
        DWORD lgth = wcslen(pResourceFile) + 1;
        m_pResourceFile = new WCHAR[lgth];
        wcscpy(m_pResourceFile, pResourceFile);
    }
    else
        m_pResourceFile = m_pDefaultResource;
        
    m_fpGetThreadUICultureName = NULL;
    m_fpGetThreadUICultureId = NULL;

    InitializeCriticalSection (&m_csMap);
}

void CCompRC::SetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME fpGetThreadUICultureParentName
)
{
    m_fpGetThreadUICultureName = fpGetThreadUICultureName;
    m_fpGetThreadUICultureId = fpGetThreadUICultureId;
    m_fpGetThreadUICultureParentName = fpGetThreadUICultureParentName;
}

void CCompRC::GetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME* fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID* fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME* fpGetThreadUICultureParentName
)
{
    if(fpGetThreadUICultureName)
        *fpGetThreadUICultureName=m_fpGetThreadUICultureName;
    if(fpGetThreadUICultureId)
        *fpGetThreadUICultureId=m_fpGetThreadUICultureId;
    if(fpGetThreadUICultureParentName)
        *fpGetThreadUICultureParentName=m_fpGetThreadUICultureParentName;
}

// POSTERRIMPORT HRESULT LoadStringRC(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet=false);

//*****************************************************************************
// Free the loaded library if we ever loaded it and only if we are not on
// Win 95 which has a known bug with DLL unloading (it randomly unloads a
// dll on shut down, not necessarily the one you asked for).  This is done
// only in debug mode to make coverage runs accurate.
//*****************************************************************************
CCompRC::~CCompRC()
{
// Free all resource libraries
#if defined(_DEBUG) || defined(_CHECK_MEM)
    if (m_Primary.m_hInst) {
        ::FreeLibrary(m_Primary.m_hInst);
    }
    if (m_pHash != NULL) {
        int i;
        for(i = 0; i < m_nHashSize; i ++) {
            if (m_pHash[i].m_hInst != NULL) {
                ::FreeLibrary(m_pHash[i].m_hInst);
                break;
            }
        }
    }
#endif

    // destroy map structure
    if(m_pResourceFile != m_pDefaultResource)
        delete [] m_pResourceFile;

    DeleteCriticalSection (&m_csMap);
    delete [] m_pHash;
}
//*****************************************************************************
// Free the memory allocated by CCompRC.
// It is true that this function is not needed, for CCompRC's destructor will
// fire and free this memory, but that will happen after we've done our memory
// leak detection, and thus we will generate memory leak errors
//*****************************************************************************
#ifdef SHOULD_WE_CLEANUP
void CCompRC::Shutdown()
{
    delete [] m_pHash;
    m_pHash=NULL;
}
#endif /* SHOULD_WE_CLEANUP */


HRESULT CCompRC::GetLibrary(HINSTANCE* phInst)
{
    _ASSERTE(phInst != NULL);

    HRESULT     hr = E_FAIL;
    HINSTANCE   hInst = 0;
    HINSTANCE   hLibInst = 0; //Holds early library instance
    BOOL        fLibAlreadyOpen = FALSE; //Determine if we can close the opened library.

    // Must resolve current thread's langId to a dll.   
    int langId;
    if (m_fpGetThreadUICultureId) {
        langId = (*m_fpGetThreadUICultureId)();

    // Callback can't return 0, since that indicates empty.
    // To indicate empty, callback should return UICULTUREID_DONTCARE
        _ASSERTE(langId != 0);

    } else {
        langId = UICULTUREID_DONTCARE;
    }


    // Try to match the primary entry
    if (m_Primary.m_LangId == langId) {
        hInst = m_Primary.m_hInst;
        hr = S_OK;
    }
    // If this is the first visit, we must set the primary entry
    else if (m_Primary.m_LangId == 0) {
        IfFailRet(LoadLibrary(&hLibInst));
        
        EnterCriticalSection (&m_csMap);

            // As we expected
            if (m_Primary.m_LangId == 0) {
                hInst = m_Primary.m_hInst = hLibInst;
                m_Primary.m_LangId = langId;
            }

            // Someone got into this critical section before us and set the primary already
            else if (m_Primary.m_LangId == langId) {
                hInst = m_Primary.m_hInst;
                fLibAlreadyOpen = TRUE;
            }

            // If neither case is true, someone got into this critical section before us and
            //  set the primary to other than the language we want...
            else
                fLibAlreadyOpen = TRUE;

        LeaveCriticalSection(&m_csMap);

        if (fLibAlreadyOpen)
        {
            FreeLibrary(hLibInst);
            fLibAlreadyOpen = FALSE;
        }
    }


    // If we enter here, we know that the primary is set to something other than the
    // language we want - multiple languages use the hash table
    if (hInst == NULL) {

        // See if the resource exists in the hash table
        EnterCriticalSection (&m_csMap);
            hInst = LookupNode(langId);
        LeaveCriticalSection (&m_csMap);

        // If we didn't find it, we have to load the library and insert it into the hash
        if (hInst == NULL) {
            IfFailRet(LoadLibrary(&hLibInst));
        
            EnterCriticalSection (&m_csMap);

                // Double check - someone may have entered this section before us
                hInst = LookupNode(langId);
                if (hInst == NULL) {
                    hInst = hLibInst;
                    AddMapNode(langId, hInst);
                }
                else
                    fLibAlreadyOpen = TRUE;

            LeaveCriticalSection (&m_csMap);

            if (fLibAlreadyOpen)
                FreeLibrary(hLibInst);
        }
    }

    *phInst = hInst;
    return hr;
}



//*****************************************************************************
// Load the string 
// We load the localized libraries and cache the handle for future use.
// Mutliple threads may call this, so the cache structure is thread safe.
//*****************************************************************************
HRESULT CCompRC::LoadString(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet)
{
    HRESULT     hr;
    HINSTANCE   hInst = 0; //instance of cultured resource dll

    hr = GetLibrary(&hInst);
    if(FAILED(hr)) return hr;

    // Now that we have the proper dll handle, load the string
    _ASSERTE(hInst != NULL);

    if (::WszLoadString(hInst, iResourceID, szBuffer, iMax) > 0)
        return (S_OK);
    
    // Allows caller to check for string not found without extra debug checking.
    if (bQuiet)
        return (E_FAIL);

    // Shouldn't be any reason for this condition but the case where we
    // used the wrong ID or didn't update the resource DLL.
    _ASSERTE(0);
    return (HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT CCompRC::LoadMUILibrary(HINSTANCE * pHInst)
{
    _ASSERTE(pHInst != NULL);
    HRESULT hr = GetLibrary(pHInst);
    return hr;
}

//*****************************************************************************
// Load the library for this thread's current language
// Called once per language. 
// Search order is: 
//  1. Dll in localized path (<dir of this module>\<lang name (en-US format)>\mscorrc.dll)
//  2. Dll in localized (parent) path (<dir of this module>\<lang name> (en format)\mscorrc.dll)
//  3. Dll in root path (<dir of this module>\mscorrc.dll)
//  4. Dll in current path   (<current dir>\mscorrc.dll)
//*****************************************************************************
HRESULT CCompRC::LoadLibrary(HINSTANCE * pHInst)
{
    bool        fFail;
    const int   MAX_LANGPATH = 20;

    WCHAR       rcPath[_MAX_PATH];      // Path to resource DLL.
    WCHAR       rcDrive[_MAX_DRIVE];    // Volume name.
    WCHAR       rcDir[_MAX_PATH];       // Directory.
    WCHAR       rcLang[MAX_LANGPATH + 2];   // extension to path for language

    DWORD       rcDriveLen;
    DWORD       rcDirLen;
    DWORD       rcLangLen;


    _ASSERTE(m_pResourceFile != NULL);

    const DWORD  rcPathSize = _MAX_PATH;
    const WCHAR* rcMscorrc = m_pResourceFile;
    const DWORD  rcMscorrcLen = Wszlstrlen(m_pResourceFile);

    DWORD dwLoadLibraryFlags;
    if(m_pResourceFile == m_pDefaultResource)
        dwLoadLibraryFlags = LOAD_LIBRARY_AS_DATAFILE;
    else
        dwLoadLibraryFlags = 0;

    _ASSERTE(pHInst != NULL);

    fFail = TRUE;

    if (m_fpGetThreadUICultureName) {
        int len = (*m_fpGetThreadUICultureName)(rcLang, MAX_LANGPATH);
        
        if (len != 0) {
            _ASSERTE(len <= MAX_LANGPATH);
            rcLang[len] = '\\';
            rcLang[len+1] = '\0';
        }
    } else {
        rcLang[0] = 0;
    }

    // Try first in the same directory as this dll.
    DWORD ret;
    VERIFY(ret = WszGetModuleFileName(GetModuleInst(), rcPath, NumItems(rcPath)));
    if( !ret ) 
        return E_UNEXPECTED;
    SplitPath(rcPath, rcDrive, rcDir, 0, 0);

    rcDriveLen = Wszlstrlen(rcDrive);
    rcDirLen   = Wszlstrlen(rcDir);
    rcLangLen  = Wszlstrlen(rcLang);

    if (rcDriveLen + rcDirLen + rcLangLen + rcMscorrcLen + 1 <= rcPathSize)
    {
        Wszlstrcpy(rcPath, rcDrive);
        Wszlstrcpy(rcPath + rcDriveLen, rcDir);
        Wszlstrcpy(rcPath + rcDriveLen + rcDirLen, rcLang);
        Wszlstrcpy(rcPath + rcDriveLen + rcDirLen + rcLangLen, rcMscorrc);

        // Feedback for debugging to eliminate unecessary loads.
        DEBUG_STMT(DbgWriteEx(L"Loading %s to load strings.\n", rcPath));

        // Load the resource library as a data file, so that the OS doesn't have
        // to allocate it as code.  This only works so long as the file contains
        // only strings.
        fFail = ((*pHInst = WszLoadLibraryEx(rcPath, NULL, dwLoadLibraryFlags)) == 0);
    }

    // If we can't find the specific language implementation, try the language parent
    if (fFail)
    {
        if (m_fpGetThreadUICultureParentName)
        {
            int len = (*m_fpGetThreadUICultureParentName)(rcLang, MAX_LANGPATH);
        
            if (len != 0) {
                _ASSERTE(len <= MAX_LANGPATH);
                rcLang[len] = '\\';
                rcLang[len+1] = '\0';
            }
        } 

        else
            rcLang[0] = 0;

        rcLangLen = Wszlstrlen(rcLang);
        if (rcDriveLen + rcDirLen + rcLangLen + rcMscorrcLen + 1 <= rcPathSize) {

            Wszlstrcpy(rcPath, rcDrive);

            Wszlstrcpy(rcPath + rcDriveLen, rcDir);
            Wszlstrcpy(rcPath + rcDriveLen + rcDirLen, rcLang);
            Wszlstrcpy(rcPath + rcDriveLen + rcDirLen + rcLangLen, rcMscorrc);

            fFail = ((*pHInst = WszLoadLibraryEx(rcPath, NULL, dwLoadLibraryFlags)) == 0);
        }
    }
    
    // If we can't find the language specific one, just use what's in the root
    if (fFail) {
        if (rcDriveLen + rcDirLen + rcMscorrcLen + 1 < rcPathSize) {
            Wszlstrcpy(rcPath, rcDrive);
            Wszlstrcpy(rcPath + rcDriveLen, rcDir);
            Wszlstrcpy(rcPath + rcDriveLen + rcDirLen, rcMscorrc);
            fFail = ((*pHInst = WszLoadLibraryEx(rcPath, NULL, dwLoadLibraryFlags)) == 0);
        }
    }

    // Last ditch search effort in current directory
    if (fFail) {
        fFail = ((*pHInst = WszLoadLibraryEx(rcMscorrc, NULL, dwLoadLibraryFlags)) == 0);
    }

    if (fFail) {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\format1.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/* routines for parsing file format stuff ... */
/* this is split off from format.cpp because this uses meta-data APIs that
   are not present in many builds.  Thus if someone needs things in the format.cpp
   file but does not have the meta-data APIs, I want it to link */

#include "stdafx.h"
#include "cor.h"
#include "corPriv.h"

/***************************************************************************/
COR_ILMETHOD_DECODER::COR_ILMETHOD_DECODER(COR_ILMETHOD* header, void *pInternalImport, bool verify) {

	try {
        // Call the basic constructor   
		this->COR_ILMETHOD_DECODER::COR_ILMETHOD_DECODER(header);
	} catch (...) { 
		Code = 0; 
		LocalVarSigTok = 0; 
	}

        // If there is a local variable sig, fetch it into 'LocalVarSig'    
    if (LocalVarSigTok && pInternalImport)
    {
        IMDInternalImport* pMDI = reinterpret_cast<IMDInternalImport*>(pInternalImport);

        if (verify) {
            if ((!pMDI->IsValidToken(LocalVarSigTok)) || (TypeFromToken(LocalVarSigTok) != mdtSignature)
				|| (RidFromToken(LocalVarSigTok)==0)) {
                Code = 0;      // failure bad local variable signature token
                return;
            }
        }
        
        DWORD cSig = 0; 
        LocalVarSig = pMDI->GetSigFromToken((mdSignature) LocalVarSigTok, &cSig); 
        
        if (verify) {
            if (!SUCCEEDED(validateTokenSig(LocalVarSigTok, LocalVarSig, cSig, 0, pMDI)) ||
                *LocalVarSig != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG) {
                Code = 0;
                return;
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\fusionbind.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: FusionBind.cpp
**
** Purpose: Implements fusion interface
**
** Date:  Dec 1, 1998
**
===========================================================*/

#include "stdafx.h"
#include <stdlib.h>
#include "UtilCode.h"
#include "FusionBind.h"
#include "ShimLoad.h"
#include "timeline.h"

BOOL STDMETHODCALLTYPE
BeforeFusionShutdown()
{
    return FusionBind::BeforeFusionShutdown();
}

void STDMETHODCALLTYPE
DontReleaseFusionInterfaces()
{
    FusionBind::DontReleaseFusionInterfaces();
}

void CodeBaseInfo::ReleaseParent()
{
    if(m_pParentAssembly && FusionBind::BeforeFusionShutdown()) {
        m_pParentAssembly->Release();
        m_pParentAssembly = NULL;
    }
}

BOOL FusionBind::m_fBeforeFusionShutdown    = TRUE;

FusionBind::~FusionBind()
{
    if (m_ownedFlags & NAME_OWNED)
        delete [] (void *) m_pAssemblyName;
    if (m_ownedFlags & PUBLIC_KEY_OR_TOKEN_OWNED)
        delete [] m_pbPublicKeyOrToken;
    if (m_ownedFlags & CODE_BASE_OWNED)
        delete [] (void *) m_CodeInfo.m_pszCodeBase;
    if (m_ownedFlags & LOCALE_OWNED)
        delete [] (void *) m_context.szLocale;
}

HRESULT FusionBind::Init(LPCSTR pAssemblyName,
                         AssemblyMetaDataInternal* pContext, 
                         PBYTE pbPublicKeyOrToken, DWORD cbPublicKeyOrToken,
                         DWORD dwFlags)
{
    _ASSERTE(pContext);

    m_pAssemblyName = pAssemblyName;
    m_pbPublicKeyOrToken = pbPublicKeyOrToken;
    m_cbPublicKeyOrToken = cbPublicKeyOrToken;
    m_dwFlags = dwFlags;
    m_ownedFlags = 0;

    m_context = *pContext;
    m_fParsed = TRUE;

    return S_OK;
}

HRESULT FusionBind::Init(LPCSTR pAssemblyDisplayName)
{
    m_pAssemblyName = pAssemblyDisplayName;
    m_fParsed = FALSE;
    return S_OK;
}

HRESULT FusionBind::CloneFields(int ownedFlags)
{
#if _DEBUG
    DWORD hash = Hash();
#endif

    if ((~m_ownedFlags & NAME_OWNED) && (ownedFlags & NAME_OWNED) &&
        m_pAssemblyName) {
        LPSTR temp = new char [strlen(m_pAssemblyName) + 1];
        if (temp == NULL)
            return E_OUTOFMEMORY;
        strcpy(temp, m_pAssemblyName);
        m_pAssemblyName = temp;
        m_ownedFlags |= NAME_OWNED;
    }

    if ((~m_ownedFlags & PUBLIC_KEY_OR_TOKEN_OWNED) && 
        (ownedFlags & PUBLIC_KEY_OR_TOKEN_OWNED) && m_cbPublicKeyOrToken > 0) {
        BYTE *temp = new BYTE [m_cbPublicKeyOrToken];
        if (temp == NULL)
            return E_OUTOFMEMORY;
        memcpy(temp, m_pbPublicKeyOrToken, m_cbPublicKeyOrToken);
        m_pbPublicKeyOrToken = temp;
        m_ownedFlags |= PUBLIC_KEY_OR_TOKEN_OWNED;
    }

    if ((~m_ownedFlags & CODE_BASE_OWNED) && 
        (ownedFlags & CODE_BASE_OWNED) && m_CodeInfo.m_dwCodeBase > 0) {
        LPWSTR temp = new WCHAR [m_CodeInfo.m_dwCodeBase];
        if (temp == NULL)
            return E_OUTOFMEMORY;
        wcscpy(temp, m_CodeInfo.m_pszCodeBase);
        m_CodeInfo.m_pszCodeBase = temp;
        m_ownedFlags |= CODE_BASE_OWNED;
    }

    if ((~m_ownedFlags & LOCALE_OWNED) && (ownedFlags & LOCALE_OWNED) &&
        m_context.szLocale) {
        LPSTR temp = new char [strlen(m_context.szLocale) + 1];
        if (temp == NULL)
            return E_OUTOFMEMORY;
        strcpy(temp, m_context.szLocale);
        m_context.szLocale = temp;
        m_ownedFlags |= LOCALE_OWNED;
    }

    _ASSERTE(hash == Hash());

    return S_OK;
}

HRESULT FusionBind::CloneFieldsToLoaderHeap(int ownedFlags, LoaderHeap *pHeap)
{
#if _DEBUG
    DWORD hash = Hash();
#endif

    if ((~m_ownedFlags & NAME_OWNED) && (ownedFlags & NAME_OWNED) &&
        m_pAssemblyName) {
        LPSTR temp = (LPSTR) pHeap->AllocMem(strlen(m_pAssemblyName) + 1);
        if (temp == NULL)
            return E_OUTOFMEMORY;
        strcpy(temp, m_pAssemblyName);
        m_pAssemblyName = temp;
    }

    if ((~m_ownedFlags & PUBLIC_KEY_OR_TOKEN_OWNED) && 
        (ownedFlags & PUBLIC_KEY_OR_TOKEN_OWNED) && m_cbPublicKeyOrToken > 0) {
        BYTE *temp = (BYTE *) pHeap->AllocMem(m_cbPublicKeyOrToken);
        if (temp == NULL)
            return E_OUTOFMEMORY;
        memcpy(temp, m_pbPublicKeyOrToken, m_cbPublicKeyOrToken);
        m_pbPublicKeyOrToken = temp;
    }

    if ((~m_ownedFlags & CODE_BASE_OWNED) && 
        (ownedFlags & CODE_BASE_OWNED) && m_CodeInfo.m_dwCodeBase > 0) {
        LPWSTR temp = (WCHAR *) pHeap->AllocMem(m_CodeInfo.m_dwCodeBase * sizeof(WCHAR));
        if (temp == NULL)
            return E_OUTOFMEMORY;
        wcscpy(temp, m_CodeInfo.m_pszCodeBase);
        m_CodeInfo.m_pszCodeBase = temp;
    }

    if ((~m_ownedFlags & LOCALE_OWNED) && (ownedFlags & LOCALE_OWNED) &&
        m_context.szLocale) {
        LPSTR temp = (char *) pHeap->AllocMem(strlen(m_context.szLocale) + 1);
        if (temp == NULL)
            return E_OUTOFMEMORY;
        strcpy(temp, m_context.szLocale);
        m_context.szLocale = temp;
    }

    _ASSERTE(hash == Hash());

    return S_OK;
}

HRESULT FusionBind::Init(IAssemblyName *pName)
{
    _ASSERTE(pName);

    HRESULT hr;
   
    // Fill out info from name, if we have it.

    DWORD cbSize = 0;
    if (pName->GetProperty(ASM_NAME_NAME, NULL, &cbSize) 
        == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        CQuickBytes qb;
        LPWSTR pwName = (LPWSTR) qb.Alloc(cbSize);

        IfFailRet(pName->GetProperty(ASM_NAME_NAME, pwName, &cbSize));

        cbSize = WszWideCharToMultiByte(CP_UTF8, 0, pwName, -1, NULL, 0, NULL, NULL);

        m_pAssemblyName = new char[cbSize];
        if (!m_pAssemblyName)
            return E_OUTOFMEMORY;

        m_ownedFlags |= NAME_OWNED;
        if(!WszWideCharToMultiByte(CP_UTF8, 0, pwName, -1, (LPSTR) m_pAssemblyName, cbSize, NULL, NULL))
            return HRESULT_FROM_WIN32(GetLastError());

    }

    m_fParsed = TRUE;

    // Note: cascade checks so we don't set lower priority version #'s if higher ones are missing
    cbSize = sizeof(m_context.usMajorVersion);
    pName->GetProperty(ASM_NAME_MAJOR_VERSION, &m_context.usMajorVersion, &cbSize);

    if (!cbSize)
        m_context.usMajorVersion = -1;
    else {
        cbSize = sizeof(m_context.usMinorVersion);
        pName->GetProperty(ASM_NAME_MINOR_VERSION, &m_context.usMinorVersion, &cbSize);
    }

    if (!cbSize)
        m_context.usMinorVersion = -1;
    else {
        cbSize = sizeof(m_context.usBuildNumber);
        pName->GetProperty(ASM_NAME_BUILD_NUMBER, &m_context.usBuildNumber, &cbSize);
    }

    if (!cbSize)
        m_context.usBuildNumber = -1;
    else {
        cbSize = sizeof(m_context.usRevisionNumber);
        pName->GetProperty(ASM_NAME_REVISION_NUMBER, &m_context.usRevisionNumber, &cbSize);
    }

    if (!cbSize)
        m_context.usRevisionNumber = -1;

    cbSize = 0;
    if (pName->GetProperty(ASM_NAME_CULTURE, NULL, &cbSize)
        == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        LPWSTR pwName = (LPWSTR) alloca(cbSize);
        IfFailRet(pName->GetProperty(ASM_NAME_CULTURE, pwName, &cbSize));

        cbSize = WszWideCharToMultiByte(CP_UTF8, 0, pwName, -1, NULL, 0, NULL, NULL);

        m_context.szLocale = new char [cbSize];
        if (!m_context.szLocale)
            return E_OUTOFMEMORY;
        m_ownedFlags |= LOCALE_OWNED;
        if (!WszWideCharToMultiByte(CP_UTF8, 0, pwName, -1, (LPSTR) m_context.szLocale, cbSize, NULL, NULL))        
            return HRESULT_FROM_WIN32(GetLastError());                                                    
    }

    m_dwFlags = 0;

    cbSize = 0;
    if (pName->GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, NULL, &cbSize)
        == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        m_pbPublicKeyOrToken = new BYTE[cbSize];
        if (m_pbPublicKeyOrToken == NULL)
            return E_OUTOFMEMORY;
        m_cbPublicKeyOrToken = cbSize;
        IfFailRet(pName->GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, m_pbPublicKeyOrToken, &cbSize));
        m_ownedFlags |= PUBLIC_KEY_OR_TOKEN_OWNED;           
    }
    else if (pName->GetProperty(ASM_NAME_PUBLIC_KEY, NULL, &cbSize)
             == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        // @todo: we need to normalize this into a public key token so
        // comparisons work correctly. But this involves binding to mscorsn.
        m_pbPublicKeyOrToken = new BYTE[cbSize];
        if (m_pbPublicKeyOrToken == NULL)
            return E_OUTOFMEMORY;
        m_cbPublicKeyOrToken = cbSize;
        IfFailRet(pName->GetProperty(ASM_NAME_PUBLIC_KEY, m_pbPublicKeyOrToken, &cbSize));
        m_dwFlags |= afPublicKey;
        m_ownedFlags |= PUBLIC_KEY_OR_TOKEN_OWNED;           
    }
    else if ((pName->GetProperty(ASM_NAME_NULL_PUBLIC_KEY, NULL, &cbSize) == S_OK) ||
             (pName->GetProperty(ASM_NAME_NULL_PUBLIC_KEY_TOKEN, NULL, &cbSize) == S_OK)) {
        m_pbPublicKeyOrToken = new BYTE[0];
        if (m_pbPublicKeyOrToken == NULL)
            return E_OUTOFMEMORY;
        m_cbPublicKeyOrToken = 0;
        m_ownedFlags |= PUBLIC_KEY_OR_TOKEN_OWNED;           
    }

    // Recover the afRetargetable flag
    BOOL bRetarget;
    cbSize = sizeof(bRetarget);
    hr = pName->GetProperty(ASM_NAME_RETARGET, &bRetarget, &cbSize);
    if (hr == S_OK && cbSize != 0 && bRetarget)
        m_dwFlags |= afRetargetable;

    cbSize = 0;
    if (pName->GetProperty(ASM_NAME_CODEBASE_URL, NULL, &cbSize)
        == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        m_CodeInfo.m_pszCodeBase = new WCHAR [ cbSize/sizeof(WCHAR) ];
        if (m_CodeInfo.m_pszCodeBase == NULL)
            return E_OUTOFMEMORY;
        IfFailRet(pName->GetProperty(ASM_NAME_CODEBASE_URL, 
                                    (void*)m_CodeInfo.m_pszCodeBase, &cbSize));
        m_CodeInfo.m_dwCodeBase = cbSize/sizeof(WCHAR);
        m_ownedFlags |= CODE_BASE_OWNED;
    }

    return S_OK;
}

HRESULT FusionBind::Init(FusionBind *pSpec, BOOL bClone)
{
    m_CodeInfo.m_pszCodeBase = pSpec->m_CodeInfo.m_pszCodeBase;
    m_CodeInfo.m_dwCodeBase = pSpec->m_CodeInfo.m_dwCodeBase;
    m_CodeInfo.SetParentAssembly(pSpec->m_CodeInfo.GetParentAssembly());

    HRESULT hr;
    if (pSpec->m_fParsed)
        hr = Init(pSpec->m_pAssemblyName, 
                  &pSpec->m_context,
                  pSpec->m_pbPublicKeyOrToken, 
                  pSpec->m_cbPublicKeyOrToken,
                  pSpec->m_dwFlags);
    else
        hr = Init(pSpec->m_pAssemblyName); 

    if (SUCCEEDED(hr)&& bClone )
        hr = CloneFields(pSpec->m_ownedFlags);

    _ASSERTE(Hash() == pSpec->Hash());
    _ASSERTE(Compare(pSpec));

    return hr;
}

HRESULT FusionBind::ParseName()
{
    HRESULT hr = S_OK;

    if (m_fParsed || !m_pAssemblyName)
        return S_OK;

    TIMELINE_START(FUSIONBIND, ("ParseName %s", m_pAssemblyName));

    IAssemblyName *pName;

    CQuickBytes qb;
    long pwNameLen = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, 0, 0);
    if(pwNameLen == 0)
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    LPWSTR pwName = (LPWSTR) qb.Alloc(pwNameLen*sizeof(WCHAR));

    if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, pwName, pwNameLen))
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    IfFailGo(CreateAssemblyNameObject(&pName, pwName, CANOF_PARSE_DISPLAY_NAME, NULL));

    if (m_ownedFlags & NAME_OWNED)
        delete [] (void *) m_pAssemblyName;
    m_pAssemblyName = NULL;

    hr = Init(pName);

    pName->Release();

 ErrExit:
    TIMELINE_END(FUSIONBIND, ("ParseName %s", m_pAssemblyName));
    return hr;
}

// Cheezy serialization code.
template<class T>void pad_v(PBYTE &pb) 
{
    while (((ULONG)pb)&3) 
        ++pb;
}
template<class T>void put_v(PBYTE &pb, T v) 
{
    *(T UNALIGNED *)pb = v; 
    pb += sizeof(T);
}
template<class T>void get_v(PBYTE &pb, T &v) 
{
    v = *(T UNALIGNED *)pb; 
    pb += sizeof(T);
}
template<class T>void put_n_v(PBYTE &pb, ULONG n, T *v) 
{   
    put_v(pb, n); 
    pad_v<T>(pb); 
    while (n--) 
        put_v(pb, *v++);
}
template<class T>void get_n_v(PBYTE &pb, ULONG &n, T *&v) 
{   
    get_v(pb, n); 
    pad_v<T>(pb); 
    v = (T*)pb; 
    pb += n * sizeof(T);
}
void put_v(PBYTE &pb, PBYTE pv, DWORD cb) 
{
    put_v(pb, cb); 
    memcpy(pb, pv, cb); 
    pb += cb;
}
void get_v(PBYTE &pb, PBYTE &pv, DWORD &cb) 
{
    get_v(pb, cb); 
    pv = pb; 
    pb += cb;
}
void put_v(PBYTE &pb, LPCSTR ps) 
{
    int i=ps?strlen(ps):0; 
    memcpy(pb, ps, i); 
    pb += i; 
    *pb++ = 0;
}
void get_v(PBYTE &pb, LPCSTR &ps) 
{
    ps = (LPCSTR)pb; 
    pb += strlen(ps)+1;
}

// Truly ghastly code to read/store as a blob of data.  Embedded pointers
//  to non-owned storage, etc.
HRESULT FusionBind::Init(PBYTE pbBuf, DWORD cbData)
{
    PBYTE pbOrg = pbBuf;
    
    // Version.
    ULONG ver;
    get_v(pbBuf, ver);
    if (ver != 1) {
        _ASSERTE(!"TypeLib assemblyref string version mismatch");
        return E_INVALIDARG;
    }
    // m_fParsed
    get_v(pbBuf, m_fParsed);
    // PublicKeyOrToken
    get_v(pbBuf, m_pbPublicKeyOrToken, m_cbPublicKeyOrToken);
    // Flags
    get_v(pbBuf, m_dwFlags);
    // AssemblyName
    get_v(pbBuf, m_pAssemblyName);
    
    // Ignore codebase.
    memset(&m_CodeInfo, 0, sizeof(m_CodeInfo));
    
    // Context.
    if (m_fParsed) {
        // version numbers.
        get_v(pbBuf, m_context.usMajorVersion);
        get_v(pbBuf, m_context.usMinorVersion);
        get_v(pbBuf, m_context.usBuildNumber);
        get_v(pbBuf, m_context.usRevisionNumber);
        // Locale
        get_v(pbBuf, m_context.szLocale);
    }
    
    // If we ran out of buffer (and somehow didn't crash!) return an error.
    if (((int)(pbBuf - pbOrg)) > ((int)cbData))
        return E_INVALIDARG;
    
    return S_OK;
} // HRESULT FusionBind::Init()

HRESULT FusionBind::Save(PBYTE pbBuf, DWORD cbBuf, DWORD *pcbReq)
{
    DWORD       cbReq=0;
    // Compute the size required.
    cbReq = sizeof(m_fParsed)
        + m_cbPublicKeyOrToken + sizeof(m_cbPublicKeyOrToken)
        + sizeof(m_dwFlags)
        + 1 + (m_pAssemblyName?strlen(m_pAssemblyName):0);
        // Assembly MetaData (context)
    if (m_fParsed)
        cbReq = cbReq
        + sizeof(AssemblyMetaDataInternal)
        + 1 + (m_context.szLocale?strlen(m_context.szLocale):0)
    ;
        
    *pcbReq = cbReq;
    if (cbReq > cbBuf)
        return S_FALSE;
    
    // Persist the junk.  MUST MATCH WITH ABOVE.
    ULONG ver=1;
    put_v(pbBuf, ver);
    // m_fParsed
    put_v(pbBuf, m_fParsed);
    // PublicKeyOrToken
    put_v(pbBuf, m_pbPublicKeyOrToken, m_cbPublicKeyOrToken);
    // Flags
    put_v(pbBuf, m_dwFlags);
    // AssemblyName
    put_v(pbBuf, m_pAssemblyName);
    
    
    // Ignore codebase.
    
    // Context.
    if (m_fParsed) {
        // version numbers.
        put_v(pbBuf, m_context.usMajorVersion);
        put_v(pbBuf, m_context.usMinorVersion);
        put_v(pbBuf, m_context.usBuildNumber);
        put_v(pbBuf, m_context.usRevisionNumber);
        // Locale
        put_v(pbBuf, m_context.szLocale);
    }
    
    return S_OK;
} // HRESULT FusionBind::Save()
    

void FusionBind::SetCodeBase(LPCWSTR szCodeBase, DWORD dwCodeBase)
{
    _ASSERTE(szCodeBase == 0 || wcslen(szCodeBase) + 1 == dwCodeBase);     // length includes terminator 
    m_CodeInfo.m_pszCodeBase = szCodeBase;
    m_CodeInfo.m_dwCodeBase = dwCodeBase;
}

DWORD FusionBind::Hash()
{
    DWORD hash = 0;

    // Normalize representation
    if (!m_fParsed)
        ParseName();


    // Hash fields.

    if (m_pAssemblyName)
        hash ^= HashStringA(m_pAssemblyName);
    hash = _rotl(hash, 4);

    hash ^= HashBytes(m_pbPublicKeyOrToken, m_cbPublicKeyOrToken);
    hash = _rotl(hash, 4);
        
    hash ^= m_dwFlags;
    hash = _rotl(hash, 4);

    if (m_CodeInfo.m_pszCodeBase)
        hash ^= HashString(m_CodeInfo.m_pszCodeBase);
    hash = _rotl(hash, 4);

    hash ^= m_context.usMajorVersion;
    hash = _rotl(hash, 8);

    if (m_context.usMajorVersion != (USHORT) -1) {
        hash ^= m_context.usMinorVersion;
        hash = _rotl(hash, 8);
        
        if (m_context.usMinorVersion != (USHORT) -1) {
            hash ^= m_context.usBuildNumber;
            hash = _rotl(hash, 8);
        
            if (m_context.usBuildNumber != (USHORT) -1) {
                hash ^= m_context.usRevisionNumber;
                hash = _rotl(hash, 8);
            }
        }
    }

    if (m_context.szLocale)
        hash ^= HashStringA(m_context.szLocale);
    hash = _rotl(hash, 4);

    hash ^= m_CodeInfo.m_fLoadFromParent;

    return hash;
}


BOOL FusionBind::Compare(FusionBind *pSpec)
{
    // Normalize representations
    if (!m_fParsed)
        ParseName();
    if (!pSpec->m_fParsed)
        pSpec->ParseName();


    // Compare fields

    if (m_CodeInfo.m_fLoadFromParent != pSpec->m_CodeInfo.m_fLoadFromParent)
        return 0;

    if (m_pAssemblyName != pSpec->m_pAssemblyName
        && (m_pAssemblyName == NULL || pSpec->m_pAssemblyName == NULL
            || strcmp(m_pAssemblyName, pSpec->m_pAssemblyName)))
        return 0;

    if (m_cbPublicKeyOrToken != pSpec->m_cbPublicKeyOrToken
        || memcmp(m_pbPublicKeyOrToken, pSpec->m_pbPublicKeyOrToken, m_cbPublicKeyOrToken))
        return 0;

    if (m_dwFlags != pSpec->m_dwFlags)
        return 0;

    if (m_CodeInfo.m_pszCodeBase != pSpec->m_CodeInfo.m_pszCodeBase
        && (m_CodeInfo.m_pszCodeBase == NULL || pSpec->m_CodeInfo.m_pszCodeBase == NULL
            || wcscmp(m_CodeInfo.m_pszCodeBase, pSpec->m_CodeInfo.m_pszCodeBase)))
        return 0;

    if (m_context.usMajorVersion != pSpec->m_context.usMajorVersion)
        return 0;

    if (m_context.usMajorVersion != (USHORT) -1) {
        if (m_context.usMinorVersion != pSpec->m_context.usMinorVersion)
            return 0;

        if (m_context.usMinorVersion != (USHORT) -1) {
            if (m_context.usBuildNumber != pSpec->m_context.usBuildNumber)
                return 0;
            
            if (m_context.usBuildNumber != (USHORT) -1) {
                if (m_context.usRevisionNumber != pSpec->m_context.usRevisionNumber)
                    return 0;
            }
        }
    }

    if (m_context.szLocale != pSpec->m_context.szLocale
        && (m_context.szLocale == NULL || pSpec->m_context.szLocale == NULL
            || strcmp(m_context.szLocale, pSpec->m_context.szLocale)))
        return 0;

    return 1;
}

#ifdef FUSION_SUPPORTED
HRESULT FusionBind::CreateFusionName(IAssemblyName **ppName, BOOL fIncludeHash)
{
    TIMELINE_START(FUSIONBIND, ("CreateFusionName %s", m_pAssemblyName));

    HRESULT hr;
    IAssemblyName *pFusionAssemblyName = NULL;
    LPWSTR pwAssemblyName = NULL;
    CQuickBytes qb;

    if (m_pAssemblyName) {
        long pwNameLen = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, 0, 0);
     if(pwNameLen==0)
         IfFailGo(HRESULT_FROM_WIN32(GetLastError()));
        pwAssemblyName = (LPWSTR) qb.Alloc(pwNameLen*sizeof(WCHAR));
        
        if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, pwAssemblyName, pwNameLen))
            IfFailGo(HRESULT_FROM_WIN32(GetLastError()));
    }

    IfFailGo(CreateAssemblyNameObject(&pFusionAssemblyName, pwAssemblyName, 
                                      m_fParsed || (!pwAssemblyName) ? 0 : CANOF_PARSE_DISPLAY_NAME, NULL));


    if (m_fParsed) {
        if (m_context.usMajorVersion != (USHORT) -1) {
            IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_MAJOR_VERSION, 
                                                      &m_context.usMajorVersion, 
                                                      sizeof(USHORT)));
            
            if (m_context.usMinorVersion != (USHORT) -1) {
                IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_MINOR_VERSION, 
                                                          &m_context.usMinorVersion, 
                                                          sizeof(USHORT)));
                
                if (m_context.usBuildNumber != (USHORT) -1) {
                    IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_BUILD_NUMBER, 
                                                              &m_context.usBuildNumber, 
                                                              sizeof(USHORT)));
                    
                    if (m_context.usRevisionNumber != (USHORT) -1)
                        IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_REVISION_NUMBER, 
                                                                  &m_context.usRevisionNumber, 
                                                                  sizeof(USHORT)));
                }
            }
        }
        
        if (m_context.szLocale) {
            MAKE_WIDEPTR_FROMUTF8(pwLocale,m_context.szLocale);
            
            IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_CULTURE, 
                                                      pwLocale, 
                                                      (DWORD)(wcslen(pwLocale) + 1) * sizeof (WCHAR)));
        }
        
        if (m_pbPublicKeyOrToken) {
            if (m_cbPublicKeyOrToken) {
                if(m_dwFlags & afPublicKey) {
                    IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_PUBLIC_KEY,
                                                              m_pbPublicKeyOrToken, m_cbPublicKeyOrToken));
                }
                else {
                        IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN,
                                                                  m_pbPublicKeyOrToken, m_cbPublicKeyOrToken));
                }
            }
            else {
                IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_NULL_PUBLIC_KEY_TOKEN,
                                                          NULL, 0));
            }
        }

        // See if the assembly[ref] is retargetable (ie, for a generic assembly).
        if (IsAfRetargetable(m_dwFlags)) {
            BOOL bTrue = TRUE;
            IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_RETARGET, 
                                                      &bTrue, sizeof(bTrue)));
        }

    }

    if (m_CodeInfo.m_dwCodeBase > 0) {
        IfFailGo(pFusionAssemblyName->SetProperty(ASM_NAME_CODEBASE_URL,
                                                  (void*)m_CodeInfo.m_pszCodeBase, 
                                                  m_CodeInfo.m_dwCodeBase*sizeof(WCHAR)));
    }

    *ppName = pFusionAssemblyName;

    TIMELINE_END(FUSIONBIND, ("CreateFusionName %s", m_pAssemblyName));

    return S_OK;

 ErrExit:
    if (pFusionAssemblyName)
        pFusionAssemblyName->Release();

    TIMELINE_END(FUSIONBIND, ("CreateFusionName %s", m_pAssemblyName));

    return hr;
}
#endif // FUSION_SUPPORTED

HRESULT FusionBind::EmitToken(IMetaDataAssemblyEmit *pEmit, 
                              mdAssemblyRef *pToken)
{
    HRESULT hr;
    ASSEMBLYMETADATA AMD;

    IfFailRet(ParseName());

    AMD.usMajorVersion = m_context.usMajorVersion;
    AMD.usMinorVersion = m_context.usMinorVersion;
    AMD.usBuildNumber = m_context.usBuildNumber;
    AMD.usRevisionNumber = m_context.usRevisionNumber;

    if (m_context.szLocale) {
        AMD.cbLocale = MultiByteToWideChar(CP_ACP, 0, m_context.szLocale, -1, NULL, 0);
        AMD.szLocale = (LPWSTR) alloca(AMD.cbLocale * sizeof(WCHAR) );
        MultiByteToWideChar(CP_ACP, 0, m_context.szLocale, -1, AMD.szLocale, AMD.cbLocale);
    }
    else {
        AMD.cbLocale = 0;
        AMD.szLocale = NULL;
    }

    long pwNameLen = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, 0, 0);
    if(pwNameLen==0)
        return HRESULT_FROM_WIN32(GetLastError());
    CQuickBytes qb;
    LPWSTR pwName = (LPWSTR) qb.Alloc(pwNameLen*sizeof(WCHAR));

    if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_pAssemblyName, -1, pwName, pwNameLen))
        return HRESULT_FROM_WIN32(GetLastError());
    return pEmit->DefineAssemblyRef(m_pbPublicKeyOrToken, m_cbPublicKeyOrToken,
                                    pwName,
                                    &AMD,
                                    NULL, 0,
                                    m_dwFlags, pToken);
}

#ifdef FUSION_SUPPORTED
HRESULT FusionBind::LoadAssembly(IApplicationContext* pFusionContext,
                                 IAssembly** ppFusionAssembly)
{
    HRESULT hr;

    TIMELINE_START(FUSIONBIND, ("LoadAssembly %s", m_pAssemblyName));

    IAssemblyName* pFusionAssemblyName = NULL;    

    IfFailGo(CreateFusionName(&pFusionAssemblyName));

    hr = GetAssemblyFromFusion(pFusionContext,
                               NULL,
                               pFusionAssemblyName,
                               &m_CodeInfo,
                               ppFusionAssembly);

 ErrExit:
    if(pFusionAssemblyName)
        pFusionAssemblyName->Release();

    TIMELINE_END(FUSIONBIND, ("LoadAssembly %s", m_pAssemblyName));

    return hr;
}
#endif // FUSION_SUPPORTED


#ifdef FUSION_SUPPORTED
HRESULT FusionBind::GetAssemblyFromFusion(IApplicationContext* pFusionContext,
                                          FusionSink* pSink,
                                          IAssemblyName* pFusionAssemblyName,
                                          CodeBaseInfo* pCodeBase,
                                          IAssembly** ppFusionAssembly)
{
    FusionSink *pLocalSink = NULL;
    if(pSink == NULL) {
        pSink = new FusionSink();

        if(pSink == NULL) 
            return E_OUTOFMEMORY;
    }
    else
        pSink->AddRef();

    HRESULT hr = RemoteLoad(pCodeBase, 
                            pFusionContext,
                            pFusionAssemblyName, 
                            pSink, 
                            ppFusionAssembly);

    pSink->Release();
    return hr;
}
#endif // FUSION_SUPPORTED



#ifdef FUSION_SUPPORTED
HRESULT FusionBind::RemoteLoad(CodeBaseInfo* pCodeBase,
                               IApplicationContext* pFusionContext,
                               LPASSEMBLYNAME pName,
                               FusionSink *pSink,
                               IAssembly** ppFusionAssembly)

{
    TIMELINE_START(FUSIONBIND, ("RemoteLoad"));

    _ASSERTE(pCodeBase);
    _ASSERTE(ppFusionAssembly); // The resulting IP must be held so the assembly will not be scavenged.
    _ASSERTE(pName);

    HRESULT hr;

    if (m_pAssemblyName)
        IfFailGo(VerifyBindingString(m_pAssemblyName));

    if (m_context.szLocale)
        IfFailGo(VerifyBindingString(m_context.szLocale));

    LONGLONG dwFlags = 0;
    DWORD dwReserved = 0;
    LPVOID pReserved = NULL;

    // Find the code base if it exists
    if(pCodeBase->GetParentAssembly()) {
        dwReserved = sizeof(IAssembly*);
        pReserved = (LPVOID) pCodeBase->GetParentAssembly();
        dwFlags |= ASM_BINDF_PARENT_ASM_HINT;
    }
    pSink->AssemblyResetEvent();
    hr = pName->BindToObject(IID_IAssembly,
                             pSink,
                             pFusionContext,
                             pCodeBase->m_pszCodeBase,
                             dwFlags,
                             pReserved,
                             dwReserved,
                             (void**) ppFusionAssembly);
    if(hr == E_PENDING) {
        // If there is an assembly IP then we were successful.
        pSink->Wait();
        hr = pSink->LastResult();
        if(pSink->m_punk && SUCCEEDED(hr)) {
            // Keep a handle to ensure it does not disappear from the cache
            // and allow access to modules associated with the assembly.
            hr = pSink->m_punk->QueryInterface(IID_IAssembly, 
                                               (void**) ppFusionAssembly);
            
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

 ErrExit:
    TIMELINE_END(FUSIONBIND, ("RemoteLoad"));
    return hr;
}
#endif // FUSION_SUPPORTED

#ifdef FUSION_SUPPORTED
/*static*/
HRESULT FusionBind::RemoteLoadModule(IApplicationContext * pFusionContext, 
                                     IAssemblyModuleImport* pModule, 
                                     FusionSink *pSink,
                                     IAssemblyModuleImport** pResult)
{
    _ASSERTE(pFusionContext && pModule && pResult);

    if(pSink == NULL) {
        pSink = new FusionSink();
    
        if(pSink == NULL) 
            return E_OUTOFMEMORY;
    }
    else
        pSink->AddRef();
    
    TIMELINE_START(FUSIONBIND, ("RemoteLoadModule"));

    pSink->AssemblyResetEvent();
    HRESULT hr = pModule->BindToObject(pSink,
                                       pFusionContext,
                                       0,
                                       (void**) pResult);
    if(hr == E_PENDING) {
        // If there is an assembly IP then we were successful.
        pSink->Wait();
        hr = pSink->LastResult();
        if(pSink->m_punk && SUCCEEDED(hr)) {
            hr = pSink->m_punk->QueryInterface(IID_IAssemblyModuleImport, 
                                               (void**) pResult);
            
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TIMELINE_END(FUSIONBIND, ("RemoteLoadModule"));

    return hr;
}
#endif // FUSION_SUPPORTED


#ifdef FUSION_SUPPORTED
/*static*/
HRESULT FusionBind::AddEnvironmentProperty(LPWSTR variable, 
                                           LPWSTR pProperty, 
                                           IApplicationContext* pFusionContext)
{
    _ASSERTE(pProperty);
    _ASSERTE(variable);

    DWORD size = _MAX_PATH;
    WCHAR rcValue[_MAX_PATH];    // Buffer for the directory.
    WCHAR *pValue = &(rcValue[0]);
    size = WszGetEnvironmentVariable(variable, pValue, size);
    if(size > _MAX_PATH) {
        pValue = (WCHAR*) _alloca(size * sizeof(WCHAR));
        size = WszGetEnvironmentVariable(variable, pValue, size);
        size++; // Add in the null terminator
    }

    if(size) {
        pFusionContext->Set(pProperty,
                            pValue,
                            size * sizeof(WCHAR),
                            0);
        return S_OK;
    }
    else 
        return S_FALSE; // no variable found
}
#endif // FUSION_SUPPORTED

// Fusion uses a context class to drive resolution of assemblies.
// Each application has properties that can be pushed into the
// fusion context (see fusionp.h). The public api is part of
// application domains.
#ifdef FUSION_SUPPORTED
/*static*/
HRESULT FusionBind::SetupFusionContext(LPCWSTR szAppBase,
                                       LPCWSTR szPrivateBin,
                                       IApplicationContext** ppFusionContext)
{
    TIMELINE_START_SAFE(FUSIONBIND, ("SetupFusionContext %S", szAppBase));

    HRESULT hr;
    _ASSERTE(ppFusionContext);

    LPCWSTR pBase;
    // if the appbase is null then use the current directory
    if (szAppBase == NULL) {
        pBase = (LPCWSTR) _alloca(_MAX_PATH * sizeof(WCHAR));
        WszGetCurrentDirectory(_MAX_PATH, (LPWSTR) pBase);
    }
    else
        pBase = szAppBase;

    if (SUCCEEDED(hr = CreateFusionContext(pBase, ppFusionContext))) {
        
        (*ppFusionContext)->Set(ACTAG_APP_BASE_URL,
                            (void*) pBase,
                            (DWORD)(wcslen(pBase) + 1) * sizeof(WCHAR),
                            0);
        
        if (szPrivateBin)
            (*ppFusionContext)->Set(ACTAG_APP_PRIVATE_BINPATH,
                                (void*) szPrivateBin,
                                (DWORD)(wcslen(szPrivateBin) + 1) * sizeof(WCHAR),
                                0);
        else
            AddEnvironmentProperty(APPENV_RELATIVEPATH, ACTAG_APP_PRIVATE_BINPATH, *ppFusionContext);

    }
    
    TIMELINE_END(FUSIONBIND, ("SetupFusionContext %S", szAppBase));

    return hr;
}
#endif // FUSION_SUPPORTED

#ifdef FUSION_SUPPORTED
/*static*/
HRESULT FusionBind::CreateFusionContext(LPCWSTR pzName, IApplicationContext** ppFusionContext)
{
    TIMELINE_START(FUSIONBIND, ("CreateFusionContext %S", pzName));

    _ASSERTE(ppFusionContext);
    
    // This is a file name not a namespace
    LPCWSTR contextName = NULL;

    if(pzName) {
        contextName = wcsrchr( pzName, L'\\' );
        if(contextName)
            contextName++;
        else
            contextName = pzName;
    }
    // We go off and create a fusion context for this application domain.
    // Note, once it is made it can not be modified.
    IAssemblyName *pFusionAssemblyName = NULL;
    HRESULT hr = CreateAssemblyNameObject(&pFusionAssemblyName, contextName, 0, NULL);

    if(SUCCEEDED(hr)) {
        hr = CreateApplicationContext(pFusionAssemblyName, ppFusionContext);
        pFusionAssemblyName->Release();
    }
    
    if(pzName)
        TIMELINE_END(FUSIONBIND, ("CreateFusionContext %S", pzName));
    else
        TIMELINE_END(FUSIONBIND, ("CreateFusionContext <unknown>"));

    return hr;
}
#endif // FUSION_SUPPORTED
 
/*static*/
HRESULT FusionBind::GetVersion(LPWSTR pVersion, DWORD* pdwVersion)
{
    HRESULT hr;
    WCHAR pCORSystem[_MAX_PATH];
    DWORD dwCORSystem = _MAX_PATH;
    
    pCORSystem[0] = L'\0';
    hr = GetInternalSystemDirectory(pCORSystem, &dwCORSystem);
    if(FAILED(hr)) return hr;

    if(dwCORSystem == 0) 
        return E_FAIL;

    dwCORSystem--; // remove the null character
    if(dwCORSystem && pCORSystem[dwCORSystem-1] == L'\\')
        dwCORSystem--; // and the trailing slash if it exists

    WCHAR* pSeparator;
    WCHAR* pTail = pCORSystem + dwCORSystem;
    for(pSeparator = pCORSystem+dwCORSystem-1; pSeparator > pCORSystem && *pSeparator != L'\\';pSeparator--);

    if(*pSeparator == L'\\')
        pSeparator++;
    
    DWORD lgth = pTail - pSeparator;
    if(lgth > *pdwVersion) {
        *pdwVersion = lgth+1;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    while(pSeparator < pTail) 
        *pVersion++ = *pSeparator++;

    *pVersion = L'\0';

    return S_OK;
}

// Used by the IMetaData API's to access an assembly's metadata. 
#ifdef FUSION_SUPPORTED
/*static*/
HRESULT 
FusionBind::FindAssemblyByName(LPCWSTR  szAppBase,
                               LPCWSTR  szPrivateBin,
                               LPCWSTR  szAssemblyName,
                               IAssembly** ppAssembly,
                               IApplicationContext** ppFusionContext)
{
    TIMELINE_START(FUSIONBIND, ("FindAssemblyByName %S", szAssemblyName));

    _ASSERTE(szAssemblyName);

    IApplicationContext *pFusionContext = NULL;

    MAKE_UTF8PTR_FROMWIDE(pName, szAssemblyName);
    FusionBind spec;

    spec.Init(pName);
    HRESULT hr = SetupFusionContext(szAppBase, szPrivateBin, &pFusionContext);
    if(SUCCEEDED(hr)) {
        IAssembly* fusionAssembly;
        hr = spec.LoadAssembly(pFusionContext, 
                               &fusionAssembly);
        
        *ppAssembly = fusionAssembly;
        
        if(ppFusionContext) 
            *ppFusionContext = pFusionContext;
        else if(pFusionContext)
            pFusionContext->Release();
    }

    TIMELINE_END(FUSIONBIND, ("FindAssemblyByName %S", szAssemblyName));

    return hr;
}
#endif // FUSION_SUPPORTED

#ifdef FUSION_SUPPORTED
/*static*/
HRESULT 
FusionBind::FindAssemblyByName(LPCWSTR  szAppBase,
                               LPCWSTR  szPrivateBin,
                               LPCWSTR  szAssemblyName,
                               LPWSTR   szName,           // [OUT] buffer - to hold name 
                               ULONG    cchName,          // [IN] the name buffer's size
                               ULONG    *pcName)          // [OUT] the number of characters returned in the buffer
{
    _ASSERTE(szAssemblyName);

    IApplicationContext *pFusionContext = NULL;
    IAssembly* fusionAssembly;
    HRESULT hr = FindAssemblyByName(szAppBase,
                                    szPrivateBin,
                                    szAssemblyName,
                                    &fusionAssembly,
                                    &pFusionContext);
    if (SUCCEEDED(hr)) {
        hr = fusionAssembly->GetManifestModulePath(szName,
                                                   &cchName);
        *pcName = cchName;
    }
    else 
        *pcName = 0;

    if(fusionAssembly)
        fusionAssembly->Release();
    if(pFusionContext)
        pFusionContext->Release();

    return hr;
}

#endif // FUSION_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\fusionsink.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
*============================================================
**
** Header:  FusionSink.cpp
**
** Purpose: Implements FusionSink, event objects that block 
**          the current thread waiting for an asynchronous load
**          of an assembly to succeed. 
**
** Date:  June 16, 1999
**
** Copyright (c) Microsoft, 1998
**
===========================================================*/

#include "stdafx.h"
#include <stdlib.h>
#include "UtilCode.h"
#include "FusionSink.h"

STDMETHODIMP FusionSink::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (riid == IID_IAssemblyBindSink)   
        *ppv = (IAssemblyBindSink*)this;
    if (*ppv == NULL)
        return E_NOINTERFACE;
    AddRef();   
    return S_OK;
}

STDMETHODIMP FusionSink::OnProgress(DWORD dwNotification,
                                    HRESULT hrNotification,
                                    LPCWSTR szNotification,
                                    DWORD dwProgress,
                                    DWORD dwProgressMax,
                                    IUnknown* punk)
{
    HRESULT hr = S_OK;
    switch(dwNotification) {
    case ASM_NOTIFICATION_DONE:
        m_LastResult = hrNotification;
		if(m_pAbortUnk) {
            m_pAbortUnk->Release();
            m_pAbortUnk = NULL;
		}

		if(punk && SUCCEEDED(hrNotification))
            hr = punk->QueryInterface(IID_IUnknown, (void**) &m_punk);
        SetEvent(m_hEvent);
        break;

    case ASM_NOTIFICATION_START:
        if(punk)
            hr = punk->QueryInterface(IID_IUnknown, (void**) &m_pAbortUnk);
        break;

    case ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE:
        if (szNotification) {
            m_fProbed = TRUE;

            if((m_fCheckCodeBase) && // If we didn't give Fusion the codebase
               (dwProgress == -1) && (dwProgressMax == -1)) { // but, Fusion has a codebase hint
                m_wszCodeBase.ReSize(wcslen(szNotification)+1);
                wcscpy(m_wszCodeBase.String(), szNotification);

                IAssemblyBinding* pBind;
                hr = m_pAbortUnk->QueryInterface(IID_IAssemblyBinding, (LPVOID*)&pBind);
                if (SUCCEEDED(hr)) {
                    // Abort the bind, so we can do a permission demand first
                    pBind->Control(E_ABORT);
                    pBind->Release();
                    m_fAborted = TRUE;
                    hr = E_ABORT;
                    m_pAbortUnk->Release();
                    m_pAbortUnk = NULL;
                }
            }
        }
        break;

    case ASM_NOTIFICATION_BIND_LOG:
        IFusionBindLog* pLog;
        pLog=NULL;
        try
        {
            if (pFusionLog&&punk)
            {
                hr=punk->QueryInterface(IID_IFusionBindLog,(LPVOID*)&pLog);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSize=0;
                    hr = pLog->GetBindLog(0,NULL,&dwSize);
                    if (hr==HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                    {
                        DWORD dwOldLen=pFusionLog->iSize;
                        if(SUCCEEDED(pFusionLog->ReSize(dwOldLen+dwSize)))
                            pLog->GetBindLog(0,pFusionLog->String()+dwOldLen,&dwSize);
                    }
                }
            }
        }
        catch(...)
        {}
        if(pLog)
            pLog->Release();
        break;
    default:
        break;
    }
    
    return hr;
}

ULONG FusionSink::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
}

ULONG FusionSink::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef) {
        Reset();
        delete this;
    }
    return (cRef);
}

HRESULT FusionSink::AssemblyResetEvent()
{
    HRESULT hr = AssemblyCreateEvent();
    if(FAILED(hr)) return hr;

    if(!ResetEvent(m_hEvent))
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

HRESULT FusionSink::AssemblyCreateEvent()
{
    HRESULT hr = S_OK;
    if(m_hEvent == NULL) {
        // Initialize the event to require manual reset
        // and to initially signaled.
        m_hEvent = WszCreateEvent(NULL, TRUE, TRUE, NULL);
        if(m_hEvent == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}

HRESULT FusionSink::Wait()
{
    HRESULT hr = S_OK;
    DWORD   dwReturn;
    do
    {   
        dwReturn =
            MsgWaitForMultipleObjects(  1,
                                        &m_hEvent,
                                        FALSE,
                                        100,
                                        QS_ALLINPUT);
        
        // if we got a message, dispatch it
        if (dwReturn == ( WAIT_OBJECT_0 + 1 )) {
            MSG msg;
            while (WszPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                WszDispatchMessage(&msg);
            }         
        }
    } while (dwReturn != WAIT_OBJECT_0); 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\debug.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Debug.cpp
//
// Helper code for debugging.
//*****************************************************************************
#include "stdafx.h"
#include "utilcode.h"

#ifdef _DEBUG
#define LOGGING
#endif


#include "log.h"

extern "C" _CRTIMP int __cdecl _flushall(void);

#ifdef _DEBUG

// On windows, we need to set the MB_SERVICE_NOTIFICATION bit on message
//  boxes, but that bit isn't defined under windows CE.  This bit of code
//  will provide '0' for the value, and if the value ever is defined, will
//  pick it up automatically.
#if defined(MB_SERVICE_NOTIFICATION)
 # define COMPLUS_MB_SERVICE_NOTIFICATION MB_SERVICE_NOTIFICATION
#else
 # define COMPLUS_MB_SERVICE_NOTIFICATION 0
#endif


//*****************************************************************************
// This struct tracks the asserts we want to ignore in the rest of this
// run of the application.
//*****************************************************************************
struct _DBGIGNOREDATA
{
    char        rcFile[_MAX_PATH];
    long        iLine;
    bool        bIgnore;
};

typedef CDynArray<_DBGIGNOREDATA> DBGIGNORE;
DBGIGNORE       grIgnore;



BOOL NoGuiOnAssert()
{
    static BOOL fFirstTime = TRUE;
    static BOOL fNoGui     = FALSE;

    if (fFirstTime)
    {
        fNoGui = REGUTIL::GetConfigDWORD(L"NoGuiOnAssert", 0);
        fFirstTime    = FALSE;
    }
    return fNoGui;

}   

BOOL DebugBreakOnAssert()
{
    static BOOL fFirstTime = TRUE;
    static BOOL fDebugBreak     = FALSE;

    if (fFirstTime)
    {
        fDebugBreak = REGUTIL::GetConfigDWORD(L"DebugBreakOnAssert", 0);
        fFirstTime    = FALSE;
    }
    return fDebugBreak;

}   

VOID TerminateOnAssert()
{
    ShutdownLogging();
    TerminateProcess(GetCurrentProcess(), 123456789);
}


VOID LogAssert(
    LPCSTR      szFile,
    int         iLine,
    LPCSTR      szExpr
)
{

    SYSTEMTIME st;
    GetLocalTime(&st);

    WCHAR exename[300];
    WszGetModuleFileName(WszGetModuleHandle(NULL), exename, sizeof(exename)/sizeof(WCHAR));

    LOG((LF_ASSERT,
         LL_FATALERROR,
         "FAILED ASSERT(PID %d [0x%08x], Thread: %d [0x%x]) (%lu/%lu/%lu: %02lu:%02lu:%02lu %s): File: %s, Line %d : %s\n",
         GetCurrentProcessId(),
         GetCurrentProcessId(),
         GetCurrentThreadId(),
         GetCurrentThreadId(),
         (ULONG)st.wMonth,
         (ULONG)st.wDay,
         (ULONG)st.wYear,
         1 + (( (ULONG)st.wHour + 11 ) % 12),
         (ULONG)st.wMinute,
         (ULONG)st.wSecond,
         (st.wHour < 12) ? "am" : "pm",
         szFile,
         iLine,
         szExpr));
    LOG((LF_ASSERT, LL_FATALERROR, "RUNNING EXE: %ws\n", exename));



}

//*****************************************************************************

BOOL LaunchJITDebugger() {

    wchar_t AeDebuggerCmdLine[256];

	if (!GetProfileStringW(L"AeDebug", L"Debugger", NULL, AeDebuggerCmdLine, (sizeof(AeDebuggerCmdLine)/sizeof(AeDebuggerCmdLine[0]))-1))
		return(FALSE);
	
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	HANDLE EventHandle = WszCreateEvent(&sa,TRUE,FALSE,NULL);
	if (!EventHandle)
		return(FALSE);

	wchar_t CmdLine[256 + 32];	// the string representaion id and event handle may be longer than %ld
	wsprintfW(CmdLine,AeDebuggerCmdLine,GetCurrentProcessId(),EventHandle);

	STARTUPINFO StartupInfo;
	memset(&StartupInfo, 0, sizeof(StartupInfo));
	StartupInfo.cb = sizeof(StartupInfo);
	StartupInfo.lpDesktop = L"Winsta0\\Default";

	PROCESS_INFORMATION ProcessInformation;	
	if (!WszCreateProcess(NULL, CmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInformation))
		return(FALSE);


	WaitForSingleObject(EventHandle, INFINITE);
	CloseHandle(EventHandle);			
	return (TRUE);
}


//*****************************************************************************
// This function is called in order to ultimately return an out of memory
// failed hresult.  But this guy will check what environment you are running
// in and give an assert for running in a debug build environment.  Usually
// out of memory on a dev machine is a bogus alloction, and this allows you
// to catch such errors.  But when run in a stress envrionment where you are
// trying to get out of memory, assert behavior stops the tests.
//*****************************************************************************
HRESULT _OutOfMemory(LPCSTR szFile, int iLine)
{
    DbgWriteEx(L"WARNING:  Out of memory condition being issued from: %hs, line %d\n",
            szFile, iLine);
    return (E_OUTOFMEMORY);
}

int _DbgBreakCount = 0;

//*****************************************************************************
// This function will handle ignore codes and tell the user what is happening.
//*****************************************************************************
int _DbgBreakCheck(
    LPCSTR      szFile, 
    int         iLine, 
    LPCSTR      szExpr)
{
    TCHAR       rcBuff[1024+_MAX_PATH];
    TCHAR       rcPath[_MAX_PATH];
    TCHAR       rcTitle[64];
    _DBGIGNOREDATA *psData;
    long        i;

    if (DebugBreakOnAssert())
    {        
        DebugBreak();
    }

    // Check for ignore all.
    for (i=0, psData = grIgnore.Ptr();  i<grIgnore.Count();  i++, psData++)
    {
        if (psData->iLine == iLine && _stricmp(psData->rcFile, szFile) == 0 && 
            psData->bIgnore == true)
            return (false);
    }

    // Give assert in output for easy access.
    WszGetModuleFileName(0, rcPath, NumItems(rcPath));
    swprintf(rcBuff, L"Assert failure(PID %d [0x%08x], Thread: %d [0x%x]): %hs\n"
                L"    File: %hs, Line: %d Image:\n%s\n", 
                GetCurrentProcessId(), GetCurrentProcessId(),
                GetCurrentThreadId(), GetCurrentThreadId(), 
                szExpr, szFile, iLine, rcPath);
    WszOutputDebugString(rcBuff);
    // Write out the error to the console
    wprintf(L"%s\n", rcBuff);

    LogAssert(szFile, iLine, szExpr);
    FlushLogging();         // make certain we get the last part of the log
	_flushall();
    if (NoGuiOnAssert())
    {
        TerminateOnAssert();
    }

    if (DebugBreakOnAssert())
    {        
        return(true);       // like a retry
    }

    // Change format for message box.  The extra spaces in the title
    // are there to get around format truncation.
    swprintf(rcBuff, L"%hs\n\n%hs, Line: %d\n\nAbort - Kill program\nRetry - Debug\nIgnore - Keep running\n"
             L"\n\nImage:\n%s\n",
        szExpr, szFile, iLine, rcPath);
    swprintf(rcTitle, L"Assert Failure (PID %d, Thread %d/%x)        ", 
             GetCurrentProcessId(), GetCurrentThreadId(), GetCurrentThreadId());

    // Tell user there was an error.
    _DbgBreakCount++;
    int ret = WszMessageBoxInternal(NULL, rcBuff, rcTitle, 
            MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION | COMPLUS_MB_SERVICE_NOTIFICATION);
	--_DbgBreakCount;

    HMODULE hKrnl32;

    switch(ret)
    {
        // For abort, just quit the app.
        case IDABORT:
          TerminateProcess(GetCurrentProcess(), 1);
//        WszFatalAppExit(0, L"Shutting down");
        break;

        // Tell caller to break at the correct loction.
        case IDRETRY:

        hKrnl32 = WszLoadLibrary(L"kernel32.dll");
        _ASSERTE(hKrnl32 != NULL);

        if(hKrnl32)
        {
            typedef BOOL (WINAPI *t_pDbgPres)();
            t_pDbgPres pFcn = (t_pDbgPres) GetProcAddress(hKrnl32, "IsDebuggerPresent");

            // If this function is available, use it.
            if (pFcn)
            {
                if (pFcn())
                {
                    SetErrorMode(0);
                }
                else
    				LaunchJITDebugger();
            }

            FreeLibrary(hKrnl32);
        }

        return (true);

        // If we want to ignore the assert, find out if this is forever.
        case IDIGNORE:
        swprintf(rcBuff, L"Ignore the assert for the rest of this run?\nYes - Assert will never fire again.\nNo - Assert will continue to fire.\n\n%hs\nLine: %d\n",
            szFile, iLine);
        if (WszMessageBoxInternal(NULL, rcBuff, L"Ignore Assert Forever?", MB_ICONQUESTION | MB_YESNO | COMPLUS_MB_SERVICE_NOTIFICATION) != IDYES)
            break;

        if ((psData = grIgnore.Append()) == 0)
            return (false);
        psData->bIgnore = true;
        psData->iLine = iLine;
        strcpy(psData->rcFile, szFile);
        break;
    }

    return (false);
}

    // Get the timestamp from the PE file header.  This is useful 
unsigned DbgGetEXETimeStamp()
{
    static cache = 0;
    if (cache == 0) {
        BYTE* imageBase = (BYTE*) WszGetModuleHandle(NULL);
        if (imageBase == 0)
            return(0);
        IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER*) imageBase;
        if ((pDOS->e_magic != IMAGE_DOS_SIGNATURE) || (pDOS->e_lfanew == 0))
            return(0);
            
        IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) (pDOS->e_lfanew + imageBase);
        cache = pNT->FileHeader.TimeDateStamp;
    }
    return cache;
}

// // //  
// // //  The following function
// // //  computes the binomial distribution, with which to compare 
// // //  hash-table statistics.  If a hash function perfectly randomizes
// // //  its input, one would expect to see F chains of length K, in a
// // //  table with N buckets and M elements, where F is
// // //
// // //    F(K,M,N) = N * (M choose K) * (1 - 1/N)^(M-K) * (1/N)^K.  
// // //
// // //  Don't call this with a K larger than 159.
// // //

#if !defined(NO_CRT) && ( defined(DEBUG) || defined(_DEBUG) )

#include <math.h>

#define MAX_BUCKETS_MATH 160

double Binomial (DWORD K, DWORD M, DWORD N)
{
    if (K >= MAX_BUCKETS_MATH)
        return -1 ;

    static double rgKFact [MAX_BUCKETS_MATH] ;
    DWORD i ;

    if (rgKFact[0] == 0)
    {
        rgKFact[0] = 1 ;
        for (i=1; i<MAX_BUCKETS_MATH; i++)
            rgKFact[i] = rgKFact[i-1] * i ;
    }

    double MchooseK = 1 ;

    for (i = 0; i < K; i++)
        MchooseK *= (M - i) ;

    MchooseK /= rgKFact[K] ;

    double OneOverNToTheK = pow (1./N, K) ;

    double QToTheMMinusK = pow (1.-1./N, M-K) ;

    double P = MchooseK * OneOverNToTheK * QToTheMMinusK ;

    return N * P ;
}

#endif // _DEBUG

#if _DEBUG
// Called from within the IfFail...() macros.  Set a breakpoint here to break on
// errors.
VOID DebBreak() 
{
  static int i = 0;  // add some code here so that we'll be able to set a BP
  i++;
}
VOID DebBreakHr(HRESULT hr) 
{
  static int i = 0;  // add some code here so that we'll be able to set a BP
  _ASSERTE(hr != 0xcccccccc);
  i++;
  //@todo: code to break on specific HR.
}
VOID DbgAssertDialog(char *szFile, int iLine, char *szExpr)
{
    if (DebugBreakOnAssert())
    {        
        DebugBreak();
    }

    DWORD dwAssertStacktrace = REGUTIL::GetConfigDWORD(L"AssertStacktrace", 1);
                                                       
    LONG lAlreadyOwned = InterlockedExchange((LPLONG)&g_BufferLock, 1);
    if (dwAssertStacktrace == 0 || lAlreadyOwned == 1) {
        if (1 == _DbgBreakCheck(szFile, iLine, szExpr))
            _DbgBreak();
    } else {
        char *szExprWithStack = &g_szExprWithStack[0];
        strcpy(szExprWithStack, szExpr);
        strcat(szExprWithStack, "\n\n");
        GetStringFromStackLevels(0, 10, szExprWithStack + strlen(szExprWithStack));
        if (1 == _DbgBreakCheck(szFile, iLine, szExprWithStack))
            _DbgBreak();
        g_BufferLock = 0;
    }
}

#endif // _DEBUG


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\idecoder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//
// idecoder.cpp
//
// Decompresses compressed methods.
//
// @TODO None of this code is particularly efficient
// @TODO Remove declarations of tables since they are almost certainly declared elsewhere also
//
#include "stdafx.h"
#include "utilcode.h"
#include "openum.h"
#include "CompressionFormat.h"
#include "cor.h"

#ifdef COMPRESSION_SUPPORTED

#define Inline0     0
#define InlineI1    1
#define InlineU1    2
#define InlineI2    3
#define InlineU2    4
#define InlineI4    5
#define InlineU4    6
#define InlineI8    7
#define InlineR4    8
#define InlineR8    9
#define InlinePcrel1 10
#define InlinePcrel4 11
#define InlineDescr4 12
#define InlineClsgn4 13
#define InlineSwitch 14
#define InlineTok    15
#define InlineU2Tok  16
#define InlinePhi    17

typedef struct
{
    BYTE Len;
    BYTE Std1;
    BYTE Std2;
} DecoderOpcodeInfo;

// @TODO Try to share tables - everyone declares their own everywhere!
static const DecoderOpcodeInfo g_OpcodeInfo[] =
{
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) l,s1,s2,
#include "opcode.def"
#undef OPDEF
};

const BYTE g_OpcodeType[] =
{
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) args,
#include "opcode.def"
    0
};

static DWORD GetOpcodeLen(OPCODE op)
{
    switch (g_OpcodeType[op])
    {
        // switch is handled specially, we don't advance the pointer automatically
        case InlinePhi:
        case InlineSwitch:
            return 0;

        case Inline0:
            return 0;

        case InlineI1:
        case InlineU1:
        case InlinePcrel1:
            return 1;

        case InlineI2:
        case InlineU2:
            return 2;

        case InlineI4:
        case InlineU4:
        case InlineR4:
        case InlinePcrel4:
        case InlineDescr4:
        case InlineClsgn4:
        case InlineTok:
            return 4;

        case InlineI8:
        case InlineR8:
            return 8;

        case InlineU2Tok:
            return 6;
    }

    return 0;
}


static OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch(opcode) {
        case CEE_PREFIX1:
            opcode = OPCODE(pCode[1] + 256);
            _ASSERTE(opcode < CEE_COUNT);
            *pdwLen = 2;
            break;

        case CEE_PREFIXREF:
        case CEE_PREFIX2:
        case CEE_PREFIX3:
        case CEE_PREFIX4:
        case CEE_PREFIX5:
        case CEE_PREFIX6:
        case CEE_PREFIX7:
            *pdwLen = 2;
            return CEE_COUNT;
        }
    return opcode;
}


class InstructionMacro
{
public:
    DWORD   m_RealOpcode;
    DWORD   m_fImpliedInlineOperand;
    BYTE    m_Operand[8];
};

// If a DLL specifies a custom encoding scheme, one of these is created for that DLL.  
class InstructionDecodingTable
{
public:
    // Mapping for single byte opcodes
    // If the value is >= 0, this maps to a CEE_* enumeration
    // If the value is < 0, it means this is a macro to be looked up in m_Macros.
    long                m_SingleByteOpcodes[256];

#ifdef _DEBUG
    long                m_lDebugMaxMacroStart;
#endif

    // This is a long list of instructions.  Some macros will span multiple entries of
    // m_Macros.  m_SingleByteOpcodes[] points into here sparsely.
    InstructionMacro    m_Macros[1];

    void *operator new(size_t size, DWORD dwNumMacros)
    {
        return ::new BYTE[size + dwNumMacros*sizeof(InstructionMacro)];
    }
};


static DWORD FourBytesToU4(const BYTE *pBytes)
{
#ifdef _X86_
    return *(const DWORD *) pBytes;
#else
    return pBytes[0] | (pBytes[1] << 8) | (pBytes[2] << 16) | (pBytes[3] << 24);
#endif
}


BOOL InstructionDecoder::OpcodeTakesFieldToken(DWORD opcode)
{
    switch (opcode)
    {
        default:
            return FALSE;

        case CEE_LDFLD:
        case CEE_LDSFLD:
        case CEE_LDFLDA:
        case CEE_LDSFLDA:
        case CEE_STFLD:
        case CEE_STSFLD:
            return TRUE;
    }
}


BOOL InstructionDecoder::OpcodeTakesMethodToken(DWORD opcode)
{
    switch (opcode)
    {
        default:
            return FALSE;

        case CEE_CALL:
        case CEE_CALLVIRT:
        case CEE_NEWOBJ:
        case CEE_JMP:
            return TRUE;
    }
}


BOOL InstructionDecoder::OpcodeTakesClassToken(DWORD opcode)
{
    switch (opcode)
    {
        default:
            return FALSE;

        case CEE_BOX:
        case CEE_UNBOX:
        case CEE_LDOBJ:
        case CEE_CPOBJ:
        case CEE_INITOBJ:
        case CEE_CASTCLASS:
        case CEE_ISINST:
        case CEE_NEWARR:
        case CEE_MKREFANY:
		case CEE_REFANYVAL:
            return TRUE;
    }
}


//
// Given a pointer to an instruction decoding format in the PE file, create a table for decoding.
//
void *InstructionDecoder::CreateInstructionDecodingTable(const BYTE *pTableStart, DWORD size)
{
    InstructionDecodingTable *pTable;
    
    if (pTableStart != NULL)
    {
        CompressionMacroHeader *pHdr = (CompressionMacroHeader*) pTableStart;
        long                    i;
        BYTE *                  pRead;
        InstructionMacro *      pEndTable;
        InstructionMacro *      pMacro;
        long                    lCurMacro;
        
        // @TODO Get this right
        pTable = new (pHdr->dwNumMacros + pHdr->dwNumMacroComponents) InstructionDecodingTable();
        if (pTable == NULL)
            return NULL;

        pEndTable = &pTable->m_Macros[pHdr->dwNumMacros + pHdr->dwNumMacroComponents];
        pRead = (BYTE*) (pHdr + 1);

        // Init these to something - we'll overwrite them though
        for (i = 0; i < 256; i++)
            pTable->m_SingleByteOpcodes[i] = i;

        // Instruction 0x00 is always NOP
        pTable->m_SingleByteOpcodes[0x00] = CEE_NOP;
        pTable->m_SingleByteOpcodes[0xFF] = CEE_PREFIXREF;

        pMacro = &pTable->m_Macros[0];
        lCurMacro = 0;

        // Decode macros
        for (i = 1; i <= (long) pHdr->dwNumMacros; i++)
        {
            pTable->m_SingleByteOpcodes[i] = -(lCurMacro+1);

#ifdef _DEBUG
            pTable->m_lDebugMaxMacroStart = lCurMacro;
#endif

            BYTE    bCount = *pRead++; // How many instructions in this macro
            DWORD   j;
            USHORT  wOperandMask;      // Operand mask

            _ASSERTE(bCount <= 16);

            // Read the mask of which opcodes have implied operands
            wOperandMask = *pRead++;

            if (bCount > 8)
                wOperandMask |= ((*pRead++) << 8);

            // Read the opcodes
            for (j = 0; j < bCount; j++)
            {
                USHORT wOpcode;
                DWORD   dwLen;

                wOpcode = (USHORT) DecodeOpcode(pRead, &dwLen);
                pRead += dwLen;

                pMacro[j].m_RealOpcode = wOpcode;
            }

            // Read the implied operands
            for (j = 0; j < bCount; j++)
            {
                if (wOperandMask & (1 << j))
                {
                    pMacro[j].m_fImpliedInlineOperand = TRUE;

                    DWORD dwOpcodeLen = GetOpcodeLen((OPCODE) pMacro[j].m_RealOpcode);

                    memcpy(pMacro[j].m_Operand, pRead, dwOpcodeLen);
                    pRead += dwOpcodeLen;
                }
                else
                {
                    pMacro[j].m_fImpliedInlineOperand = FALSE;
                }
            }

            // End-of-macro code
            pMacro[bCount].m_RealOpcode = CEE_COUNT;
            pMacro += (bCount+1);
            lCurMacro += (bCount+1);
        }

        _ASSERTE(pMacro <= pEndTable);
        return pTable;
    }
    else
    {
        _ASSERTE(!"Illegal call to CreateInstructionDecodingTable");
        return NULL;
    }
}

void InstructionDecoder::DestroyInstructionDecodingTable(void *pTable)
{
    delete ((InstructionDecodingTable*) pTable);
}


//
// Format: 16 bits
//
// Bit #0    indicates whether it 4 bytes follow (otherwise, 2 bytes)
// Bits #1-3 indicate type
//   000x TypeDef
//   001x MethodDef
//   010x FieldDef
//   011x TypeRef
//   100x MemberRef
//
static DWORD UncompressToken(const BYTE **ppCode)
{
    const BYTE *    pCode = *ppCode;
    DWORD           dwRid;

    if ((pCode[0] & 1) == 0)
    {
        // 2 bytes
        dwRid = pCode[0] | (pCode[1] << 8);
        *ppCode += 2;
    }
    else
    {
        // 4 bytes
        dwRid = pCode[0] | (pCode[1] << 8) | (pCode[2] << 16) | (pCode[3] << 24);
        *ppCode += 4;
    }

    switch ((dwRid >> 1) & 7)
    {
        default:
            _ASSERTE(0);
            break;

        case 0:
            dwRid = ((dwRid >> 4) | mdtTypeDef);
            break;

        case 1:
            dwRid = ((dwRid >> 4) | mdtMethodDef);
            break;

        case 2:
            dwRid = ((dwRid >> 4) | mdtFieldDef);
            break;

        case 3:
            dwRid = ((dwRid >> 4) | mdtTypeRef);
            break;

        case 4:
            dwRid = ((dwRid >> 4) | mdtMemberRef);
            break;
    }

    return dwRid;
}


//
// Format: 8-32 bits
//
// Bit #0 indicates whether this is a compact encoding.  If NOT set, this is a FieldDef, and 
// bits #1-7 provide a 128 byte range, from -64...+63 as a delta from the last FieldDef 
// encountered in this method.
//
// Otherwise, set bit #0.  If bit #1 is set, it indicates that this is a 4 byte encoding, 
// otherwise it is a 2 byte encoding.  If bit #2 is set, this is a MemberRef, otherwise it's 
// a FieldDef.
//     xxxxxxxx xxxxx??0
//
static DWORD UncompressFieldToken(const BYTE **ppCode, DWORD *pdwPrevFieldDefRid)
{
    const BYTE *    pCode = *ppCode;
    DWORD           dwRid;

    if ((pCode[0] & 1) == 0)
    {
        // Compact encoding
        long delta = ((long) (pCode[0] >> 1)) - 64;

        dwRid = (DWORD) (((long) (*pdwPrevFieldDefRid)) + delta);
        (*ppCode)++;

        *pdwPrevFieldDefRid = dwRid;
        dwRid |= mdtFieldDef;
    }
    else
    {
        if ((pCode[0] & 2) == 0)
        {
            // 2 bytes
            dwRid = pCode[0] | (pCode[1] << 8);
            *ppCode += 2;
        }
        else
        {
            // 4 bytes
            dwRid = pCode[0] | (pCode[1] << 8) | (pCode[2] << 16) | (pCode[3] << 24);
            *ppCode += 4;
        }

        if (dwRid & 4)
        {
            dwRid = ((dwRid >> 3) | mdtMemberRef);
        }
        else
        {
            dwRid = (dwRid >> 3);
            *pdwPrevFieldDefRid = dwRid;
            dwRid |= mdtFieldDef;
        }
    }

    return dwRid;
}


//
// Format: 8-32 bits
//
// Bit #0 indicates whether this is a compact encoding.  If NOT set, this is the same token
// type as the last method token (ref or def), and bits #1-7 provide a 128 byte range, from
// -64...+63 as a delta.
//
// Otherwise, set bit #0.  If bit #1 is set, it indicates that this is a 4 byte encoding, 
// otherwise it is a 2 byte encoding.  If bit #2 is set, this is a MemberRef, otherwise it's 
// a FieldDef.
//     xxxxxxxx xxxxx??0
//
static DWORD UncompressMethodToken(const BYTE **ppCode, DWORD *pdwPrevMethodToken)
{
    const BYTE *    pCode = *ppCode;
    DWORD           dwRid;

    if ((pCode[0] & 1) == 0)
    {
        // Compact encoding
        long delta = ((long) (pCode[0] >> 1)) - 64;

        dwRid = (DWORD) (((long) (RidFromToken(*pdwPrevMethodToken))) + delta);
        (*ppCode)++;

        dwRid |= TypeFromToken(*pdwPrevMethodToken);
    }
    else
    {
        if ((pCode[0] & 2) == 0)
        {
            // 2 bytes
            dwRid = pCode[0] | (pCode[1] << 8);
            *ppCode += 2;
        }
        else
        {
            // 4 bytes
            dwRid = pCode[0] | (pCode[1] << 8) | (pCode[2] << 16) | (pCode[3] << 24);
            *ppCode += 4;
        }

        if (dwRid & 4)
            dwRid = ((dwRid >> 3) | mdtMemberRef);
        else
            dwRid = ((dwRid >> 3) | mdtMethodDef);
    }

    *pdwPrevMethodToken = dwRid;
    return dwRid;
}


//
// Format: 8-32 bits
//
// Bit #0 is not set, this is a 1 byte encoding of a TypeDef, and bits #1-7 are the typedef.
//
// If bit #0 is set, then bit #1 indicates whether this is a typeref (if set).  bit #2 indicates
// whether this is a 4 byte encoding (if set) rather than a 2 byte encoding (if clear).
//
static DWORD UncompressClassToken(const BYTE **ppCode)
{
    const BYTE *    pCode = *ppCode;
    DWORD           dwRid;

    if ((pCode[0] & 1) == 0)
    {
        // Compact encoding
        dwRid = (DWORD) (pCode[0] >> 1);
        dwRid |= mdtTypeDef;
        (*ppCode)++;
    }
    else
    {
        if ((pCode[0] & 2) == 0)
        {
            // 2 bytes
            dwRid = pCode[0] | (pCode[1] << 8);
            *ppCode += 2;
        }
        else
        {
            // 4 bytes
            dwRid = pCode[0] | (pCode[1] << 8) | (pCode[2] << 16) | (pCode[3] << 24);
            *ppCode += 4;
        }

        if (dwRid & 4)
            dwRid = ((dwRid >> 3) | mdtTypeRef);
        else
            dwRid = ((dwRid >> 3) |  mdtTypeDef);
    }

    return dwRid;
}

HRESULT InstructionDecoder::DecompressMethod(void *pDecodingTable, const BYTE *pCompressed, DWORD dwSize, BYTE **ppOutput)
{
    InstructionDecodingTable *  pTable = (InstructionDecodingTable*) pDecodingTable;
    BYTE *                      pCurOutPtr;
    BYTE *                      pEndOutPtr;
    InstructionMacro *          pMacro = NULL;
    BOOL                        fInMacro = FALSE;
    DWORD                       dwPrevFieldDefRid = 0;
    DWORD                       dwPrevMethodToken = 0;

    *ppOutput = new BYTE[ dwSize ];
    if (ppOutput == NULL)
        return E_OUTOFMEMORY;

    pCurOutPtr = *ppOutput;
    pEndOutPtr = pCurOutPtr + dwSize;

    while (pCurOutPtr < pEndOutPtr)
    {
        OPCODE      instr;
        const BYTE *pOperand;
        DWORD       dwScratchSpace;
        signed long Lookup;
        
        //
        // Start of instruction decode
        //

        // Are we already in a macro?
        if (fInMacro)
        {
            // Decode next instruction
#ifdef _DEBUG
            _ASSERTE(pMacro != NULL);
#endif
            pMacro++;
            instr = (OPCODE) pMacro->m_RealOpcode;

            if (instr == CEE_COUNT)
            {
                // End of current macro, so start over
                // Do regular lookup now
                fInMacro = FALSE;
#ifdef _DEBUG
                pMacro = NULL;
#endif
            }
        }

        if (fInMacro == FALSE)
        {
            // Not already in a macro, so decode next element from opcode stream

            // Do single byte lookup
            Lookup = pTable->m_SingleByteOpcodes[ *pCompressed ];
            if ((unsigned long) Lookup < CEE_COUNT)
            {
                // Not a macro, just a regular instruction
                if (Lookup == CEE_PREFIXREF)
                {
                    // Prefix ref means its in the 3 byte canonical form
                    instr = (OPCODE) (pCompressed[1] + (pCompressed[2] << 8));
                    pCompressed += 3;
                }
                else
                {
                    // 1 byte compact form
                    pCompressed++;
                }

                goto decode_inline_operand;
            }

            // Else, it's a macro
            _ASSERTE(Lookup < 0);

            Lookup = -(Lookup+1);
#ifdef _DEBUG
            _ASSERTE(Lookup <= pTable->m_lDebugMaxMacroStart);
#endif

            pMacro = &pTable->m_Macros[Lookup];
            fInMacro = TRUE;
    
            pCompressed++;
        }

        // Get real instruction from the macro definition
        instr = (OPCODE) pMacro->m_RealOpcode;

        if (pMacro->m_fImpliedInlineOperand)
        {
            // Macro has implied inline operand, point at it
            pOperand = pMacro->m_Operand;
        }
        else
        {
            // Macro requires explicit operand
            pOperand = pCompressed;

decode_inline_operand:
            if (g_OpcodeType[instr] == InlineTok)
            {
                // Tokens are compressed specially
                if (OpcodeTakesFieldToken(instr))
                {
                    dwScratchSpace = UncompressFieldToken(&pCompressed, &dwPrevFieldDefRid);
                }
                else if (OpcodeTakesMethodToken(instr))
                {
                    dwScratchSpace = UncompressMethodToken(&pCompressed, &dwPrevMethodToken);
                }
                else if (OpcodeTakesClassToken(instr))
                {
                    dwScratchSpace = UncompressClassToken(&pCompressed);
                }
                else
                {
                    dwScratchSpace  = UncompressToken(&pCompressed); // Advance pCompressed as necessary
                }

                pOperand        = (BYTE*) &dwScratchSpace; // Not endian agnostic!
            }
            else
            {
                pOperand = pCompressed;
                pCompressed += GetOpcodeLen(instr);
            }
        }

        // Emit instruction and operand data

        // We have to emit things exactly the way the compressor does, otherwise the basic block
        // offsets all get screwed up.  For example, we have to know when to emit the 1 byte form,
        // the 2 byte form, and the 3 byte form.
        if (g_OpcodeInfo[instr].Len == 0)
        {
            // Deprecated opcode, so emit 1 byte form
            *pCurOutPtr++ = REFPRE;
            *pCurOutPtr++ = (BYTE) (instr & 255);
            *pCurOutPtr++ = (BYTE) (instr >> 8);
        }
        else
        {
            if (g_OpcodeInfo[instr].Len == 2)
                *pCurOutPtr++ = g_OpcodeInfo[instr].Std1;
            *pCurOutPtr++ = g_OpcodeInfo[instr].Std2;
        }

        if (instr == CEE_SWITCH)
        {
            DWORD dwNumCases = FourBytesToU4(pCompressed);

            memcpy(pCurOutPtr, pCompressed, (dwNumCases+1) * sizeof(DWORD));
            pCurOutPtr  += ((dwNumCases+1) * sizeof(DWORD));
            pCompressed += ((dwNumCases+1) * sizeof(DWORD));
        }
        else
        {
            DWORD dwInlineLen = GetOpcodeLen(instr);
            memcpy(pCurOutPtr, pOperand, dwInlineLen);
            pCurOutPtr += dwInlineLen;
        }
    }

    _ASSERTE(pCurOutPtr == pEndOutPtr);
    return S_OK;
}

#endif // COMPRESSSION_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\ilformatter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                             ILFormatter.h                               */
/***************************************************************************/

#include "stdafx.h"
#include <cor.h>
#include <debugMacros.h>     		// for ASSERTE
#include "ILFormatter.h"
#include "OutString.h"
#include "OpInfo.h"
#include "endian.h"

/***************************************************************************/
void ILFormatter::init(IMetaDataImport* aMeta, const BYTE* aStart, 
				  const BYTE* aLimit, unsigned maxStack, const COR_ILMETHOD_SECT_EH* eh) {
    this->~ILFormatter();		// clean out old stuff

    meta = aMeta;
	start = aStart;
	limit = aLimit;
    if (maxStack == 0) maxStack++;
    stackStart = stackCur = new StackEntry[maxStack];
    stackEnd = stackStart + maxStack;
    targetStart = targetCur = targetEnd = 0;
    if (eh != 0) {
        IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT buff;
        const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clause;
        for(unsigned i = 0; i < eh->EHCount(); i++) {
            clause = eh->EHClause(i, &buff);
				// is it a regular catch clause ?
            if ((clause->Flags & (COR_ILEXCEPTION_CLAUSE_FINALLY | COR_ILEXCEPTION_CLAUSE_FAULT)) == 0)
                setTarget(clause->HandlerOffset, 1);
			if(clause->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)
				setTarget(clause->FilterOffset, 1);
        }
    }
}

/***************************************************************************/
inline size_t ILFormatter::stackDepth() {
	return(stackCur - stackStart);
}

/***************************************************************************/
inline void ILFormatter::pushAndClear(OutString* val, int prec) {
    if (stackCur >= stackEnd) {
	    _ASSERTE(!"Stack Overflow (can be ignored)");
        return;             // Ignore overflow in free build
    }
	stackCur->val.swap(*val);
    val->clear();
	stackCur->prec = prec;
	stackCur++;
}

/***************************************************************************/
inline OutString*  ILFormatter::top() {
    if (stackDepth() == 0) {
	    _ASSERTE(!"Stack underflow (can be ignored)");
        stackStart->val.clear();
        stackStart->val << "<UNDERFLOW ERROR>";
        return (&stackStart->val);
    }
	return(&stackCur[-1].val);
}

/***************************************************************************/
inline OutString* ILFormatter::pop(int prec) {
    if (stackDepth() == 0) {
	    _ASSERTE(!"Stack underflow (can be ignored)");
        stackStart->val.clear();
        stackStart->val << "<UNDERFLOW ERROR>";
        return (&stackStart->val);
    }
	--stackCur;
	if (stackCur->prec < prec) {
		stackCur->val.prepend('(');
		stackCur->val << ')';
	}
	return(&stackCur->val);
}

/***************************************************************************/
inline void ILFormatter::popN(size_t num) {
	if (stackCur-stackStart < (SSIZE_T)num) {
	    _ASSERTE(!"Stack underflow (can be ignored)");
		stackCur = stackStart;
		return;
	}
	stackCur -= num;
}

/***************************************************************************/
void ILFormatter::setStackAsTarget(size_t ilOffset) {

    Target*ptr = targetStart;
    for(;;) {
        if (ptr >= targetCur)
            return;
        if (ptr->ilOffset == ilOffset)
            break;
        ptr++;
    }

    for(size_t i = 0; i < ptr->stackDepth; i++) {
        stackStart[i].val.clear();
		stackStart[i].val << "@STK" << (unsigned)i;
    }
    stackCur = stackStart + ptr->stackDepth;
}

/***************************************************************************/
void ILFormatter::setTarget(size_t ilOffset, size_t depth) {
    if (depth == 0)
        return;

    if (targetCur >= targetEnd) {
        Target* targetOld = targetStart;
        size_t oldLen = targetCur-targetStart;
        targetStart = new Target[oldLen+10];
        targetEnd = &targetStart[oldLen+10];
        targetCur = &targetStart[oldLen];
        memcpy(targetStart, targetOld, sizeof(Target)*oldLen);
        delete [] targetOld;
    }
    targetCur->ilOffset = ilOffset;
    targetCur->stackDepth = depth;
    targetCur++;
}

/***************************************************************************/
void ILFormatter::spillStack(OutString* out) {

	for(unsigned i = 0; i < stackDepth(); i++) {
        // don't bother spilling something already spilled.  
        if (memcmp(stackStart[i].val.val(), "@STK", 4) != 0) 
		    *out << "@STK" << i << " = " << stackStart[i].val.val() << "\n";
		stackStart[i].val.clear();
		stackStart[i].val << "@STK" << i ;
	}
}

/***************************************************************************/
const BYTE* ILFormatter::formatInstr(const BYTE* instrPtr, OutString* out) {

	_ASSERTE(start < instrPtr && instrPtr < limit);
	OpArgsVal arg;
	OpInfo op;
	instrPtr = op.fetch(instrPtr, &arg);
	*out << op.getName();
	if (op.getArgsInfo() != InlineNone)
		*out << ' ';
	formatInstrArgs(op, arg, out, instrPtr - start);
	return(instrPtr);
}

/***************************************************************************/
void ILFormatter::formatArgs(unsigned numArgs, OutString* out) {

    *out << '(';
    if (numArgs > stackDepth()) {
        _ASSERTE(!"Underflow error");
        *out << "<UNDERFLOW ERROR>";
    }
    else {
        popN(numArgs);
        for(unsigned i = 0; i < numArgs; i++) {
            if (i != 0) *out << ", ";
            *out << stackCur[i].val.val();
        }
    }
    *out << ')';
}

/***************************************************************************/
void ILFormatter::formatInstrArgs(OpInfo op, OpArgsVal arg, OutString* out, size_t curILOffset) {

    MDUTF8CSTR typeName=0;
    HRESULT hr;
    switch(op.getArgsInfo() & PrimaryMask) {
		case InlineNone:
			break;
		case InlineVar:
			*out << arg.i;
			break;
		case InlineI:
		case InlineRVA:
			out->hex(arg.i, 0, OutString::put0x);
			break;
        case InlineR:
			*out << arg.r;
			break;
        case InlineBrTarget: {
			_ASSERTE(curILOffset != INVALID_IL_OFFSET);
            size_t target = curILOffset + arg.i;
            setTarget(target, stackDepth());
			*out << "IL_"; out->hex(target, 4, OutString::zeroFill);
            } break;
		case InlineI8:
			out->hex(arg.i, 0, OutString::put0x);
			break;
		case InlineString: {
			ULONG numChars;
			wchar_t str[84];
			HRESULT hr = meta->GetUserString(arg.i, str, 80, &numChars);
			_ASSERTE(SUCCEEDED(hr));
            if (numChars < 80)
                str[numChars] = 0;
			wcscpy(&str[80], L"...");
            *out << '"';
			wchar_t* ptr = str;
			while(*ptr != 0) {
				if (*ptr == '\n') 
					*out << "\\n";
				else if (*ptr == '"') 
					*out << "\\\"";
				else if (*ptr < 0x20 || * ptr >= 0x80) {
					*out << '\\';
					out->hex(*ptr, 4, OutString::zeroFill);
				}
				else 
					*out << char(*ptr);
				ptr++;
			}
            *out << '"';
			} break;
		case InlineMethod:
		case InlineField: 
        case InlineTok: {
                // Get the typeName if possible 
            mdToken mdType = mdTypeDefNil;
            if (TypeFromToken(arg.i) == mdtMethodDef)
                hr = meta->GetMethodProps(mdMethodDef(arg.i), &mdType, 0, 0, 0, 0, 0, 0, 0, 0);
            else if (TypeFromToken(arg.i) == mdtMemberRef)
                hr = meta->GetMemberRefProps(mdMemberRef(arg.i), &mdType, 0, 0, 0, 0, 0);
            else if (TypeFromToken(arg.i) == mdtFieldDef)
                hr = meta->GetFieldProps(mdMethodDef(arg.i), &mdType, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            if (SUCCEEDED(hr) && mdType != mdTypeDefNil) {
                hr = meta->GetNameFromToken(mdType, &typeName);
            }
		}
            // FALL THROUGH
        case InlineType: {
            // FIX handle case if (TypeFromToken(arg.i) == mdtTypeSpec)
			MDUTF8CSTR name;
            hr = meta->GetNameFromToken(arg.i, &name);
            if (SUCCEEDED(hr)) {
                if (typeName) {
                    const char* lastDot = strrchr(typeName, '.');
                    if (lastDot) typeName = lastDot + 1;
                    *out << typeName << "::";
                }
			    *out << name;
            }
            else {
                *out << "TOK<";
                out->hex(arg.i, 0, OutString::put0x);
                *out << '>';
            }
		} 	break;
		case InlineSig:    
			*out << "SIG<";
			out->hex(arg.i, 0, OutString::put0x);
			*out << '>';
			break;
		case InlineSwitch: {
			_ASSERTE(curILOffset != INVALID_IL_OFFSET);
			unsigned i =0; 
			while (i < arg.switch_.count) {
                size_t target = curILOffset + int(readDWordSmallEndian((BYTE*) &arg.switch_.targets[i]));
                setTarget(target, stackDepth()-1);
				*out << "IL_"; out->hex(target, 4, OutString::zeroFill);
				if (i < arg.switch_.count)
					*out << ' ';
                i++;
				}
			} break;
		case InlinePhi: {
			unsigned i =0; 
			while (i < arg.phi.count) {
				*out << readWordSmallEndian((BYTE*) &arg.phi.vars[i]);
				if (i < arg.phi.count)
					*out << ' ';
                i++;
				}
			} break;
		default:
			_ASSERTE(!"BadType");
    }
}

/***************************************************************************/
const BYTE* ILFormatter::formatStatement(const BYTE* instrPtr, OutString* out) {

	OutString result;
	OpInfo op;
	OutString *lhs, *rhs, *idx;
	const char* name;
	int prec = 0;

        // set stack as it would be if it was begin jumped to
    setStackAsTarget(instrPtr - start);   

	while(instrPtr < limit) {
		OpArgsVal inlineArg;
		instrPtr = op.fetch(instrPtr, &inlineArg);

		switch(op.getOpcode()) {
			case CEE_UNALIGNED:
			case CEE_TAILCALL:
			case CEE_VOLATILE:
				// for now just skip these
				break;

			case CEE_LDARGA_S:
			case CEE_LDARGA:
				result << "&";
				goto DO_LDARG;

			case CEE_LDARG_0:
			case CEE_LDARG_1:
			case CEE_LDARG_2:
			case CEE_LDARG_3:
				inlineArg.i = op.getOpcode() - CEE_LDARG_0;
				goto DO_LDARG;

			case CEE_LDARG:
			case CEE_LDARG_S:
			DO_LDARG:
				name = "arg";
			DO_LDARG_LDLOC:
				result << name << inlineArg.i;
				prec = 0x1000;
				goto DO_PUSH;
			DO_PUSH:
				pushAndClear(&result, prec);   // also clears result!
				break;

			case CEE_LDLOCA_S:
			case CEE_LDLOCA:
				result << "&";
				goto DO_LDLOC;

			case CEE_LDLOC_0:
			case CEE_LDLOC_1:
			case CEE_LDLOC_2:
			case CEE_LDLOC_3:
				inlineArg.i = op.getOpcode() - CEE_LDLOC_0;
				goto DO_LDLOC;

			case CEE_LDLOC:
			case CEE_LDLOC_S:
			DO_LDLOC:
				name = "loc";
				goto DO_LDARG_LDLOC;

			case CEE_STARG:
			case CEE_STARG_S:
				name = "arg";
			DO_STARG_STLOC:
				lhs = pop(0x10);
				result << name << inlineArg.i << " = " << lhs->val();
			DO_STMT:
				spillStack(out);
				*out << result.val() << '\n';
                    // if flow of control does not fall through, 
                    // assume the stack is empty
                if (op.getFlow() == BRANCH || op.getFlow() == RETURN ||
                    op.getFlow() == THROW) {
                    popN(stackDepth());
                }
                return(instrPtr);

			case CEE_STLOC_0:
			case CEE_STLOC_1:
			case CEE_STLOC_2:
			case CEE_STLOC_3:
				inlineArg.i = op.getOpcode() - CEE_STLOC_0;
				goto DO_STLOC;

			case CEE_STLOC:
			case CEE_STLOC_S:
			DO_STLOC:
				name = "loc";
				goto DO_STARG_STLOC;

			case CEE_LDC_I4_M1:
			case CEE_LDC_I4_0:
			case CEE_LDC_I4_1:
			case CEE_LDC_I4_2:
			case CEE_LDC_I4_3:
			case CEE_LDC_I4_4:
			case CEE_LDC_I4_5:
			case CEE_LDC_I4_6:
			case CEE_LDC_I4_7:
			case CEE_LDC_I4_8:
				inlineArg.i = op.getOpcode() - CEE_LDC_I4_0;
				// FALL THROUGH
			case CEE_LDC_I4:
			case CEE_LDC_I4_S:
				result << inlineArg.i;	
				prec = 0x1000;
				goto DO_PUSH;

			case CEE_LDC_I8:
				result.hex(inlineArg.i8);
				prec = 0x1000;
				goto DO_PUSH;

			case CEE_LDC_R4:
			case CEE_LDC_R8:
				result << inlineArg.r;
				prec = 0x1000;
				goto DO_PUSH;

			case CEE_LDNULL:
				result << "null"; 
				prec = 0x1000;
				goto DO_PUSH;

			case CEE_LDSTR:
				formatInstrArgs(op, inlineArg, &result);  
				prec = 0x1000;
				goto DO_PUSH;

			case CEE_BEQ:
			case CEE_BEQ_S:
				name = "==";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BGE:
			case CEE_BGE_S:
				name = ">=";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BGE_UN:
			case CEE_BGE_UN_S:
				name = ">=un";	prec = 0x40; 	goto DO_BR_BINOP;

			case CEE_BGT:
			case CEE_BGT_S:
				name = ">";		prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BGT_UN:
			case CEE_BGT_UN_S:
				name = ">un";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BLE:
			case CEE_BLE_S:
				name = "<=";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BLE_UN:
			case CEE_BLE_UN_S:
				name = "<=un";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BLT:
			case CEE_BLT_S:
				name = "<";		prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BLT_UN:
			case CEE_BLT_UN_S:
				name = "<un";	prec = 0x40; 	goto DO_BR_BINOP;
			case CEE_BNE_UN:
			case CEE_BNE_UN_S:
				name = "!=un";	prec = 0x40; 	goto DO_BR_BINOP;
			DO_BR_BINOP:
				rhs = pop(prec);
				lhs = pop(prec-1);
				result << "if (" << lhs->val() << ' ' << name << ' ' << rhs->val() << ") ";
				goto DO_BR;

			case CEE_LEAVE_S:
			case CEE_LEAVE:
				while (stackDepth() > 0) {
					lhs = pop();			
					*lhs << '\n' << result;		// put the result in front of anything else
					result.swap(*lhs);		
				}
                    /* fall through */
			case CEE_BR_S:
			case CEE_BR:
            DO_BR: {
                size_t target = (instrPtr - start) + inlineArg.i;
                setTarget(target, stackDepth());
                result << "goto IL_"; result.hex(target, 4, OutString::zeroFill);
                } goto DO_STMT;

			case CEE_BRFALSE_S:
			case CEE_BRFALSE:
				name = "!";		
				goto DO_BR_UNOP;
			case CEE_BRTRUE_S:
			case CEE_BRTRUE:
				name = "";	    
			DO_BR_UNOP:
				lhs = pop();
				result << "if (" << name << lhs->val() << ") ";
				goto DO_BR;
			
			case CEE_OR:
				name = "|";		prec = 0x20; 	goto DO_BINOP;
			case CEE_XOR:
				name = "^";		prec = 0x20; 	goto DO_BINOP;
			case CEE_AND:
				name = "&";		prec = 0x30; 	goto DO_BINOP;
			case CEE_SHL:
				name = "<<";	prec = 0x50; 	goto DO_BINOP;
			case CEE_SHR:
				name = ">>";	prec = 0x50; 	goto DO_BINOP;
			case CEE_SHR_UN:
				name = ">>un";	prec = 0x50; 	goto DO_BINOP;
			case CEE_CEQ:
				name = "==";	prec = 0x40; 	goto DO_BINOP;
			case CEE_CGT:
				name = ">";		prec = 0x40; 	goto DO_BINOP;
			case CEE_CGT_UN:
				name = ">un";	prec = 0x40; 	goto DO_BINOP;
			case CEE_CLT:
				name = "<";		prec = 0x40; 	goto DO_BINOP;
			case CEE_CLT_UN:
				name = "<un";	prec = 0x40; 	goto DO_BINOP;
			case CEE_ADD:
				name = "+";		prec = 0x60; 	goto DO_BINOP;
			case CEE_ADD_OVF:
				name = "+ovf";	prec = 0x60; 	goto DO_BINOP;
			case CEE_ADD_OVF_UN:
				name = "+ovf.un";prec = 0x60; 	goto DO_BINOP;
			case CEE_SUB:
				name = "-";		prec = 0x60; 	goto DO_BINOP;
			case CEE_SUB_OVF:
				name = "-ovf";	prec = 0x60; 	goto DO_BINOP;
			case CEE_SUB_OVF_UN:
				name = "-ovf.un";prec = 0x60; 	goto DO_BINOP;
			case CEE_MUL:
				name = "*";		prec = 0x70; 	goto DO_BINOP;
			case CEE_MUL_OVF:
				name = "*ovf";	prec = 0x70; 	goto DO_BINOP;
			case CEE_MUL_OVF_UN:
				name = "*ovf.un";prec = 0x70; 	goto DO_BINOP;
			case CEE_DIV:
				name = "/";		prec = 0x70; 	goto DO_BINOP;
			case CEE_DIV_UN:
				name = "/un";	prec = 0x70; 	goto DO_BINOP;
			case CEE_REM:
				name = "%";		prec = 0x70; 	goto DO_BINOP;
			case CEE_REM_UN:
				name = "%un";	prec = 0x70; 	goto DO_BINOP;
			DO_BINOP:
				rhs = pop(prec);
				lhs = pop(prec-1);
				result << lhs->val() << ' ' << name << ' ' << rhs->val();
			goto DO_PUSH;

			case CEE_NOT:
				name = "~";	prec = 0x80; 	goto DO_UNOP;
			case CEE_NEG:
				name = "-";	prec = 0x80; 	goto DO_UNOP;
			DO_UNOP:
				lhs = pop(prec-1);
				result << name << lhs->val();
			goto DO_PUSH;

			case CEE_RET:
                _ASSERTE(stackDepth() <= 1);
                result << "return"; 
                if (stackDepth() > 0) {
				    lhs = pop();
				    result << ' ' << lhs->val();
                }
			goto DO_STMT;

			case CEE_POP:
                lhs = pop();
				result.swap(*lhs);
				goto DO_STMT;
				
            case CEE_DUP: 
				spillStack(out);
				lhs = top();
				result << lhs->val();
				prec = 0x1000;		// spillstack makes them temps, so they have high prec
				goto DO_PUSH;

			case CEE_LDFLDA:
				name = "&";
				goto DO_LDFLD_LDFLDA;
			case CEE_LDFLD:
				name = "";
			DO_LDFLD_LDFLDA:
				prec = 0x110;	
				lhs = pop(prec-1);
				result << name << lhs->val() << '.';
				formatInstrArgs(op, inlineArg, &result);  
				goto DO_PUSH;
				
			case CEE_LDSFLDA:
				name = "&";
				goto DO_LDSFLD_LDSFLDA;
			case CEE_LDSFLD:
				name = "";
			DO_LDSFLD_LDSFLDA:
				prec = 0x1000;	
				result << name;
				formatInstrArgs(op, inlineArg, &result);  
				goto DO_PUSH;
		
			case CEE_STFLD:
				rhs = pop(0x10);
				lhs = pop(0x110-1);
				result << lhs->val() << '.';
				formatInstrArgs(op, inlineArg, &result);  
				result << " = " << rhs->val();
				goto DO_STMT;

			case CEE_STSFLD:
				rhs = pop(0x20);
				formatInstrArgs(op, inlineArg, &result);  
				result << " = " << rhs->val();
				goto DO_STMT;

			case CEE_CALLI:
				lhs = pop();
				result << "CALLI<" << lhs->val() << '>';
				goto DO_CALL;

			case CEE_NEWOBJ:
				result << "new ";
				// FALL THROUGH 
			case CEE_CALL:
			case CEE_CALLVIRT: {
				formatInstrArgs(op, inlineArg, &result);  

			DO_CALL:
                    // Get the signature stuff 
				PCCOR_SIGNATURE sig;
				ULONG cSig;
				HRESULT hr;
                if (TypeFromToken(inlineArg.i) == mdtMethodDef)
                    hr = meta->GetMethodProps(mdMethodDef(inlineArg.i), 0, 0, 0, 0, 0, &sig, &cSig, 0, 0);
                else if (TypeFromToken(inlineArg.i) == mdtMemberRef)
				    hr = meta->GetMemberRefProps(mdMemberRef(inlineArg.i), 0, 0, 0, 0, &sig, &cSig);
                else
				    hr = meta->GetSigFromToken(mdSignature(inlineArg.i), &sig, &cSig);
				_ASSERTE(SUCCEEDED(hr));
                unsigned hasThis = CorSigUncompressData(sig) & IMAGE_CEE_CS_CALLCONV_HASTHIS;
				unsigned numArgs = CorSigUncompressData(sig); 
				while(*sig == ELEMENT_TYPE_CMOD_REQD || *sig == ELEMENT_TYPE_CMOD_OPT) {
					sig++;
					CorSigUncompressToken(sig);	
				}

                formatArgs(numArgs, &result);
                if (hasThis && op.getOpcode() != CEE_NEWOBJ) {
                    lhs = pop(0x90);
                    result.swap(*lhs);
                    result << '.' << lhs->val();
                }
				prec = 0x1000;	
				if (op.getOpcode() == CEE_NEWOBJ || *sig != ELEMENT_TYPE_VOID)
					goto DO_PUSH;
				} goto DO_STMT;

			case CEE_LDELEM_I1: 
			case CEE_LDELEM_I2: 
			case CEE_LDELEM_I4: 
			case CEE_LDELEM_I8: 
			case CEE_LDELEM_REF:
			case CEE_LDELEM_R4: 
			case CEE_LDELEM_R8: 
			case CEE_LDELEM_U1: 
			case CEE_LDELEM_U2:
			case CEE_LDELEM_I:  
				rhs = pop(0x100);
				lhs = pop();
				result << lhs->val() << '[' << rhs->val() << ']';
				prec = 0x100;	
				goto DO_PUSH;
				
			case CEE_STELEM_I1:
			case CEE_STELEM_I2: 
			case CEE_STELEM_I4: 
			case CEE_STELEM_I8:
			case CEE_STELEM_REF:
			case CEE_STELEM_R4:
			case CEE_STELEM_R8:
			case CEE_STELEM_I: 
				rhs = pop(0x100);
				idx = pop();
				lhs = pop(0x20);
				result << lhs->val() << '[' << idx->val() << "] = " << rhs->val();
				goto DO_STMT;

			case CEE_LDIND_I1:	name = "I1"; goto DO_LDIND;
			case CEE_LDIND_I2:	name = "I2"; goto DO_LDIND;
			case CEE_LDIND_I4:	name = "I4"; goto DO_LDIND;
			case CEE_LDIND_I8:	name = "I8"; goto DO_LDIND;
			case CEE_LDIND_I:	name = "I";  goto DO_LDIND;
			case CEE_LDIND_R4:	name = "R4"; goto DO_LDIND;
			case CEE_LDIND_R8:	name = "R8"; goto DO_LDIND;
			case CEE_LDIND_U1:	name = "U1"; goto DO_LDIND;
			case CEE_LDIND_U2:	name = "U2"; goto DO_LDIND;
			case CEE_LDIND_REF:	name = "REF";goto DO_LDIND;
			DO_LDIND:
				prec = 0x90;	
				lhs = pop(prec);
				result << name << "(*" << lhs->val() << ')';
				goto DO_PUSH;
				
			case CEE_STIND_I1:	name = "I1"; goto DO_STIND;
			case CEE_STIND_I2:	name = "I2"; goto DO_STIND;
			case CEE_STIND_I4:	name = "I4"; goto DO_STIND;
			case CEE_STIND_I8:	name = "I8"; goto DO_STIND;
			case CEE_STIND_REF:	name = "REF";goto DO_STIND;
			case CEE_STIND_R4:	name = "R4"; goto DO_STIND;
			case CEE_STIND_R8:	name = "R8"; goto DO_STIND;
			DO_STIND:
				rhs = pop();
				lhs = pop(0x90);
				result << '*' << lhs->val() << " = " << name << '(' << rhs->val() << ')';
				goto DO_STMT;

			case CEE_LDVIRTFTN:
			case CEE_ARGLIST:
			case CEE_BREAK:
			case CEE_ENDFILTER:
			case CEE_CPBLK:
			case CEE_INITBLK:
			case CEE_LDOBJ:
			case CEE_CPOBJ:
			case CEE_STOBJ:
			case CEE_INITOBJ:
			case CEE_LOCALLOC:
			case CEE_NOP:
			case CEE_SWITCH:
			case CEE_CASTCLASS:
			case CEE_ISINST:
			case CEE_LDLEN:
			case CEE_JMP:
			case CEE_NEWARR:
			case CEE_THROW:
			case CEE_RETHROW:
			case CEE_LDELEM_U4:
			case CEE_LDIND_U4:
			case CEE_LDELEMA:
			case CEE_ENDFINALLY:
			case CEE_STIND_I:
			case CEE_CKFINITE:
			case CEE_MKREFANY:
			case CEE_REFANYTYPE:
			case CEE_REFANYVAL:
			case CEE_CONV_I1:
			case CEE_CONV_I2:
			case CEE_CONV_I4:
			case CEE_CONV_I8:
			case CEE_CONV_R4:
			case CEE_CONV_R8:
			case CEE_CONV_R_UN:
			case CEE_CONV_OVF_I_UN:
			case CEE_CONV_OVF_I1_UN:
			case CEE_CONV_OVF_I2_UN:
			case CEE_CONV_OVF_I4_UN:
			case CEE_CONV_OVF_I8_UN:
			case CEE_CONV_OVF_U_UN:
			case CEE_CONV_OVF_U1_UN:
			case CEE_CONV_OVF_U2_UN:
			case CEE_CONV_OVF_U4_UN:
			case CEE_CONV_OVF_U8_UN:
			case CEE_CONV_OVF_I1:
			case CEE_CONV_OVF_I2:
			case CEE_CONV_OVF_I4:
			case CEE_CONV_OVF_I8:
			case CEE_CONV_OVF_U1:
			case CEE_CONV_OVF_U2:
			case CEE_CONV_OVF_U4:
			case CEE_CONV_OVF_U8:
			case CEE_CONV_U4:
			case CEE_CONV_U8:
			case CEE_CONV_U2:
			case CEE_CONV_U1:
			case CEE_CONV_I:
			case CEE_CONV_OVF_I:
			case CEE_CONV_OVF_U:
			case CEE_CONV_U:
			case CEE_BOX:
			case CEE_UNBOX:
			case CEE_LDFTN:
			case CEE_LDTOKEN:
			case CEE_SIZEOF:
			default:
				result << op.getName();
				if (op.getArgsInfo() != InlineNone) {
					result << '<';
					formatInstrArgs(op, inlineArg, &result, instrPtr-start);  
					result << '>';
				}

				_ASSERTE(op.getNumPop() >= 0);
				if (op.getNumPop() > 0) 
                    formatArgs(op.getNumPop(), &result);
			
				prec = 0x1000;
				_ASSERTE(op.getNumPush() == 0 || op.getNumPush() == 1);
				if (op.getNumPush() > 0)
					goto DO_PUSH;
				goto DO_STMT;
		}
	}
	return(instrPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\inifile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * inifile.c - Initialization file processing module.
 */


/* Headers
 **********/

#include "stdafx.h"
#include "inifile.h"


#define WARNING_OUT(x)
#define ERROR_OUT(x)
#define PRIVATE_CODE    static
#define PRIVATE_DATA    static
#define PUBLIC_CODE 
#define PCVOID          const void *

char                *g_pcszIniFile;
char                *g_pcszIniSection;


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const PCSTR s_rgcszTrue[] =
{
   "1",
   "On",
   "True",
   "Y",
   "Yes"
};

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const PCSTR s_rgcszFalse[] =
{
   "0",
   "Off",
   "False",
   "N",
   "No"
};




/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL SetBOOLIniSwitch(BOOLINISWITCH *);
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(DECINTINISWITCH *);
PRIVATE_CODE BOOL SetIniSwitch(PCVOID);
PRIVATE_CODE BOOL IsYesString(PCSTR);
PRIVATE_CODE BOOL IsNoString(PCSTR);
PRIVATE_CODE BOOL IsStringInList(PCSTR, const PCSTR *, UINT);
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(BOOLINISWITCH *);
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(DECINTINISWITCH *);
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(UNSDECINTINISWITCH *);




/*
** SetBOOLIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetBOOLIniSwitch(BOOLINISWITCH * pcbis)
{
   DWORD dwcbKeyLen;
   char rgchRHS[MAX_INI_SWITCH_RHS_LEN];

   //   ASSERT(IS_VALID_STRUCT_PTR(pcbis, CBOOLINISWITCH));

   /* Set boolean .ini switch. */

   dwcbKeyLen = GetPrivateProfileStringA(g_pcszIniSection, pcbis->pcszKeyName, "", rgchRHS, sizeof(rgchRHS), g_pcszIniFile);

   /* Is the .ini switch set? */

   if (rgchRHS[0])
   {
      /* Yes.  Set or clear flag? */

      if (IsYesString(rgchRHS))
      {
         /* Set flag. */

         if (IS_FLAG_CLEAR(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            SET_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT(("SetBOOLIniSwitch(): %s set in %s![%s].",
                         pcbis->pcszKeyName,
                         g_pcszIniFile,
                         g_pcszIniSection));
         }
      }
      else if (IsNoString(rgchRHS))
      {
         /* Clear flag. */

         if (IS_FLAG_SET(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            CLEAR_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT(("SetBOOLIniSwitch(): %s cleared in %s![%s].",
                         pcbis->pcszKeyName,
                         g_pcszIniFile,
                         g_pcszIniSection));
         }
      }
      else
         /* Unknown flag. */
         WARNING_OUT(("SetBOOLIniSwitch(): Found unknown Boolean RHS %s for %s in %s![%s].",
                      rgchRHS,
                      pcbis->pcszKeyName,
                      g_pcszIniFile,
                      g_pcszIniSection));
   }

   return(TRUE);
}


/*
** SetDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(DECINTINISWITCH *pcdiis)
{
   INT nNewValue;

    //  ASSERT(IS_VALID_STRUCT_PTR(pcdiis, CDECINTINISWITCH));

   /* Get decimal integer .ini switch. */

   nNewValue = GetPrivateProfileIntA(g_pcszIniSection, pcdiis->pcszKeyName, *(pcdiis->pnValue), g_pcszIniFile);

   /* New value? */

   if (nNewValue != *(pcdiis->pnValue))
   {
      /* Yes. */

      *(pcdiis->pnValue) = nNewValue;

      WARNING_OUT(("SetDecimalIntIniSwitch(): %s set to %d in %s![%s].",
                   pcdiis->pcszKeyName,
                   *(pcdiis->pnValue),
                   g_pcszIniFile,
                   g_pcszIniSection));
   }

   return(TRUE);
}


/*
** SetUnsignedDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetUnsignedDecimalIntIniSwitch(UNSDECINTINISWITCH *pcudiis)
{
   INT nNewValue;

    //   ASSERT(IS_VALID_STRUCT_PTR(pcudiis, CUNSDECINTINISWITCH));

   /* Get unsigned decimal integer .ini switch as signed decimal integer. */

    //   ASSERT(*(pcudiis->puValue) <= INT_MAX);

   nNewValue = GetPrivateProfileIntA(g_pcszIniSection, pcudiis->pcszKeyName, *(pcudiis->puValue), g_pcszIniFile);

   if (nNewValue >= 0)
   {
      if ((UINT)nNewValue != *(pcudiis->puValue))
      {
         /* New non-negative value. */

         *(pcudiis->puValue) = nNewValue;

         WARNING_OUT(("SetUnsignedDecimalIntIniSwitch(): %s set to %u in %s![%s].",
                      pcudiis->pcszKeyName,
                      *(pcudiis->puValue),
                      g_pcszIniFile,
                      g_pcszIniSection));
      }
   }
   else
      /* Negative value. */
      WARNING_OUT(("SetUnsignedDecimalIntIniSwitch(): Unsigned value %s set to %d in %s![%s].  Ignored.",
                   pcudiis->pcszKeyName,
                   nNewValue,
                   g_pcszIniFile,
                   g_pcszIniSection));

   return(TRUE);
}


/*
** SetIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetIniSwitch(PCVOID pcvIniSwitch)
{
   BOOL bResult;

   // ASSERT(IS_VALID_READ_PTR((PCINISWITCHTYPE)pcvIniSwitch, CINISWITCHTYPE));

   /* Set .ini switch based upon type. */

   switch (*(INISWITCHTYPE *)pcvIniSwitch)
   {
      case IST_BOOL:
         bResult = SetBOOLIniSwitch((BOOLINISWITCH *)pcvIniSwitch);
         break;

      case IST_DEC_INT:
         bResult = SetDecimalIntIniSwitch((DECINTINISWITCH *)pcvIniSwitch);
         break;

      case IST_UNS_DEC_INT:
         bResult = SetUnsignedDecimalIntIniSwitch((UNSDECINTINISWITCH *)pcvIniSwitch);
         break;

      default:
         ERROR_OUT(("SetIniSwitch(): Unrecognized .ini switch type %d.",
                    *(PCINISWITCHTYPE)pcvIniSwitch));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/*
** IsYesString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsYesString(PCSTR pcsz)
{
   // ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, s_rgcszTrue, ARRAY_ELEMENTS(s_rgcszTrue)));
}


/*
** IsNoString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsNoString(PCSTR pcsz)
{
   // ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, s_rgcszFalse, ARRAY_ELEMENTS(s_rgcszFalse)));
}


/*
** IsStringInList()
**
** Determines whether or not a given string matches a string in a list of
** strings.
**
** Arguments:     pcsz - pointer to string to be checked
**
** Returns:       
**
** Side Effects:  none
**
** N.b., string comparison is case-insensitive.
*/
PRIVATE_CODE BOOL IsStringInList(PCSTR pcsz, const PCSTR *pcpcszList,
                                 UINT ucbStrings)
{
   UINT u;
   BOOL bFound = FALSE;

//   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
//   ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcszList, PCSTR, ucbStrings * sizeof(*pcpcszList)));

   /* Search the list for the given string. */

   for (u = 0; u < ucbStrings; u++)
   {
  //    ASSERT(IS_VALID_STRING_PTR(pcpcszList[u], CSTR));

      if (! lstrcmpiA(pcsz, pcpcszList[u]))
      {
         bFound = TRUE;
         break;
      }
   }

   return(bFound);
}


/*
** IsValidPCBOOLINIKEY()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(BOOLINISWITCH * pcbis)
{
    return TRUE;
#ifdef DICKMAN    
   return(IS_VALID_READ_PTR(pcbis, CBOOLINISWITCH) &&
          EVAL(pcbis->istype == IST_BOOL) &&
          IS_VALID_STRING_PTR(pcbis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcbis->pdwParentFlags, DWORD) &&
          EVAL(pcbis->dwFlag));
#endif          
}


/*
** IsValidPCDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(DECINTINISWITCH *pcdiis)
{
    return TRUE;
#ifdef DICKMAN    
   return(IS_VALID_READ_PTR(pcdiis, CDECINTINISWITCH) &&
          EVAL(pcdiis->istype == IST_DEC_INT) &&
          IS_VALID_STRING_PTR(pcdiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcdiis->pnValue, INT));
#endif          
}


/*
** IsValidPCUNSDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(UNSDECINTINISWITCH *pcudiis)
{
    return TRUE;
#ifdef DICKMAN    
   return(IS_VALID_READ_PTR(pcudiis, CUNSDECINTINISWITCH) &&
          EVAL(pcudiis->istype == IST_UNS_DEC_INT) &&
          IS_VALID_STRING_PTR(pcudiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcudiis->puValue, UINT));
#endif          
}


/****************************** Public Functions *****************************/


/*
** SetIniSwitches()
**
** Set flags from initialization file.
**
** Arguments:     ppcvIniSwitches - pointer to array of pointers to .ini switch
**                                  structures describing .ini switches to set
**                ucSwitches - number of .ini switch pointers in
**                             ppcvIniSwitches array
**
** Returns:       TRUE if .ini switch processing is successful.  FALSE if not.
**
** Side Effects:  none
**
** N.b, the global variables g_pcszIniFile and g_pcszIniSection must be filled in
** before calling SetIniSwitches().
*/
PUBLIC_CODE BOOL SetIniSwitches(const void **pcpcvIniSwitches, UINT ucSwitches)
{
   BOOL bResult = TRUE;
   UINT u;

  // ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcvIniSwitches, const PCVOID, ucSwitches * sizeof(*pcpcvIniSwitches)));

   /* Process .ini switches. */

   for (u = 0; u < ucSwitches; u++)
      bResult = SetIniSwitch(pcpcvIniSwitches[u]) && bResult;

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\guidfromname.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// GuidFromName

// Algorithm from Internet Draft document "UUIDs and GUIDs"
// By Paul J. Leach and Rich Sals, February 4, 1998.

// This function has been adapted from the routines in the document
//  uuid_create_from_name and format_uuid_v3

// Changes from documented routines:
// 1. Changed all instances of uuid_t to GUID.
//      uuid_t field time_low is GUID field Data1.
//      uuid_t field time_mid is GUID field Data2.
//      uuid_t field time_hi_and_version is GUID field Data3.
//      uuid_t field clock_seq_hi_and_reserved is GUID field Data4[0].
//      uuid_t field clock_seq_low is GUID field Data4[1].
//      uuid_t field node[6] is GUID field Data4[2] through Data4[8].
//
// 2. Use a c++ implementation of the md5 cryptographic hash function.
//
// 3. Implemented the htonl, htons, ntohl, ntohs socket routines as inlines.
//
// 4. Renamed variables and types to suit my biases.

/*
** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
** Digital Equipment Corporation, Maynard, Mass.
** To anyone who acknowledges that this file is provided "AS IS"
** without any express or implied warranty: permission to use, copy,
** modify, and distribute this file for any purpose is hereby
** granted without fee, provided that the above copyright notices and
** this notice appears in all source code copies, and that none of
** the names of Open Software Foundation, Inc., Hewlett-Packard
** Company, or Digital Equipment Corporation be used in advertising
** or publicity pertaining to distribution of the software without
** specific, written prior permission.  Neither Open Software
** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
** Corporation makes any representations about the suitability of
** this software for any purpose.
*/

#include "stdafx.h"

#include <wtypes.h>
#include "md5.h"                // cryptographic hash function
#include "GuidFromName.h"       // verify our function signature

// Figure out if we're compiling for a big- or little-endian machine.
// This is evaluated at compile time in retail builds.

inline bool BigEndian()
{
    unsigned long n = 0xff000000L;

    return 0 != *reinterpret_cast<unsigned char *>(&n);
}

//=============================================================================
// htons, htonl, ntohs, ntohl equivalents copied and adapted from socket library.
//=============================================================================

// HostToNetworkLong converts a 32-bit long to network byte order

inline ULONG HostToNetworkLong(ULONG hostlong)
{
    if (BigEndian())
        return hostlong;
    else
        return  ( (hostlong >> 24) & 0x000000FFL) |
                ( (hostlong >>  8) & 0x0000FF00L) |
                ( (hostlong <<  8) & 0x00FF0000L) |
                ( (hostlong << 24) & 0xFF000000L);
}

// HostToNetworkLong converts a 16-bit short to network byte order

inline USHORT HostToNetworkShort(USHORT hostshort)
{
    if (BigEndian())
        return hostshort;
    else
        return ((hostshort >> 8) & 0x00FF) | ((hostshort << 8) & 0xFF00);
}

// NetworkToHostLong converts a 32-bit long to local host byte order

inline ULONG NetworkToHostLong(ULONG netlong)
{
    if (BigEndian())
        return netlong;
    else
        return  ( (netlong >> 24) & 0x000000FFL) |
                ( (netlong >>  8) & 0x0000FF00L) |
                ( (netlong <<  8) & 0x00FF0000L) |
                ( (netlong << 24) & 0xFF000000L);
}

// NetworkToHostShort converts a 16-bit short to local host byte order

inline USHORT NetworkToHostShort(USHORT netshort)
{
    if (BigEndian())
        return netshort;
    else
        return ((netshort >> 8) & 0x00FF) | ((netshort << 8) & 0xFF00);
}

//=============================================================================
// GuidFromName(GUID * pGuidResult, REFGUID refGuidNsid, 
//              const void * pvName, DWORD dwcbName);
//=============================================================================

void GuidFromName
(
    GUID *  pGuidResult,        // resulting GUID
    REFGUID refGuidNsid,        // Name Space GUID, so identical names from
                                // different name spaces generate different GUIDs
    const void * pvName,        // the name from which to generate a GUID
    DWORD dwcbName              // name length in bytes
)
{
    MD5         md5;            // Cryptographic hash class instance
    MD5HASHDATA md5HashData;    // 128-bit hash result
    GUID        guidNsid;       // context NameSpace GUID in network byte order


    // put name space ID in network byte order so it hashes the same
    // no matter what endian machine we're on

    guidNsid = refGuidNsid;

    // The sample code in the IETF draft document discards the result of
    // htonl and htons.  I've implemented what I think is meant and I've
    // sent a note to the author asking for confirmation that this is
    // his intent.

    if (!BigEndian())   // evaluated at compile time in retail builds
    {
        guidNsid.Data1 = HostToNetworkLong (guidNsid.Data1);
        guidNsid.Data2 = HostToNetworkShort(guidNsid.Data2);
        guidNsid.Data3 = HostToNetworkShort(guidNsid.Data3);
    }

    md5.Init();
    md5.HashMore(&guidNsid, sizeof(GUID));
    md5.HashMore(pvName, dwcbName);
    md5.GetHashValue(&md5HashData);

    // the hash is in network byte order at this point

    memcpy(pGuidResult, &md5HashData, sizeof(GUID));

    // Remainder adapted from function "format_uuid_v3" in IETF draft document

    // Construct a version 3 uuid with the pseudo-random number plus a few constants.

    // convert GUID from network order to local byte order

    if (!BigEndian())   // evaluated at compile time in retail builds
    {
        pGuidResult->Data1 = NetworkToHostLong (pGuidResult->Data1);
        pGuidResult->Data2 = NetworkToHostShort(pGuidResult->Data2);
        pGuidResult->Data3 = NetworkToHostShort(pGuidResult->Data3);
    }

    // set version number 
    pGuidResult->Data3 &= 0x0FFF;   // clear version number nibble
    pGuidResult->Data3 |= (3 << 12);// set version 3 = name-based

    // set variant field
    pGuidResult->Data4[0] &= 0x3F;  // clear variant bits
    pGuidResult->Data4[0] |= 0x80;  // set variant = 100b
}



void CorGuidFromNameW
(
    GUID *  pGuidResult,        // resulting GUID
    LPCWSTR wzName,             // the unicode name from which to generate a GUID
    SIZE_T  cchName             // name length in count of unicode character
)
{
// This guid is used for calling GuidFromName function as COM+ runtime uniqualifier
//
// {69F9CBC9-DA05-11d1-9408-0000F8083460}
    static const GUID COMPLUS_RUNTIME_GUID = {0x69f9cbc9, 0xda05, 0x11d1, 
            {0x94, 0x8, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60}};

    GuidFromName(
        pGuidResult, 
        COMPLUS_RUNTIME_GUID, 
        wzName, 
        (DWORD)((cchName == -1 ? (lstrlenW(wzName)+1) : cchName) * sizeof(WCHAR)));
}

void CorIIDFromCLSID
(
	GUID *	pGuidResult,		// resulting GUID
	REFGUID GuidClsid			// CLSID from which to derive GUID.
)
{
// This guid is used for calling GuidFromName function as COM+ runtime uniqualifier
//
// {AEB11C3A-1920-11d2-8F05-00A0C9A6186D}
static const GUID COMPLUS_RUNTIME_IID_GUID = 
{ 0xaeb11c3a, 0x1920, 0x11d2, { 0x8f, 0x5, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

    GuidFromName(
        pGuidResult, 
        COMPLUS_RUNTIME_IID_GUID, 
        &GuidClsid, 
		sizeof(GUID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\internaldebug.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// InternalDebug.cpp
//
// This is internal code for debug mode which will turn on memory dump checking
// and other settings.  Call the api's according to:
//		_DbgInit		On startup to init the system.
//		_DbgRecord		Call this when you are sure you want dump checking.
//		_DbgUninit		Call at process shutdown to force the dump.
//
// The reason not to enable dumping under all circumstance is one might want
// to pre-empt the dump when you hit Ctrl+C or otherwise terminate the process.
// This is actually pretty common while unit testing code, and seeing a dump
// when you obviously did not free resources is annoying.
//
//*****************************************************************************
#include "stdafx.h"						// Standard header.
#include "utilcode.h"

#ifdef _DEBUG


//********** Forwards. ********************************************************
// These are here to avoid pulling in <crtdbg.h> for which we've defined a
// bunch of alternative functions.
typedef void *_HFILE; /* file handle pointer */
extern "C" 
{
_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );
_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );
_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );
_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );
_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );
}
#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)


//********** Globals. *********************************************************
int				g_bDumpMemoryLeaks = false; // Set to true to get a dump.


//********** Code. ************************************************************

void _DbgInit(HINSTANCE hInstance)
{
	// Set break alloc flags based on memory key if found.
	if (REGUTIL::GetLong(L"CheckMem", FALSE))
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_CHECK_ALWAYS_DF|_CRTDBG_LEAK_CHECK_DF);

	// Check to see if a break alloc has been set.  If you get memory leaks, you
	// can set this registry key in order to see the call stack for the allocation
	// number which caused the leak.
	DWORD dwBreakAlloc;
	if (dwBreakAlloc=REGUTIL::GetLong(L"BreakAlloc", 0))
		_CrtSetBreakAlloc(dwBreakAlloc);
}


void _DbgRecord()
{
	g_bDumpMemoryLeaks = true;
}

// By default, don't report these leaks
BOOL	g_fReportLeaks=FALSE;

#ifdef SHOULD_WE_CLEANUP
void SetReportingOfCRTMemoryLeaks(BOOL fShouldWeReport)
{
	g_fReportLeaks=fShouldWeReport;
}// ReportCRTMemoryLeaks;
#endif /* SHOULD_WE_CLEANUP */

void _DbgUninit()
{
	WCHAR		rcDump[512];
	BOOL		bDump = FALSE;

	bDump = g_fReportLeaks;

	if (WszGetEnvironmentVariable(L"DONT_DUMP_LEAKS", rcDump, NumItems(rcDump)))
		bDump = FALSE;

	/*
	// Should we care about this?
	else if (WszGetEnvironmentVariable(L"DUMP_CRT_LEAKS", rcDump, NumItems(rcDump)) != 0)
	{
		bDump = (*rcDump == 'Y' || *rcDump == 'y' || *rcDump == '1');
	}
*/
	if (bDump)
	{
		_CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF);
		_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
		_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
	}
}





#endif _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\jitperf.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "JitPerf.h"
#include "PerfLog.h"

//=============================================================================
// ALL THE JIT PERF STATS GATHERING CODE IS COMPILED ONLY IF THE ENABLE_JIT_PERF WAS DEFINED.
#if defined(ENABLE_JIT_PERF)

__int64 g_JitCycles = 0;
size_t g_NonJitCycles = 0;
CRITICAL_SECTION g_csJit;
__int64 g_tlsJitCycles = 0;
DWORD g_dwTlsPerfIndex;
int g_fJitPerfOn;

size_t g_dwTlsx86CodeSize = 0;
DWORD g_dwTlsx86CodeIndex;
size_t g_TotalILCodeSize = 0;
size_t g_Totalx86CodeSize = 0;
size_t g_TotalMethodsJitted = 0;

void OutputStats ()
{
    LARGE_INTEGER cycleFreq;
    if (QueryPerformanceFrequency (&cycleFreq)) 
    {
        double dJitC = (double) g_JitCycles;
        double dNonJitC = (double) g_NonJitCycles;
        double dFreq = (double)cycleFreq.QuadPart;
        double compileSpeed = (double)g_TotalILCodeSize/(dJitC/dFreq);

        PERFLOG((L"Jit Cycles", (dJitC - dNonJitC), CYCLES));
        PERFLOG((L"Jit Time", (dJitC - dNonJitC)/dFreq, SECONDS));
        PERFLOG((L"Non Jit Cycles", dNonJitC, CYCLES));
        PERFLOG((L"Non Jit Time", dNonJitC/dFreq, SECONDS));
        PERFLOG((L"Total Jit Cycles", dJitC, CYCLES));
        PERFLOG((L"Total Jit Time", dJitC/dFreq, SECONDS));
        PERFLOG((L"Methods Jitted", g_TotalMethodsJitted, COUNT));
        PERFLOG((L"IL Code Compiled", g_TotalILCodeSize, BYTES));
        PERFLOG((L"X86 Code Emitted", g_Totalx86CodeSize, BYTES));
        // Included the perf counter description in this case because its not obvious what we are reporting.
        PERFLOG((L"ExecTime", compileSpeed/1000, KBYTES_PER_SEC, L"IL Code compiled/sec"));
    }
}

void InitJitPerf(void) 
{
    wchar_t lpszValue[2];
    DWORD cchValue = 2;

    g_fJitPerfOn = WszGetEnvironmentVariable (L"JIT_PERF_OUTPUT", lpszValue, cchValue);
    if (g_fJitPerfOn && ((g_dwTlsPerfIndex = TlsAlloc()) == 0xFFFFFFFF)) 
    {
        g_fJitPerfOn = 0;
    }
    if (g_fJitPerfOn && ((g_dwTlsx86CodeIndex = TlsAlloc()) == 0xFFFFFFFF)) 
    {
        TlsFree (g_dwTlsPerfIndex);
        g_fJitPerfOn = 0;
    }
    if (g_fJitPerfOn) 
    {
        InitializeCriticalSection (&g_csJit);
    }
}

void DoneJitPerfStats()
{
    if (g_fJitPerfOn) 
    {
        TlsFree (g_dwTlsPerfIndex);
        TlsFree (g_dwTlsx86CodeIndex);

        DeleteCriticalSection (&g_csJit);
    
        // Output stats to stdout and if necessary to the perf automation file.
        OutputStats();
    }
    

}

#endif //ENABLE_JIT_PERF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\log.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Simple Logging Facility
//
#include "stdafx.h" 

//
// Define LOGGING by default in a checked build. If you want to log in a free
// build, define logging independent of _DEBUG here and each place you want
// to use it.
//
#ifdef _DEBUG
#define LOGGING
#endif

#include "log.h"
#include "utilcode.h"
#include "inifile.h"



#ifdef LOGGING

//@TODO put in common header somewhere....
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

#define DEFAULT_LOGFILE_NAME    "COMPLUS.LOG"

#define LOG_ENABLE_FILE_LOGGING         0x0001
#define LOG_ENABLE_FLUSH_FILE           0x0002
#define LOG_ENABLE_CONSOLE_LOGGING      0x0004
#define LOG_ENABLE_APPEND_FILE          0x0010
#define LOG_ENABLE_DEBUGGER_LOGGING     0x0020
#define LOG_ENABLE                      0x0040 


static DWORD    LogFlags                    = 0;
static char     szLogFileName[MAX_PATH+1]   = DEFAULT_LOGFILE_NAME;
static HANDLE   LogFileHandle               = INVALID_HANDLE_VALUE;
static DWORD    LogFacilityMask             = 0xFFFFFFFF;
static DWORD    LogVMLevel                  = 5;        
        // @todo FIX should probably only display warnings and above by default


VOID InitLogging()
{

        // FIX bit of a hack for now, check for the log file in the
        // registry and if there, turn on file logging VPM
    LogFlags |= REGUTIL::GetConfigFlag(L"LogEnable", LOG_ENABLE);
    LogFacilityMask = REGUTIL::GetConfigDWORD(L"LogFacility", LogFacilityMask) | LF_ALWAYS;
    LogVMLevel = REGUTIL::GetConfigDWORD(L"LogLevel", LogVMLevel);
    LogFlags |= REGUTIL::GetConfigFlag(L"LogFileAppend", LOG_ENABLE_APPEND_FILE);
    LogFlags |= REGUTIL::GetConfigFlag(L"LogFlushFile",  LOG_ENABLE_FLUSH_FILE);
    LogFlags |= REGUTIL::GetConfigFlag(L"LogToDebugger", LOG_ENABLE_DEBUGGER_LOGGING);
    LogFlags |= REGUTIL::GetConfigFlag(L"LogToFile",     LOG_ENABLE_FILE_LOGGING);
    LogFlags |= REGUTIL::GetConfigFlag(L"LogToConsole",  LOG_ENABLE_CONSOLE_LOGGING);
    
    LPWSTR fileName = REGUTIL::GetConfigString(L"LogFile");
    if (fileName != 0) 
    {
        int ret = WszWideCharToMultiByte(CP_ACP, 0, fileName, -1, szLogFileName, sizeof(szLogFileName)-1, NULL, NULL);
        _ASSERTE(ret != 0);
        delete fileName;
    }

    if ((LogFlags & LOG_ENABLE) &&
        (LogFlags & LOG_ENABLE_FILE_LOGGING) &&
        (LogFileHandle == INVALID_HANDLE_VALUE))
    {
        DWORD fdwCreate = (LogFlags & LOG_ENABLE_APPEND_FILE) ? OPEN_ALWAYS : CREATE_ALWAYS;
        LogFileHandle = CreateFileA(
            szLogFileName, 
            GENERIC_WRITE, 
            FILE_SHARE_READ, 
            NULL, 
            fdwCreate, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |  ((LogFlags & LOG_ENABLE_FLUSH_FILE) ? FILE_FLAG_WRITE_THROUGH : 0), 
            NULL);
            
            // Some other logging may be going on, try again with another file name
        if (LogFileHandle == INVALID_HANDLE_VALUE) 
        {
            char* ptr = szLogFileName + strlen(szLogFileName) + 1;
            ptr[-1] = '.'; 
            ptr[0] = '0'; 
            ptr[1] = 0;

            for(int i = 0; i < 10; i++) 
            {
                LogFileHandle = CreateFileA(
                    szLogFileName, 
                    GENERIC_WRITE, 
                    FILE_SHARE_READ, 
                    NULL, 
                    fdwCreate, 
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |  ((LogFlags & LOG_ENABLE_FLUSH_FILE) ? FILE_FLAG_WRITE_THROUGH : 0), 
                    NULL);
                if (LogFileHandle != INVALID_HANDLE_VALUE)
                    break;
                *ptr = *ptr + 1;
            }
            if (LogFileHandle == INVALID_HANDLE_VALUE) {
                DWORD       written;
                char buff[MAX_PATH+60];
                strcpy(buff, "Could not open log file, logging to ");
                strcat(buff, szLogFileName);
                // ARULM--Changed WriteConsoleA to WriteFile to be CE compat
                WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), buff, (DWORD)strlen(buff), &written, 0);
                }
        }
        if (LogFileHandle == INVALID_HANDLE_VALUE)
            WszMessageBoxInternal(NULL, L"Could not open log file", L"CLR logging", MB_OK|MB_ICONINFORMATION);
        if (LogFileHandle != INVALID_HANDLE_VALUE)
        {
            if (LogFlags & LOG_ENABLE_APPEND_FILE)
                SetFilePointer(LogFileHandle, 0, NULL, FILE_END);
            LogSpew( LF_ALL, FATALERROR, "************************ New Output *****************\n" );
        }        
    }
}

VOID InitializeLogging()
{
	static bool bInit = false;
	if (bInit)
		return;
	bInit = true;

    InitLogging();      // You can call this in the debugger to fetch new settings
}

VOID FlushLogging() {
    if (LogFileHandle != INVALID_HANDLE_VALUE)
        FlushFileBuffers( LogFileHandle );
}

VOID ShutdownLogging()
{
    if (LogFileHandle != INVALID_HANDLE_VALUE) {
        LogSpew( LF_ALL, FATALERROR, "Logging shutting down\n");
        CloseHandle( LogFileHandle );
        }
    LogFileHandle = INVALID_HANDLE_VALUE;
}


bool LoggingEnabled()
{
	return ((LogFlags & LOG_ENABLE) != 0);
}


bool LoggingOn(DWORD facility, DWORD level) {

	return((LogFlags & LOG_ENABLE) &&
		   level <= LogVMLevel && 
		   (facility & LogFacilityMask));
}

//
// Don't use me directly, use the macros in log.h
//
VOID LogSpewValist(DWORD facility, DWORD level, char *fmt, va_list args)
{
    if (!LoggingOn(facility, level))
		return;


// We must operate with a very small stack (in case we're logging durring
// a stack overflow)

	const int BUFFERSIZE = 1000;
	// We're going to bypass our debug memory allocator and just allocate memory from
	// the process heap. Why? Because our debug memory allocator will log out of memory
	// conditions. If we're low on memory, and we try to log an out of memory condition, and we try
	// and allocate memory again using the debug allocator, we could (and probably will) hit
	// another low memory condition, try to log it, and we spin indefinately until we hit a stack overflow.
	HANDLE		hProcessHeap = GetProcessHeap();
	char *		pBuffer = (char*)HeapAlloc(hProcessHeap, 0, BUFFERSIZE*sizeof(char));
    DWORD       buflen = 0;
    DWORD       written;
    BOOL		fAllocBuf1 = TRUE;
    BOOL		fAllocBuf2 = TRUE;
    
	static bool needsPrefix = true;

	_ASSERTE(pBuffer != NULL);
	if (pBuffer == NULL)
	{
		pBuffer = "Error Allocating memory for logging!";
		buflen = 36;
		fAllocBuf1 = FALSE;
	}
	else
	{
		if (needsPrefix)
			buflen = wsprintfA(pBuffer, "TID %03x: ", GetCurrentThreadId());

		needsPrefix = (fmt[strlen(fmt)-1] == '\n');

		int cCountWritten = _vsnprintf(&pBuffer[buflen], BUFFERSIZE-buflen, fmt, args );
		pBuffer[BUFFERSIZE-1] = 0;
		if (cCountWritten < 0) {
			buflen = BUFFERSIZE - 1;
		} else {
			buflen += cCountWritten;
		}
	
    	// Its a little late for this, but at least you wont continue
    	// trashing your program...
    	_ASSERTE((buflen < BUFFERSIZE) && "Log text is too long!") ;
	}

	//convert NL's to CR NL to fixup notepad
	const int BUFFERSIZE2 = BUFFERSIZE + 500;
	char * pBuffer2 = (char*)HeapAlloc(hProcessHeap, 0, BUFFERSIZE2*sizeof(char));
	_ASSERTE(pBuffer2 != NULL);

	if (pBuffer2 != NULL && fAllocBuf1)
	{
		char *d = pBuffer2;
		for (char *p = pBuffer; *p != '\0'; p++)
		{
			if (*p == '\n') {
				_ASSERTE(d < pBuffer2 + BUFFERSIZE2);
				*(d++) = '\r';				
			}
		
			_ASSERTE(d < pBuffer2 + BUFFERSIZE2);
			*(d++) = *p;			
		}
		HeapFree(hProcessHeap, 0, pBuffer);

		buflen = (DWORD)(d - pBuffer2);
		pBuffer = pBuffer2;
	}

    if (LogFlags & LOG_ENABLE_FILE_LOGGING && LogFileHandle != INVALID_HANDLE_VALUE)
    {
        WriteFile(LogFileHandle, pBuffer, buflen, &written, NULL);
        if (LogFlags & LOG_ENABLE_FLUSH_FILE) {
            FlushFileBuffers( LogFileHandle );
		}
    }

    if (LogFlags & LOG_ENABLE_CONSOLE_LOGGING)
    {
    	// ARULM--Changed WriteConsoleA to WriteFile to be CE compat
        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), pBuffer, buflen, &written, 0);
        //@TODO ...Unnecessary to flush console?
        if (LogFlags & LOG_ENABLE_FLUSH_FILE)
            FlushFileBuffers( GetStdHandle(STD_OUTPUT_HANDLE) );
    }

    if (LogFlags & LOG_ENABLE_DEBUGGER_LOGGING)
    {
        OutputDebugStringA(pBuffer);
    }        
	if (fAllocBuf1)
		HeapFree(hProcessHeap, 0, pBuffer);
}

VOID LogSpew(DWORD facility, DWORD level, char *fmt, ... )
{
    va_list     args;
    va_start( args, fmt );
    LogSpewValist (facility, level, fmt, args);
}

VOID LogSpewAlways (char *fmt, ... )
{
    va_list     args;
    va_start( args, fmt );
    LogSpewValist (LF_ALWAYS, LL_ALWAYS, fmt, args);
}

#endif // LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\md5.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// md5.cpp
//
#include "stdafx.h"

#include <stdlib.h>
#include <wtypes.h>
#include "md5.h"

void MD5::Init(BOOL fConstructed)
    {
    // These two fields are read only, and so initialization thereof can be 
    // omitted on the second and subsequent hashes using this same instance.
    //
    if (!fConstructed)
        {
        memset(m_padding, 0, 64);
        m_padding[0]=0x80;
        }

    m_cbitHashed = 0;
    m_cbData     = 0;
    m_a = 0x67452301;   // magic
    m_b = 0xefcdab89;   //      ... constants
    m_c = 0x98badcfe;   //              ... per
    m_d = 0x10325476;   //                      .. RFC1321
    }


void MD5::HashMore(const void* pvInput, ULONG cbInput)
// Hash the additional data into the state
    {
    const BYTE* pbInput = (const BYTE*)pvInput;

    m_cbitHashed += (cbInput<<3);

    ULONG cbRemaining = 64 - m_cbData;
    if (cbInput < cbRemaining)
        {
        // It doesn't fill up the buffer, so just store it
        memcpy(&m_data[m_cbData], pbInput, cbInput);
        m_cbData += cbInput;
        }
    else
        {
        // It does fill up the buffer. Fill up all that it will take
        memcpy(&m_data[m_cbData], pbInput, cbRemaining);

        // Hash the now-full buffer
        MD5Transform(m_state, (ULONG*)&m_data[0]);
        cbInput -= cbRemaining;
        pbInput += cbRemaining;

        // Hash the data in 64-byte runs, starting just after what we've copied
        while (cbInput >= 64)
            {
            MD5Transform(m_state, (ULONG*)pbInput);
            pbInput += 64;
            cbInput -= 64;
            }

        // Store the tail of the input into the buffer
        memcpy(&m_data[0], pbInput, cbInput);
        m_cbData = cbInput;
        }
    }


void MD5::GetHashValue(MD5HASHDATA* phash)
// Finalize the hash by appending the necessary padding and length count. Then
// return the final hash value.
    {
    union {
        ULONGLONG cbitHashed;
        BYTE      rgb[8];
        }u;

    // Remember how many bits there were in the input data
    u.cbitHashed = m_cbitHashed;

    // Calculate amount of padding needed. Enough so total byte count hashed is 56 mod 64
    ULONG cbPad = (m_cbData < 56 ? 56-m_cbData : 120-m_cbData);

    // Hash the padding
    HashMore(&m_padding[0], cbPad);

    // Hash the (before padding) bit length
    HashMore(&u.rgb[0], 8);

    // Return the hash value
    memcpy(phash, &m_a, 16);
    }




// We have two implementations of the core 'transform' at the heart
// of this hash: one in C, another in x86 assembler.
//
#if !defined(_X86_)
#define USE_C_MD5_TRANSFORM
#endif

#ifdef USE_C_MD5_TRANSFORM

    ////////////////////////////////////////////////////////////////
    //
    // ROTATE_LEFT should be a macro that updates its first operand
    // with its present value rotated left by the amount of its 
    // second operand, which is always a constant.
    // 
    // One way to portably do it would be
    //
    //      #define ROL(x, n)        (((x) << (n)) | ((x) >> (32-(n))))
    //      #define ROTATE_LEFT(x,n) (x) = ROL(x,n)
    //
    // but our compiler has an intrinsic!

    #define ROTATE_LEFT(x,n) (x) = _lrotl(x,n)

    ////////////////////////////////////////////////////////////////
    //
    // Constants used in each of the various rounds

    #define MD5_S11 7
    #define MD5_S12 12
    #define MD5_S13 17
    #define MD5_S14 22
    #define MD5_S21 5
    #define MD5_S22 9
    #define MD5_S23 14
    #define MD5_S24 20
    #define MD5_S31 4
    #define MD5_S32 11
    #define MD5_S33 16
    #define MD5_S34 23
    #define MD5_S41 6
    #define MD5_S42 10
    #define MD5_S43 15
    #define MD5_S44 21

    ////////////////////////////////////////////////////////////////
    //
    // The core twiddle functions

//  #define F(x, y, z) (((x) & (y)) | ((~x) & (z)))         // the function per the standard
    #define F(x, y, z) ((((z) ^ (y)) & (x)) ^ (z))          // an alternate encoding

//  #define G(x, y, z) (((x) & (z)) | ((y) & (~z)))         // the function per the standard
    #define G(x, y, z) ((((x) ^ (y)) & (z)) ^ (y))          // an alternate encoding

    #define H(x, y, z) ((x) ^ (y) ^ (z))

    #define I(x, y, z) ((y) ^ ((x) | (~z)))

    #define AC(ac)  ((ULONG)(ac))
    
    ////////////////////////////////////////////////////////////////

    #define FF(a, b, c, d, x, s, ac) { \
        (a) += F (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define GG(a, b, c, d, x, s, ac) { \
        (a) += G (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    ////////////////////////////////////////////////////////////////

    #define HH(a, b, c, d, x, s, ac) { \
        (a) += H (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define II(a, b, c, d, x, s, ac) { \
        (a) += I (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
        {
        ULONG a=state[0];
        ULONG b=state[1];
        ULONG c=state[2];
        ULONG d=state[3];

        // Round 1
        FF (a, b, c, d, data[ 0], MD5_S11, 0xd76aa478); // 1 
        FF (d, a, b, c, data[ 1], MD5_S12, 0xe8c7b756); // 2 
        FF (c, d, a, b, data[ 2], MD5_S13, 0x242070db); // 3 
        FF (b, c, d, a, data[ 3], MD5_S14, 0xc1bdceee); // 4 
        FF (a, b, c, d, data[ 4], MD5_S11, 0xf57c0faf); // 5 
        FF (d, a, b, c, data[ 5], MD5_S12, 0x4787c62a); // 6 
        FF (c, d, a, b, data[ 6], MD5_S13, 0xa8304613); // 7 
        FF (b, c, d, a, data[ 7], MD5_S14, 0xfd469501); // 8 
        FF (a, b, c, d, data[ 8], MD5_S11, 0x698098d8); // 9 
        FF (d, a, b, c, data[ 9], MD5_S12, 0x8b44f7af); // 10 
        FF (c, d, a, b, data[10], MD5_S13, 0xffff5bb1); // 11 
        FF (b, c, d, a, data[11], MD5_S14, 0x895cd7be); // 12 
        FF (a, b, c, d, data[12], MD5_S11, 0x6b901122); // 13 
        FF (d, a, b, c, data[13], MD5_S12, 0xfd987193); // 14 
        FF (c, d, a, b, data[14], MD5_S13, 0xa679438e); // 15 
        FF (b, c, d, a, data[15], MD5_S14, 0x49b40821); // 16 

        // Round 2
        GG (a, b, c, d, data[ 1], MD5_S21, 0xf61e2562); // 17 
        GG (d, a, b, c, data[ 6], MD5_S22, 0xc040b340); // 18 
        GG (c, d, a, b, data[11], MD5_S23, 0x265e5a51); // 19 
        GG (b, c, d, a, data[ 0], MD5_S24, 0xe9b6c7aa); // 20 
        GG (a, b, c, d, data[ 5], MD5_S21, 0xd62f105d); // 21 
        GG (d, a, b, c, data[10], MD5_S22,  0x2441453); // 22 
        GG (c, d, a, b, data[15], MD5_S23, 0xd8a1e681); // 23 
        GG (b, c, d, a, data[ 4], MD5_S24, 0xe7d3fbc8); // 24 
        GG (a, b, c, d, data[ 9], MD5_S21, 0x21e1cde6); // 25 
        GG (d, a, b, c, data[14], MD5_S22, 0xc33707d6); // 26 
        GG (c, d, a, b, data[ 3], MD5_S23, 0xf4d50d87); // 27 
        GG (b, c, d, a, data[ 8], MD5_S24, 0x455a14ed); // 28 
        GG (a, b, c, d, data[13], MD5_S21, 0xa9e3e905); // 29 
        GG (d, a, b, c, data[ 2], MD5_S22, 0xfcefa3f8); // 30 
        GG (c, d, a, b, data[ 7], MD5_S23, 0x676f02d9); // 31 
        GG (b, c, d, a, data[12], MD5_S24, 0x8d2a4c8a); // 32 

        // Round 3
        HH (a, b, c, d, data[ 5], MD5_S31, 0xfffa3942); // 33 
        HH (d, a, b, c, data[ 8], MD5_S32, 0x8771f681); // 34 
        HH (c, d, a, b, data[11], MD5_S33, 0x6d9d6122); // 35 
        HH (b, c, d, a, data[14], MD5_S34, 0xfde5380c); // 36 
        HH (a, b, c, d, data[ 1], MD5_S31, 0xa4beea44); // 37 
        HH (d, a, b, c, data[ 4], MD5_S32, 0x4bdecfa9); // 38 
        HH (c, d, a, b, data[ 7], MD5_S33, 0xf6bb4b60); // 39 
        HH (b, c, d, a, data[10], MD5_S34, 0xbebfbc70); // 40 
        HH (a, b, c, d, data[13], MD5_S31, 0x289b7ec6); // 41 
        HH (d, a, b, c, data[ 0], MD5_S32, 0xeaa127fa); // 42 
        HH (c, d, a, b, data[ 3], MD5_S33, 0xd4ef3085); // 43 
        HH (b, c, d, a, data[ 6], MD5_S34,  0x4881d05); // 44 
        HH (a, b, c, d, data[ 9], MD5_S31, 0xd9d4d039); // 45 
        HH (d, a, b, c, data[12], MD5_S32, 0xe6db99e5); // 46 
        HH (c, d, a, b, data[15], MD5_S33, 0x1fa27cf8); // 47 
        HH (b, c, d, a, data[ 2], MD5_S34, 0xc4ac5665); // 48 

        // Round 4
        II (a, b, c, d, data[ 0], MD5_S41, 0xf4292244); // 49 
        II (d, a, b, c, data[ 7], MD5_S42, 0x432aff97); // 50 
        II (c, d, a, b, data[14], MD5_S43, 0xab9423a7); // 51 
        II (b, c, d, a, data[ 5], MD5_S44, 0xfc93a039); // 52 
        II (a, b, c, d, data[12], MD5_S41, 0x655b59c3); // 53 
        II (d, a, b, c, data[ 3], MD5_S42, 0x8f0ccc92); // 54 
        II (c, d, a, b, data[10], MD5_S43, 0xffeff47d); // 55 
        II (b, c, d, a, data[ 1], MD5_S44, 0x85845dd1); // 56 
        II (a, b, c, d, data[ 8], MD5_S41, 0x6fa87e4f); // 57 
        II (d, a, b, c, data[15], MD5_S42, 0xfe2ce6e0); // 58 
        II (c, d, a, b, data[ 6], MD5_S43, 0xa3014314); // 59 
        II (b, c, d, a, data[13], MD5_S44, 0x4e0811a1); // 60 
        II (a, b, c, d, data[ 4], MD5_S41, 0xf7537e82); // 61 
        II (d, a, b, c, data[11], MD5_S42, 0xbd3af235); // 62 
        II (c, d, a, b, data[ 2], MD5_S43, 0x2ad7d2bb); // 63 
        II (b, c, d, a, data[ 9], MD5_S44, 0xeb86d391); // 64 

        state[0] += a;
        state[1] += b;
        state[2] += c;
        state[3] += d;
        }

#else

    __declspec(naked) void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
    // This implementation uses some pretty funky arithmetic identities
    // to effect its logic. Way cool! Kudos to whomever came up with this.
    //
        {
        __asm
            {
            push        ebx
            push        esi
            
            mov         ecx,dword ptr [esp+10h]     // data pointer to ecx
            
            push        edi
            mov         edi,dword ptr [esp+10h]     // state pointer to edi
            
            push        ebp
            mov         ebx,dword ptr [edi+4]       // ebx = b
            mov         ebp,dword ptr [edi+8]       // ebp = c
            mov         edx,dword ptr [edi+0Ch]     // edx = d
            
            mov         eax,edx                     // eax = d
            xor         eax,ebp                     // eax =    d xor c
            and         eax,ebx                     // eax =   (d xor c) ^ b
            xor         eax,edx                     // eax =  ((d xor c) ^ b) xor d
            add         eax,dword ptr [ecx]         // eax = (((d xor c) ^ b) xor d) + data[0]
            add         eax,dword ptr [edi]         // eax = (((d xor c) ^ b) xor d) + data[0] + a
            sub         eax,28955B88h               // eax = (((d xor c) ^ b) xor d) + data[0] + a + ac
            rol         eax,7                       // rotated left in the standard way
            lea         esi,dword ptr [eax+ebx]     // store temp sum in esi
            
            mov         eax,ebp                     // eax =        c
            xor         eax,ebx                     // eax =  b xor c
            and         eax,esi                     // eax = (b xor c) ^ ...
            xor         eax,ebp
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [edx+eax-173848AAh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [ebp+eax+242070DBh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+0Ch]
            lea         eax,dword ptr [ebx+eax-3E423112h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [esi+eax-0A83F051h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+14h]
            lea         eax,dword ptr [edx+eax+4787C62Ah]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edi+eax-57CFB9EDh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [ebx+eax-2B96AFFh]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+20h]
            lea         eax,dword ptr [esi+eax+698098D8h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edx+eax-74BB0851h]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+28h]
            lea         eax,dword ptr [edi+eax-0A44Fh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-76A32842h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+30h]
            lea         eax,dword ptr [esi+eax+6B901122h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [edx+eax-2678E6Dh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+38h]
            lea         eax,dword ptr [edi+eax-5986BC72h]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [ebx+eax+49B40821h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [esi+eax-9E1DA9Eh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edx+eax-3FBF4CC0h]
            rol         eax,9
            add         eax,esi
            
            mov         edx,eax                             // edx =    x
            xor         edx,esi                             // edx =   (x xor y)
            and         edx,ebx                             // edx =  ((x xor y) and z)
            xor         edx,esi                             // edx = (((x xor y) and z) xor y)
            add         edx,dword ptr [ecx+2Ch]             // edx = (((x xor y) and z) xor y) + data
            lea         edx,dword ptr [edi+edx+265E5A51h]   // edx = (((x xor y) and z) xor y) + data + ...
            rol         edx,0Eh
            lea         edi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,edi
            and         edx,esi
            xor         edx,eax
            add         edx,dword ptr [ecx]
            lea         edx,dword ptr [ebx+edx-16493856h]
            mov         ebx,edi
            rol         edx,14h
            add         edx,edi

            xor         ebx,edx
            and         ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+14h]
            lea         esi,dword ptr [esi+ebx-29D0EFA3h]
            mov         ebx,edx
            rol         esi,5
            add         esi,edx

            xor         ebx,esi
            and         ebx,edi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+28h]
            lea         eax,dword ptr [eax+ebx+2441453h]
            rol         eax,9
            lea         ebx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [edi+eax-275E197Fh]
            rol         eax,0Eh
            lea         edi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,edi
            and         eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [edx+eax-182C0438h]
            mov         edx,edi
            rol         eax,14h
            add         eax,edi
            
            xor         edx,eax
            and         edx,ebx
            xor         edx,edi
            add         edx,dword ptr [ecx+24h]
            lea         edx,dword ptr [esi+edx+21E1CDE6h]
            rol         edx,5
            lea         esi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,esi
            and         edx,edi
            xor         edx,eax
            add         edx,dword ptr [ecx+38h]
            lea         edx,dword ptr [ebx+edx-3CC8F82Ah]
            rol         edx,9
            add         edx,esi
            
            mov         ebx,edx
            xor         ebx,esi
            and         ebx,eax
            xor         ebx,esi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edi,dword ptr [edi+ebx-0B2AF279h]
            mov         ebx,edx
            rol         edi,0Eh
            add         edi,edx
            
            xor         ebx,edi
            and         ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+455A14EDh]
            rol         eax,14h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [esi+eax-561C16FBh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [edx+eax-3105C08h]
            rol         eax,9
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,ebx
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [edi+eax+676F02D9h]
            rol         eax,0Eh
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,edi
            mov         ebp,eax
            and         ebp,esi
            xor         ebp,edx
            add         ebp,dword ptr [ecx+30h]
            lea         ebx,dword ptr [ebx+ebp-72D5B376h]
            rol         ebx,14h
            add         ebx,edi
            
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+14h]
            lea         eax,dword ptr [esi+ebp-5C6BEh]
            mov         esi,edi
            rol         eax,4
            add         eax,ebx
            
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+20h]
            lea         edx,dword ptr [edx+esi-788E097Fh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         esi,edx
            mov         ebp,edx
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+2Ch]
            lea         esi,dword ptr [edi+esi+6D9D6122h]
            rol         esi,10h
            add         esi,edx
            
            xor         ebp,esi
            mov         edi,ebp
            xor         edi,eax
            add         edi,dword ptr [ecx+38h]
            lea         edi,dword ptr [ebx+edi-21AC7F4h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebx,edi
            xor         ebx,ebp
            add         ebx,dword ptr [ecx+4]
            lea         eax,dword ptr [eax+ebx-5B4115BCh]
            mov         ebx,esi
            rol         eax,4
            add         eax,edi
            
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+10h]
            lea         edx,dword ptr [edx+ebx+4BDECFA9h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+1Ch]
            lea         esi,dword ptr [esi+ebx-944B4A0h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+28h]
            lea         edi,dword ptr [edi+ebp-41404390h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+34h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp+289B7EC6h]
            rol         eax,4
            add         eax,edi
            
            xor         ebx,eax
            add         ebx,dword ptr [ecx]
            lea         edx,dword ptr [edx+ebx-155ED806h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+0Ch]
            lea         esi,dword ptr [esi+ebx-2B10CF7Bh]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+18h]
            lea         edi,dword ptr [edi+ebp+4881D05h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+24h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp-262B2FC7h]
            rol         eax,4
            add         eax,edi

            xor         ebx,eax
            add         ebx,dword ptr [ecx+30h]
            lea         edx,dword ptr [edx+ebx-1924661Bh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+3Ch]
            lea         esi,dword ptr [esi+ebx+1FA27CF8h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+8]
            lea         edi,dword ptr [edi+ebx-3B53A99Bh]
            mov         ebx,edx
            rol         edi,17h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx]
            lea         eax,dword ptr [eax+ebx-0BD6DDBCh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+1Ch]
            lea         edx,dword ptr [edx+ebx+432AFF97h]
            mov         ebx,edi
            rol         edx,0Ah
            not         ebx
            add         edx,eax
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+38h]
            lea         esi,dword ptr [esi+ebx-546BDC59h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+14h]
            lea         edi,dword ptr [edi+ebx-36C5FC7h]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+30h]
            lea         eax,dword ptr [eax+ebx+655B59C3h]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edx,dword ptr [edx+ebx-70F3336Eh]
            rol         edx,0Ah
            add         edx,eax
            mov         ebx,edi
            not         ebx
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+28h]
            lea         esi,dword ptr [esi+ebx-100B83h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+4]
            lea         edi,dword ptr [edi+ebx-7A7BA22Fh]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+6FA87E4Fh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+3Ch]
            lea         edx,dword ptr [edx+ebx-1D31920h]
            rol        edx,0Ah
            lea         ebx,dword ptr [eax+edx]
            mov         edx,edi
            not         edx
            
            or          edx,ebx
            xor         edx,eax
            add         edx,dword ptr [ecx+18h]
            lea         edx,dword ptr [esi+edx-5CFEBCECh]
            rol         edx,0Fh
            lea         esi,dword ptr [ebx+edx]
            mov         edx,eax
            not         edx
            
            or          edx,esi
            xor         edx,ebx
            add         edx,dword ptr [ecx+34h]
            lea         edx,dword ptr [edi+edx+4E0811A1h]
            rol         edx,15h
            lea         edi,dword ptr [esi+edx]
            mov         edx,ebx
            not         edx
            
            or          edx,edi
            xor         edx,esi
            add         edx,dword ptr [ecx+10h]
            lea         eax,dword ptr [eax+edx-8AC817Eh]
            rol         eax,6
            lea         edx,dword ptr [edi+eax]
            mov         eax,esi
            not         eax
            
            or          eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-42C50DCBh]
            rol         eax,0Ah
            lea         ebx,dword ptr [edx+eax]
            mov         eax,edi
            not         eax
            
            or          eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [esi+eax+2AD7D2BBh]
            rol         eax,0Fh
            lea         esi,dword ptr [ebx+eax]
            mov         eax,edx
            not         eax
            
            or          eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edi+eax-14792C6Fh]
            mov         edi,dword ptr [esp+14h]
            rol         eax,15h
            add         eax,esi
            
            add         edx,dword ptr [edi]             // add in starting state
            add         eax,dword ptr [edi+4]
            add         esi,dword ptr [edi+8]
            add         ebx,dword ptr [edi+0Ch]
            
            pop         ebp
            mov         dword ptr [edi],edx             // store back new state
            mov         dword ptr [edi+4],eax
            mov         dword ptr [edi+8],esi
            mov         dword ptr [edi+0Ch],ebx

            pop         edi
            pop         esi
            pop         ebx

            ret         8
            }
        }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\makepath.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*makepath.c - create path name from components
*
*Purpose:
*       To provide support for creation of full path names from components
*
*******************************************************************************/
#include "stdafx.h"
#include "WinWrap.h"



/***
*void _makepath() - build path name from components
*
*Purpose:
*       create a path name from its individual components
*
*Entry:
*       WCHAR *path  - pointer to buffer for constructed path
*       WCHAR *drive - pointer to drive component, may or may not contain
*                     trailing ':'
*       WCHAR *dir   - pointer to subdirectory component, may or may not include
*                     leading and/or trailing '/' or '\' characters
*       WCHAR *fname - pointer to file base name component
*       WCHAR *ext   - pointer to extension component, may or may not contain
*                     a leading '.'.
*
*Exit:
*       path - pointer to constructed path name
*
*Exceptions:
*
*******************************************************************************/

void MakePath (
        register WCHAR *path,
        const WCHAR *drive,
        const WCHAR *dir,
        const WCHAR *fname,
        const WCHAR *ext
        )
{
        register const WCHAR *p;

        /* we assume that the arguments are in the following form (although we
         * do not diagnose invalid arguments or illegal filenames (such as
         * names longer than 8.3 or with illegal characters in them)
         *
         *  drive:
         *      A           ; or
         *      A:
         *  dir:
         *      \top\next\last\     ; or
         *      /top/next/last/     ; or
         *      either of the above forms with either/both the leading
         *      and trailing / or \ removed.  Mixed use of '/' and '\' is
         *      also tolerated
         *  fname:
         *      any valid file name
         *  ext:
         *      any valid extension (none if empty or null )
         */

        /* copy drive */

        if (drive && *drive) {
                *path++ = *drive;
                *path++ = _T(':');
        }

        /* copy dir */

        if ((p = dir) && *p) {
                do {
                        *path++ = *p++;
                }
                while (*p);
#ifdef _MBCS
                if (*(p=_mbsdec(dir,p)) != _T('/') && *p != _T('\\')) {
#else  /* _MBCS */
                if (*(p-1) != _T('/') && *(p-1) != _T('\\')) {
#endif  /* _MBCS */
                        *path++ = _T('\\');
                }
        }

        /* copy fname */

        if (p = fname) {
                while (*p) {
                        *path++ = *p++;
                }
        }

        /* copy ext, including 0-terminator - check to see if a '.' needs
         * to be inserted.
         */

        if (p = ext) {
                if (*p && *p != _T('.')) {
                        *path++ = _T('.');
                }
                while (*path++ = *p++)
                        ;
        }
        else {
                /* better add the 0-terminator */
                *path = _T('\0');
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\loaderheap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"                     // Precompiled header key.
#include "utilcode.h"
#include "wsperf.h"
#if defined( MAXALLOC )
#include "dbgalloc.h"
#endif // MAXALLOC
#include "PerfCounters.h"

FnUtilCodeCallback UtilCodeCallback::OutOfMemoryCallback = NULL;

#ifdef _DEBUG
DWORD UnlockedLoaderHeap::s_dwNumInstancesOfLoaderHeaps = 0;
#endif // _DEBUG

//
// RangeLists are constructed so they can be searched from multiple
// threads without locking.  They do require locking in order to 
// be safely modified, though.
//

RangeList::RangeList()
{
	InitBlock(&m_starterBlock);
		 
	m_firstEmptyBlock = &m_starterBlock;
	m_firstEmptyRange = 0;
}

RangeList::~RangeList()
{
	RangeListBlock *b = m_starterBlock.next;

	while (b != NULL)
	{
		RangeListBlock *bNext = b->next;
		delete b;
		b = bNext;
	}
}

void RangeList::InitBlock(RangeListBlock *b)
{
	Range *r = b->ranges;
	Range *rEnd = r + RANGE_COUNT; 
	while (r < rEnd)
		r++->id = NULL;

	b->next = NULL;
}

BOOL RangeList::AddRange(const BYTE *start, const BYTE *end, void *id)
{
	_ASSERTE(id != NULL);

	Lock();

	RangeListBlock *b = m_firstEmptyBlock;
	Range *r = b->ranges + m_firstEmptyRange;
	Range *rEnd = b->ranges + RANGE_COUNT;

	while (TRUE)
	{
		while (r < rEnd)
		{
			if (r->id == NULL)
			{
				r->start = start;
				r->end = end;
				r->id = id;
				
				r++;

				m_firstEmptyBlock = b;
				m_firstEmptyRange = r - b->ranges;

				Unlock();

				return TRUE;
			}
			r++;
		}

		//
		// If there are no more blocks, allocate a 
		// new one.
		//

		if (b->next == NULL)
		{
			RangeListBlock *newBlock = new RangeListBlock();

			if (newBlock == NULL)
			{
			    // @todo Why do we unlock here?  Why not
			    // after we modify m_firstEmptyBlock/Range?
				Unlock();

				m_firstEmptyBlock = b;
				m_firstEmptyRange = r - b->ranges;

				return FALSE;
			}

			InitBlock(newBlock);

			newBlock->next = NULL;
			b->next = newBlock;
		}

		//
		// Next block
		//

		b = b->next;
		r = b->ranges;
		rEnd = r + RANGE_COUNT;
	}
}

void RangeList::RemoveRanges(void *id)
{
	Lock();

	RangeListBlock *b = &m_starterBlock;
	Range *r = b->ranges;
	Range *rEnd = r + RANGE_COUNT;

	//
	// Find the first free element, & mark it.
	//

	while (TRUE)
	{
		//
		// Clear entries in this block.
		//

		while (r < rEnd)
		{
			if (r->id == id)
				r->id = NULL;
			r++;
		}

		//
		// If there are no more blocks, we're done.
		//

		if (b->next == NULL)
		{
			m_firstEmptyRange = 0;
			m_firstEmptyBlock = &m_starterBlock;

			Unlock();

			return; 
		}

		// 
		// Next block.
		// 

		b = b->next;
		r = b->ranges;
		rEnd = r + RANGE_COUNT;
	}
}

void *RangeList::FindIdWithinRange(const BYTE *start, const BYTE *end)
{
	RangeListBlock *b = &m_starterBlock;
	Range *r = b->ranges;
	Range *rEnd = r + RANGE_COUNT;
	void *idCandidate = 0; // want this to be as large as possible

	//
	// Look for a matching element
	//

	while (TRUE)
	{
		while (r < rEnd)
		{
			if (r->id != NULL &&
                r->id > idCandidate &&
                start <= r->start && 
                r->end < end)
				idCandidate = r->id;

			r++;
		}

		//
		// If there are no more blocks, we're done.
		//

		if (b->next == NULL)
			return idCandidate;

		// 
		// Next block.
		// 

		b = b->next;
		r = b->ranges;
		rEnd = r + RANGE_COUNT;
	}
}


BOOL RangeList::IsInRange(const BYTE *address)
{
	RangeListBlock *b = &m_starterBlock;
	Range *r = b->ranges;
	Range *rEnd = r + RANGE_COUNT;

	//
	// Look for a matching element
	//

	while (TRUE)
	{
		while (r < rEnd)
		{
			if (r->id != NULL &&
                address >= r->start 
				&& address < r->end)
				return TRUE;
			r++;
		}

		//
		// If there are no more blocks, we're done.
		//

		if (b->next == NULL)
			return FALSE;

		// 
		// Next block.
		// 

		b = b->next;
		r = b->ranges;
		rEnd = r + RANGE_COUNT;
	}
}

DWORD UnlockedLoaderHeap::m_dwSystemPageSize = 0;

UnlockedLoaderHeap::UnlockedLoaderHeap(DWORD dwReserveBlockSize, 
                                       DWORD dwCommitBlockSize,
                                       DWORD *pPrivatePerfCounter_LoaderBytes,
                                       DWORD *pGlobalPerfCounter_LoaderBytes,
                                       RangeList *pRangeList,
                                       const BYTE *pMinAddr)
{
    m_pCurBlock                 = NULL;
    m_pFirstBlock               = NULL;

    m_dwReserveBlockSize        = dwReserveBlockSize + sizeof(LoaderHeapBlockUnused); // Internal overhead for an allocation 
    m_dwCommitBlockSize         = dwCommitBlockSize;

    m_pPtrToEndOfCommittedRegion = NULL;
    m_pEndReservedRegion         = NULL;
    m_pAllocPtr                  = NULL;

    m_pRangeList                 = pRangeList;

    m_pMinAddr                   = max((PBYTE)BOT_MEMORY, pMinAddr);    // MinAddr can't be lower than BOT_MEMORY
    m_pMaxAddr                   = (PBYTE)TOP_MEMORY;
    
    if (m_dwSystemPageSize == NULL) {
        SYSTEM_INFO systemInfo;
        GetSystemInfo(&systemInfo);
        m_dwSystemPageSize = systemInfo.dwPageSize;
    }

    // Round to RESERVED_BLOCK_PAGES_TO_ROUND size
    m_dwReserveBlockSize = (m_dwReserveBlockSize + RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1) & (~(RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1));

    m_dwTotalAlloc         = 0;

#ifdef _DEBUG
    m_dwDebugWastedBytes        = 0;
    s_dwNumInstancesOfLoaderHeaps++;
#endif

    m_pPrivatePerfCounter_LoaderBytes = pPrivatePerfCounter_LoaderBytes;
    m_pGlobalPerfCounter_LoaderBytes = pGlobalPerfCounter_LoaderBytes;
}

UnlockedLoaderHeap::UnlockedLoaderHeap(DWORD dwReserveBlockSize, DWORD dwCommitBlockSize, 
                                       const BYTE* dwReservedRegionAddress, DWORD dwReservedRegionSize, 
                                       DWORD *pPrivatePerfCounter_LoaderBytes,
                                       DWORD *pGlobalPerfCounter_LoaderBytes,
                                       RangeList *pRangeList)
{
    m_pCurBlock                 = NULL;
    m_pFirstBlock               = NULL;

    m_dwReserveBlockSize        = dwReserveBlockSize + sizeof(LoaderHeapBlock); // Internal overhead for an allocation 
    m_dwCommitBlockSize         = dwCommitBlockSize;

    m_pPtrToEndOfCommittedRegion = NULL;
    m_pEndReservedRegion         = NULL;
    m_pAllocPtr                  = NULL;

	m_pRangeList				 = pRangeList;

    m_pMinAddr                   = (PBYTE)BOT_MEMORY;
    m_pMaxAddr                   = (PBYTE)TOP_MEMORY;

	if (m_dwSystemPageSize == NULL) {
		SYSTEM_INFO systemInfo;
		GetSystemInfo(&systemInfo);
		m_dwSystemPageSize = systemInfo.dwPageSize;
	}

    // Round to RESERVED_BLOCK_PAGES_TO_ROUND size
    m_dwReserveBlockSize = (m_dwReserveBlockSize + RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1) & (~(RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1));

    m_dwTotalAlloc         = 0;

#ifdef _DEBUG
    m_dwDebugWastedBytes        = 0;
    s_dwNumInstancesOfLoaderHeaps++;
#endif

    m_pPrivatePerfCounter_LoaderBytes = pPrivatePerfCounter_LoaderBytes;
    m_pGlobalPerfCounter_LoaderBytes = pGlobalPerfCounter_LoaderBytes;

    // Pages are actually already reserved. We call this to setup our data structures.
    ReservePages (0, dwReservedRegionAddress, dwReservedRegionSize, m_pMinAddr, m_pMaxAddr, FALSE);
}

// ~LoaderHeap is not synchronised (obviously)
UnlockedLoaderHeap::~UnlockedLoaderHeap()
{
	if (m_pRangeList != NULL)
		m_pRangeList->RemoveRanges((void *) this);

    LoaderHeapBlock *pSearch, *pNext;

    for (pSearch = m_pFirstBlock; pSearch; pSearch = pNext)
    {
        BOOL    fSuccess;
        void *  pVirtualAddress;
        BOOL    fReleaseMemory;

        pVirtualAddress = pSearch->pVirtualAddress;
        fReleaseMemory = pSearch->m_fReleaseMemory;
        pNext = pSearch->pNext;
        
        // Log the range of pages for this loader heap.
        WS_PERF_LOG_PAGE_RANGE(this, pSearch, (unsigned char *)pSearch->pVirtualAddress + pSearch->dwVirtualSize - m_dwSystemPageSize, pSearch->dwVirtualSize);
    
        
        fSuccess = VirtualFree(pVirtualAddress, pSearch->dwVirtualSize, MEM_DECOMMIT);
        _ASSERTE(fSuccess);

	    if (fReleaseMemory)
        {    
            fSuccess = VirtualFree(pVirtualAddress, 0, MEM_RELEASE);
            _ASSERTE(fSuccess);
        }
    }

    if (m_pGlobalPerfCounter_LoaderBytes)
        *m_pGlobalPerfCounter_LoaderBytes = *m_pGlobalPerfCounter_LoaderBytes - m_dwTotalAlloc;
    if (m_pPrivatePerfCounter_LoaderBytes)
        *m_pPrivatePerfCounter_LoaderBytes = *m_pPrivatePerfCounter_LoaderBytes - m_dwTotalAlloc;

#ifdef _DEBUG
    s_dwNumInstancesOfLoaderHeaps --;
#endif // _DEBUG
}

#if 0
// Disables access to all pages in the heap - useful when trying to determine if someone is
// accessing something in the low frequency heap
void UnlockedLoaderHeap::DebugGuardHeap()
{
    LoaderHeapBlock *pSearch, *pNext;

    for (pSearch = m_pFirstBlock; pSearch; pSearch = pNext)
    {
        void *  pResult;
        void *  pVirtualAddress;

        pVirtualAddress = pSearch->pVirtualAddress;
        pNext = pSearch->pNext;

        pResult = VirtualAlloc(pVirtualAddress, pSearch->dwVirtualSize, MEM_COMMIT, PAGE_NOACCESS);
        _ASSERTE(pResult != NULL);
    }
}
#endif

DWORD UnlockedLoaderHeap::GetBytesAvailCommittedRegion()
{
    if (m_pAllocPtr < m_pPtrToEndOfCommittedRegion)
        return (DWORD)(m_pPtrToEndOfCommittedRegion - m_pAllocPtr);
    else
        return 0;
}

DWORD UnlockedLoaderHeap::GetBytesAvailReservedRegion()
{
    if (m_pAllocPtr < m_pEndReservedRegion)
        return (DWORD)(m_pEndReservedRegion- m_pAllocPtr);
    else
        return 0;
}

#define SETUP_NEW_BLOCK(pData, dwSizeToCommit, dwSizeToReserve)                     \
        m_pPtrToEndOfCommittedRegion = (BYTE *) (pData) + (dwSizeToCommit);         \
        m_pAllocPtr                  = (BYTE *) (pData) + sizeof(LoaderHeapBlock);  \
        m_pEndReservedRegion         = (BYTE *) (pData) + (dwSizeToReserve);


BOOL UnlockedLoaderHeap::ReservePages(DWORD dwSizeToCommit, 
                                      const BYTE* dwReservedRegionAddress,
                                      DWORD dwReservedRegionSize,
                                      const BYTE* pMinAddr,
                                      const BYTE* pMaxAddr,
                                      BOOL fCanAlloc)
{
    DWORD dwSizeToReserve;

    // Add sizeof(LoaderHeapBlock)
    dwSizeToCommit += sizeof(LoaderHeapBlockUnused);

    // Round to page size again
    dwSizeToCommit = (dwSizeToCommit + m_dwSystemPageSize - 1) & (~(m_dwSystemPageSize - 1));

    // Figure out how much to reserve
    dwSizeToReserve = max(dwSizeToCommit, m_dwReserveBlockSize);
    dwSizeToReserve = max(dwSizeToReserve, dwReservedRegionSize);

    // Round to 16 page size
    dwSizeToReserve = (dwSizeToReserve + 16*m_dwSystemPageSize - 1) & (~(16*m_dwSystemPageSize - 1));

    _ASSERTE(dwSizeToCommit <= dwSizeToReserve);    

    void *pData = NULL;
    BOOL fReleaseMemory = TRUE;

    // Reserve pages
    // If we don't care where the memory is...
    if (!dwReservedRegionAddress &&
         pMinAddr == (PBYTE)BOT_MEMORY &&
         pMaxAddr == (PBYTE)TOP_MEMORY)
    {
        // Figure out how much to reserve
        dwSizeToReserve = max(dwSizeToCommit, m_dwReserveBlockSize);
        dwSizeToReserve = max(dwSizeToReserve, dwReservedRegionSize);

        // Round to ROUND_TO_PAGES page size
        dwSizeToReserve = (dwSizeToReserve + RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1) & (~(RESERVED_BLOCK_ROUND_TO_PAGES*m_dwSystemPageSize - 1));
        pData = VirtualAlloc(NULL, dwSizeToReserve, MEM_RESERVE, PAGE_NOACCESS);
    }
    // if we do care, and haven't been given a pre-reserved blob
    else if (!dwReservedRegionAddress &&
             (pMinAddr != (PBYTE)BOT_MEMORY || pMaxAddr != (PBYTE)TOP_MEMORY))
    {
        const BYTE *pStart;
        const BYTE *pNextIgnore;
        const BYTE *pLastIgnore;
        HRESULT hr = FindFreeSpaceWithinRange(pStart, 
                                              pNextIgnore,
                                              pLastIgnore,
                                              pMinAddr,
                                              pMaxAddr,
                                              dwSizeToReserve);
        if (FAILED(hr))
            return FALSE;
        pData = (void *)pStart;
    }
    // may or may not care about location, but we've already
    // been given a pre-reserved blob to commit.
    else
    {
        dwSizeToReserve = dwReservedRegionSize;
        fReleaseMemory = FALSE;
        pData = (void *)dwReservedRegionAddress;
    }

    // When the user passes in the reserved memory, the commit size is 0 and is adjusted to be the sizeof(LoaderHeap). 
    // If for some reason this is not true then we just catch this via an assertion and the dev who changed code
    // would have to add logic here to handle the case when committed mem is more than the reserved mem. One option 
    // could be to leak the users memory and reserve+commit a new block, Another option would be to fail the alloc mem
    // and notify the user to provide more reserved mem.
    _ASSERTE((dwSizeToCommit <= dwSizeToReserve) && "Loaderheap tried to commit more memory than reserved by user");

    if (pData == NULL)
    {
        _ASSERTE(!"Unable to VirtualAlloc reserve in a loaderheap");
        return FALSE;
    }

    // Commit first set of pages, since it will contain the LoaderHeapBlock
    void *pTemp = VirtualAlloc(pData, dwSizeToCommit, MEM_COMMIT, PAGE_READWRITE);
    if (pTemp == NULL)
    {
        _ASSERTE(!"Unable to VirtualAlloc commit in a loaderheap");

        // Unable to commit - release pages
		if (fReleaseMemory)
			VirtualFree(pData, 0, MEM_RELEASE);

        return FALSE;
    }

    if (m_pGlobalPerfCounter_LoaderBytes)
        *m_pGlobalPerfCounter_LoaderBytes = *m_pGlobalPerfCounter_LoaderBytes + dwSizeToCommit;
    if (m_pPrivatePerfCounter_LoaderBytes)
        *m_pPrivatePerfCounter_LoaderBytes = *m_pPrivatePerfCounter_LoaderBytes + dwSizeToCommit;

	// Record reserved range in range list, if one is specified
	// Do this AFTER the commit - otherwise we'll have bogus ranges included.
	if (m_pRangeList != NULL)
	{
		if (!m_pRangeList->AddRange((const BYTE *) pData, 
									((const BYTE *) pData) + dwSizeToReserve, 
									(void *) this))
		{
			_ASSERTE(!"Unable to add range to range list in a loaderheap");

			if (fReleaseMemory)
				VirtualFree(pData, 0, MEM_RELEASE);

			return FALSE;
		}
	}

    WS_PERF_UPDATE("COMMITTED", dwSizeToCommit, pTemp);
    WS_PERF_COMMIT_HEAP(this, dwSizeToCommit); 

    m_dwTotalAlloc += dwSizeToCommit;

    LoaderHeapBlock *pNewBlock;

    pNewBlock = (LoaderHeapBlock *) pData;

    pNewBlock->dwVirtualSize    = dwSizeToReserve;
    pNewBlock->pVirtualAddress  = pData;
    pNewBlock->pNext            = NULL;
    pNewBlock->m_fReleaseMemory = fReleaseMemory;

    LoaderHeapBlock *pCurBlock = m_pCurBlock;

    // Add to linked list
    while (pCurBlock != NULL &&
           pCurBlock->pNext != NULL)
        pCurBlock = pCurBlock->pNext;

    if (pCurBlock != NULL)        
        m_pCurBlock->pNext = pNewBlock;
    else
        m_pFirstBlock = pNewBlock;

    if (!fCanAlloc)
    {
        // If we want to use the memory immediately...
        m_pCurBlock = pNewBlock;

        SETUP_NEW_BLOCK(pData, dwSizeToCommit, dwSizeToReserve);
    }
    else
    {
        // The caller is just interested if we can, actually get the memory.
        // So stash it into the next item in the list & we'll go looking for
        // it later.
        LoaderHeapBlockUnused *pCanAllocBlock = (LoaderHeapBlockUnused *)pNewBlock;
        pCanAllocBlock->cbCommitted = dwSizeToCommit;
        pCanAllocBlock->cbReserved = dwSizeToReserve;
    }
    return TRUE;
}

// Get some more committed pages - either commit some more in the current reserved region, or, if it
// has run out, reserve another set of pages. 
// Returns: FALSE if we can't get any more memory (we can't commit any more, and
//              if bGrowHeap is TRUE, we can't reserve any more)
// TRUE: We can/did get some more memory - check to see if it's sufficient for
//       the caller's needs (see UnlockedAllocMem for example of use)
BOOL UnlockedLoaderHeap::GetMoreCommittedPages(size_t dwMinSize, 
                                               BOOL bGrowHeap,
                                               const BYTE *pMinAddr,
                                               const BYTE *pMaxAddr,
                                               BOOL fCanAlloc)
{
    // If we have memory we can use, what are you doing here!  
    DWORD memAvailable = m_pPtrToEndOfCommittedRegion - m_pAllocPtr;

    // The current region may be out of range, if there is a current region.
    BOOL fOutOfRange = (pMaxAddr < m_pAllocPtr || pMinAddr >= m_pEndReservedRegion) &&
                        m_pAllocPtr != NULL && m_pEndReservedRegion != NULL;
    _ASSERTE(dwMinSize > memAvailable || fOutOfRange);
    
    DWORD dwSizeToCommit = max(dwMinSize - memAvailable, m_dwCommitBlockSize);

    // If we do not have space in the current block of heap to commit
    if (dwMinSize + m_pAllocPtr >= m_pEndReservedRegion) {
        dwSizeToCommit = dwMinSize;
    }

    // Round to page size
    dwSizeToCommit = (dwSizeToCommit + m_dwSystemPageSize - 1) & (~(m_dwSystemPageSize - 1));

    // Does this fit in the reserved region?
    if (!fOutOfRange &&
         m_pPtrToEndOfCommittedRegion + dwSizeToCommit <= m_pEndReservedRegion)
    {
        // Yes, so commit the desired number of reserved pages
        void *pData = VirtualAlloc(m_pPtrToEndOfCommittedRegion, dwSizeToCommit, MEM_COMMIT, PAGE_READWRITE);
        _ASSERTE(pData != NULL);
        if (pData == NULL)
            return FALSE;

        if (m_pGlobalPerfCounter_LoaderBytes)
            *m_pGlobalPerfCounter_LoaderBytes = *m_pGlobalPerfCounter_LoaderBytes + dwSizeToCommit;
        if (m_pPrivatePerfCounter_LoaderBytes)
            *m_pPrivatePerfCounter_LoaderBytes = *m_pPrivatePerfCounter_LoaderBytes + dwSizeToCommit;

        // If fCanAlloc is true, then we'll end up doing this work before
        // the actual alloc, but it won't change anything else.

        WS_PERF_UPDATE("COMMITTED", dwSizeToCommit, pData);
        WS_PERF_COMMIT_HEAP(this, dwSizeToCommit); 

        m_dwTotalAlloc += dwSizeToCommit;

        m_pPtrToEndOfCommittedRegion += dwSizeToCommit;
        return TRUE;
    }

    if (PreviouslyAllocated((BYTE*)pMinAddr, (BYTE*)pMaxAddr, dwMinSize, fCanAlloc))
        return TRUE;

    if (bGrowHeap)
    {
        // Need to allocate a new set of reserved pages
    #ifdef _DEBUG
        m_dwDebugWastedBytes += (DWORD)(m_pPtrToEndOfCommittedRegion - m_pAllocPtr);
    #endif
    
        // Note, there are unused reserved pages at end of current region -can't do much about that
        return ReservePages(dwSizeToCommit, 0, 0, pMinAddr, pMaxAddr, fCanAlloc);
    }
    return FALSE;
}

BOOL UnlockedLoaderHeap::PreviouslyAllocated(BYTE *pMinAddr, BYTE *pMaxAddr, DWORD dwMinSize, BOOL fCanAlloc)
{
    // We may have already allocated the memory when someone called "UnlockedCanAllocMem"
    if (m_pFirstBlock != NULL)
    {
        LoaderHeapBlockUnused* unused = NULL;
        
        // If we've already got a current block, then check to see if the 'next' one has
        // already been allocated.
        if (m_pCurBlock != NULL &&
            m_pCurBlock->pNext != NULL)
            unused = (LoaderHeapBlockUnused*)m_pCurBlock->pNext;

        // Alternately, the first thing the caller may have done is call "UCAM", in which
        // case the m_pFirstBlock will be set, but m_pCurBlock won't be (yet).
        else if (m_pFirstBlock != NULL &&
                 m_pCurBlock == NULL)
            unused = (LoaderHeapBlockUnused*)m_pFirstBlock;

        while(unused != NULL)
        {
            if (fCanAlloc)
            {
                BYTE *pBlockSpaceStart = (BYTE *)unused + sizeof(LoaderHeapBlock);

                // If there's space available, and it's located where we need it, use it.
                if (unused->cbReserved - sizeof(LoaderHeapBlock) >= dwMinSize &&
                    pBlockSpaceStart >= pMinAddr &&
                    pBlockSpaceStart + dwMinSize < pMaxAddr)
                    return TRUE;
                else
                // otherwise check the next one, if there is one.
                    unused = (LoaderHeapBlockUnused*)unused->pNext;
            }
            else
            {
                SETUP_NEW_BLOCK( ((void *)unused), unused->cbCommitted, unused->cbReserved);
                m_pCurBlock = unused;

                // Zero out the fields that we borrowed...
                unused->cbCommitted = 0;
                unused->cbReserved = 0;
                return TRUE; 
                // Note that we haven't actually checked to make sure that
                // this has enough space / is in the right place: UnlockedAllocMem 
                // will loop around, thus checking to make sure that 
                // this block is actually ok to use.
                // @todo NOTE; this may leak memory, just as if we asked for more
                // space than is left in the current block.
            }
        }
    }

    return FALSE;
}

// In debug mode, allocate an extra LOADER_HEAP_DEBUG_BOUNDARY bytes and fill it with invalid data.  The reason we
// do this is that when we're allocating vtables out of the heap, it is very easy for code to
// get careless, and end up reading from memory that it doesn't own - but since it will be
// reading some other allocation's vtable, no crash will occur.  By keeping a gap between
// allocations, it is more likely that these errors will be encountered.
#ifdef _DEBUG
void *UnlockedLoaderHeap::UnlockedAllocMem(size_t dwSize, BOOL bGrowHeap)
{
    void *pMem = UnlockedAllocMemHelper(dwSize + LOADER_HEAP_DEBUG_BOUNDARY, bGrowHeap);

    if (pMem == NULL)
        return pMem;

    // Don't fill the memory we allocated - it is assumed to be zeroed - fill the memory after it
    memset((BYTE *) pMem + dwSize, 0xEE, LOADER_HEAP_DEBUG_BOUNDARY);

    return pMem;
}
#endif

#ifdef _DEBUG
void *UnlockedLoaderHeap::UnlockedAllocMemHelper(size_t dwSize, BOOL bGrowHeap)
#else
void *UnlockedLoaderHeap::UnlockedAllocMem(size_t dwSize, BOOL bGrowHeap)
#endif
{
    _ASSERTE(dwSize != 0);

#ifdef MAXALLOC
    static AllocRequestManager allocManager(L"AllocMaxLoaderHeap");
    if (! allocManager.CheckRequest(dwSize))
        return NULL;
#endif

    // DWORD align
    dwSize = (dwSize + 3) & (~3);

    WS_PERF_ALLOC_HEAP(this, dwSize); 

    // Enough bytes available in committed region?
again:
    if (dwSize <= GetBytesAvailCommittedRegion())
    {
        void *pData = m_pAllocPtr;
        m_pAllocPtr += dwSize;
        return pData;
    }

    // Need to commit some more pages in reserved region.
    // If we run out of pages in the reserved region, VirtualAlloc some more pages
    // if bGrowHeap is true
    if (GetMoreCommittedPages(dwSize,bGrowHeap, m_pMinAddr, m_pMaxAddr, FALSE) == FALSE)
    {
        if (bGrowHeap && UtilCodeCallback::OutOfMemoryCallback) {
            UtilCodeCallback::OutOfMemoryCallback();
        }
        return NULL;
    }

    goto again;
}

// Can we allocate memory within the heap?
BOOL UnlockedLoaderHeap::UnlockedCanAllocMem(size_t dwSize, BOOL bGrowHeap)
{
again:
    if (dwSize == 0 ||
        dwSize <= GetBytesAvailReservedRegion() ||
        PreviouslyAllocated((BYTE*)m_pMinAddr, 
                            (BYTE*)m_pMaxAddr, 
                            dwSize,
                            TRUE))
    {
        // We should only be handing out memory within the ranges the heap operates in.
        _ASSERTE(dwSize == 0 ||
                 PreviouslyAllocated((BYTE*)m_pMinAddr, 
                                     (BYTE*)m_pMaxAddr, 
                                     dwSize, 
                                     TRUE) ||
                 m_pAllocPtr >= m_pMinAddr && m_pAllocPtr +dwSize < m_pMaxAddr);
        return TRUE;
    }
    else if (GetMoreCommittedPages(dwSize, bGrowHeap, m_pMinAddr, m_pMaxAddr, TRUE) == FALSE)
    {
        return FALSE;
    }

    goto again;
}

// Can we allocate memory within the heap, but within different ranges than
// the heap's range?
BOOL UnlockedLoaderHeap::UnlockedCanAllocMemWithinRange(size_t dwSize, BYTE *pStart, BYTE *pEnd, BOOL bGrowHeap)
{
again:
    BYTE *pMemIsOkStart = GetAllocPtr();
    BYTE *pMemIsOkEnd = pMemIsOkStart + GetReservedBytesFree();

    // If the next available memory completely within the given range, use it
    if (dwSize == 0 ||
        (dwSize <= GetBytesAvailReservedRegion() &&
         pMemIsOkStart >= pStart &&
         pMemIsOkEnd < pEnd) ||
        PreviouslyAllocated((BYTE*)m_pMinAddr, 
                            (BYTE*)m_pMaxAddr, 
                            dwSize,
                            TRUE))
    {
        return TRUE;
    }
    // If we can't get the memory in general, then we're screwed, so give up.
    else if ( !GetMoreCommittedPages(dwSize, bGrowHeap, pStart, pEnd, TRUE))
        return FALSE;
        
    goto again;
}

#ifdef MAXALLOC
AllocRequestManager::AllocRequestManager(LPCTSTR key)
{
    m_newRequestCount = 0;
    m_maxRequestCount = UINT_MAX;    // to allow allocation during GetLong
    OnUnicodeSystem();
    m_maxRequestCount = REGUTIL::GetLong(key, m_maxRequestCount, NULL, HKEY_CURRENT_USER);
}

BOOL AllocRequestManager::CheckRequest(size_t size)
{
    if (m_maxRequestCount == UINT_MAX)
        return TRUE;

    if (m_newRequestCount >= m_maxRequestCount)
        return FALSE;
    ++m_newRequestCount;
    return TRUE;
}

void AllocRequestManager::UndoRequest()
{
    if (m_maxRequestCount == UINT_MAX)
        return;

    _ASSERTE(m_newRequestCount > 0);
    --m_newRequestCount;
}

void * AllocMaxNew(size_t n, void **ppvCallstack)
{
    static AllocRequestManager allocManager(L"AllocMaxNew");

	if (n == 0) n++;		// allocation size always > 0, makes Boundschecker happy

    if (! allocManager.CheckRequest(n))
        return NULL;
    return DbgAlloc(n, ppvCallstack);
}
#endif // MAXALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\miniio.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "miniio.h"
#include "utilcode.h"
#include "hrex.h"

//
// @todo ia64: use of DWORD for sizes throughout should be examined
//

/* ------------------------------------------------------------------------------------ *
 * MiniFile
 * ------------------------------------------------------------------------------------ */

MiniFile::MiniFile(LPCWSTR pPath)
{
    m_file = WszCreateFile(pPath, 
                           GENERIC_READ|GENERIC_WRITE, 
                           0 /* NO SHARING */,
                           NULL, OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL, NULL);
    if (m_file == INVALID_HANDLE_VALUE)
        ThrowLastError();

    DWORD dwHigh;
    DWORD dwLow = ::GetFileSize( m_file, &dwHigh );
    if (dwHigh != 0)
        ThrowError( E_FAIL );

    m_filePos = m_pos = m_end = m_buffer;
    m_dirty = FALSE;
    m_eof = FALSE;

    m_indentLevel = 0;
}

MiniFile::~MiniFile()
{
    Flush();
    if (m_file != INVALID_HANDLE_VALUE)
        CloseHandle(m_file);
}

BOOL MiniFile::IsEOF()
{
    return (m_pos == m_end 
            && (m_eof
                || (GetFileSize(m_file, NULL) 
                    == SetFilePointer(m_file, 0, NULL, FILE_CURRENT))));
}

DWORD MiniFile::GetOffset()
{
    return (DWORD)(SetFilePointer(m_file, 0, NULL, FILE_CURRENT) - (m_filePos - m_pos));
}

DWORD MiniFile::GetSize()
{
    DWORD size = GetFileSize(m_file, NULL);

    if (m_end > m_filePos 
        && size == SetFilePointer(m_file, 0, NULL, FILE_CURRENT))
        size += (DWORD)(m_end - m_filePos);

    return size;
}

void MiniFile::SeekTo(DWORD offset)
{
    EmptyBuffer();

    if (SetFilePointer(m_file, offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
        ThrowLastError();

    m_eof = FALSE;
}

void MiniFile::SeekFromEnd(DWORD offset)
{
    EmptyBuffer();

    if (SetFilePointer(m_file, offset, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
        ThrowLastError();

    m_eof = (offset == 0);
}

void MiniFile::Seek(LONG offset)
{
    if (m_pos + offset < m_end
        && m_pos + offset > m_buffer)
        m_pos += offset;
    else
    {
        offset -= (LONG)(m_filePos - m_pos);

        EmptyBuffer();
        
        if (SetFilePointer(m_file, offset, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
            ThrowLastError();

        m_eof = FALSE;
    }
}

void MiniFile::Truncate()
{
    if (m_filePos != m_pos)
    {
        if (SetFilePointer(m_file, (LONG)(m_pos - m_filePos), NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
            ThrowLastError();

        m_filePos = m_pos;
    }

    if (!SetEndOfFile(m_file))
        ThrowLastError();

    m_end = m_filePos;
    m_eof = TRUE;
}

void MiniFile::Flush()
{
    if (m_dirty)
    {
        if (SetFilePointer(m_file, m_buffer - m_filePos, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
            ThrowLastError();
        DWORD written;
        if (!WriteFile(m_file, m_buffer, m_end - m_buffer, &written, NULL))
            ThrowLastError();
        m_filePos = m_end;
        m_dirty = FALSE;
    }
}

void MiniFile::EmptyBuffer()
{
    if (m_dirty)
        Flush();

    m_pos = m_filePos = m_end = m_buffer;
}

void MiniFile::SyncBuffer()
{
    if (m_dirty)
        Flush();

    LONG offset = (LONG)(m_filePos - m_pos);

    if (offset)
    {
        if (SetFilePointer(m_file, -offset, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
            ThrowLastError();
        m_eof = FALSE;
    }

    DWORD read;
    if (m_eof)
        read = 0;
    else
    {
        ReadFile(m_file, m_buffer, BUFFER_SIZE, &read, NULL);
        if ((LONG) read < offset)
            ThrowError(INVALID_SET_FILE_POINTER);
        if (read < BUFFER_SIZE)
            m_eof = TRUE;
    }

    m_pos = m_buffer + offset;
    m_end = m_filePos = m_buffer + read;
}

BOOL MiniFile::ReadOne(BYTE *pByte)
{
    while (TRUE)
    {
        if (m_pos < m_end)
        {
            *pByte = *m_pos++;
            return TRUE;
        }
        else if (m_eof)
            return FALSE;

        SyncBuffer();
        // Try again - should hit one of the above 2 cases now.
    }
}

BOOL MiniFile::Read(BYTE *buffer, DWORD length, DWORD *read)
{
    *read = 0;

    while (TRUE)
    {
        DWORD chunk = (DWORD)(m_end - m_pos);
        if (length < chunk)
            chunk = length;
        length -= chunk;

        CopyMemory(buffer, m_pos, chunk);
        buffer += chunk;
        m_pos += chunk;
        *read += chunk;

        if (length == 0)
            return TRUE;
        if (m_eof)
            return FALSE;

        SyncBuffer();
    }
}

BOOL MiniFile::ReadToOne(BYTE *buffer, DWORD length, DWORD *read, BYTE termination)
{
    *read = 0;

    while (TRUE)
    {
        DWORD chunk = (DWORD)(m_end - m_pos);
        if (length < chunk)
            chunk = length;
        length -= chunk;

        BYTE *p = buffer;
        BYTE *end = p + chunk;
        while (p < end)
        {
            if ((*p++ = *m_pos++) == termination)
            {
                *read += (DWORD)(p - buffer);
                return TRUE;
            }
        }
        buffer += chunk;
        *read += chunk;

        if (length == 0)
            return TRUE;
        if (m_eof)
            return FALSE;

        SyncBuffer();
    }
}

BOOL MiniFile::SkipToOne(DWORD *read, BYTE termination)
{
    *read = 0;

    while (TRUE)
    {
        BYTE *p = m_pos;
        while (m_pos < m_end)
        {
            if (*m_pos == termination)
            {
                *read += (DWORD)(m_pos - p);
                return TRUE;
            }
            m_pos++;
        }
        *read += (DWORD)(m_pos - p);

        if (m_eof)
            return FALSE;

        SyncBuffer();
    }
}

BOOL MiniFile::SkipToOneOf(DWORD *read, LPCSTR terminators)
{
    *read = 0;

    while (TRUE)
    {
        BYTE *p = m_pos;
        while (m_pos < m_end)
        {
            if (strchr(terminators, *m_pos) != NULL)
            {
                *read += (DWORD)(m_pos - p);
                return TRUE;
            }
            m_pos++;
        }
        *read += (DWORD)(m_pos - p);

        if (m_eof)
            return FALSE;

        SyncBuffer();
    }
}

BOOL MiniFile::MatchOne(BYTE byte)
{
    while (TRUE)
    {
        if (m_pos < m_end)
        {
            if (byte == *m_pos)
            {
                m_pos++;
                return TRUE;
            }
            else
                return FALSE;
        }
        else if (m_eof)
            return FALSE;

        SyncBuffer();
        // Try again - should hit one of the above 2 cases now.
    }
}

BOOL MiniFile::Match(DWORD *read, const BYTE *buffer, DWORD length)
{
    *read = 0;

    while (TRUE)
    {
        DWORD chunk = (DWORD)(m_end - m_pos);
        if (length < chunk)
            chunk = length;
        length -= chunk;

        const BYTE *p = buffer;
        const BYTE *end = p + chunk;
        while (p < end)
        {
            if ((*p != *m_pos))
            {
                *read += (DWORD)(p - buffer);
                return FALSE;
            }
            p++;
            m_pos++;
        }
        buffer += chunk;
        *read += chunk;

        if (length == 0)
            return TRUE;
        if (m_eof)
            return FALSE;

        SyncBuffer();
    }
}

void MiniFile::WriteOne(BYTE byte)
{
    while (TRUE)
    {
        if (m_pos < m_end)
        {
            *m_pos++ = byte;
            break;
        }
        else if (m_end < m_buffer + BUFFER_SIZE)
        {
            *m_pos++ = byte;
            m_end++;
            break;
        }

        SyncBuffer();
        // Try again - should hit one of the above 2 cases now.
    }

    m_dirty = TRUE;
}

void MiniFile::Write(BYTE *buffer, DWORD length, DWORD *written)
{
    *written = 0;

    while (TRUE)
    {
        DWORD chunk = (DWORD)(m_end - m_pos);
        if (length < chunk)
            chunk = length;
        length -= chunk;

        DWORD after = m_buffer + BUFFER_SIZE - m_end;
        if (length < after)
            after = length;
        length -= after;
        chunk += after;

        if (chunk > 0)
        {
            CopyMemory(m_pos, buffer, chunk);
            buffer += chunk;
            m_pos += chunk;
            *written += chunk;

            m_end += after;

            m_dirty = TRUE;
        }

        if (length == 0)
            return;

        SyncBuffer();
    }
}

void MiniFile::WriteNumber(int number)
{
    CHAR buffer[10];

    sprintf(buffer, "%d", number);
    DWORD written;
    Write((BYTE*)buffer, (DWORD)strlen(buffer), &written);
}

int MiniFile::ReadNumber()
{
    // @todo: doesn't handle negative numbers
    // @todo: doesn't handle syntax errors
    int result = 0;
    BYTE c;

    while (ReadOne(&c))
    {
        if (!isdigit(c))
        {
            Seek(-1);
            break;
        }

        result *= 10;
        result += c - '0';
    }

    return result;
}

void MiniFile::WriteHexNumber(int number)
{
    CHAR buffer[10];

    sprintf(buffer, "%x", number);
    DWORD written;
    Write((BYTE*)buffer, (DWORD)strlen(buffer), &written);
}

int MiniFile::ReadHexNumber()
{
    // @todo: doesn't handle syntax errors
    int result = 0;
    BYTE c;

    while (ReadOne(&c))
    {
        if (isdigit(c))
        {
            result <<= 4;
            result += c - '0';
        }
        else if (c >= 'a' && c <= 'f')
        {
            result <<= 4;
            result += c - 'a' + 10;
        }
        else
        {
            Seek(-1);
            break;
        }
    }

    return result;
}

// Checks for |"string"| & returns string
LPSTR MiniFile::ReadQuotedString()
{
    if (!MatchOne('\"'))
        return NULL;

    DWORD read;
    if (!SkipToOne(&read, '\"'))
        ThrowSyntaxError(MISMATCHED_QUOTES);

    LPSTR result = new CHAR [read+1];

    Seek(-(LONG)read);
    Read((BYTE*) result, read, &read);
    result[read] = 0;

    Seek(1);

    return result;
}

// Writes |"string"|
void MiniFile::WriteQuotedString(LPCSTR string)
{
    _ASSERTE(strchr(string, '\"') == NULL);

    WriteOne('\"');
    DWORD written;
    Write((BYTE*)string, (DWORD)strlen(string), &written);
    WriteOne('\"');
}

// Writes |<tag>|
void MiniFile::WriteStartTag(LPCSTR tag)
{
    DWORD written;

    WriteOne('<');
    Write((BYTE*) tag, (DWORD)strlen(tag), &written);
    WriteOne('>');

    PushIndent();
}

// Writes |</tag>|
void MiniFile::WriteEndTag(LPCSTR tag)
{
    DWORD written;

    PopIndent();

    Write((BYTE*) "</", 2, &written);
    Write((BYTE*)tag, (DWORD)strlen(tag), &written);
    WriteOne('>');
}

// Writes |<tag>string</tag>|
void MiniFile::WriteTag(LPCSTR tag, LPCSTR string)
{
    _ASSERTE(strstr(tag, "</") == NULL);
    WriteStartTag(tag);

    DWORD written;
    Write((BYTE*)string, (DWORD)strlen(string), &written);

    WriteEndTag(tag);
}

// Writes |<tag/>|
void MiniFile::WriteEmptyTag(LPCSTR tag)
{
    DWORD written;

    WriteOne('<');
    Write((BYTE*)tag, (DWORD)strlen(tag), &written);
    Write((BYTE*)"/>", 2, &written);
}

// Reads |<tag>|
LPSTR MiniFile::ReadAnyStartTag()
{
    DWORD read;

    // 
    // Find the start of the next tag's text
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;

    Seek(1);

    if (!SkipToOneOf(&read, "/> "))
        ThrowSyntaxError(MISMATCHED_TAG_BRACKETS);

    if (!MatchOne('>'))
        ThrowSyntaxError(EXPECTED_TAG_OPEN);

    //
    // Allocate memory for the tag, seek back, and read it in.
    //

    LPSTR result = new CHAR [read+1];
    Seek(-(LONG)read-1);
    Read((BYTE*)result, read, &read);
    result[read] = 0;

    Seek(1);

    return result;
}

// Checks for |<tag>|
BOOL MiniFile::CheckStartTag(LPCSTR tag)
{
    DWORD read;

    //
    // Find the start of the next tag
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;

    Seek(1);

    if (Match(&read, (BYTE*)tag, (DWORD)strlen(tag))
        && (MatchOne('>')))
        return TRUE;

    Seek(-(LONG)read-1);
    return FALSE;
}

// Throws if not |<tag>|
void MiniFile::ReadStartTag(LPCSTR tag)
{
    if (!CheckStartTag(tag))
        ThrowExpectedTag(tag);
}

// Checks for |<tag>string</tag>| and returns string or NULL
LPSTR MiniFile::CheckTag(LPCSTR tag)
{
    if (!CheckStartTag(tag))
        return NULL;

    DWORD read;
    if (!SkipToOne(&read, '<'))
        ThrowSyntaxError(MISMATCHED_TAG);

    LPSTR result = new CHAR [read+1];
    Seek(-(LONG)read);
    Read((BYTE*)result, read, &read);
    result[read] = 0;

    ReadEndTag(tag);

    return result;
}

// Throws if not |<tag>string</tag>|, or returns string
LPSTR MiniFile::ReadTag(LPCSTR tag)
{
    LPSTR result = CheckTag(tag);
    if (result == NULL)
        ThrowExpectedTag(tag);
    return result;
}

// Checks for |<tag/>|
BOOL MiniFile::CheckEmptyTag(LPCSTR tag)
{
    DWORD read;

    //
    // Find the start of the next tag
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;

    Seek(1);

    if (Match(&read, (BYTE*)tag, (DWORD)strlen(tag))
        && (MatchOne('/')))
    {
        read++;
        if (MatchOne('>'))
            return TRUE;
    }

    Seek(-(LONG)read-1);
    return FALSE;
}

// Throws if not |<tag/>|
void MiniFile::ReadEmptyTag(LPCSTR tag)
{
    if (!CheckEmptyTag(tag))
        ThrowExpectedTag(tag);
}

// Checks for |</tag>|
BOOL MiniFile::CheckEndTag(LPCSTR tag)
{
    DWORD read;

    //
    // Find the start of the next tag
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;
    
    Seek(1);

    if (!MatchOne('/'))
    {
        Seek(-1);
        return FALSE;
    }

    if (Match(&read, (BYTE*) tag, (DWORD)strlen(tag))
        && MatchOne('>'))
    {
        return TRUE;
    }

    Seek(-(LONG) read-2);
    return FALSE;
}

// Throws if not |</tag>|
void MiniFile::ReadEndTag(LPCSTR tag)
{
    if (!CheckEndTag(tag))
        ThrowExpectedTag(tag);
}


// Writes |<tag|
void MiniFile::WriteStartTagOpen(LPCSTR tag)
{
    DWORD written;

    WriteOne('<');
    Write((BYTE*) tag, (DWORD)strlen(tag), &written);
}

// Writes | name="string"|
void MiniFile::WriteTagParameter(LPCSTR name, LPCSTR string)
{
    _ASSERTE(strchr(string, '\"') == NULL);

    DWORD written;

    Write((BYTE*) name, (DWORD)strlen(name), &written);
    Write((BYTE*) " =\"", 3, &written);
    Write((BYTE*) string, (DWORD)strlen(string), &written);
    WriteOne('\"');
}

// Writes |>|
void MiniFile::WriteStartTagClose(LPCSTR tag)
{
    WriteOne('>');
    
    PushIndent();
}

// Reads |<tag|
LPSTR MiniFile::ReadAnyStartTagOpen()
{
    DWORD read;

    // 
    // Find the start of the next tag's text
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;
    Seek(1);

    //
    // Find the end of the tag name (assume it's terminated with either ' ' or >)
    //
    
    if (!SkipToOneOf(&read, "> "))
        ThrowSyntaxError(MISMATCHED_TAG_BRACKETS);

    //
    // Allocate memory for the tag, seek back, and read it in.
    //

    LPSTR result = new CHAR [read+1];
    Seek(-(LONG)read);
    Read((BYTE*) result, read, &read);
    result[read] = 0;

    return result;
}

// Checks for |<tag|
BOOL MiniFile::CheckStartTagOpen(LPCSTR tag)
{
    DWORD read;

    //
    // Find the start of the next tag
    //

    if (!SkipToOne(&read, '<'))
        return FALSE;

    Seek(1);

    if (Match(&read, (BYTE*) tag, (DWORD)strlen(tag))
        && (MatchOne('>')
            || MatchOne(' ')))
    {
        Seek(-1);
        return TRUE;
    }

    Seek(-(LONG)read-1);
    return FALSE;
}

// Throws if not |<tag|
void MiniFile::ReadStartTagOpen(LPCSTR tag)
{
    if (!CheckStartTagOpen(tag))
        ThrowExpectedTag(tag);
}

// Checks for | tag="string"| & returns string
LPCSTR MiniFile::CheckStringParameter(LPCSTR tag)
{
    if (!MatchOne(' '))
        return NULL;
    
    DWORD read;
    if (!Match(&read, (BYTE*) tag, (DWORD)strlen(tag))
        || !MatchOne('='))
    {
        Seek(-(LONG)read-1);
        return NULL;
    }
    
    LPCSTR string = ReadQuotedString();
    if (string == NULL)
        Seek(-(LONG)read-2);

    return string;
}

void MiniFile::StartNewLine()
{
    WriteOne('\r');
    WriteOne('\n');
    for (int i=0; i<m_indentLevel; i++)
        WriteOne('\t');
}

void MiniFile::ThrowHR(HRESULT hr) 
{
    ::ThrowHR(hr); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\mschr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************
*****************************************

	$Logfile: /Cedar/Code/SubSystem/win32/mschr.h $ 

	$Revision: 16 $

	DESCRIPTION:
		Character comparison and convertions routines

	Creator: Bob Devine
	DATE: 10/17/94


	$Archive: /Cedar/Code/SubSystem/win32/mschr.h $

	Last change information:

	$Date: 5/01/95 2:29p $
	$Author: Bharry $

*****************************************
****************************************/

#ifndef __MSCHR__
#define __MSCHR__

#include <ctype.h>

/* Character type operations. */
#define CHR_SPACE    0x1
#define CHR_LOWER    0x2
#define CHR_UPPER    0x4
#define CHR_DIGIT    0x8
#define CHR_PRINT    0x10
#define CHR_EOL      0x20


class MSCHR
{
public: 
	inline static int  EXTFUN IsDBCSLeadByte(char c1);
	inline static int  EXTFUN IsPunct(const char *pc1);
    inline static int  EXTFUN IsAlpha(const char *pc1);
	inline static int  EXTFUN IsAlnum(const char *pc1);
	inline static int  EXTFUN IsDigit(const char *pc1);
    inline static int  EXTFUN IsEOL(const char *pc1);
	inline static int  EXTFUN IsLwr(const char *pc1);
	inline static int  EXTFUN IsUpr(const char *pc1);
	inline static int  EXTFUN IsPrint(const char *pc1);
	inline static int  EXTFUN IsSpace(const char *pc1);
    inline static int  EXTFUN Cmp(const char *pc1, const char *pc2);
    inline static int  EXTFUN CmpI(const char *pc1, const char *pc2);
    inline static int  EXTFUN Coll(const char *pc1, const char *pc2);
    inline static int  EXTFUN CollI(const char *pc1, const char *pc2);
	inline static void EXTFUN Lwr(char *pc1);
	inline static void EXTFUN Upr(char *pc1);
	inline static void EXTFUN Copy(char *pc1, const char *pc2);
	inline static int  EXTFUN Next(const char *&pc1);
	inline static int  EXTFUN Prev(const char *&pc1,const char *pcBegin);
#if defined(COMPILER_CONST_ANACHRONISM)
	inline static int  EXTFUN Next(char *&pc1)
        { return Next((const char *&)pc1); }
	inline static int  EXTFUN Prev(char *&pc1,char *pcBegin)
        {  return Prev((const char *&)pc1, pcBegin); }
#endif // COMPILER_CONST_ANACHRONISM
	inline static int  EXTFUN IsDBCSSafe(const char *pc1, const char *pcBegin);
	inline static int  EXTFUN Size(const char *pc1);

	inline static char EXTFUN Upr(char c1);
	inline static char EXTFUN Lwr(char c1);
	
private:
#ifdef DOS
	static int EXTFUN LookupDBCSLeadByte(unsigned char c1);
	static void LoadDBCSTable();
#endif

    static int iDBCSTable;
	static unsigned char *pDBCSTable;
};

inline int EXTFUN MSCHR::IsDBCSLeadByte(char c1)
{
#ifdef _MBCS
#ifdef DOS
	// DBCS lead bytes are always 128 or greater.
	if ((unsigned) c1 < 128) return FALSE;
    
    // Look up the byte and return the state.
	return MSCHR::LookupDBCSLeadByte ((unsigned char) c1);
	
#elif defined (WIN16) || defined (WIN32)
	return ((unsigned) c1 >= 128 && ::IsDBCSLeadByte (c1));
#endif
#else
	return (FALSE);
#endif
}


inline int EXTFUN MSCHR::IsPunct(const char *pc1)
{
    // For now only worry about the lower 128 bytes
    if( !MSCHR::IsDBCSLeadByte( *pc1 ) )
	    return(ispunct(*pc1));
    else
        return FALSE;
}

inline int EXTFUN MSCHR::IsAlpha(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(MSCHR::IsDBCSLeadByte(*pc1) || isalpha(*pc1));
#elif defined (WIN16)
	return(MSCHR::IsDBCSLeadByte(*pc1) || IsCharAlpha (*pc1));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(iType & C1_ALPHA);
#endif

#else
	return(isalpha(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsAlnum(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(MSCHR::IsDBCSLeadByte(*pc1) || isalnum(*pc1));
#elif defined (WIN16)
	return(MSCHR::IsDBCSLeadByte(*pc1) || IsCharAlphaNumeric (*pc1));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(iType & (C1_ALPHA|C1_DIGIT));
#endif

#else
	return(isalnum(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsDigit(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(!MSCHR::IsDBCSLeadByte(*pc1) && isdigit(*pc1));
#elif defined (WIN16)
	return(IsCharAlphaNumeric (*pc1) && !IsCharAlpha(*pc1));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(iType & C1_DIGIT);
#endif

#else
	return(isdigit(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsEOL(const char *pc1)
{
#if defined(COMPILER_INLINE_BUG)

    return (*pc1 == '\n' || *pc1 == '\r');

#else // COMPILER_INLINE_BUG

    if (*pc1 == '\n' || *pc1 == '\r')
        return(1);
    return(0);

#endif // COMPILER_INLINE_BUG
}

inline int EXTFUN MSCHR::IsLwr(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(!MSCHR::IsDBCSLeadByte(*pc1) && islower(*pc1));
#elif defined (WIN16)
	char	rcBuf[3];

	rcBuf[1] = rcBuf[2] = '\0';
	MSCHR::Copy (rcBuf, pc1);
	AnsiLower (rcBuf);
	if (MSCHR::Cmp (pc1, rcBuf))
       return (FALSE);
	AnsiUpper (rcBuf);
    return (MSCHR::Cmp (pc1, rcBuf));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(iType & C1_LOWER);
#endif

#else
	return(islower(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsUpr(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(!MSCHR::IsDBCSLeadByte(*pc1) && isupper(*pc1));
#elif defined (WIN16)
	char	rcBuf[3];

	rcBuf[1] = rcBuf[2] = '\0';
	MSCHR::Copy (rcBuf, pc1);
	AnsiUpper (rcBuf);
	if (MSCHR::Cmp (pc1, rcBuf))
       return (FALSE);
	AnsiLower (rcBuf);
    return (MSCHR::Cmp (pc1, rcBuf));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(iType & C1_UPPER);
#endif

#else
	return(isupper(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsPrint(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
	return(MSCHR::IsDBCSLeadByte(*pc1) || isprint(*pc1));
#elif defined (WIN16)
	return(MSCHR::IsDBCSLeadByte(*pc1) || isprint(*pc1));
#else
	WORD	iType;

	if ( !GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
					MSCHR::Size (pc1), &iType) )
		return FALSE;
	return(!(iType & C1_CNTRL));
#endif

#else
	return(isprint(*pc1));
#endif
}

inline int EXTFUN MSCHR::IsSpace(const char *pc1)
{
#ifdef _INTL
#ifdef DOS
    return (!(*pc1 & 0x80) && isspace (*pc1));
#elif defined (WIN16)
    return (!(*pc1 & 0x80) && isspace (*pc1));
#else
	WORD	iType;

	if (!GetStringTypeA (LOCALE_USER_DEFAULT, CT_CTYPE1, pc1, 
				MSCHR::Size (pc1), &iType))
		return FALSE;
	
	return(iType & C1_SPACE);
#endif

#else
    return (isspace (*pc1));
#endif
}

inline void EXTFUN MSCHR::Lwr(char *pc1)
{
#ifdef _INTL
#ifdef DOS
	*pc1 = tolower(*pc1);
#elif defined (WIN16)
	char	rcBuf[3];

#ifdef _MBCS
	if (IsDBCSLeadByte (rcBuf[0] = *pc1))
		{
		rcBuf[1] = *(pc1+1);
		rcBuf[2] = '\0';
		}
	else
		rcBuf[1] = '\0';
#else
	rcBuf[0] = *pc1;
	rcBuf[1] = '\0';
#endif
	AnsiLower (rcBuf);
	*pc1 = rcBuf[0];
#ifdef _MBCS
	if (rcBuf[1] != '\0')
		*(pc1+1) = rcBuf[1];
#endif
#else
	char	rcBuf[3];

#ifdef _MBCS
	if (IsDBCSLeadByte (rcBuf[0] = *pc1))
		{
		rcBuf[1] = *(pc1+1);
		rcBuf[2] = '\0';
		}
	else
		rcBuf[1] = '\0';
#else
	rcBuf[0] = *pc1;
	rcBuf[1] = '\0';
#endif
	CharLower (rcBuf);
	*pc1 = rcBuf[0];
#ifdef _MBCS
	if (rcBuf[1] != '\0')
		*(pc1+1) = rcBuf[1];
#endif
#endif

#else
#pragma warning(disable : 4244)
	*pc1 = tolower(*pc1);
#pragma warning(default : 4244)
#endif
}

inline void EXTFUN MSCHR::Upr(char *pc1)
{
#ifdef _INTL
#ifdef DOS
	*pc1 = toupper(*pc1);
#elif defined (WIN16)
	char	rcBuf[3];

#ifdef _MBCS
	if (IsDBCSLeadByte (rcBuf[0] = *pc1))
		{
		rcBuf[1] = *(pc1+1);
		rcBuf[2] = '\0';
		}
	else
		rcBuf[1] = '\0';
#else
	rcBuf[0] = *pc1;
	rcBuf[1] = '\0';
#endif
	AnsiUpper (rcBuf);
	*pc1 = rcBuf[0];
#ifdef _MBCS
	if (rcBuf[1] != '\0')
		*(pc1+1) = rcBuf[1];
#endif
#else
	char	rcBuf[3];

#ifdef _MBCS
	if (IsDBCSLeadByte (rcBuf[0] = *pc1))
		{
		rcBuf[1] = *(pc1+1);
		rcBuf[2] = '\0';
		}
	else
		rcBuf[1] = '\0';
#else
	rcBuf[0] = *pc1;
	rcBuf[1] = '\0';
#endif
	CharUpper (rcBuf);
	*pc1 = rcBuf[0];
#ifdef _MBCS
	if (rcBuf[1] != '\0')
		*(pc1+1) = rcBuf[1];
#endif
#endif

#else
#pragma warning(disable : 4244)
	*pc1 = toupper(*pc1);
#pragma warning(default : 4244)
#endif
}

inline int EXTFUN MSCHR::Cmp(const char *pc1, const char *pc2)
{
#if defined(COMPILER_INLINE_BUG)

        return ((unsigned char) *pc1 - (unsigned char) *pc2);

#else // COMPILER_INLINE_BUG

	if (*pc1 != *pc2) return ((unsigned char) *pc1 - (unsigned char) *pc2);
#ifdef _MBCS
	if (IsDBCSLeadByte (*pc1))
		{
		if (IsDBCSLeadByte (*pc2))
    		return((unsigned char) *(pc1+1) - (unsigned char) *(pc2+1));
		else
			return ((int) (unsigned char) *(pc1+1));
		}
	else if (IsDBCSLeadByte (*pc2))
		return (-(int) (unsigned char) *(pc2+1));
#endif
	return (0);

#endif // COMPILER_INLINE_BUG
}

inline int EXTFUN MSCHR::CmpI(const char *pc1, const char *pc2)
{
#ifdef _INTL
	char	rcBuf1[3];
	char	rcBuf2[3];

#ifdef _MBCS
	// Quick test.
	if (!((*pc1 | *pc2) & 128))
		return (Lwr(*pc1) - Lwr(*pc2));

	MSCHR::Copy (rcBuf1, pc1);
	MSCHR::Copy (rcBuf2, pc2);

#ifdef DOS
	MSCHR::Lwr (rcBuf1);
	MSCHR::Lwr (rcBuf2);
#else
    if (IsDBCSLeadByte (rcBuf1[0]))
    	rcBuf1[2] = '\0';
    else
    	rcBuf1[1] = '\0';
    if (IsDBCSLeadByte (rcBuf2[0]))
    	rcBuf2[2] = '\0';
    else
    	rcBuf2[1] = '\0';
#if defined(WIN16)
	AnsiLower (rcBuf1);
 	AnsiLower (rcBuf2);
#else
	CharLower (rcBuf1);
	CharLower (rcBuf2);
#endif
#endif

	return (MSCHR::Cmp (rcBuf1, rcBuf2));

#else

#ifdef DOS
    return((unsigned char) tolower (*pc1) - (unsigned char) tolower(*pc2));

#else
	rcBuf1[0] = *pc1;
	rcBuf2[0] = *pc2;
	rcBuf1[1] = rcBuf2[1] = '\0';

#if defined (WIN16)
	AnsiLower (rcBuf1);
	AnsiLower (rcBuf2);
#else
	CharLower (rcBuf1);
	CharLower (rcBuf2);
#endif
	return ((unsigned char) rcBuf1[0] - (unsigned char) rcBuf2[0]);

#endif
#endif

#else
    if (islower(*pc1))
        return((unsigned char) *pc1 - (unsigned char) tolower(*pc2));
    else
        return((unsigned char) *pc1 - (unsigned char) toupper(*pc2));
#endif
}

inline int EXTFUN MSCHR::Coll(const char *pc1, const char *pc2)
{
#ifdef _INTL
#ifdef DOS
	return (MSCHR::Cmp (pc1, pc2));

#else
	char	rcBuf1[3];
	char	rcBuf2[3];

#ifdef _MBCS
	MSCHR::Copy (rcBuf1, pc1);
	MSCHR::Copy (rcBuf2, pc2);

    if (IsDBCSLeadByte (rcBuf1[0]))
    	rcBuf1[2] = '\0';
    else
    	rcBuf1[1] = '\0';
    if (IsDBCSLeadByte (rcBuf2[0]))
    	rcBuf2[2] = '\0';
    else
    	rcBuf2[1] = '\0';
#else
	rcBuf1[0] = *pc1;
	rcBuf2[0] = *pc2;
	rcBuf1[0] = rcBuf2[0] = '\0';
#endif

#ifdef WIN16
	return (lstrcmp (rcBuf1, rcBuf2));
#else
    return (CompareString (LOCALE_USER_DEFAULT, 0, rcBuf1, -1, rcBuf1, -1) - 2);
#endif
#endif

#else
	return (MSCHR::Cmp (pc1, pc2));
#endif
}

inline int EXTFUN MSCHR::CollI(const char *pc1, const char *pc2)
{
#ifdef _INTL
#ifdef DOS
	return (MSCHR::CmpI (pc1, pc2));

#else
	char	rcBuf1[3];
	char	rcBuf2[3];

#ifdef _MBCS
	MSCHR::Copy (rcBuf1, pc1);
	MSCHR::Copy (rcBuf2, pc2);

    if (IsDBCSLeadByte (rcBuf1[0]))
    	rcBuf1[2] = '\0';
    else
    	rcBuf1[1] = '\0';
    if (IsDBCSLeadByte (rcBuf2[0]))
    	rcBuf2[2] = '\0';
    else
    	rcBuf2[1] = '\0';
#else
	rcBuf1[0] = *pc1;
	rcBuf2[0] = *pc2;
	rcBuf1[0] = rcBuf2[0] = '\0';
#endif

#ifdef WIN16
	return (lstrcmpi (rcBuf1, rcBuf2));
#else
    return (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, rcBuf1, -1, rcBuf1, -1) - 2);
#endif
#endif

#else
	return (MSCHR::CmpI (pc1, pc2));
#endif
}

inline void EXTFUN MSCHR::Copy(char *pc1,const char *pc2)
{
	*pc1 = *pc2;
#ifdef _MBCS
	if (IsDBCSLeadByte (*pc2))
		*(pc1+1) = *(pc2+1);
#endif
}

inline int EXTFUN MSCHR::Next(const char *&pc1)
{
#ifdef _MBCS
	if (IsDBCSLeadByte (*pc1))
	{
		pc1 += 2;
		return 2;
	}
#endif

	++pc1;
	return 1;
}

inline int EXTFUN MSCHR::Prev(const char *&pc1,const char *pcBegin)
{
	const char	*pcTemp;
	int			iTemp;

	// Check if we are already at the beginning.
	if (pc1 == pcBegin) return (0);

	// If the previous byte is a lead byte, it must be the second byte.
	pcTemp = pc1 - 1;
	if (MSCHR::IsDBCSLeadByte (*pcTemp))
	{
		pc1 -= 2;
		return (2);
	}

	// Loop back until we find a non-lead byte.
	while (pcBegin < pcTemp-- && MSCHR::IsDBCSLeadByte (*pcTemp));

	// Step back 1 or 2?
	iTemp = 1 + ((pc1 - pcTemp) & 1);
	pc1 -= iTemp;
	return (iTemp);
}

inline int EXTFUN MSCHR::IsDBCSSafe(const char *pc1, const char *pcBegin)
{
	const char *pcSaved = pc1;

	// Find the first non-lead byte.
	while (pc1-- > pcBegin && MSCHR::IsDBCSLeadByte (*pc1));

	// Return if we are safe.
	return ((int) (pcSaved - pc1) & 0x1);
}

inline char  EXTFUN MSCHR::Upr(char c1)
{
return ((c1 >= 'a' && c1 <= 'z') ? c1 + ('A' - 'a') : c1);
}

inline char  EXTFUN MSCHR::Lwr(char c1)
{
return ((c1 >= 'A' && c1 <= 'Z') ? c1 + ('a' - 'A') : c1);
}

inline int EXTFUN MSCHR::Size(const char *pc1)
{
#ifdef _MBCS
	if (MSCHR::IsDBCSLeadByte (*pc1))
		return 2;
#endif

	return 1;
}

#endif /*__MSCHR__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\namespaceutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// NamespaceUtil.cpp
//
// Helpers for converting namespace separators.
//
//*****************************************************************************
#include "stdafx.h" 
#include "corhdr.h"
#include "corhlpr.h"
#include "utilcode.h"

#ifndef _ASSERTE
#define _ASSERTE(foo)
#endif

#include "NSUtilPriv.h"

// This macro expands into the list of inalid chars to case on.
// You must define _T_TYPE to handle wide vs narrow chars.
#define INVALID_CHAR_LIST() \
        case _T_TYPE('/') : \
        case _T_TYPE('\\') :


//*****************************************************************************
// Determine how many chars large a fully qualified name would be given the
// two parts of the name.  The return value includes room for every character
// in both names, as well as room for the separator and a final terminator.
//*****************************************************************************
int ns::GetFullLength(                  // Number of chars in full name.
    const WCHAR *szNameSpace,           // Namspace for value.
    const WCHAR *szName)                // Name of value.
{
    int iLen = 1;                       // Null terminator.
    if (szNameSpace)
        iLen += (int)wcslen(szNameSpace);
    if (szName)
        iLen += (int)wcslen(szName);
    if (szNameSpace && *szNameSpace && szName && *szName)
        ++iLen;
    return iLen;
}   //int ns::GetFullLength()

int ns::GetFullLength(                  // Number of chars in full name.
    LPCUTF8     szNameSpace,            // Namspace for value.
    LPCUTF8     szName)                 // Name of value.
{
    int iLen = 1;
    if (szNameSpace)
        iLen += (int)strlen(szNameSpace);
    if (szName)
        iLen += (int)strlen(szName);
    if (szNameSpace && *szNameSpace && szName && *szName)
        ++iLen;
    return iLen;
}   //int ns::GetFullLength()


//*****************************************************************************
// Scan the given string to see if the name contains any invalid characters
// that are not allowed.
//*****************************************************************************
#undef _T_TYPE
#define _T_TYPE(x) L ## x
int ns::IsValidName(                    // true if valid, false invalid.
    const WCHAR *szName)                // Name to parse.
{
    for (const WCHAR *str=szName; *str;  str++)
    {
        switch (*str)
        {
        INVALID_CHAR_LIST();
        return false;
        }
    }
    return true;
}   //int ns::IsValidName()

#undef _T_TYPE
#define _T_TYPE
int ns::IsValidName(                    // true if valid, false invalid.
    LPCUTF8     szName)                 // Name to parse.
{
    for (LPCUTF8 str=szName; *str;  str++)
    {
        switch (*str)
        {
        INVALID_CHAR_LIST();
        return false;
        }
    }
    return true;
}   //int ns::IsValidName()


//*****************************************************************************
// Scan the string from the rear looking for the first valid separator.  If
// found, return a pointer to it.  Else return null.  This code is smart enough
// to skip over special sequences, such as:
//      a.b..ctor
//         ^
//         |
// The ".ctor" is considered one token.
//*****************************************************************************
WCHAR *ns::FindSep(                     // Pointer to separator or null.
    const WCHAR *szPath)                // The path to look in.
{
    _ASSERTE(szPath);
    WCHAR *ptr = wcsrchr(szPath, NAMESPACE_SEPARATOR_WCHAR);
    if((ptr == NULL) || (ptr == szPath)) return NULL;
    if(*(ptr - 1) == NAMESPACE_SEPARATOR_WCHAR) // here ptr is at least szPath+1
        --ptr;
    return ptr;
}   //WCHAR *ns::FindSep()

//@todo: this isn't dbcs safe if this were ansi, but this is utf8.  Still an issue?
LPUTF8 ns::FindSep(                     // Pointer to separator or null.
    LPCUTF8     szPath)                 // The path to look in.
{
    _ASSERTE(szPath);
    LPUTF8 ptr = strrchr(szPath, NAMESPACE_SEPARATOR_CHAR);
    if((ptr == NULL) || (ptr == szPath)) return NULL;
    if(*(ptr - 1) == NAMESPACE_SEPARATOR_CHAR) // here ptr is at least szPath+1
        --ptr;
    return ptr;
}   //LPUTF8 ns::FindSep()



//*****************************************************************************
// Take a path and find the last separator (nsFindSep), and then replace the
// separator with a '\0' and return a pointer to the name.  So for example:
//      a.b.c
// becomes two strings "a.b" and "c" and the return value points to "c".
//*****************************************************************************
WCHAR *ns::SplitInline(                 // Pointer to name portion.
    WCHAR       *szPath)                // The path to split.
{
    WCHAR *ptr = ns::FindSep(szPath);
    if (ptr)
    {
        *ptr = 0;
        ++ptr;
    }
    return ptr;
}   // WCHAR *ns::SplitInline()

LPUTF8 ns::SplitInline(                 // Pointer to name portion.
    LPUTF8      szPath)                 // The path to split.
{
    LPUTF8 ptr = ns::FindSep(szPath);
    if (ptr)
    {
        *ptr = 0;
        ++ptr;
    }
    return ptr;
}   // LPUTF8 ns::SplitInline()

void ns::SplitInline(
    LPWSTR      szPath,                 // Path to split.
    LPCWSTR     &szNameSpace,           // Return pointer to namespace.
    LPCWSTR     &szName)                // Return pointer to name.
{
    WCHAR *ptr = SplitInline(szPath);
    if (ptr)
    {
        szNameSpace = szPath;
        szName = ptr;
    }
    else
    {
        szNameSpace = 0;
        szName = szPath;
    }
}   // void ns::SplitInline()

void ns::SplitInline(
    LPUTF8      szPath,                 // Path to split.
    LPCUTF8     &szNameSpace,           // Return pointer to namespace.
    LPCUTF8     &szName)                // Return pointer to name.
{
    LPUTF8 ptr = SplitInline(szPath);
    if (ptr)
    {
        szNameSpace = szPath;
        szName = ptr;
    }
    else
    {
        szNameSpace = 0;
        szName = szPath;
    }
}   // void ns::SplitInline()


//*****************************************************************************
// Split the last parsable element from the end of the string as the name,
// the first part as the namespace.
//*****************************************************************************
int ns::SplitPath(                      // true ok, false trunction.
    const WCHAR *szPath,                // Path to split.
    WCHAR       *szNameSpace,           // Output for namespace value.
    int         cchNameSpace,           // Max chars for output.
    WCHAR       *szName,                // Output for name.
    int         cchName)                // Max chars for output.
{
    const WCHAR *ptr = ns::FindSep(szPath);
    int iLen = (ptr) ? ptr - szPath : 0;
    int iCopyMax;
    int brtn = true;
        
    if (szNameSpace && cchNameSpace)
    {
        iCopyMax = cchNameSpace;
        iCopyMax = min(iCopyMax, iLen);
        wcsncpy(szNameSpace, szPath, iCopyMax);
        szNameSpace[iCopyMax] = 0;
        
        if (iLen >= cchNameSpace)
            brtn = false;
    }

    if (szName && cchName)
    {
        iCopyMax = cchName;
        if (ptr)
            ++ptr;
        else
            ptr = szPath;
        iLen = (int)wcslen(ptr);
        iCopyMax = min(iCopyMax, iLen);
        wcsncpy(szName, ptr, iCopyMax);
        szName[iCopyMax] = 0;
    
        if (iLen >= cchName)
            brtn = false;
    }
    return brtn;
}   // int ns::SplitPath()


int ns::SplitPath(                      // true ok, false trunction.
    LPCUTF8     szPath,                 // Path to split.
    LPUTF8      szNameSpace,            // Output for namespace value.
    int         cchNameSpace,           // Max chars for output.
    LPUTF8      szName,                 // Output for name.
    int         cchName)                // Max chars for output.
{
    LPCUTF8 ptr = ns::FindSep(szPath);
    int iLen = (ptr) ? ptr - szPath : 0;
    int iCopyMax;
    int brtn = true;
        
    if (szNameSpace && cchNameSpace)
    {
        iCopyMax = cchNameSpace;
        iCopyMax = min(iCopyMax, iLen);
        strncpy(szNameSpace, szPath, iCopyMax);
        szNameSpace[iCopyMax] = 0;
        
        if (iLen >= cchNameSpace)
            brtn = false;
    }

    if (szName && cchName)
    {
        iCopyMax = cchName;
        if (ptr)
            ++ptr;
        else
            ptr = szPath;
        iLen = (int)strlen(ptr);
        iCopyMax = min(iCopyMax, iLen);
        strncpy(szName, ptr, iCopyMax);
        szName[iCopyMax] = 0;
    
        if (iLen >= cchName)
            brtn = false;
    }
    return brtn;
}   // int ns::SplitPath()


//*****************************************************************************
// Take two values and put them together in a fully qualified path using the
// correct separator.
//*****************************************************************************
int ns::MakePath(                       // true ok, false truncation.
    WCHAR       *szOut,                 // output path for name.
    int         cchChars,               // max chars for output path.
    const WCHAR *szNameSpace,           // Namespace.
    const WCHAR *szName)                // Name.
{
    if (cchChars < 1)
        return false;

    int iCopyMax = 0, iLen;
    int brtn = true;

    if (szOut)
        *szOut = 0;
    else
        return false;
        
    if (szNameSpace && *szNameSpace != '\0')
    {
        iLen = (int)wcslen(szNameSpace) + 1;
        iCopyMax = min(cchChars, iLen);
        wcsncpy(szOut, szNameSpace, iCopyMax);
        szOut[iCopyMax - 1] = (szName && *szName) ? NAMESPACE_SEPARATOR_WCHAR : 0;
        
        if (iLen > cchChars)
            brtn = false;
    }
    
    if (szName && *szName)
    {
        int iCur = iCopyMax;
        iLen = (int)wcslen(szName) + 1;
        cchChars -= iCur;
        iCopyMax = min(cchChars, iLen);
        wcsncpy(&szOut[iCur], szName, iCopyMax);
        szOut[iCur + iCopyMax - 1] = 0;
        
        if (iLen > cchChars)
            brtn = false;
    }
    
    return brtn;
}   // int ns::MakePath()

int ns::MakePath(                       // true ok, false truncation.
    LPUTF8      szOut,                  // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szNameSpace,            // Namespace.
    LPCUTF8     szName)                 // Name.
{
    if (cchChars < 1)
        return false;

    int iCopyMax = 0, iLen;
    int brtn = true;

    if (szOut)
        *szOut = 0;
    else
        return false;
   
    if (szNameSpace && *szNameSpace)
    {
        iLen = (int)strlen(szNameSpace) + 1;
        iCopyMax = min(cchChars, iLen);
        strncpy(szOut, szNameSpace, iCopyMax);
        szOut[iCopyMax - 1] = (szName && *szName) ? NAMESPACE_SEPARATOR_CHAR : 0;
        
        if (iLen > cchChars)
            brtn = false;
    }
    
    if (szName && *szName)
    {
        int iCur = iCopyMax;
        iLen = (int)strlen(szName) + 1;
        cchChars -= iCur;
        iCopyMax = min(cchChars, iLen);
        strncpy(&szOut[iCur], szName, iCopyMax);
        szOut[iCur + iCopyMax - 1] = 0;
        
        if (iLen > cchChars)
            brtn = false;
    }
    
    return brtn;
}   // int ns::MakePath()

int ns::MakePath(                       // true ok, false truncation.
    WCHAR       *szOut,                 // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szNamespace,            // Namespace.
    LPCUTF8     szName)                 // Name.
{
    if (cchChars < 1)
        return false;

    if (szOut)
        *szOut = 0;
    else
        return false;

    if (szNamespace != NULL && *szNamespace != '\0')
    {
        if (cchChars < 2)
            return false;

        int count;

        // We use cBuffer - 2 to account for the '.' and at least a 1 character name below.
        count = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szNamespace, -1, szOut, cchChars-2);
        if (count == 0)
            return false; // Supply a bigger buffer!

        szOut[count-1] = NAMESPACE_SEPARATOR_WCHAR;
        szOut += count;
        cchChars -= count;
    }

    if (WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szName, -1, szOut, cchChars) == 0)
        return false; // supply a bigger buffer!
    return true;
}   // int ns::MakePath()

int ns::MakePath(                       // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    LPCUTF8     szNameSpace,            // Namespace for name.
    LPCUTF8     szName)                 // Final part of name.
{
    int iLen = 2;
    if (szNameSpace)
        iLen += (int)strlen(szNameSpace);
    if (szName)
        iLen += (int)strlen(szName);
    LPUTF8 szOut = (LPUTF8) qb.Alloc(iLen);
    if (!szOut)
        return false;
    return ns::MakePath(szOut, iLen, szNameSpace, szName);
}   // int ns::MakePath()

int ns::MakePath(                       // true ok, false out of memory
    CQuickArray<WCHAR> &qa,             // Where to put results.
    LPCUTF8            szNameSpace,     // Namespace for name.
    LPCUTF8            szName)          // Final part of name.
{
    int iLen = 2;
    if (szNameSpace)
        iLen += (int)strlen(szNameSpace);
    if (szName)
        iLen += (int)strlen(szName);
    WCHAR *szOut = (WCHAR *) qa.Alloc(iLen);
    if (!szOut)
        return false;
    return ns::MakePath(szOut, iLen, szNameSpace, szName);
}   // int ns::MakePath()

int ns::MakePath(                       // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    const WCHAR *szNameSpace,           // Namespace for name.
    const WCHAR *szName)                // Final part of name.
{
    int iLen = 2;
    if (szNameSpace)
        iLen += (int)wcslen(szNameSpace);
    if (szName)
        iLen += (int)wcslen(szName);
    WCHAR *szOut = (WCHAR *) qb.Alloc(iLen * sizeof(WCHAR));
    if (!szOut)
        return false;
    return ns::MakePath(szOut, iLen, szNameSpace, szName);
}   // int ns::MakePath()
  
bool ns::MakeAssemblyQualifiedName(                                        // true ok, false truncation
                                   WCHAR* pBuffer,                         // Buffer to recieve the results
                                   int    dwBuffer,                        // Number of characters total in buffer
                                   const WCHAR *szTypeName,                // Namespace for name.
                                   int   dwTypeName,                       // Number of characters (not including null)
                                   const WCHAR *szAssemblyName,            // Final part of name.
                                   int   dwAssemblyName)                   // Number of characters (not including null)
{
    if (dwBuffer < 1)
        return false;

    int iCopyMax = 0;
    _ASSERTE(pBuffer);
    *pBuffer = NULL;
    
    if (szTypeName && *szTypeName != L'\0')
    {
        iCopyMax = min(dwBuffer, dwTypeName);
        wcsncpy(pBuffer, szTypeName, iCopyMax);
        dwBuffer -= iCopyMax;
    }
    
    if (szAssemblyName && *szAssemblyName != L'\0')
    {
        
        if(dwBuffer < ASSEMBLY_SEPARATOR_LEN) 
            return false;

        for(DWORD i = 0; i < ASSEMBLY_SEPARATOR_LEN; i++)
            pBuffer[iCopyMax+i] = ASSEMBLY_SEPARATOR_WSTR[i];

        dwBuffer -= ASSEMBLY_SEPARATOR_LEN;
        if(dwBuffer == 0) 
            return false;

        int iCur = iCopyMax + ASSEMBLY_SEPARATOR_LEN;
        iCopyMax = min(dwBuffer, dwAssemblyName+1);
        wcsncpy(pBuffer + iCur, szAssemblyName, iCopyMax);
        pBuffer[iCur + iCopyMax - 1] = L'\0';
        
        if (iCopyMax < dwAssemblyName+1)
            return false;
    }
    else {
        if(dwBuffer == 0) {
            pBuffer[iCopyMax-1] = L'\0';
            return false;
        }
        else
            pBuffer[iCopyMax] = L'\0';
    }
    
    return true;
}   // int ns::MakePath()

bool ns::MakeAssemblyQualifiedName(                                        // true ok, false out of memory
                                   CQuickBytes &qb,                        // Where to put results.
                                   const WCHAR *szTypeName,                // Namespace for name.
                                   const WCHAR *szAssemblyName)            // Final part of name.
{
    int iTypeName = 0;
    int iAssemblyName = 0;
    if (szTypeName)
        iTypeName = (int)wcslen(szTypeName);
    if (szAssemblyName)
        iAssemblyName = (int)wcslen(szAssemblyName);

    int iLen = ASSEMBLY_SEPARATOR_LEN + iTypeName + iAssemblyName + 1; // Space for null terminator
    WCHAR *szOut = (WCHAR *) qb.Alloc(iLen * sizeof(WCHAR));
    if (!szOut)
        return false;

    bool ret = ns::MakeAssemblyQualifiedName(szOut, iLen, szTypeName, iTypeName, szAssemblyName, iAssemblyName);
    _ASSERTE(ret);
    return true;
}   

int ns::MakeNestedTypeName(             // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    LPCUTF8     szEnclosingName,        // Full name for enclosing type
    LPCUTF8     szNestedName)           // Full name for nested type
{
    _ASSERTE(szEnclosingName && szNestedName);
    int iLen = 2;
    iLen += (int)strlen(szEnclosingName);
    iLen += (int)strlen(szNestedName);
    LPUTF8 szOut = (LPUTF8) qb.Alloc(iLen);
    if (!szOut)
        return false;
    return ns::MakeNestedTypeName(szOut, iLen, szEnclosingName, szNestedName);
}   // int ns::MakeNestedTypeName()

int ns::MakeNestedTypeName(             // true ok, false truncation.
    LPUTF8      szOut,                  // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szEnclosingName,        // Full name for enclosing type
    LPCUTF8     szNestedName)           // Full name for nested type
{
    if (cchChars < 1)
        return false;

    int iCopyMax = 0, iLen;
    int brtn = true;

    if (szOut)
        *szOut = 0;
    else
        return false;
        
    iLen = (int)strlen(szEnclosingName) + 1;
    iCopyMax = min(cchChars, iLen);
    strncpy(szOut, szEnclosingName, iCopyMax);
    szOut[iCopyMax - 1] = NESTED_SEPARATOR_CHAR;
    
    if (iLen > cchChars)
        brtn = false;

    int iCur = iCopyMax;
    iLen = (int)strlen(szNestedName) + 1;
    cchChars -= iCur;
    iCopyMax = min(cchChars, iLen);
    strncpy(&szOut[iCur], szNestedName, iCopyMax);
    szOut[iCur + iCopyMax - 1] = 0;
    
    if (iLen > cchChars)
        brtn = false;
    
    return brtn;
}   // int ns::MakeNestedTypeName()

INT32 ns::InvariantToLower(
                           LPUTF8 szOut,
                           INT32 cMaxBytes,
                           LPCUTF8 szIn) {

    _ASSERTE(szOut);
    _ASSERTE(szIn);

    //Figure out the maximum number of bytes which we can copy without
    //running out of buffer.  If cMaxBytes is less than inLength, copy
    //one fewer chars so that we have room for the null at the end;
    int inLength = (int)(strlen(szIn)+1);
    int copyLen  = (inLength<=cMaxBytes)?inLength:(cMaxBytes-1);
    LPUTF8 szEnd;

    //Compute our end point.
    szEnd = szOut + copyLen;

    //Walk the string copying the characters.  Change the case on
    //any character between A-Z.
    for (; szOut<szEnd; szOut++, szIn++) {
        if (*szIn>='A' && *szIn<='Z') {
            *szOut = *szIn | 0x20;
        } else {
            *szOut = *szIn;
        }
    }

    //If we copied everything, tell them how many characters we copied, 
    //and arrange it so that the original position of the string + the returned
    //length gives us the position of the null (useful if we're appending).
    if (copyLen==inLength) {
        return copyLen-1;
    } else {
        *szOut=0;
        return -(inLength - copyLen);
    }
}

int ns::MakeLowerCasePath(              // true ok, false truncation.
    LPUTF8      szOut,                  // output path for name.
    int         cBytes,                 // max bytes for output path.
    LPCUTF8     szNameSpace,            // Namespace.
    LPCUTF8     szName)                 // Name.
{
    if (cBytes < 1)
        return 0;

    int iCurr=0;

    if (szOut)
        *szOut = 0;
    else
        return false;
    
    if (szNameSpace && szNameSpace[0]!=0) {
        iCurr=ns::InvariantToLower(szOut, cBytes, szNameSpace);
        
        //We didn't have enough room in our buffer, the return value is the
        //negative of the amount of space that we needed.
        if (iCurr<0) {
            return 0;
        }

        if (szName) {
            szOut[iCurr++]=NAMESPACE_SEPARATOR_CHAR;
        }

    }

    if (szName) {
        iCurr = ns::InvariantToLower(&(szOut[iCurr]), (cBytes - iCurr), szName);
        if (iCurr<0) {
            return 0;
        }
    } 

    return iCurr;
}   // int ns::MakeLowerCasePath()

//*****************************************************************************
// Given a buffer that already contains a namespace, this function appends a
// name onto that buffer with the inclusion of the separator between the two.
// The return value is a pointer to where the separator was written.
//*****************************************************************************
const WCHAR *ns::AppendPath(            // Pointer to start of appended data.
    WCHAR       *szBasePath,            // Current path to append to.
    int         cchMax,                 // Max chars for output buffer, including existing data.
    const WCHAR *szAppend)              // Value to append to existing path.
{
    _ASSERTE(0 && "nyi");
    return false;
#if 0    
    int iLen = wcslen(szBasePath);
    if (cchMax - iLen > 0)
        szBasePath[iLen] = NAMESPACE_SEPARATOR_WCHAR;
    
    int iCopyMax = wcslen(szAppend);
    cchMax -= iLen;
    iCopyMax = max(cchMax, cchMax);
    wcsncpy(&szBasePath[iLen + 1], szAppend, iCopyMax);
    szBasePath[iLen + iCopyMax] = 0;
    return &szBasePath[iLen + 1];
#endif
}   // const WCHAR *ns::AppendPath()

LPCUTF8     ns::AppendPath(             // Pointer to start of appended data.
    LPUTF8      szBasePath,             // Current path to append to.
    int         cchMax,                 // Max chars for output buffer, including existing data.
    LPCUTF8     szAppend)               // Value to append to existing path.
{
    _ASSERTE(0 && "nyi");
    return false;
}   // LPCUTF8     ns::AppendPath()


//*****************************************************************************
// Given a two sets of name and namespace, this function, compares if the
// concatenation of each sets gives the same full-qualified name.  Instead of
// actually doing the concatenation and making the comparison, this does the
// comparison in a more optimized manner that avoid any kind of allocations.
//*****************************************************************************
bool ns::FullQualNameCmp(               // true if identical, false otherwise.
    LPCUTF8     szNameSpace1,           // NameSpace 1.
    LPCUTF8     szName1,                // Name 1.
    LPCUTF8     szNameSpace2,           // NameSpace 2.
    LPCUTF8     szName2)                // Name 2.
{
    LPCUTF8     rszType1[3];            // Array of components of Type1.
    LPCUTF8     rszType2[3];            // Array of components of Type2.
    ULONG       ulCurIx1 = 0;           // Current index into Array1.
    ULONG       ulCurIx2 = 0;           // Current index into Array2.
    LPCUTF8     szType1;                // Current index into current string1.
    LPCUTF8     szType2;                // Current index into current string2.
    ULONG       ulFullQualLen1;         // Length of full qualified name1.
    ULONG       ulFullQualLen2;         // Length of full qualified name2.

    // Replace each of the NULLs passed in with empty strings.
    rszType1[0] = szNameSpace1 ? szNameSpace1 : EMPTY_STR;
    rszType1[2] = szName1 ? szName1 : EMPTY_STR;
    rszType2[0] = szNameSpace2 ? szNameSpace2 : EMPTY_STR;
    rszType2[2] = szName2 ? szName2 : EMPTY_STR;

    // Set namespace separators as needed.  Set it to the empty string where
    // not needed.
    rszType1[1] = (*rszType1[0] && *rszType1[2]) ? NAMESPACE_SEPARATOR_STR : EMPTY_STR;
    rszType2[1] = (*rszType2[0] && *rszType2[2]) ? NAMESPACE_SEPARATOR_STR : EMPTY_STR;

    // Compute the full qualified lengths for each Type.
    ulFullQualLen1 = (int)(strlen(rszType1[0]) + strlen(rszType1[1]) + strlen(rszType1[2]));
    ulFullQualLen2 = (int)(strlen(rszType2[0]) + strlen(rszType2[1]) + strlen(rszType2[2]));

    // Fast path, compare Name length.
    if (ulFullQualLen1 != ulFullQualLen2)
        return false;

    // Get the first component of the second type.
    szType2 = rszType2[ulCurIx2];

    // Compare the names.  The logic below assumes that the lengths of the full
    // qualified name are equal for the two names.
    for (ulCurIx1 = 0; ulCurIx1 < 3; ulCurIx1++)
    {
        // Get the current component of the name of the first Type.
        szType1 = rszType1[ulCurIx1];
        // Compare the current component to the second type, grabbing as much
        // of as many components as needed.
        while (*szType1)
        {
            // Get the next non-empty component of the second type.
            while (! *szType2)
                szType2 = rszType2[++ulCurIx2];
            // Compare the current character.
            if (*szType1++ != *szType2++)
                return false;
        }
    }
    return true;
}   // bool ns::FullQualNameCmp()


// Change old namespace separator to new in a string.
void SlashesToDots(char* pStr, int ilen)
{
    if (pStr)
    {
        for (char *pChar = pStr; *pChar; pChar++)
        {
            if (*pChar == '/')
                *pChar = NAMESPACE_SEPARATOR_CHAR;
        }
    }
}   // void SlashesToDots()

// Change old namespace separator to new in a string.
void SlashesToDots(WCHAR* pStr, int ilen)
{
    if (pStr)
    {
        for (WCHAR *pChar = pStr; *pChar; pChar++)
        {
            if (*pChar == L'/')
                *pChar = NAMESPACE_SEPARATOR_WCHAR;
        }
    }
}   // void SlashesToDots()

// Change new namespace separator back to old in a string.
// (Yes, this is actually done)
void DotsToSlashes(char* pStr, int ilen)
{
    if (pStr)
    {
        for (char *pChar = pStr; *pChar; pChar++)
        {
            if (*pChar == NAMESPACE_SEPARATOR_CHAR)
            {
                *pChar = '/';

                // Skip the second character of double occurrences
                if (*(pChar + 1) == NAMESPACE_SEPARATOR_CHAR)
                    pChar++;
            }
        }
    }
}   // void DotsToSlashes()

// Change new namespace separator back to old in a string.
// (Yes, this is actually done)
void DotsToSlashes(WCHAR* pStr, int ilen)
{
    if (pStr)
    {
        for (WCHAR *pChar = pStr; *pChar; pChar++)
        {
            if (*pChar == NAMESPACE_SEPARATOR_WCHAR)
            {
                *pChar = L'/';

                // Skip the second character of double occurrences
                if (*(pChar + 1) == NAMESPACE_SEPARATOR_WCHAR)
                    pChar++;
            }
        }
    }
}   // void DotsToSlashes()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\opinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                OpInfo.cpp                               */
/***************************************************************************/

#include "stdafx.h"
#include <cor.h>                // for debugMacros.h
#include "debugMacros.h"        // for ASSERTE
#include "OpInfo.h"
#include "endian.h"

    // ARRRG: there is a bug in VC in that it treats enumeration in bitfields
    // as integer, not the enumeration when doing static intitialization.  
    // This is a work-around.  
#define initEnum(x)     int(x)


OpInfo::OpInfoData OpInfo::table[] = {

#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) \
    { s, initEnum(args + type), initEnum(ctrl), pop, push, initEnum(c) },

	// Kind of a hack, get the prefixes (IInternal) to return InlineOpcode instead of InlineNone
#define IInternal 	(InlineOpcode - InlineNone)
#define IMacro 		0
#define IPrimitive	0
#define IAnnotation	0
#define IObjModel	0
#define IPrefix 	0

#define Pop0    0
#define Pop1    1
#define PopI    1
#define PopI4   1
#define PopR4   1
#define PopI8   1
#define PopR8   1
#define PopRef  1
#define VarPop  -1

#define Push0    0
#define Push1    1
#define PushI    1
#define PushI4   1
#define PushR4   1
#define PushI8   1
#define PushR8   1
#define PushRef  1
#define VarPush  -1

#include "opcode.def"
#undef OPDEF
};


/***************************************************************************/
/* parse instruction at 'instrPtr', into its opcode (OpInfo), and its 
   (inline)args, 'args'  'instrPtr' is updated */

/***************************************************************************/
const BYTE* OpInfo::fetch(const BYTE* instrPtr, OpArgsVal* args) {
	
	data = &table[*instrPtr++];
AGAIN:
	_ASSERTE(data - table == data->opcode);
	switch(data->format) {
        case InlineNone:
            break;
        case InlineOpcode:
			_ASSERTE(*instrPtr + 256 < (sizeof(table) / sizeof(OpInfoData)));
			data = &table[256 + *instrPtr++];
			goto AGAIN;
			
		case ShortInlineVar:
			args->i = readByteSmallEndian(instrPtr); instrPtr +=1;
			break;
		case InlineVar:
			args->i = readWordSmallEndian(instrPtr); instrPtr +=2;
			break;
		case ShortInlineI:
		case ShortInlineBrTarget:
			args->i = char(readByteSmallEndian(instrPtr)); instrPtr +=1;
			break;
		case ShortInlineR: {
			DWORD f = readDWordSmallEndian(instrPtr); instrPtr +=4;
			args->r = *((float*) (&f));
			}
			break;
		case InlineRVA:
		case InlineI:
		case InlineMethod:
        case InlineField:
		case InlineType:
		case InlineString:
		case InlineSig:    
        case InlineTok:
		case InlineBrTarget:
			args->i = int(readDWordSmallEndian(instrPtr)); instrPtr +=4;
			break;
		case InlineI8:
			args->i8 = readDWordSmallEndian(instrPtr) + (readDWordSmallEndian(instrPtr + 4) << 32);
			instrPtr +=8;
			break;
		case InlineR: {
			__int64 d = readDWordSmallEndian(instrPtr) + (readDWordSmallEndian(instrPtr + 4) << 32);
            instrPtr += 8;
			args->r = *((double*) (&d)); 
			} break;
		case InlineSwitch:    
			args->switch_.count   = readDWordSmallEndian(instrPtr); instrPtr +=4;
			args->switch_.targets = (int*) instrPtr; instrPtr += (4 * args->switch_.count);
			break;
		case InlinePhi:   
			args->phi.count = readByteSmallEndian(instrPtr); instrPtr +=1;
			args->phi.vars  = (unsigned short*) instrPtr; instrPtr += (2 * args->phi.count);
			break;
		default:
#ifdef _DEBUG
			_ASSERTE(!"BadType");
#else
			__assume(0);		// we are really certain the default case does not happen
#endif
		}
	return(instrPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\outstring.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************/
/*                         OutString.cpp                         */
/*****************************************************************/
/* A simple, lightweight, character output stream, with very few
   external dependancies (like sprintf ... ) */

/* Author: Vance Morrison 
   Date :  2/1/99 				*/
/*****************************************************************/

#include "stdafx.h"
#include "OutString.h"


/*****************************************************************/
//  print out 'count' instances of the character 'c'
OutString& OutString::pad(unsigned count, char c) {
	if (cur+count > end)
		realloc(count);
	memset(cur, c, count);
	cur = cur + count;
	return(*this);
}

/*****************************************************************/
// prints out a decimal representation
OutString& OutString::operator<<(double d) {

	if (d == 0.0) {
		*this << "0.0";
		return *this;
	}

	if (d < 0) {
		d = -d;
		*this << '-';
	}

		// compute the exponent
	int exponent = 0;
	while (d > 10.0)  {
		d /= 10;
		exponent++;
		if (exponent > 500) {		// avoids a possible infinite loop
            *this << "INF";		
			return *this;
		}
	}
	while (d < 1.0)  {
		d *= 10;
		--exponent;
		if (exponent < -500) {		// avoids a possible infinite loop
			*this << "0.0";		
			return *this;
		}
	}

	// we now have a normalized d (between 1 and 10)
	double delta = .5E-10;		
	d += delta;		// round to the precision we are displaying

	unsigned trailingZeros = 0;
	for(unsigned i = 0; i < 10; i++) {
		int digit = (int) d;
		d = (d - digit) * 10;		// ISSUE: does roundoff ever bite us here?
	
		if (digit == 0)		// defer printing traiing zeros
			trailingZeros++;
		else {
			if (trailingZeros > 0) {
				this->pad(trailingZeros, '0');
				trailingZeros = 0;
			}
		*this << (char) ('0' + digit);
		}
		if (i == 0)
			*this << '.';
	
	}
	if (exponent != 0) {
		*this << 'E';
		*this << exponent;
	}
	return(*this);
}

/*****************************************************************/
// prints out a decimal representation
OutString& OutString::dec(int i, unsigned minWidth) {
	char buff[12];			// big enough for any number (10 digits, - sign, null term)
	char* ptr = &buff[11];
	*ptr = 0;

	unsigned val = i;
	if (i < 0)
		val = -i;	// note this happens to also work for minint!

	for(;;) {
		if (val < 10) {
			*--ptr = '0' + val;
			break;
			}
		*--ptr = '0' + (val % 10);
		val = val / 10;
		}

	if (i < 0)
		*--ptr = '-';
	
	unsigned len = &buff[11] - ptr; 	// length of string
	if (len < minWidth)
		pad(minWidth-len, ' ');
	
	*this << ptr;
	return(*this);
}

/*****************************************************************/
OutString& OutString::hex(unsigned __int64 i, int minWidth, unsigned flags) {

	unsigned hi = unsigned(i >> 32);
	unsigned low = unsigned(i);
	
	if (hi != 0) {
		minWidth -= 8;
		hex(hi, minWidth, flags);		// print upper bits
		flags = zeroFill;
		minWidth = 8;
	}
	return hex(low, minWidth, flags);	// print lower bits
}

/*****************************************************************/
OutString& OutString::hex(unsigned i, int minWidth, unsigned flags) {
	char buff[12];			// big enough for any number 
	char* ptr = &buff[11];
	*ptr = 0;

    static const char digits[] = "0123456789ABCDEF";

	for(;;) {
		if (i < 16) {
			*--ptr = digits[i];
			break;
			}
		*--ptr = digits[(i % 16)];
		i = i / 16;
		}

	int len = &buff[11] - ptr; 			// length of string
	if (flags & put0x) {
        if (flags & zeroFill)
		    *this << "0x";
        else
            *--ptr = 'x', *--ptr = '0';
		len += 2;
		}

	if (len < minWidth)
		pad(minWidth-len, (flags & zeroFill) ? '0' : ' ');
	
	*this << ptr;
	return(*this);
}

/*****************************************************************/
void OutString::realloc(size_t neededSpace)  {
    size_t oldSize = cur-start;
	size_t newSize = (oldSize + neededSpace) * 3 / 2 + 32;
	char* oldBuff = start;
	start = new char[newSize+1];
	memcpy(start, oldBuff, oldSize);
	cur = &start[oldSize];
	end = &start[newSize];
	delete [] oldBuff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\perfalloc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// PerfAlloc.cpp
//
//  Routines layered on top of allocation primitives to dissect working set
//  Used for free builds only. Debug builds have their own routines called Dbgallod
//  to maintain allocation stats.
//

#include "stdafx.h"
#include "ImageHlp.h"
#include "corhlpr.h"
#include "utilcode.h"
#include "PerfAlloc.h"

#ifdef PERFALLOC
BOOL                PerfUtil::g_PerfAllocHeapInitialized = FALSE;
LONG                PerfUtil::g_PerfAllocHeapInitializing = 0;
PerfAllocVars       PerfUtil::g_PerfAllocVariables;


BOOL PerfVirtualAlloc::m_fPerfVirtualAllocInited = FALSE;
PerfBlock* PerfVirtualAlloc::m_pFirstBlock = 0;
PerfBlock* PerfVirtualAlloc::m_pLastBlock = 0;
DWORD PerfVirtualAlloc::m_dwEnableVirtualAllocStats = 0;

#endif // #if defined(PERFALLOC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\perflog.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "PerfLog.h"
#include "JitPerf.h"
#include "WSPerf.h"

//=============================================================================
// ALL THE PERF LOG CODE IS COMPILED ONLY IF THE ENABLE_PERF_LOG WAS DEFINED.
// ENABLE_PERF_LOGis defined if GOLDEN or DISABLE_PERF_LOG is not defined.
#if defined (ENABLE_PERF_LOG)
//=============================================================================

//-----------------------------------------------------------------------------
// Widechar strings representing the units in UnitOfMeasure. *** Keep in sync  *** 
// with the array defined in PerfLog.cpp
wchar_t wszUnitOfMeasureDescr[MAX_UNITS_OF_MEASURE][MAX_CHARS_UNIT] = 
{
    L"",
    L"sec",
    L"Bytes",
    L"KBytes",
    L"KBytes/sec",
    L"cycles"
};

//-----------------------------------------------------------------------------
// Widechar strings representing the "direction" property of above units. 
// *** Keep in sync  *** with the array defined in PerfLog.cpp
// "Direction" property is false if an increase in the value of the counter indicates
// a degrade.
// "Direction" property is true if an increase in the value of the counter indicates
// an improvement.
wchar_t wszIDirection[MAX_UNITS_OF_MEASURE][MAX_CHARS_DIRECTION] =
{
    L"false",
    L"false",
    L"false",
    L"false",
    L"true",
    L"false"
};

//-----------------------------------------------------------------------------
// Initialize static variables of the PerfLog class.
bool PerfLog::m_perfLogInit = false;
wchar_t PerfLog::m_wszOutStr_1[];
wchar_t PerfLog::m_wszOutStr_2[];
char PerfLog::m_szPrintStr[];
DWORD PerfLog::m_dwWriteByte = 0;
int PerfLog::m_fLogPerfData = 0;
HANDLE PerfLog::m_hPerfLogFileHandle = 0;
bool PerfLog::m_perfAutomationFormat = false;
bool PerfLog::m_commaSeparatedFormat = false;

//-----------------------------------------------------------------------------
// Initliaze perf logging. Must be called before calling PERFLOG (x)...
void PerfLog::PerfLogInitialize()
{
    // Make sure we are called only once.
    if (m_perfLogInit)
    {
        return;
    }

    // First check for special cases:

    // Checks the JIT_PERF_OUTPUT env var and sets g_fJitPerfOn.
    InitJitPerf();
    
#ifdef WS_PERF
    // Private working set perf stats
    InitWSPerf();
#endif // WS_PERF

    // Put other special cases here.

    // @TODO agk: clean this logic a bit
    // Special cases considered. Now turn on loggin if any of above want logging
    // or if PERF_OUTPUT says so.

    wchar_t lpszValue[2];
    // Read the env var PERF_OUTPUT and if set continue.
    m_fLogPerfData = WszGetEnvironmentVariable (L"PERF_OUTPUT", lpszValue, sizeof(lpszValue)/sizeof(lpszValue[0]));    
    if (!m_fLogPerfData)
    {
        // Make sure that JIT perf was not requested. 
        if (!g_fJitPerfOn)
            return;

        // JIT perf stats are needed so set the flags also.
        m_fLogPerfData = 1;
    }

    // See if we want to output to the database
    wchar_t _lpszValue[11];
    DWORD _cchValue = 10; // 11 - 1
    _cchValue = WszGetEnvironmentVariable (L"PerfOutput", _lpszValue, _cchValue);
    if (_cchValue && (wcscmp (_lpszValue, L"DBase") == 0))
        m_perfAutomationFormat = true;
    if (_cchValue && (wcscmp (_lpszValue, L"CSV") == 0))
        m_commaSeparatedFormat = true;
    
    if (PerfAutomationFormat() || CommaSeparatedFormat())
    {
        // Hardcoded file name for spitting the perf auotmation formatted perf data. Open
        // the file here for writing and close in PerfLogDone().
        m_hPerfLogFileHandle = WszCreateFile (L"C:\\PerfData.dat",
                                              GENERIC_WRITE,
                                              FILE_SHARE_WRITE,    
                                              0,
                                              OPEN_ALWAYS,
                                              FILE_ATTRIBUTE_NORMAL,
                                              0);

        // check return value
        if(m_hPerfLogFileHandle == INVALID_HANDLE_VALUE)
        {
            m_fLogPerfData = 0;
            goto ErrExit;
        }
           
        // Make sure we append to the file.  @TODO agk: Is this necessary?
        if(SetFilePointer (m_hPerfLogFileHandle, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER )
        {
            CloseHandle (m_hPerfLogFileHandle);
            m_fLogPerfData = 0;
            goto ErrExit;
        }    
    }

    m_perfLogInit = true;    

ErrExit:
    return;
}

// Wrap up...
void PerfLog::PerfLogDone()
{
    DoneJitPerfStats();

#ifdef WS_PERF
    // Private working set perf
    OutputWSPerfStats();
#endif // WS_PERF
    
    if (CommaSeparatedFormat())
    {
        if (0 == WriteFile (m_hPerfLogFileHandle, "\n", (DWORD)strlen("\n"), &m_dwWriteByte, NULL))
            wprintf(L"ERROR: Could not write to perf log.\n");
    }

    if (PerfLoggingEnabled())
        CloseHandle (m_hPerfLogFileHandle);
}

void PerfLog::OutToStdout(wchar_t *wszName, UnitOfMeasure unit, wchar_t *wszDescr)
{
    if (wszDescr)
        swprintf(m_wszOutStr_2, L" (%s)\n", wszDescr);
    else
        swprintf(m_wszOutStr_2, L"\n");
    
    wprintf(L"%s", m_wszOutStr_1);
    wprintf(L"%s", m_wszOutStr_2);
}

void PerfLog::OutToPerfFile(wchar_t *wszName, UnitOfMeasure unit, wchar_t *wszDescr)
{
    if (CommaSeparatedFormat())
    {
        if(WszWideCharToMultiByte (CP_ACP, 0, m_wszOutStr_1, -1, m_szPrintStr, PRINT_STR_LEN-1, 0, 0)) {       
            if (0 == WriteFile (m_hPerfLogFileHandle, m_szPrintStr, (DWORD)strlen(m_szPrintStr), &m_dwWriteByte, NULL))
                wprintf(L"ERROR: Could not write to perf log.\n");
        }
        else
            wprintf(L"ERROR: Could not do string conversion.\n");
    }
    else
    {
        // Hack. The formats for ExecTime is slightly different from a custom value.
        if (wcscmp(wszName, L"ExecTime") == 0)
            swprintf(m_wszOutStr_2, L"ExecUnitDescr=%s\nExecIDirection=%s\n", wszDescr, wszIDirection[unit]);
        else
        {
            if (wszDescr)
                swprintf(m_wszOutStr_2, L"%s Descr=%s\n%s Unit Descr=None\n%s IDirection=%s\n", wszName, wszDescr, wszName, wszName, wszIDirection[unit]);
            else
                swprintf(m_wszOutStr_2, L"%s Descr=None\n%s Unit Descr=None\n%s IDirection=%s\n", wszName, wszName, wszName, wszIDirection[unit]);
        }

        // Write both pieces to the file.
        if(WszWideCharToMultiByte (CP_ACP, 0, m_wszOutStr_1, -1, m_szPrintStr, PRINT_STR_LEN-1, 0, 0)) {
            if (0 == WriteFile (m_hPerfLogFileHandle, m_szPrintStr, (DWORD)strlen(m_szPrintStr), &m_dwWriteByte, NULL))
                wprintf(L"ERROR: Could not write to perf log.\n");
        }      
        else
            wprintf(L"ERROR: Could not do string conversion.\n");
        
        if( WszWideCharToMultiByte (CP_ACP, 0, m_wszOutStr_2, -1, m_szPrintStr, PRINT_STR_LEN-1, 0, 0) ) {
            if (0 == WriteFile (m_hPerfLogFileHandle, m_szPrintStr, (DWORD)strlen(m_szPrintStr), &m_dwWriteByte, NULL))
                wprintf(L"ERROR: Could not write to perf log.\n");
        }
        else
            wprintf(L"ERROR: Could not do string conversion.\n");        
    }
}

// Output stats in pretty print to stdout and perf automation format to file 
// handle m_hPerfLogFileHandle
void PerfLog::Log(wchar_t *wszName, __int64 val, UnitOfMeasure unit, wchar_t *wszDescr)
{
    // Format the output into two pieces: The first piece is formatted here, rest in OutToStdout.
    swprintf(m_wszOutStr_1, L"%-30s%12.3g %s", wszName, val, wszUnitOfMeasureDescr[unit]);
    OutToStdout (wszName, unit, wszDescr);

    // Format the output into two pieces: The first piece is formatted here, rest in OutToPerfFile
    if (CommaSeparatedFormat())
    {
        swprintf(m_wszOutStr_1, L"%s;%0.3g;", wszName, val);
        OutToPerfFile (wszName, unit, wszDescr);
    }
    
    if (PerfAutomationFormat())
    {
        // Hack, Special case for ExecTime. since the format is slightly different than for custom value.
        if (wcscmp(wszName, L"ExecTime") == 0)
            swprintf(m_wszOutStr_1, L"%s=%0.3g\nExecUnit=%s\n", wszName, val, wszUnitOfMeasureDescr[unit]);
        else
            swprintf(m_wszOutStr_1, L"%s=%0.3g\n%s Unit=%s\n", wszName, val, wszName, wszUnitOfMeasureDescr[unit]);
        OutToPerfFile (wszName, unit, wszDescr);
    }
}

// Output stats in pretty print to stdout and perf automation format to file 
// handle m_hPerfLogFileHandle
void PerfLog::Log(wchar_t *wszName, double val, UnitOfMeasure unit, wchar_t *wszDescr)
{
    // Format the output into two pieces: The first piece is formatted here, rest in OutToStdout.
    swprintf(m_wszOutStr_1, L"%-30s%12.3g %s", wszName, val, wszUnitOfMeasureDescr[unit]);
    OutToStdout (wszName, unit, wszDescr);

    // Format the output into two pieces: The first piece is formatted here, rest in OutToPerfFile
    if (CommaSeparatedFormat())
    {
        swprintf(m_wszOutStr_1, L"%s;%0.3g;", wszName, val);
        OutToPerfFile (wszName, unit, wszDescr);
    }
    
    if (PerfAutomationFormat())
    {
        // Hack, Special case for ExecTime. since the format is slightly different than for custom value.
        if (wcscmp(wszName, L"ExecTime") == 0)
            swprintf(m_wszOutStr_1, L"%s=%0.3g\nExecUnit=%s\n", wszName, val, wszUnitOfMeasureDescr[unit]);
        else
            swprintf(m_wszOutStr_1, L"%s=%0.3g\n%s Unit=%s\n", wszName, val, wszName, wszUnitOfMeasureDescr[unit]);
        OutToPerfFile (wszName, unit, wszDescr);
    }
}

// Output stats in pretty print to stdout and perf automation format to file 
// handle m_hPerfLogFileHandle
void PerfLog::Log(wchar_t *wszName, unsigned val, UnitOfMeasure unit, wchar_t *wszDescr)
{
    // Format the output into two pieces: The first piece is formatted here, rest in OutToStdout.
    swprintf(m_wszOutStr_1, L"%-30s%12d %s", wszName, val, wszUnitOfMeasureDescr[unit]);
    OutToStdout (wszName, unit, wszDescr);

    // Format the output into two pieces: The first piece is formatted here, rest in OutToPerfFile
    if (CommaSeparatedFormat())
    {
        swprintf(m_wszOutStr_1, L"%s;%d;", wszName, val);
        OutToPerfFile (wszName, unit, wszDescr);
    }
    
    if (PerfAutomationFormat())
    {
        // Hack, Special case for ExecTime. since the format is slightly different than for custom value.
        if (wcscmp(wszName, L"ExecTime") == 0)
            swprintf(m_wszOutStr_1, L"%s=%0.3d\nExecUnit=%s\n", wszName, val, wszUnitOfMeasureDescr[unit]);
        else
            swprintf(m_wszOutStr_1, L"%s=%0.3d\n%s Unit=%s\n", wszName, val, wszName, wszUnitOfMeasureDescr[unit]);
        OutToPerfFile (wszName, unit, wszDescr);
    }
}

// Output stats in pretty print to stdout and perf automation format to file 
// handle m_hPerfLogFileHandle
void PerfLog::Log(wchar_t *wszName, DWORD val, UnitOfMeasure unit, wchar_t *wszDescr)
{
    // Format the output into two pieces: The first piece is formatted here, rest in OutToStdout.

    swprintf(m_wszOutStr_1, L"%-30s%12d %s", wszName, val, wszUnitOfMeasureDescr[unit]);
    OutToStdout (wszName, unit, wszDescr);

    // Format the output into two pieces: The first piece is formatted here, rest in OutToPerfFile
    if (CommaSeparatedFormat())
    {
        swprintf(m_wszOutStr_1, L"%s;%d;", wszName, val);
        OutToPerfFile (wszName, unit, wszDescr);
    }
    
    if (PerfAutomationFormat())
    {
        // Hack, Special case for ExecTime. since the format is slightly different than for custom value.
        if (wcscmp(wszName, L"ExecTime") == 0)
            swprintf(m_wszOutStr_1, L"%s=%0.3d\nExecUnit=%s\n", wszName, val, wszUnitOfMeasureDescr[unit]);
        else
            swprintf(m_wszOutStr_1, L"%s=%0.3d\n%s Unit=%s\n", wszName, val, wszName, wszUnitOfMeasureDescr[unit]);
        OutToPerfFile (wszName, unit, wszDescr);
    }
}


//=============================================================================
// ALL THE PERF LOG CODE IS COMPILED ONLY IF THE ENABLE_PERF_LOG WAS DEFINED.
#endif // ENABLE_PERF_LOG
//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\prettyprintsig.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// This code supports formatting a method and it's signature in a friendly
// and consistent format.
//
// Microsoft Confidential.
//*****************************************************************************
#include "stdafx.h"
#include "PrettyPrintSig.h"
#include "utilcode.h"
#include "MetaData.h"

/***********************************************************************/
static WCHAR* asStringW(CQuickBytes *out) 
{
	SIZE_T oldSize = out->Size();
	if (FAILED(out->ReSize(oldSize + 1)))
        return 0;
	WCHAR * cur = (WCHAR *) ((BYTE *) out->Ptr() + oldSize);
	*cur = 0;	
	return((WCHAR*) out->Ptr()); 
} // static WCHAR* asStringW()

static CHAR* asStringA(CQuickBytes *out) 
{
	SIZE_T oldSize = out->Size();
	if (FAILED(out->ReSize(oldSize + 1)))
        return 0;
	CHAR * cur = (CHAR *) ((BYTE *) out->Ptr() + oldSize);
	*cur = 0;	
	return((CHAR*) out->Ptr()); 
} // static CHAR* asStringA()


static HRESULT appendStrW(CQuickBytes *out, const WCHAR* str) 
{
	SIZE_T len = wcslen(str) * sizeof(WCHAR); 
	SIZE_T oldSize = out->Size();
	if (FAILED(out->ReSize(oldSize + len)))
        return E_OUTOFMEMORY;
	WCHAR * cur = (WCHAR *) ((BYTE *) out->Ptr() + oldSize);
	memcpy(cur, str, len);	
		// Note no trailing null!	
    return S_OK;
} // static HRESULT appendStrW()

static HRESULT appendStrA(CQuickBytes *out, const CHAR* str) 
{
	SIZE_T len = strlen(str) * sizeof(CHAR); 
	SIZE_T oldSize = out->Size();
	if (FAILED(out->ReSize(oldSize + len)))
        return E_OUTOFMEMORY;
	CHAR * cur = (CHAR *) ((BYTE *) out->Ptr() + oldSize);
	memcpy(cur, str, len);	
		// Note no trailing null!	
    return S_OK;
} // static HRESULT appendStrA()


static HRESULT appendStrNumW(CQuickBytes *out, int num) 
{
	WCHAR buff[16];	
	swprintf(buff, L"%d", num);	
	return appendStrW(out, buff);	
} // static HRESULT appendStrNumW()

static HRESULT appendStrNumA(CQuickBytes *out, int num) 
{
	CHAR buff[16];	
	sprintf(buff, "%d", num);	
	return appendStrA(out, buff);	
} // static HRESULT appendStrNumA()

//*****************************************************************************
//*****************************************************************************
// pretty prints 'type' to the buffer 'out' returns a poitner to the next type, 
// or 0 on a format failure 

static PCCOR_SIGNATURE PrettyPrintType(
	PCCOR_SIGNATURE typePtr,			// type to convert, 	
	CQuickBytes *out,					// where to put the pretty printed string	
	IMetaDataImport *pIMDI)				// ptr to IMDInternal class with ComSig
{
	mdToken		tk;	
	const WCHAR	*str;	
	WCHAR rcname[MAX_CLASS_NAME];
	bool		isValueArray;
	HRESULT		hr;

	switch(*typePtr++) 
	{	
		case ELEMENT_TYPE_VOID			:	
			str = L"void"; goto APPEND;	
		case ELEMENT_TYPE_BOOLEAN		:	
			str = L"bool"; goto APPEND;	
		case ELEMENT_TYPE_CHAR			:	
			str = L"wchar"; goto APPEND; 
		case ELEMENT_TYPE_I1			:	
			str = L"int8"; goto APPEND;	
		case ELEMENT_TYPE_U1			:	
			str = L"unsigned int8"; goto APPEND; 
		case ELEMENT_TYPE_I2			:	
			str = L"int16"; goto APPEND; 
		case ELEMENT_TYPE_U2			:	
			str = L"unsigned int16"; goto APPEND;	
		case ELEMENT_TYPE_I4			:	
			str = L"int32"; goto APPEND; 
		case ELEMENT_TYPE_U4			:	
			str = L"unsigned int32"; goto APPEND;	
		case ELEMENT_TYPE_I8			:	
			str = L"int64"; goto APPEND; 
		case ELEMENT_TYPE_U8			:	
			str = L"unsigned int64"; goto APPEND;	
		case ELEMENT_TYPE_R4			:	
			str = L"float32"; goto APPEND;	
		case ELEMENT_TYPE_R8			:	
			str = L"float64"; goto APPEND;	
		case ELEMENT_TYPE_U 			:	
			str = L"unsigned int"; goto APPEND;	 
		case ELEMENT_TYPE_I 			:	
			str = L"int"; goto APPEND;	 
		case 0x1a /* obsolete */    	:	
			str = L"float"; goto APPEND;  
		case ELEMENT_TYPE_OBJECT		:	
			str = L"class System.Object"; goto APPEND;	 
		case ELEMENT_TYPE_STRING		:	
			str = L"class System.String"; goto APPEND;	 
		case ELEMENT_TYPE_TYPEDBYREF		:	
			str = L"refany"; goto APPEND;	
		APPEND: 
			appendStrW(out, str);	
			break;	

		case ELEMENT_TYPE_VALUETYPE	:	
			str = L"value class ";	
			goto DO_CLASS;	
		case ELEMENT_TYPE_CLASS 		:	
			str = L"class "; 
			goto DO_CLASS;	

		DO_CLASS:
			typePtr += CorSigUncompressToken(typePtr, &tk);
			appendStrW(out, str);	
			rcname[0] = 0;
			str = rcname;

			if (TypeFromToken(tk) == mdtTypeRef)
				hr = pIMDI->GetTypeRefProps(tk, 0, rcname, NumItems(rcname), 0);
			else if (TypeFromToken(tk) == mdtTypeDef)
			{
				hr = pIMDI->GetTypeDefProps(tk, rcname, NumItems(rcname), 0,
						0, 0);
			}
			else
			{
				_ASSERTE(!"Unknown token type encountered in signature.");
				str = L"<UNKNOWN>";
			}

			appendStrW(out, str);	
			break;	

		case ELEMENT_TYPE_SZARRAY	 :	 
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			appendStrW(out, L"[]");
			break;
		case 0x17 /* obsolete */	:	
			isValueArray = true; goto DO_ARRAY;
		DO_ARRAY:
			{	
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			unsigned bound = CorSigUncompressData(typePtr); 

			if (isValueArray)
				appendStrW(out, L" value");
				
			WCHAR buff[32];	
			swprintf(buff, L"[%d]", bound);	
			appendStrW(out, buff);	
			} break;	
		case 0x1e /* obsolete */		:
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			appendStrW(out, L"[?]");
			break;
		case ELEMENT_TYPE_ARRAY		:	
			{	
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			unsigned rank = CorSigUncompressData(typePtr);	
				// TODO what is the syntax for the rank 0 case? 
			if (rank == 0) 
			{
				appendStrW(out, L"[??]");
			}
			else 
			{
				_ASSERTE(rank != 0);	
				int* lowerBounds = (int*) _alloca(sizeof(int)*2*rank);	
				int* sizes		 = &lowerBounds[rank];	
				memset(lowerBounds, 0, sizeof(int)*2*rank); 
				
				unsigned numSizes = CorSigUncompressData(typePtr);	
				_ASSERTE(numSizes <= rank); 
				for(unsigned i =0; i < numSizes; i++)	
					sizes[i] = CorSigUncompressData(typePtr);	
				
				unsigned numLowBounds = CorSigUncompressData(typePtr);	
				_ASSERTE(numLowBounds <= rank); 
				for(i = 0; i < numLowBounds; i++)	
					lowerBounds[i] = CorSigUncompressData(typePtr); 
				
				appendStrW(out, L"[");	
				for(i = 0; i < rank; i++)	
				{	
					if (sizes[i] != 0 && lowerBounds[i] != 0)	
					{	
						if (lowerBounds[i] == 0)	
							appendStrNumW(out, sizes[i]);	
						else	
						{	
							appendStrNumW(out, lowerBounds[i]);	
							appendStrW(out, L"...");	
							if (sizes[i] != 0)	
								appendStrNumW(out, lowerBounds[i] + sizes[i] + 1);	
						}	
					}	
					if (i < rank-1) 
						appendStrW(out, L",");	
				}	
				appendStrW(out, L"]");  
			}
			} break;	

        case 0x13 /* obsolete */        :   
			appendStrW(out, L"!");  
			appendStrNumW(out, CorSigUncompressData(typePtr));
			break;
            // Modifiers or depedant types  
		case ELEMENT_TYPE_PINNED	:
			str = L" pinned"; goto MODIFIER;	
            str = L"*"; goto MODIFIER;   
        case ELEMENT_TYPE_BYREF         :   
            str = L"&"; goto MODIFIER;   
		MODIFIER:
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			appendStrW(out, str);	
			break;	

		default:	
		case ELEMENT_TYPE_SENTINEL		:	
		case ELEMENT_TYPE_END			:	
			_ASSERTE(!"Unknown Type");	
			return(typePtr);	
			break;	
	}	
	return(typePtr);	
} // static PCCOR_SIGNATURE PrettyPrintType()

//*****************************************************************************
// Converts a com signature to a text signature.
//
// Note that this function DOES NULL terminate the result signature string.
//*****************************************************************************
LPCWSTR PrettyPrintSig(
	PCCOR_SIGNATURE typePtr,			// type to convert, 	
	unsigned	typeLen,				// length of type
	const WCHAR	*name,					// can be "", the name of the method for this sig	
	CQuickBytes *out,					// where to put the pretty printed string	
	IMetaDataImport *pIMDI) 			// Import api to use.
{
	out->ReSize(0); 
	unsigned numArgs;	
	PCCOR_SIGNATURE typeEnd = typePtr + typeLen;

	if (name != 0)						// 0 means a local var sig	
	{
			// get the calling convention out	
		unsigned callConv = CorSigUncompressData(typePtr);	

		if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
		{
			PrettyPrintType(typePtr, out, pIMDI);	
			if (name != 0 && *name != 0)	
			{	
				appendStrW(out, L" ");	
				appendStrW(out, name);	
			}	
			return(asStringW(out));	
		}

		if (callConv & IMAGE_CEE_CS_CALLCONV_HASTHIS)	
			appendStrW(out, L"instance ");	

		static WCHAR* callConvNames[8] = 
		{	
			L"", 
			L"unmanaged cdecl ", 
			L"unmanaged stdcall ",	
			L"unmanaged thiscall ",	
			L"unmanaged fastcall ",	
			L"vararg ",	 
			L"<error> "	 
			L"<error> "	 
		};	
		appendStrW(out, callConvNames[callConv & 7]);	

		numArgs = CorSigUncompressData(typePtr);	
			// do return type	
		typePtr = PrettyPrintType(typePtr, out, pIMDI); 

	}
	else	
		numArgs = CorSigUncompressData(typePtr);	

	if (name != 0 && *name != 0)	
	{	
		appendStrW(out, L" ");	
		appendStrW(out, name);	
	}	
	appendStrW(out, L"(");	

	bool needComma = false;
	while(typePtr < typeEnd) 
	{
		if (*typePtr == ELEMENT_TYPE_SENTINEL) 
		{
			if (needComma)
				appendStrW(out, L",");	
			appendStrW(out, L"...");	  
			typePtr++;
		}
		else 
		{
			if (numArgs <= 0)
				break;
			if (needComma)
				appendStrW(out, L",");	
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			--numArgs;	
		}
		needComma = true;
	}
	appendStrW(out, L")");	
	return (asStringW(out));	
} // LPCWSTR PrettyPrintSig()

// Internal implementation of PrettyPrintSig().

//*****************************************************************************
//*****************************************************************************
// pretty prints 'type' to the buffer 'out' returns a poitner to the next type, 
// or 0 on a format failure 

static HRESULT PrettyPrintTypeA(        // S_OK or error code.
	PCCOR_SIGNATURE &typePtr,			// type to convert, 	
	CQuickBytes     *out,				// where to put the pretty printed string	
	IMDInternalImport *pIMDI)			// ptr to IMDInternal class with ComSig
{
	mdToken		tk;	                    // A type's token.
	const CHAR	*str;	                // Temporary string.
    LPCUTF8     pNS;                    // A type's namespace.
    LPCUTF8     pN;                     // A type's name.
	bool		isValueArray;           // If true, array is value array.
	HRESULT		hr;                     // A result.

	switch(*typePtr++) 
	{	
		case ELEMENT_TYPE_VOID			:	
			str = "void"; goto APPEND;	
		case ELEMENT_TYPE_BOOLEAN		:	
			str = "bool"; goto APPEND;	
		case ELEMENT_TYPE_CHAR			:	
			str = "wchar"; goto APPEND; 
		case ELEMENT_TYPE_I1			:	
			str = "int8"; goto APPEND;	
		case ELEMENT_TYPE_U1			:	
			str = "unsigned int8"; goto APPEND; 
		case ELEMENT_TYPE_I2			:	
			str = "int16"; goto APPEND; 
		case ELEMENT_TYPE_U2			:	
			str = "unsigned int16"; goto APPEND;	
		case ELEMENT_TYPE_I4			:	
			str = "int32"; goto APPEND; 
		case ELEMENT_TYPE_U4			:	
			str = "unsigned int32"; goto APPEND;	
		case ELEMENT_TYPE_I8			:	
			str = "int64"; goto APPEND; 
		case ELEMENT_TYPE_U8			:	
			str = "unsigned int64"; goto APPEND;	
		case ELEMENT_TYPE_R4			:	
			str = "float32"; goto APPEND;	
		case ELEMENT_TYPE_R8			:	
			str = "float64"; goto APPEND;	
		case ELEMENT_TYPE_U 			:	
			str = "unsigned int"; goto APPEND;	 
		case ELEMENT_TYPE_I 			:	
			str = "int"; goto APPEND;	 
		case 0x1a /* obsolete */ 		:	
			str = "float"; goto APPEND;  
		case ELEMENT_TYPE_OBJECT		:	
			str = "class System.Object"; goto APPEND;	 
		case ELEMENT_TYPE_STRING		:	
			str = "class System.String"; goto APPEND;	 
		case ELEMENT_TYPE_TYPEDBYREF	:	
			str = "refany"; goto APPEND;	
		APPEND: 
			IfFailGo(appendStrA(out, str));	
			break;	

		case ELEMENT_TYPE_VALUETYPE	    :	
			str = "value class ";	
			goto DO_CLASS;	
		case ELEMENT_TYPE_CLASS 		:	
			str = "class "; 
			goto DO_CLASS;	

        case ELEMENT_TYPE_CMOD_REQD:
            str = "required_modifier ";
            goto DO_CLASS;
        
        case ELEMENT_TYPE_CMOD_OPT:
            str = "optional_modifier ";
            goto DO_CLASS;

		DO_CLASS:
			typePtr += CorSigUncompressToken(typePtr, &tk); 
			IfFailGo(appendStrA(out, str));	
			str = "<UNKNOWN>";	

            if (TypeFromToken(tk) == mdtTypeRef)
            {
                //@consider: assembly name?
                pIMDI->GetNameOfTypeRef(tk, &pNS, &pN);
            }
            else
            {
                _ASSERTE(TypeFromToken(tk) == mdtTypeDef);
                pIMDI->GetNameOfTypeDef(tk, &pN, &pNS);
            }
            
            if (pNS && *pNS)
            {
                IfFailGo(appendStrA(out, pNS));
                IfFailGo(appendStrA(out, NAMESPACE_SEPARATOR_STR));
            }
            IfFailGo(appendStrA(out, pN));
			break;	

		case ELEMENT_TYPE_SZARRAY	 :	 
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			IfFailGo(appendStrA(out, "[]"));
			break;
		case 0x17 /* obsolete */	    :	
			isValueArray = true; goto DO_ARRAY;
		DO_ARRAY:
			{	
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			unsigned bound = CorSigUncompressData(typePtr); 

			if (isValueArray)
				IfFailGo(appendStrA(out, " value"));
				
			CHAR buff[32];	
			sprintf(buff, "[%d]", bound);	
			IfFailGo(appendStrA(out, buff));	
			} break;	
		case 0x1e /* obsolete */		:
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			IfFailGo(appendStrA(out, "[?]"));
			break;
		case ELEMENT_TYPE_ARRAY		:	
			{	
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			unsigned rank = CorSigUncompressData(typePtr);	
				// TODO what is the syntax for the rank 0 case? 
			if (rank == 0) 
			{
				IfFailGo(appendStrA(out, "[??]"));
			}
			else 
			{
				_ASSERTE(rank != 0);	
				int* lowerBounds = (int*) _alloca(sizeof(int)*2*rank);	
				int* sizes		 = &lowerBounds[rank];	
				memset(lowerBounds, 0, sizeof(int)*2*rank); 
				
				unsigned numSizes = CorSigUncompressData(typePtr);	
				_ASSERTE(numSizes <= rank); 
				for(unsigned i =0; i < numSizes; i++)	
					sizes[i] = CorSigUncompressData(typePtr);	
				
				unsigned numLowBounds = CorSigUncompressData(typePtr);	
				_ASSERTE(numLowBounds <= rank); 
				for(i = 0; i < numLowBounds; i++)	
					lowerBounds[i] = CorSigUncompressData(typePtr); 
				
				IfFailGo(appendStrA(out, "["));	
				for(i = 0; i < rank; i++)	
				{	
					if (sizes[i] != 0 && lowerBounds[i] != 0)	
					{	
						if (lowerBounds[i] == 0)	
							appendStrNumA(out, sizes[i]);	
						else	
						{	
							appendStrNumA(out, lowerBounds[i]);	
							IfFailGo(appendStrA(out, "..."));	
							if (sizes[i] != 0)	
								appendStrNumA(out, lowerBounds[i] + sizes[i] + 1);	
						}	
					}	
					if (i < rank-1) 
						IfFailGo(appendStrA(out, ","));	
				}	
				IfFailGo(appendStrA(out, "]"));  
			}
			} 
            break;	

        case 0x13 /* obsolete */        :   
			IfFailGo(appendStrA(out, "!"));  
			appendStrNumA(out, CorSigUncompressData(typePtr));
			break;
            // Modifiers or depedant types  
		case ELEMENT_TYPE_PINNED	:
			str = " pinned"; goto MODIFIER;	
        case ELEMENT_TYPE_PTR           :   
            str = "*"; goto MODIFIER;   
        case ELEMENT_TYPE_BYREF         :   
            str = "&"; goto MODIFIER;   
		MODIFIER:
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			IfFailGo(appendStrA(out, str));	
			break;	

		default:	
		case ELEMENT_TYPE_SENTINEL		:	
		case ELEMENT_TYPE_END			:	
			_ASSERTE(!"Unknown Type");	
            hr = E_INVALIDARG;
			break;	
	}	
ErrExit:    
    return hr;
} // static HRESULT PrettyPrintTypeA()

//*****************************************************************************
// Converts a com signature to a text signature.
//
// Note that this function DOES NULL terminate the result signature string.
//*****************************************************************************
HRESULT PrettyPrintSigInternal(
	PCCOR_SIGNATURE typePtr,			// type to convert, 	
	unsigned	typeLen,				// length of type
	const CHAR	*name,					// can be "", the name of the method for this sig	
	CQuickBytes *out,					// where to put the pretty printed string	
	IMDInternalImport *pIMDI) 			// Import api to use.
{
    HRESULT     hr = S_OK;              // A result.
	out->ReSize(0); 
	unsigned numArgs;	
	PCCOR_SIGNATURE typeEnd = typePtr + typeLen;
	bool needComma = false;

	if (name != 0)						// 0 means a local var sig	
	{
			// get the calling convention out	
		unsigned callConv = CorSigUncompressData(typePtr);	

		if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
		{
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI));	
			if (name != 0 && *name != 0)	
			{	
				IfFailGo(appendStrA(out, " "));	
				IfFailGo(appendStrA(out, name));	
			}	
            goto ErrExit;
		}

		if (callConv & IMAGE_CEE_CS_CALLCONV_HASTHIS)	
			IfFailGo(appendStrA(out, "instance "));	

		static CHAR* callConvNames[8] = 
		{	
			"", 
			"unmanaged cdecl ", 
			"unmanaged stdcall ",	
			"unmanaged thiscall ",	
			"unmanaged fastcall ",	
			"vararg ",	 
			"<error> "	 
			"<error> "	 
		};	
		appendStrA(out, callConvNames[callConv & 7]);	

		numArgs = CorSigUncompressData(typePtr);	
			// do return type	
		IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 

	}
	else	
		numArgs = CorSigUncompressData(typePtr);	

	if (name != 0 && *name != 0)	
	{	
		IfFailGo(appendStrA(out, " "));	
		IfFailGo(appendStrA(out, name));	
	}	
	IfFailGo(appendStrA(out, "("));	

	while(typePtr < typeEnd) 
	{
		if (*typePtr == ELEMENT_TYPE_SENTINEL) 
		{
			if (needComma)
				IfFailGo(appendStrA(out, ","));	
			IfFailGo(appendStrA(out, "..."));	  
			++typePtr;
		}
		else 
		{
			if (numArgs <= 0)
				break;
			if (needComma)
				IfFailGo(appendStrA(out, ","));	
			IfFailGo(PrettyPrintTypeA(typePtr, out, pIMDI)); 
			--numArgs;	
		}
		needComma = true;
	}
	IfFailGo(appendStrA(out, ")"));	
    if (asStringA(out) == 0)
        IfFailGo(E_OUTOFMEMORY);
    
ErrExit:
    return hr;
} // HRESULT PrettyPrintSigInternal()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\regutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// regutil.h
//
// This module contains a set of functions that can be used to access the
// regsitry.
//
//*****************************************************************************


#include "stdafx.h"
#include "utilcode.h"
#include "mscoree.h"

//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
long REGUTIL::GetLong(                  // Return value from registry or default.
    LPCTSTR     szName,                 // Name of value to get.
    long        iDefault,               // Default value to return if not found.
    LPCTSTR     szKey,                  // Name of key, NULL==default.
    HKEY        hKeyVal)                // What key to work on.
{
    long        iValue;                 // The value to read.
    DWORD       iType;                  // Type of value to get.
    DWORD       iSize;                  // Size of buffer.
    HKEY        hKey;                   // Key for the registry entry.

    // Open the key if it is there.
    if (ERROR_SUCCESS != WszRegOpenKeyEx(hKeyVal, (szKey) ? szKey : FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &hKey))
        return (iDefault);

    // Read the key value if found.
    iType = REG_DWORD;
    iSize = sizeof(long);
    if (ERROR_SUCCESS != WszRegQueryValueEx(hKey, szName, NULL, 
            &iType, (LPBYTE)&iValue, &iSize) || iType != REG_DWORD)
        iValue = iDefault;

    // We're done with the key now.
    VERIFY(!RegCloseKey(hKey));
    return (iValue);
}


//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
long REGUTIL::SetLong(                  // Return value from registry or default.
    LPCTSTR     szName,                 // Name of value to get.
    long        iValue,                 // Value to set.
    LPCTSTR     szKey,                  // Name of key, NULL==default.
    HKEY        hKeyVal)                // What key to work on.
{
    long        lRtn;                   // Return code.
    HKEY        hKey;                   // Key for the registry entry.

    // Open the key if it is there.
	if (ERROR_SUCCESS != WszRegOpenKey(hKeyVal, (szKey) ? szKey : FRAMEWORK_REGISTRY_KEY_W, &hKey))
        return (-1);

    // Read the key value if found.
    lRtn = WszRegSetValueEx(hKey, szName, NULL, REG_DWORD, (const BYTE *) &iValue, sizeof(DWORD));

    // We're done with the key now.
    VERIFY(!RegCloseKey(hKey));
    return (lRtn);
}


//*****************************************************************************
// Open's the given key and returns the value desired.  If the value is not
// in the key, or the key does not exist, then the default is copied to the
// output buffer.
//*****************************************************************************
/*
// This is commented out because it calls StrNCpy which calls Wszlstrcpyn which we commented out
// because we didn't have a Win98 implementation and nobody was using it. jenh

LPCTSTR REGUTIL::GetString(             // Pointer to user's buffer.
    LPCTSTR     szName,                 // Name of value to get.
    LPCTSTR     szDefault,              // Default value if not found.
    LPTSTR      szBuff,                 // User's buffer to write to.
    ULONG       iMaxBuff,               // Size of user's buffer.
    LPCTSTR     szKey,                  // Name of key, NULL=default.
    int         *pbFound,               // Found key in registry?
    HKEY        hKeyVal)                // What key to work on.
{
    HKEY        hKey;                   // Key for the registry entry.
    DWORD       iType;                  // Type of value to get.
    DWORD       iSize;                  // Size of buffer.

    // Open the key if it is there.
    if (ERROR_SUCCESS != WszRegOpenKeyEx(hKeyVal, (szKey) ? szKey : FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &hKey))
    {
        StrNCpy(szBuff, szDefault, min((int)Wszlstrlen(szDefault), (int)iMaxBuff-1));
        if (pbFound != NULL) *pbFound = FALSE;
        return (szBuff); 
    }

    // Init the found flag.
    if (pbFound != NULL) *pbFound = TRUE;

    // Read the key value if found.
    iType = REG_SZ;
    iSize = iMaxBuff;
    if (ERROR_SUCCESS != WszRegQueryValueEx(hKey, szName, NULL, &iType, 
                    (LPBYTE)szBuff, &iSize) ||
        (iType != REG_SZ && iType != REG_EXPAND_SZ))
    {
        if (pbFound != NULL) *pbFound = FALSE;
        StrNCpy(szBuff, szDefault, min((int)Wszlstrlen(szDefault), (int)iMaxBuff-1));
    }

    // We're done with the key now.
    RegCloseKey(hKey);
    return (szBuff);
}
*/

//*****************************************************************************
// Reads from the environment setting
//*****************************************************************************
static LPWSTR EnvGetString(LPWSTR name, BOOL fPrependCOMPLUS)
{
    WCHAR buff[64];
    if(wcslen(name) > (size_t)(64 - 1 - (fPrependCOMPLUS ? 8 : 0))) 
        return(0);

    if (fPrependCOMPLUS)
        wcscpy(buff, L"COMPlus_");
    else
        *buff = 0;

    wcscat(buff, name);

    int len = WszGetEnvironmentVariable(buff, 0, 0);
    if (len == 0)
        return(0);
    LPWSTR ret = new WCHAR [len];
    WszGetEnvironmentVariable(buff, ret, len);
    return(ret);
}

//*****************************************************************************
// Reads a DWORD from the COR configuration according to the level specified
// Returns back defValue if the key cannot be found
//*****************************************************************************
DWORD REGUTIL::GetConfigDWORD(LPWSTR name, DWORD defValue, CORConfigLevel dwFlags, BOOL fPrependCOMPLUS)
{
    DWORD ret = 0;
    DWORD rtn;
    HKEY userKey;
    HKEY machineKey;
    DWORD type;
    DWORD size = 4;

    if (dwFlags & COR_CONFIG_ENV)
    {
        LPWSTR val = NULL;
        val = EnvGetString(name, fPrependCOMPLUS);  // try getting it from the environement first
        if (val != 0) {
            LPWSTR endPtr;
            rtn = wcstoul(val, &endPtr, 16);        // treat it has hex
            delete [] val;
            if (endPtr != val)                      // success
                return(rtn);
        }
    }

    if (dwFlags & COR_CONFIG_USER)
    {
        if (WszRegOpenKeyEx(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &userKey) == ERROR_SUCCESS)
        {
            rtn = WszRegQueryValueEx(userKey, name, 0, &type, (LPBYTE)&ret, &size);
            VERIFY(!RegCloseKey(userKey));
            if (rtn == ERROR_SUCCESS && type == REG_DWORD)
                return(ret);
        }
    }

    if (dwFlags & COR_CONFIG_MACHINE)
    {
        if (WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &machineKey) == ERROR_SUCCESS)
        {
            rtn = WszRegQueryValueEx(machineKey, name, 0, &type, (LPBYTE)&ret, &size);
            VERIFY(!RegCloseKey(machineKey));
            if (rtn == ERROR_SUCCESS && type == REG_DWORD)
                return(ret);
        }
    }

    return(defValue);
}

//*****************************************************************************
// Helper for setting value
//*****************************************************************************
static HRESULT OpenOrCreateKey(HKEY rootKey, LPCWSTR wszKey, HKEY *phReg)
{
    LONG lRet;

    if ((lRet = WszRegOpenKeyEx(rootKey, wszKey, 0, KEY_ALL_ACCESS, phReg)) != ERROR_SUCCESS)
    {
        lRet = WszRegCreateKeyEx(rootKey, wszKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, phReg, NULL);
    }

    return HRESULT_FROM_WIN32(lRet);
}

//*****************************************************************************
// Sets a DWORD from the COR configuration according to the level specified
//*****************************************************************************
HRESULT REGUTIL::SetConfigDWORD(LPWSTR name, DWORD value, CORConfigLevel dwFlags)
{
    HRESULT hr = S_OK;
    DWORD ret = 0;
    HKEY userKey = NULL;
    HKEY machineKey = NULL;

    if (dwFlags & ~(COR_CONFIG_USER|COR_CONFIG_MACHINE))
        return ERROR_BAD_ARGUMENTS;

    if (dwFlags & COR_CONFIG_USER) {
        if ((hr = OpenOrCreateKey(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W, &userKey)) == ERROR_SUCCESS)
        {
            hr = WszRegSetValueEx(userKey, name, 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD));
            VERIFY(!RegCloseKey(userKey));

            if (SUCCEEDED(hr))
                return hr;      // Set only one
        }
    }

    if (dwFlags & COR_CONFIG_MACHINE) {
        if ((hr = OpenOrCreateKey(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W, &machineKey)) == ERROR_SUCCESS)
        {
            hr = WszRegSetValueEx(machineKey, name, 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD));
            VERIFY(!RegCloseKey(machineKey));
        }
    }

    return hr;
}

//*****************************************************************************
// Reads a string from the COR configuration according to the level specified
// The caller is responsible for deallocating the returned string
//*****************************************************************************
LPWSTR REGUTIL::GetConfigString(LPWSTR name, BOOL fPrependCOMPLUS, CORConfigLevel level)
{
    HRESULT lResult;
    HKEY userKey = NULL;
    HKEY machineKey = NULL;
    DWORD type;
    DWORD size;
    LPWSTR ret = NULL;

    if (level & COR_CONFIG_ENV)
    {
        ret = EnvGetString(name, fPrependCOMPLUS);  // try getting it from the environement first
        if (ret != 0) {
                if (*ret != 0) 
                    return(ret);
                delete [] ret;
                ret = NULL;
        }
    }

    if (level & COR_CONFIG_USER)
    {
        if ((WszRegOpenKeyEx(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &userKey) == ERROR_SUCCESS) &&
            (WszRegQueryValueEx(userKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ) {
            ret = (LPWSTR) new BYTE [size];
            if (!ret)
                goto ErrExit;
            ret[0] = L'\0';
            lResult = WszRegQueryValueEx(userKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            goto ErrExit;
            }
    }

    if (level & COR_CONFIG_MACHINE)
    {
        if ((WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &machineKey) == ERROR_SUCCESS) &&
            (WszRegQueryValueEx(machineKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ) {
            ret = (LPWSTR) new BYTE[size];
            if (!ret)
                goto ErrExit;
            ret[0] = L'\0';
            lResult = WszRegQueryValueEx(machineKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            goto ErrExit;
            }
    }

ErrExit:
    if (userKey)
        VERIFY(!RegCloseKey(userKey));
    if (machineKey)
        VERIFY(!RegCloseKey(machineKey));
    return(ret);
}

void REGUTIL::FreeConfigString(LPWSTR str)
{
    delete [] str;
}

//*****************************************************************************
// Reads a BIT flag from the COR configuration according to the level specified
// Returns back defValue if the key cannot be found
//*****************************************************************************
DWORD REGUTIL::GetConfigFlag(LPWSTR name, DWORD bitToSet, BOOL defValue)
{
    return(GetConfigDWORD(name, defValue) != 0 ? bitToSet : 0);
}


//*****************************************************************************
// Set an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey = szValue.  If szSubkey or szValue are
// NULL, omit them from the above expression.
//*****************************************************************************
BOOL REGUTIL::SetKeyAndValue(           // TRUE or FALSE.
    LPCTSTR     szKey,                  // Name of the reg key to set.
    LPCTSTR     szSubkey,               // Optional subkey of szKey.
    LPCTSTR     szValue)                // Optional value for szKey\szSubkey.
{
    HKEY        hKey = NULL;                   // Handle to the new reg key.
    CQuickBytes qb;
    TCHAR*      rcKey = (TCHAR*) qb.Alloc((_tcslen(szKey) + (szSubkey ? (1 + _tcslen(szSubkey)) : 0) + 1) * sizeof(TCHAR));

    // Init the key with the base key name.
    _tcscpy(rcKey, szKey);

    // Append the subkey name (if there is one).
    if (szSubkey != NULL)
    {
        _tcscat(rcKey, L"\\");
        _tcscat(rcKey, szSubkey);
    }

    // Create the registration key.
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, rcKey, 0, NULL,
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, NULL) != ERROR_SUCCESS)
        return(FALSE);

    // Set the value (if there is one).
    if (szValue != NULL) {
        if( WszRegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *) szValue,
                        (Wszlstrlen(szValue)+1) * sizeof(TCHAR)) != ERROR_SUCCESS ) {
             VERIFY(!RegCloseKey(hKey));
             return(FALSE);
        }            
    }

    VERIFY(!RegCloseKey(hKey));
    return(TRUE);
}


//*****************************************************************************
// Delete an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey.
//*****************************************************************************
LONG REGUTIL::DeleteKey(                // TRUE or FALSE.
    LPCTSTR     szKey,                  // Name of the reg key to set.
    LPCTSTR     szSubkey)               // Subkey of szKey.
{
    size_t nLen = _tcslen(szKey)+1;

    if (szSubkey != NULL)
        nLen += _tcslen(szSubkey) + _tcslen(_T("\\"));
        
    TCHAR * rcKey = (TCHAR *) _alloca(nLen * sizeof(TCHAR) );

    // Init the key with the base key name.
    _tcscpy(rcKey, szKey);

    // Append the subkey name (if there is one).
    if (szSubkey != NULL)
    {
        _tcscat(rcKey, _T("\\"));
        _tcscat(rcKey, szSubkey);
    }

    // Delete the registration key.    
    return WszRegDeleteKey(HKEY_CLASSES_ROOT, rcKey);
}


//*****************************************************************************
// Open the key, create a new keyword and value pair under it.
//*****************************************************************************
BOOL REGUTIL::SetRegValue(              // Return status.
    LPCTSTR     szKeyName,              // Name of full key.
    LPCTSTR     szKeyword,              // Name of keyword.
    LPCTSTR     szValue)                // Value of keyword.
{
    HKEY        hKey;                   // Handle to the new reg key.

    // Create the registration key.
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, szKeyName, 0, NULL,
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, NULL) != ERROR_SUCCESS)
        return (FALSE);

    // Set the value (if there is one).
    if (szValue != NULL) {
        if( WszRegSetValueEx(hKey, szKeyword, 0, REG_SZ, (BYTE *)szValue, 
        	(Wszlstrlen(szValue)+1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
              VERIFY(!RegCloseKey(hKey));
              return(FALSE);
        }            
    }
    
    VERIFY(!RegCloseKey(hKey));
    return (TRUE);
}


//*****************************************************************************
// Does standard registration of a CoClass with a progid.
//*****************************************************************************
HRESULT REGUTIL::RegisterCOMClass(      // Return code.
    REFCLSID    rclsid,                 // Class ID.
    LPCTSTR     szDesc,                 // Description of the class.
    LPCTSTR     szProgIDPrefix,         // Prefix for progid.
    int         iVersion,               // Version # for progid.
    LPCTSTR     szClassProgID,          // Class progid.
    LPCTSTR     szThreadingModel,       // What threading model to use.
    LPCTSTR     szModule,               // Path to class.
    HINSTANCE   hInst,                  // Handle to module being registered
    LPCTSTR     szAssemblyName,         // Optional Assembly,
    LPCTSTR     szVersion,              // Optional Runtime version (directory containing runtime)
    BOOL        fExternal,              // flag - External to mscoree.
    BOOL        fRelativePath)          // flag - Relative path in szModule 
{
    TCHAR       rcCLSID[256];           // CLSID\\szID.
    TCHAR       rcInproc[_MAX_PATH+64]; // CLSID\\InprocServer32
    TCHAR       rcProgID[256];          // szProgIDPrefix.szClassProgID
    TCHAR       rcIndProgID[256];       // rcProgID.iVersion
    TCHAR       rcShim[_MAX_PATH];
    HRESULT     hr;

    // Format the prog ID values.
    VERIFY(swprintf(rcIndProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
    VERIFY(swprintf(rcProgID, L"%s.%d", rcIndProgID, iVersion));

    // Do the initial portion.
    if (FAILED(hr = RegisterClassBase(rclsid, szDesc, rcProgID, rcIndProgID, rcCLSID, NumItems(rcCLSID) )))
        return (hr);
    
    VERIFY(swprintf(rcInproc, L"%s\\%s", rcCLSID, L"InprocServer32"));

    if (!fExternal){
        SetKeyAndValue(rcCLSID, L"InprocServer32", szModule);
    }
    else{
        LPCTSTR pSep = szModule;
        if (!fRelativePath && szModule) {
            pSep = wcsrchr(szModule, L'\\');
            if(pSep == NULL)
                pSep = szModule;
            else 
                pSep++;
        }        
        HMODULE hMod = WszLoadLibrary(L"mscoree.dll");
        if (!hMod)
            return E_FAIL;

        DWORD ret;
        VERIFY(ret = WszGetModuleFileName(hMod, rcShim, NumItems(rcShim)));
        FreeLibrary(hMod);        
        if( !ret ) 
        	return E_FAIL;	       
        
        // Set the server path.
        SetKeyAndValue(rcCLSID, L"InprocServer32", rcShim);
        if(pSep)
            SetKeyAndValue(rcCLSID, L"Server", pSep);

        if(szAssemblyName) {
            SetRegValue(rcInproc, L"Assembly", szAssemblyName);
            SetRegValue(rcInproc, L"Class", rcIndProgID);
        }
    }

    // Set the runtime version, it needs to be passed in from the outside
    if(szVersion != NULL) {
        LPCTSTR pSep2 = NULL;
        LPTSTR pSep1 = wcsrchr(szVersion, L'\\');
        if(pSep1 != NULL) {
            *pSep1 = '\0';
            pSep2 = wcsrchr(szVersion, L'\\');
            if (!pSep2)
                pSep2 = szVersion;
            else
                pSep2 = pSep2++;    // exclude '\\'
        }
        else 
            pSep2 = szVersion;
        WCHAR* rcVersion=new WCHAR[(wcslen(rcInproc)+wcslen(pSep2)+2)];
        if(rcVersion==NULL)
            return (E_OUTOFMEMORY);
        wcscpy(rcVersion,rcInproc);
        wcscat(rcVersion,L"\\");
        wcscat(rcVersion,pSep2);
        SetRegValue(rcVersion, L"ImplementedInThisVersion", L"");
        delete[] rcVersion;
        if(pSep1 != NULL)
            *pSep1 = L'\\';
    }

    // Add the threading model information.
    SetRegValue(rcInproc, L"ThreadingModel", szThreadingModel);
    return (S_OK);
}



//*****************************************************************************
// Does standard registration of a CoClass with a progid.
// NOTE: This is the non-side-by-side execution version.
//*****************************************************************************
HRESULT REGUTIL::RegisterCOMClass(      // Return code.
    REFCLSID    rclsid,                 // Class ID.
    LPCTSTR     szDesc,                 // Description of the class.
    LPCTSTR     szProgIDPrefix,         // Prefix for progid.
    int         iVersion,               // Version # for progid.
    LPCTSTR     szClassProgID,          // Class progid.
    LPCTSTR     szThreadingModel,       // What threading model to use.
    LPCTSTR     szModule)               // Path to class.
{
    TCHAR       rcCLSID[256];           // CLSID\\szID.
    TCHAR       rcInproc[_MAX_PATH+64]; // CLSID\\InprocServer32
    TCHAR       rcProgID[256];          // szProgIDPrefix.szClassProgID
    TCHAR       rcIndProgID[256];       // rcProgID.iVersion
    HRESULT     hr;

    // Format the prog ID values.
    VERIFY(swprintf(rcIndProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
    VERIFY(swprintf(rcProgID, L"%s.%d", rcIndProgID, iVersion));

    // Do the initial portion.
    if (FAILED(hr = RegisterClassBase(rclsid, szDesc, rcProgID, rcIndProgID, rcCLSID, NumItems(rcCLSID) )))
        return (hr);

    // Set the server path.
    SetKeyAndValue(rcCLSID, L"InprocServer32", szModule);

    // Add the threading model information.
    VERIFY(swprintf(rcInproc, L"%s\\%s", rcCLSID, L"InprocServer32"));
    SetRegValue(rcInproc, L"ThreadingModel", szThreadingModel);
    return (S_OK);
}



//*****************************************************************************
// Register the basics for a in proc server.
//*****************************************************************************
HRESULT REGUTIL::RegisterClassBase(     // Return code.
    REFCLSID    rclsid,                 // Class ID we are registering.
    LPCTSTR     szDesc,                 // Class description.
    LPCTSTR     szProgID,               // Class prog ID.
    LPCTSTR     szIndepProgID,      // Class version independant prog ID.
    LPTSTR       szOutCLSID,             // CLSID formatted in character form.
    DWORD      cchOutCLSID)           // Out CLS ID buffer size
{
    TCHAR       szID[64];               // The class ID to register.

    // Create some base key strings.
#ifdef _UNICODE
    GuidToLPWSTR(rclsid, szID, NumItems(szID));
#else
    OLECHAR     szWID[64];              // The class ID to register.

    GuidToLPWSTR(rclsid, szWID, NumItems(szWID));
    WszWideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID)-1, NULL, NULL);
#endif
    size_t nLen = _tcslen(_T("CLSID\\")) + _tcslen( szID) + 1;
    if( cchOutCLSID < nLen ) 	
	return E_INVALIDARG;

    _tcscpy(szOutCLSID, _T("CLSID\\"));
    _tcscat(szOutCLSID, szID);

    // Create ProgID keys.
    SetKeyAndValue(szProgID, NULL, szDesc);
    SetKeyAndValue(szProgID, L"CLSID", szID);

    // Create VersionIndependentProgID keys.
    SetKeyAndValue(szIndepProgID, NULL, szDesc);
    SetKeyAndValue(szIndepProgID, L"CurVer", szProgID);
    SetKeyAndValue(szIndepProgID, L"CLSID", szID);

    // Create entries under CLSID.
    SetKeyAndValue(szOutCLSID, NULL, szDesc);
    SetKeyAndValue(szOutCLSID, L"ProgID", szProgID);
    SetKeyAndValue(szOutCLSID, L"VersionIndependentProgID", szIndepProgID);
    SetKeyAndValue(szOutCLSID, L"NotInsertable", NULL);
    return (S_OK);
}



//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
//*****************************************************************************
HRESULT REGUTIL::UnregisterCOMClass(    // Return code.
    REFCLSID    rclsid,                 // Class ID we are registering.
    LPCTSTR     szProgIDPrefix,         // Prefix for progid.
    int         iVersion,               // Version # for progid.
    LPCTSTR     szClassProgID,          // Class progid.
    BOOL        fExternal)              // flag - External to mscoree.
{
    TCHAR       rcCLSID[64];            // CLSID\\szID.
    TCHAR       rcProgID[128];          // szProgIDPrefix.szClassProgID
    TCHAR       rcIndProgID[128];       // rcProgID.iVersion

    // Format the prog ID values.
    VERIFY(swprintf(rcProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
    VERIFY(swprintf(rcIndProgID, L"%s.%d", rcProgID, iVersion));

    HRESULT hr = UnregisterClassBase(rclsid, rcProgID, rcIndProgID, rcCLSID, NumItems(rcCLSID));
    if(FAILED(hr))
    	return( hr);
    DeleteKey(rcCLSID, L"InprocServer32");
    if (fExternal){
        DeleteKey(rcCLSID, L"Server");
        DeleteKey(rcCLSID, L"Version");
    }
    GuidToLPWSTR(rclsid, rcCLSID, NumItems(rcCLSID));
    DeleteKey(L"CLSID", rcCLSID);
    return (S_OK);
}


//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
// NOTE: This is the non-side-by-side execution version.
//*****************************************************************************
HRESULT REGUTIL::UnregisterCOMClass(    // Return code.
    REFCLSID    rclsid,                 // Class ID we are registering.
    LPCTSTR     szProgIDPrefix,         // Prefix for progid.
    int         iVersion,               // Version # for progid.
    LPCTSTR     szClassProgID)          // Class progid.
{
    TCHAR       rcCLSID[64];            // CLSID\\szID.
    TCHAR       rcProgID[128];          // szProgIDPrefix.szClassProgID
    TCHAR       rcIndProgID[128];       // rcProgID.iVersion

    // Format the prog ID values.
    VERIFY(swprintf(rcProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
    VERIFY(swprintf(rcIndProgID, L"%s.%d", rcProgID, iVersion));

    HRESULT hr = UnregisterClassBase(rclsid, rcProgID, rcIndProgID, rcCLSID, NumItems(rcCLSID));
    if(FAILED(hr))		// we don't want to delete unexpected keys
    	return( hr);
    
    DeleteKey(rcCLSID, L"InprocServer32");
    
    GuidToLPWSTR(rclsid, rcCLSID, NumItems(rcCLSID));
    DeleteKey(L"CLSID", rcCLSID);
    return (S_OK);
}


//*****************************************************************************
// Delete the basic settings for an inproc server.
//*****************************************************************************
HRESULT REGUTIL::UnregisterClassBase(   // Return code.
    REFCLSID    rclsid,                 // Class ID we are registering.
    LPCTSTR     szProgID,               // Class prog ID.
    LPCTSTR     szIndepProgID,          // Class version independant prog ID.
    LPTSTR      szOutCLSID,             // Return formatted class ID here.
    DWORD      cchOutCLSID)           // Out CLS ID buffer size    
{
    TCHAR       szID[64];               // The class ID to register.

    // Create some base key strings.
#ifdef _UNICODE
    GuidToLPWSTR(rclsid, szID, NumItems(szID));
#else
    OLECHAR     szWID[64];              // The class ID to register.

    GuidToLPWSTR(rclsid, szWID, NumItems(szWID));
    WszWideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID)-1, NULL, NULL);
#endif
    size_t nLen = _tcslen(_T("CLSID\\")) + _tcslen( szID) + 1;
    if( cchOutCLSID < nLen ) 	
	return E_INVALIDARG;

    _tcscpy(szOutCLSID,  _T("CLSID\\"));
    _tcscat(szOutCLSID, szID);

    // Delete the version independant prog ID settings.
    DeleteKey(szIndepProgID, L"CurVer");
    DeleteKey(szIndepProgID, L"CLSID");
    WszRegDeleteKey(HKEY_CLASSES_ROOT, szIndepProgID);

    // Delete the prog ID settings.
    DeleteKey(szProgID, L"CLSID");
    WszRegDeleteKey(HKEY_CLASSES_ROOT, szProgID);

    // Delete the class ID settings.
    DeleteKey(szOutCLSID, L"ProgID");
    DeleteKey(szOutCLSID, L"VersionIndependentProgID");
    DeleteKey(szOutCLSID, L"NotInsertable");
    WszRegDeleteKey(HKEY_CLASSES_ROOT, szOutCLSID);
    return (S_OK);
}


//*****************************************************************************
// Register a type library.
//*****************************************************************************
HRESULT REGUTIL::RegisterTypeLib(       // Return code.
    REFGUID     rtlbid,                 // TypeLib ID we are registering.
    int         iVersion,               // Typelib version.
    LPCTSTR     szDesc,                 // TypeLib description.
    LPCTSTR     szModule)               // Path to the typelib.
{
    TCHAR       szID[64];               // The typelib ID to register.
    TCHAR       szTLBID[256];           // TypeLib\\szID.
    TCHAR       szHelpDir[_MAX_PATH];
    TCHAR       szDrive[_MAX_DRIVE];
    TCHAR       szDir[_MAX_DIR];
    TCHAR       szVersion[64];
    LPTSTR      szTmp;

    // Create some base key strings.
#ifdef _UNICODE
    GuidToLPWSTR(rtlbid, szID, NumItems(szID));
#else
    OLECHAR     szWID[64];              // The class ID to register.

    GuidToLPWSTR(rtlbid, szWID, NumItems(szWID));
    WszWideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID)-1, NULL, NULL);
#endif
    _tcscpy(szTLBID, L"TypeLib\\");
    _tcscat(szTLBID, szID);

    VERIFY(swprintf(szVersion, L"%d.0", iVersion));

    // Create Typelib keys.
    SetKeyAndValue(szTLBID, NULL, NULL);
    SetKeyAndValue(szTLBID, szVersion, szDesc);
    _tcscat(szTLBID, L"\\");
    _tcscat(szTLBID, szVersion);
    SetKeyAndValue(szTLBID, L"0", NULL);
    SetKeyAndValue(szTLBID, L"0\\win32", szModule);
    SetKeyAndValue(szTLBID, L"FLAGS", L"0");
    SplitPath(szModule, szDrive, szDir, NULL, NULL);
    _tcscpy(szHelpDir, szDrive);
    if ((szTmp = CharPrev(szDir, szDir + Wszlstrlen(szDir))) != NULL)
        *szTmp = '\0';
    _tcscat(szHelpDir, szDir);
    SetKeyAndValue(szTLBID, L"HELPDIR", szHelpDir);
    return (S_OK);
}


//*****************************************************************************
// Remove the registry keys for a type library.
//*****************************************************************************
HRESULT REGUTIL::UnregisterTypeLib(     // Return code.
    REFGUID     rtlbid,                 // TypeLib ID we are registering.
    int         iVersion)               // Typelib version.
{
    TCHAR       szID[64];               // The typelib ID to register.
    TCHAR       szTLBID[256];           // TypeLib\\szID.
    TCHAR       szTLBVersion[256];      // TypeLib\\szID\\szVersion
    TCHAR       szVersion[64];

    // Create some base key strings.
#ifdef _UNICODE
    GuidToLPWSTR(rtlbid, szID, NumItems(szID));
#else
    OLECHAR     szWID[64];              // The class ID to register.

    GuidToLPWSTR(rtlbid, szWID, NumItems(szWID));
    WszWideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID)-1, NULL, NULL);
#endif
    VERIFY(swprintf(szVersion, L"%d.0", iVersion));
    _tcscpy(szTLBID, L"TypeLib\\");
    _tcscat(szTLBID, szID);
    _tcscpy(szTLBVersion, szTLBID);
    _tcscat(szTLBVersion, L"\\");
    _tcscat(szTLBVersion, szVersion);

    // Delete Typelib keys.
    DeleteKey(szTLBVersion, L"HELPDIR");
    DeleteKey(szTLBVersion, L"FLAGS");
    DeleteKey(szTLBVersion, L"0\\win32");
    DeleteKey(szTLBVersion, L"0");
    DeleteKey(szTLBID, szVersion);
    WszRegDeleteKey(HKEY_CLASSES_ROOT, szTLBID);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\sources.inc ===
#
# Viper build instructions for this directory
#
#   Bob Atkinson
#   April 1997

NO_CRT                  =1
!include $(NTMAKEENV)\sources.cor

INCLUDES        = $(INCLUDES);.;..\inc;..\..\inc;

MINORCOMP       =utilcode

PRECOMPILED_INCLUDE     = stdafx.h
PRECOMPILED_CXX         = 1
PRECOMPILED_SOURCEFILE  = stdafx.cpp

TARGETNAME      =$(CORBUILDENV)utilcode$(_CRTFLAVOR)
TARGETPATH      =$(TARGETCORLIB)
TARGETTYPE      =LIBRARY

PRECOMPILED_INCLUDE     = ..\stdafx.h
PRECOMPILED_CXX         = 1
PRECOMPILED_SOURCEFILE  = ..\stdafx.cpp
PRECOMPILED_Obj         = stdafx_utilcode.obj

!ifdef _WIN32_FUSION
COR_C_FLAGS     = -DUNICODE -D_UNICODE $(_CRTIMPFLAGS) 
!else
COR_C_FLAGS     = -DUNICODE -D_UNICODE $(_CRTIMPFLAGS) -D_WIN32_FUSION=0x0100 
!endif

#
# remove this when DCOR_ILEXCEPTION_OFFSETLEN_SUPPORTED removed from cor.h
#
COR_C_FLAGS       = $(COR_C_FLAGS) -DCOR_ILEXCEPTION_OFFSETLEN_SUPPORTED -DENABLE_PERF_COUNTERS

CDEFINES                = $(CDEFINES) $(COR_C_FLAGS)

SOURCES=                        \
        ..\arraylist.cpp           \
        ..\assemblyfilehash.cpp    \
        ..\ccomprc.cpp             \
        ..\FusionBind.cpp          \
        ..\FusionSink.cpp          \
        ..\CompletePath.cpp        \
        ..\debug.cpp               \
        ..\GuidFromName.cpp        \
        ..\md5.cpp                 \
        ..\miniio.cpp              \
        ..\regutil.cpp             \
        ..\format1.cpp             \
        ..\SigHelper.cpp           \
        ..\util.cpp                \
        ..\utf.c                   \
        ..\utsem.cpp               \
        ..\PostError.cpp           \
        ..\PrettyPrintSig.cpp      \
        ..\SigHelper.cpp           \
        ..\StackTrace.cpp          \
        ..\StgPool.cpp             \
        ..\StgPooli.cpp            \
        ..\StgPoolReadonly.cpp     \
        ..\StressLog.cpp           \
        ..\splitpat.c              \
        ..\SxSHelpers.cpp          \
        ..\timeline.cpp            \
        ..\InternalDebug.cpp       \
        ..\makepath.c              \
        ..\log.cpp                 \
        ..\inifile.cpp             \
        ..\loaderheap.cpp          \
        ..\idecoder.cpp            \
        ..\winfix.cpp              \
        ..\DbgAlloc.cpp            \
        ..\wsperf.cpp              \
        ..\jitperf.cpp             \
        ..\tlbutils.cpp            \
        ..\PerfLog.cpp             \
        ..\NameSpaceUtil.cpp       \
        ..\outstring.cpp           \
        ..\ilformatter.cpp         \
        ..\opinfo.cpp              \
        ..\PerfAlloc.cpp           \
        ..\wsinfo.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\sighelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: SIGHELPER.CPP
//
// This file defines the helpers for processing signature
// ===========================================================================
#include "stdafx.h"						// Precompiled header key.

#ifndef COMPLUS98

#include <utilcode.h>
#include <corpriv.h>
#include <sighelper.h>



///////////////////////////////////////////////////////////////////////////////
//
// Given a COM+ signature to fill in CorETypeStruct
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CorSigGetSimpleEType(			// return S_FALSE if element type is too complicated to be hold in CorETypeStruct
	void		*pData,					// [IN] pointing to the starting of an element type
	CorSimpleETypeStruct *pEType,		// [OUT] struct containing parsing result
	ULONG		*pcbCount)				// [OUT] how many bytes this element type consisted of
{
	_ASSERTE(!"NYI!");
	return NOERROR;
}




///////////////////////////////////////////////////////////////////////////////
//
// pass in a CorETypeStruct, determine how many bytes will need to represent this
// in COM+ signature
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CorSigGetSimpleETypeCbSize(		// return hresult
	CorSimpleETypeStruct *pEType,		// [IN] pass in 
	ULONG		*pcbCount)				// [OUT]count of bytes
{
	ULONG		dwData;
	CorElementType et = ELEMENT_TYPE_MAX;
	ULONG		cb = 0;
	ULONG		cb1 = 0;

	// output param should not be NULL
	_ASSERTE(pcbCount);
	*pcbCount = 0;
	if (pEType->corEType == ELEMENT_TYPE_ARRAY || pEType->corEType == ELEMENT_TYPE_SZARRAY)
	{
		_ASSERTE(!"bad type");
		return S_FALSE;
	}

	// bad type in corEType...
	if (pEType->corEType == ELEMENT_TYPE_PTR || pEType->corEType == ELEMENT_TYPE_BYREF)
	{
		_ASSERTE(!"bad type");
		return S_FALSE;
	}

	cb = CorSigCompressElementType(et, &dwData);
	cb1 = cb;
	if (CorIsPrimitiveType(pEType->corEType)) 
	{
		*pcbCount = cb;
		return NOERROR;
	}

	if (pEType->dwFlags & CorSigElementTypePtr) 
	{
		// need to hold cIndirection number of etPtr
		cb1 += cb * pEType->cIndirection;
	}

	if (pEType->dwFlags & CorSigElementTypeByRef) 
	{
		// need to hold etBYREF
		cb1 += cb;
	}

	if (pEType->corEType == ELEMENT_TYPE_VALUETYPE || pEType->corEType == ELEMENT_TYPE_CLASS)
	{
		// composit or class will require space for rid
		cb1 += CorSigCompressToken(pEType->typeref, &dwData);
	}
	*pcbCount = cb1;
	return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
//
// translate the pass-in CorETypeStruct to bytes. 
//
///////////////////////////////////////////////////////////////////////////////
HRESULT	CorSigPutSimpleEType(			// return hresult
	CorSimpleETypeStruct *pEType,		// [IN] pass in
	void		*pSig,					// [IN] buffer where the signature will be write to
	ULONG		*pcbCount)				// [OUT] optional, count of bytes that write to pSig
{
	BYTE const	*pszSig = reinterpret_cast<BYTE const*>(pSig);
	ULONG		cIndirection;
	ULONG		cb, cbTotal = 0;
	RID			rid;

	_ASSERTE(pcbCount);
	*pcbCount = 0;

	// not holding all of the information
	if (pEType->corEType == ELEMENT_TYPE_ARRAY || pEType->corEType == ELEMENT_TYPE_SZARRAY)
	{
		_ASSERTE(!"bad type");
		return S_FALSE;
	}

	// bad type in corEType...
	if (pEType->corEType == ELEMENT_TYPE_PTR || pEType->corEType == ELEMENT_TYPE_BYREF)
	{
		_ASSERTE(!"bad corEType!");
		return E_FAIL;
	}

	if (pEType->dwFlags & CorSigElementTypeByRef)
	{
		cb = CorSigCompressElementType(ELEMENT_TYPE_BYREF, (void *)&pszSig[cbTotal]);
		cbTotal += cb;
	}
	cIndirection = pEType->cIndirection;
	while (cIndirection--)
	{
		cb = CorSigCompressElementType(ELEMENT_TYPE_PTR, (void *)&pszSig[cbTotal]);
		cbTotal += cb;
	}
	cb = CorSigCompressElementType(pEType->corEType, (void *)&pszSig[cbTotal]);
	cbTotal += cb;

	if (pEType->corEType == ELEMENT_TYPE_VALUETYPE || pEType->corEType == ELEMENT_TYPE_CLASS)
	{
		rid = (ULONG)pEType->typeref;

		_ASSERTE(TypeFromToken(rid) == mdtTypeRef || TypeFromToken(rid) == mdtTypeDef);
		
		cb = CorSigCompressToken(rid, (ULONG *)&pszSig[cbTotal]);
		cbTotal += cb;
	}

	if (pcbCount)
		*pcbCount = cbTotal;
	return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
//
// resolve a signature to an CorETypeStruct
//
///////////////////////////////////////////////////////////////////////////////
BOOL ResolveTextSigToSimpleEType(		// return FALSE if bad signature
	LPCUTF8		*ppwzSig,				// [IN|OUT] pointing to the signature
	CorSimpleETypeStruct *pEType,		// [OUT] struct to fill after parsing an arg or a ret type
	ULONG		*pcDims,				// [OUT] count of '[' found
	BOOL		fAllowVoid)				// [IN] allow void or not
{
	DWORD		dwDimension = 0;
	LPCUTF8		pwzSig = *ppwzSig;

	// output parameter should not be NULL
	_ASSERTE(pEType && pcDims);
	memset(pEType, 0, sizeof(CorSimpleETypeStruct));

    if (*pwzSig == '&') 
	{
		pEType->dwFlags |=  CorSigElementTypeByRef;
		pwzSig++;
	}
	
    while (*pwzSig == '*') 
	{
		pEType->dwFlags |=  CorSigElementTypePtr;
		pEType->cIndirection++;
		pwzSig++;
	}
	
    while (*pwzSig == '[')
    {
        dwDimension++;
        pwzSig++;
    }

    switch (*pwzSig++)
    {
        default:
        {
            return FALSE;
        }

        case 'R':
        {
			pEType->corEType = ELEMENT_TYPE_TYPEDBYREF;
            break;
        }

        case 'I':
        {
			pEType->corEType = ELEMENT_TYPE_I4;
            break;
        }

        case 'J':
        {
			pEType->corEType = ELEMENT_TYPE_I8;
            break;
        }

        case 'F':			// float
        {
			pEType->corEType = ELEMENT_TYPE_R4;
            break;
        }

        case 'D':			// double
        {
			pEType->corEType = ELEMENT_TYPE_R8;
            break;
        }

        case 'C':			// two byte unsigned unicode char
        {
			pEType->corEType = ELEMENT_TYPE_CHAR;
            break;
        }

        case 'S':			// signed short
        {
			pEType->corEType = ELEMENT_TYPE_I2;
            break;
        }

        case 'Z':			// boolean
		{
			pEType->corEType = ELEMENT_TYPE_BOOLEAN;
			break;
		}
        case 'B':			// Unsigned BYTE
        {
			pEType->corEType = ELEMENT_TYPE_U1;
			break;
        }

        case 'Y':          // Signed Byte
        { 
			pEType->corEType = ELEMENT_TYPE_I1;
			break;
        }

        case 'P':          // Platform dependent int (32 or 64 bits).
        { 
			pEType->corEType = ELEMENT_TYPE_I;
			break;
        }

        case 'V':
        {
            if (fAllowVoid == FALSE)
                return FALSE;

            // can't have an array of voids
            if (dwDimension > 0)
                return FALSE;

			pEType->corEType = ELEMENT_TYPE_VOID;
            break;
        }

        case 'L':
        {
			pEType->corEType = ELEMENT_TYPE_CLASS;
			break;
        }

        case 'i':
        {
            pEType->corEType = ELEMENT_TYPE_I;
            break;
        }

        case 'l':
        {
			pEType->corEType = ELEMENT_TYPE_VALUETYPE;
			break;
        }
    }

	*pcDims = dwDimension;
    *ppwzSig = pwzSig;
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// resolve a signature to an CorETypeStruct
//
///////////////////////////////////////////////////////////////////////////////
BOOL BJResolveTextSigToSimpleEType(		// return FALSE if bad signature
	LPCUTF8		*ppwzSig,				// [IN|OUT] pointing to the signature
	CorSimpleETypeStruct *pEType,		// [OUT] struct to fill after parsing an arg or a ret type
	ULONG		*pcDims,				// [OUT] count of '[' found
	BOOL		fAllowVoid)				// [IN] allow void or not
{
	DWORD		dwDimension = 0;
	LPCUTF8		pwzSig = *ppwzSig;

	// output parameter should not be NULL
	_ASSERTE(pEType && pcDims);
	memset(pEType, 0, sizeof(CorSimpleETypeStruct));

    if (*pwzSig == '&') 
	{
		pEType->dwFlags |=  CorSigElementTypeByRef;
		pwzSig++;
	}
	
    while (*pwzSig == '*') 
	{
		pEType->dwFlags |=  CorSigElementTypePtr;
		pEType->cIndirection++;
		pwzSig++;
	}
	
    while (*pwzSig == '[')
    {
        dwDimension++;
        pwzSig++;
    }

    switch (*pwzSig++)
    {
        default:
        {
            return FALSE;
        }

        case 'R':
        {
			pEType->corEType = ELEMENT_TYPE_TYPEDBYREF;
            break;
        }

        case 'I':
        {
			pEType->corEType = ELEMENT_TYPE_I4;
            break;
        }

        case 'J':
        {
			pEType->corEType = ELEMENT_TYPE_I8;
            break;
        }

        case 'F':			// float
        {
			pEType->corEType = ELEMENT_TYPE_R4;
            break;
        }

        case 'D':			// double
        {
			pEType->corEType = ELEMENT_TYPE_R8;
            break;
        }

        case 'C':			// two byte unsigned unicode char
        {
			pEType->corEType = ELEMENT_TYPE_CHAR;
            break;
        }

        case 'S':			// signed short
        {
			pEType->corEType = ELEMENT_TYPE_I2;
            break;
        }

        case 'Z':			// boolean
		{
			pEType->corEType = ELEMENT_TYPE_BOOLEAN;
			break;
		}
        case 'B':			// signed BYTE
        {
			pEType->corEType = ELEMENT_TYPE_I1;
			break;
        }

        case 'V':
        {
            if (fAllowVoid == FALSE)
                return FALSE;

            // can't have an array of voids
            if (dwDimension > 0)
                return FALSE;

			pEType->corEType = ELEMENT_TYPE_VOID;
            break;
        }

        case 'L':
        {
			pEType->corEType = ELEMENT_TYPE_CLASS;
			break;
        }

        case 'l':
        {
			pEType->corEType = ELEMENT_TYPE_VALUETYPE;
			break;
        }
    }

	*pcDims = dwDimension;
    *ppwzSig = pwzSig;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// return number of bytes for a class name embedded in a text signature. 
// copy the class name into buffer if caller wants it.
//
///////////////////////////////////////////////////////////////////////////////
BOOL ExtractClassNameFromTextSig(		// return FALSE if bad signature
	LPCUTF8		*ppSrc,					// [IN|OUT] text signature. On exit, *ppSrc will skip over the class name including ";"
	CQuickBytes *pqbClassName,			// [IN|OUT] buffer to hold class name
	ULONG		*pcbBuffer)				// [OUT] count of bytes for the class name
{
    LPCUTF8		pSrc = *ppSrc;
    DWORD		i = 0;
	BYTE		*prgBuffer;
	HRESULT		hr = NOERROR;

	// ensure buffer is big enough
    while (*pSrc != '\0' && *pSrc != ';')
    {
		pSrc++;
		i++;
	}
	if (*pSrc != ';')
		return FALSE;

	if (pqbClassName) 
	{
		// copy only if caller wants it

		// make room for NULL terminating
		IfFailRet(pqbClassName->ReSize(i + 1));
		prgBuffer = (BYTE *)pqbClassName->Ptr();

		// now copy class name copy 
		memcpy(prgBuffer, *ppSrc, i);

		// NULL terminate the output
		prgBuffer[i++] = '\0';
	}

    *ppSrc = pSrc+1;
	*pcbBuffer = i;
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// count args in a text siganture
//
///////////////////////////////////////////////////////////////////////////////
DWORD CountArgsInTextSignature(			// return number of arguments in a Text signature
	LPCUTF8		pwzSig)					// [IN] text signature
{
    DWORD count = 0;

    if (*pwzSig++ != '(')
        return FALSE;

    while (*pwzSig != ')')
    {
        switch (*pwzSig++)
        {
            case 'R':
            case 'D':
            case 'F':
            case 'J':
            case 'I':
            case 'i':
            case 'Z':
            case 'S':
            case 'C':
			case 'B':
			case 'Y':
			case 'P':
            {
                count++;
                break;
            }

            case 'l':
            case 'L':
            {
                LPCUTF8 pSrc = pwzSig;

                pwzSig = strchr(pwzSig, ';');
                if (pwzSig == NULL)
                    return 0xFFFFFFFF;

                pwzSig++;
                count++;
                break;
            }

            case L'&':
            case L'*':
            case L'[':
                break;

            default:
            case L'V':
            {
                return 0xFFFFFFFF;
            }
        }
    }

    return count;
}


//=============================================================================
// CeeCallSignature
//=============================================================================

CeeCallSignature::CeeCallSignature(unsigned numArgs)
{
	_numArgs = numArgs; // We'll eventually add 3 for call conv, ret value & end code
	_curPosNibble = 1; // return value starts at nibble 1 
	_signature = new UCHAR[calcNumBytes(_numArgs)];
	assert(_signature);
	memset(_signature, '\0', calcNumBytes(_numArgs));
}

CeeCallSignature::~CeeCallSignature()
{
    delete _signature;
}

HRESULT CeeCallSignature::addArg(UCHAR argType, unsigned structSize)
{
	return addType(argType, structSize, false);
}

HRESULT CeeCallSignature::
		addType(UCHAR argType, unsigned structSize, bool returnType)
{
	_ASSERTE(_curPosNibble <= _numArgs);
	_ASSERTE(returnType || _curPosNibble > 1); // must set ret type before arg

	UCHAR *byteOffset = _signature + _curPosNibble/2;
	if (_curPosNibble%2) 
		// currently in the middle of a byte
		setMost(byteOffset, argType);
	else
		setLeast(byteOffset, argType);
	++_curPosNibble;

	if (! structSize)
		return S_OK;

	if (argType == IMAGE_CEE_CS_STRUCT4) {
		_ASSERTE(structSize <= 15);
		addArg(structSize, 0);
	} else if (argType == IMAGE_CEE_CS_STRUCT32 || argType == IMAGE_CEE_CS_BYVALUE) {
		if (_curPosNibble%2) {
			HRESULT hr = addArg(0, 0);	// pad so integer is on byte boundary
			TESTANDRETURNHR(hr);
		}
		byteOffset = _signature + _curPosNibble/2;
		*(unsigned *)byteOffset = structSize;
		_curPosNibble += 2*sizeof(structSize);
	}
	return S_OK;
}



#endif // !COMPLUS98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\posterror.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Errors.cpp
//
// This module contains the error handling/posting code for the engine.  It
// is assumed that all methods may be called by a dispatch client, and therefore
// errors are always posted using IErrorInfo.  Additional support is given
// for posting OLE DB errors when required.
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#include <UtilCode.h>                   // Utility helpers.
#include <CorError.h>
#include "..\\dlls\\mscorrc\\resource.h"


#include <PostError.h>

#define FORMAT_MESSAGE_LENGTH       1024
#if !defined(lengthof)
#define lengthof(x) (sizeof(x)/sizeof(x[0]))
#endif

// Global variables.
extern DWORD    g_iTlsIndex=0xffffffff; // Index for this process for thread local storage.

// Local prototypes.
HRESULT FillErrorInfo(LPCWSTR szMsg, DWORD dwHelpContext);

//********** Code. ************************************************************

CCompRC         g_ResourceDll;          // Used for all clients in process.

//*****************************************************************************
// Function that we'll expose to the outside world to fire off the shutdown method
//*****************************************************************************
#ifdef SHOULD_WE_CLEANUP
void ShutdownCompRC()
{
    g_ResourceDll.Shutdown();
}
#endif /* SHOULD_WE_CLEANUP */

void GetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME* fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID* fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME* fpGetThreadUICultureParentName
)
{
    g_ResourceDll.GetResourceCultureCallbacks(
        fpGetThreadUICultureName, 
        fpGetThreadUICultureId,
        fpGetThreadUICultureParentName
    );
}
//*****************************************************************************
// Set callbacks to get culture info
//*****************************************************************************
void SetResourceCultureCallbacks(
    FPGETTHREADUICULTURENAME fpGetThreadUICultureName,
    FPGETTHREADUICULTUREID fpGetThreadUICultureId,
    FPGETTHREADUICULTUREPARENTNAME fpGetThreadUICultureParentName
)
{
// Either both are NULL or neither are NULL
    _ASSERTE((fpGetThreadUICultureName != NULL) == 
        (fpGetThreadUICultureId != NULL));

    g_ResourceDll.SetResourceCultureCallbacks(
        fpGetThreadUICultureName, 
        fpGetThreadUICultureId,
        fpGetThreadUICultureParentName
    );

}

//*****************************************************************************
// Public function to load a resource string
//*****************************************************************************
HRESULT LoadStringRC(
    UINT iResourceID, 
    LPWSTR szBuffer, 
    int iMax, 
    int bQuiet
)
{
    return (g_ResourceDll.LoadString(iResourceID, szBuffer, iMax, bQuiet));
}

//*****************************************************************************
// Call at DLL startup to init the error system.
//*****************************************************************************
void InitErrors(DWORD *piTlsIndex)
{
    // Allocate a tls index for this process.
    if (g_iTlsIndex == 0xffffffff)
        VERIFY((g_iTlsIndex = TlsAlloc()) != 0xffffffff);

    // Give index to caller if they want it.
    if (piTlsIndex)
        *piTlsIndex = g_iTlsIndex;
}


//*****************************************************************************
// Call at DLL shutdown to free TLS.
//*****************************************************************************
void UninitErrors()
{
    if (g_iTlsIndex != 0xffffffff)
    {
        TlsFree(g_iTlsIndex);
        g_iTlsIndex = 0xffffffff;
    }
}

//*****************************************************************************
// Format a Runtime Error message.
//*****************************************************************************
HRESULT _cdecl FormatRuntimeErrorVa(        
    WCHAR       *rcMsg,                 // Buffer into which to format.         
    ULONG       cchMsg,                 // Size of buffer, characters.          
    HRESULT     hrRpt,                  // The HR to report.                    
    va_list     marker)                 // Optional args.                       
{
    WCHAR       rcBuf[512];             // Resource string.
    HRESULT     hr;
    
    // Ensure nul termination.
    *rcMsg = L'\0';

    // If this is one of our errors, then grab the error from the rc file.
    if (HRESULT_FACILITY(hrRpt) == FACILITY_URT)
    {
        hr = LoadStringRC(LOWORD(hrRpt), rcBuf, NumItems(rcBuf), true);
        if (hr == S_OK)
        {
            _vsnwprintf(rcMsg, cchMsg, rcBuf, marker);
            rcMsg[cchMsg - 1] = 0;
        }
    }
    // Otherwise it isn't one of ours, so we need to see if the system can
    // find the text for it.
    else
    {
        if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                rcMsg, cchMsg, 0/*@todo: marker*/))
        {
            hr = S_OK;

            // System messages contain a trailing \r\n, which we don't want normally.
            int iLen = lstrlenW(rcMsg);
            if (iLen > 3 && rcMsg[iLen - 2] == '\r' && rcMsg[iLen - 1] == '\n')
                rcMsg[iLen - 2] = '\0';
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // If we failed to find the message anywhere, then issue a hard coded message.
    if (FAILED(hr))
    {
        swprintf(rcMsg, L"Common Language Runtime Internal error: 0x%08x", hrRpt);
        DEBUG_STMT(DbgWriteEx(rcMsg));
    }

    return hrRpt;    
}

//*****************************************************************************
// Format a Runtime Error message, varargs.
//*****************************************************************************
HRESULT _cdecl FormatRuntimeError(
    WCHAR       *rcMsg,                 // Buffer into which to format.
    ULONG       cchMsg,                 // Size of buffer, characters.
    HRESULT     hrRpt,                  // The HR to report.
    ...)                                // Optional args.
{
    va_list     marker;                 // User text.
    va_start(marker, hrRpt);
    hrRpt = FormatRuntimeErrorVa(rcMsg, cchMsg, hrRpt, marker);
    va_end(marker);
    return hrRpt;
}

//*****************************************************************************
// This function will post an error for the client.  If the LOWORD(hrRpt) can
// be found as a valid error message, then it is loaded and formatted with
// the arguments passed in.  If it cannot be found, then the error is checked
// against FormatMessage to see if it is a system error.  System errors are
// not formatted so no add'l parameters are required.  If any errors in this
// process occur, hrRpt is returned for the client with no error posted.
//*****************************************************************************
HRESULT _cdecl PostError(               // Returned error.
    HRESULT     hrRpt,                  // Reported error.
    ...)                                // Error arguments.
{
    WCHAR       rcMsg[512];             // Error message.
    va_list     marker;                 // User text.
    long        *pcRef;                 // Ref count in tls.
    HRESULT     hr;

    // Return warnings without text.
    if (!FAILED(hrRpt))
        return (hrRpt);

    // Format the error.
    va_start(marker, hrRpt);
    FormatRuntimeErrorVa(rcMsg, lengthof(rcMsg), hrRpt, marker);
    va_end(marker);
    
    // Check for an old message and clear it.  Our public entry points do not do
    // a SetErrorInfo(0, 0) because it takes too long.
    IErrorInfo  *pIErrInfo;
    if (GetErrorInfo(0, &pIErrInfo) == S_OK)
        pIErrInfo->Release();

    // Turn the error into a posted error message.  If this fails, we still
    // return the original error message since a message caused by our error
    // handling system isn't going to give you a clue about the original error.
    VERIFY((hr = FillErrorInfo(rcMsg, LOWORD(hrRpt))) == S_OK);

    // Indicate in tls that an error occured.
    if ((pcRef = (long *) TlsGetValue(g_iTlsIndex)) != 0)
        *pcRef |= 0x80000000;
    return (hrRpt);
}


//*****************************************************************************
// Create, fill out and set an error info object.  Note that this does not fill
// out the IID for the error object; that is done elsewhere.
//*****************************************************************************
HRESULT FillErrorInfo(                  // Return status.
    LPCWSTR     szMsg,                  // Error message.
    DWORD       dwHelpContext)          // Help context.
{
    CComPtr<ICreateErrorInfo> pICreateErr;// Error info creation Iface pointer.
    CComPtr<IErrorInfo> pIErrInfo;      // The IErrorInfo interface.
    HRESULT     hr;                     // Return status.

    // Get the ICreateErrorInfo pointer.
    if (FAILED(hr = CreateErrorInfo(&pICreateErr)))
        return (hr);

    // Set message text description.
    if (FAILED(hr = pICreateErr->SetDescription((LPWSTR) szMsg)))
        return (hr);

    // Set the help file and help context.
//@todo: we don't have a help file yet.
    if (FAILED(hr = pICreateErr->SetHelpFile(L"complib.hlp")) ||
        FAILED(hr = pICreateErr->SetHelpContext(dwHelpContext)))
        return (hr);

    // Get the IErrorInfo pointer.
    if (FAILED(hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PVOID *) &pIErrInfo)))
        return (hr);

    // Save the error and release our local pointers.
    SetErrorInfo(0L, pIErrInfo);
    return (S_OK);
}

//*****************************************************************************
// Diplays a message box with details about error if client  
// error mode is set to see such messages; otherwise does nothing. 
//*****************************************************************************
void DisplayError(HRESULT hr, LPWSTR message, UINT nMsgType)
{
    WCHAR   rcMsg[FORMAT_MESSAGE_LENGTH];       // Error message to display
    WCHAR   rcTemplate[FORMAT_MESSAGE_LENGTH];  // Error message template from resource file
    WCHAR   rcTitle[24];        // Message box title

    // Retrieve error mode
    UINT last = SetErrorMode(0);
    SetErrorMode(last);         //set back to previous value
                    
    // Display message box if appropriate
    if(last & SEM_FAILCRITICALERRORS)
        return;
    
    //Format error message
    LoadStringRC(IDS_EE_ERRORTITLE, rcTitle, NumItems(rcTitle), true);
    LoadStringRC(IDS_EE_ERRORMESSAGETEMPLATE, rcTemplate, NumItems(rcTemplate), true);

    _snwprintf(rcMsg, FORMAT_MESSAGE_LENGTH, rcTemplate, hr, message);
    WszMessageBoxInternal(NULL, rcMsg, rcTitle , nMsgType);
}

//
//
// SSAutoEnter
//
//

//*****************************************************************************
// Update the iid and progid for a posted error.
//*****************************************************************************
void SSAutoEnter::UpdateError()
{
    IErrorInfo  *pIErrInfo;             // Error info object.
    ICreateErrorInfo *pICreateErr;      // Error info creation Iface pointer.

    _ASSERTE(*(long *) TlsGetValue(g_iTlsIndex) == 0);

    // If there was an error, set the interface ID and prog id.
    //@todo: this doesn't handle the case where this entry point called
    // another which in turn posted an error.  This will override.  Now
    // this may be good for a client to know which entry point they called
    // that caused the error, but it doesn't tell us which one is really
    // in error.
    if (GetErrorInfo(0, &pIErrInfo) == S_OK)
    {
        if (pIErrInfo->QueryInterface(IID_ICreateErrorInfo,
                                        (PVOID *) &pICreateErr) == S_OK)
        {
            pICreateErr->SetGUID(*m_psIID);
            pICreateErr->SetSource((LPWSTR) m_szProgID);
            pICreateErr->Release();
        }
        SetErrorInfo(0, pIErrInfo);
        pIErrInfo->Release();
    }
}


//@todo: M2, this will leak 4 bytes per thread because we disable thread
// notifications in DllMain.  We probably need to clean this up since we
// are a service and in the IIS environment we'll fragment heap memory 
// if we are run 24x7.
long * SSAutoEnter::InitSSAutoEnterThread()
{
    long        *pcRef;

    VERIFY(pcRef = new long);
    if (pcRef) 
    {
        *pcRef = 0;
        VERIFY(TlsSetValue(g_iTlsIndex, pcRef));
    }
    return (pcRef);
}

int CorMessageBox(
                  HWND hWnd,        // Handle to Owner Window
                  UINT uText,       // Resource Identifier for Text message
                  UINT uCaption,    // Resource Identifier for Caption
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle, // Flag to show FileName in Caption
                  ...)              // Additional Arguments
{
    //Assert if none of MB_ICON is set
    _ASSERTE((uType & MB_ICONMASK) != 0);

    int result = IDCANCEL;
    WCHAR   *rcMsg = new WCHAR[FORMAT_MESSAGE_LENGTH];      // Error message to display
    WCHAR   *rcCaption = new WCHAR[FORMAT_MESSAGE_LENGTH];      // Message box title

    if (!rcMsg || !rcCaption)
            goto exit1;

    //Load the resources using resource IDs
    if (SUCCEEDED(LoadStringRC(uCaption, rcCaption, FORMAT_MESSAGE_LENGTH, true)) &&  
        SUCCEEDED(LoadStringRC(uText, rcMsg, FORMAT_MESSAGE_LENGTH, true)))
    {
        WCHAR *rcFormattedMessage = new WCHAR[FORMAT_MESSAGE_LENGTH];
        WCHAR *rcFormattedTitle = new WCHAR[FORMAT_MESSAGE_LENGTH];
        WCHAR *fileName = new WCHAR[MAX_PATH];

        if (!rcFormattedMessage || !rcFormattedTitle || !fileName)
            goto exit;
        
        //Format message string using optional parameters
        va_list     marker;
        va_start(marker, ShowFileNameInTitle);
        vswprintf(rcFormattedMessage, rcMsg, marker);

        //Try to get filename of Module and add it to title
        if (ShowFileNameInTitle && WszGetModuleFileName(NULL, fileName, MAX_PATH))
        {
            LPWSTR name = new WCHAR[wcslen(fileName) + 1];
            LPWSTR ext = new WCHAR[wcslen(fileName) + 1];
        
            SplitPath(fileName, NULL, NULL, name, ext);     //Split path so that we discard the full path

            swprintf(rcFormattedTitle,
                     L"%s%s - %s",
                     name, ext, rcCaption);
            if(name)
                delete [] name;
            if(ext)
                delete [] ext;
        }
        else
        {
            wcscpy(rcFormattedTitle, rcCaption);
        }
        result = WszMessageBoxInternal(hWnd, rcFormattedMessage, rcFormattedTitle, uType);
exit:
        if (rcFormattedMessage)
            delete [] rcFormattedMessage;
        if (rcFormattedTitle)
            delete [] rcFormattedTitle;
        if (fileName)
            delete [] fileName;
    }
    else
    {
        //This means that Resources cannot be loaded.. show an appropriate error message. 
        result = WszMessageBoxInternal(NULL, L"Failed to load resources from resource file\nPlease check your Setup", L"Setup Error", MB_OK | MB_ICONSTOP); 
    }

exit1:
    if (rcMsg)
        delete [] rcMsg;
    if (rcCaption)
        delete [] rcCaption;
    return result;
}


int CorMessageBoxCatastrophic(
                  HWND hWnd,        // Handle to Owner Window
                  UINT iText,       // Text for MessageBox
                  UINT iTitle,      // Title for MessageBox
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle) // Flag to show FileName in Caption
{
    WCHAR wszText[500];
    WCHAR wszTitle[500];

    HRESULT hr;

    hr = LoadStringRC(iText,
                      wszText,
                      sizeof(wszText)/sizeof(wszText[0]),
                      FALSE);
    if (FAILED(hr)) {
        wszText[0] = L'?';
        wszText[1] = L'\0';
    }

    hr = LoadStringRC(iTitle,
                      wszTitle,
                      sizeof(wszTitle)/sizeof(wszTitle[0]),
                      FALSE);
    if (FAILED(hr)) {
        wszTitle[0] = L'?';
        wszTitle[1] = L'\0';
    }

    return CorMessageBoxCatastrophic(
            hWnd, wszText, wszTitle, uType, ShowFileNameInTitle );
}


int CorMessageBoxCatastrophic(
                  HWND hWnd,        // Handle to Owner Window
                  LPWSTR lpText,    // Text for MessageBox
                  LPWSTR lpTitle,   // Title for MessageBox
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle, // Flag to show FileName in Caption
                  ...)
{
    _ASSERTE((uType & MB_ICONMASK) != 0);

    WCHAR rcFormattedMessage[FORMAT_MESSAGE_LENGTH];
    WCHAR rcFormattedTitle[FORMAT_MESSAGE_LENGTH];
    WCHAR fileName[MAX_PATH];

    //Format message string using optional parameters
    va_list     marker;
    va_start(marker, uType);
    vswprintf(rcFormattedMessage, lpText, marker);

    //Try to get filename of Module and add it to title
    if (ShowFileNameInTitle && WszGetModuleFileName(NULL, fileName, MAX_PATH)){
        LPWSTR name = new WCHAR[wcslen(fileName) + 1];
        LPWSTR ext = new WCHAR[wcslen(fileName) + 1];
        
        SplitPath(fileName, NULL, NULL, name, ext); //Split path so that we discard the full path

        swprintf(rcFormattedTitle,
                 L"%s%s - %s",
                 name, ext, lpTitle);
        if(name)
            delete [] name;
        if(ext)
            delete [] ext;
    }
    else{
        wcscpy(rcFormattedTitle, lpTitle);
    }
    return WszMessageBoxInternal(hWnd, rcFormattedMessage, rcFormattedTitle, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <CrtWrap.h>

#define IN_WINFIX_CPP 

#include <WinWrap.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\splitpat.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*splitpath.c - break down path name into components
*
*Purpose:
*       To provide support for accessing the individual components of an
*       arbitrary path name
*
*******************************************************************************/
#include "stdafx.h"
#include "WinWrap.h"


/***
*_splitpath() - split a path name into its individual components
*
*Purpose:
*       to split a path name into its individual components
*
*Entry:
*       path  - pointer to path name to be parsed
*       drive - pointer to buffer for drive component, if any
*       dir   - pointer to buffer for subdirectory component, if any
*       fname - pointer to buffer for file base name component, if any
*       ext   - pointer to buffer for file name extension component, if any
*
*Exit:
*       drive - pointer to drive string.  Includes ':' if a drive was given.
*       dir   - pointer to subdirectory string.  Includes leading and trailing
*           '/' or '\', if any.
*       fname - pointer to file base name
*       ext   - pointer to file extension, if any.  Includes leading '.'.
*
*Exceptions:
*
*******************************************************************************/

void SplitPath (
        register const WCHAR *path,
        WCHAR *drive,
        WCHAR *dir,
        WCHAR *fname,
        WCHAR *ext
        )
{
        register WCHAR *p;
        WCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((_tcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == _T(':'))) {
            if (drive) {
                _tcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = _T('\0');
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = _T('\0');
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (WCHAR *)path; *p; p++) {
#ifdef _MBCS
            if (_ISLEADBYTE (*p))
                p++;
            else {
#endif  /* _MBCS */
            if (*p == _T('/') || *p == _T('\\'))
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == _T('.'))
                dot = p;
#ifdef _MBCS
            }
#endif  /* _MBCS */
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = __min((unsigned)(((char *)last_slash - (char *)path) / sizeof(WCHAR)),
                    (unsigned)(_MAX_DIR - 1));
                _tcsncpy(dir, path, len);
                *(dir + len) = _T('\0');
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = _T('\0');
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = __min((unsigned)(((char *)dot - (char *)path) / sizeof(WCHAR)),
                    (unsigned)(_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = __min((unsigned)(((char *)p - (char *)dot) / sizeof(WCHAR)),
                    (unsigned)(_MAX_EXT - 1));
                _tcsncpy(ext, dot, len);
                *(ext + len) = _T('\0');
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = __min((unsigned)(((char *)p - (char *)path) / sizeof(WCHAR)),
                    (unsigned)(_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            if (ext) {
                *ext = _T('\0');
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stacktrace.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------- 
// Microsoft Confidential 
// robch@microsoft.com
//----------------------------------------------------------------------------- 

#include "stdafx.h"
#include "StackTrace.h"
#include <imagehlp.h>

HINSTANCE LoadImageHlp()
{
    HINSTANCE hmodule = NULL;
    HMODULE hmod = WszGetModuleHandle(L"mscorwks.dll");
    if (hmod == NULL) {
        hmod = WszGetModuleHandle(L"mscorsvr.dll");
    }
    if (hmod) {
        WCHAR filename[MAX_PATH+12+10+1] = L"\0"; // for "imagehlp.dll" "int_tools\"

        if (WszGetModuleFileName(hmod,filename,MAX_PATH))
        {
            WCHAR *pt = wcsrchr (filename, L'\\');
            if (pt) {
                pt ++;
                wcscpy (pt, L"imagehlp.dll");
                hmodule = WszLoadLibrary(filename);
                if (hmodule == NULL) {
                    wcscpy (pt, L"int_tools\\imagehlp.dll");
                    hmodule = WszLoadLibrary(filename);
                }
            }
        }
    }

    if (hmodule == NULL) {
        hmodule = LoadLibraryA("imagehlp.dll");
    }
    return hmodule;
}

// @TODO_IA64: all of this stack trace stuff is pretty much broken on 64-bit
// right now because this code doesn't use the new SymXxxx64 functions.

#ifdef _DEBUG

#define LOCAL_ASSERT(x)
//
//--- Macros ------------------------------------------------------------------
//

#define COUNT_OF(x)    (sizeof(x) / sizeof(x[0]))

//
// Types and Constants --------------------------------------------------------
//

char g_szExprWithStack[TRACE_BUFF_SIZE];
int g_BufferLock = -1;

struct SYM_INFO
{
    DWORD       dwOffset;
    char        achModule[cchMaxAssertModuleLen];
    char        achSymbol[cchMaxAssertSymbolLen];
};

//--- Function Pointers to APIs in IMAGEHLP.DLL. Loaded dynamically. ---------

typedef LPAPI_VERSION (__stdcall *pfnImgHlp_ImagehlpApiVersionEx)(
    LPAPI_VERSION AppVersion
    );

typedef BOOL (__stdcall *pfnImgHlp_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetModuleInfo)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    );

typedef LPVOID (__stdcall *pfnImgHlp_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetSymFromAddr)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PDWORD              pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    );

typedef BOOL (__stdcall *pfnImgHlp_SymInitialize)(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef BOOL (__stdcall *pfnImgHlp_SymUnDName)(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );

typedef BOOL (__stdcall *pfnImgHlp_SymLoadModule)(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );

struct IMGHLPFN_LOAD
{
    LPSTR   pszFnName;
    LPVOID * ppvfn;
};

//
// Globals --------------------------------------------------------------------
//

static BOOL      g_fLoadedImageHlp = FALSE;          // set to true on success
static BOOL      g_fLoadedImageHlpFailed = FALSE;    // set to true on failure
static HINSTANCE g_hinstImageHlp   = NULL;
static HANDLE    g_hProcess = NULL;

pfnImgHlp_ImagehlpApiVersionEx    _ImagehlpApiVersionEx;
pfnImgHlp_StackWalk               _StackWalk;
pfnImgHlp_SymGetModuleInfo        _SymGetModuleInfo;
pfnImgHlp_SymFunctionTableAccess  _SymFunctionTableAccess;
pfnImgHlp_SymGetSymFromAddr       _SymGetSymFromAddr;
pfnImgHlp_SymInitialize           _SymInitialize;
pfnImgHlp_SymUnDName              _SymUnDName;
pfnImgHlp_SymLoadModule           _SymLoadModule;

IMGHLPFN_LOAD ailFuncList[] =
{
    { "ImagehlpApiVersionEx",   (LPVOID*)&_ImagehlpApiVersionEx },
    { "StackWalk",              (LPVOID*)&_StackWalk },
    { "SymGetModuleInfo",       (LPVOID*)&_SymGetModuleInfo },
    { "SymFunctionTableAccess", (LPVOID*)&_SymFunctionTableAccess },
    { "SymGetSymFromAddr",      (LPVOID*)&_SymGetSymFromAddr },
    { "SymInitialize",          (LPVOID*)&_SymInitialize },
    { "SymUnDName",             (LPVOID*)&_SymUnDName },
    { "SymLoadModule",          (LPVOID*)&_SymLoadModule },
};

//
//--- Forward declarations ----------------------------------------------------
//

static void Dummy1();
static void Dummy2();

/****************************************************************************
* Dummy1 *
*--------*
*   Description:  
*       A placeholder function used to determine if addresses being retrieved
*       are for functions in this compilation unit or not.
*
*       WARNING!! This function must be the first function in this
*       compilation unit
******************************************************************** robch */
static void Dummy1()
{
}

/****************************************************************************
* IsWin95 *
*---------*
*   Description:  
*       Are we running on Win95 or not. Some of the logic contained here
*       differs on Windows 9x.
*
*   Return:
*   TRUE - If we're running on a Win 9x platform
*   FALSE - If we're running on a non-Win 9x platform
******************************************************************** robch */
static BOOL IsWin95()
{
    return GetVersion() & 0x80000000;
}

/****************************************************************************
* MagicInit *
*-----------*
*   Description:  
*       Initializes the symbol loading code. Currently called (if necessary)
*       at the beginning of each method that might need ImageHelp to be
*       loaded.
******************************************************************** robch */
void MagicInit()
{
    if (g_fLoadedImageHlp || g_fLoadedImageHlpFailed)
    {
        return;
    }

    g_hProcess = GetCurrentProcess();
    
    //
    // Try to load imagehlp.dll
    //
    if (g_hinstImageHlp == NULL) {
        g_hinstImageHlp = LoadImageHlp();
    }
    LOCAL_ASSERT(g_hinstImageHlp);

    if (NULL == g_hinstImageHlp)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    //
    // Try to get the API entrypoints in imagehlp.dll
    //
    for (int i = 0; i < COUNT_OF(ailFuncList); i++)
    {
        *(ailFuncList[i].ppvfn) = GetProcAddress(
                g_hinstImageHlp, 
                ailFuncList[i].pszFnName);
        LOCAL_ASSERT(*(ailFuncList[i].ppvfn));
        
        if (!*(ailFuncList[i].ppvfn))
        {
            g_fLoadedImageHlpFailed = TRUE;
            return;
        }
    }

    API_VERSION AppVersion = { 4, 0, API_VERSION_NUMBER, 0 };
    LPAPI_VERSION papiver = _ImagehlpApiVersionEx(&AppVersion);

    //
    // We assume any version 4 or greater is OK.
    //
    LOCAL_ASSERT(papiver->Revision >= 4);
    if (papiver->Revision < 4)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    g_fLoadedImageHlp = TRUE;
    
    //
    // Initialize imagehlp.dll
    //
    _SymInitialize(g_hProcess, NULL, /*FALSE*/ TRUE);

    return;
}


/****************************************************************************
* FillSymbolInfo *
*----------------*
*   Description:  
*       Fills in a SYM_INFO structure
******************************************************************** robch */
void FillSymbolInfo
(
SYM_INFO *psi,
DWORD dwAddr
)
{
    if (!g_fLoadedImageHlp)
    {
        return;
    }

    LOCAL_ASSERT(psi);
    memset(psi, 0, sizeof(SYM_INFO));

    IMAGEHLP_MODULE  mi;
    mi.SizeOfStruct = sizeof(mi);
    
    if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
    {
        strncpy(psi->achModule, "<no module>", sizeof(psi->achModule)-1);
    }
    else
    {
        strncpy(psi->achModule, mi.ModuleName, sizeof(psi->achModule)-1);
        strupr(psi->achModule);
    }

    CHAR rgchUndec[256];
    CHAR * pszSymbol = NULL;

    // Name field of IMAGEHLP_SYMBOL is dynamically sized.
    // Pad with space for 255 characters.
    union
    {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddr;
        sym.MaxNameLength = 255;

        if (_SymGetSymFromAddr(g_hProcess, dwAddr, &psi->dwOffset, &sym))
        {
            pszSymbol = sym.Name;

            if (_SymUnDName(&sym, rgchUndec, COUNT_OF(rgchUndec)-1))
            {
                pszSymbol = rgchUndec;
            }
        }
        else
        {
            pszSymbol = "<no symbol>";
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";

        // @TODO_IA64: this cast is temporary and is just here
        // to fix the build until we fix this code the proper way.
        psi->dwOffset = (DWORD)(dwAddr - mi.BaseOfImage);
    }

    strncpy(psi->achSymbol, pszSymbol, COUNT_OF(psi->achSymbol)-1);
}

/****************************************************************************
* FunctionTableAccess *
*---------------------*
*   Description:  
*       Helper for imagehlp's StackWalk API.
******************************************************************** robch */
LPVOID __stdcall FunctionTableAccess
(
HANDLE hProcess,
DWORD dwPCAddr
)
{
    return _SymFunctionTableAccess( hProcess, dwPCAddr );
}

/****************************************************************************
* GetModuleBase *
*---------------*
*   Description:  
*       Helper for imagehlp's StackWalk API. Retrieves the base address of 
*       the module containing the giving virtual address.
*
*       NOTE: If the module information for the given module hasnot yet been
*       loaded, then it is loaded on this call.
*
*   Return:
*       Base virtual address where the module containing ReturnAddress is
*       loaded, or 0 if the address cannot be determined.
******************************************************************** robch */
DWORD __stdcall GetModuleBase
(
HANDLE hProcess,
DWORD dwAddr
)
{
    IMAGEHLP_MODULE ModuleInfo;
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
    
    if (_SymGetModuleInfo(hProcess, dwAddr, &ModuleInfo))
    {
        // @TODO_IA64: this cast is temporary and is just here
        // to fix the build until we fix this code the proper way.
        return (DWORD)ModuleInfo.BaseOfImage;       
    }
    else
    {
        MEMORY_BASIC_INFORMATION mbi;
        
        if (VirtualQueryEx(hProcess, (LPVOID)dwAddr, &mbi, sizeof(mbi)))
        {
            if (IsWin95() || (mbi.Type & MEM_IMAGE))
            {
                char achFile[MAX_PATH] = {0};
                DWORD cch;
                
                cch = GetModuleFileNameA(
                        (HINSTANCE)mbi.AllocationBase,
                        achFile,
                        MAX_PATH);

                // Ignore the return code since we can't do anything with it.
                _SymLoadModule(
                    hProcess,
                    NULL,
                    ((cch) ? achFile : NULL),
                    NULL,
                    (DWORD)mbi.AllocationBase,
                    0);

                return (DWORD)mbi.AllocationBase;
            }
        }
    }

    return 0;
}


/****************************************************************************
* GetStackBacktrace *
*-------------------*
*   Description:  
*       Gets a stacktrace of the current stack, including symbols.
*
*   Return:
*       The number of elements actually retrieved.
******************************************************************** robch */
UINT GetStackBacktrace
(
UINT ifrStart,          // How many stack elements to skip before starting.
UINT cfrTotal,          // How many elements to trace after starting.
DWORD *pdwEip,          // Array to be filled with stack addresses.
SYM_INFO *psiSymbols // This array is filled with symbol information.
                        // It should be big enough to hold cfrTotal elts.
                        // If NULL, no symbol information is stored.
)
{
    DWORD * pdw = pdwEip;
    SYM_INFO * psi = psiSymbols;

    MagicInit();

    memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

    if (psiSymbols)
    {
        memset(psiSymbols, 0, cfrTotal * sizeof(SYM_INFO));
    }

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;

#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif defined(_M_IA64)
        dwMachType              = IMAGE_FILE_MACHINE_IA64;
        stkfrm.AddrPC.Offset    = 0;    // @TODO_IA64: what's the right reg to put here?
#else
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace)
        ifrStart += 1;

        for (UINT i = 0; i < ifrStart + cfrTotal; i++)
        {
            // @TODO_IA64: The casts below are temporary and need
            // to be fixed the correct way ASAP
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            (PFUNCTION_TABLE_ACCESS_ROUTINE)FunctionTableAccess,
                            (PGET_MODULE_BASE_ROUTINE)GetModuleBase,
                            NULL))
            {
                break;
            }
            if (i >= ifrStart &&
                ((void*)stkfrm.AddrPC.Offset < (void*)Dummy1 ||
                (void*)stkfrm.AddrPC.Offset > (void*)Dummy2))
            {
                // @TODO_IA64: This cast is temporary and is only 
                // intended to fix the build until this code is
                // correctly fixed for 64 bit
                *pdw++ = (DWORD)stkfrm.AddrPC.Offset;

                if (psi)
                {
                    // @TODO_IA64: This cast is temporary and is only 
                    // intended to fix the build until this code is
                    // correctly fixed for 64 bit
                    FillSymbolInfo(psi++, (DWORD)stkfrm.AddrPC.Offset);
                }   
            }
        }
    }

    // @TODO_IA64: This cast is temporary and is only 
    // intended to fix the build until this code is
    // correctly fixed for 64 bit
    return (DWORD)(pdw - pdwEip);
}


/****************************************************************************
* GetStringFromSymbolInfo *
*-------------------------*
*   Description:  
*       Actually prints the info into the string for the symbol.
******************************************************************** robch */
void GetStringFromSymbolInfo
(
DWORD dwAddr,
SYM_INFO *psi,   // @parm Pointer to SYMBOL_INFO. Can be NULL.
CHAR *pszString     // @parm Place to put string.
)
{
    LOCAL_ASSERT(pszString);

    // <module>! <symbol> + 0x<offset> 0x<addr>\n

    if (psi)
    {
        wsprintfA(pszString,
                 "%s! %s + 0x%X (0x%08X)",
                 (psi->achModule[0]) ? psi->achModule : "<no module>",
                 (psi->achSymbol[0]) ? psi->achSymbol : "<no symbol>",
                 psi->dwOffset,
                 dwAddr);
    }
    else
    {
        wsprintfA(pszString, "<symbols not available> (0x%08X)", dwAddr);
    }

    LOCAL_ASSERT(strlen(pszString) < cchMaxAssertStackLevelStringLen);
}

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines
******************************************************************** robch */
void GetStringFromStackLevels
(
UINT ifrStart,      // @parm How many stack elements to skip before starting.
UINT cfrTotal,      // @parm How many elements to trace after starting.
                    //  Can't be more than cfrMaxAssertStackLevels.
CHAR *pszString     // @parm Place to put string.
                    //  Max size will be cchMaxAssertStackLevelStringLen * cfrTotal.
)
{
    LOCAL_ASSERT(pszString);
    LOCAL_ASSERT(cfrTotal < cfrMaxAssertStackLevels);

    *pszString = '\0';

    if (cfrTotal == 0)
    {
        return;
    }

    DWORD rgdwStackAddrs[cfrMaxAssertStackLevels];
    SYM_INFO rgsi[cfrMaxAssertStackLevels];

    // Ignore this function (GetStringFromStackLevels)
    ifrStart += 1;

    UINT uiRetrieved =
            GetStackBacktrace(ifrStart, cfrTotal, rgdwStackAddrs, rgsi);

    // First level
    CHAR aszLevel[cchMaxAssertStackLevelStringLen];
    GetStringFromSymbolInfo(rgdwStackAddrs[0], &rgsi[0], aszLevel);
    strcpy(pszString, aszLevel);

    // Additional levels
    for (UINT i = 1; i < uiRetrieved; ++i)
    {
        strcat(pszString, "\n");
        GetStringFromSymbolInfo(rgdwStackAddrs[i],
                        &rgsi[i], aszLevel);
        strcat(pszString, aszLevel);
    }

    LOCAL_ASSERT(strlen(pszString) <= cchMaxAssertStackLevelStringLen * cfrTotal);
}


/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address of the next instruction,
*       0 if there's an error.
******************************************************************** robch */
DWORD GetAddrFromStackLevel
(
UINT ifrStart       // How many stack elements to skip before starting.
)
{
    MagicInit();

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread  = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;
        
#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif defined(_M_IA64)
        dwMachType              = IMAGE_FILE_MACHINE_IA64;
        stkfrm.AddrPC.Offset    = 0;  // @TODO_IA64: what is the correct reg to put here?
#else
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace) and the one below
        ifrStart += 2;

        for (UINT i = 0; i < ifrStart; i++)
        {
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            (PFUNCTION_TABLE_ACCESS_ROUTINE)FunctionTableAccess,
                            (PGET_MODULE_BASE_ROUTINE)GetModuleBase,
                            NULL))
            {
                break;
            }
        }

        // @TODO_IA64: This cast is temporary and is only 
        // intended to fix the build until this code is
        // correctly fixed for 64 bit
        return (DWORD)stkfrm.AddrPC.Offset;
    }

    return 0;
}


/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Returns a string from an address.
******************************************************************** robch */
void GetStringFromAddr
(
DWORD dwAddr,
LPSTR szString // Place to put string.
                // Buffer must hold at least cchMaxAssertStackLevelStringLen.
)
{
    LOCAL_ASSERT(szString);

    SYM_INFO si;
    FillSymbolInfo(&si, dwAddr);

    wsprintfA(szString,
             "%s! %s + 0x%X (0x%08X)",
             (si.achModule[0]) ? si.achModule : "<no module>",
             (si.achSymbol[0]) ? si.achSymbol : "<no symbol>",
             si.dwOffset,
             dwAddr);
}

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before exit
*       to free the dynamically loaded imagehlp.dll.
******************************************************************** robch */
void MagicDeinit(void)
{
    if (g_hinstImageHlp)
    {
        FreeLibrary(g_hinstImageHlp);

        g_hinstImageHlp   = NULL;
        g_fLoadedImageHlp = FALSE;
    }
}

static void Dummy2()
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stgpool.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgPool.cpp
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
//*****************************************************************************
#include "stdafx.h"                     // Standard include.
#include <StgPool.h>                    // Our interface definitions.
#include <basetsd.h>					// For UINT_PTR typedef
#include <PostError.h>					// Error handling.

#if 0
//********** Internal helpers. ************************************************
HRESULT VariantWriteToStream(VARIANT *pVal, IStream* pStream);
HRESULT VariantReadFromStream(VARIANT *pVal, IStream* pStream);
#endif

#define MAX_CHAIN_LENGTH 20             // Max chain length before rehashing.

//
//
// StgPool
//
//


//*****************************************************************************
// Free any memory we allocated.
//*****************************************************************************
StgPool::~StgPool()
{
    Uninit();
} // StgPool::~StgPool()


//*****************************************************************************
// Init the pool for use.  This is called for both the create empty case.
//*****************************************************************************
HRESULT StgPool::InitNew(               // Return code.
	ULONG		cbSize,	    			// Estimated size.
	ULONG		cItems)				    // Estimated item count.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == m_zeros);
    _ASSERTE(m_pNextSeg == 0);
    _ASSERTE(m_pCurSeg == this);
    _ASSERTE(m_cbCurSegOffset == 0);
    _ASSERTE(m_cbSegSize == 0);
    _ASSERTE(m_cbSegNext == 0);

    m_bDirty = false;
    m_bReadOnly = false;
    m_bFree = false;

    return (S_OK);
} // HRESULT StgPool::InitNew()

//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
HRESULT StgPool::InitOnMem(             // Return code.
        void        *pData,             // Predefined data.
        ULONG       iSize,              // Size of data.
        int         bReadOnly)          // true if append is forbidden.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == m_zeros);
    _ASSERTE(m_pNextSeg == 0);
    _ASSERTE(m_pCurSeg == this);
    _ASSERTE(m_cbCurSegOffset == 0);

    // Create case requires no further action.
    if (!pData)
        return (E_INVALIDARG);

    // Might we be extending this heap?
    m_bReadOnly = bReadOnly;


    m_pSegData = reinterpret_cast<BYTE*>(pData);
    m_cbSegSize = iSize;
    m_cbSegNext = iSize;

    m_bFree = false;
    m_bDirty = false;

    return (S_OK);
} // HRESULT StgPool::InitOnMem()


//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
HRESULT StgPool::InitOnMemReadOnly(     // Return code.
        void        *pData,             // Predefined data.
        ULONG       iSize)              // Size of data.
{
	return InitOnMem(pData, iSize, true);	
} // HRESULT StgPool::InitOnMemReadOnly()

//*****************************************************************************
// Called when the pool must stop accessing memory passed to InitOnMem().
//*****************************************************************************
HRESULT StgPool::TakeOwnershipOfInitMem()
{
    // If the pool doesn't have a pointer to non-owned memory, done.
    if (m_bFree)
        return (S_OK);

    // If the pool doesn't have a pointer to memory at all, done.
    if (m_pSegData == m_zeros)
    {
        _ASSERTE(m_cbSegSize == 0);
        return (S_OK);
    }

    // Get some memory to keep.
    BYTE *pData = reinterpret_cast<BYTE*>(malloc(m_cbSegSize+4));
    if (pData == 0)
        return (PostError(OutOfMemory()));

    // Copy the old data to the new memory.
    memcpy(pData, m_pSegData, m_cbSegSize);
    m_pSegData = pData;
    m_bFree = true;

    return (S_OK);
} // HRESULT StgPool::TakeOwnershipOfInitMem()


//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
void StgPool::Uninit()
{
    // Free base segment, if appropriate.
    if (m_bFree && (m_pSegData != m_zeros))
	{
        free(m_pSegData);
		m_bFree = false;
	}

    // Free chain, if any.
    StgPoolSeg  *pSeg = m_pNextSeg;
    while (pSeg)
    {
        StgPoolSeg *pNext = pSeg->m_pNextSeg;
        free(pSeg);
        pSeg = pNext;
    }

    // Clear vars.
    m_pSegData = (BYTE*)m_zeros;
    m_cbSegSize = m_cbSegNext = 0;
    m_pNextSeg = 0;
    m_pCurSeg = this;
    m_cbCurSegOffset = 0;
    m_State = eNormal;
} // void StgPool::Uninit()

//*****************************************************************************
// Called to copy the pool to writable memory, reset the r/o bit.
//*****************************************************************************
HRESULT StgPool::ConvertToRW()
{
	HRESULT		hr;						// A result.
	IfFailRet(TakeOwnershipOfInitMem());

	IfFailRet(SetHash(true));

	m_bReadOnly = false;

	return S_OK;
} // HRESULT StgPool::ConvertToRW()

//*****************************************************************************
// Turn hashing off or on.  Real implementation as required in subclass.
//*****************************************************************************
HRESULT StgPool::SetHash(int bHash)
{
	return S_OK;
} // HRESULT StgPool::SetHash()

//*****************************************************************************
// Trim any empty final segment.
//*****************************************************************************
void StgPool::Trim()
{
	// If no chained segments, nothing to do.
	if (m_pNextSeg == 0)
		return;

    // Handle special case for a segment that was completely unused.
    if (m_pCurSeg->m_cbSegNext == 0)
    {
        // Find the segment which points to the empty segment.
        for (StgPoolSeg *pPrev = this; pPrev && pPrev->m_pNextSeg != m_pCurSeg; pPrev = pPrev->m_pNextSeg);
        _ASSERTE(pPrev && pPrev->m_pNextSeg == m_pCurSeg);

        // Free the empty segment.
        free(m_pCurSeg);
        
        // Fix the pCurSeg pointer.
        pPrev->m_pNextSeg = 0;
        m_pCurSeg = pPrev;

		// Adjust the base offset, because the PREVIOUS seg is now current.
		_ASSERTE(m_pCurSeg->m_cbSegNext <= m_cbCurSegOffset);
		m_cbCurSegOffset = m_cbCurSegOffset - m_pCurSeg->m_cbSegNext;
    }
} // void StgPool::Trim()

//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
bool StgPool::Grow(                     // true if successful.
    ULONG       iRequired)              // Min required bytes to allocate.
{
    ULONG       iNewSize;               // New size we want.
    StgPoolSeg  *pNew;                  // Temp pointer for malloc.

    _ASSERTE(!m_bReadOnly);

    // Would this put the pool over 2GB?
    if ((m_cbCurSegOffset + iRequired) > INT_MAX)
        return (false);

    // Adjust grow size as a ratio to avoid too many reallocs.
    if ((m_pCurSeg->m_cbSegNext + m_cbCurSegOffset) / m_ulGrowInc >= 3)
        m_ulGrowInc *= 2;

    // If first time, handle specially.
    if (m_pSegData == m_zeros)
    {
        // Allocate the buffer.
        iNewSize = max(m_ulGrowInc, iRequired);
        BYTE *pSegData = reinterpret_cast<BYTE*>(malloc(iNewSize+4));
        if (pSegData == 0)
            return (false);
        m_pSegData = pSegData;

        // Will need to delete it.
        m_bFree = true;

        // How big is this initial segment?
        m_cbSegSize = iNewSize;

        // Do some validation of var fields.
        _ASSERTE(m_cbSegNext == 0);
        _ASSERTE(m_pCurSeg == this);
        _ASSERTE(m_pNextSeg == 0);

        return (true);
    }

    // Allocate the new space enough for header + data.
    iNewSize = max(m_ulGrowInc, iRequired) + sizeof(StgPoolSeg);
    pNew = reinterpret_cast<StgPoolSeg*>(malloc(iNewSize+4));
    if (pNew == 0)
        return (false);

    // Set the fields in the new segment.
    pNew->m_pSegData = reinterpret_cast<BYTE*>(pNew) + sizeof(StgPoolSeg);
    _ASSERTE(ALIGN4BYTE(reinterpret_cast<ULONG>(pNew->m_pSegData)) == reinterpret_cast<ULONG>(pNew->m_pSegData));
    pNew->m_pNextSeg = 0;
    pNew->m_cbSegSize = iNewSize - sizeof(StgPoolSeg);
    pNew->m_cbSegNext = 0;

    // Calculate the base offset of the new segment.
    m_cbCurSegOffset = m_cbCurSegOffset + m_pCurSeg->m_cbSegNext;

    // Handle special case for a segment that was completely unused.
	//@todo: Trim();
    if (m_pCurSeg->m_cbSegNext == 0)
    {
        // Find the segment which points to the empty segment.
        for (StgPoolSeg *pPrev = this; pPrev && pPrev->m_pNextSeg != m_pCurSeg; pPrev = pPrev->m_pNextSeg);
        _ASSERTE(pPrev && pPrev->m_pNextSeg == m_pCurSeg);

        // Free the empty segment.
        free(m_pCurSeg);
        
        // Link in the new segment.
        pPrev->m_pNextSeg = pNew;
        m_pCurSeg = pNew;

        return (true);
    }

#ifndef NO_CRT
    // Give back any memory that we won't use.
    if (m_pNextSeg == 0)
    {   // First segment allocated as [header]->[data].
        // Be sure that we are contracting the allocation.
        if (m_pCurSeg->m_cbSegNext < (_msize(m_pCurSeg->m_pSegData)-4))
        {
            // Contract the allocation.
            void *pRealloc = _expand(m_pCurSeg->m_pSegData, m_pCurSeg->m_cbSegNext+4);
            // Shouldn't have moved.
            _ASSERTE(pRealloc == m_pCurSeg->m_pSegData);
        }
    }
    else
    {   // Chained segments are allocated together, [header][data].
        // Be sure that we are contracting the allocation.
        if (m_pCurSeg->m_cbSegNext+sizeof(StgPoolSeg) < (_msize(m_pCurSeg)-4))
        {
            // Contract the allocation.
            void *pRealloc = _expand(m_pCurSeg, m_pCurSeg->m_cbSegNext+sizeof(StgPoolSeg)+4);
            // Shouldn't have moved.
            _ASSERTE(pRealloc == m_pCurSeg);
        }
    }
#endif

    // Fix the size of the old segment.
    m_pCurSeg->m_cbSegSize = m_pCurSeg->m_cbSegNext;

    // Link the new segment into the chain.
    m_pCurSeg->m_pNextSeg = pNew;
    m_pCurSeg = pNew;

    return (true);
} // bool StgPool::Grow()


//*****************************************************************************
// Add a segment to the chain of segments.
//*****************************************************************************
HRESULT StgPool::AddSegment(			// S_OK or error.
	const void	*pData,					// The data.
	ULONG		cbData,					// Size of the data.
	bool		bCopy)					// If true, make a copy of the data.
{
    StgPoolSeg  *pNew;                  // Temp pointer for malloc.

	// If we need to copy the data, just grow the heap by enough to take the
	//  the new data, and copy it in.
	if (bCopy)
	{
		if (!Grow(cbData))
			return E_OUTOFMEMORY;
		memcpy(GetNextLocation(), pData, cbData);
		return S_OK;
	}

    // If first time, handle specially.
    if (m_pSegData == m_zeros)
	{	// Data was passed in.
		m_pSegData = reinterpret_cast<BYTE*>(const_cast<void*>(pData));
		m_cbSegSize = cbData;
		m_cbSegNext = cbData;
		_ASSERTE(m_pNextSeg == 0);

        // Will not delete it.
        m_bFree = false;

		return S_OK;
	}

    // Not first time.  Handle a completely empty tail segment.
    Trim();

    // Abandon any space past the end of the current live data.
    _ASSERTE(m_cbSegSize >= m_cbSegNext);
    m_cbSegSize = m_cbSegNext;

	// Allocate a new segment header.
	pNew = reinterpret_cast<StgPoolSeg*>(malloc(sizeof(StgPoolSeg)));
	if (pNew == 0)
		return E_OUTOFMEMORY;

	// Set the fields in the new segment.
	pNew->m_pSegData = reinterpret_cast<BYTE*>(const_cast<void*>(pData));
	pNew->m_pNextSeg = 0;
	pNew->m_cbSegSize = cbData;
	pNew->m_cbSegNext = cbData;

    // Calculate the base offset of the new segment.
    m_cbCurSegOffset = m_cbCurSegOffset + m_pCurSeg->m_cbSegNext;

	// Link the segment into the chain.
	_ASSERTE(m_pCurSeg->m_pNextSeg == 0);
	m_pCurSeg->m_pNextSeg = pNew;
	m_pCurSeg = pNew;

	return S_OK;
} // HRESULT StgPool::AddSegment()


//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgPool::OrganizeBegin()
{
    // Validate transition.
    _ASSERTE(m_State == eNormal);

    m_State = eMarking;
    return (S_OK);
} // HRESULT StgPool::OrganizeBegin()

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgPool::OrganizeMark(
    ULONG       ulOffset)
{
    // Validate state.
    _ASSERTE(m_State == eMarking);

    return (S_OK);
} // HRESULT StgPool::OrganizeMark()

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgPool::OrganizePool()
{
    // Validate transition.
    _ASSERTE(m_State == eMarking);

    m_State = eOrganized;
    return (S_OK);
} // HRESULT StgPool::OrganizePool()

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    *pulNew = ulOld;
    return (S_OK);
} // HRESULT StgPool::OrganizeRemap()

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgPool::OrganizeEnd()
{ 
    // Validate transition.
    _ASSERTE(m_State == eOrganized);

    m_State = eNormal;
    return (S_OK); 
} // HRESULT StgPool::OrganizeEnd()


//*****************************************************************************
// Copy from the organized pool into a chunk of memory.  Then init pTo to be
// on top of that version of the data.  The pTo heap will treat this copy of
// the data as read only, even though we allocated it.
//*****************************************************************************
HRESULT StgPool::SaveCopy(              // Return code.
    StgPool     *pTo,                   // Copy to this heap.
    StgPool     *pFrom,                 // From this heap.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool)         // String pool for variant heap.
{
    IStream     *pIStream = 0;          // Stream for save.
    void        *pbData= 0;             // Pointer to allocated data.
    ULONG       cbSaveSize;             // Save size for the heap after organization.
    HRESULT     hr;

    // Get the save size so we can grow our own segment to the correct size.
    if (FAILED(hr = pFrom->GetSaveSize(&cbSaveSize)))
        goto ErrExit;

	// Make sure that we're going to malloc more than zero bytes before
	// allocating and manipulating memory
	if (cbSaveSize > 0)
	{
		// Allocate a piece of memory big enough for this heap.
		if ((pbData = malloc(cbSaveSize)) == 0)
		{
			hr = OutOfMemory();
			goto ErrExit;
		}

		// Create a stream on top of our internal memory for the persist function.
		{
			if (SUCCEEDED(hr = CInMemoryStream::CreateStreamOnMemory(pbData, cbSaveSize, &pIStream)))
			{
				// Save the stream we are copying to our own memory, thus giving us
				// a copy of the persisted data in the new format.
				hr = pFrom->PersistToStream(pIStream);
        
				pIStream->Release();
			}
		}
		if (FAILED(hr)) 
			goto ErrExit;

		// Now finally init the to heap with this data.
		if (!pStringPool)
		{
			hr = pTo->InitOnMem(pbData, cbSaveSize, true);
		}
#if 0 // variant pool
		else
		{
			hr = ((StgVariantPool *) pTo)->InitOnMem(pBlobPool, pStringPool, 
					pbData, cbSaveSize, true);
		}
#endif
	} 
	else // instead of malloc'ing 0 bytes, just init pointer to 0
		pbData = 0;

ErrExit:
    if (FAILED(hr))
    {
        if (pbData)
            free(pbData);
    }
    return (hr);
} // HRESULT StgPool::SaveCopy()


//*****************************************************************************
// Free the data that was allocated for this heap.  The SaveCopy method
// allocates the data from the mem heap and then gives it to this heap to
// use as read only memory.  We'll ask the heap for that pointer and free it.
//*****************************************************************************
void StgPool::FreeCopy(
    StgPool     *pCopy)                 // Heap with copy data.
{
    void        *pbData;                // Pointer to data to free.

    // Retrieve and free the data.
    pbData = pCopy->GetData(0);
    if (pbData)
        free(pbData);
} // void StgPool::FreeCopy()


//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgPool::PersistToStream(       // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr = S_OK;
    ULONG       cbTotal;                // Total bytes written.
    StgPoolSeg  *pSeg;                  // A segment being written.

    _ASSERTE(m_pSegData != m_zeros);

    // Start with the base segment.
    pSeg = this;
    cbTotal = 0;

    // As long as there is data, write it.
    while (pSeg)
    {   
        // If there is data in the segment . . .
        if (pSeg->m_cbSegNext)
		{	// . . . write and count the data.
			if (FAILED(hr = pIStream->Write(pSeg->m_pSegData, pSeg->m_cbSegNext, 0)))
				return (hr);
			cbTotal += pSeg->m_cbSegNext;
		}

        // Get the next segment.
        pSeg = pSeg->m_pNextSeg;
    }

    // Align to 4 byte boundary.
    if (Align(cbTotal) != cbTotal)
    {
        _ASSERTE(sizeof(hr) >= 3);
        hr = 0;
        hr = pIStream->Write(&hr, Align(cbTotal)-cbTotal, 0);
    }

    return (hr);
} // HRESULT StgPool::PersistToStream()

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgPool::PersistPartialToStream(// Return code.
    IStream     *pIStream,              // The stream to write to.
	ULONG		iOffset)				// Starting offset.
{
    HRESULT     hr = S_OK;				// A result.
    ULONG       cbTotal;                // Total bytes written.
    StgPoolSeg  *pSeg;                  // A segment being written.

	_ASSERTE(m_State == eNormal);
    _ASSERTE(m_pSegData != m_zeros);

    // Start with the base segment.
    pSeg = this;
    cbTotal = 0;

    // As long as there is data, write it.
    while (pSeg)
    {   
        // If there is data in the segment . . .
        if (pSeg->m_cbSegNext)
		{	// If this data should be skipped...
			if (iOffset >= pSeg->m_cbSegNext)
			{	// Skip it
				iOffset -= pSeg->m_cbSegNext;
			}
			else
			{	// At least some data should be written, so write and count the data.
				if (FAILED(hr = pIStream->Write(pSeg->m_pSegData+iOffset, pSeg->m_cbSegNext-iOffset, 0)))
					return (hr);
				cbTotal += pSeg->m_cbSegNext-iOffset;
				iOffset = 0;
			}
		}

        // Get the next segment.
        pSeg = pSeg->m_pNextSeg;
    }

    // Align to 4 byte boundary.
    if (Align(cbTotal) != cbTotal)
    {
        _ASSERTE(sizeof(hr) >= 3);
        hr = 0;
        hr = pIStream->Write(&hr, Align(cbTotal)-cbTotal, 0);
    }

    return (hr);
} // HRESULT StgPool::PersistPartialToStream()


//*****************************************************************************
// Get a pointer to the data at some offset.  May require traversing the
//  chain of extensions.  It is the caller's responsibility not to attempt
//  to access data beyond the end of a segment.
// This is an internal accessor, and should only be called when the data
//  is not in the base segment.
//*****************************************************************************
BYTE *StgPool::GetData_i(               // pointer to data or NULL.
    ULONG       ulOffset)               // Offset of data within pool.
{
    // Shouldn't be called on base segment.
    _ASSERTE(ulOffset >= m_cbSegNext);
    StgPoolSeg  *pSeg = this;

    while (ulOffset && ulOffset >= pSeg->m_cbSegNext)
    {
        // If we are chaining through this segment, it should be fixed (size == next).
        _ASSERTE(pSeg->m_cbSegNext == pSeg->m_cbSegSize);

        // On to next segment.
        ulOffset -= pSeg->m_cbSegNext;
        pSeg = pSeg->m_pNextSeg;

        // Is there a next?
        if (pSeg == 0)
        {
#ifdef _DEBUG
            if(REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1))
                _ASSERTE(!"Offset past end-of-chain passed to GetData_i()");
#endif
	        return (BYTE*)m_zeros;
        }
    }

    if (ulOffset >= pSeg->m_cbSegNext)
    {
#ifdef _DEBUG
        // This is not a logic error -- a corrupted or malicious code could do this.
        if(REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1))
            _ASSERTE(!"Attempt to access past end of pool.");
#endif
        return (BYTE*)m_zeros;
    }

    return (pSeg->m_pSegData + ulOffset);
} // BYTE *StgPool::GetData_i()


//
//
// StgStringPool
//
//


//*****************************************************************************
// Create a new, empty string pool.
//*****************************************************************************
HRESULT StgStringPool::InitNew(         // Return code.
	ULONG		cbSize,					// Estimated size.
	ULONG		cItems)					// Estimated item count.
{
    HRESULT     hr;                     // A result.
    ULONG       i;                      // Offset of empty string.

    // Let base class intialize.
    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    _ASSERTE(m_Remap.Count() == 0);
    _ASSERTE(m_RemapIndex.Count() == 0);

	// Set initial table sizes, if specified.
	if (cbSize)
		if (!Grow(cbSize))
			return E_OUTOFMEMORY;
	if (cItems)
		m_Hash.SetBuckets(cItems);

    // Init with empty string.
    hr = AddString("", &i, 0);
    // Empty string had better be at offset 0.
    _ASSERTE(i == 0);
    SetDirty(false);
    return (hr);
} // HRESULT StgStringPool::InitNew()


//*****************************************************************************
// Load a string heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new strings.
//*****************************************************************************
HRESULT StgStringPool::InitOnMem(       // Return code.
    void        *pData,                 // Predefined data.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    HRESULT     hr;

    // There may be up to three extra '\0' characters appended for padding.  Trim them.
    char *pchData = reinterpret_cast<char*>(pData);
    while (iSize > 1 && pchData[iSize-1] == 0 && pchData[iSize-2] == 0)
        --iSize;

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    //@todo: defer this until we hand out a pointer.
    if (!bReadOnly)
        TakeOwnershipOfInitMem();

    _ASSERTE(m_Remap.Count() == 0);
    _ASSERTE(m_RemapIndex.Count() == 0);

    // If might be updated, build the hash table.
    if (!bReadOnly)
        hr = RehashStrings();

    return (hr);
} // HRESULT StgStringPool::InitOnMem()

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgStringPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();

    // Clean up any remapping state.
    m_State = eNormal;
    m_Remap.Clear();
    m_RemapIndex.Clear();
} // void StgStringPool::Uninit()

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
HRESULT StgStringPool::SetHash(int bHash)
{
    HRESULT     hr = S_OK;

    _ASSERTE(m_State == eNormal);

    // If turning on hash again, need to rehash all strings.
    if (bHash)
        hr = RehashStrings();

    m_bHash = bHash;
    return (hr);
} // HRESULT StgStringPool::SetHash()

//*****************************************************************************
// The string will be added to the pool.  The offset of the string in the pool
// is returned in *piOffset.  If the string is already in the pool, then the
// offset will be to the existing copy of the string.
//*****************************************************************************
HRESULT StgStringPool::AddString(       // Return code.
    LPCSTR      szString,               // The string to add to pool.
    ULONG       *piOffset,              // Return offset of string here.
    int         iLength)                // -1 null terminated.
{
	STRINGHASH	*pHash;					// Hash item for add.
	ULONG		iLen;					// To handle non-null strings.
    LPSTR       pData;					// Pointer to location for new string.

    _ASSERTE(!m_bReadOnly);

    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Null pointer is an error.
    if (szString == 0)
        return (PostError(E_INVALIDARG));

    // Find the real length we need in buffer.
    if (iLength == -1)
        iLen = (ULONG)(strlen(szString) + 1);
    else
        iLen = iLength + 1;

    // Where to put the new string?
    if (iLen > GetCbSegAvailable())
    {
        if (!Grow(iLen))
            return (PostError(OutOfMemory()));
    }
    pData = reinterpret_cast<LPSTR>(GetNextLocation());

    // Copy the data into the buffer.
    if (iLength == -1)
        strcpy(pData, szString);
    else
    {
        strncpy(pData, szString, iLength);
        pData[iLength] = '\0';
    }

    // If the hash table is to be kept built (default).
    if (m_bHash)
    {
        // Find or add the entry.
        pHash = m_Hash.Find(pData, true);
        if (!pHash)
            return (PostError(OutOfMemory()));

        // If the entry was new, keep the new string.
        if (pHash->iOffset == 0xffffffff)
        {
            *piOffset = pHash->iOffset = GetNextOffset();
            SegAllocate(iLen);
            SetDirty();

            // Check for hash chains that are too long.
            if (m_Hash.MaxChainLength() > MAX_CHAIN_LENGTH)
                RehashStrings();
        }
        // Else use the old one.
        else
            *piOffset = pHash->iOffset;
    }
    // Probably an import which defers the hash table for speed.
    else
    {
        *piOffset = GetNextOffset();
        SegAllocate(iLen);
        SetDirty();
    }
    return (S_OK);
} // HRESULT StgStringPool::AddString()

//*****************************************************************************
// The string will be added to the pool. If it contains no characters with
//  the high bit turned on, this is equivalent to AddString.  However, if
//  any high-bit characters are found, conversion is required -- possibly
//  MBCS to Unicode, and certainly wide character to UTF8.
//
// This implementation emphasizes simplicity and reliability at the expense
//  of performance; if a high-bit character is found, the string is converted
//  to Unicode, and then passed to AddStringW, which will convert from Unicode
//  to UTF8.
//*****************************************************************************
HRESULT StgStringPool::AddStringA(      // Return code.
    LPCSTR      szString,               // The string to add to pool.
    ULONG       *piOffset,              // Return offset of string here.
    int         iLength)                // -1 null terminated.
{
	STRINGHASH	*pHash;					// Hash item for add.
	ULONG		iLen;					// To handle non-null strings.
    LPSTR       pData;					// Pointer to location for new string.
	LPCSTR		pFrom = szString;		// Update pointer for source string.
	LPSTR		pTo;					// Update pointer for dest string.
	int			iCopy = iLength;		// Max chars to copy.

    _ASSERTE(!m_bReadOnly);
    
    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Null pointer is an error.
    if (szString == 0)
        return (PostError(E_INVALIDARG));

    // Find the real length we need in buffer.
    if (iLength == -1)
        iLen = (ULONG)(strlen(szString) + 1);
    else
        iLen = iLength + 1;

    // Where to put the new string?
    if (iLen > GetCbSegAvailable())
    {
        if (!Grow(iLen))
            return (PostError(OutOfMemory()));
    }
    pData = reinterpret_cast<LPSTR>(GetNextLocation());

    // Copy the data into the buffer.
    pTo = pData;
    for (;;)
    {
        if (iCopy-- == 0)
            break;
        if (*pFrom == 0)
            break;
        if ((*pTo++=*pFrom++) & 0x80)
        {   // Found a high-bit character.  Convert to Unicode and defer to AddStringW.
            CQuickBytes rBuf;           // Buffer for conversion.
            int     iWide;              // Resulting characters.
            LPWSTR  pwString = reinterpret_cast<LPWSTR>(rBuf.Alloc(iLen * sizeof(WCHAR)));
            if (pwString == 0)
                return (PostError(OutOfMemory()));
            // Convert to Unicode.
            iWide = ::WszMultiByteToWideChar(CP_ACP, 0, szString, iLen-1, pwString, iLen-1);
            if (iWide == 0)
                return (BadError(HRESULT_FROM_NT(GetLastError())));
            pwString[iWide] = 0;

            // Defer to AddStringW.
            return (AddStringW(pwString, piOffset, iWide));
        }
    }
    *pTo = '\0';
    // Did we copy no more than expected?
    _ASSERTE((iLength - iCopy) <= static_cast<int>(iLen));

    // If the hash table is to be kept built (default).
    if (m_bHash)
    {
        // Find or add the entry.
        pHash = m_Hash.Find(pData, true);
        if (!pHash)
            return (PostError(OutOfMemory()));

        // If the entry was new, keep the new string.
        if (pHash->iOffset == 0xffffffff)
        {
            *piOffset = pHash->iOffset = GetNextOffset();
            SegAllocate(iLen);
            SetDirty();
        }
        // Else use the old one.
        else
            *piOffset = pHash->iOffset;
    }
    // Probably an import which defers the hash table for speed.
    else
    {
        *piOffset = GetNextOffset();
        SegAllocate(iLen);
        SetDirty();
    }
    return (S_OK);
} // HRESULT StgStringPool::AddStringA()


//*****************************************************************************
// Add a string to the pool with Unicode to UTF8 conversion.
//*****************************************************************************
HRESULT StgStringPool::AddStringW(      // Return code.
    LPCWSTR     szString,               // The string to add to pool.
    ULONG       *piOffset,              // Return offset of string here.
    int         iLength)                // -1 null terminated.
{
	STRINGHASH	*pHash;					// Hash item for add.
	ULONG		iLen;					// Correct length after conversion.
    LPSTR       pData;					// Pointer to location for new string.

    _ASSERTE(!m_bReadOnly);
    
    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Null pointer is an error.
    if (szString == 0)
        return (PostError(E_INVALIDARG));

    // Special case empty string.
    if (iLength == 0 || (iLength == -1 && *szString == '\0'))
    {
        *piOffset = 0;
        return (S_OK);
    }

    // How many bytes will be required in the heap?
    iLen = ::WszWideCharToMultiByte(CP_UTF8, 0, szString, iLength, 0, 0, 0, 0);
    // WCTMB includes trailing 0 if iLength==-1, doesn't otherwise.
    if (iLength >= 0)
        ++iLen;

    // Check for room.
    if (iLen > GetCbSegAvailable())
    {
        if (!Grow(iLen))
            return (PostError(OutOfMemory()));
    }
    pData = reinterpret_cast<LPSTR>(GetNextLocation());

    // Convert the data in place to the correct location.
    iLen = ::WszWideCharToMultiByte(CP_UTF8, 0, szString, iLength,
        pData, GetCbSegAvailable(), 0, 0);
    if (iLen == 0)
        return (BadError(HRESULT_FROM_NT(GetLastError())));
    // If the conversion didn't, null terminate; count the null.
    if (iLength >= 0)
        pData[iLen++] = '\0';

    // If the hash table is to be kept built (default).
    if (m_bHash)
    {
        // Find or add the entry.
        pHash = m_Hash.Find(pData, true);
        if (!pHash)
            return (PostError(OutOfMemory()));

        // If the entry was new, keep the new string.
        if (pHash->iOffset == 0xffffffff)
        {
            *piOffset = pHash->iOffset = GetNextOffset();
            SegAllocate(iLen);
            SetDirty();
        }
        // Else use the old one.
        else
            *piOffset = pHash->iOffset;
    }
    // Probably an import which defers the hash table for speed.
    else
    {
        *piOffset = GetNextOffset();
        SegAllocate(iLen);
        SetDirty();
    }
    return (S_OK);
} // HRESULT StgStringPool::AddStringW()


//*****************************************************************************
// Clears out the existing hash table used to eliminate duplicates.  Then
// rebuilds the hash table from scratch based on the current data.
//*****************************************************************************
HRESULT StgStringPool::RehashStrings()
{
    ULONG       iOffset;                // Loop control.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.
    STRINGHASH  *pHash;                 // Hash item for add.
    LPCSTR      pString;                // A string;
    ULONG       iLen;                   // The string's length.
    int         iBuckets;               // Buckets in the hash.
    int         iCount;                 // Items in the hash.
    int         iNewBuckets;            // New count of buckets in the hash.

    // Determine the new bucket size.
    iBuckets = m_Hash.Buckets();
    iCount = m_Hash.Count();
    iNewBuckets = max(iCount, iBuckets+iBuckets/2+1);
    
#ifdef _DEBUG
    WCHAR buf[80];
    swprintf(buf, L"Rehash string heap. count: %d, buckets: %d->%d, max chain: %d\n", iCount, iBuckets, iNewBuckets, m_Hash.MaxChainLength());
    WszOutputDebugString(buf);
#endif
    
	// Remove any stale data.
	m_Hash.Clear();
    m_Hash.SetBuckets(iNewBuckets);

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=1;  iOffset < iMax;  )
    {
        // Get the string from the pool.
        pString = reinterpret_cast<LPCSTR>(pSeg->m_pSegData + iSeg);
        // Add the string to the hash table.
        if ((pHash = m_Hash.Add(pString)) == 0)
            return (PostError(OutOfMemory()));
        pHash->iOffset = iOffset;

        // Move to next string.
        iLen = (ULONG)(strlen(pString) + 1);
        iOffset += iLen;
        iSeg += iLen;
        if (iSeg >= pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
} // HRESULT StgStringPool::RehashStrings()

//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
HRESULT StgStringPool::GetNextItem(		// Return code.
    ULONG       ulItem,                 // Current item.
    ULONG		*pulNext)		        // Return offset of next pool item.
{
    LPCSTR      pString;                // A string;

    // Outside of heap?
    if (ulItem >= GetNextOffset())
    {
        *pulNext = 0;
        return S_FALSE;
    }
    
    pString = reinterpret_cast<LPCSTR>(GetData(ulItem));
    ulItem += (ULONG)(strlen(pString) + 1);
    
    // Was it the last item in heap?
    if (ulItem >= GetNextOffset())
    {
        *pulNext = 0;
        return S_FALSE;
    }
    
    *pulNext = ulItem;
    return (S_OK);
} // HRESULT StgStringPool::GetNextItem()


//*****************************************************************************
// Prepare for string reorganization.
//*****************************************************************************
HRESULT StgStringPool::OrganizeBegin()
{
	ULONG		iOffset;				// Loop control.
	ULONG		iMax;					// End of loop.
	ULONG		iSeg;					// Location within segment.
	StgPoolSeg	*pSeg = this;			// To loop over segments.
	LPCSTR		pString;				// A string;
	ULONG		iLen;					// The string's length.
	StgStringRemap *pRemap;				// A new remap element.

    _ASSERTE(m_State == eNormal);
    _ASSERTE(m_Remap.Count() == 0);

    //@todo: should this code iterate over the pool, counting the strings
    //  and then allocate a buffer big enough?

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=1;  iOffset < iMax;  )
    {
        // Get the string from the pool.
        pString = reinterpret_cast<LPCSTR>(pSeg->m_pSegData + iSeg);
        iLen = (ULONG)(strlen(pString));

        // Add the string to the remap list.
        pRemap = m_Remap.Append();
        if (pRemap == 0)
        {
            m_Remap.Clear();
            return (PostError(OutOfMemory()));
        }
        pRemap->ulOldOffset = iOffset;
        pRemap->cbString = iLen;
        pRemap->ulNewOffset = ULONG_MAX;

        // Move to next string.
        iOffset += iLen + 1;
        iSeg += iLen + 1;
        if (iSeg >= pSeg->m_cbSegNext)
        {
            _ASSERTE(iSeg == pSeg->m_cbSegNext);
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }

    m_State = eMarking;
    return (S_OK);
} // HRESULT StgStringPool::OrganizeBegin()

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgStringPool::OrganizeMark(
    ULONG       ulOffset)
{
    int         iContainer;             // Index for insert, if not already in list.
    StgStringRemap  *pRemap;            // Found entry.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Treat (very common) null string specially.
    // Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);
    
    StgStringRemap  sTarget = {ulOffset};// For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.  If exact match, set the ulNewOffset to 0;
    if (pRemap = const_cast<StgStringRemap*>(Searcher.Find(&sTarget, &iContainer)))
    {
        pRemap->ulNewOffset = 0;
        return (S_OK);
    }

    // Found a tail string.  Get the remap record for the containing string.
    _ASSERTE(iContainer > 0);
    pRemap = m_Remap.Get(iContainer-1);

    // If this is the longest tail so far, set ulNewOffset to the delta from the 
    //  heap's string.
    _ASSERTE(ulOffset > pRemap->ulOldOffset);
    ULONG cbDelta = ulOffset - pRemap->ulOldOffset;
    if (cbDelta < pRemap->ulNewOffset)
        pRemap->ulNewOffset = cbDelta;

    return (S_OK);
} // HRESULT StgStringPool::OrganizeMark()

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgStringPool::OrganizePool()
{
    StgStringRemap  *pRemap;            // An entry in the Remap array.
    LPCSTR      pszSaved;               // Pointer to most recently saved string.
    LPCSTR      pszNext;                // Pointer to string under consideration.
    ULONG       cbSaved;                // Size of most recently saved string.
    ULONG       cbDelta;                // Delta in sizes between saved and current strings.
    ULONG       ulOffset;               // Current offset as we loop through the strings.
    int         i;                      // Loop control.
    int         iCount;                 // Count of live strings.


    // Validate state.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

    // Allocate enough indices for the entire remap array.
    if (!m_RemapIndex.AllocateBlock(m_Remap.Count()))
        return (PostError(OutOfMemory()));
    iCount = 0;

    // Add the live strings to the index map.  Discard any unused heads
    //  at this time.
    for (i=0; i<m_Remap.Count(); ++i)
    {
        pRemap = m_Remap.Get(i);
        if (pRemap->ulNewOffset != ULONG_MAX)
        {
            _ASSERTE(pRemap->ulNewOffset < pRemap->cbString);
            m_RemapIndex[iCount++] = i;
            // Discard head of the string?
            if (pRemap->ulNewOffset)
            {
                pRemap->ulOldOffset += pRemap->ulNewOffset;
                pRemap->cbString -= pRemap->ulNewOffset;
                pRemap->ulNewOffset = 0;
            }
        }
    }
    // Clear unused entries from the index map. 
    // Note: AllocateBlock a negative number.
    m_RemapIndex.AllocateBlock(iCount - m_RemapIndex.Count());

    // If no strings marked, nothing to save.
    if (iCount == 0)
    {
        m_cbOrganizedSize = 0;
        m_cbOrganizedOffset = 0;
        return (S_OK);
    }

#if defined(_DEBUG) && 0
    {
        LPCSTR  pString;
        ULONG   ulOld;
        int     ix;
        for (ix=0; ix<iCount; ++ix)
        {
            ulOld = m_Remap[m_RemapIndex[ix]].ulOldOffset;
            pString = GetString(ulOld);
        }
    }
#endif

    //*****************************************************************
    // Phase 1: Sort decending by reversed string value.
    SortReversedName NameSorter(m_RemapIndex.Ptr(), m_RemapIndex.Count(), *this);
    NameSorter.Sort();

#if defined(_DEBUG)
    {
        LPCSTR  pString;
        ULONG   ulOld;
        int     ix;
        for (ix=0; ix<iCount; ++ix)
        {
            ulOld = m_Remap[m_RemapIndex[ix]].ulOldOffset;
            pString = GetString(ulOld);
        }
    }
#endif
    //*****************************************************************
    // Search for duplicates and potential tail-merges.

    // Build the pool from highest to lowest offset.  Since we don't 
    //  know yet how big the pool will be, start with the end at 
    //  ULONG_MAX; then shift the whole set down to start at 1 (right
    //  after the empty string).

    // Map the highest entry first string.  Save length and pointer.
    int ix = iCount - 1;
    pRemap = m_Remap.Get(m_RemapIndex[ix]);
    pszSaved = GetString(pRemap->ulOldOffset);
    cbSaved = pRemap->cbString;
    ulOffset = ULONG_MAX - (cbSaved + 1);
    pRemap->ulNewOffset = ulOffset;

    // For each item in array (other than the highest entry)...
    for (--ix; ix>=0; --ix)
    {
        // Get the remap entry.
        pRemap = m_Remap.Get(m_RemapIndex[ix]);
        pszNext = GetString(pRemap->ulOldOffset);
        _ASSERTE(strlen(pszNext) == pRemap->cbString);
        // If the length is less than or equal to saved length, it might be a substring.
        if (pRemap->cbString <= cbSaved)
        {
             // delta = len(saved) - len(next) [saved is not shorter].  Compare (szOld+delta, szNext)
            cbDelta = cbSaved - pRemap->cbString;
            if (strcmp(pszNext, pszSaved + cbDelta) == 0)
            {   // Substring: save just the offset
                pRemap->ulNewOffset = ulOffset + cbDelta;
                continue;
            }
        }
        // Unique string.  Map string.  Save length and pointer.
        cbSaved = pRemap->cbString;
        ulOffset -= cbSaved + 1;
        pRemap->ulNewOffset = ulOffset;
        pszSaved = pszNext;
    }

    // How big is the optimized pool?
    m_cbOrganizedSize = ULONG_MAX - ulOffset + 1;

    // Shift each entry so that the lowest one starts at 1.
    for (ix=0; ix<iCount; ++ix)
        m_Remap[m_RemapIndex[ix]].ulNewOffset -= ulOffset - 1;
    // Find the highest offset in the pool.
    m_cbOrganizedOffset = m_Remap[m_RemapIndex[--ix]].ulNewOffset;
    for (--ix; ix >= 0 && m_Remap[m_RemapIndex[ix]].ulNewOffset >= m_cbOrganizedOffset ; --ix)
        m_cbOrganizedOffset = m_Remap[m_RemapIndex[ix]].ulNewOffset;
    m_cbOrganizedSize = ALIGN4BYTE(m_cbOrganizedSize);

    return (S_OK);
} // HRESULT StgStringPool::OrganizePool()

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgStringPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If not reorganized, new == old.
    // Treat (very common) null string specially.
    // Some columns use 0xffffffff as a null flag.
    if (m_State == eNormal || ulOld == 0 || ulOld == 0xffffffff)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Search for old index.  May not be in the map, since the pool may have
    //  been optimized previously.  In that case, find the string that this 
    //  one was the tail of, get the new location of that string, and adjust
    //  by the length deltas.
    int         iContainer;                 // Index of containing string, if not in map.
    StgStringRemap const *pRemap;               // Found entry.
    StgStringRemap  sTarget = {ulOld};          // For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.
    pRemap = Searcher.Find(&sTarget, &iContainer);
    // Found?
    if (pRemap)
    {   // Yes.
        _ASSERTE(pRemap->ulNewOffset > 0);
        *pulNew = static_cast<ULONG>(pRemap->ulNewOffset);
        return (S_OK);
    }

    // Not Found; this is a persisted tail-string.  New offset is to containing
    //  string's new offset as old offset is to containing string's old offset.
    // This string wasn't found; it is a tail of the previous entry.
    _ASSERTE(iContainer > 0);
    pRemap = m_Remap.Get(iContainer-1);
    // Make sure that the offset really is contained within the previous entry.
    _ASSERTE(ulOld >= pRemap->ulOldOffset && ulOld < pRemap->ulOldOffset + pRemap->cbString);
    *pulNew = pRemap->ulNewOffset + ulOld-pRemap->ulOldOffset;

    return (S_OK);
} // HRESULT StgStringPool::OrganizeRemap()

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgStringPool::OrganizeEnd()
{ 
    // Validate state.
    _ASSERTE(m_State == eOrganized);

    m_Remap.Clear(); 
    m_RemapIndex.Clear();
    m_State = eNormal;
    m_cbOrganizedSize = 0;

    return (S_OK); 
} // HRESULT StgStringPool::OrganizeEnd()

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgStringPool::PersistToStream( // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr = S_OK;              // A result.
    StgStringRemap  *pRemap;            // A remap entry.
    ULONG       ulOffset;               // Offset within the pool.
#ifdef _DEBUG
    ULONG       ulOffsetDbg;            // For debugging offsets.
#endif
    int         i;                      // Loop control.
    LPCSTR      pszString;              // Pointer to a string.

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Validate state.
    _ASSERTE(m_State == eOrganized);

    // If there is any string data at all, then start pool with empty string.
    if (m_RemapIndex.Count())
    {
        hr = 0; // cheeze -- use hr as a buffer for 0
        if (FAILED(hr = pIStream->Write(&hr, 1, 0)))
            return (hr);
        ulOffset = 1;
    }
    else
        ulOffset = 0;

    // Iterate over the map writing unique strings.  We will detect a unique string
    //  because it will start just past the end of the previous string; ie the next
    //  offset.
    DEBUG_STMT(ulOffsetDbg = 0);
    for (i=0; i<m_RemapIndex.Count(); ++i)
    {
        // Get the remap entry.
        pRemap = m_Remap.Get(m_RemapIndex[i]);

        // The remap array is sorted by strings.  A given entry may be a tail-string of a higer
        //  indexed string.  Thus, each new unique string will start at ulOffset, just past the
        //  previous unique string.  Tail matched strings will be destined for an offset higher
        //  than ulOffset, and should be skipped.  Finally, in the case of duplicate copies of 
        //  otherwise unique strings, the first copy will appear to be the unique string; the 
        //  offset will be advanced, and subsequent strings will start before ulOffset.
        //  or equal to what we've already written.
        _ASSERTE(pRemap->ulNewOffset >= ulOffset || pRemap->ulNewOffset == ulOffsetDbg);

        // If this string starts past ulOffset, it must be a tail string, and needn't be
        //  written.
        if (static_cast<ULONG>(pRemap->ulNewOffset) > ulOffset)
        {
            // Better be at least one more string, for this one to be the tail of.
            _ASSERTE(i < (m_RemapIndex.Count() - 1));

            // Better end at same point as next string, which this one is a tail of.
            DEBUG_STMT(StgStringRemap *pRemapDbg = m_Remap.Get(m_RemapIndex[i+1]);)
            _ASSERTE(pRemap->ulNewOffset + pRemap->cbString == pRemapDbg->ulNewOffset + pRemapDbg->cbString);

            // This string better really be a tail of the next one.
            DEBUG_STMT(int delta = pRemapDbg->cbString - pRemap->cbString;)
            DEBUG_STMT(const char *p1 = GetString(pRemap->ulOldOffset);)
            DEBUG_STMT(const char *p2 = GetString(pRemapDbg->ulOldOffset) + delta;)
            _ASSERTE(strcmp(p1, p2) == 0);
            continue;
        }

		// If this string starts before ulOffset, it is a duplicate of a previous string.
        if (static_cast<ULONG>(pRemap->ulNewOffset) < ulOffset)
		{
            // There had better be some string before this one.
            _ASSERTE(i > 0);

            // Better end just before where the next string is supposed to start.
			_ASSERTE(pRemap->ulNewOffset + pRemap->cbString + 1 == ulOffset);

            // This string better really match up with the one it is supposed to be a duplicate of.
            DEBUG_STMT(StgStringRemap *pRemapDbg = m_Remap.Get(m_RemapIndex[i-1]);)
            DEBUG_STMT(int delta = pRemapDbg->cbString - pRemap->cbString;)
            DEBUG_STMT(const char *p1 = GetString(pRemap->ulOldOffset);)
            DEBUG_STMT(const char *p2 = GetString(pRemapDbg->ulOldOffset) + delta;)
            _ASSERTE(strcmp(p1, p2) == 0);
			continue;
		}

        // New unique string.  (It starts exactly where we expect it to.)

        // Get the string data, and write it.
        pszString = GetString(pRemap->ulOldOffset);
        _ASSERTE(pRemap->cbString == strlen(pszString));
        if (FAILED(hr=pIStream->Write(pszString, pRemap->cbString+1, 0)))
            return (hr);

        // Save this offset for debugging duplicate strings.
        DEBUG_STMT(ulOffsetDbg = ulOffset);

        // Shift up for the next one.
        ulOffset += pRemap->cbString + 1;
        _ASSERTE(ulOffset <= m_cbOrganizedSize);
        _ASSERTE(ulOffset > 0);
    }

    // Align.
    if (ulOffset != ALIGN4BYTE(ulOffset))
    {
        hr = 0;
        if (FAILED(hr = pIStream->Write(&hr, ALIGN4BYTE(ulOffset)-ulOffset, 0)))
            return (hr);
        ulOffset += ALIGN4BYTE(ulOffset)-ulOffset;
    }

    // Should have written exactly what we expected.
    _ASSERTE(ulOffset == m_cbOrganizedSize);

    return (S_OK);
} // HRESULT StgStringPool::PersistToStream()


//
//
// StgGuidPool
//
//

HRESULT StgGuidPool::InitNew(           // Return code.
	ULONG		cbSize,					// Estimated size.
	ULONG		cItems)					// Estimated item count.
{
    HRESULT     hr;                     // A result.

    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

	// Set initial table sizes, if specified.
	if (cbSize)
		if (!Grow(cbSize))
			return E_OUTOFMEMORY;
	if (cItems)
		m_Hash.SetBuckets(cItems);

    return (S_OK);
} // HRESULT StgGuidPool::InitNew()

//*****************************************************************************
// Load a Guid heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Guids.
//*****************************************************************************
HRESULT StgGuidPool::InitOnMem(         // Return code.
    void        *pData,                 // Predefined data.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    HRESULT     hr;

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    // For init on existing mem case.
    if (pData && iSize)
    {
        // If we cannot update, then we don't need a hash table.
        if (bReadOnly)
            return (S_OK);

        //@todo: defer this until we hand out a pointer.
        TakeOwnershipOfInitMem();

        // Build the hash table on the data.
        if (FAILED(hr = RehashGuids()))
        {
            Uninit();
            return (hr);
        }
    }

    return (S_OK);
} // HRESULT StgGuidPool::InitOnMem()

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgGuidPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();
} // void StgGuidPool::Uninit()

//*****************************************************************************
// Add a segment to the chain of segments.
//*****************************************************************************
HRESULT StgGuidPool::AddSegment(			// S_OK or error.
	const void	*pData,					// The data.
	ULONG		cbData,					// Size of the data.
	bool		bCopy)					// If true, make a copy of the data.
{
	// Want an integeral number of GUIDs.
	_ASSERTE((cbData % sizeof(GUID)) == 0);

	return StgPool::AddSegment(pData, cbData, bCopy);

} // HRESULT StgGuidPool::AddSegment()

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
HRESULT StgGuidPool::SetHash(int bHash)
{
    HRESULT     hr = S_OK;

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

    // If turning on hash again, need to rehash all guids.
    if (bHash)
        hr = RehashGuids();

    m_bHash = bHash;
    return (hr);
} // HRESULT StgGuidPool::SetHash()

//*****************************************************************************
// The Guid will be added to the pool.  The index of the Guid in the pool
// is returned in *piIndex.  If the Guid is already in the pool, then the
// index will be to the existing copy of the Guid.
//*****************************************************************************
HRESULT StgGuidPool::AddGuid(			// Return code.
	REFGUID		guid,					// The Guid to add to pool.
	ULONG		*piIndex)				// Return 1-based index of Guid here.
{
	GUIDHASH	*pHash;					// Hash item for add.

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

	// Special case for GUID_NULL
	if (guid == GUID_NULL)
	{
		*piIndex = 0;
		return (S_OK);
	}

	// If the hash table is to be kept built (default).
	if (m_bHash)
	{
		// Find or add the entry.
		pHash = m_Hash.Find(&guid, true);
		if (!pHash)
			return (PostError(OutOfMemory()));

		// If the guid was found, just use it.
		if (pHash->iIndex != 0xffffffff)
		{	// Return 1-based index.
			*piIndex = pHash->iIndex;
			return (S_OK);
		}
	}

    // Space on heap for new guid?
    if (sizeof(GUID) > GetCbSegAvailable())
    {
        if (!Grow(sizeof(GUID)))
            return (PostError(OutOfMemory()));
    }

    // Copy the guid to the heap.
    *reinterpret_cast<GUID*>(GetNextLocation()) = guid;
    SetDirty();

	// Give the 1-based index back to caller.
    *piIndex = (GetNextOffset() / sizeof(GUID)) + 1;

	// If hashing, save the 1-based index in the hash.
	if (m_bHash)
		pHash->iIndex = *piIndex;

    // Update heap counters.
    SegAllocate(sizeof(GUID));

    return (S_OK);
} // HRESULT StgGuidPool::AddGuid()

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgGuidPool::GetGuid(				// Pointer to guid in pool.
	ULONG		iIndex)					// 1-based index of Guid in pool.
{
    if (iIndex == 0)
        return (reinterpret_cast<GUID*>(const_cast<BYTE*>(m_zeros)));

	// Convert to 0-based internal form, defer to implementation.
	return (GetGuidi(iIndex-1));
} // GUID *StgGuidPool::GetGuid()



//*****************************************************************************
// Recompute the hashes for the pool.
//*****************************************************************************
HRESULT StgGuidPool::RehashGuids()
{
    ULONG       iOffset;                // Loop control.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.
    GUIDHASH    *pHash;                 // Hash item for add.
    GUID        *pGuid;                 // A guid;

	// Remove any stale data.
	m_Hash.Clear();

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each guid.
    for (iSeg=iOffset=0;  iOffset < iMax;  )
    {
        // Get a pointer to the guid.
        pGuid = reinterpret_cast<GUID*>(pSeg->m_pSegData + iSeg);
        // Add the guid to the hash table.
        if ((pHash = m_Hash.Add(pGuid)) == 0)
            return (PostError(OutOfMemory()));
        pHash->iIndex = iOffset / sizeof(GUID);

        // Move to next Guid.
        iOffset += sizeof(GUID);
        iSeg += sizeof(GUID);
        if (iSeg > pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
} // HRESULT StgGuidPool::RehashGuids()

//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
HRESULT StgGuidPool::GetNextItem(		// Return code.
    ULONG       ulItem,                 // Current item.
    ULONG		*pulNext)		        // Return offset of next pool item.
{
    ++ulItem;
    
    // Outside of heap, or last item in heap?
    if ((ulItem*sizeof(GUID)) >= GetNextOffset())
    {
        *pulNext = 0;
        return S_FALSE;
    }
    
    *pulNext = ulItem;
    return (S_OK);
} // HRESULT StgGuidPool::GetNextItem()

//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeBegin()
{
    int         cRemap;

    // Validate transition.
    _ASSERTE(m_State == eNormal);

	_ASSERTE(m_Remap.Count() == 0);
	cRemap = GetNextIndex();
	if (cRemap == 0)
	{
		m_State = eMarking;
		m_cbOrganizedSize = 0;
		return (S_OK);
	}

	if (!m_Remap.AllocateBlock(cRemap))
		return (PostError(OutOfMemory()));

    memset(m_Remap.Ptr(), 0xff, cRemap * sizeof(m_Remap.Ptr()[0]));
    // Be sure we recognize the "not mapped" value.
    _ASSERTE(m_Remap[0] == ULONG_MAX);

    m_State = eMarking;
    return (S_OK);
} // HRESULT StgGuidPool::OrganizeBegin()

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeMark(
	ULONG		ulOffset)				// 1-based index of guid.
{
    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Don't mark special NULL-GUID. Some columns use 0xffffffff as NULL.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);

	// Convert to 0-based internal format.
	--ulOffset;

	_ASSERTE(ulOffset < static_cast<ULONG>(m_Remap.Count()));
	m_Remap[ulOffset] = 1;

    return (S_OK);
} // HRESULT StgGuidPool::OrganizeMark()

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgGuidPool::OrganizePool()
{
    int         i;                      // Loop control.
    int         iIndex;                 // New index.

    // Validate transition.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

	iIndex = 0;
	for (i=0; i<m_Remap.Count(); ++i)
	{
		if (m_Remap[i] != ULONG_MAX)
			m_Remap[i] = iIndex++;
	}

	// Remember how big the pool will be.
	m_cbOrganizedSize = iIndex * sizeof(GUID);

    return (S_OK);
} // HRESULT StgGuidPool::OrganizePool()

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgGuidPool::OrganizeRemap(
	ULONG		ulOld,					// Old 1-based offset.
	ULONG		*pulNew)				// Put new 1-based offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    if (ulOld == 0 || ulOld == 0xffffffff || m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

	// Convert to 0-based internal form.
	--ulOld;

	// Valid index?
	_ASSERTE(ulOld < static_cast<ULONG>(m_Remap.Count()));
	// Did they map this one?
	_ASSERTE(m_Remap[ulOld] != ULONG_MAX);

	// Give back 1-based external form.
	*pulNew = m_Remap[ulOld] + 1;

    return (S_OK);
} // HRESULT StgGuidPool::OrganizeRemap()

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeEnd()
{ 
    // Validate transition.
    _ASSERTE(m_State == eOrganized);

    m_Remap.Clear();
    m_cbOrganizedSize = 0;

    m_State = eNormal;
    return (S_OK); 
} // HRESULT StgGuidPool::OrganizeEnd()

//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
HRESULT StgGuidPool::PersistToStream(// Return code.
    IStream     *pIStream)              // The stream to write to.
{
	int			i;						// Loop control.
	GUID		*pGuid;					// data to write.
	ULONG		cbTotal;				// Size written.
	HRESULT		hr = S_OK;

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

	// Verify state.
	_ASSERTE(m_State == eOrganized);

	cbTotal = 0;
	for (i=0; i<m_Remap.Count(); ++i)
	{
		if (m_Remap[i] != ULONG_MAX)
		{	// Use internal form, GetGuidi, to get 0-based index.
			pGuid = GetGuidi(i);
			if (FAILED(hr = pIStream->Write(pGuid, sizeof(GUID), 0)))
				return (hr);
			cbTotal += sizeof(GUID);
		}
	}
	_ASSERTE(cbTotal == m_cbOrganizedSize);

    return (S_OK);
} // HRESULT StgGuidPool::PersistToStream()
//
//
// StgBlobPool
//
//



//*****************************************************************************
// Create a new, empty blob pool.
//*****************************************************************************
HRESULT StgBlobPool::InitNew(           // Return code.
	ULONG		cbSize,					// Estimated size.
	ULONG		cItems)					// Estimated item count.
{
    HRESULT     hr;                     // A result.
    ULONG       i;                      // Offset of empty blob.

    // Let base class intialize.
    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    _ASSERTE(m_Remap.Count() == 0);

	// Set initial table sizes, if specified.
	if (cbSize)
		if (!Grow(cbSize))
			return E_OUTOFMEMORY;
	if (cItems)
		m_Hash.SetBuckets(cItems);

    // Init with empty blob.
    hr = AddBlob(0, NULL, &i);
    // Empty blob better be at offset 0.
    _ASSERTE(i == 0);
    SetDirty(false);
    return (hr);
} // HRESULT StgBlobPool::InitNew()


//*****************************************************************************
// Init the blob pool for use.  This is called for both create and read case.
// If there is existing data and bCopyData is true, then the data is rehashed
// to eliminate dupes in future adds.
//*****************************************************************************
HRESULT StgBlobPool::InitOnMem(         // Return code.
    void        *pBuf,                  // Predefined data.
    ULONG       iBufSize,               // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    BLOBHASH    *pHash;                 // Hash item for add.
    ULONG       iOffset;                // Loop control.
    void const  *pBlob;                 // Pointer to a given blob.
    ULONG       cbBlob;                 // Length of a blob.
    int         iSizeLen = 0;           // Size of an encoded length.
    HRESULT     hr;

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pBuf, iBufSize, bReadOnly)))
        return (hr);

    // Init hash table from existing data.
    // If we cannot update, we don't need a hash table.
    if (bReadOnly)
        return (S_OK);

    //@todo: defer this until we hand out a pointer.
    TakeOwnershipOfInitMem();

    // Go through each blob.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=0; iOffset < iMax; )
    {
        // Get the string from the pool.
        pBlob = pSeg->m_pSegData + iSeg;

        // Add the blob to the hash table.
        if ((pHash = m_Hash.Add(pBlob)) == 0)
        {
            Uninit();
            return (E_OUTOFMEMORY);
        }
        pHash->iOffset = iOffset;

        // Move to next blob.
        cbBlob = CPackedLen::GetLength(pBlob, &iSizeLen);
        ULONG		cbCur;					// Size of length + data.
		cbCur = cbBlob + iSizeLen;
		if (cbCur == 0)
		{
			Uninit();
			return CLDB_E_FILE_CORRUPT;
		}
        iOffset += cbCur;
        iSeg += cbBlob + iSizeLen;
        if (iSeg > pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
} // HRESULT StgBlobPool::InitOnMem()


//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgBlobPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();
} // void StgBlobPool::Uninit()


//*****************************************************************************
// The blob will be added to the pool.  The offset of the blob in the pool
// is returned in *piOffset.  If the blob is already in the pool, then the
// offset will be to the existing copy of the blob.
//*****************************************************************************
HRESULT StgBlobPool::AddBlob(           // Return code.
    ULONG       iSize,                  // Size of data item.
    const void  *pData,                 // The data.
    ULONG       *piOffset)              // Return offset of blob here.
{
    BLOBHASH    *pHash;                 // Hash item for add.
    void        *pBytes;                // Working pointer.
	BYTE		*pStartLoc;				// Location to write real blob
    ULONG       iRequired;              // How much buffer for this blob?
	ULONG		iFillerLen;				// space to fill to make byte-aligned

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Can we handle this blob?
    if (iSize > CPackedLen::MAX_LEN)
        return (PostError(CLDB_E_TOO_BIG));

	// worst case is we need three more bytes to ensure byte-aligned, hence the 3
	iRequired = iSize + CPackedLen::Size(iSize) + 3;
    if (iRequired > GetCbSegAvailable())
    {
        if (!Grow(iRequired))
            return (PostError(OutOfMemory()));
    }

	
	// unless changed due to alignment, the location of the blob is just
	// the value returned by GetNextLocation(), which is also a iFillerLen of
	// 0

	pStartLoc = (BYTE *) GetNextLocation();
	iFillerLen = 0;

	// technichally, only the data portion must be DWORD-aligned.  So, if the
	// data length is zero, we don't need to worry about alignment.

	if (m_bAlign && iSize > 0)
	{
		// figure out how many bytes are between the current location and
		// the position to write the size of the real blob.
		ULONG iStart = (ULONG)GetNextLocation();
		ULONG iLenSize  = CPackedLen::Size(iSize);
		ULONG iSum = (iStart % sizeof(DWORD)) + iLenSize;
		iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);

		// if there is a difference between where we are now and we want to
		// start, put in a filler blob.
		if (iFillerLen > 0)
		{
			// Pack in "filler blob" length.
			pStartLoc = (BYTE *) CPackedLen::PutLength(GetNextLocation(), iFillerLen - 1);

			// Write iFillerLen - 1 bytes of zeros after the length indicator.
			for (ULONG i = 0; i < iFillerLen - 1; i++)
			{
				*pStartLoc++ = 0;
			}
		}		
	} 
	
    // Pack in the length at pStartLoc (the start location)
    pBytes = CPackedLen::PutLength(pStartLoc, iSize);

#if defined(_DEBUG)
	if (m_bAlign && iSize > 0)
		// check to make sure blob write will be DWORD-aligned
		_ASSERTE( ( ( (ULONG) pBytes ) % sizeof(DWORD) ) == 0);
#endif

    // Put the bytes themselves.
    memcpy(pBytes, pData, iSize);

    // Find or add the entry.
    if ((pHash = m_Hash.Find(GetNextLocation() + iFillerLen, true)) == 0)
        return (PostError(OutOfMemory()));

    // If the entry was new, keep the new blob.
    if (pHash->iOffset == 0xffffffff)
    {
		// this blob's offset is increased by iFillerLen bytes
        pHash->iOffset = *piOffset = GetNextOffset() + iFillerLen;
		// only SegAllocate what we actually used, rather than what we requested
        SegAllocate(iSize + CPackedLen::Size(iSize) + iFillerLen);
        SetDirty();
        
        // Check for hash chains that are too long.
        if (m_Hash.MaxChainLength() > MAX_CHAIN_LENGTH)
            RehashBlobs();
    }
    // Else use the old one.
    else
        *piOffset = pHash->iOffset;
    return (S_OK);
} // HRESULT StgBlobPool::AddBlob()

//*****************************************************************************
// Return a pointer to a blob, and the size of the blob.
//*****************************************************************************
void *StgBlobPool::GetBlob(             // Pointer to blob's bytes.
    ULONG       iOffset,                // Offset of blob in pool.
    ULONG       *piSize)                // Return size of blob.
{
    void const  *pData;                 // Pointer to blob's bytes.

#if 0 
	// This should not be a necessary special case.  The zero byte at the 
	//  start of the pool will code for a length of zero.  We will return
	//  a pointer to the next length byte, but the caller should notice that
	//  the size is zero, and should not look at any bytes.
    if (iOffset == 0)
    {
        *piSize = 0;
        return (const_cast<BYTE*>(m_zeros));
    }
#endif

    // Is the offset within this heap?
    //_ASSERTE(IsValidOffset(iOffset));
	if(!IsValidOffset(iOffset))
	{
#ifdef _DEBUG
        if(REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1))
		    _ASSERTE(!"Invalid Blob Offset");
#endif
		iOffset = 0;
	}

    // Get size of the blob (and pointer to data).
	pData = CPackedLen::GetData(GetData(iOffset), piSize);

	// Sanity check the return alignment.
	_ASSERTE(!IsAligned() || (((UINT_PTR)(pData) % sizeof(DWORD)) == 0));

    // Return pointer to data.
    return (const_cast<void*>(pData));
} // void *StgBlobPool::GetBlob()

//*****************************************************************************
// Return a pointer to a blob, the size of the blob, and the offset of 
//  the next blob (-1 at end).
//*****************************************************************************
void *StgBlobPool::GetBlobNext(			// Pointer to blob's bytes.
	ULONG		iOffset,				// Offset of blob in pool.
	ULONG		*piSize,				// Return size of blob.
	ULONG		*piNext)				// Return offset of next blob.
{
    const BYTE	*pData;                 // Pointer to blob's bytes.
	int			iLen = 0;				// Length of the length field.
	ULONG		ulNext;					// Offset of next blob.

    if (iOffset == 0)
    {
        *piSize = 0;
		if (1 < GetNextOffset())
			*piNext = 1;
		else
			*piNext = -1;
        return (const_cast<BYTE*>(m_zeros));
    }
	else
	if (iOffset == -1)
	{
        *piSize = 0;
		*piNext = -1;
        return (const_cast<BYTE*>(m_zeros));
	}

    // Is the offset within this heap?
    _ASSERTE(IsValidOffset(iOffset));

    // Get size of the blob, and the size of the size.
	pData = GetData(iOffset);
    *piSize = CPackedLen::GetLength(pData, &iLen);

	// Get the blob itself.
	pData += iLen;

	// Get the offset of the next blob.
	ulNext = iOffset + *piSize + iLen;
	if (ulNext < GetNextOffset())
		*piNext = ulNext;
	else
		*piNext = -1;

	// Sanity check the return alignment.
	_ASSERTE(!IsAligned() || (((UINT_PTR)(pData) % sizeof(DWORD)) == 0));

    // Return pointer to data.
    return (const_cast<BYTE*>(pData));
} // void *StgBlobPool::GetBlobNext()

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
HRESULT StgBlobPool::SetHash(int bHash)
{
    HRESULT     hr = S_OK;

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

    // If turning on hash again, need to rehash all Blobs.
    if (bHash)
        hr = RehashBlobs();

    //@todo: m_bHash = bHash;
    return (hr);
} // HRESULT StgBlobPool::SetHash()

//*****************************************************************************
// Clears out the existing hash table used to eliminate duplicates.  Then
// rebuilds the hash table from scratch based on the current data.
//*****************************************************************************
HRESULT StgBlobPool::RehashBlobs()
{
    void const  *pBlob;                 // Pointer to a given blob.
    ULONG       cbBlob;                 // Length of a blob.
    int         iSizeLen = 0;           // Size of an encoded length.
	ULONG		iOffset;				// Location within iteration.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.
    BLOBHASH	*pHash;                 // Hash item for add.
    int         iBuckets;               // Buckets in the hash.
    int         iCount;                 // Items in the hash.
    int         iNewBuckets;            // New count of buckets in the hash.

    // Determine the new bucket size.
    iBuckets = m_Hash.Buckets();
    iCount = m_Hash.Count();
    iNewBuckets = max(iCount, iBuckets+iBuckets/2+1);
    
#ifdef _DEBUG
    WCHAR buf[80];
    swprintf(buf, L"Rehash blob heap. count: %d, buckets: %d->%d, max chain: %d\n", iCount, iBuckets, iNewBuckets, m_Hash.MaxChainLength());
    WszOutputDebugString(buf);
#endif
    
	// Remove any stale data.
	m_Hash.Clear();
    m_Hash.SetBuckets(iNewBuckets);
    
    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=0; iOffset < iMax; )
    {
        // Get the string from the pool.
        pBlob = pSeg->m_pSegData + iSeg;

        // Add the blob to the hash table.
        if ((pHash = m_Hash.Add(pBlob)) == 0)
        {
            Uninit();
            return (E_OUTOFMEMORY);
        }
        pHash->iOffset = iOffset;

        // Move to next blob.
        cbBlob = CPackedLen::GetLength(pBlob, &iSizeLen);
        cbBlob = CPackedLen::GetLength(pBlob, &iSizeLen);
        ULONG		cbCur;					// Size of length + data.
		cbCur = cbBlob + iSizeLen;
		if (cbCur == 0)
		{
			Uninit();
			return CLDB_E_FILE_CORRUPT;
		}
        iOffset += cbCur;
        iSeg += cbBlob + iSizeLen;
        if (iSeg >= pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
} // HRESULT StgBlobPool::RehashBlobs()

//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
HRESULT StgBlobPool::GetNextItem(		// Return code.
    ULONG       ulItem,                 // Current item.
    ULONG		*pulNext)		        // Return offset of next pool item.
{
    void const  *pBlob;                 // Pointer to a given blob.
    ULONG       cbBlob;                 // Length of a blob.
    int         iSizeLen = 0;           // Size of an encoded length.

    // Outside of heap?
    if (ulItem >= GetNextOffset())
    {
        *pulNext = 0;
        return S_FALSE;
    }
    
    pBlob = GetData(ulItem);
    // Move to next blob.
    cbBlob = CPackedLen::GetLength(pBlob, &iSizeLen);
    ulItem += cbBlob + iSizeLen;
    
    // Was it the last item in heap?
    if (ulItem >= GetNextOffset())
    {
        *pulNext = 0;
        return S_FALSE;
    }
    
    *pulNext = ulItem;
    return (S_OK);
} // HRESULT StgBlobPool::GetNextItem()

//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeBegin()
{
	m_cbOrganizedOffset = 0;
    return (StgPool::OrganizeBegin());
} // HRESULT StgBlobPool::OrganizeBegin()

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeMark(
    ULONG       ulOffset)
{
    int         iContainer;             // Index for insert, if not already in list.
    StgBlobRemap  *psRemap;             // Found entry.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Don't mark 0 (empty) entry.  Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);
    
    // Is the offset within this heap?
    _ASSERTE(IsValidOffset(ulOffset));

    StgBlobRemap    sTarget = {ulOffset};// For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search, done if found.
    if (psRemap = const_cast<StgBlobRemap*>(Searcher.Find(&sTarget, &iContainer)))
        return (S_OK);

    // Add the entry to the remap array.
    if ((psRemap = m_Remap.Insert(iContainer)) == 0)
        return (PostError(OutOfMemory()));

    psRemap->ulOldOffset = ulOffset;
    psRemap->iNewOffset = -1;
    return (S_OK);
} // HRESULT StgBlobPool::OrganizeMark()

//*****************************************************************************
// This reorganizes the blob pool for minimum size. 
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgBlobPool::OrganizePool()
{
    ULONG       ulOffset;               // New offset of a blob.
    int         i;                      // Loop control.
	ULONG		iFillerLen;				// Size of pre-blob filler to maintain alignment
    ULONG       cbBlob;                 // Size of a blob.
    int         cbLen = 0;              // Size of a length.
    // Validate transition.
    _ASSERTE(m_State == eMarking);

    m_State = eOrganized;

    // If nothing to save, we're done.
    if (m_Remap.Count() == 0)
    {
        m_cbOrganizedSize = 0;
        return (S_OK);
    }

    // Start past the empty blob.
    ulOffset = 1;

    // Go through the remap array, and assign each item it's new offset.
    for (i=0; i<m_Remap.Count(); ++i)
    {
        // Still at a valid offset within this heap?
        _ASSERTE(IsValidOffset(ulOffset));

        // Get size of the blob and of length.
        cbBlob = CPackedLen::GetLength(GetData(m_Remap[i].ulOldOffset), &cbLen);

		// For alignment case, need to add in expected padding.
		if (m_bAlign)
		{
			ULONG iSum = (ulOffset % sizeof(DWORD)) + cbLen;
			iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);
		}
		else
			iFillerLen = 0;

		// Set the mapping values.
        m_Remap[i].iNewOffset = ulOffset + iFillerLen;
        m_cbOrganizedOffset = m_Remap[i].iNewOffset;

        // Adjust offset to next blob.
        ulOffset += cbBlob + cbLen + iFillerLen;
    }

    // How big is the whole thing?
    m_cbOrganizedSize = ALIGN4BYTE(ulOffset);

    return (S_OK);
} // HRESULT StgBlobPool::OrganizePool()

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgBlobPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If not reorganized, new == old.
    if (m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Empty blob translates to self.  Some columns use 0xffffffff as a null flag.
    if (ulOld == 0 || ulOld == 0xffffffff)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Search for old index.  
    int         iContainer;                 // Index of containing Blob, if not in map.
    StgBlobRemap const *psRemap;                // Found entry.
    StgBlobRemap    sTarget = {ulOld};          // For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.
    psRemap = Searcher.Find(&sTarget, &iContainer);
    // Found?
    if (psRemap)
    {   // Yes.
        _ASSERTE(psRemap->iNewOffset >= 0);
        *pulNew = static_cast<ULONG>(psRemap->iNewOffset);
        return (S_OK);
    }

    // Not Found, translate to SQL-style NULL.
    _ASSERTE(!"Remap a non-marked blob.");
    *pulNew = 0xffffffff;

    return (S_OK);
} // HRESULT StgBlobPool::OrganizeRemap()

//*****************************************************************************
// Called to leave the organizing state.  Blobs may be added again.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeEnd()
{ 
    _ASSERTE(m_State == eOrganized);

    m_Remap.Clear(); 
    m_State = eNormal;
    m_cbOrganizedSize = 0;

    return (S_OK); 
} // HRESULT StgBlobPool::OrganizeEnd()

//*****************************************************************************
// The entire Blob pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgBlobPool::PersistToStream(   // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr;                     // A result.
    StgBlobRemap *psRemap;              // A remap entry.
    ULONG       ulTotal;                // Bytes written so far.
    int         i;                      // Loop control.
    ULONG       cbBlob;                 // Size of a blob.
    int         cbLen = 0;              // Size of a length.
    BYTE        *pBlob;                 // Pointer to a blob.
	ULONG		iFillerLen;				// Size of pre-blob filler to maintain alignment

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Validate state.
    _ASSERTE(m_State == eOrganized);

    // If there is any blob data at all, then start pool with empty blob.
    if (m_Remap.Count())
    {
        hr = 0; // cheeze -- use hr as a buffer for 0
        if (FAILED(hr = pIStream->Write(&hr, 1, 0)))
            return (hr);
        ulTotal = 1;
    }
    else
        ulTotal = 0;

    // Iterate over the map writing Blobs.  
    for (i=0; i<m_Remap.Count(); ++i)
    {
        // Get the remap entry.
        psRemap = m_Remap.Get(i);

        // Get size of the blob and of length.
        pBlob = GetData(psRemap->ulOldOffset);
        cbBlob = CPackedLen::GetLength(pBlob, &cbLen);

		if (m_bAlign)
		{
			ULONG iSum = (ulTotal % sizeof(DWORD)) + cbLen;
			iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);

			// if there is a difference between where we are now and we want to
			// start, put in a filler blob.
			if (iFillerLen > 0)
			{
				BYTE	rgFillBlob[sizeof(DWORD)];

				// Zero out buffer.				
				*(DWORD *) rgFillBlob = 0;

				// Pack in "filler blob" length, we know it will only be 1 byte
				CPackedLen::PutLength(&rgFillBlob[0], iFillerLen - 1);
				if (FAILED(hr = pIStream->Write(&rgFillBlob, iFillerLen, 0)))
					return (hr);

				ulTotal += iFillerLen;
			}
		}
		else
			iFillerLen = 0;

        // Is this what we expected?
        _ASSERTE(ulTotal == static_cast<ULONG>(psRemap->iNewOffset));

#if defined (_DEBUG)
	// check to make sure that we are writing aligned if desired
	if (m_bAlign)
		_ASSERTE( (ulTotal + cbLen) % sizeof(DWORD) == 0 );
#endif

        // Write the data.
        if (FAILED(hr = pIStream->Write(pBlob, cbBlob+cbLen, 0)))
            return (hr);

        // Accumulate the bytes.
        ulTotal += cbBlob + cbLen;
    }

    // Align.
    if (ulTotal != ALIGN4BYTE(ulTotal))
    {
        hr = 0;
        if (FAILED(hr = pIStream->Write(&hr, ALIGN4BYTE(ulTotal)-ulTotal, 0)))
            return (hr);
        ulTotal += ALIGN4BYTE(ulTotal)-ulTotal;
    }

    // Should have written exactly what we expected.
    _ASSERTE(ulTotal == m_cbOrganizedSize);

    return (S_OK);
} // HRESULT StgBlobPool::PersistToStream()



#if 0
//
//
// StgVariantPool
//
//



//*****************************************************************************
// Init the variant pool for usage.  This is called for the create case.
//*****************************************************************************
HRESULT StgVariantPool::InitNew(        // Return code.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool)         // Pool to keep strings in.
{
    HRESULT     hr;

    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    // Save off the pools we know about.
    m_pBlobPool = pBlobPool;
    m_pStringPool = pStringPool;

    return (S_OK);
} // HRESULT StgVariantPool::InitNew()

//*****************************************************************************
// Init the variant pool for usage.  This is called for the open existing case.
//*****************************************************************************
HRESULT StgVariantPool::InitOnMem(      // Return code.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool,         // Pool to keep strings in.
    void        *pData,                 // Predefined data, may be null.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if update is forbidden.
{
	HRESULT		hr;
	ULONG		cVariants;				// Count of persisted variants.
	ULONG		ulPoolData;				// Offset of start of some pool data.

    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    // Copy the data, so we can update it.
    if (!bReadOnly)
        TakeOwnershipOfInitMem();

    // Save off the pools we know about.
    m_pBlobPool = pBlobPool;
    m_pStringPool = pStringPool;

    // Get the count of variants.
    cVariants = *reinterpret_cast<ULONG*>(m_pSegData);
    ulPoolData = sizeof(ULONG);

    // Get the array of variants.
    m_rVariants.InitOnMem(sizeof(StgVariant), m_pSegData + ulPoolData, cVariants, cVariants);
    ulPoolData += cVariants * sizeof(StgVariant);

    // Other data goes on top of stream.
    if (FAILED(hr = CInMemoryStream::CreateStreamOnMemory(m_pSegData + ulPoolData,
                iSize - ulPoolData, &m_pIStream)))
        return (hr);

    // If not readonly, copy the other stream to an updateable one.
    if (!bReadOnly)
    {
        IStream *pTmp=0;
        if (FAILED(hr = CreateStreamOnHGlobal(0, true, &pTmp)))
            return (hr);
        ULARGE_INTEGER iBigSize;
        iBigSize.QuadPart = iSize - ulPoolData;
        if (FAILED(hr = m_pIStream->CopyTo(pTmp, iBigSize, 0, 0)))
            return (hr);
        m_pIStream = pTmp;
    }

    return (S_OK);
} // HRESULT StgVariantPool::InitOnMem()


//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
void StgVariantPool::Uninit()
{
    // Clear out dynamic arrays.
    ClearVars();

    // Clean up any remapping state.
    m_State = eNormal;

    // Let base class free any memory it owns.
    StgPool::Uninit();
} // void StgVariantPool::Uninit()


//*****************************************************************************
// Add the given variant to the pool.  The index returned is good only for
// the duration of the load.  It must be converted into a final index when you
// persist the information to disk.
//*****************************************************************************
HRESULT StgVariantPool::AddVariant(     // Return code.
    VARIANT     *pVal,                  // The value to store.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    _ASSERTE(pVal->vt != VT_BLOB);
    return AddVarianti(pVal, 0, 0, piIndex);
} // HRESULT StgVariantPool::AddVariant()

HRESULT StgVariantPool::AddVariant(     // Return code.
    ULONG       iSize,                  // Size of data item.
    const void  *pData,                 // The data.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    VARIANT vt;
    vt.vt = VT_BLOB;
    return AddVarianti(&vt, iSize, pData, piIndex);
} // HRESULT StgVariantPool::AddVariant()


HRESULT StgVariantPool::AddVarianti(    // Return code.
    VARIANT     *pVal,                  // The value to store, if variant.
    ULONG       cbBlob,                 // The size to store, if blob.
    const void  *pBlob,                 // Pointer to data, if blob.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    HRESULT     hr = S_OK;              // A result.
    StgVariant  *pStgVariant;           // New pool entry.
    ULONG       iIndex;                 // Index of new item.
    ULONG       ulOffset;               // Offset into pool's stream.
    ULONG       ulOther;                // Offset into another pool.
    void        *pWrite;                // For writing directly to the stream.
    ULONG       cbWrite = 0;            // Bytes to write directly to stream.
    
    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    _ASSERTE(!m_bReadOnly);

    // Find new index.
    iIndex = m_rVariants.Count();

    // Add the item to the current list of values.
    if ((pStgVariant = m_rVariants.Append()) == 0)
        return (PostError(OutOfMemory()));

    // Type of variant.
    pStgVariant->m_vt = pVal->vt;

    // Be optimistic about storing the value directly.
    pStgVariant->m_bDirect = true;

    // See if the value can be stored directly.
    switch (pVal->vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
        pStgVariant->Set(pVal->cVal);
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        pStgVariant->Set(pVal->iVal);
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        pStgVariant->Set(pVal->lVal);
        // If it is possible to store all the bits directly, done.
        if (pStgVariant->Get() == pVal->lVal)
            break;
        // Won't fit; write to the stream
        pWrite = &pVal->lVal;
        cbWrite = 4;
        goto WriteToStream;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        pWrite = &pVal->dblVal;
        cbWrite = sizeof(double);
        goto WriteToStream;

    case VT_BSTR:
        // Special case for NULL bstrVal.
        if (pVal->bstrVal == 0)
        {
            ulOther = -1;
        }
        else
        {
            hr = m_pStringPool->AddStringW(pVal->bstrVal, &ulOther);
            if (FAILED(hr)) goto ErrExit;
        }
        pWrite = &ulOther;
        cbWrite = sizeof(ulOther);
        goto WriteToStream;

    case VT_BLOB:
        hr = m_pBlobPool->AddBlob(cbBlob, pBlob, &ulOther);
        if (FAILED(hr)) goto ErrExit;
        pWrite = &ulOther;
        cbWrite = sizeof(ulOther);
        goto WriteToStream;

    default:
        // Write to other pool.
        // Get the current offset for the data, then write this value to the stream.
        if (FAILED(hr = GetOtherSize(&ulOffset)))
            goto ErrExit;
        if (ulOffset > StgVariant::VALUE_MASK)
        {
            hr = PostError(DISP_E_OVERFLOW);
            goto ErrExit;
        }

WriteToStream:
        // Create a temporary stream if need be.
        if (m_pIStream == 0 &&
            FAILED(hr = CreateStreamOnHGlobal(0, true, &m_pIStream)))
        {
            return (hr);
        }

        // Data will go at the end of the stream.
        LARGE_INTEGER iSeek;
        ULARGE_INTEGER ulPos;
        iSeek.QuadPart = 0;
        if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_END, &ulPos)))
            goto ErrExit;;
        // Never allow the size to get bigger than 4 bytes.
        if (ulPos.QuadPart >= StgVariant::VALUE_MASK)
            return (PostError(DISP_E_OVERFLOW));
        // Size is where new data will be written.
        ulOffset = static_cast<ULONG>(ulPos.QuadPart);
        // Write direct or through variant helper?
        if (cbWrite)
            hr = m_pIStream->Write(pWrite, cbWrite, 0);
        else
            hr = VariantWriteToStream(pVal, m_pIStream);
        if (FAILED(hr)) goto ErrExit;
        pStgVariant->Set(ulOffset);
        pStgVariant->m_bDirect = 0;

        break;
    }

ErrExit:
    if (SUCCEEDED(hr))
    {
        // Convert from internal 0-based to external 1-based index.
        *piIndex = iIndex + 1;
        SetDirty();
    }
    else
        m_rVariants.Delete(iIndex);
    return (hr);
} // HRESULT StgVariantPool::AddVarianti()

	
//*****************************************************************************
// Lookup the logical variant and return a copy to the caller.
//*****************************************************************************
HRESULT StgVariantPool::GetVariant(     // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    VARIANT     *pVal)                  // Put variant here.
{
    HRESULT     hr = S_OK;              // A result.
    StgVariant  *pStgVariant;           // The pool entry.
    ULONG       ulOffset;               // Offset into pool's stream.
    ULONG       ulOther;                // Offset into another pool
    void        *pRead;                 // For writing directly to the stream.
    ULONG       cbRead = 0;             // Bytes to write directly to stream.
    LPCSTR      pString;                // The string, if a BSTR.
    LARGE_INTEGER liOffset;             // For stream seek.
    VARTYPE     vt;                     // Resulting type.

    _ASSERTE(pVal->vt == VT_EMPTY);

    // If the index is 0, then nothing was ever assigned.  Leave the value of VT_EMPTY.
    if (iIndex == 0)
        return (S_OK);

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);
    vt = pStgVariant->m_vt;

    // Pull the value out of the array and/or stream.
    switch (vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
        pVal->cVal = static_cast<CHAR>(pStgVariant->Get());
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        pVal->iVal = static_cast<SHORT>(pStgVariant->Get());
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        pRead = &pVal->lVal;
        cbRead = 4;
        goto ReadFromStream;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        pRead = &pVal->dblVal;
        cbRead = sizeof(double);
        goto ReadFromStream;

    case VT_BLOB:
    case VT_BSTR:
        pRead = &ulOther;
        cbRead = sizeof(ulOther);
        
ReadFromStream:
        // Get the value; perhaps indirectly.
        if (FAILED(hr = GetValue(pStgVariant, pRead, cbRead)))
            goto ErrExit;
        // If the variant is a BSTR, create one.
        if (pStgVariant->m_vt == VT_BSTR)
        {
            if (ulOther == -1)
                pVal->bstrVal = 0;
            else
            {
                pString = m_pStringPool->GetString(ulOther);
                if (pString == 0)
                    pVal->bstrVal = 0;
                else
                {
                    if ((pVal->bstrVal = ::Utf8StringToBstr(pString)) == 0)
                        return (PostError(OutOfMemory()));
                }
            }
        }
        else
        if (pStgVariant->m_vt == VT_BLOB)
        {   // It is a blob.  Retrieve it.
            if (ulOther == -1)
                vt = VT_EMPTY;
            else
            {
                const void *pBlob;
                ULONG cbBlob;
                pBlob = m_pBlobPool->GetBlob(ulOther, &cbBlob);
				//@todo: if we can find a supported way to keep OLEAUT32 from freeing safearray memory
				// we should let the safearray point to our data.  Until then, we have to copy.
#if !defined(VARIANT_BLOB_NOALLOC)
				pVal->parray = SafeArrayCreateVector(VT_UI1, 0, cbBlob);
				if (pVal->parray == 0)
					return (E_OUTOFMEMORY);
				memcpy(pVal->parray->pvData, pBlob, cbBlob);
#else
                if (FAILED(hr = SafeArrayAllocDescriptor(1, &pVal->parray)))
                    return (hr);
                pVal->parray->cbElements = 1;
                pVal->parray->rgsabound[0].cElements = cbBlob;
                pVal->parray->rgsabound[0].lLbound = 0;
                pVal->parray->fFeatures = FADF_STATIC | FADF_FIXEDSIZE;
                pVal->parray->pvData = const_cast<void*>(pBlob);
#endif
                vt = VT_UI1 | VT_ARRAY;
            }
        }
        break;

    default:
        // Retrieve the offset into the variant stream.
        ulOffset = pStgVariant->Get();
        liOffset.QuadPart = ulOffset;

        // Read the value from the stream.
        if (FAILED(hr = m_pIStream->Seek(liOffset, STREAM_SEEK_SET, 0)) ||
            FAILED(hr = VariantReadFromStream(pVal, m_pIStream)))
            goto ErrExit;
        break;
    }

ErrExit:
    if (SUCCEEDED(hr))
        pVal->vt = vt;
    return (hr);
} // HRESULT StgVariantPool::GetVariant()

//*****************************************************************************
// Get the BLOB stored as a variant.
//*****************************************************************************
HRESULT StgVariantPool::GetVariant(     // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    ULONG       *pcbBlob,               // Return size of blob.
    const void  **ppBlob)               // Put blob pointer here.
{
    HRESULT     hr;                     // A result.
    StgVariant  *pStgVariant;           // A pool entry.
    ULONG       ulOther;                // Offset into another pool

    // If the index is 0, then nothing was ever assigned.  Leave the value of VT_EMPTY.
    if (iIndex == 0)
        return (S_OK);

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);

    if (pStgVariant->m_vt != VT_BLOB)
        return (E_INVALIDARG);

    // Get the blob's offset.
    if (FAILED(hr = GetValue(pStgVariant, &ulOther, 4)))
        return (hr);

    // Get the blob.
    *ppBlob = m_pBlobPool->GetBlob(ulOther, pcbBlob);

    return (S_OK);
} // HRESULT StgVariantPool::GetVariant()

//*****************************************************************************
// Get the type of the variant.
//*****************************************************************************
HRESULT StgVariantPool::GetVariantType( // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    VARTYPE     *pVt)                   // Put variant type here.
{
    StgVariant  *pStgVariant;           // A pool entry.

    // If the index is 0, then nothing was ever assigned.  The type is VT_EMPTY.
    if (iIndex == 0)
    {
        *pVt = VT_EMPTY;
        return (S_OK);
    }

    // Convert to 0-based internal format.
    --iIndex;

    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);

    *pVt = pStgVariant->m_vt;
    
    return (S_OK);
} // HRESULT StgVariantPool::GetVariantType()

//*****************************************************************************
// Get the blob pool index of a blob variant.
//*****************************************************************************
ULONG StgVariantPool::GetBlobIndex(		// Return blob pool index.
	ULONG		iIndex)					// 1-based Variant index.
{
    HRESULT     hr;                     // A result.
    StgVariant  *pStgVariant;           // A pool entry.
    ULONG       ulOther;                // Offset into another pool

    // If the index is 0, then nothing was ever assigned.  Return 0, null blob.
    if (iIndex == 0)
        return 0;

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

	// Get the small form of the variant.
    pStgVariant = m_rVariants.Get(iIndex);

	// If not a blob, there is no blob index.  Return 0.
    if (pStgVariant->m_vt != VT_BLOB)
        return 0;

    // Get the blob's offset.
    if (FAILED(hr = GetValue(pStgVariant, &ulOther, 4)))
        return (hr);

    // Return the offset.
    return ulOther;
} // ULONG StgVariantPool::GetBlobIndex()


HRESULT StgVariantPool::GetValue(       // Get the value directly or from the stream.
    StgVariant  *pStgVariant,           // The internal form of variant.
    void        *pRead,                 // Where to put the value.
    ULONG       cbRead)                 // Bytes to read for value.
{
    HRESULT     hr;                     // A result.

    if (pStgVariant->m_bDirect)
    {
        _ASSERTE(cbRead == 4);
        *reinterpret_cast<long*>(pRead) = pStgVariant->Get();
        return (S_OK);
    }

    // Seek to this variant in the pool's stream.
    LARGE_INTEGER iSeek;
    iSeek.QuadPart = pStgVariant->Get();
    if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_SET, 0)))
        return (hr);

    // Read the bits from the pool's stream.
    hr = m_pIStream->Read(pRead, cbRead, 0);

    return (hr);
} // HRESULT StgVariantPool::GetValue()
        
HRESULT StgVariantPool::GetEntrysStreamSize(// Get the size for the streamed part of this item.
    StgVariant  *pStgVariant,           // The internal form of variant.
    ULONG       *pSize)                 // Put size here..
{
	HRESULT		hr = S_OK;				// A result.
	ULONG		cbOthers;				// Total size of others pool.
	int			i;						// Loop control.

    if (pStgVariant->m_bDirect)
    {
        *pSize = 0;
        return (S_OK);
    }

    switch (pStgVariant->m_vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _ASSERTE(!"Non-directly stored 1 or 2 byte variant");
        *pSize = 0;
        break;

    // If these are in stream, they are 4 bytes.
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:

    case VT_BSTR:
    case VT_BLOB:
        *pSize = sizeof(LONG);
        break;

    // If these are in stream, they are 8 bytes.
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        *pSize = sizeof(DOUBLE);
        break;

    default:
        // Search for next non-direct entry.  Stream size will be offsets delta.
        i = m_rVariants.ItemIndex(pStgVariant);
        for (++i; i<m_rVariants.Count(); ++i)
        {
            if (!m_rVariants[i].m_bDirect)
                break;
        }
        // Found one, or ran out of entries?
        if (i == m_rVariants.Count())
        {   // Ran out of entries
            if (FAILED(hr = GetOtherSize(&cbOthers)))
                break;
            *pSize = cbOthers - pStgVariant->m_iVal;
        }
        else
        {   // Found one.
            *pSize = m_rVariants[i].m_iVal - pStgVariant->m_iVal;
        }
        break;
    }
    return (hr);
} // HRESULT StgVariantPool::GetEntrysStreamSize()
        

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
// Prepare for pool re-organization.
HRESULT StgVariantPool::OrganizeBegin()
{
    int         cRemap;                 // Number of entries in remap array.
    int         i;                      // Loop control.

    // Validate transition.
    _ASSERTE(m_State == eNormal);

    _ASSERTE(m_Remap.Count() == 0);

    // Allocate an array with an entry for every current variant.
    cRemap = m_rVariants.Count();
    if (!m_Remap.AllocateBlock(cRemap))
        return (PostError(OutOfMemory()));

    // Set everything as "not marked".
    for (i=0; i<cRemap; ++i)
        m_Remap[i] = -1;

    m_State = eMarking;
    return (S_OK);
} // HRESULT StgVariantPool::OrganizeBegin()

// Mark an object as being live in the organized pool.
HRESULT StgVariantPool::OrganizeMark(
    ULONG       ulOffset)               // 1-based index of the item.
{
    HRESULT     hr=S_OK;                // A result.
    StgVariant  *pStgVariant;           // The entry being marked.
    ULONG       ulOther;                // Offset into another pool.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // If index 0, is for a VT_EMPTY, which is not in the pool.
    // Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);

    // Convert to 0-based internal format.
    --ulOffset;

    // Mark the entry as in use.
    _ASSERTE(ulOffset < static_cast<ULONG>(m_Remap.Count()));
    m_Remap[ulOffset] = 0;

    // If it is a string or blob, mark the appropriate pool entry.
    pStgVariant = m_rVariants.Get(ulOffset);

    if (pStgVariant->m_vt == VT_BSTR || pStgVariant->m_vt == VT_BLOB)
    {
        if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
            return (hr);
        if (pStgVariant->m_vt == VT_BSTR)
            hr = m_pStringPool->OrganizeMark(ulOther);
        else
            hr = m_pBlobPool->OrganizeMark(ulOther);
    }

    return (hr);
} // HRESULT StgVariantPool::OrganizeMark()

// Organize, based on marked items.
HRESULT StgVariantPool::OrganizePool()
{
    HRESULT     hr;                     // A result.
    int         i, j;                   // Loop control.
    int         iNew=0;                 // For assigning the new index.
    ULONG       ulOffset;               // An offset into something.
    ULONG       cbStreamExtra;          // Extra size in the Stream.
    ULONG       cbBlobExtra;            // sizeof(ULONG) if Blobs not stored directly.
    ULONG       cbStringExtra;          // sizeof(ULONG) if strings not stored directly.
    StgVariant  *pStgVariant;           // An entry in the pool.
    StgVariant  *pStgVariant2;          // A prior entry, for finding duplicates.
    ULONG       ulOffset2;              // A prior entry's offset; for finding duplicates.
    int         bFoundDup;              // Was a duplicate prior entry found?
#ifdef _DEBUG
    int         cDups;                  // Count of duplicates.
#endif

    // Validate state.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

    // Record size of header.
    m_cbOrganizedSize = sizeof(ULONG);
    DEBUG_STMT(cDups = 0);

    // How big are string and blob pool offsets?
    if (FAILED(hr = m_pBlobPool->GetSaveSize(&ulOffset)))
        return (hr);
    cbBlobExtra = (ulOffset <= StgVariant::VALUE_MASK) ? 0 : sizeof(ULONG);

    if (FAILED(hr = m_pStringPool->GetSaveSize(&ulOffset)))
        return (hr);
    cbStringExtra = (ulOffset <= StgVariant::VALUE_MASK) ? 0 : sizeof(ULONG);

    //@todo: use a hashed lookup instead of an O(n) lookup.  (which makes loop O(n**2) )

    // Assign new indices for marked entries.
    for (i=0; i<m_Remap.Count(); ++i)
    {   // Is entry marked as in-use?
        if (m_Remap[i] != -1)
        {   // Examine the entry, and look for a prior duplicate to use instead.
            bFoundDup = false;
            pStgVariant = m_rVariants.Get(i);
            // Look for Blobs and Strings by their pool offset.
            if (pStgVariant->m_vt == VT_BLOB || pStgVariant->m_vt == VT_BSTR)
            {
                if (FAILED(hr = GetValue(pStgVariant, &ulOffset, sizeof(ulOffset))))
                    return (hr);
                for (j = i-1; j>=0 ; --j)
                {   // If prior item is getting deleted, skip it.
                    if (m_Remap[j] == -1)
                        continue;
                    pStgVariant2 = m_rVariants.Get(j);
                    if (pStgVariant2->m_vt == pStgVariant->m_vt)
                    {
                        if (FAILED(hr = GetValue(pStgVariant2, &ulOffset2, sizeof(ulOffset2))))
                            return (hr);
                        if (ulOffset2 == ulOffset)
                        {
                            m_Remap[i] = m_Remap[j];
                            bFoundDup = true;
                            break;
                        }
                    }
                }
            }
            else
            if (pStgVariant->m_bDirect)
            {   // Look for a prior duplicate of the direct value.
                for (j = i-1; j>=0 ; --j)
                {   // If prior item is getting deleted, skip it.
                    if (m_Remap[j] == -1)
                        continue;
                    if (*pStgVariant == m_rVariants[j])
                    {
                        m_Remap[i] = m_Remap[j];
                        bFoundDup = true;
                        break;
                    }
                }
            }

            // If entry is a dup, size is already counted, so on to the next entry.
            if (bFoundDup)
            {
                DEBUG_STMT(++cDups;)
                continue;
            }

            // Record this kept entry.
            m_Remap[i] = iNew++;

            // Record the size. Every item has a StgVariant.
            m_cbOrganizedSize += sizeof(StgVariant);

            // If a blob or string, size will depend on that other pool.
            if (pStgVariant->m_vt == VT_BSTR)
                m_cbOrganizedSize += cbStringExtra;
            else 
            if (pStgVariant->m_vt == VT_BLOB)
                m_cbOrganizedSize += cbBlobExtra;
            else
            {
                if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStreamExtra)))
                    return (hr);
                m_cbOrganizedSize += cbStreamExtra;
            }

        }
    }

    // Align; compute size needed for cookie.
    m_cOrganizedVariants = iNew;
    m_cbOrganizedSize = ALIGN4BYTE(m_cbOrganizedSize);
    m_cbOrganizedCookieSize = iNew > USHRT_MAX ? sizeof(long) : sizeof(short);

#if defined(_DEBUG)
    WCHAR buf[30];
    wsprintfW(buf, L"%d duplicates merged\n", cDups);
    WszOutputDebugString(buf);
#endif
    return (S_OK);
} // HRESULT StgVariantPool::OrganizePool()

// Remap a cookie from the in-memory state to the persisted state.
HRESULT StgVariantPool::OrganizeRemap(
    ULONG       ulOld,                  // 1-based old index.
    ULONG       *pulNew)                // 1-based new index.
{
    ULONG       ulNew;

    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If for VT_EMPTY, no translation.  If not reorganized, new == old.
    // If index 0, is for a VT_EMPTY, which is not in the pool.
    // Some columns use 0xffffffff as a null flag.
    if (ulOld == 0 || ulOld == 0xffffffff || m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Convert to 0-based internal format.
    --ulOld;

    // Look up in the remap array.
    _ASSERTE(ulOld < static_cast<ULONG>(m_Remap.Count()));
    _ASSERTE(m_Remap[ulOld] != -1);
    ulNew = m_Remap[ulOld];

    // Give back the new index in 1-based external format.
    *pulNew = ulNew + 1;

    return (S_OK);
} // HRESULT StgVariantPool::OrganizeRemap()

// Done with regoranization.  Release any state.
HRESULT StgVariantPool::OrganizeEnd()
{
    // Validate transition.
    _ASSERTE(m_State == eOrganized);

    m_Remap.Clear();
    m_cbOrganizedSize = 0;

    m_State = eNormal;
    return (S_OK);
} // HRESULT StgVariantPool::OrganizeEnd()


//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
HRESULT StgVariantPool::GetSaveSize(    // Return code.
    ULONG       *pcbSaveSize)           // Return save size of this pool.
{
	// Only an organized pool can be saved to stream.
	_ASSERTE(m_State == eOrganized);

    *pcbSaveSize = m_cbOrganizedSize;
    
    return (S_OK);
} // HRESULT StgVariantPool::GetSaveSize()


//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
HRESULT StgVariantPool::PersistToStream(// Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr = S_OK;              // A result.
    int         i;                      // Loop control.
    int         iPrev;                  // Most recently persisted item.
    ULONG       ulOffset;               // Cumulative offset in stream.
    ULONG       ulOther;                // Offset into another pool.
    int         bDirect;                // Is a given entry direct?
    StgVariant  *pStgVariant;           // An entry to be written.
    StgVariant  sStgVariant;            // A working variant.
    ULONG       cbWritten;              // For tracking the size.
    ULONG       cbStream;               // Size of an entry's stream part.
    int         bBlobDirect;            // Blobs offset stored direct?
    int         bStringDirect;          // Strings offset stored direct?

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Write the size.
    if (FAILED(hr = pIStream->Write(&m_cOrganizedVariants, sizeof(ULONG), 0)))
        return (hr);
    cbWritten = sizeof(ULONG);

    // How big are string and blob pool offsets?
    if (FAILED(hr = m_pBlobPool->GetSaveSize(&ulOffset)))
        return (hr);
    bBlobDirect = (ulOffset <= StgVariant::VALUE_MASK) ? true : false;

    if (FAILED(hr = m_pStringPool->GetSaveSize(&ulOffset)))
        return (hr);
    bStringDirect = (ulOffset <= StgVariant::VALUE_MASK) ? true : false;

    // Write the variants to be kept.
    ulOffset = 0;
    iPrev = -1;
    for (i=0; i<m_rVariants.Count(); ++i)
    {   // Is this entry to be kept?  
        if (m_Remap[i] != -1)
        {   // If a duplicate of an already persisted entry, skip.
            if (static_cast<int>(m_Remap[i]) <= iPrev)
            {
#if defined(_DEBUG)
                // Search back until we find another entry that mapped to the same place.
                for (int j=i-1; j>=0; --j)
                {
                    if (m_Remap[j] == m_Remap[i])
                    {
                        _ASSERTE(m_rVariants[j].m_vt == m_rVariants[i].m_vt);
                        break;
                    }
                }
#endif
                continue;
            }
            // Get the entry.
            pStgVariant = m_rVariants.Get(i);
            bDirect = pStgVariant->m_bDirect;

            // If a string, direct is computed at save time (now).
            if (pStgVariant->m_vt == VT_BSTR)
            {   // If string offsets are stored directly, create the correct StgVariant.
                if (bStringDirect)
                {
                    if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                        return (hr);
                    if (FAILED(hr = m_pStringPool->OrganizeRemap(ulOther, &ulOther)))
                        return (hr);
                    sStgVariant.m_vt = VT_BSTR;
                    sStgVariant.m_bDirect = 1;
                    sStgVariant.m_iSign = 0;
                    sStgVariant.m_iVal = ulOther;
                    pStgVariant = &sStgVariant;
                    bDirect = true;
                }
                else

                    bDirect = false;
            }
            else
            if (pStgVariant->m_vt == VT_BLOB)
            {   // If Blob offsets are stored directly, create the correct StgVariant.
                if (bBlobDirect)
                {
                    if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                        return (hr);
                    if (FAILED(hr = m_pBlobPool->OrganizeRemap(ulOther, &ulOther)))
                        return (hr);
                    sStgVariant.m_vt = VT_BLOB;
                    sStgVariant.m_bDirect = 1;
                    sStgVariant.m_iSign = 0;
                    sStgVariant.m_iVal = ulOther;
                    pStgVariant = &sStgVariant;
                    bDirect = true;
                }
                else

                    bDirect = false;
            }

            // If not direct, create a new variant with the correct (future) offset.
            if (!bDirect)
            {   // Create a StgVariant with the stream offset that will exist in the persisted state.
                sStgVariant = *pStgVariant;
                sStgVariant.m_iVal = ulOffset;
                sStgVariant.m_bDirect = 0;
                // Account for the size of the stream part.
                if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStream)))
                    return (hr);
                ulOffset += cbStream;
                // Point to new variant, for the write.
                pStgVariant = &sStgVariant;
            }

            // Write out the variant.
            if (FAILED(hr = pIStream->Write(pStgVariant, sizeof(StgVariant), 0)))
                return (hr);
            cbWritten += sizeof(StgVariant);
            // Record that we've written it.
            iPrev = m_Remap[i];
        }
    }

    // Write any stream parts for the variants.
    iPrev = -1;
    for (i=0; i<m_rVariants.Count(); ++i)
    {   // Is this entry to be kept?  
        if (m_Remap[i] != -1)
        {   // If a duplicate of an already persisted entry, skip.
            if (static_cast<int>(m_Remap[i]) <= iPrev)
                continue;
            // Get the entry.
            pStgVariant = m_rVariants.Get(i);

            // If direct, there is no stream part.
            if (pStgVariant->m_vt == VT_BSTR)
            {
                if (bStringDirect)
                    continue;
                if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                    return (hr);
                if (FAILED(hr = m_pStringPool->OrganizeRemap(ulOther, &ulOther)))
                    return (hr);
WriteOtherOffset:
                if (FAILED(hr = m_pIStream->Write(&ulOther, sizeof(ulOther), 0)))
                    return (hr);
                // Record that it was written.
                cbWritten += sizeof(ulOther);

                iPrev = m_Remap[i];
                continue;
            }
            else 
            if (pStgVariant->m_vt == VT_BLOB)
            {
                if (bBlobDirect)
                    continue;
                if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                    return (hr);
                if (FAILED(hr = m_pBlobPool->OrganizeRemap(ulOther, &ulOther)))
                    return (hr);
                goto WriteOtherOffset;
            }
            else
            if (pStgVariant->m_bDirect)
                continue;

            // Get the size of the stream part.
            if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStream)))
                return (hr);
            // Copy the stream bytes to the output stream.

            // Seek to this variant in the storage stream.
            LARGE_INTEGER iSeek;
            iSeek.QuadPart = pStgVariant->m_iVal;
            if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_SET, 0)))
                return (hr);

            // Copy the bits to the output stream.
            ULARGE_INTEGER iBigSize;
            iBigSize.QuadPart = cbStream;
            hr = m_pIStream->CopyTo(pIStream, iBigSize, 0, 0);
            cbWritten += cbStream;

            iPrev = m_Remap[i];
        }
    }

    // Align.
    if ((cbStream = ALIGN4BYTE(cbWritten) - cbWritten) != 0)
    {
        hr = 0;
        _ASSERTE(sizeof(hr) >= cbStream);
        hr = m_pIStream->Write(&hr, cbStream, 0);
        cbWritten += cbStream;
    }

    _ASSERTE(cbWritten == m_cbOrganizedSize);

    return (hr);
} // HRESULT StgVariantPool::PersistToStream()


//*****************************************************************************
// Return the size of the current variable sized data.
//*****************************************************************************
HRESULT StgVariantPool::GetOtherSize(   // Return code.
    ULONG       *pulSize)               // Put size of the stream here.
{
    STATSTG     statstg;                // Information about stream.
    HRESULT     hr;

    // Allow case where there is no data.
    if (m_pIStream == 0)
    {
        *pulSize = 0;
        return (S_OK);
    }

    // Ask the stream for how big it is.
    if (FAILED(hr = m_pIStream->Stat(&statstg, 0)))
        return (hr);

    // Never allow the size to get bigger than 4 bytes.
    if (statstg.cbSize.QuadPart > ULONG_MAX)
        return (PostError(DISP_E_OVERFLOW));

    // Return the new offset to caller.
    *pulSize = static_cast<ULONG>(statstg.cbSize.QuadPart);
    return (S_OK);
} // HRESULT StgVariantPool::GetOtherSize()

#endif

//
//
// Helper code.
//
//



//********************************************************************************
// The following functions make up for lacks in the 64-bit SDK ATL implementation
// as of 15 May 1998. [[brianbec]]
//********************************************************************************
#ifdef _IA64_

    HRESULT BstrWriteToStream (const CComBSTR & bStr,  IStream * pStream)
    {
        _ASSERTE(pStream != NULL);
        
        ULONG cb;
        ULONG cbStrLen = bStr.m_str ? SysStringByteLen(bStr.m_str)+sizeof(OLECHAR) : 0;
        
        HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
        
        if (FAILED(hr))
            return hr;
        return cbStrLen ? pStream->Write((void*) bStr.m_str, cbStrLen, &cb) : S_OK;
            return S_OK ;
    }


    HRESULT BstrReadFromStream (CComBSTR & bStr ,  IStream * pStream)
    {
        _ASSERTE(pStream != NULL);
        _ASSERTE(bStr.m_str == NULL); // should be empty
        ULONG cb = 0;
        ULONG cbStrLen;
        HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
        if (hr != S_OK)
            return hr;
            
        // FIX:
        if (cb != sizeof(cbStrLen))
            return E_FAIL;
    
        if (cbStrLen != 0)
        {
            //subtract size for terminating NULL which we wrote out
            //since SysAllocStringByteLen overallocates for the NULL
            bStr.m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
            if (bStr.m_str == NULL)
                hr = E_OUTOFMEMORY;
            else
                hr = pStream->Read((void*) bStr.m_str, cbStrLen, &cb);
        }
        return hr;
    }

#endif // _IA64_


#if 0
//*****************************************************************************
// This helper functions is stolen from CComVariant in the ATL code.  this
// version fixes a couple of problems with ATL's code:  (1) it handles VT_BYREF
// data, and (2) it will back out the 2 byte VARTYPE if the first Write fails.
// Finally, this version doesn't require a complete copy of the variant to work.
//*****************************************************************************
HRESULT VariantWriteToStream(VARIANT *pVal, IStream* pStream)
{
    CComVariant sConvert;
    HRESULT     hr;

    // Convert byref values into the value they point to.
    if (pVal->vt & VT_BYREF)
    {
        if (FAILED(hr = ::VariantChangeType(&sConvert, pVal, 0, pVal->vt & ~VT_BYREF)))
            return (hr);
        pVal = &sConvert;
    }

    if (FAILED(hr = pStream->Write(&pVal->vt, sizeof(VARTYPE), 0)))
        return (hr);

    int cbWrite = 0;
    switch (pVal->vt)
    {
    case VT_UNKNOWN:
    case VT_DISPATCH:
        {
            CComPtr<IPersistStream> spStream;
            if (pVal->punkVal != NULL)
                hr = pVal->punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
            if (SUCCEEDED(hr))
            {
                if (spStream != NULL)
                    hr = OleSaveToStream(spStream, pStream);
                else
                    hr = WriteClassStm(pStream, CLSID_NULL);
            }
        }
    case VT_UI1:
    case VT_I1:
        cbWrite = sizeof(BYTE);
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbWrite = sizeof(short);
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        cbWrite = sizeof(long);
        break;
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        cbWrite = sizeof(double);
        break;
    case VT_I8:
    case VT_UI8:
        cbWrite = sizeof(__int64);
        break;
    default:
        break;
    }

    // If intrinsic type, write it out.
    if (SUCCEEDED(hr) && cbWrite != 0)
        hr = pStream->Write((void*) &pVal->bVal, cbWrite, NULL);

    // If errors occured on conversion, then take off the VARTTYPE.
    if (FAILED(hr))
    {
        STATSTG     statstg;                // Information about stream.
        if (SUCCEEDED(pStream->Stat(&statstg, 0)))
            VERIFY(pStream->SetSize(statstg.cbSize) == S_OK);
        return (hr);
    }

    if (cbWrite != 0)
        return (S_OK);

    // Try conversion to BSTR.
    CComBSTR bstrWrite;
    CComVariant varBSTR;
    if (pVal->vt != VT_BSTR)
    {
        if (SUCCEEDED(hr = ::VariantChangeType(&varBSTR, pVal, VARIANT_NOVALUEPROP, VT_BSTR)))
            bstrWrite = varBSTR.bstrVal;
    }
    else
        bstrWrite = pVal->bstrVal;

	if (SUCCEEDED(hr))
    {
    	_ASSERTE(pStream != NULL);
    	ULONG cb;
    	ULONG cbStrLen = bstrWrite ? SysStringByteLen(bstrWrite)+sizeof(OLECHAR) : 0;
    	HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
    	if (FAILED(hr))
    		return hr;
    	hr = cbStrLen ? pStream->Write((void*) bstrWrite, cbStrLen, &cb) : S_OK;
    }

    // Cleanup conversion errors in the stream.
    if (FAILED(hr))
    {
        STATSTG     statstg;                // Information about stream.
        if (SUCCEEDED(pStream->Stat(&statstg, 0)))
            VERIFY(pStream->SetSize(statstg.cbSize) == S_OK);
        return (hr);
    }
    return (hr);
} // HRESULT VariantWriteToStream()


//*****************************************************************************
// Modified version of ATL's read code.
//*****************************************************************************
HRESULT VariantReadFromStream(VARIANT *pVal, IStream* pStream)
{
    _ASSERTE(pStream != NULL);
    HRESULT hr;
    hr = VariantClear(pVal);
    if (FAILED(hr))
        return hr;
    VARTYPE vtRead;
    hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
    if (FAILED(hr))
        return hr;

	pVal->vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			pVal->punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&pVal->punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	case VT_I8:
	case VT_UI8:
		cbRead = sizeof(__int64);
		break;
	default:
		break;
	}
	if (cbRead != 0)
		return pStream->Read((void*) &pVal->bVal, cbRead, NULL);

    // Try to read as BSTR.
    BSTR bstrRead=0;
    ULONG cb;
    ULONG cbStrLen;
    hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
    if (FAILED(hr))
        return hr;
    if (cbStrLen != 0)
    {
        //subtract size for terminating NULL which we wrote out
        //since SysAllocStringByteLen overallocates for the NULL
        bstrRead = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
        if (bstrRead == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = pStream->Read((void*) bstrRead, cbStrLen, &cb);
    }

	if (FAILED(hr))
		return hr;
	pVal->vt = VT_BSTR;
	pVal->bstrVal = bstrRead;
	if (vtRead != VT_BSTR)
		hr = VariantChangeType(pVal, pVal, 0, vtRead);
	return hr;
} // HRESULT VariantReadFromStream()
#endif // 0 -- variant pool


#if 0 && defined(_DEBUG)
//*****************************************************************************
// Checks all structures for validity.
//*****************************************************************************
void StgCodePool::AssertValid() const
{
    CCodeChunk  *pChunk;                // To follow chain.
    ULONG       iOffset;                // Offset within a chunk.
    ULONG       iTotal;                 // Total offset so far.
    ULONG       iLen;                   // Length of one element.


    if (m_pChain)
    {
        // If we have a chain, we'd better plan on freeing it.
        _ASSERTE(m_bFree);

        iTotal = 0;
        pChunk = m_pChain;
        // Iterate over chunks.
        do {
            iOffset = 0;

            // Is this chunk the last one in the chain?
            if (pChunk->m_pNext == 0)
            {
                _ASSERTE(m_pCurrent == pChunk);
                _ASSERTE(m_iOffsetCurChunk == iTotal);
            }

            // Iterate over elements in the chunk.
            iLen = 0;
            while (iOffset < pChunk->m_iSize && iLen >= 0)
            {
                // Length of an element.
                iLen = CPackedLen::GetLength(pChunk->m_data+iOffset);
                // Validate length.
                _ASSERTE(iLen != -1);
                if (iLen == -1) break;
                // On to next element (or end).
                iOffset += iLen + CPackedLen::Size(iLen);
            };

            // If not out due to bad length, check that exactly consumed chunk.
            if (iLen >= 0)
                _ASSERTE(iOffset == pChunk->m_iSize);

            iTotal += iOffset;

            // On to next chunk;
            pChunk = pChunk->m_pNext;
        } while (pChunk);
    }
    else
    if (m_pData)
    {
        _ASSERTE(m_iSize > 0);
        iOffset = 0;

        // Iterate over elements in the file data.
        do {
            // Length of an element.
            iLen = CPackedLen::GetLength(m_pData+iOffset);
            // Validate length.
            _ASSERTE(iLen >= 0);
            if (iLen < 0) break;
            // On to next element (or end).
            iOffset += iLen + CPackedLen::Size(iLen);
        } while (iOffset < m_iSize && iLen >= 0);

        // If not out due to bad length, check that exactly consumed chunk.
        if (iLen >= 0)
            _ASSERTE(iOffset == m_iSize);
    }

} // void StgCodePool::AssertValid()
#endif

//
// CInMemoryStream
//

ULONG STDMETHODCALLTYPE CInMemoryStream::Release()
{
    ULONG       cRef = InterlockedDecrement((long *) &m_cRef);
    if (cRef == 0)
    {
        if (m_dataCopy != NULL)
            delete [] m_dataCopy;
        
        delete this;
    }
    return (cRef);
} // ULONG STDMETHODCALLTYPE CInMemoryStream::Release()

HRESULT STDMETHODCALLTYPE CInMemoryStream::QueryInterface(REFIID riid, PVOID *ppOut)
{
    *ppOut = this;
    AddRef();
    return (S_OK);
} // HRESULT STDMETHODCALLTYPE CInMemoryStream::QueryInterface()

HRESULT STDMETHODCALLTYPE CInMemoryStream::Read(
                               void        *pv,
                               ULONG       cb,
                               ULONG       *pcbRead)
{
    ULONG       cbRead = min(cb, m_cbSize - m_cbCurrent);

    if (cbRead == 0)
        return (S_FALSE);
    memcpy(pv, (void *) ((long) m_pMem + m_cbCurrent), cbRead);
    if (pcbRead)
        *pcbRead = cbRead;
    m_cbCurrent += cbRead;
    return (S_OK);
} // HRESULT STDMETHODCALLTYPE CInMemoryStream::Read()

HRESULT STDMETHODCALLTYPE CInMemoryStream::Write(
                                const void  *pv,
                                ULONG       cb,
                                ULONG       *pcbWritten)
{
    if (m_cbCurrent + cb > m_cbSize)
        return (OutOfMemory());
    memcpy((BYTE *) m_pMem + m_cbCurrent, pv, cb);
    m_cbCurrent += cb;
    if (pcbWritten) *pcbWritten = cb;
    return (S_OK);
} // HRESULT STDMETHODCALLTYPE CInMemoryStream::Write()

HRESULT STDMETHODCALLTYPE CInMemoryStream::Seek(LARGE_INTEGER dlibMove,
                               DWORD       dwOrigin,
                               ULARGE_INTEGER *plibNewPosition)
{
    _ASSERTE(dwOrigin == STREAM_SEEK_SET || dwOrigin == STREAM_SEEK_CUR);
    _ASSERTE(dlibMove.QuadPart <= ULONG_MAX);

	if (dwOrigin == STREAM_SEEK_SET)
	{
		m_cbCurrent = (ULONG) dlibMove.QuadPart;
	}
	else
	if (dwOrigin == STREAM_SEEK_CUR)
	{
		m_cbCurrent+= (ULONG)dlibMove.QuadPart;
	}
    //HACK HACK HACK This allows dynamic IL to pass an assert in
    //TiggerStorage::WriteSignature.
    //
    // @todo: this is bad. This hack is here for a reason, and I can't
    // figure out how to repro the case and therefore fix it
    // properly. So I've added this "no hacks" thing for people who
    // need a stream that really works. We need to fix the problem in
    // TiggerStorage::WriteSignature and get this crap out of here
    // sometime soon, but now (1508.x integration hell) is not the
    // time.
    //
    // -- mikemag Fri Mar 17 11:58:57 2000
    //
	if (plibNewPosition)
	{
		if (m_noHacks)
			plibNewPosition->QuadPart = m_cbCurrent;
		else
			plibNewPosition->LowPart=0;
	}

	return (m_cbCurrent < m_cbSize) ? (S_OK) : E_FAIL;
} // HRESULT STDMETHODCALLTYPE CInMemoryStream::Seek()

HRESULT STDMETHODCALLTYPE CInMemoryStream::CopyTo(
                                 IStream     *pstm,
                                 ULARGE_INTEGER cb,
                                 ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    HRESULT     hr;
    // We don't handle pcbRead or pcbWritten.
    _ASSERTE(pcbRead == 0);
    _ASSERTE(pcbWritten == 0);

    _ASSERTE(cb.QuadPart <= ULONG_MAX);
    ULONG       cbTotal = min(static_cast<ULONG>(cb.QuadPart), m_cbSize - m_cbCurrent);
    ULONG       cbRead=min(1024, cbTotal);
    CQuickBytes rBuf;
    void        *pBuf = rBuf.Alloc(cbRead);
    if (pBuf == 0)
        return (PostError(OutOfMemory()));

    while (cbTotal)
        {
            if (cbRead > cbTotal)
                cbRead = cbTotal;
            if (FAILED(hr=Read(pBuf, cbRead, 0)))
                return (hr);
            if (FAILED(hr=pstm->Write(pBuf, cbRead, 0)))
                return (hr);
            cbTotal -= cbRead;
        }

    // Adjust seek pointer to the end.
    m_cbCurrent = m_cbSize;

    return (S_OK);
} // HRESULT STDMETHODCALLTYPE CInMemoryStream::CopyTo()

HRESULT CInMemoryStream::CreateStreamOnMemory(           // Return code.
                                    void        *pMem,                  // Memory to create stream on.
                                    ULONG       cbSize,                 // Size of data.
                                    IStream     **ppIStream,			          // Return stream object here.
									BOOL		fDeleteMemoryOnRelease
									)  
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return (PostError(OutOfMemory()));
    pIStream->InitNew(pMem, cbSize);
	if (fDeleteMemoryOnRelease)
	{
		// make sure this memory is allocated using new
		pIStream->m_dataCopy = (BYTE *)pMem;
	}
    *ppIStream = pIStream;
    return (S_OK);
} // HRESULT CInMemoryStream::CreateStreamOnMemory()

HRESULT CInMemoryStream::CreateStreamOnMemoryNoHacks(void *pMem,
                                                     ULONG cbSize,
                                                     IStream **ppIStream)
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return (PostError(OutOfMemory()));
    pIStream->InitNew(pMem, cbSize);
    pIStream->m_noHacks = true;
    *ppIStream = pIStream;
    return (S_OK);
}

HRESULT CInMemoryStream::CreateStreamOnMemoryCopy(void *pMem,
                                                  ULONG cbSize,
                                                  IStream **ppIStream)
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return (PostError(OutOfMemory()));

    // Init the stream.
    pIStream->m_cbCurrent = 0;
    pIStream->m_noHacks = true;
    pIStream->m_cbSize = cbSize;

    // Copy the data.
    pIStream->m_dataCopy = new BYTE[cbSize];

    if (pIStream->m_dataCopy == NULL)
    {
        delete pIStream;
        return (PostError(OutOfMemory()));
    }
    
    pIStream->m_pMem = pIStream->m_dataCopy;
    memcpy(pIStream->m_dataCopy, pMem, cbSize);

    *ppIStream = pIStream;
    return (S_OK);
}

//---------------------------------------------------------------------------
// CGrowableStream is a simple IStream implementation that grows as
// its written to. All the memory is contigious, so read access is
// fast. A grow does a realloc, so be aware of that if you're going to
// use this.
//---------------------------------------------------------------------------

CGrowableStream::CGrowableStream() 
{
    m_swBuffer = NULL;
    m_dwBufferSize = 0;
    m_dwBufferIndex = 0;
    m_cRef = 1;
}

CGrowableStream::~CGrowableStream() 
{
    // Destroy the buffer.
    if (m_swBuffer != NULL)
        free(m_swBuffer);

    m_swBuffer = NULL;
    m_dwBufferSize = 0;
}

ULONG STDMETHODCALLTYPE CGrowableStream::Release()
{
    ULONG       cRef = InterlockedDecrement((long *) &m_cRef);

    if (cRef == 0)
        delete this;

    return (cRef);
}

HRESULT STDMETHODCALLTYPE CGrowableStream::QueryInterface(REFIID riid,
                                                          PVOID *ppOut)
{
    *ppOut = this;
    AddRef();
    return (S_OK);
}

HRESULT CGrowableStream::Read(void HUGEP * pv,
                              ULONG cb,
                              ULONG * pcbRead)
{
    HRESULT hr = S_OK;
    DWORD dwCanReadBytes = 0;

    if (NULL == pv)
        return E_POINTER;

    // short-circuit a zero-length read or see if we are at the end
    if (cb == 0 || m_dwBufferIndex >= m_dwBufferSize)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;

        return S_OK;
    }

    // Figure out if we have enough room in the buffer
    dwCanReadBytes = cb;

    if ((dwCanReadBytes + m_dwBufferIndex) > m_dwBufferSize)
        dwCanReadBytes = (m_dwBufferSize - m_dwBufferIndex);

    // copy from our buffer to caller's buffer
    memcpy(pv, &m_swBuffer[m_dwBufferIndex], dwCanReadBytes);

    // adjust our current position
    m_dwBufferIndex += dwCanReadBytes;

    // if they want the info, tell them how many byte we read for them
    if (pcbRead != NULL)
        *pcbRead = dwCanReadBytes;

    return hr;
}

HRESULT CGrowableStream::Write(const void HUGEP * pv,
                               ULONG cb,
                               ULONG * pcbWritten)
{
    HRESULT hr = S_OK;
    DWORD dwActualWrite = 0;
    WCHAR *pszData = NULL;

    // avoid NULL write
    if (cb == 0)
    {
        hr = S_OK;
        goto Error;
    }

    // Check if our buffer is large enough
    _ASSERTE(m_dwBufferIndex <= m_dwBufferSize);
    
    if (cb > (m_dwBufferSize - m_dwBufferIndex))
    {
        // Grow at least a page at a time.
        DWORD size = m_dwBufferSize + max(cb, 4096);

        if (m_swBuffer == NULL)
            m_swBuffer = (char*) malloc(size);
        else
            m_swBuffer = (char*) realloc(m_swBuffer, (size));
            
        if (m_swBuffer == NULL)
        {
            m_dwBufferIndex = 0;
            m_dwBufferSize = 0;
            return E_OUTOFMEMORY;
        }
        
        m_dwBufferSize = size;
    }
    
    if ((pv != NULL) && (cb > 0))
    {
        // write to current position in the buffer
        memcpy(&m_swBuffer[m_dwBufferIndex], pv, cb);

        // now update our current index
        m_dwBufferIndex += cb;

        // in case they want to know the number of bytes written
        dwActualWrite = cb;
    }

Error:
    if (pcbWritten)
        *pcbWritten = dwActualWrite;

    return hr;
}

STDMETHODIMP CGrowableStream::Seek(LARGE_INTEGER dlibMove,
                                   DWORD dwOrigin,
                                   ULARGE_INTEGER * plibNewPosition)
{
    // a Seek() call on STREAM_SEEK_CUR and a dlibMove == 0 is a
    // request to get the current seek position.
    if ((dwOrigin == STREAM_SEEK_CUR && dlibMove.LowPart == 0) &&
        (dlibMove.HighPart == 0) && 
        (NULL != plibNewPosition))
    {
        goto Error;        
    }

    // we don't support STREAM_SEEK_SET (beginning of buffer)
    if (dwOrigin != STREAM_SEEK_SET)
        return E_NOTIMPL;

    // did they ask to seek past end of buffer?
    if (dlibMove.LowPart > m_dwBufferSize)
        return E_UNEXPECTED;

    // we ignore the high part of the large integer
    m_dwBufferIndex = dlibMove.LowPart;

Error:
    if (NULL != plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = m_dwBufferIndex;
    }

    return S_OK;
}
STDMETHODIMP CGrowableStream::SetSize(ULARGE_INTEGER libNewSize)
{
    DWORD dwNewSize = libNewSize.LowPart;

    _ASSERTE(libNewSize.HighPart == 0);

    // we don't support large allocations
    if (libNewSize.HighPart > 0)
        return E_OUTOFMEMORY;

    if (m_swBuffer == NULL)         // no existing contents or size
        m_swBuffer = (char*) malloc(dwNewSize);
    else                            // existing allocation, must realloc
        m_swBuffer = (char *) realloc(m_swBuffer, (dwNewSize));
        
    if (m_swBuffer == NULL)
    {
        m_dwBufferIndex = 0;
        m_dwBufferSize = 0;
        return E_OUTOFMEMORY;
    }
    else
        m_dwBufferSize = dwNewSize;
        
    return S_OK;
}

STDMETHODIMP CGrowableStream::Stat(STATSTG * pstatstg, DWORD grfStatFlag)
{
    if (NULL == pstatstg)
        return E_POINTER;

    // this is the only useful information we hand out - the size of the stream
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_dwBufferSize;
    pstatstg->type = STGTY_STREAM;

    // we ignore the grfStatFlag - we always assume STATFLAG_NONAME
    pstatstg->pwcsName = NULL;

    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stresslog.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*************************************************************************************/
/*                                   StressLog.cpp                                   */
/*************************************************************************************/

/*************************************************************************************/

#include "stdafx.h"			// precompiled headers
#include "switches.h"
#include "StressLog.h"

#ifdef STRESS_LOG

StressLog StressLog::theLog = { 0, 0, 0, TLS_OUT_OF_INDEXES, 0, 0 };	
const static unsigned __int64 RECYCLE_AGE = 0x40000000L;		// after a billion cycles, we can discard old threads

/*********************************************************************************/
#ifdef _X86_

/* This is like QueryPerformanceCounter but a lot faster */
__forceinline __declspec(naked) unsigned __int64 getTimeStamp() {
   __asm {
        RDTSC   // read time stamp counter
        ret
    };
}

#else
unsigned __int64 getTimeStamp() {
	LARGE_INTEGER ret = 0;
	QueryPerformanceCounter(&ret);
	return count.ret;
}

#endif

/*********************************************************************************/
void StressLog::Enter() {

		// spin to aquire the lock
	int i = 20;
	while (InterlockedCompareExchange(&theLog.lock, 1, 0) != 0) {
		SwitchToThread();	
		if  (--i < 0) Sleep(2);
	}
}

void StressLog::Leave() {

	theLog.lock = 0;
}


/*********************************************************************************/
void StressLog::Initialize(unsigned facilities,  unsigned logSize) {

	Enter();
	if (theLog.TLSslot == TLS_OUT_OF_INDEXES) {
		unsigned aSlot = TlsAlloc();
		if (aSlot != TLS_OUT_OF_INDEXES) {
			if (logSize < 0x1000)
				logSize = 0x1000;
			theLog.size = logSize;
			theLog.facilitiesToLog = facilities;
			theLog.deadCount = 0;
			theLog.TLSslot = aSlot;
		}
	}
	Leave();
}

/*********************************************************************************/
void StressLog::Terminate() {

	if (theLog.TLSslot != TLS_OUT_OF_INDEXES) {
		theLog.facilitiesToLog = 0;

		Enter(); Leave();		// The Enter() Leave() forces a memory barrier on weak memory model systems
								// we want all the other threads to notice that facilitiesToLog is now zero

				// This is not strictly threadsafe, since there is no way of insuring when all the
				// threads are out of logMsg.  In practice, since they can no longer enter logMsg
				// and there are no blocking operations in logMsg, simply sleeping will insure
				// that everyone gets out. 
		Sleep(2);
		Enter();	

			// Free the log memory
		ThreadStressLog* ptr = theLog.logs;
		theLog.logs = 0;
		while(ptr != 0) {
			ThreadStressLog* tmp = ptr;
			ptr = ptr->next;
			delete [] tmp;
		}

		if (theLog.TLSslot != TLS_OUT_OF_INDEXES)
			TlsFree(theLog.TLSslot);
		theLog.TLSslot = TLS_OUT_OF_INDEXES;
		Leave();
	}
}

/*********************************************************************************/
/* create a new thread stress log buffer associated with Thread local slot TLSslot, for the Stress log */

ThreadStressLog* StressLog::CreateThreadStressLog() {

	ThreadStressLog* msgs = 0;
	Enter();

	if (theLog.facilitiesToLog == 0)		// Could be in a race with Terminate
		goto LEAVE;

	_ASSERTE(theLog.TLSslot != TLS_OUT_OF_INDEXES);	// because facilitiesToLog is != 0

	BOOL skipInsert = FALSE;

		// See if we can recycle a dead thread
	if (theLog.deadCount > 0) {
		unsigned __int64 recycleAge = getTimeStamp() - RECYCLE_AGE;
		msgs = theLog.logs;
		while(msgs != 0) {
			if (msgs->isDead && msgs->Prev(msgs->curPtr)->timeStamp < recycleAge) {
				skipInsert = TRUE;
				--theLog.deadCount;
				msgs->isDead = FALSE;
				break;
			}
			msgs = msgs->next;
		}
	}

	if (msgs == 0)  {
		msgs = (ThreadStressLog*) new char[theLog.size];
		if (msgs == 0) 
			goto LEAVE;
		
		msgs->endPtr = &msgs->startPtr[(theLog.size - sizeof(ThreadStressLog)) / sizeof(StressMsg)];
		msgs->readPtr = 0;
		msgs->isDead = FALSE;
	}

	memset(msgs->startPtr, 0, (msgs->endPtr-msgs->startPtr)*sizeof(StressMsg));
	msgs->curPtr = msgs->startPtr;
	msgs->threadId = GetCurrentThreadId();

	if (!TlsSetValue(theLog.TLSslot, msgs)) {
		msgs->isDead = TRUE;
		theLog.deadCount++;
		msgs = 0;
	}

	if (!skipInsert) {
			// Put it into the stress log
		msgs->next = theLog.logs;
		theLog.logs = msgs;
	}

LEAVE:
	Leave();
	return msgs;
}
	
/*********************************************************************************/
/* static */
void StressLog::ThreadDetach() {

	if (theLog.facilitiesToLog == 0) 
		return;
		
	Enter();
	if (theLog.facilitiesToLog == 0) {		// log is not active.  
		Leave();
		return;
	}
	
	_ASSERTE(theLog.TLSslot != TLS_OUT_OF_INDEXES);	// because facilitiesToLog is != 0

	ThreadStressLog* msgs = (ThreadStressLog*) TlsGetValue(theLog.TLSslot);
	if (msgs != 0) {
		LogMsg("******* DllMain THREAD_DETACH called Thread dieing *******\n", 0);

		msgs->isDead = TRUE;
		theLog.deadCount++;
	}

	Leave();
}

/*********************************************************************************/
/* fetch a buffer that can be used to write a stress message, it is thread safe */

/* static */
void StressLog::LogMsg(const char* format, void* data1, void* data2, void* data3, void* data4) {

	ThreadStressLog* msgs = (ThreadStressLog*) TlsGetValue(theLog.TLSslot);
	if (msgs == 0) {
		msgs = CreateThreadStressLog();
		if (msgs == 0)
			return;
	}

		// First Entry
	msgs->curPtr->format = format;
	msgs->curPtr->data = data1;
	msgs->curPtr->moreData.data2 = data2;
	msgs->curPtr->moreData.data3 = data3;
	msgs->curPtr = msgs->Next(msgs->curPtr);

		// Second Entry
	msgs->curPtr->format = ThreadStressLog::continuationMsg();
	msgs->curPtr->data = data4;
	msgs->curPtr->timeStamp = getTimeStamp();
	msgs->curPtr = msgs->Next(msgs->curPtr);
}


/* static */
void StressLog::LogMsg(const char* format, void* data) {

	ThreadStressLog* msgs = (ThreadStressLog*) TlsGetValue(theLog.TLSslot);
	if (msgs == 0) {
		msgs = CreateThreadStressLog();
		if (msgs == 0)
			return;
	}

	msgs->curPtr->format = format;
	msgs->curPtr->data = data;
	msgs->curPtr->timeStamp = getTimeStamp();
	msgs->curPtr = msgs->Next(msgs->curPtr);
}

#endif // STRESS_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stgpoolreadonly.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgPoolReadOnly.cpp
//
// Read only pools are used to reduce the amount of data actually required in the database.
// 
//*****************************************************************************
#include "stdafx.h"                     // Standard include.
#include <StgPool.h>                    // Our interface definitions.
#include <basetsd.h>					// For UINT_PTR typedef
#include "metadatatracker.h"
//
//
// StgPoolReadOnly
//
//

#ifdef METADATATRACKER_ENABLED
MetaDataTracker  *MetaDataTracker::m_MDTrackers = NULL;
DWORD MetaDataTracker::s_trackerOptions = 0;
HANDLE MetaDataTracker::s_MDErrFile = 0;
BOOL displayMDAccessStats = NULL;
HMODULE     MetaDataTracker::m_imagehlp = NULL;
BOOL        MetaDataTracker::m_symInit = FALSE;
CRITICAL_SECTION MetaDataTracker::MetadataTrackerCriticalSection;
DWORD       MetaDataTracker::s_MDTrackerCriticalSectionInited = 0;
BOOL        MetaDataTracker::s_MDTrackerCriticalSectionInitedDone = FALSE;
MDHintFileHandle *MetaDataTracker::s_EmptyMDHintFileHandle = NULL;

BOOL        (*MetaDataTracker::m_pStackWalk)(DWORD MachineType,
                                    HANDLE hProcess,
                                    HANDLE hThread,
                                    LPSTACKFRAME StackFrame,
                                    PVOID ContextRecord,
                                    PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                    PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                    PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                    PTRANSLATE_ADDRESS_ROUTINE TranslateAddress) = NULL;
DWORD       (*MetaDataTracker::m_pUnDecorateSymbolName)(PCSTR DecoratedName,  
                                                   PSTR UnDecoratedName,  
                                                   DWORD UndecoratedLength,  
                                                   DWORD Flags) = NULL;        
BOOL        (*MetaDataTracker::m_pSymInitialize)(HANDLE hProcess,     
                                            PSTR UserSearchPath,  
                                            BOOL fInvadeProcess);  
DWORD       (*MetaDataTracker::m_pSymSetOptions)(DWORD SymOptions) = NULL;   
BOOL        (*MetaDataTracker::m_pSymCleanup)(HANDLE hProcess) = NULL;
BOOL        (*MetaDataTracker::m_pSymGetLineFromAddr)(HANDLE hProcess,
                                                 DWORD dwAddr,
                                                 PDWORD pdwDisplacement,
                                                 PIMAGEHLP_LINE Line) = NULL;
BOOL        (*MetaDataTracker::m_pSymGetSymFromAddr)(HANDLE hProcess,
                                                DWORD dwAddr,
                                                PDWORD pdwDisplacement,
                                                PIMAGEHLP_SYMBOL Symbol);
PVOID       (*MetaDataTracker::m_pSymFunctionTableAccess)(HANDLE hProcess,
                                                     DWORD AddrBase) = NULL;
DWORD       (*MetaDataTracker::m_pSymGetModuleBase)(HANDLE hProcess,
                                               DWORD Address) = NULL;
wchar_t* MetaDataTracker::contents[] = 
    {
#undef MiniMdTable
#define MiniMdTable(x) L#x,
          MiniMdTables()
#undef MiniMdTable

         L"String pool",
         L"User String pool",
         L"Guid pool",
         L"Blob pool"
    };

heapAccess* MetaDataTracker::orphanedHeapAccess = 0;
BOOL MetaDataTracker::s_bMetaDataTrackerInited = FALSE;


#endif

const BYTE StgPoolSeg::m_zeros[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};


//*****************************************************************************
// Free any memory we allocated.
//*****************************************************************************
StgPoolReadOnly::~StgPoolReadOnly()
{
}


//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
HRESULT StgPoolReadOnly::InitOnMemReadOnly(// Return code.
        void        *pData,             // Predefined data.
        ULONG       iSize)              // Size of data.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == m_zeros);

    // Create case requires no further action.
    if (!pData)
        return (E_INVALIDARG);

    m_pSegData = reinterpret_cast<BYTE*>(pData);
    m_cbSegSize = iSize;
    m_cbSegNext = iSize;
    return (S_OK);
}

//*****************************************************************************
// Prepare to shut down or reinitialize.
//*****************************************************************************
void StgPoolReadOnly::Uninit()
{
	m_pSegData = (BYTE*)m_zeros;
	m_pNextSeg = 0;
}


//*****************************************************************************
// Convert a string to UNICODE into the caller's buffer.
//*****************************************************************************
HRESULT StgPoolReadOnly::GetStringW(      // Return code.
    ULONG       iOffset,                // Offset of string in pool.
    LPWSTR      szOut,                  // Output buffer for string.
    int         cchBuffer)              // Size of output buffer.
{
    LPCSTR      pString;                // The string in UTF8.
    int         iChars;
    pString = GetString(iOffset);
    iChars = ::WszMultiByteToWideChar(CP_UTF8, 0, pString, -1, szOut, cchBuffer);
    if (iChars == 0)
        return (BadError(HRESULT_FROM_NT(GetLastError())));
    return (S_OK);
}


//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgPoolReadOnly::GetGuid(			// Pointer to guid in pool.
	ULONG		iIndex)					// 1-based index of Guid in pool.
{
    if (iIndex == 0)
        return (reinterpret_cast<GUID*>(const_cast<BYTE*>(m_zeros)));

	// Convert to 0-based internal form, defer to implementation.
	return (GetGuidi(iIndex-1));
}


//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgPoolReadOnly::GetGuidi(		// Pointer to guid in pool.
	ULONG		iIndex)					// 0-based index of Guid in pool.
{
	ULONG iOffset = iIndex * sizeof(GUID);
    _ASSERTE(IsValidOffset(iOffset));
    return (reinterpret_cast<GUID*>(GetData(iOffset)));
}


//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
void *StgPoolReadOnly::GetBlob(             // Pointer to blob's bytes.
    ULONG       iOffset,                // Offset of blob in pool.
    ULONG       *piSize)                // Return size of blob.
{
    void const  *pData = NULL;          // Pointer to blob's bytes.

    if (iOffset == 0)
    {
        *piSize = 0;
        return (const_cast<BYTE*>(m_zeros));
    }

    // Is the offset within this heap?
    //_ASSERTE(IsValidOffset(iOffset));
	if(!IsValidOffset(iOffset))
	{
#ifdef _DEBUG
        if(REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1))
		    _ASSERTE(!"Invalid Blob Offset");
#endif
		iOffset = 0;
	}

    // Get size of the blob (and pointer to data).
    *piSize = CPackedLen::GetLength(GetData(iOffset), &pData);

	// @todo: meichint
	// Do we need to perform alignment check here??
	// I don't want to introduce IsAligned to just for debug checking.
	// Sanity check the return alignment.
	// _ASSERTE(!IsAligned() || (((UINT_PTR)(pData) % sizeof(DWORD)) == 0));

    // Return pointer to data.
    return (const_cast<void*>(pData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\sxshelpers.cpp ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
//*****************************************************************************
// 
//  sxshelpers.cpp
//
//  Some helping classes and methods for SxS in mscoree and mscorwks/mscorsvr
//*****************************************************************************

#include "stdafx.h"
#include "utilcode.h"
#include "sxsapi.h"
#include "sxshelpers.h"

// forward declaration
BOOL TranslateWin32AssemblyIdentityToFusionDisplayName(LPWSTR *ppwzFusionDisplayName, PCWSTR lpWin32AssemblyIdentity);

// The initial size of the buffer passed to SxsLookupClrGuid.
#define INIT_GUID_LOOKUP_BUFFER_SIZE 512

// Function pointer to the function to lookup a CLR type by GUID in the unmanaged
// fusion activation context.
PFN_SXS_LOOKUP_CLR_GUID g_pfnLookupGuid = NULL;
volatile BOOL g_fSxSInfoInitialized = FALSE;

// And Here are the functions for getting shim info from 
// Win32 activation context

//  FindShimInfoFromWin32
//
//  This method is used in ComInterop. If a COM client calls 
//  CoCreateInstance on a managed COM server, we will use this method
//  trying to find required info of the managed COM server from Win32 subsystem.
//  If this fails, we will fall back to query the registry. 
//
//  Parameters:
//      rclsid:              [in]  The CLSID of the managed COM server
//      bLoadRecord:         [in]  Set to TRUE if we are looking for a record
//      *ppwzRuntimeVersion: [out] Runtime version
//      *ppwzClassName:      [out] Class name
//      *ppwzAssemblyString: [out] Assembly display name
//  Return:
//      FAILED(hr) if cannot find shim info from Win32
//      SUCCEEDED(HR) if shim info is found from Win32

HRESULT
FindShimInfoFromWin32(
    REFCLSID rClsid,
    BOOL bLoadRecord, 
    LPWSTR *ppwszRuntimeVersion,
    LPWSTR *ppwszClassName,
    LPWSTR *ppwszAssemblyString
    )
{
    CQuickBytes rDataBuffer;
    SIZE_T cbWritten;
    HMODULE hmSxsDll = NULL;
    HRESULT hr = S_OK;
    PCSXS_GUID_INFORMATION_CLR pFoundInfo = NULL;
    SIZE_T cch;
    GUID MyGuid = rClsid;
    DWORD dwFlags = bLoadRecord ? SXS_LOOKUP_CLR_GUID_FIND_SURROGATE : SXS_LOOKUP_CLR_GUID_FIND_ANY;

    if (!ppwszRuntimeVersion && !ppwszClassName && !ppwszAssemblyString)
        IfFailGo(E_INVALIDARG);

    if (ppwszRuntimeVersion)
        *ppwszRuntimeVersion = NULL;

    if (ppwszClassName)
        *ppwszClassName = NULL;

    if (ppwszAssemblyString)
        *ppwszAssemblyString = NULL;

    // If we haven't initialized the SxS info yet, then do so now.
    if (!g_fSxSInfoInitialized)
    {
        hmSxsDll = WszLoadLibrary(SXS_DLL_NAME_W);
        if (hmSxsDll != NULL)
        {
            // Lookup the SxsLookupClrGuid function in the SxS DLL.
            g_pfnLookupGuid = (PFN_SXS_LOOKUP_CLR_GUID)GetProcAddress(hmSxsDll, SXS_LOOKUP_CLR_GUID);
        }

        // The SxS info has been initialized.
        g_fSxSInfoInitialized = TRUE;
    }

    // If we don't have the proc address of SxsLookupClrGuid, then return a failure.
    if (g_pfnLookupGuid == NULL)
        IfFailGo(E_FAIL);

    // Resize the CQuickBytes to the initial buffer size.
    rDataBuffer.ReSize(INIT_GUID_LOOKUP_BUFFER_SIZE);

    if (!g_pfnLookupGuid(dwFlags, &MyGuid, INVALID_HANDLE_VALUE, rDataBuffer.Ptr(), rDataBuffer.Size(), &cbWritten))
    {
        const DWORD dwLastError = ::GetLastError();

        // Failed b/c we need more space? Expand and try again.
        if (dwLastError == ERROR_INSUFFICIENT_BUFFER) 
        {
            rDataBuffer.ReSize(cbWritten);

            // Still failed even with enough space? Bummer.
            if (!g_pfnLookupGuid(0, &MyGuid, INVALID_HANDLE_VALUE, rDataBuffer.Ptr(), rDataBuffer.Size(), &cbWritten))
                IfFailGo(E_FAIL);
        }
        // All other failures are real failures - probably the section isn't present
        // or some other problem.
        else
        {
            IfFailGo(E_FAIL);
        }
    }

    pFoundInfo = (PCSXS_GUID_INFORMATION_CLR)rDataBuffer.Ptr();

    if (pFoundInfo->dwFlags == SXS_GUID_INFORMATION_CLR_FLAG_IS_SURROGATE && ppwszRuntimeVersion)
    {
        // Surrogate does not have runtime version information !!!
        IfFailGo(E_FAIL);
    }

    //
    // This is special - translate the win32 assembly name into a managed
    // assembly identity.
    //
    if (ppwszAssemblyString && pFoundInfo->pcwszAssemblyIdentity)
    {
        if (!TranslateWin32AssemblyIdentityToFusionDisplayName(ppwszAssemblyString, pFoundInfo->pcwszAssemblyIdentity))
            IfFailGo(E_FAIL);
    }    

    //
    // For each field, allocate the outbound pointer and call through.
    //
    if (ppwszClassName && pFoundInfo->pcwszTypeName)
    {
        cch = wcslen(pFoundInfo->pcwszTypeName);

        if (cch > 0)
        {
            IfNullGo(*ppwszClassName = new WCHAR[cch + 1]);
            wcscpy(*ppwszClassName, pFoundInfo->pcwszTypeName);
        }
        else
            IfFailGo(E_FAIL);
    }    

    if (ppwszRuntimeVersion && pFoundInfo->pcwszRuntimeVersion)
    {
        cch = wcslen(pFoundInfo->pcwszRuntimeVersion);

        if (cch > 0)
        {
            IfNullGo(*ppwszRuntimeVersion = new WCHAR[cch + 1]);
            wcscpy(*ppwszRuntimeVersion, pFoundInfo->pcwszRuntimeVersion);
        }
        else
            IfFailGo(E_FAIL);
    }    

ErrExit:
    //
    // Deallocate in case of failure
    //
    if (FAILED(hr))
    {
        if (ppwszRuntimeVersion && *ppwszRuntimeVersion)
        {
            delete [] *ppwszRuntimeVersion;
            *ppwszRuntimeVersion = NULL;
        }
        if (ppwszAssemblyString && *ppwszAssemblyString)
        {
            delete [] *ppwszAssemblyString;
            *ppwszAssemblyString = NULL;
        }
        if (ppwszClassName && *ppwszClassName)
        {
            delete [] *ppwszClassName;
            *ppwszClassName = NULL;
        }
    }

    return hr;
}

// TranslateWin32AssemblyIdentityToFusionDisplayName
//
// Culture info is missing in the assemblyIdentity returned from win32,
// So Need to do a little more work here to get the correct fusion display name
//
// replace "language=" in assemblyIdentity to "culture=" if any.
// If "language=" is not present in assemblyIdentity, add "culture=neutral" 
// to it.
//
// Also check other attributes as well. 
//
// Parameters:
//     ppwzFusionDisplayName: the corrected output of assembly displayname
//     lpWin32AssemblyIdentity: input assemblyIdentity returned from win32
//
// returns:
//     TRUE if the conversion is done.
//     FALSE otherwise

BOOL TranslateWin32AssemblyIdentityToFusionDisplayName(LPWSTR *ppwzFusionDisplayName, PCWSTR lpWin32AssemblyIdentity)
{
    ULONG size = 0;
    LPWSTR lpAssemblyIdentityCopy = NULL;
    LPWSTR lpVersionKey = L"version=";
    LPWSTR lpPublicKeyTokenKey = L"publickeytoken=";
    LPWSTR lpCultureKey = L"culture=";
    LPWSTR lpNeutral = L"neutral";
    LPWSTR lpLanguageKey = L"language=";
    LPWSTR lpMatch = NULL;
    LPWSTR lpwzFusionDisplayName = NULL;
    
    if (ppwzFusionDisplayName == NULL) return FALSE;
    *ppwzFusionDisplayName = NULL;
    
    if (lpWin32AssemblyIdentity == NULL) return FALSE;

    size = wcslen(lpWin32AssemblyIdentity);
    if (size == 0) return FALSE;

    // make a local copy
    lpAssemblyIdentityCopy = new WCHAR[size+1];
    if (!lpAssemblyIdentityCopy)
        return FALSE;

    wcscpy(lpAssemblyIdentityCopy, lpWin32AssemblyIdentity);

    // convert to lower case
    _wcslwr(lpAssemblyIdentityCopy);

    // check if "version" key is presented
    if (!wcsstr(lpAssemblyIdentityCopy, lpVersionKey))
    {
        // version is not presented, append it
        size += wcslen(lpVersionKey)+8; // length of ","+"0.0.0.0"
        lpwzFusionDisplayName = new WCHAR[size+1];
        if (!lpwzFusionDisplayName)
        {
            // clean up
            delete[] lpAssemblyIdentityCopy;
            return FALSE;
        }

        //copy old one
        wcscpy(lpwzFusionDisplayName, lpAssemblyIdentityCopy);
        wcscat(lpwzFusionDisplayName, L",");
        wcscat(lpwzFusionDisplayName, lpVersionKey);
        wcscat(lpwzFusionDisplayName, L"0.0.0.0");

        // delete the old copy
        delete[] lpAssemblyIdentityCopy;

        // lpAssemblyIdentityCopy has the new copy
        lpAssemblyIdentityCopy = lpwzFusionDisplayName;
        lpwzFusionDisplayName = NULL;
    }

    // check if "publickeytoken" key is presented
    if (!wcsstr(lpAssemblyIdentityCopy, lpPublicKeyTokenKey))
    {
        // publickeytoken is not presented, append it
        size += wcslen(lpPublicKeyTokenKey)+5; //length of ","+"null"
        lpwzFusionDisplayName = new WCHAR[size+1];
        if (!lpwzFusionDisplayName)
        {
            // clean up
            delete[] lpAssemblyIdentityCopy;
            return FALSE;
        }

        // copy the old one
        wcscpy(lpwzFusionDisplayName, lpAssemblyIdentityCopy);
        wcscat(lpwzFusionDisplayName, L",");
        wcscat(lpwzFusionDisplayName, lpPublicKeyTokenKey);
        wcscat(lpwzFusionDisplayName, L"null");

        // delete the old copy
        delete[] lpAssemblyIdentityCopy;

        // lpAssemblyIdentityCopy has the new copy
        lpAssemblyIdentityCopy = lpwzFusionDisplayName;
        lpwzFusionDisplayName = NULL;
    }
    
    if (wcsstr(lpAssemblyIdentityCopy, lpCultureKey))
    {
        // culture info is already included in the assemblyIdentity
        // nothing need to be done
        lpwzFusionDisplayName = lpAssemblyIdentityCopy;
        *ppwzFusionDisplayName = lpwzFusionDisplayName;
        return TRUE;
    }

    if ((lpMatch = wcsstr(lpAssemblyIdentityCopy, lpLanguageKey)) !=NULL )
    {
        // language info is included in the assembly identity
        // need to replace it with culture
        
        // final size 
        size += wcslen(lpCultureKey)-wcslen(lpLanguageKey);
        lpwzFusionDisplayName = new WCHAR[size + 1];
        if (!lpwzFusionDisplayName)
        {
            // clean up
            delete[] lpAssemblyIdentityCopy;
            return FALSE;
        }
        wcsncpy(lpwzFusionDisplayName, lpAssemblyIdentityCopy, lpMatch-lpAssemblyIdentityCopy);
        lpwzFusionDisplayName[lpMatch-lpAssemblyIdentityCopy] = L'\0';
        wcscat(lpwzFusionDisplayName, lpCultureKey);
        wcscat(lpwzFusionDisplayName, lpMatch+wcslen(lpLanguageKey));
        *ppwzFusionDisplayName = lpwzFusionDisplayName;
        
        // clean up
        delete[] lpAssemblyIdentityCopy;
        return TRUE;
    }
    else 
    {
        // neither culture or language key is presented
        // let us attach culture info key to the identity
        size += wcslen(lpCultureKey)+wcslen(lpNeutral)+1;
        lpwzFusionDisplayName = new WCHAR[size + 1];
        if (!lpwzFusionDisplayName)
        {
            // clean up
            delete[] lpAssemblyIdentityCopy;
            return FALSE;
        }
            
        wcscpy(lpwzFusionDisplayName, lpAssemblyIdentityCopy);
        wcscat(lpwzFusionDisplayName, L",");
        wcscat(lpwzFusionDisplayName, lpCultureKey);
        wcscat(lpwzFusionDisplayName, lpNeutral);
        *ppwzFusionDisplayName = lpwzFusionDisplayName;

        // clean up
        delete[] lpAssemblyIdentityCopy;
        return TRUE;
    }
}

//****************************************************************************
//  AssemblyVersion
//  
//  class to handle assembly version
//  Since only functions in this file will use it,
//  we declare it in the cpp file so other people won't use it.
//
//****************************************************************************
class AssemblyVersion
{
    public:
        // constructors
        AssemblyVersion();

        AssemblyVersion(AssemblyVersion& version);
        
        // Init
        HRESULT Init(LPCWSTR pwzVersion);
        HRESULT Init(WORD major, WORD minor, WORD build, WORD revision);

        // assign operator
        AssemblyVersion& operator=(const AssemblyVersion& version);

        // Comparison operator
        friend BOOL operator==(const AssemblyVersion& version1,
                               const AssemblyVersion& version2);
        friend BOOL operator>=(const AssemblyVersion& version1,
                              const AssemblyVersion& version2);
        
        // Return a string representation of version
        // 
        // Note: This method allocates memory.
        // Caller is responsible to free the memory
        HRESULT ToString(LPWSTR *ppwzVersion);

        HRESULT ToString(DWORD positions, LPWSTR *ppwzVersion);

    private:

        // pwzVersion must have format of "a.b.c.d",
        // where a,b,c,d are all numbers
        HRESULT ValidateVersion(LPCWSTR pwzVersion);

    private:
        WORD        _major;
        WORD        _minor;
        WORD        _build;
        WORD        _revision;
};

AssemblyVersion::AssemblyVersion()
:_major(0)
,_minor(0)
,_build(0)
,_revision(0)
{
}

AssemblyVersion::AssemblyVersion(AssemblyVersion& version)
{
    _major = version._major;
    _minor = version._minor;
    _build = version._build;
    _revision = version._revision;
}

// Extract version info from pwzVersion, expecting "a.b.c.d",
// where a,b,c and d are all digits.
HRESULT AssemblyVersion::Init(LPCWSTR pcwzVersion)
{
    HRESULT hr = S_OK;
    LPWSTR  pwzVersionCopy = NULL;
    LPWSTR  pwzTokens = NULL;
    LPWSTR  pwzToken = NULL;
    int size = 0;
    int iVersion = 0;

    if ((pcwzVersion == NULL) || (*pcwzVersion == L'\0'))
        IfFailGo(E_INVALIDARG);

    IfFailGo(ValidateVersion(pcwzVersion));
    
    size = wcslen(pcwzVersion);
    
    IfNullGo(pwzVersionCopy = new WCHAR[size + 1]);
   
    wcscpy(pwzVersionCopy, pcwzVersion);
    pwzTokens = pwzVersionCopy;
    
    // parse major version
    pwzToken = wcstok(pwzTokens, L".");
    if (pwzToken != NULL)
    {
        iVersion = _wtoi(pwzToken);
        if (iVersion > 0xffff)
            IfFailGo(E_INVALIDARG);
        _major = (WORD)iVersion;
    }

    // parse minor version
    pwzToken = wcstok(NULL, L".");
    if (pwzToken != NULL)
    {
        iVersion = _wtoi(pwzToken);
        if (iVersion > 0xffff)
            IfFailGo(E_INVALIDARG);
        _minor = (WORD)iVersion;
    }

    // parse build version
    pwzToken = wcstok(NULL, L".");
    if (pwzToken != NULL)
    {
        iVersion = _wtoi(pwzToken);
        if (iVersion > 0xffff)
            IfFailGo(E_INVALIDARG);
        _build = (WORD)iVersion;
    }

    // parse revision version
    pwzToken = wcstok(NULL, L".");
    if (pwzToken != NULL)
    {
        iVersion = _wtoi(pwzToken);
        if (iVersion > 0xffff)
            IfFailGo(E_INVALIDARG);
        _revision = (WORD)iVersion;
    }
   
ErrExit:
    if (pwzVersionCopy)
        delete[] pwzVersionCopy;
    return hr;
}

HRESULT AssemblyVersion::Init(WORD major, WORD minor, WORD build, WORD revision)
{
    _major = major;
    _minor = minor;
    _build = build;
    _revision = revision;

    return S_OK;
}

AssemblyVersion& AssemblyVersion::operator=(const AssemblyVersion& version)
{
    _major = version._major;
    _minor = version._minor;
    _build = version._build;
    _revision = version._revision;

    return *this;
}

// pcwzVersion must be in format of a.b.c.d, where a, b, c, d are numbers
HRESULT AssemblyVersion::ValidateVersion(LPCWSTR pcwzVersion)
{
    LPCWSTR   pwCh = pcwzVersion;
    INT       dots = 0; // number of dots
    BOOL      bIsDot = FALSE; // is previous char a dot?

    // first char cannot be .
    if (*pwCh == L'.')
        return E_INVALIDARG;
    
    for(;*pwCh != L'\0';pwCh++)
    {
        if (*pwCh == L'.')
        {
            if (bIsDot) // ..
                return E_INVALIDARG;
            else 
            {
                dots++;
                bIsDot = TRUE;
            }
        }
        else if (!iswdigit(*pwCh))
            return E_INVALIDARG;
        else
            bIsDot = FALSE;
    }

    if (dots > 3)
        return E_INVALIDARG;

    return S_OK;
}

// Return a string representation of version
HRESULT AssemblyVersion::ToString(LPWSTR *ppwzVersion)
{
    return ToString(4, ppwzVersion);
}

HRESULT AssemblyVersion::ToString(DWORD positions, LPWSTR *ppwzVersion)
{
    HRESULT hr = S_OK;
    // maximum version string size
    DWORD size = sizeof("65535.65535.65535.65535"); 
    DWORD ccVersion = 0;
    LPWSTR pwzVersion = NULL;

    if (ppwzVersion == NULL)
        IfFailGo(E_INVALIDARG);
    
    *ppwzVersion = NULL;

    pwzVersion = new WCHAR[size + 1];
    IfNullGo(pwzVersion);

    switch(positions)
    {
    case 1:
        _snwprintf(pwzVersion, size, L"%hu", 
                   _major);
        break;
    case 2:
        _snwprintf(pwzVersion, size, L"%hu.%hu", 
                   _major, _minor);
        break;
    case 3:
        _snwprintf(pwzVersion, size, L"%hu.%hu.%hu", 
                   _major, _minor, _build);
        break;
    case 4:
        _snwprintf(pwzVersion, size, L"%hu.%hu.%hu.%hu", 
                   _major, _minor, _build, _revision);
        break;
    }

    *ppwzVersion = pwzVersion;

ErrExit:
    return hr;
}
    
BOOL operator==(const AssemblyVersion& version1, 
                const AssemblyVersion& version2)
{
    return ((version1._major == version2._major)
            && (version1._minor == version2._minor)
            && (version1._build == version2._build)
            && (version1._revision == version2._revision));
}

BOOL operator>=(const AssemblyVersion& version1,
                const AssemblyVersion& version2)
{
    ULONGLONG ulVersion1;
    ULONGLONG ulVersion2;

    ulVersion1 = version1._major;
    ulVersion1 = (ulVersion1<<16)|version1._minor;
    ulVersion1 = (ulVersion1<<16)|version1._build;
    ulVersion1 = (ulVersion1<<16)|version1._revision;

    ulVersion2 = version2._major;
    ulVersion2 = (ulVersion2<<16)|version2._minor;
    ulVersion2 = (ulVersion2<<16)|version2._build;
    ulVersion2 = (ulVersion2<<16)|version2._revision;

    return (ulVersion1 >= ulVersion2);
}


// Find which subkey has the highest verion
// If retrun S_OK, *ppwzHighestVersion has the highest version string.
//      *pbIsTopKey indicates if top key is the one with highest version.
// If return S_FALSE, cannot find any version. *ppwzHighestVersion is set
//      to NULL, and *pbIsTopKey is TRUE.
// If failed, *ppwzHighestVersion will be set to NULL, and *pbIsTopKey is 
// undefined.
// Note: If succeeded, this function will allocate memory for *ppwzVersion. 
//      Caller is responsible to release them
HRESULT FindHighestVersion(REFCLSID rclsid, BOOL bLoadRecord, LPWSTR *ppwzHighestVersion, BOOL *pbIsTopKey, BOOL *pbIsUnmanagedObject)
{
    HRESULT     hr = S_OK;
    WCHAR       szID[64];
    WCHAR       clsidKeyname[128];
    WCHAR       wzSubKeyName[32]; 
    DWORD       cwSubKeySize;
    DWORD       dwIndex;          // subkey index
    HKEY        hKeyCLSID = NULL;
    HKEY        hSubKey = NULL;
    DWORD       type;
    DWORD       size;
    BOOL        bIsTopKey = FALSE;   // Does top key have the highest version?
    BOOL        bGotVersion = FALSE; // Do we get anything out of registry?
    LONG        lResult;
    LPWSTR      wzAssemblyString = NULL;
    DWORD       numSubKeys = 0;
    AssemblyVersion avHighest;
    AssemblyVersion avCurrent;


    _ASSERTE(pbIsUnmanagedObject != NULL);
    *pbIsUnmanagedObject = FALSE;


    if ((ppwzHighestVersion == NULL) || (pbIsTopKey == NULL))
        IfFailGo(E_INVALIDARG);

    *ppwzHighestVersion = NULL;

    if (!GuidToLPWSTR(rclsid, szID, NumItems(szID))) 
        IfFailGo(E_INVALIDARG);

    if (bLoadRecord)
    {
        wcscpy(clsidKeyname, L"Record\\");
        wcscat(clsidKeyname, szID);
    }
    else
    {
        wcscpy(clsidKeyname, L"CLSID\\");
        wcscat(clsidKeyname, szID);
        wcscat(clsidKeyname, L"\\InprocServer32");
    }

    // Open HKCR\CLSID\<clsid> , or HKCR\Record\<RecordId>
    IfFailWin32Go(WszRegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    clsidKeyname,
                    0, 
                    KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                    &hKeyCLSID));


    //
    // Start by looking for a version subkey.
    //

    IfFailWin32Go(WszRegQueryInfoKey(hKeyCLSID, NULL, NULL, NULL,
                  &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL));
    
    for ( dwIndex = 0; dwIndex < numSubKeys;  dwIndex++)
    {
        cwSubKeySize = NumItems(wzSubKeyName);
        
        IfFailWin32Go(WszRegEnumKeyEx(hKeyCLSID, //HKCR\CLSID\<clsid>\InprocServer32
                        dwIndex,             // which subkey
                        wzSubKeyName,        // subkey name
                        &cwSubKeySize,       // size of subkey name
                        NULL,                // lpReserved
                        NULL,                // lpClass
                        NULL,                // lpcbClass
                        NULL));              // lpftLastWriteTime
       
        hr = avCurrent.Init(wzSubKeyName);
        if (FAILED(hr))
        {
            // not valid version subkey, ignore
            continue;
        }
        
        IfFailWin32Go(WszRegOpenKeyEx(
                    hKeyCLSID,
                    wzSubKeyName,
                    0,
                    KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                    &hSubKey));

        // Check if this is a non-interop scenario
        lResult = WszRegQueryValueEx(
                        hSubKey,
                        SBSVERSIONVALUE,
                        NULL,
                        &type,
                        NULL,
                        &size);  
        if (lResult == ERROR_SUCCESS)
        {
            *pbIsUnmanagedObject = TRUE;
        }
        // This is an interop assembly
        else
        {
            lResult = WszRegQueryValueEx(
                            hSubKey,
                            L"Assembly",
                            NULL,
                            &type,
                            NULL,
                            &size);  
            if (!((lResult == ERROR_SUCCESS)&&(type == REG_SZ)&&(size > 0)))
            {
                // do not have value "Assembly"
                RegCloseKey(hSubKey);
                hSubKey = NULL;
                continue;
            }

            lResult = WszRegQueryValueEx(
                            hSubKey,
                            L"Class",
                            NULL,
                            &type,
                            NULL,
                            &size);
            if (!((lResult == ERROR_SUCCESS)&&(type == REG_SZ)&&(size > 0)))
            {
                // do not have value "Class"
                RegCloseKey(hSubKey);
                hSubKey = NULL;
                continue;
            }

            // check runtime version only when not dealing with record
            if (!bLoadRecord)
            {
                lResult = WszRegQueryValueEx(
                                hSubKey,
                                L"RuntimeVersion",
                                NULL,
                                &type,
                                NULL,
                                &size);
                if (!((lResult == ERROR_SUCCESS)&&(type == REG_SZ)&&(size > 0)))
                {
                    // do not have value "RuntimeVersion"
                    RegCloseKey(hSubKey);
                    hSubKey = NULL;
                    continue;
                }
            }
        }
        // ok. Now I believe this is a valid subkey
        RegCloseKey(hSubKey);
        hSubKey = NULL;

        if (bGotVersion)
        {
            if (avCurrent >= avHighest)
                avHighest = avCurrent;
        }
        else
        {
            avHighest = avCurrent;
        }

        bGotVersion = TRUE;
    }


    //
    // If there are no subkeys, then look at the top level key.
    //
    
    if (!bGotVersion)
    {
        // make sure value Class exists
        // If not dealing with record, also make sure RuntimeVersion exists.
        if (((WszRegQueryValueEx(hKeyCLSID, L"Class", NULL, &type, NULL, &size) == ERROR_SUCCESS) && (type == REG_SZ)&&(size > 0))
            &&(bLoadRecord || (WszRegQueryValueEx(hKeyCLSID, L"RuntimeVersion", NULL, &type, NULL, &size) == ERROR_SUCCESS) && (type == REG_SZ)&&(size > 0)))
        {
            // Get the size of assembly display name
            lResult = WszRegQueryValueEx(
                            hKeyCLSID,
                            L"Assembly",
                            NULL,
                            &type,
                            NULL,
                            &size);
        
            if ((lResult == ERROR_SUCCESS) && (type == REG_SZ) && (size > 0))
            {
                IfNullGo(wzAssemblyString = new WCHAR[size + 1]);
                IfFailWin32Go(WszRegQueryValueEx(
                              hKeyCLSID,
                              L"Assembly",
                              NULL,
                              &type,
                              (LPBYTE)wzAssemblyString,
                              &size));
            
                // Now we have the assembly display name.
                // Extract the version out.

                // first lowercase display name
                _wcslwr(wzAssemblyString);

                // locate "version="
                LPWSTR pwzVersion = wcsstr(wzAssemblyString, L"version=");
                if (pwzVersion) {
                    // point to the character after "version="
                    pwzVersion += 8; // length of L"version="

                    // Now find the next L','
                    LPWSTR pwzEnd = pwzVersion;
                    
                    while((*pwzEnd != L',') && (*pwzEnd != L'\0'))
                        pwzEnd++;

                    // terminate version string
                    *pwzEnd = L'\0';

                    // trim version string
                    while(iswspace(*pwzVersion)) 
                        pwzVersion++;

                    pwzEnd--;
                    while(iswspace(*pwzEnd)&&(pwzEnd > pwzVersion))
                    {
                        *pwzEnd = L'\0';
                        pwzEnd--;
                    }
                           
                    // Make sure the version is valid.
                    if(SUCCEEDED(avHighest.Init(pwzVersion)))
                    {
                        // This is the first version found, so it is the highest version
                        bIsTopKey = TRUE;
                        bGotVersion = TRUE;
                    }
                }
            }
        } // end of handling of key HKCR\CLSID\<clsid>\InprocServer32
    }

    if (bGotVersion)
    {
        // Now we have the highest version. Copy it out
        if(*pbIsUnmanagedObject)
            IfFailGo(avHighest.ToString(3, ppwzHighestVersion));
        else 
            IfFailGo(avHighest.ToString(ppwzHighestVersion));
        *pbIsTopKey = bIsTopKey;

        // return S_OK to indicate we successfully found the highest version.
        hr = S_OK;
    }
    else
    {
        // Didn't find anything.
        // let us just return the top one. (fall back to default)
        *pbIsTopKey = TRUE;

        // return S_FALSE to indicate that we didn't find anything
        hr = S_FALSE;
    }

ErrExit:
    if (hKeyCLSID)
        RegCloseKey(hKeyCLSID);
    if (hSubKey)
        RegCloseKey(hSubKey);
    if (wzAssemblyString)
        delete[] wzAssemblyString;

    return hr;
}

// FindRuntimeVersionFromRegistry
//
// Find the runtimeVersion corresponding to the highest version
HRESULT FindRuntimeVersionFromRegistry(REFCLSID rclsid, LPWSTR *ppwzRuntimeVersion, BOOL fListedVersion)
{
    HRESULT hr = S_OK;
    HKEY    userKey = NULL;
    WCHAR   szID[64];
    WCHAR   keyname[256];
    DWORD   size;
    DWORD   type;
    LPWSTR  pwzVersion;
    BOOL    bIsTopKey;
    BOOL    bIsUnmanagedObject = FALSE;
    LPWSTR  pwzRuntimeVersion = NULL;

    if (ppwzRuntimeVersion == NULL)
        IfFailGo(E_INVALIDARG);

    // Initialize the string passed in to NULL.
    *ppwzRuntimeVersion = NULL;

    // Convert the GUID to its string representation.
    if (GuidToLPWSTR(rclsid, szID, NumItems(szID)) == 0)
        IfFailGo(E_INVALIDARG);
    
    // retrieve the highest version.
    
    IfFailGo(FindHighestVersion(rclsid, FALSE, &pwzVersion, &bIsTopKey, &bIsUnmanagedObject));

    if (!bIsUnmanagedObject)
    {
        if(fListedVersion) {
            // if highest version is in top key,
            // we will look at HKCR\CLSID\<clsid>\InprocServer32 or HKCR\Record\<RecordId>
            // Otherwise we will look at HKCR\CLSID\<clsid>\InprocServer32\<version> or HKCR\Record\<RecordId>\<Version>
            wcscpy(keyname, L"CLSID\\");
            wcscat(keyname, szID);
            wcscat(keyname, L"\\InprocServer32");
            if (!bIsTopKey)
            {
                wcscat(keyname, L"\\");
                wcscat(keyname, pwzVersion);
            }
            
            // open the registry
            IfFailWin32Go(WszRegOpenKeyEx(HKEY_CLASSES_ROOT, keyname, 0, KEY_READ, &userKey));
            
            // extract the runtime version.
            hr = WszRegQueryValueEx(userKey, L"RuntimeVersion", NULL, &type, NULL, &size);
            if (hr == ERROR_SUCCESS)
            {
                IfNullGo(pwzRuntimeVersion = new WCHAR[size + 1]);
                IfFailWin32Go(WszRegQueryValueEx(userKey, L"RuntimeVersion", NULL,  NULL, (LPBYTE)pwzRuntimeVersion, &size));
            }
            else
            {
                IfNullGo(pwzRuntimeVersion = new WCHAR[wcslen(V1_VERSION_NUM) + 1]);
                wcscpy(pwzRuntimeVersion, V1_VERSION_NUM);
            }
        }
   }
    else
    {
        // We need to prepend the 'v' to the version string
        IfNullGo(pwzRuntimeVersion = new WCHAR[wcslen(pwzVersion)+1+1]); // +1 for the v, +1 for the null
        *pwzRuntimeVersion = 'v';
        wcscpy(pwzRuntimeVersion+1, pwzVersion);
    }
    // now we have the data, copy it out
    *ppwzRuntimeVersion = pwzRuntimeVersion;
    hr = S_OK;

ErrExit:
    if (userKey) 
        RegCloseKey(userKey);

    if (pwzVersion)
        delete[] pwzVersion;

    if (FAILED(hr))
    {
        if (pwzRuntimeVersion)
            delete[] pwzRuntimeVersion;
    }

    return hr;
}

// FindShimInfoFromRegistry
//
// Find shim info corresponding to the highest version
HRESULT FindShimInfoFromRegistry(REFCLSID rclsid, BOOL bLoadRecord, LPWSTR *ppwzClassName,
                      LPWSTR *ppwzAssemblyString, LPWSTR *ppwzCodeBase)
{
    HRESULT hr = S_OK;
    HKEY    userKey = NULL;
    WCHAR   szID[64];
    WCHAR   keyname[256];
    DWORD   size;
    DWORD   type;
    LPWSTR  pwzVersion;
    BOOL    bIsTopKey;
    LPWSTR  pwzClassName = NULL;
    LPWSTR  pwzAssemblyString = NULL;
    LPWSTR  pwzCodeBase = NULL;
    LONG    lResult;
    
    // at least one should be specified.
    // codebase is optional
    if ((ppwzClassName == NULL) && (ppwzAssemblyString == NULL))
        IfFailGo(E_INVALIDARG);

    // Initialize the strings passed in to NULL.
    if (ppwzClassName)
        *ppwzClassName = NULL;
    if (ppwzAssemblyString)
        *ppwzAssemblyString = NULL;
    if (ppwzCodeBase)
        *ppwzCodeBase = NULL;

    // Convert the GUID to its string representation.
    if (GuidToLPWSTR(rclsid, szID, NumItems(szID)) == 0)
        IfFailGo(E_INVALIDARG);
    
    // retrieve the highest version.
    BOOL bIsUnmanaged = FALSE;
    
    IfFailGo(FindHighestVersion(rclsid, bLoadRecord, &pwzVersion, &bIsTopKey, &bIsUnmanaged));

    // if highest version is in top key,
    // we will look at HKCR\CLSID\<clsid>\InprocServer32 or HKCR\Record\<RecordId>
    // Otherwise we will look at HKCR\CLSID\<clsid>\InprocServer32\<version> or HKCR\Record\<RecordId>\<Version>
    if (bLoadRecord)
    {
        wcscpy(keyname, L"Record\\");
        wcscat(keyname, szID);
    }
    else
    {
        wcscpy(keyname, L"CLSID\\");
        wcscat(keyname, szID);
        wcscat(keyname, L"\\InprocServer32");
    }
    if (!bIsTopKey)
    {
         wcscat(keyname, L"\\");
         wcscat(keyname, pwzVersion);
    }
  
    // open the registry
    IfFailWin32Go(WszRegOpenKeyEx(HKEY_CLASSES_ROOT, keyname, 0, KEY_READ, &userKey));
  
    // get the class name
    IfFailWin32Go(WszRegQueryValueEx(userKey, L"Class", NULL, &type, NULL, &size));
    IfNullGo(pwzClassName = new WCHAR[size + 1]);
    IfFailWin32Go(WszRegQueryValueEx(userKey, L"Class", NULL, NULL, (LPBYTE)pwzClassName, &size));

    // get the assembly string 
    IfFailWin32Go(WszRegQueryValueEx(userKey, L"Assembly", NULL, &type, NULL, &size));
    IfNullGo(pwzAssemblyString = new WCHAR[size + 1]);
    IfFailWin32Go(WszRegQueryValueEx(userKey, L"Assembly", NULL, NULL, (LPBYTE)pwzAssemblyString, &size));

    // get the code base if requested
    if (ppwzCodeBase)
    {
        // get the codebase, however not finding it does not constitute
        // a fatal error.
        lResult = WszRegQueryValueEx(userKey, L"CodeBase", NULL, &type, NULL, &size);
        if ((lResult == ERROR_SUCCESS) && (type == REG_SZ) && (size > 0))
        {
            IfNullGo(pwzCodeBase = new WCHAR[size + 1]);
            IfFailWin32Go(WszRegQueryValueEx(userKey, L"CodeBase", NULL, NULL, (LPBYTE)pwzCodeBase, &size));                        
        }
    }

    // now we got everything. Copy them out
    if (ppwzClassName)
        *ppwzClassName = pwzClassName;
    if (ppwzAssemblyString)
        *ppwzAssemblyString = pwzAssemblyString;
    if (ppwzCodeBase)
        *ppwzCodeBase = pwzCodeBase;

    hr = S_OK;

ErrExit:
    if (userKey)
        RegCloseKey(userKey);
    
    if (pwzVersion)
        delete[] pwzVersion;

    if (FAILED(hr))
    {
        if (pwzClassName)
            delete[] pwzClassName;
        if (pwzAssemblyString)
            delete[] pwzAssemblyString;
        if (pwzCodeBase)
            delete[] pwzCodeBase;
    }

    return hr;
}


HRESULT GetConfigFileFromWin32Manifest(WCHAR* buffer, DWORD dwBuffer, DWORD* pSize)
{
    HRESULT hr = S_OK;

    // Get the basic activation context first.
    ACTIVATION_CONTEXT_DETAILED_INFORMATION* pInfo = NULL;
    ACTIVATION_CONTEXT_DETAILED_INFORMATION acdi;
    DWORD length = 0;

    HANDLE hActCtx = NULL;
    DWORD nCount = 0;

    nCount = sizeof(acdi);
    if (!WszQueryActCtxW(0, hActCtx, NULL, ActivationContextDetailedInformation, 
                         &acdi, nCount, &nCount))
    {
        
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            pInfo = (ACTIVATION_CONTEXT_DETAILED_INFORMATION*) alloca(nCount);
            
            if (WszQueryActCtxW(0, hActCtx, NULL, ActivationContextDetailedInformation, 
                                pInfo, nCount, &nCount) &&
                pInfo->ulAppDirPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE) 
            {
                
                //pwzPathName = pInfo->lpAppDirPath;
                WCHAR* pwzConfigName = NULL;

                if(pInfo->lpRootConfigurationPath) 
                    pwzConfigName = (WCHAR*) pInfo->lpRootConfigurationPath;
                else if(pInfo->lpRootManifestPath) 
                {
                    size_t length = wcslen(pInfo->lpRootManifestPath);
                    if(length != 0) {
                        WCHAR tail[] = L".config";
                        // length of string plus .config plus termination character
                        pwzConfigName = (WCHAR*) alloca(length*sizeof(WCHAR) + sizeof(tail)); // sizeof(tail) includes NULL term.
                        wcscpy(pwzConfigName, pInfo->lpRootManifestPath);
                        LPWSTR ptr = wcsrchr(pwzConfigName, L'.');
                        if(ptr == NULL) 
                            ptr = pwzConfigName+length;
                        wcscpy(ptr, tail);
                    }
                }

                if(pwzConfigName) 
                {
                    length = wcslen(pwzConfigName) + 1;
                    if(length > dwBuffer || buffer == NULL) 
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    else 
                        wcscpy(buffer, pwzConfigName);
                }
            }
        }
    }
    if(pSize) *pSize = length;
    return hr;
}

HRESULT GetApplicationPathFromWin32Manifest(WCHAR* buffer, DWORD dwBuffer, DWORD* pSize)
{
    HRESULT hr = S_OK;

    // Get the basic activation context first.
    ACTIVATION_CONTEXT_DETAILED_INFORMATION* pInfo = NULL;
    ACTIVATION_CONTEXT_DETAILED_INFORMATION acdi;
    DWORD length = 0;

    HANDLE hActCtx = NULL;
    DWORD nCount = 0;

    nCount = sizeof(acdi);
    if (!WszQueryActCtxW(0, hActCtx, NULL, ActivationContextDetailedInformation, 
                         &acdi, nCount, &nCount))
    {
        
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            pInfo = (ACTIVATION_CONTEXT_DETAILED_INFORMATION*) alloca(nCount);
            
            if (WszQueryActCtxW(0, hActCtx, NULL, ActivationContextDetailedInformation, 
                                pInfo, nCount, &nCount) &&
                pInfo->ulAppDirPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE) 
            {
                
                if(pInfo->lpAppDirPath) {
                    length = wcslen(pInfo->lpAppDirPath) + 1;
                    if(length > dwBuffer || buffer == NULL) {
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else {
                        wcscpy(buffer, pInfo->lpAppDirPath);
                    }
                }

            }
        }
    }
    if(pSize) *pSize = length;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\stgpooli.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgPool.cpp
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
//*****************************************************************************
#include "stdafx.h"						// Standard include.
#include <StgPool.h>					// Our interface definitions.

int CStringPoolHash::Cmp(
	const void	*pData, 				// A string.
	void		*pItem)					// A hash item which refers to a string.
{
	LPCSTR p1 = reinterpret_cast<LPCSTR>(pData);
    LPCSTR p2 = m_Pool->GetString(reinterpret_cast<STRINGHASH*>(pItem)->iOffset);
	return (strcmp(p1, p2));
} // int CStringPoolHash::Cmp()


int CBlobPoolHash::Cmp(
	const void *pData,					// A blob.
	void		*pItem)					// A hash item which refers to a blob.
{
	ULONG		ul1;
	ULONG		ul2;
	void		*pData2;

	// Get size of first item.
	ul1 = CPackedLen::GetLength(pData);
	// Adjust size to include the length of size field.
	ul1 += CPackedLen::Size(ul1);

	// Get the second item.
	pData2 = m_Pool->GetData(reinterpret_cast<BLOBHASH*>(pItem)->iOffset);

	// Get and adjust size of second item.
	ul2 = CPackedLen::GetLength(pData2);
	ul2 += CPackedLen::Size(ul2);

	if (ul1 < ul2)
		return (-1);
	else if (ul1 > ul2)
		return (1);
	return (memcmp(pData, pData2, ul1));
} // int CBlobPoolHash::Cmp()

int CGuidPoolHash::Cmp(const void *pData, void *pItem)
{
    GUID *p2 = m_Pool->GetGuid(reinterpret_cast<GUIDHASH*>(pItem)->iIndex);
    return (memcmp(pData, p2, sizeof(GUID)));
} // int CGuidPoolHash::Cmp()

//
//
// CPackedLen
//
//


//*****************************************************************************
// Parse a length, return the data, store length.
//*****************************************************************************
void const *CPackedLen::GetData(		// Pointer to data, or 0 on error.
	void const	*pData, 				// First byte of length.
	ULONG		*pLength)				// Put length here, or -1 on error.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if ((*pBytes & 0x80) == 0x00)		// 0??? ????
	{
		*pLength = (*pBytes & 0x7f);
		return pBytes + 1;
	}

	if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
	{
		*pLength = ((*pBytes & 0x3f) << 8 | *(pBytes+1));
		return pBytes + 2;
	}

	if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
	{
		*pLength = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
		return pBytes + 4;
	}

	*pLength = -1;
	return 0;
} // void const *CPackedLen::GetData()

//*****************************************************************************
// Parse a length, return the length, pointer to actual bytes.
//*****************************************************************************
ULONG CPackedLen::GetLength(			// Length or -1 on error.
	void const	*pData, 				// First byte of length.
	void const	**ppCode)				// Put pointer to bytes here, if not 0.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if ((*pBytes & 0x80) == 0x00)		// 0??? ????
	{
		if (ppCode) *ppCode = pBytes + 1;
		return (*pBytes & 0x7f);
	}

	if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
	{
		if (ppCode) *ppCode = pBytes + 2;
		return ((*pBytes & 0x3f) << 8 | *(pBytes+1));
	}

	if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
	{
		if (ppCode) *ppCode = pBytes + 4;
		return ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
	}

	return -1;
} // ULONG CPackedLen::GetLength()

//*****************************************************************************
// Parse a length, return the length, size of the length.
//*****************************************************************************
ULONG CPackedLen::GetLength(			// Length or -1 on error.
	void const	*pData, 				// First byte of length.
	int			*pSizeLen)				// Put size of length here, if not 0.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if ((*pBytes & 0x80) == 0x00)		// 0??? ????
	{
		if (pSizeLen) *pSizeLen = 1;
		return (*pBytes & 0x7f);
	}

	if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
	{
		if (pSizeLen) *pSizeLen = 2;
		return ((*pBytes & 0x3f) << 8 | *(pBytes+1));
	}

	if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
	{
		if (pSizeLen) *pSizeLen = 4;
		return ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
	}

	return -1;
} // ULONG CPackedLen::GetLength()

//*****************************************************************************
// Encode a length.
//*****************************************************************************
#pragma warning(disable:4244) // conversion from unsigned long to unsigned char
void* CPackedLen::PutLength(			// First byte past length.
	void		*pData, 				// Pack the length here.
	ULONG		iLen)					// The length.
{
	BYTE		*pBytes = reinterpret_cast<BYTE*>(pData);

	if (iLen <= 0x7F)
	{
		*pBytes = iLen;
		return pBytes + 1;
	}

	if (iLen <= 0x3FFF)
	{
		*pBytes = (iLen >> 8) | 0x80;
		*(pBytes+1) = iLen & 0xFF;
		return pBytes + 2;
	}

	_ASSERTE(iLen <= 0x1FFFFFFF);
	*pBytes = (iLen >> 24) | 0xC0;
	*(pBytes+1) = (iLen >> 16) & 0xFF;
	*(pBytes+2) = (iLen >> 8)  & 0xFF;
	*(pBytes+3) = iLen & 0xFF;
	return pBytes + 4;
} // void* CPackedLen::PutLength()
#pragma warning(default:4244) // conversion from unsigned long to unsigned char
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\utf.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.

This file was copied from the Windows XP code base on 1/28/2002
to ensure the CLR has appropriate UTF-8 surrogate support and can
recognize invalid UTF-8 sequences on all platforms.  -- BrianGru
--*/



//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};




/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\tlbutils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Utilities used to help manipulating typelib's.
**  
**			Created by: dmortens
===========================================================*/

#include "stdafx.h"                     // Precompiled header key.
#include "TlbUtils.h"
#include "dispex.h"
#include "PostError.h"
#include "__file__.ver"

static const LPCWSTR        DLL_EXTENSION           = {L".dll"};
static const int            DLL_EXTENSION_LEN       = 4;
static const LPCWSTR        EXE_EXTENSION           = {L".exe"};
static const int            EXE_EXTENSION_LEN       = 4;

#define CUSTOM_MARSHALER_ASM ", CustomMarshalers, Version=" VER_ASSEMBLYVERSION_STR_NO_NULL ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"

StdConvertibleItfInfo aStdConvertibleInterfaces[] = 
{
    { "System.Runtime.InteropServices.Expando.IExpando", (GUID*)&IID_IDispatchEx, 
      "System.Runtime.InteropServices.CustomMarshalers.ExpandoToDispatchExMarshaler" CUSTOM_MARSHALER_ASM, "IExpando" },

    { "System.Reflection.IReflect", (GUID*)&IID_IDispatchEx, 
      "System.Runtime.InteropServices.CustomMarshalers.ExpandoToDispatchExMarshaler" CUSTOM_MARSHALER_ASM, "IReflect" },

    { "System.Collections.IEnumerator", (GUID*)&IID_IEnumVARIANT,
      "System.Runtime.InteropServices.CustomMarshalers.EnumeratorToEnumVariantMarshaler" CUSTOM_MARSHALER_ASM, "" },

    { "System.Type", (GUID*)&IID_ITypeInfo,
      "System.Runtime.InteropServices.CustomMarshalers.TypeToTypeInfoMarshaler" CUSTOM_MARSHALER_ASM, "" },
};

// This method returns the custom marshaler info to convert the native interface
// to its managed equivalent. Or null if the interface is not a standard convertible interface.
StdConvertibleItfInfo *GetConvertionInfoFromNativeIID(REFGUID rGuidNativeItf)
{
	// Look in the table of interfaces that have standard convertions to see if the
	// specified interface is there.
	for (int i = 0; i < sizeof(aStdConvertibleInterfaces) / sizeof(StdConvertibleItfInfo); i++)
	{
		if (IsEqualGUID(rGuidNativeItf, *(aStdConvertibleInterfaces[i].m_pNativeTypeIID)))
			return &aStdConvertibleInterfaces[i];
	}

	// The interface is not in the table.
	return NULL;
}

// This method returns the custom marshaler info to convert the managed type to
// to its native equivalent. Or null if the interface is not a standard convertible interface.
StdConvertibleItfInfo *GetConvertionInfoFromManagedType(LPUTF8 strMngTypeName)
{
	// Look in the table of interfaces that have standard convertions to see if the
	// specified managed type is there.
	for (int i = 0; i < sizeof(aStdConvertibleInterfaces) / sizeof(StdConvertibleItfInfo); i++)
	{
		if (strcmp(strMngTypeName, aStdConvertibleInterfaces[i].m_strMngTypeName) == 0)
			return &aStdConvertibleInterfaces[i];
	}

	// The managed type is not in the table.
	return NULL;
}

// This method generates a mangled type name based on the original name specified.
// This type name is guaranteed to be unique inside the TLB.
HRESULT GenerateMangledTypeName(ITypeLib *pITLB, BSTR szOriginalTypeName, BSTR *pszMangledTypeName)
{
	HRESULT hr = S_OK;
    BSTR szMangledName = NULL;
	int cMangleIndex = 0;

	if (!szOriginalTypeName || !pszMangledTypeName)
		return E_POINTER;

	for (cMangleIndex = 0; cMangleIndex < INT_MAX; cMangleIndex++)
	{
		BOOL bNameAlreadyInUse = FALSE;
		WCHAR szPrefix[256];

		if (cMangleIndex == 0)
			swprintf(szPrefix, L"__");
		else
			swprintf(szPrefix, L"_%i", cMangleIndex++);

		// Mangle the name by prefixing it with the prefix we previously created.
		szMangledName = SysAllocStringLen(NULL, (unsigned int)(wcslen(szOriginalTypeName) + wcslen(szPrefix) + 1));
	    swprintf(szMangledName, L"%s%s", szPrefix, szOriginalTypeName);

		// Check to see if the mangled name is already used in the context of this typelib.
        if (pITLB)
        {
		    if (FAILED(hr = pITLB->IsName(szMangledName, 0, &bNameAlreadyInUse)))
		    {
			    SysFreeString(szMangledName);
			    return hr;
		    }
        }

		if (!bNameAlreadyInUse)
			break;

		// Free the mangled name since it will be allocated when we try again next time
		// through the loop.
	    SysFreeString(szMangledName);
	}

	// Sanity check.
	_ASSERTE(cMangleIndex < INT_MAX);

	// Return the mangled name. It is the job of the caller to free the string.
	*pszMangledTypeName = szMangledName;
	return S_OK;
}

//*****************************************************************************
// Given a typelib, determine the managed namespace name.
//*****************************************************************************
HRESULT GetNamespaceNameForTypeLib(     // S_OK or error.
    ITypeLib    *pITLB,                 // [IN] The TypeLib.
    BSTR        *pwzNamespace)          // [OUT] Put the namespace name here.
{   
    HRESULT     hr = S_OK;              // A result.
    ITypeLib2   *pITLB2=0;              //For getting custom value.
    TLIBATTR    *pAttr=0;               // Typelib attributes.
    BSTR        szPath=0;               // Typelib path.
    
    // If custom attribute for namespace exists, use it.
    if (pITLB->QueryInterface(IID_ITypeLib2, (void **)&pITLB2) == S_OK)
    {
        VARIANT vt;
        VariantInit(&vt);
        if (pITLB2->GetCustData(GUID_ManagedName, &vt) == S_OK)
        {   
            if (V_VT(&vt) == VT_BSTR)
            {   
                // If the namespace ends with .dll then remove the extension.
                LPWSTR pDest = wcsstr(vt.bstrVal, DLL_EXTENSION);
                if (pDest && (pDest[DLL_EXTENSION_LEN] == 0 || pDest[DLL_EXTENSION_LEN] == ' '))
                    *pDest = 0;

                if (!pDest)
                {
                    // If the namespace ends with .exe then remove the extension.
                    pDest = wcsstr(vt.bstrVal, EXE_EXTENSION);
                    if (pDest && (pDest[EXE_EXTENSION_LEN] == 0 || pDest[EXE_EXTENSION_LEN] == ' '))
                        *pDest = 0;
                }

                if (pDest)
                {
                    // We removed the extension so re-allocate a string of the new length.
                    *pwzNamespace = SysAllocString(vt.bstrVal);
                    SysFreeString(vt.bstrVal);
                }
                else
                {
                    // There was no extension to remove so we can use the string returned
                    // by GetCustData().
                    *pwzNamespace = vt.bstrVal;
                }        

                goto ErrExit;
            }
            else
            {
                VariantClear(&vt);
            }
        }
    }
    
    // No custom attribute, use library name.
    IfFailGo(pITLB->GetDocumentation(MEMBERID_NIL, pwzNamespace, 0, 0, 0));
    if (!ns::IsValidName(*pwzNamespace))
    {
        pITLB->GetLibAttr(&pAttr);
        IfFailGo(QueryPathOfRegTypeLib(pAttr->guid, pAttr->wMajorVerNum, pAttr->wMinorVerNum, pAttr->lcid, &szPath));
        IfFailGo(PostError(TLBX_E_INVALID_NAMESPACE, szPath, pwzNamespace));
    }
    
ErrExit:
    if (szPath)
        ::SysFreeString(szPath);
    if (pAttr)
        pITLB->ReleaseTLibAttr(pAttr);
    if (pITLB2)
        pITLB2->Release();
    
    return hr;
} // HRESULT GetNamespaceNameForTypeLib()

//*****************************************************************************
// Given an ITypeInfo, determine the managed name.  Optionally supply a default
//  namespace, otherwise derive namespace from containing typelib.
//*****************************************************************************
HRESULT GetManagedNameForTypeInfo(      // S_OK or error.
    ITypeInfo   *pITI,                  // [IN] The TypeInfo.
    LPCWSTR     wzNamespace,            // [IN, OPTIONAL] Default namespace name.
    LPCWSTR     wzAsmName,              // [IN, OPTIONAL] Assembly name.
    BSTR        *pwzName)               // [OUT] Put the name here.
{
    HRESULT     hr = S_OK;              // A result.
    ITypeInfo2  *pITI2=0;               // For getting custom value.
    ITypeLib    *pITLB=0;               // Containing typelib.
    
    BSTR        bstrName=0;             // Typeinfo's name.
    BSTR        bstrNamespace=0;        // Typelib's namespace.
    int         cchFullyQualifiedName;  // Size of namespace + name buffer.
    int         cchAsmName=0;           // The size of the assembly name.
    int         cchAsmQualifiedName=0;  // The size of the assembly qualified name buffer.
    CQuickArray<WCHAR> qbFullyQualifiedName;  // The fully qualified type name.  

    // Check for a custom value with name.
    if (pITI->QueryInterface(IID_ITypeInfo2, (void **)&pITI2) == S_OK)
    {
        VARIANT     vt;                     // For getting custom value.
        ::VariantInit(&vt);
        if (pITI2->GetCustData(GUID_ManagedName, &vt) == S_OK && vt.vt == VT_BSTR)
        {   // There is a custom value with the name.  Just believe it.
            *pwzName = vt.bstrVal;
            vt.bstrVal = 0;
            vt.vt = VT_EMPTY;
            goto ErrExit;
        }
    }
    
    // Still need name, get the namespace.
    if (wzNamespace == 0)
    {
        IfFailGo(pITI->GetContainingTypeLib(&pITLB, 0));
        IfFailGo(GetNamespaceNameForTypeLib(pITLB, &bstrNamespace));
        wzNamespace = bstrNamespace;
    }
    
    // Get the name, and combine with namespace.
    IfFailGo(pITI->GetDocumentation(MEMBERID_NIL, &bstrName, 0,0,0));
    cchFullyQualifiedName = (int)(wcslen(bstrName) + wcslen(wzNamespace) + 1);
    qbFullyQualifiedName.ReSize(cchFullyQualifiedName + 1);
    ns::MakePath(qbFullyQualifiedName.Ptr(), cchFullyQualifiedName + 1, wzNamespace, bstrName);

    // If the assembly name is specified, then add it to the type name.
    if (wzAsmName)
    {
        cchAsmName = wcslen(wzAsmName);
        cchAsmQualifiedName = cchFullyQualifiedName + cchAsmName + 3;
        IfNullGo(*pwzName = ::SysAllocStringLen(0, cchAsmQualifiedName));
        ns::MakeAssemblyQualifiedName(*pwzName, cchAsmQualifiedName, qbFullyQualifiedName.Ptr(), cchFullyQualifiedName, wzAsmName, cchAsmName);
    }
    else
    {
        IfNullGo(*pwzName = ::SysAllocStringLen(qbFullyQualifiedName.Ptr(), cchFullyQualifiedName));
    }

ErrExit:
    if (bstrName)
        ::SysFreeString(bstrName);
    if (bstrNamespace)
        ::SysFreeString(bstrNamespace);
    if (pITLB)
        pITLB->Release();
    if (pITI2)
        pITI2->Release();

    return (hr);
} // HRESULT GetManagedNameForTypeInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\timeline.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include "timeline.h"
#include "utilcode.h"

#if ENABLE_TIMELINE

Timeline Timeline::g_Timeline;

static HMODULE crt;
static int ( __cdecl *FPRINTF)( void *stream, const char *format, ...);
static int ( __cdecl *VFPRINTF)( void *stream, const char *format, va_list argptr );
static void * ( __cdecl *FOPEN)( const char *filename, const char *mode );
static int ( __cdecl *FCLOSE)( void *stream );

void Timeline::Startup() 
{ 
    g_Timeline.Init(); 
}

void Timeline::Shutdown() 
{ 
    g_Timeline.Destroy(); 
}

void Timeline::Init()
{
    m_enabled = REGUTIL::GetConfigDWORD(L"Timeline", 0);

    if (m_enabled != 0)
    {
        crt = WszLoadLibrary(L"msvcrt.dll");
        if (crt == NULL)
            m_enabled = 0;
        else
        {
            FPRINTF = (int (__cdecl *)( void *, const char *, ...)) GetProcAddress(crt, "fprintf");
            VFPRINTF = (int (__cdecl *)( void *, const char *, va_list)) GetProcAddress(crt, "vfprintf");
            FOPEN = (void *(__cdecl *)( const char *, const char *)) GetProcAddress(crt, "fopen");
            FCLOSE = (int (__cdecl *)( void * )) GetProcAddress(crt, "fclose");

            m_out = FOPEN("TIMELINE.LOG", "w+");
            

            QueryPerformanceFrequency(&m_frequency);
            m_frequency.QuadPart /= 1000; // We'll report times in ms.

            QueryPerformanceCounter(&m_lastTime[0]);
        }
    }

    m_lastLevel = -1;

    if (m_enabled != 0)
        EventStart("Timeline");
}

void Timeline::Destroy()
{
    if (m_enabled != 0)
    {
        EventEnd("Timeline\n");
        FCLOSE(m_out);
    }
}

void Timeline::Stamp(int level)
{
    if (level >= MAX_LEVEL)
        return;

    //
    // Record this time in our slot.
    //

    timestamp now;
    QueryPerformanceCounter(&now);

    //
    // Print indentation and timestamps
    //

    for (int i=0; i<=level; i++)
    {
        if (i > m_lastLevel)
        {
            m_lastTime[i] = now;
            
            FPRINTF(m_out, "------- ");
        }
        else
        {
            __int64 interval = now.QuadPart - m_lastTime[i].QuadPart;

            FPRINTF(m_out, "%+07.3f ", (double) (interval / m_frequency.QuadPart) / 1000.0);
        }
    }
}

void Timeline::Event(LPCSTR string, ...)
{
    va_list args;
    va_start(args, string);
    
    Stamp(m_lastLevel);
    VFPRINTF(m_out, string, args);
    VFPRINTF(m_out, "\n", NULL);
    
    va_end(args);
}

void Timeline::EventStart(LPCSTR string, ...)
{
    va_list args;
    va_start(args, string);

    Stamp(m_lastLevel+1);
    m_lastLevel++;
    VFPRINTF(m_out, "Start ", NULL);
    VFPRINTF(m_out, string, args);
    VFPRINTF(m_out, "\n", NULL);

    va_end(args);
}

void Timeline::EventEnd(LPCSTR string, ...)
{
    va_list args;
    va_start(args, string);
    
    Stamp(m_lastLevel);
    m_lastLevel--;
    VFPRINTF(m_out, "End ", NULL);
    VFPRINTF(m_out, string, args);
    VFPRINTF(m_out, "\n", NULL);

    va_end(args);
}

#endif // ENABLE_TIMELINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\wsinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "wsinfo.h"

WSInfo::WSInfo(IMetaDataImport *pImport)
    : m_pImport(pImport),
    m_total(0)
{
    HCORENUM hEnum = NULL;
    DWORD count;

    IfFailThrow(pImport->EnumTypeDefs(&hEnum, NULL, 0, NULL));
    IfFailThrow(pImport->CountEnum(hEnum, &m_cTypes));
    m_cTypes += 1;

    // @todo:
    // I can't believe this is the only way to count the defs
    //

    m_cMethods = 0;
    m_cFields = 0;
    while (TRUE)
    {
        mdTypeDef td;
        IfFailThrow(pImport->EnumTypeDefs(&hEnum, &td, 1, &count));

        if (count == 0)
            break;

        HCORENUM hMethodEnum = NULL;
        IfFailThrow(pImport->EnumMethods(&hMethodEnum, td, NULL, 0, NULL));
        IfFailThrow(pImport->CountEnum(hMethodEnum, &count));
        pImport->CloseEnum(hMethodEnum);

        m_cMethods += count;

        HCORENUM hFieldEnum = NULL;
        IfFailThrow(pImport->EnumFields(&hFieldEnum, td, NULL, 0, NULL));
        IfFailThrow(pImport->CountEnum(hFieldEnum, &count));
        pImport->CloseEnum(hFieldEnum);

        m_cFields += count;
    }

    pImport->CloseEnum(hEnum);

    HCORENUM hMethodEnum = NULL;
    IfFailThrow(pImport->EnumMethods(&hMethodEnum, mdTypeDefNil, NULL, 0, NULL));
    IfFailThrow(pImport->CountEnum(hMethodEnum, &count));
    pImport->CloseEnum(hMethodEnum);

    m_cMethods += count;

    HCORENUM hFieldEnum = NULL;
    IfFailThrow(pImport->EnumFields(&hFieldEnum, mdTypeDefNil, NULL, 0, NULL));
    IfFailThrow(pImport->CountEnum(hFieldEnum, &count));
    pImport->CloseEnum(hFieldEnum);

    m_cFields += count;

    //
    // Now allocate arrays
    //

    m_pTypeSizes = new ULONG [ m_cTypes+1 ];
    if (m_pTypeSizes == NULL)
        ThrowHR(E_OUTOFMEMORY);
    ZeroMemory(m_pTypeSizes, sizeof(ULONG) * (m_cTypes+1));

    m_pMethodSizes = new ULONG [ m_cMethods+1 ];
    if (m_pMethodSizes == NULL)
        ThrowHR(E_OUTOFMEMORY);
    ZeroMemory(m_pMethodSizes, sizeof(ULONG) * (m_cMethods+1));

    m_pFieldSizes = new ULONG [ m_cFields+1 ];
    if (m_pFieldSizes == NULL)
        ThrowHR(E_OUTOFMEMORY);
    ZeroMemory(m_pFieldSizes, sizeof(ULONG) * (m_cFields+1));
}

WSInfo::~WSInfo()
{
    if (m_pImport != NULL)
        m_pImport->Release();

    if (m_pTypeSizes != NULL)
        delete [] m_pTypeSizes;

    if (m_pMethodSizes != NULL)
        delete [] m_pMethodSizes;

    if (m_pFieldSizes != NULL)
        delete [] m_pFieldSizes;
}

void WSInfo::AdjustAllTypeSizes(LONG size)
{
    LONG delta = size / (m_cTypes-1);
    
    ULONG *p = m_pTypeSizes;
    ULONG *pEnd = p + m_cTypes;

    while (++p < pEnd)
        *p += delta;
}

void WSInfo::AdjustTypeSize(mdTypeDef token, LONG size)
{
    if (IsNilToken(token))
        AdjustAllTypeSizes(size);
    else
	{
		_ASSERTE(m_pImport->IsValidToken(token));
		m_pTypeSizes[RidFromToken(token)] += size;
	}
}

void WSInfo::AdjustAllMethodSizes(LONG size)
{
    LONG delta = size / (m_cMethods-1);
    
    ULONG *p = m_pMethodSizes;
    ULONG *pEnd = p + m_cMethods;

    while (++p < pEnd)
        *p += delta;
}

void WSInfo::AdjustMethodSize(mdMethodDef token, LONG size)
{
    if (IsNilToken(token))
        AdjustAllMethodSizes(size);
    else
    {
        _ASSERTE(m_pImport->IsValidToken(token));
        m_pMethodSizes[RidFromToken(token)] += size;
    }
}

void WSInfo::AdjustAllFieldSizes(LONG size)
{
    LONG delta = size / (m_cFields-1);
    
    ULONG *p = m_pFieldSizes;
    ULONG *pEnd = p + m_cFields;

    while (++p < pEnd)
        *p += delta;
}

void WSInfo::AdjustFieldSize(mdFieldDef token, LONG size)
{
    if (IsNilToken(token))
        AdjustAllFieldSizes(size);
    else
    {
        _ASSERTE(m_pImport->IsValidToken(token));
        m_pFieldSizes[RidFromToken(token)] += size;
    }
}

void WSInfo::AdjustTokenSize(mdToken token, LONG size)
{
    switch (TypeFromToken(token))
    {
    case mdtTypeDef:
        AdjustTypeSize(token, size);
        return;

    case mdtFieldDef:
        AdjustFieldSize(token, size);
        return;

    case mdtMethodDef:
        AdjustMethodSize(token, size);
        return;
        
    default:
        // @todo: should we try to get a parent token here?
        break;
    }
}

ULONG WSInfo::GetTotalAttributedSize()
{
    ULONG size = 0;

    ULONG *p, *pEnd;

    p = m_pTypeSizes;
    pEnd = p + m_cTypes;
    while (p < pEnd)
        size += *p++;

    p = m_pMethodSizes;
    pEnd = p + m_cMethods;
    while (p < pEnd)
        size += *p++;

    p = m_pFieldSizes;
    pEnd = p + m_cFields;
    while (p < pEnd)
        size += *p++;

    return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\utf.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-20-99    SamerA    Surrogate support.
   
This file was copied from the Windows XP code base on 5/01/2002
to ensure the CLR has appropriate UTF-8 surrogate support and can
recognize invalid UTF-8 sequences on all platforms.  -- BrianGru
--*/



//
//  Include Files.
//

#include <ole2.h>
#define NlsStrLenW(x) lstrlenW(x)
#include "utf.h"




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 4;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - UTF7: flags not 0.
    //     - UTF8: flags not 0 nor MB_ERR_INVALID_CHARS.
    //
    if (CodePage == CP_UTF8) 
    {
        // UTF8        
        if ((dwFlags & ~MB_ERR_INVALID_CHARS) != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    } 
    else if (dwFlags != 0)
    {
        // UTF7
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar,
                                dwFlags);
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    //CHAR is signed, so we have to cast lpSrcStr to an unsigned char below.
    BYTE* pUTF7 = (BYTE*)lpSrcStr;    
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
            // Terminate the shifted sequence.
            fShift = FALSE;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        if (cchSrc == 0 && fShift && *(pUTF7--) == SHIFT_OUT)
        {
            //
            // Do nothing here.
            // If we are in shift-in mode previously, and the last byte is a shift-out byte ('-'),
            // we should absorb this byte.  So don't set error.
            //
        } else
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  04-22-2002    ShawnSte  Fix bug 533476 where final characters are broken.
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags
    )
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    CONST BYTE* pUTF8 = (CONST BYTE*)lpSrcStr;
    DWORD dwUnicodeChar;           // Our character with room for full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    BOOL bCheckInvalidBytes = (dwFlags & MB_ERR_INVALID_CHARS);
    BYTE UTF8;

    // Note that we can't test destination buffer length here because we may have to
    // iterate through thousands of broken characters which won't be output, even though
    // the buffer has no more room.
    while (cchSrc--)
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                // In this function always test buffer size before using it
                if (cchWC >= cchDest)
                {
                    // Error: Buffer too small, we didn't process this character
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            nTB = bSurrogatePair = 0;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                // Add room for trail byte and add the trail byte falue
                dwUnicodeChar <<= 6;
                dwUnicodeChar |= LOWER_6_BIT(*pUTF8);

                // If we're done then we may need to store the data
                if (nTB == 0)
                {
                    if (bSurrogatePair)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) >= cchDest)
                            {
                                // Error: Buffer too small, we didn't process this character
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                

                            lpDestStr[cchWC]   = (WCHAR)
                                                 (((dwUnicodeChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                            lpDestStr[cchWC+1] = (WCHAR)
                                                 ((dwUnicodeChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                        }

                        //
                        //  End of sequence.  Advance the output counter, turn off surrogateness
                        //
                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                    else
                    {
                        if (cchDest)
                        {
                            
                            if (cchWC >= cchDest)
                            {
                                // Error: Buffer too small, we didn't process this character
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }

                            lpDestStr[cchWC] = (WCHAR)dwUnicodeChar;            
                        }

                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                      
                }
                        
            }
            else
            {
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }
                
                // error - not expecting a trail byte. That is, there is a trailing byte without leading byte.
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                // error - A leading byte before the previous sequence is completed.
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }            
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                // Put this character back so that we can start over another sequence.
                cchSrc++;
                pUTF8--;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                // Recover the data from the byte
                UTF8 >>= nTB;

                //
                // Check for non-shortest form.
                // 
                switch (nTB)
                {
                    case 1:
                        nTB = 0;
                        break;
                    case 2:
                        // Make sure that bit 8 ~ bit 11 is not all zero.
                        // 110XXXXx 10xxxxxx
                        if ((*pUTF8 & 0x1e) == 0)
                        {
                            nTB = 0;
                        }
                        break;
                    case 3:
                        // Look ahead to check for non-shortest form.
                        // 1110XXXX 10Xxxxxx 10xxxxxx
                        if (cchSrc >= 2)
                        {
                            if (((*pUTF8 & 0x0f) == 0) && (*(pUTF8 + 1) & 0x20) == 0)
                            {
                                nTB = 0;
                            }
                        }
                        break;
                    case 4:                    
                        //
                        // This is a surrogate unicode pair
                        //
                        if (cchSrc >= 3)
                        {
                            WORD word = (((WORD)*pUTF8) << 8) | *(pUTF8 + 1);
                            // Look ahead to check for non-shortest form.
                            // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx                        
                            // Check if the 5 X bits are all zero.
                            // 0x0730 == 00000111 00110000
                            if ( (word & 0x0730) == 0 ||
                                  // If the 21st bit is 1, we have extra work
                                  ( (word & 0x0400) == 0x0400 &&
                                     // The 21st bit is 1.
                                     // Make sure that the resulting Unicode is within the valid surrogate range.
                                     // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point range
                                     // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                     // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                     // bit are all zero.
                                     // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                     // XXXXX can only be 10000.    
                                     // 0x0330 = 0000 0011 0011 0000
                                    (word & 0x0330) != 0 ) )
                            {
                                // Not shortest form
                                nTB = 0;
                            }                              
                            else
                            { 
                                // A real surrogate pair
                                bSurrogatePair = TRUE;
                            }
                        }                        
                        break;
                    default:                    
                        // 
                        // If the bits is greater than 4, this is an invalid
                        // UTF8 lead byte.
                        //
                        nTB = 0;
                        break;
                }

                if (nTB != 0) 
                {
                    //
                    //  Store the value from the first byte and decrement
                    //  the number of bytes to follow.
                    //
                    dwUnicodeChar = UTF8;
                    nTB--;
                } else 
                {
                    if (bCheckInvalidBytes) 
                    {
                        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                        return (0);
                    }                 
                }
            }
        }
        pUTF8++;
    }

    if ((bCheckInvalidBytes && nTB != 0) || (cchWC == 0)) 
    {
        // About (cchWC == 0):
        // Because we now throw away non-shortest form, it is possible that we generate 0 chars.
        // In this case, we have to set error to ERROR_NO_UNICODE_TRANSLATION so that we conform
        // to the spec of MultiByteToWideChar.
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}

////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                if (cchU7 < cchDest) 
                {
                    lpDestStr[cchU7++] = SHIFT_OUT;
                } 
                else 
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 ++;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    if (cchU8 < cchDest) 
                    {
                        lpDestStr[cchU8] = (char)*lpWC;
                    } 
                    else 
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\winfix.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// WinWrap.cpp
//
// This file contains wrapper functions for Win32 API's that take strings.
// Support on each platform works as follows:
//      OS          Behavior
//      ---------   -------------------------------------------------------
//      NT          Fully supports both W and A funtions.
//      Win 9x      Supports on A functions, stubs out the W functions but
//                      then fails silently on you with no warning.
//      CE          Only has the W entry points.
//
// COM+ internally uses UNICODE as the internal state and string format.  This
// file will undef the mapping macros so that one cannot mistakingly call a
// method that isn't going to work.  Instead, you have to call the correct
// wrapper API.
//
//*****************************************************************************

#include "stdafx.h"                     // Precompiled header key.
#include "WinWrap.h"                    // Header for macros and functions.
#include "utilcode.h"
#include "psapi.h"
#include "tlhelp32.h"
#include "winnls.h"
#include "version/__file__.ver"


//********** Globals. *********************************************************
int             g_bOnUnicodeBox = -1;   // true if on UNICODE system.
bool            g_bUTF78Support = FALSE;// true if CP_UTF7 & 8 supported CORRECTLY
static int      g_bUseUnicodeAPI = -1;
bool            g_bWCtoMBBestFitMappingSupport = TRUE;  // true if WideCharToMultiByte supports WC_NO_BEST_FIT_CHARS.


// Return true if Unicode API should be used, false if ANSI should get used.
inline int UseUnicodeAPI()
{
#ifdef _DEBUG
    // For this to work, you must have called OnUnicodeSystem().  If you did
    // not, then this will never work.  Note that because the debug subsystem
    // uses these wrappers, we can't use _ASSERTE to do this check or you'll
    // get a stack overflow.
    if (g_bUseUnicodeAPI == -1 || g_bOnUnicodeBox == -1)
    {
        DebugBreak();
        return (false);
    }
#endif // _DEBUG

    return (g_bUseUnicodeAPI);
}


// Return true if UTF7/8 is fully supported (ie, surrogates & error detection), 
// false if it isn't.
inline bool UTF78Support()
{
#ifdef _DEBUG
    // For this to work, you must have called OnUnicodeSystem().  If you did
    // not, then this will never work.  Note that because the debug subsystem
    // uses these wrappers, we can't use _ASSERTE to do this check or you'll
    // get a stack overflow.
    if (g_bUseUnicodeAPI == -1 || g_bOnUnicodeBox == -1)
    {
        DebugBreak();
        return (false);
    }
#endif // _DEBUG

    return (g_bUTF78Support);
}

inline bool WCToMBBestFitMappingSupport()
{
    // Whether WideCharToMultiByte supports the ability to disable best
    // fit mapping via the WC_NO_BEST_FIT_CHARS flag (NT5 and higher, and Win98+)
    // Note on debug builds, this will sometimes be set to false on NT machines
    // just so we can force ourselves to test the NT 4-only code path.  This 
    // is just like the OnUnicodeSystem mutent based on a test's timestamp.
#ifdef _DEBUG
    // For this to work, you must have called OnUnicodeSystem().  If you did
    // not, then this will never work.  Note that because the debug subsystem
    // uses these wrappers, we can't use _ASSERTE to do this check or you'll
    // get a stack overflow.
    if (g_bUseUnicodeAPI == -1 || g_bOnUnicodeBox == -1)
    {
        DebugBreak();
        return (false);
    }
#endif // _DEBUG

    return (g_bWCtoMBBestFitMappingSupport);
}

ULONG DBCS_MAXWID=0;
const ULONG MAX_REGENTRY_LEN=256;

// From UTF.C
extern "C" {
    int UTFToUnicode(
        UINT CodePage,
        DWORD dwFlags,
        LPCSTR lpMultiByteStr,
        int cchMultiByte,
        LPWSTR lpWideCharStr,
        int cchWideChar);

    int UnicodeToUTF(
        UINT CodePage,
        DWORD dwFlags,
        LPCWSTR lpWideCharStr,
        int cchWideChar,
        LPSTR lpMultiByteStr,
        int cchMultiByte,
        LPCSTR lpDefaultChar,
        LPBOOL lpUsedDefaultChar);
};


//-----------------------------------------------------------------------------
// OnUnicodeSystem
//
// @func Determine if the OS that we are on, actually supports the unicode verion
// of the win32 API.  If YES, then g_bOnUnicodeBox == FALSE.
//
// @rdesc True of False
//-----------------------------------------------------------------------------------
BOOL OnUnicodeSystem()
{
    HKEY    hkJunk = HKEY_CURRENT_USER;
    CPINFO  cpInfo;

    // If we already did the test, return the value.  Otherwise go the slow route
    // and find out if we are or not.
    if (g_bOnUnicodeBox != -1)
        return (g_bOnUnicodeBox);

    // Per Shupak, you're supposed to get the maximum size of a DBCS char 
    // dynamically to work properly on all locales (bug 2757).
    if (GetCPInfo(CP_ACP, &cpInfo))
        DBCS_MAXWID = cpInfo.MaxCharSize;
    else
        DBCS_MAXWID = 2;        

    g_bOnUnicodeBox = TRUE;
    g_bUseUnicodeAPI = TRUE;

    // Detect if WCtoMB supports WC_NO_BEST_FIT_CHARS (NT5, XP, and Win98+)
    const WCHAR * const wStr = L"A";
    int r = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wStr, 1, NULL, 0, NULL, NULL);
    g_bWCtoMBBestFitMappingSupport = (r != 0);

    // Detect whether this platform supports UTF-7 & UTF-8 correctly. 
    // (Surrogates, invalid bytes, rejects non-shortest form)  WinXP & higher
    r = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, "A", -1, NULL, 0);
    g_bUTF78Support = (r != 0);

    // NT is always UNICODE.  GetVersionEx is faster than actually doing a
    // RegOpenKeyExW on NT, so figure it out that way and do hard way if you have to.
    OSVERSIONINFO   sVerInfo;
    sVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (WszGetVersionEx(&sVerInfo) && sVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        goto ErrExit;
    }

    // Check to see if we have win95's broken registry, thus
    // do not have Unicode support in the OS
    if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                     L"SOFTWARE",
                     0,
                     KEY_READ,
                     &hkJunk) == ERROR_SUCCESS) &&
        hkJunk == HKEY_CURRENT_USER)
    {
       // Try the ANSI version
        if ((RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                             "SOFTWARE",
                             0,
                            KEY_READ,
                            &hkJunk) == ERROR_SUCCESS) &&
            (hkJunk != HKEY_CURRENT_USER))

        {
            g_bOnUnicodeBox = FALSE;
            g_bUseUnicodeAPI = FALSE;
        }
    }

    if (hkJunk != HKEY_CURRENT_USER)
        RegCloseKey(hkJunk);


ErrExit:

#if defined( _DEBUG )
    {
    
    #if defined( _M_IX86 )
        // This little "mutent" forces a user to run ANSI on a UNICODE
        // machine on a regular basis.  Given most people run on NT for dev
        // test cases, they miss wrapper errors they've introduced.  This 
        // gives you an even chance of finding them sooner.

        // Base this on the time stamp in the exe.  This way it always repros,
        // and given that we rebuild our tests regularly, every test also
        // gets run both ways over time.  

        // Until release we will turn this off. Tests that have unicode
        // characters in names tend to fail on Unicode box's because
        // of the lossy nature of the conversion from unicode to DBCS.
        // These tests should not fail on unicode boxes and the false
        // positives are now wasting time. At the beginning of the next
        // version, remove the false to re-enable the test.
        if (g_bUseUnicodeAPI && DbgRandomOnExe(.5) && false) {
            g_bUseUnicodeAPI = false;
            g_bWCtoMBBestFitMappingSupport = false;
        }

        // In debug mode, allow the user to force the ANSI path.  This is good for
        // cases where you are only running on an NT machine, and you need to
        // test what a Win '9x machine would do.
        WCHAR       rcVar[96];
        if (WszGetEnvironmentVariable(L"WINWRAP_ANSI", rcVar, NumItems(rcVar)))
            g_bUseUnicodeAPI = (*rcVar == 'n' || *rcVar == 'N');

    #endif // _M_IX86 
    }
#endif // _DEBUG

    return g_bOnUnicodeBox;
}


/////////////////////////////////////////////////////////////////////////
//
// WARNING: below is a very large #ifdef that groups together all the 
//          wrappers that are X86-only.  They all mirror some function 
//          that is known to be available on the non-X86 win32 platforms
//          in only the Unicode variants.  
//
/////////////////////////////////////////////////////////////////////////
#ifdef PLATFORM_WIN32
#ifdef _X86_
//-----------------------------------------------------------------------------
// WszLoadLibraryEx
//
// @func Loads a Dynamic Library
//
// @rdesc Instance Handle
//-----------------------------------------------------------------------------------
HINSTANCE WszLoadLibraryEx(
    LPCWSTR lpLibFileName,      // points to name of executable module
    HANDLE hFile,               // reserved, must be NULL 
    DWORD dwFlags               // entry-point execution flag 
    )
{   
    HINSTANCE   hInst = NULL;
    LPSTR       szLibFileName = NULL;

    _ASSERTE( !hFile );

    if (UseUnicodeAPI())
        return  LoadLibraryExW(lpLibFileName, hFile, dwFlags);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpLibFileName,
                      &szLibFileName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hInst = LoadLibraryExA(szLibFileName, hFile, dwFlags);

Exit:
    delete[] szLibFileName;

    return hInst;
}

//-----------------------------------------------------------------------------
// WszLoadString
//
// @func Loads a Resource String and converts it to unicode if
// need be.
//
// @rdesc Length of string (Ansi is cb) (UNICODE is cch)
//-----------------------------------------------------------------------------------
int WszLoadString(
    HINSTANCE hInstance,    // handle of module containing string resource 
    UINT uID,               // resource identifier 
    LPWSTR lpBuffer,        // address of buffer for resource 
    int cchBufferMax        // size of buffer **in characters**
   )
{
    int     cbLen = 0;  
    PSTR    pStr = NULL;

    _ASSERTE( lpBuffer && cchBufferMax != 0 );
    if( !lpBuffer || cchBufferMax == 0 ) 
        return 0;    
    lpBuffer[0] = L'\0';

    if (UseUnicodeAPI())
        return  LoadStringW(hInstance, uID, lpBuffer, cchBufferMax);

    // Allocate a buffer for the string allowing room for
    // a multibyte string
    pStr = new CHAR[cchBufferMax];
    if( pStr == NULL )
        goto EXIT;

    cbLen = LoadStringA(hInstance, uID, pStr, cchBufferMax);

    _ASSERTE( cchBufferMax > 0 );
    if( (cbLen > 0) &&
        SUCCEEDED(WszConvertToUnicode(pStr, (cbLen + sizeof(CHAR)), &lpBuffer, 
        (ULONG*)&cchBufferMax, FALSE)) )
    {
        cbLen = lstrlenW(lpBuffer);
    }
    else
    {
        cbLen = 0;
    }

EXIT:
    delete[] pStr;

    return cbLen;
}

//-----------------------------------------------------------------------------
// WszFormatMessage
//
// @func Loads a Resource String and converts it to unicode if
// need be.
//
// @rdesc Length of string (Ansi is cb) (UNICODE is cch)
// (Not including '\0'.)
//-----------------------------------------------------------------------------------
DWORD WszFormatMessage
    (
    DWORD   dwFlags,        // source and processing options 
    LPCVOID lpSource,       // pointer to  message source 
    DWORD   dwMessageId,    // requested message identifier 
    DWORD   dwLanguageId,   // language identifier for requested message 
    LPWSTR  lpBuffer,       // pointer to message buffer 
    DWORD   nSize,          // maximum size of message buffer 
    va_list *Arguments      // address of array of message inserts 
    )
{
    PSTR    pStr = NULL;
    DWORD   cbLen = 0;  
    ULONG   cchOut = 0;
    const   int MAXARGS = 3;

    _ASSERTE( nSize >= 0 );

    if (UseUnicodeAPI())
        return  FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, 
                    lpBuffer, nSize, Arguments);

    LPSTR alpSource = 0;
    if (dwFlags & FORMAT_MESSAGE_FROM_STRING) 
    {
        _ASSERTE(lpSource != NULL);
        if (FAILED(WszConvertToAnsi((LPWSTR)lpSource, &alpSource, 0, NULL, TRUE)))
            return(0);
        lpSource = (LPCVOID) alpSource;
    }
    
    char* aArgs[MAXARGS];
    for (int i = 0; i < MAXARGS; i++)
    {
        aArgs[i] = NULL;
    }

    if (Arguments != 0) {
        _ASSERTE(dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY);

        LPWSTR*  wArgs = (LPWSTR*) Arguments;


        if (alpSource) {
            char* ptr = alpSource;
            for (;;) {                  // Count number of %
                ptr = strchr(ptr, '%');
                if (ptr == 0)
                    break;
                if (ptr[1] == '%')      // Don't count %%
                    ptr++;
                else if (ptr[1] >= '1' && ptr[1] <= '9')
                {
                    if (ptr[1] > '0' + MAXARGS)
                    {
                        _ASSERTE(!"WinFix implementation restriction: no more than 3 inserts allowed!");
                    }
                    if (wArgs[ptr[1] - '1'])
                    {
                        if (FAILED(WszConvertToAnsi(wArgs[ptr[1] - '1'], &aArgs[ptr[1] - '1'], 0, NULL, TRUE)))
                            goto CLEANUP_ARGS;
                    }
                }
                ptr++;
            }
        }
        else {
            // We are fetching from a HR.  For now we only handle the one arg case
            aArgs[1] = aArgs[2] = "<Unknown>";
            if (wArgs[0])
            {
                if (FAILED(WszConvertToAnsi(wArgs[0], &aArgs[0], 0, NULL, TRUE)))
                    goto CLEANUP_ARGS;
            }
        }

        Arguments = (va_list*) aArgs;
    }

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        cbLen = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId, 
                               (char*)&pStr, nSize, Arguments);

        if (nSize <= cbLen)
            nSize = cbLen+1;

        *(LPWSTR*)lpBuffer = (LPWSTR) LocalAlloc(LPTR, nSize*sizeof(WCHAR));
    }
    else
    {
        pStr = new CHAR[nSize];
        if( pStr )
        {
            cbLen = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId, 
                                (char*)pStr, nSize, Arguments);
        }
    }

    if( pStr )
    {
        if( cbLen != 0 )
        {
            cbLen++;    //For '\0'

            cchOut = cbLen;

            if( FAILED(WszConvertToUnicode(pStr, cbLen, 
                                           (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) 
                                           ? (LPWSTR*)lpBuffer : &lpBuffer,
                                           &cchOut, FALSE)) )
                cchOut = 0;
            else
                cchOut--;   // Decrement count to exclude '\0'
        }
    }

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
        LocalFree(pStr);
    else
        delete[] pStr;

CLEANUP_ARGS:
    for (unsigned i = 0; i < MAXARGS; i++)
        delete [] aArgs[i];

    delete[] alpSource;

    // Return excludes null terminator
    return cchOut;
}

#if 0 // don't need this, use FullPath instead.
//-----------------------------------------------------------------------------
// WszFullPath
//
// @func Retrieves the absolute path from a relative path
//
// @rdesc If the function succeeds, the return value is the length, 
// in characters, of the string copied to the buffer.
//-----------------------------------------------------------------------------------
LPWSTR WszFullPath
    (
    LPWSTR      absPath,    //@parm INOUT | Buffer for absolute path 
    LPCWSTR     relPath,    //@parm IN | Relative path to convert
    ULONG       maxLength   //@parm IN | Maximum length of the absolute path name buffer 
    )
{
    PSTR    pszRel = NULL;
    PSTR    pszAbs = NULL;
    PWSTR   pwszReturn = NULL;

    if( UseUnicodeAPI() ) 
        return _wfullpath( absPath, relPath, maxLength );

    // No Unicode Support
    pszAbs = new char[maxLength * DBCS_MAXWID];
    if( pszAbs )
    {
        if( FAILED(WszConvertToAnsi(relPath,
                          &pszRel, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        if( _fullpath(pszAbs, pszRel, maxLength * DBCS_MAXWID) )
        {
            if( SUCCEEDED(WszConvertToUnicode(pszAbs, -1, &absPath, 
                &maxLength, FALSE)) )
            {
                pwszReturn = absPath;
            }
        }


    }

Exit:
    delete[] pszRel;
    delete[] pszAbs;

    // Return 0 if error, else count of characters in buffer
    return pwszReturn;
}
#endif // 0 -- to knock out FullPath wrapper


DWORD
WszGetFullPathName(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    if (UseUnicodeAPI())
        return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    
    DWORD       rtn;
    int         iOffset;
    LPSTR       rcFileName;
    LPSTR       szBuffer;
    LPSTR       szFilePart;
    CQuickBytes qbBuffer;

    int         cbFileName = _MAX_PATH * DBCS_MAXWID;
    rcFileName = (LPSTR) alloca(cbFileName);
    szBuffer = (LPSTR) qbBuffer.Alloc(nBufferLength * 2);
    if (!szBuffer)
        return (0);
    Wsz_wcstombs(rcFileName, lpFileName, cbFileName);
    
    rtn = GetFullPathNameA(rcFileName, nBufferLength * 2, szBuffer, &szFilePart);   
    if (rtn)
    {
        Wsz_mbstowcs(lpBuffer, szBuffer, nBufferLength);

        if (lpFilePart)
        {
            iOffset = MultiByteToWideChar(CP_ACP, 0, szBuffer, szFilePart - szBuffer,
                    NULL, 0);
            *lpFilePart = &lpBuffer[iOffset];
        }
    }
    else if (lpBuffer && nBufferLength)
        *lpBuffer = 0;
    return (rtn);
}


//-----------------------------------------------------------------------------
// WszSearchPath
//
// @func SearchPath for a given file name
//
// @rdesc If the function succeeds, the value returned is the length, in characters, 
//   of the string copied to the buffer, not including the terminating null character. 
//   If the return value is greater than nBufferLength, the value returned is the size 
//   of the buffer required to hold the path. 
//-----------------------------------------------------------------------------------
DWORD WszSearchPath
    (
    LPWSTR      wzPath,     // @parm IN | address of search path 
    LPWSTR      wzFileName, // @parm IN | address of filename 
    LPWSTR      wzExtension,    // @parm IN | address of extension 
    DWORD       nBufferLength,  // @parm IN | size, in characters, of buffer 
    LPWSTR      wzBuffer,       // @parm IN | address of buffer for found filename 
    LPWSTR      *pwzFilePart    // @parm OUT | address of pointer to file component 
    )
{

    PSTR    szPath = NULL;
    PSTR    szFileName = NULL;
    PSTR    szExtension = NULL;
    PSTR    szBuffer = NULL;
    PSTR    szFilePart = NULL;
    DWORD   dwRet = 0;
    ULONG   cCh, cChConvert;

    if( UseUnicodeAPI() ) 
        return SearchPathW( wzPath, wzFileName, wzExtension, nBufferLength, wzBuffer, pwzFilePart);

    // No Unicode Support
    if( FAILED(WszConvertToAnsi(wzPath,
                            &szPath,
                            0,
                            NULL,
                            TRUE)) ||
        FAILED(WszConvertToAnsi(wzFileName,
                            &szFileName,
                            0,
                            NULL,
                            TRUE)) ||
        FAILED(WszConvertToAnsi(wzExtension,
                            &szExtension,
                            0,
                            NULL,
                            TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    szBuffer = new char[nBufferLength * DBCS_MAXWID];

    dwRet = SearchPathA(szPath, szFileName, szExtension, nBufferLength * DBCS_MAXWID, szBuffer, 
        pwzFilePart ? &szFilePart : NULL);

    if (dwRet == 0) 
    {
        // SearchPathA failed
        goto Exit;
    }
    cCh = 0;
    cChConvert = nBufferLength;

    // to get the count of unicode character into buffer
    if( szFilePart )
    {
        // this won't trigger the conversion sinch cCh == 0
        cCh = (MultiByteToWideChar(CP_ACP,
                                0,                              
                                szBuffer,
                                (int) (szFilePart - szBuffer),
                                NULL,
                                0));
        _ASSERTE(cCh);
    }

    if( FAILED(WszConvertToUnicode(
            szBuffer, 
            dwRet > nBufferLength ? nBufferLength : -1, // if buffer is not big enough, we may not have NULL char
            &wzBuffer, 
            &cChConvert, 
            FALSE)) )
    {
        // fail in converting to Unicode
        dwRet = 0;
    }
    else 
    {
        dwRet = cChConvert;             // return the count of unicode character being converted
        if (pwzFilePart)
            *pwzFilePart = wzBuffer + cCh;  // update the pointer of the file part

    }
Exit:
    delete[] szPath;
    delete[] szFileName;
    delete[] szExtension;
    delete[] szBuffer;

    // Return 0 if error, else count of characters in buffer
    return dwRet;
}


//-----------------------------------------------------------------------------
// WszGetModuleFileName
//
// @func Retrieves the full path and filename for the executable file 
// containing the specified module. 
//
// @rdesc If the function succeeds, the return value is the length, 
// in characters, of the string copied to the buffer.
//-----------------------------------------------------------------------------------
DWORD WszGetModuleFileName
    (
    HMODULE hModule,        //@parm IN    | handle to module to find filename for 
    LPWSTR lpwszFilename,   //@parm INOUT | pointer to buffer for module path 
    DWORD nSize             //@parm IN    | size of buffer, in characters 
    )
{
    DWORD   dwVal = 0;
    PSTR    pszBuffer = NULL;


    _ASSERTE(nSize && lpwszFilename);
    if( nSize == 0 || lpwszFilename == NULL)
        return dwVal;
    *lpwszFilename = L'\0';    

    if( UseUnicodeAPI() ) 
        return GetModuleFileNameW(hModule, lpwszFilename, nSize);

    // No Unicode Support
    pszBuffer = new char[nSize * DBCS_MAXWID];
    if( pszBuffer )
    {
        dwVal = GetModuleFileNameA(hModule, pszBuffer, (nSize * DBCS_MAXWID));

        if(dwVal) {
            if(FAILED(WszConvertToUnicode(pszBuffer, -1, &lpwszFilename, &nSize, FALSE)))
                dwVal = 0;
            else
                dwVal = nSize - 1;
        }

        delete[] pszBuffer;
    }

    // Return 0 if error, else count of characters in buffer
    return dwVal;
}

//-----------------------------------------------------------------------------
// WszGetPrivateProfileInt
//
// @func Retrieve values from a profile file
//
// @rdesc returns the value from the file, or if not found, the default value.
//-----------------------------------------------------------------------------------
UINT WszGetPrivateProfileInt
    (
    LPCWSTR    wszAppName,
    LPCWSTR    wszKeyName,
    INT        nDefault,
    LPCWSTR    wszFileName
    )
{
    if (UseUnicodeAPI())
    {
        return GetPrivateProfileIntW(wszAppName,
                                     wszKeyName,
                                     nDefault,
                                     wszFileName);
    }

    LPSTR lpFileName = NULL;
    HRESULT hr = WszConvertToAnsi(wszFileName, &lpFileName, -1, NULL, TRUE);
    if (FAILED(hr))
        return nDefault;

    MAKE_ANSIPTR_FROMWIDE(lpAppName, wszAppName);
    MAKE_ANSIPTR_FROMWIDE(lpKeyName, wszKeyName);
    
    int ret = GetPrivateProfileIntA(lpAppName, lpKeyName, nDefault, lpFileName);

    delete[] lpFileName;
    return ret;
}

     
//-----------------------------------------------------------------------------
// WszGetPrivateProfileString
//
// @func Retrieve values from a profile file
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from GetPrivateProfileString,
// which is num chars copied, not including '\0'.
//-----------------------------------------------------------------------------------
DWORD WszGetPrivateProfileString
    (
    LPCWSTR     lpwszSection,
    LPCWSTR     lpwszEntry,
    LPCWSTR     lpwszDefault,
    LPWSTR      lpwszRetBuffer,
    DWORD       cchRetBuffer,       
    LPCWSTR     lpwszFile
    )   
{
    if (UseUnicodeAPI())
    {
        return GetPrivateProfileStringW(lpwszSection,
                                        lpwszEntry,
                                        lpwszDefault,
                                        lpwszRetBuffer,
                                        cchRetBuffer,
                                        lpwszFile);
    } else if (!lpwszRetBuffer || cchRetBuffer == 0)
    {
        return 0;
    } else
    {
        LPSTR   pszSection = NULL;
        LPSTR   pszEntry = NULL;
        LPSTR   pszDefault = NULL;
        LPWSTR  pwszRetBuffer = NULL;
        LPSTR   pszFile = NULL;
        DWORD   dwRet = 0;

        if( FAILED(WszConvertToAnsi(lpwszSection,
                            &pszSection,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszEntry,
                            &pszEntry,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszDefault,
                            &pszDefault,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszFile,
                            &pszFile,
                            0,
                            NULL,
                            TRUE)) ) 
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        dwRet = GetPrivateProfileStringA(pszSection,
                                    pszEntry,
                                    pszDefault,
                                    (LPSTR) lpwszRetBuffer,
                                    cchRetBuffer,
                                    pszFile);
        if (dwRet == 0)
        {
            *lpwszRetBuffer = L'\0';
        }
        else {
            DWORD               dw;

            if ((lpwszSection && lpwszEntry && (dwRet == cchRetBuffer - 1)) ||
                ((!lpwszSection || !lpwszEntry) && (dwRet == cchRetBuffer - 2))) {
                dw = cchRetBuffer;
            }
            else {
                dw = dwRet + 1;
            }

            if (FAILED(WszConvertToUnicode((LPSTR)lpwszRetBuffer, dw, &pwszRetBuffer,
                                           &dw, TRUE))) {
                dwRet = 0;
                goto Exit;
            }

            memcpy(lpwszRetBuffer, pwszRetBuffer, (dw) * sizeof(WCHAR));
        }

Exit:
        delete[] pszSection;
        delete[] pszEntry;
        delete[] pszDefault;
        delete[] pwszRetBuffer;
        delete[] pszFile;

        return dwRet;
    }   
}


//-----------------------------------------------------------------------------
// WszWritePrivateProfileString
//
// @func Write values to a profile file
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
BOOL WszWritePrivateProfileString
    (
    LPCWSTR     lpwszSection,
    LPCWSTR     lpwszKey,
    LPCWSTR     lpwszString,
    LPCWSTR     lpwszFile
    )
{
    if (UseUnicodeAPI())
    {
        return WritePrivateProfileStringW(lpwszSection,
                                        lpwszKey,
                                        lpwszString,
                                        lpwszFile);
    } else
    {
        LPSTR   pszSection = NULL;
        LPSTR   pszKey = NULL;
        LPSTR   pszString = NULL;
        LPSTR   pszFile = NULL;
        BOOL    fRet = FALSE;

        if( FAILED(WszConvertToAnsi(lpwszSection,
                            &pszSection,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszKey,
                            &pszKey,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszString,
                            &pszString,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszFile,
                            &pszFile,
                            0,
                            NULL,
                            TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        fRet = WritePrivateProfileStringA(pszSection,
                                    pszKey,
                                    pszString,
                                    pszFile);
Exit:   
        delete[] pszSection;
        delete[] pszKey;
        delete[] pszString;
        delete[] pszFile;
        return fRet;
    }
}


//-----------------------------------------------------------------------------
// WszCreateFile
//
// @func CreateFile
//
// @rdesc File handle.
//-----------------------------------------------------------------------------------
HANDLE WszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
{
    LPSTR pszFileName = NULL;
    HANDLE hReturn;

    if ( UseUnicodeAPI() )
    {
        hReturn = CreateFileW( 
            pwszFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDistribution,
            dwFlagsAndAttributes,
            hTemplateFile );
    }
    else
    {
        // Win95, so convert.
        if ( FAILED(WszConvertToAnsi( 
                    pwszFileName,
                    &pszFileName, 
                    0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            hReturn = INVALID_HANDLE_VALUE;
        }
        else
        {
            hReturn = CreateFileA( 
                pszFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDistribution,
                dwFlagsAndAttributes,
                hTemplateFile );
        }
        delete [] pszFileName;
    }

    if (hReturn != INVALID_HANDLE_VALUE)
    {
        if (GetFileType( hReturn ) != FILE_TYPE_DISK)
        {
            CloseHandle( hReturn );
            hReturn = INVALID_HANDLE_VALUE;
            SetLastError( COR_E_DEVICESNOTSUPPORTED );
        }
    }

    return hReturn;
}


//-----------------------------------------------------------------------------
// WszCopyFile
//
// @func CopyFile
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszCopyFile(
    LPCWSTR pwszExistingFileName,   // pointer to name of an existing file 
    LPCWSTR pwszNewFileName,    // pointer to filename to copy to 
    BOOL bFailIfExists )    // flag for operation if file exists 
{
    LPSTR pszExistingFileName = NULL;
    LPSTR pszNewFileName = NULL;
    BOOL  fReturn;

    if ( UseUnicodeAPI() )
        return CopyFileW( pwszExistingFileName, pwszNewFileName, bFailIfExists );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszExistingFileName,
                &pszExistingFileName, 
                0, NULL, TRUE))
    ||   FAILED(WszConvertToAnsi( 
                pwszNewFileName,
                &pszNewFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        fReturn = CopyFileA( pszExistingFileName, pszNewFileName, bFailIfExists );
    }
    delete [] pszExistingFileName;
    delete [] pszNewFileName;
    return fReturn;
}

//-----------------------------------------------------------------------------
// WszMoveFile
//
// @func MoveFile
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszMoveFile(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName )    // address of new name for the file 
{
    LPSTR pszExistingFileName = NULL;
    LPSTR pszNewFileName = NULL;
    BOOL  fReturn;

    if ( UseUnicodeAPI() )
        return MoveFileW( pwszExistingFileName, pwszNewFileName );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszExistingFileName,
                &pszExistingFileName, 
                0, NULL, TRUE))
    ||   FAILED(WszConvertToAnsi( 
                pwszNewFileName,
                &pszNewFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        fReturn = MoveFileA( pszExistingFileName, pszNewFileName );
    }
    delete [] pszExistingFileName;
    delete [] pszNewFileName;
    return fReturn;
}


//-----------------------------------------------------------------------------
// WszMoveFileEx
//
// @func MoveFileEx
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszMoveFileEx(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName,    // address of new name for the file 
    DWORD dwFlags )     // flag to determine how to move file 
{
    LPSTR pszExistingFileName = NULL;
    LPSTR pszNewFileName = NULL;
    BOOL  fReturn;

    // NOTE!  MoveFileExA is not implemented in Win95.
    // And MoveFile does *not* move a file; its function is really rename-a-file.
    // So for Win95 we have to do Copy+Delete.
    _ASSERTE( dwFlags == (MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ));

    if ( UseUnicodeAPI() )
        return MoveFileExW( pwszExistingFileName, pwszNewFileName, dwFlags );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszExistingFileName,
                &pszExistingFileName, 
                0, NULL, TRUE))
    ||   FAILED(WszConvertToAnsi( 
                pwszNewFileName,
                &pszNewFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        // Copy files, and overwrite existing.
        fReturn = CopyFileA( pszExistingFileName, pszNewFileName, FALSE );
        // Try to delete current one (irrespective of copy failures).
        DeleteFileA( pszExistingFileName );
    }
    delete [] pszExistingFileName;
    delete [] pszNewFileName;
    return fReturn;
}


//-----------------------------------------------------------------------------
// WszDeleteFile
//
// @func DeleteFile
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszDeleteFile(
    LPCWSTR pwszFileName )  // address of name of the existing file  
{
    LPSTR pszFileName = NULL;
    BOOL  fReturn;

    if ( UseUnicodeAPI() )
        return DeleteFileW( pwszFileName );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszFileName,
                &pszFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        fReturn = DeleteFileA( pszFileName );
    }
    delete [] pszFileName;
    return fReturn;
}
 

//-----------------------------------------------------------------------------
// WszSetFileSecurity
//
// @func SetFileSecurity
//
// @rdesc Set ACL on file.
//-----------------------------------------------------------------------------------
BOOL WszSetFileSecurity(
    LPCWSTR lpwFileName,                       // file name   
    SECURITY_INFORMATION SecurityInformation,  // contents
    PSECURITY_DESCRIPTOR pSecurityDescriptor ) // sd 
{
    LPSTR lpFileName = NULL;
    BOOL bReturn;

    if ( UseUnicodeAPI() )
        return SetFileSecurityW( 
            lpwFileName,
            SecurityInformation,
            pSecurityDescriptor );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                lpwFileName,
                &lpFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        bReturn = FALSE;
    }
    else
    {
        bReturn = SetFileSecurityA( 
            lpFileName,
            SecurityInformation,
            pSecurityDescriptor );
    }
    delete [] lpFileName;
    return bReturn;
}



//-----------------------------------------------------------------------------
// WszGetDriveType
//
// @func GetDriveType
//-----------------------------------------------------------------------------------
UINT WszGetDriveType(
    LPCWSTR lpwRootPath )
{
    LPSTR lpRootPath = NULL;
    UINT uiReturn;

    if ( UseUnicodeAPI() )
        return GetDriveTypeW( 
            lpwRootPath );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                lpwRootPath,
                &lpRootPath, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        uiReturn = DRIVE_UNKNOWN;
    }
    else
    {
        uiReturn = GetDriveTypeA( 
            lpRootPath );
    }
    delete [] lpRootPath;
    return uiReturn;
}

//-----------------------------------------------------------------------------
// WszGetVolumeInformation
//
// @func GetVolumeInformation
//-----------------------------------------------------------------------------------
BOOL WszGetVolumeInformation(
  LPCWSTR lpwRootPathName,          // root directory
  LPWSTR lpwVolumeNameBuffer,       // volume name buffer
  DWORD nVolumeNameSize,            // length of name buffer
  LPDWORD lpVolumeSerialNumber,     // volume serial number
  LPDWORD lpMaximumComponentLength, // maximum file name length
  LPDWORD lpFileSystemFlags,        // file system options
  LPWSTR lpwFileSystemNameBuffer,   // file system name buffer
  DWORD nFileSystemNameSize)        // length of file system name buffer 
{
    LPSTR lpRootPathName = NULL;
    LPSTR lpVolumeNameBuffer = NULL;
    LPSTR lpFileSystemNameBuffer = NULL;

    BOOL bReturn = FALSE;

    if ( UseUnicodeAPI() )
        return GetVolumeInformationW(
            lpwRootPathName,
            lpwVolumeNameBuffer,
            nVolumeNameSize,
            lpVolumeSerialNumber,
            lpMaximumComponentLength,
            lpFileSystemFlags,
            lpwFileSystemNameBuffer,
            nFileSystemNameSize );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi(
                lpwRootPathName,
                &lpRootPathName,
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        bReturn = FALSE;
        goto EXIT;
    }

    // Allocate a buffer for the string allowing room for
    // a multibyte string
    if(lpwVolumeNameBuffer)
    {
        lpVolumeNameBuffer = new CHAR[nVolumeNameSize * sizeof(WCHAR)];
        if( lpVolumeNameBuffer == NULL )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto EXIT;
        }
    }

    if(lpwFileSystemNameBuffer)
    {
        lpFileSystemNameBuffer = new CHAR[nFileSystemNameSize * sizeof(WCHAR)];
        if( lpFileSystemNameBuffer == NULL )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto EXIT;
        }
    }

    bReturn = GetVolumeInformationA(
        lpRootPathName,
        lpVolumeNameBuffer,
        nVolumeNameSize * sizeof(WCHAR),
        lpVolumeSerialNumber,
        lpMaximumComponentLength,
        lpFileSystemFlags,
        lpFileSystemNameBuffer,
        nFileSystemNameSize * sizeof(WCHAR));


    if(lpVolumeNameBuffer)
    {
        if( FAILED(WszConvertToUnicode(lpVolumeNameBuffer, -1, &lpwVolumeNameBuffer,
            &nVolumeNameSize, FALSE)) )
            bReturn = FALSE;
    }

    if(lpFileSystemNameBuffer)
    {
        if( FAILED(WszConvertToUnicode(lpFileSystemNameBuffer, -1, &lpwFileSystemNameBuffer,
            &nFileSystemNameSize, FALSE)) )
            bReturn = FALSE;
    }

EXIT :

    delete [] lpRootPathName;
    delete [] lpVolumeNameBuffer;
    delete [] lpFileSystemNameBuffer;

    return bReturn;
}

//-----------------------------------------------------------------------------
// WszRegOpenKeyEx
//
// @func Opens a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegOpenKeyEx
//-----------------------------------------------------------------------------
LONG WszRegOpenKeyEx
    (
    HKEY    hKey,
    LPCWSTR wszSub,
    DWORD   dwRes,
    REGSAM  sam,
    PHKEY   phkRes
    )
{
    LPSTR   szSub= NULL;
    LONG    lRet;

    if (UseUnicodeAPI())
        return  RegOpenKeyExW(hKey,wszSub,dwRes,sam,phkRes);

    if( FAILED(WszConvertToAnsi((LPWSTR)wszSub,
                      &szSub, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegOpenKeyExA(hKey,(LPCSTR)szSub,dwRes,sam,phkRes);

Exit:
    delete[] szSub;

    return lRet;
}


//-----------------------------------------------------------------------------
// WszRegEnumKeyEx
//
// @func Opens a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegOpenKeyEx
//-----------------------------------------------------------------------------------
LONG WszRegEnumKeyEx
    (
    HKEY        hKey,
    DWORD       dwIndex,
    LPWSTR      lpName,
    LPDWORD     lpcName,
    LPDWORD     lpReserved,
    LPWSTR      lpClass,
    LPDWORD     lpcClass,
    PFILETIME   lpftLastWriteTime
    )
{
    LONG    lRet = ERROR_NOT_ENOUGH_MEMORY;
    PSTR    szName = NULL, 
            szClass = NULL;

    if (UseUnicodeAPI())
        return RegEnumKeyExW(hKey, dwIndex, lpName,
                lpcName, lpReserved, lpClass,
                lpcClass, lpftLastWriteTime);
        

    // Sigh, it is win95

    if ((lpcName) && (*lpcName  > 0))
    {
        szName = new char[*lpcName];
        if (!(szName))
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

    }

    if ((lpcClass) && (*lpcClass > 0))
    {
        szClass = new char[*lpcClass];
        if (!(szClass))
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

    }

    lRet = RegEnumKeyExA(
            hKey,
            dwIndex,
            szName,
            lpcName,
            lpReserved,
            szClass,
            lpcClass,
            lpftLastWriteTime);


    // lpcName and lpcClass filled in by RegEnumValueExA do not include the null terminating 
    // character, so we need to use *lpcName + 1 and *lpcClass + 1 to include the trailing null char
    if (lRet == ERROR_SUCCESS)
    {
        if (szName)
        {
            if (!MultiByteToWideChar(    CP_ACP,
                                                  0,                              
                                                  szName,
                                                 *lpcName + 1,
                                                 lpName,
                                                 *lpcName + 1))
           {
                lRet = GetLastError();
                goto Exit;
           }
        }

        if (szClass)
        {

            if (!MultiByteToWideChar(    CP_ACP,
                                                  0,                              
                                                  szClass,
                                                 *lpcClass + 1,
                                                  lpClass,
                                                  *lpcClass + 1))
           {
                
                lRet = GetLastError();
                goto Exit;
           }
        }
    }

Exit:
    delete[] szName;
    delete[] szClass;

    return  lRet;
}


//-----------------------------------------------------------------------------
// WszRegDeleteKey
//
// @func Delete a key from the registry
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegDeleteKey
//-----------------------------------------------------------------------------------
LONG WszRegDeleteKey
    (
    HKEY    hKey,
    LPCWSTR lpSubKey
    )
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;

    if( UseUnicodeAPI() )
        return RegDeleteKeyW(hKey,lpSubKey);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegDeleteKeyA(hKey,szSubKey);

Exit:
    delete[] szSubKey;

    return lRet;
}


//-----------------------------------------------------------------------------
// WszRegSetValueEx
//
// @func Add a value to a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
LONG WszRegSetValueEx
    (
    HKEY        hKey,
    LPCWSTR     lpValueName,
    DWORD       dwReserved,
    DWORD       dwType,
    CONST BYTE  *lpData,
    DWORD       cbData
    )
{
    LPSTR   szValueName = NULL;
    LPSTR   szData = NULL;
    LONG    lRet;

    if (UseUnicodeAPI())
        return RegSetValueExW(hKey,lpValueName,dwReserved,dwType,lpData,cbData);

    // Win95, now convert

    if( FAILED(WszConvertToAnsi((LPWSTR)lpValueName,
                      &szValueName, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    switch (dwType)
    {
        case    REG_MULTI_SZ:
        {
            szData = new CHAR[cbData];
            if( FAILED(WszConvertToAnsi((LPWSTR)lpData,
                              &szData, cbData, &cbData, FALSE)) )
            {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
            szData[cbData++] = '\0';
            lpData = (const BYTE *)(szData);
        }
        break;

        case    REG_EXPAND_SZ:
        case    REG_SZ:
        {
            if( FAILED(WszConvertToAnsi((LPWSTR)lpData,
                              &szData, 0, NULL, TRUE)) )
            {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
            lpData = (const BYTE *)(szData);
            cbData = cbData / sizeof(WCHAR);
        }
    }

    lRet =  RegSetValueExA(hKey,szValueName,dwReserved,dwType,lpData,cbData);

Exit:
    delete[] szValueName;
//@TODO Odbc DM does not free szData
    delete[] szData;

    return  lRet;
}


//-----------------------------------------------------------------------------
// WszRegCreateKeyEx
//
// @func Create a Registry key entry
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
LONG WszRegCreateKeyEx
    (
    HKEY                    hKey,
    LPCWSTR                 lpSubKey,
    DWORD                   dwReserved,
    LPWSTR                  lpClass,
    DWORD                   dwOptions,
    REGSAM                  samDesired,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    PHKEY                   phkResult,
    LPDWORD                 lpdwDisposition
    )
{
    long    lRet = ERROR_NOT_ENOUGH_MEMORY;

    LPSTR   szSubKey = NULL, 
            szClass = NULL;

    _ASSERTE(lpSubKey != NULL);

    if( UseUnicodeAPI() )
        return RegCreateKeyExW(hKey,lpSubKey,dwReserved,lpClass,
                               dwOptions,samDesired,lpSecurityAttributes,
                               phkResult,lpdwDisposition);

    // Non Win95, now convert
    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if( FAILED(WszConvertToAnsi((LPWSTR)lpClass,
                      &szClass,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegCreateKeyExA(hKey,szSubKey,dwReserved,szClass,
                               dwOptions,samDesired,lpSecurityAttributes,
                               phkResult,lpdwDisposition);


Exit:
    delete[] szSubKey;
    delete[] szClass;

    return  lRet;
}


LONG WszRegQueryValue(HKEY hKey, LPCWSTR lpSubKey,
    LPWSTR lpValue, PLONG lpcbValue)
{
    long    lRet = ERROR_NOT_ENOUGH_MEMORY;

    LPSTR   szSubKey = NULL;
    LPSTR   szValue = NULL;

    if( UseUnicodeAPI() )
        return RegQueryValueW(hKey, lpSubKey, lpValue, lpcbValue);

    if ((lpValue) && (lpcbValue) && (*lpcbValue) && 
        ((szValue = new char[*lpcbValue]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    LONG    cbNumBytes = *lpcbValue;
    if ((lRet = RegQueryValueA(hKey, szSubKey, 
                szValue, &cbNumBytes)) != ERROR_SUCCESS)
        goto Exit;

    // convert output to unicode.
    if ((lpcbValue) && (lpValue) && (szValue))
    {
        if (!MultiByteToWideChar(CP_ACP, 0, szValue, -1, lpValue, (*lpcbValue)/sizeof(WCHAR)))
        {
            lRet = GetLastError();
            _ASSERTE(0);
            goto Exit;
        }

    }
    lRet = ERROR_SUCCESS;

Exit:

    // Fix up lpcbValue to be the number of bytes in Wide character land.

    if (lpcbValue)
        *lpcbValue = (*lpcbValue)*sizeof(WCHAR)/sizeof(CHAR);
    
    delete[] szSubKey;
    delete[] szValue;
    return  lRet;
}


LONG WszRegDeleteValue(HKEY hKey, LPCWSTR lpValueName)
{
    LONG    lRet;
    LPSTR   szValueName = NULL;

    if (UseUnicodeAPI())
        return RegDeleteValueW(hKey, lpValueName);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpValueName, &szValueName, 0, NULL, 
        TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegDeleteValueA(hKey, szValueName);

Exit:
    delete[] szValueName;

    return lRet;
}


LONG WszRegLoadKey(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;
    LPSTR   szFile = NULL;

    _ASSERTE(lpSubKey != NULL && lpFile != NULL);

    if (UseUnicodeAPI())
        return RegLoadKeyW(hKey, lpSubKey, lpFile);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey, &szSubKey, 0, NULL, TRUE)) || 
        FAILED(WszConvertToAnsi((LPWSTR)lpFile, &szFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegLoadKeyA(hKey, szSubKey, szFile);

Exit:
    delete[] szSubKey;
    delete[] szFile;

    return lRet;
}


LONG WszRegUnLoadKey(HKEY hKey, LPCWSTR lpSubKey)
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;

    _ASSERTE(lpSubKey != NULL);

    if (UseUnicodeAPI())
        return RegUnLoadKeyW(hKey, lpSubKey);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey, &szSubKey, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegUnLoadKeyA(hKey, szSubKey);

Exit:
    delete[] szSubKey;

    return lRet;
}


LONG WszRegRestoreKey(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
{
    LONG    lRet;
    LPSTR   szFile = NULL;

    _ASSERTE(lpFile != NULL);

    if (UseUnicodeAPI())
        return RegRestoreKeyW(hKey, lpFile, dwFlags);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpFile, &szFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegRestoreKeyA(hKey, szFile, dwFlags);

Exit:
    delete[] szFile;

    return lRet;
}


LONG WszRegReplaceKey(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile,
    LPCWSTR lpOldFile)
{
    LONG    lRet;
    LPSTR   szSubKey  = NULL;
    LPSTR   szNewFile = NULL;
    LPSTR   szOldFile = NULL;

    _ASSERTE(lpNewFile != NULL && lpOldFile != NULL);

    if (UseUnicodeAPI())
        return RegReplaceKeyW(hKey, lpSubKey, lpNewFile, lpOldFile);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,  &szSubKey,  0, NULL, TRUE))||
        FAILED(WszConvertToAnsi((LPWSTR)lpNewFile, &szNewFile, 0, NULL, TRUE))||
        FAILED(WszConvertToAnsi((LPWSTR)lpOldFile, &szOldFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegReplaceKeyA(hKey, szSubKey, szNewFile, szOldFile);

Exit:
    delete[] szSubKey;
    delete[] szNewFile;
    delete[] szOldFile;

    return lRet;
}


LONG WszRegQueryInfoKey(HKEY hKey, LPWSTR lpClass, LPDWORD lpcClass,
    LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen,
    LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen,
    LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime)
{
    LONG    lRet;
    LPSTR   szClass = NULL;

    if (UseUnicodeAPI())
        return RegQueryInfoKeyW(hKey, lpClass, lpcClass, lpReserved, 
            lpcSubKeys, lpcMaxSubKeyLen, lpcMaxClassLen, lpcValues, 
            lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor,
            lpftLastWriteTime);

    if ((lpcClass) && (*lpcClass) && 
        ((szClass = new char[*lpcClass]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if ((lRet = RegQueryInfoKeyA(hKey, szClass, lpcClass, lpReserved, 
            lpcSubKeys, lpcMaxSubKeyLen, lpcMaxClassLen, lpcValues, 
            lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor,
            lpftLastWriteTime)) != ERROR_SUCCESS)
        goto Exit;

    // convert output to unicode.
    if ((lpcClass) && (lpClass) && (szClass))
    {
        if (!MultiByteToWideChar(CP_ACP, 0, szClass, -1, lpClass, *lpcClass))
        {
            lRet = GetLastError();;
            _ASSERTE(0);
            goto Exit;
        }

    }

    lRet = ERROR_SUCCESS;

Exit:
    delete[] szClass;

    return lRet;
}


LONG WszRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName,
    LPDWORD lpcValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData)
{
    LONG    lRet;
    LPSTR   szValueName = NULL;
    DWORD dwcbValueName = 0;
    DWORD dwcbData = 0;
    LPWSTR szData = NULL;
    DWORD  dwType = 0;

    if (UseUnicodeAPI())
        return RegEnumValueW(hKey, dwIndex, lpValueName, lpcValueName, 
            lpReserved, lpType, lpData, lpcbData);

    if (lpcbData)
        dwcbData = *lpcbData;

    if (lpcValueName)
        dwcbValueName = (*lpcValueName) * 2; // *2 because chars could be DBCS...

    if (dwcbValueName && 
        ((szValueName = new char[dwcbValueName]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if ((lRet = RegEnumValueA(hKey, dwIndex, szValueName, &dwcbValueName, 
            lpReserved, &dwType, lpData, &dwcbData)) != ERROR_SUCCESS)
        goto Exit;

    if(lpType)
        *lpType = dwType;

    if (lpcValueName)
    {
        DWORD dwConvertedChars = 0;
        // convert output to unicode.
        if (lpValueName && szValueName)
            if (!(dwConvertedChars=MultiByteToWideChar(CP_ACP, 0, szValueName, -1, lpValueName, *lpcValueName)))
            {
                lRet = GetLastError();
                _ASSERTE(0);
                goto Exit;
            }
            
        // Return the number of characters not including the NULL
        *lpcValueName=dwConvertedChars-1;
    }


    // Also convert the data from ANSI to Unicode if it is of type 
    // @todo: Need to convert for REG_MULTI_SZ too
    if (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ)
    {
        if (*lpcbData < dwcbData*sizeof(WCHAR))
        {
            lRet = ERROR_INSUFFICIENT_BUFFER;
            goto Exit;
        }

        if ((szData = new WCHAR [dwcbData]) == NULL)
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

        HRESULT hr = WszConvertToUnicode ((LPCSTR)lpData, dwcbData, &szData, &dwcbData, FALSE);

        if (SUCCEEDED (hr))
        {
            memcpy ((CHAR *)lpData, szData, dwcbData * sizeof (WCHAR));
        }
        else
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
    }
    lRet = ERROR_SUCCESS;

Exit:
    delete [] szValueName;
    delete [] szData;

    // Multiply the count of bytes by 2 if we converted to Unicode.
    if (lpcbData && (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ))
        *lpcbData = dwcbData*sizeof(WCHAR);
    else if (lpcbData)
        *lpcbData = dwcbData;
    
    return lRet;
}


//
// Helper for RegQueryValueEx. Called when the wrapper (a) knows the contents are a REG_SZ and
// (b) knows the size of the ansi string (passed in as *lpcbData).
//
__inline
LONG _WszRegQueryStringSizeEx(HKEY hKey, LPSTR szValueName, LPDWORD lpReserved, LPDWORD lpcbData)
{
    LONG lRet = ERROR_SUCCESS;

    _ASSERTE(lpcbData != NULL);

#ifdef _RETURN_EXACT_SIZE
    DWORD dwType = REG_SZ;

    // The first buffer was not large enough to contain the ansi.
    // Create another with the exact size.
    LPSTR szValue = (LPSTR)_alloca(*lpcbData);
    
    // Try to get the value again. This time it should succeed.
    lRet = RegQueryValueExA(hKey, szValueName, lpReserved, &dwType, (BYTE*)szValue, lpcbData);
    if (lRet != ERROR_SUCCESS)
    {
        _ASSERTE(!"Unexpected failure when accessing registry.");
        return lRet;
    }
    
    // With the ansi version in hand, figure out how many characters are
    // required to convert to unicode.
    DWORD cchRequired = MultiByteToWideChar(CP_ACP, 0, szValue, -1, NULL, 0);
    if (cchRequired == 0)
        return GetLastError();
    
    // Return the number of bytes needed for the unicode string.
    _ASSERTE(lRet == ERROR_SUCCESS);
    _ASSERTE(cchRequired * sizeof(WCHAR) > *lpcbData);
    *lpcbData = cchRequired * sizeof(WCHAR);
#else // !_RETURN_EXACT_SIZE
    // Return a conservative approximation. In the english case, this value
    // is actually the exact value. In other languages, it might be an over-
    // estimate.
    *lpcbData *= 2;
#endif // _RETURN_EXACT_SIZE

    return lRet;
}


//
// Helper for RegQueryValueEx. Called when a null data pointer is passed
// to the wrapper. Returns the buffer size required to hold the contents
// of the registry value.
//
__inline
LONG _WszRegQueryValueSizeEx(HKEY hKey, LPSTR szValueName, LPDWORD lpReserved,
                             LPDWORD lpType, LPDWORD lpcbData)
{
    _ASSERTE(lpType != NULL);

    LONG lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, NULL, lpcbData);
    
    // If the type is not a string or if the value size is 0,
    // then no conversion is necessary. The type and size values are set
    // as required.
    if (!(*lpType == REG_SZ || *lpType == REG_MULTI_SZ || *lpType == REG_EXPAND_SZ)
        || lRet != ERROR_SUCCESS || *lpcbData == 0)
        return lRet;
    
#ifdef _RETURN_EXACT_SIZE
    // To return the proper size required for a unicode string,
    // we need to fetch the value and do the conversion ourselves.
    // There is not necessarily a 1:2 mapping of size from Ansi to
    // unicode (e.g. Chinese).
    
    // Allocate a buffer for the ansi string.
    szValue = (LPSTR)_alloca(*lpcbData);
    
    // Get the ansi string from the registry.
    lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, (BYTE*)szValue, lpcbData);
    if (lRet != ERROR_SUCCESS) // this should pass, but check anyway
    {
        _ASSERTE(!"Unexpected failure when accessing registry.");
        return lRet;
    }
    
    // Get the number of wchars required to convert to unicode.
    DWORD cchRequired = MultiByteToWideChar(CP_ACP, 0, szValue, -1, NULL, 0);
    if (cchRequired == 0)
        return GetLastError();
    
    // Calculate the number of bytes required for unicode.
    *lpcbData = cchRequired * sizeof(WCHAR);
#else // !_RETURN_EXACT_SIZE
    // Return a conservative approximation. In the english case, this value
    // is actually the exact value. In other languages, it might be an over-
    // estimate.
    *lpcbData *= 2;
#endif // _RETURN_EXACT_SIZE

    return lRet;
}


//
// Wrapper for RegQueryValueEx that is optimized for retrieving
// string values. (Less copying of buffers than other wrapper.)
//
LONG WszRegQueryStringValueEx(HKEY hKey, LPCWSTR lpValueName,
                              LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
                              LPDWORD lpcbData)
{
    if (UseUnicodeAPI())
        return RegQueryValueExW(hKey, lpValueName,
                                lpReserved, lpType, lpData, lpcbData);

    LPSTR   szValueName = NULL;
    LPSTR   szValue = NULL;
    DWORD   dwType = 0;
    LONG    lRet = ERROR_NOT_ENOUGH_MEMORY;


    // We care about the type, so if the caller doesn't care, set the
    // type parameter for our purposes.
    if (lpType == NULL)
        lpType = &dwType;

    // Convert the value name.
    if (FAILED(WszConvertToAnsi(lpValueName, &szValueName, 0, NULL, TRUE)))
        goto Exit;

    // Case 1:
    // The data pointer is null, so the caller is querying for size or type only.
    if (lpData == NULL)
    {
        lRet = _WszRegQueryValueSizeEx(hKey, szValueName, lpReserved, lpType, lpcbData);
    }
    // Case 2:
    // The data pointer is not null, so fill the buffer if possible,
    // or return an error condition.
    else
    {
        _ASSERTE(lpcbData != NULL && "Non-null buffer passed with null size pointer.");

        // Create a new buffer on the stack to hold the registry value.
        // The buffer is twice as big as the unicode buffer to guarantee that
        // we can retrieve any ansi string that will fit in the unicode buffer
        // after it is converted.
        DWORD dwValue = *lpcbData * 2;
        szValue = (LPSTR)_alloca(dwValue);

        // Get the registry contents.
        lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, (BYTE*)szValue, &dwValue);
        if (lRet != ERROR_SUCCESS)
        {
            if ((*lpType == REG_SZ || *lpType == REG_MULTI_SZ || *lpType == REG_EXPAND_SZ) &&
                (lRet == ERROR_NOT_ENOUGH_MEMORY || lRet == ERROR_MORE_DATA))
            {
                lRet = _WszRegQueryStringSizeEx(hKey, szValueName, lpReserved, &dwValue);
                if (lRet == ERROR_SUCCESS)
                    lRet = ERROR_NOT_ENOUGH_MEMORY;

                *lpcbData = dwValue;
            }

            goto Exit;
        }

        // If the result is not a string, then no conversion is necessary.
        if (!(*lpType == REG_SZ || *lpType == REG_MULTI_SZ || *lpType == REG_EXPAND_SZ))
        {
            if (dwValue > *lpcbData)
            {
                // Size of data is bigger than the caller's buffer,
                // so return the appropriate error code.
                lRet = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                // Copy the data from the temporary buffer to the caller's buffer.
                memcpy(lpData, szValue, dwValue);
            }

            // Set the output param for the size of the reg value.
            *lpcbData = dwValue;
            goto Exit;
        }

        // Now convert the ansi string into the unicode buffer.
        DWORD cchConverted = MultiByteToWideChar(CP_ACP, 0, szValue, dwValue, (LPWSTR)lpData, *lpcbData / sizeof(WCHAR));
        if (cchConverted == 0)
        {
#ifdef _RETURN_EXACT_SIZE
            // The retrieved ansi string is too large to convert into the caller's buffer, but we
            // know what the string is, so call conversion again to get exact wchar count required.
            *lpcbData = MultiByteToWideChar(CP_ACP, 0, szValue, dwValue, NULL, 0) * sizeof(WCHAR);
#else // !_RETURN_EXACT_SIZE
            // Return a conservative estimate of the space required.
            *lpcbData = dwValue * 2;
#endif // _RETURN_EXACT_SIZE
            lRet = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            // Everything converted OK. Set the number of bytes retrieved and return success.
            *lpcbData = cchConverted * sizeof(WCHAR);
            _ASSERTE(lRet == ERROR_SUCCESS);
        }
    }

Exit:
    delete[] szValueName;
    return lRet;
}


//
// Default wrapper for RegQueryValueEx
//
LONG WszRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData)
{
    long    lRet = ERROR_NOT_ENOUGH_MEMORY;
    LPSTR   szValueName = NULL;
    LPSTR   szValue = NULL;
    DWORD   dwType;
    DWORD   dwBufSize;

    if( UseUnicodeAPI() )
        return RegQueryValueExW(hKey, lpValueName,
                lpReserved, lpType, lpData, lpcbData);

    // Convert the value name.
    if( FAILED(WszConvertToAnsi((LPWSTR)lpValueName,
                                &szValueName,
                                0,        // max length ignored for alloc
                                NULL,
                                TRUE)) )
        goto Exit;

    // We care about the type, so if the caller doesn't care, set the
    // type parameter for our purposes.
    if (lpType == NULL)
        lpType = &dwType;

    // Case 1:
    // The data pointer is null, so the caller is querying for size or type only.
    if (lpData == NULL)
    {
        lRet = _WszRegQueryValueSizeEx(hKey, szValueName, lpReserved, lpType, lpcbData);
    }
    // Case 2:
    // The data pointer is not null, so fill the buffer if possible,
    // or return an error condition.
    else
    {
        _ASSERTE(lpcbData != NULL && "Non-null buffer passed with null size pointer.");
        dwBufSize = *lpcbData;

        // Try to get the value from the registry.
        lRet = RegQueryValueExA(hKey, szValueName,
            lpReserved, lpType, lpData, lpcbData);
        
        // Check for error conditions...
        if (lRet != ERROR_SUCCESS)
        {
            if ((*lpType == REG_SZ || *lpType == REG_MULTI_SZ || *lpType == REG_EXPAND_SZ)
                && (lRet == ERROR_NOT_ENOUGH_MEMORY || lRet == ERROR_MORE_DATA))
            {
                // The error is that we don't have enough room, even for the ansi
                // version, so call the helper to set the buffer requirements to
                // successfully retrieve the value.
                lRet = _WszRegQueryStringSizeEx(hKey, szValueName, lpReserved, lpcbData);
                if (lRet == ERROR_SUCCESS)
                    lRet = ERROR_NOT_ENOUGH_MEMORY;
            }
            goto Exit;
        }
        
        // If the returned value is a string, then we need to do some special handling...
        if (*lpType == REG_SZ || *lpType == REG_MULTI_SZ || *lpType == REG_EXPAND_SZ)
        {
            // First get the size required to convert the ansi string to unicode.
            DWORD dwAnsiSize = *lpcbData;
            DWORD cchRequired = WszMultiByteToWideChar(CP_ACP, 0, (LPSTR)lpData, dwAnsiSize, NULL, 0);
            if (cchRequired == 0)
            {
                lRet = GetLastError();
                goto Exit;
            }
            
            // Set the required size in the output parameter.
            *lpcbData = cchRequired * sizeof(WCHAR);

            if (dwBufSize < *lpcbData)
            {
                // If the caller didn't pass in enough space for the
                // unicode version, then return appropriate error.
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
            
            // At this point we know that the caller passed in enough
            // memory to hold the unicode version of the string.

            // Allocate buffer in which to copy ansi version.
            szValue = (LPSTR)_alloca(dwAnsiSize);
            
            // Copy the ansi version into a buffer.
            memcpy(szValue, lpData, dwAnsiSize);

            // Convert ansi to unicode.
            if (!WszMultiByteToWideChar(CP_ACP, 0, szValue, dwAnsiSize, (LPWSTR) lpData, dwBufSize / sizeof(WCHAR)))
            {
                lRet = GetLastError();
                _ASSERTE(0);
                goto Exit;
            }
        }
        
        lRet = ERROR_SUCCESS;
    }
Exit:
    delete[] szValueName;
    return  lRet;
}

#ifdef _DEBUG 
//This version of RegQueryValueEx always calls the Unicode version of the appropriate
//functions if it's running on an Unicode-enabled system.  This helps in cases where
//we're reading data from the registry that may not translate properly through the
//WideCharToMultiByte/MultiByteToWideChar round-trip.  The cannonical example of this
//is the Japanese Yen symbol which is stored in the registry as \u00A0, but gets translated
//to \u005C by WCTMB.
//This function only exists under Debug.  On a retail build, it's #defined to call
//WszRegQueryValueEx.
LONG WszRegQueryValueExTrue(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
                            LPDWORD lpcbData)
{

    if (OnUnicodeSystem())
    {
        return RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
    }
    return WszRegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}
#endif


HANDLE
WszCreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);

    HANDLE h = NULL;
    LPSTR szString = NULL;

    if( lpName && FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, szString);

Exit:
    delete[] szString;
    return h;
}


//-----------------------------------------------------------------------------
// WszGetUserName
//
// @func Gets the user name for the current thread
//-----------------------------------------------------------------------------

BOOL 
WszGetUserName(
    LPWSTR lpBuffer, 
    LPDWORD pSize)
{
    LPSTR szBuffer = NULL;
    BOOL  fRet = FALSE;

    if (UseUnicodeAPI())
        return GetUserNameW(lpBuffer, pSize);

    if (lpBuffer && pSize && (*pSize) &&
        ((szBuffer = new char[*pSize]) == NULL))
        return FALSE;

    if (fRet = GetUserNameA(szBuffer, pSize))
    {
        // convert output to unicode.
        if (pSize && (*pSize) && lpBuffer)
        {
            int nRet = MultiByteToWideChar(CP_ACP, 0, szBuffer, -1, lpBuffer, *pSize);
            _ASSERTE(nRet);
            if (nRet == 0)
                fRet = FALSE;
        }
    }

    delete[] szBuffer;

    return fRet;
}


//-----------------------------------------------------------------------------
// WszCreateDirectory
//
// @func Creates a directory
//-----------------------------------------------------------------------------

BOOL 
WszCreateDirectory(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    _ASSERTE(lpPathName != NULL);

    if (UseUnicodeAPI())
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);

    LPSTR szPathName;
    BOOL fRet = FALSE;

    if (FAILED(WszConvertToAnsi((LPWSTR)lpPathName,
                      &szPathName, 0, NULL, TRUE)))
        goto Exit;

    fRet = CreateDirectoryA(szPathName, lpSecurityAttributes);

Exit:
    delete[] szPathName;
    return fRet;
}


//-----------------------------------------------------------------------------
// WszRemoveDirectory
//
// @func Removes a directory
//-----------------------------------------------------------------------------

BOOL 
WszRemoveDirectory(
    LPCWSTR lpPathName)
{
    _ASSERTE(lpPathName != NULL);

    if (UseUnicodeAPI())
        return RemoveDirectoryW(lpPathName);

    LPSTR szPathName;
    BOOL fRet = FALSE;

    if (FAILED(WszConvertToAnsi((LPWSTR)lpPathName,
                      &szPathName, 0, NULL, TRUE)))
        goto Exit;

    fRet = RemoveDirectoryA(szPathName);

Exit:
    delete[] szPathName;
    return fRet;
}


//-----------------------------------------------------------------------------
// WszGetSystemDirectory
//
// @func Get the system directory for this machine
//-----------------------------------------------------------------------------

UINT 
WszGetSystemDirectory(
    LPWSTR lpBuffer,
    UINT uSize)
{
    if (UseUnicodeAPI())
        return GetSystemDirectoryW((LPWSTR)lpBuffer, uSize);

    UINT  uRet = 0;

    if (lpBuffer && uSize) {
        //Assume each character could be two bytes (Could be a DBCS return).
        char* szBuffer = (char*) _alloca(uSize * 2);
        uRet = GetSystemDirectoryA(szBuffer, uSize);
        if (uRet > uSize)
        {
            // The buffer supplied isn't big enough.
            return 0;
        }
        //Copy the string into unicode and put it in lpBuffer.
        uRet = MultiByteToWideChar(CP_ACP, 0, szBuffer, uRet+1, lpBuffer, uSize);
        if (uRet == 0)
            return 0;
        
        uRet--;  // Return number of chars copied excluding trailing \0.
    } else {
        //Get the number of characters required.
        uRet = GetSystemDirectoryA(NULL, 0);
    }

    return uRet;
}


//-----------------------------------------------------------------------------
// WszGetWindowsDirectory
//
// @func Get the system directory for this machine
//-----------------------------------------------------------------------------

UINT 
WszGetWindowsDirectory(
    LPWSTR lpBuffer,
    UINT uSize)
{
    if (UseUnicodeAPI())
        return GetWindowsDirectoryW((LPWSTR)lpBuffer, uSize);

    UINT  uRet = 0;

    if (lpBuffer) {
        //Assume each character could be two bytes (Could be a DBCS return).
        char* szBuffer = (char*) _alloca(uSize * 2);
        uRet = GetWindowsDirectoryA(szBuffer, uSize);
        if (uRet > uSize)
        {
            // The buffer supplied isn't big enough.
            return 0;
        }
      
        //Copy the string into unicode and put it in lpBuffer.
        uRet = MultiByteToWideChar(CP_ACP, 0, szBuffer, uRet+1, lpBuffer, uSize);
        if (uRet == 0)
                return 0;
        uRet--;  // Return number of chars copied excluding trailing \0.
    } else {
        //Get the number of characters required.
        uRet = GetWindowsDirectoryA(NULL, 0);
    }

    return uRet;
}


BOOL 
WszEnumResourceLanguages(
  HMODULE hModule,             // module handle
  LPCWSTR lpType,              // resource type
  LPCWSTR lpName,              // resource name
  ENUMRESLANGPROC lpEnumFunc,  // callback function
  LPARAM  lParam              // application-defined parameter
)
{
    if (OnUnicodeSystem())
    {
        return (EnumResourceLanguagesW(hModule, lpType, lpName, lpEnumFunc, lParam));
    }

    _ASSERTE(!"Unexpected usage of WszEnumResourceLanguages. ANSI version is not implemented.  If you need the ANSI version, talk to JRoxe.");
    return (FALSE);
}

int 
WszGetDateFormat(
  LCID Locale,               // locale
  DWORD dwFlags,             // options
  CONST SYSTEMTIME *lpDate,  // date
  LPCWSTR lpFormat,          // date format
  LPWSTR lpDateStr,          // formatted string buffer
  int cchDate                // size of buffer
) {
    if (UseUnicodeAPI())
        return GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);

    LPSTR pFormatA = NULL;
    LPSTR pStrA = NULL;
    
    int fRet = 0;

    if (FAILED(WszConvertToAnsi((LPWSTR)lpFormat,
                      &pFormatA, 0, NULL, TRUE))) {
        goto Exit;
    }
    fRet = GetDateFormatA(Locale, dwFlags, NULL, pFormatA, NULL, 0);

    if (fRet > 0 && cchDate > 0 && lpDateStr != NULL) {
        CQuickBytes buffer;
        pStrA = (LPSTR)buffer.Alloc(fRet);
        if( pStrA == NULL ) {
            goto Exit;
        }
        fRet = GetDateFormatA(Locale, dwFlags, lpDate, pFormatA, pStrA, fRet);
        if(fRet > 0) {
            fRet = WszMultiByteToWideChar(CP_ACP, 0, pStrA, fRet, lpDateStr, cchDate);
        }
    }
Exit:
    if (pFormatA) {
       delete[] pFormatA;
    }
    return fRet;
}

BOOL 
WszSetWindowText(
  HWND hWnd,         // handle to window or control
  LPCWSTR lpString   // title or text
)
{
    if(UseUnicodeAPI())
        return ::SetWindowTextW(hWnd, lpString);

    LPSTR spString = NULL;
    if(lpString) {
        if(FAILED(WszConvertToAnsi(lpString, &spString, -1, NULL, TRUE)))
            return FALSE;
    }
    
    return ::SetWindowTextA(hWnd,spString);
    
}

LONG_PTR WszSetWindowLongPtr(
  HWND hWnd,           // handle to window
  int nIndex,          // offset of value to set
  LONG_PTR dwNewLong   // new value
)
{
    return ::SetWindowLongPtr(hWnd,
                              nIndex,
                              dwNewLong);
}

//  LONG WszGetWindowLong(
//    HWND hWnd,  // handle to window
//    int nIndex  // offset of value to retrieve
//  )
//  {
//      return ::GetWindowLong(hWnd, nIndex);
//  }


LONG_PTR WszGetWindowLongPtr(
  HWND hWnd,  // handle to window
  int nIndex  // offset of value to retrieve
)
{
    return ::GetWindowLongPtr(hWnd, nIndex);
}

LRESULT WszCallWindowProc(
  WNDPROC lpPrevWndFunc,  // pointer to previous procedure
  HWND hWnd,              // handle to window
  UINT Msg,               // message
  WPARAM wParam,          // first message parameter
  LPARAM lParam           // second message parameter
)
{
    return ::CallWindowProcA(lpPrevWndFunc,
                            hWnd,
                            Msg,
                            wParam,
                            lParam);
}

BOOL WszSystemParametersInfo(
  UINT uiAction,  // system parameter to retrieve or set
  UINT uiParam,   // depends on action to be taken
  PVOID pvParam,  // depends on action to be taken
  UINT fWinIni    // user profile update option
)
{
    return ::SystemParametersInfoA(uiAction,
                                   uiParam,
                                   pvParam,
                                   fWinIni);
}


int WszGetWindowText(
  HWND hWnd,        // handle to window or control
  LPWSTR lpString,  // text buffer
  int nMaxCount     // maximum number of characters to copy
)
{
    if (UseUnicodeAPI())
        return GetWindowTextW(hWnd, lpString, nMaxCount);

    UINT  uRet = 0;
    if (lpString && nMaxCount) {
        //Assume each character could be two bytes (Could be a DBCS return).
        int size = nMaxCount * 2;
        char* szBuffer = (char*) _alloca(size);
        uRet = GetWindowTextA(hWnd, szBuffer, size);
        if (uRet > (UINT) nMaxCount)
        {
            // The buffer supplied isn't big enough.
            return 0;
        }
        //Copy the string into unicode and put it in lpBuffer.
        uRet = MultiByteToWideChar(CP_ACP, 
                                   MB_ERR_INVALID_CHARS, 
                                   szBuffer, uRet+1, 
                                   lpString, nMaxCount);
        if (uRet == 0)
            return 0;
        
        uRet--;  // Return number of chars copied excluding trailing \0.
    }
    return uRet;
}

BOOL WszSetDlgItemText(
  HWND hDlg,         // handle to dialog box
  int nIDDlgItem,    // control identifier
  LPCWSTR lpString   // text to set
)
{
    if(UseUnicodeAPI()) 
        return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

    HRESULT hr = S_OK;
    LPSTR spString = NULL;
    if(lpString) {
        hr = WszConvertToAnsi(lpString, &spString, -1, NULL, TRUE);
        delete [] lpString;
        IfFailGo(hr);
    }

    IfFailGo(SetDlgItemTextA(hDlg, nIDDlgItem, spString) ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

 ErrExit:
    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//-----------------------------------------------------------------------------
// WszFindFirstFile
//
// @func Searches the disk for files matching a pattern.  Note - close this
// handle with FindClose, not CloseHandle!
//-----------------------------------------------------------------------------

HANDLE WszFindFirstFile(
    LPCWSTR lpFileName,                 // pointer to name of file to search for
    LPWIN32_FIND_DATA lpFindFileData)   // pointer to returned information
{
    _ASSERTE(lpFileName != NULL);

    if (UseUnicodeAPI())
        return FindFirstFileW(lpFileName, lpFindFileData);

    LPSTR szFileName = NULL;
    WIN32_FIND_DATAA fd;
    HANDLE hRet      = INVALID_HANDLE_VALUE;

    if (FAILED(WszConvertToAnsi((LPWSTR)lpFileName,
                      &szFileName, 0, NULL, TRUE)))
        goto Exit;

    hRet = FindFirstFileA(szFileName, &fd);

    if ((hRet != INVALID_HANDLE_VALUE) && lpFindFileData)
    {
        lpFindFileData->dwFileAttributes = fd.dwFileAttributes;

        lpFindFileData->ftCreationTime.dwLowDateTime = 
            fd.ftCreationTime.dwLowDateTime; 
        lpFindFileData->ftCreationTime.dwHighDateTime = 
            fd.ftCreationTime.dwHighDateTime; 

        lpFindFileData->ftLastAccessTime.dwLowDateTime = 
            fd.ftLastAccessTime.dwLowDateTime;     
        lpFindFileData->ftLastAccessTime.dwHighDateTime = 
            fd.ftLastAccessTime.dwHighDateTime;     

        lpFindFileData->ftLastWriteTime.dwLowDateTime = 
            fd.ftLastWriteTime.dwLowDateTime; 
        lpFindFileData->ftLastWriteTime.dwHighDateTime = 
            fd.ftLastWriteTime.dwHighDateTime; 


        lpFindFileData->nFileSizeHigh = fd.nFileSizeHigh;
        lpFindFileData->nFileSizeLow  = fd.nFileSizeLow;
        lpFindFileData->dwReserved0   = fd.dwReserved0;
        lpFindFileData->dwReserved1   = fd.dwReserved1;

        // convert output to unicode.
        int nRet1 = MultiByteToWideChar(CP_ACP, 0, fd.cFileName, -1, 
                                                   lpFindFileData->cFileName, MAX_PATH);
        _ASSERTE(nRet1);
        int nRet2 = MultiByteToWideChar(CP_ACP, 0, fd.cAlternateFileName, -1, 
                                                   lpFindFileData->cAlternateFileName, 14);

        _ASSERTE(nRet2);

        // If either of the conversions failed, bail
        if (nRet1 == 0 || nRet2 == 0)
        {
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            goto Exit;
        }


    }

Exit:
    delete[] szFileName;
    return hRet;
}


//-----------------------------------------------------------------------------
// WszFindNextFile
//
// @func Looks for the next matching file in a set (see FindFirstFile)
//-----------------------------------------------------------------------------

BOOL WszFindNextFile(
    HANDLE hFindHandle,                 // handle returned from FindFirstFile
    LPWIN32_FIND_DATA lpFindFileData)   // pointer to returned information
{
    if (UseUnicodeAPI())
        return FindNextFileW(hFindHandle, lpFindFileData);

    WIN32_FIND_DATAA fd;
    BOOL fRet = FALSE;

    fRet = FindNextFileA(hFindHandle, &fd);

    if (fRet && lpFindFileData)
    {
        lpFindFileData->dwFileAttributes = fd.dwFileAttributes;

        lpFindFileData->ftCreationTime.dwLowDateTime = 
            fd.ftCreationTime.dwLowDateTime; 
        lpFindFileData->ftCreationTime.dwHighDateTime = 
            fd.ftCreationTime.dwHighDateTime; 

        lpFindFileData->ftLastAccessTime.dwLowDateTime = 
            fd.ftLastAccessTime.dwLowDateTime;     
        lpFindFileData->ftLastAccessTime.dwHighDateTime = 
            fd.ftLastAccessTime.dwHighDateTime;     

        lpFindFileData->ftLastWriteTime.dwLowDateTime = 
            fd.ftLastWriteTime.dwLowDateTime; 
        lpFindFileData->ftLastWriteTime.dwHighDateTime = 
            fd.ftLastWriteTime.dwHighDateTime; 


        lpFindFileData->nFileSizeHigh = fd.nFileSizeHigh;
        lpFindFileData->nFileSizeLow  = fd.nFileSizeLow;
        lpFindFileData->dwReserved0   = fd.dwReserved0;
        lpFindFileData->dwReserved1   = fd.dwReserved1;

        // convert output to unicode.
        int nRet1 = MultiByteToWideChar(CP_ACP, 0, fd.cFileName, -1, 
                                                          lpFindFileData->cFileName, MAX_PATH);
        _ASSERTE(nRet1);

        int nRet2 = MultiByteToWideChar(CP_ACP, 0, fd.cAlternateFileName, -1, 
                                                          lpFindFileData->cAlternateFileName, 14);
        _ASSERTE(nRet2);

        // If either of the conversions failed, bail
        if (nRet1 == 0 || nRet2 == 0)
        {
            fRet = FALSE;
        }

        
    }

    return fRet;
}


BOOL
WszPeekMessage(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg)
{
    if (UseUnicodeAPI()) 
        return PeekMessageW(lpMsg,
                            hWnd,
                            wMsgFilterMin,
                            wMsgFilterMax,
                            wRemoveMsg);
    else
        return PeekMessageA(lpMsg,
                            hWnd,
                            wMsgFilterMin,
                            wMsgFilterMax,
                            wRemoveMsg);
}


LONG
WszDispatchMessage(
    CONST MSG *lpMsg)
{
    if (UseUnicodeAPI()) 
        return DispatchMessageW(lpMsg);
    else
        return DispatchMessageA(lpMsg);
}

BOOL
WszPostMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    if (UseUnicodeAPI()) 
        return PostMessageW(hWnd, Msg, wParam, lParam);
    else
        return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WszCryptAcquireContext(HCRYPTPROV *phProv,
                       LPCWSTR pwszContainer,
                       LPCWSTR pwszProvider,
                       DWORD dwProvType,
                       DWORD dwFlags)
{
    // NOTE:  CryptAcquireContextW does not exist on Win95 and therefore this
    // wrapper must always target ANSI (or you'd have to dynamically load
    // the api with GetProcAddress).
    LPSTR szContainer = NULL;
    LPSTR szProvider = NULL;

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszContainer,
                &szContainer,
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    BOOL retval;
    if ( FAILED(WszConvertToAnsi( 
                pwszProvider,
                &szProvider, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        retval = FALSE;
        goto Exit;
    }

    retval = CryptAcquireContextA(phProv, szContainer, szProvider, dwProvType, dwFlags);

 Exit:
    if (szContainer)
        delete[] szContainer;

    if (szProvider)
        delete[] szProvider;

    return retval;
}


BOOL WszGetVersionEx(
    LPOSVERSIONINFOW lpVersionInformation)
{
    if(UseUnicodeAPI())
        return GetVersionExW(lpVersionInformation);

    OSVERSIONINFOA VersionInfo;
    BOOL        bRtn;
    
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    bRtn = GetVersionExA(&VersionInfo);

    //workaround for Whistler Beta 1 bug
    if (!bRtn)
    {
        if (VersionInfo.dwMajorVersion == 5 &&
            VersionInfo.dwMinorVersion == 1 &&
            VersionInfo.dwBuildNumber  >= 2195)
        {
            bRtn = TRUE;
            VersionInfo.szCSDVersion[0] = '\0';
        }
    }

    if (bRtn)
    {
        // note that we have made lpVersionInformation->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA)
        memcpy(lpVersionInformation, &VersionInfo, offsetof(OSVERSIONINFOA, szCSDVersion));
        VERIFY(Wsz_mbstowcs(lpVersionInformation->szCSDVersion, VersionInfo.szCSDVersion, 128));
    }
    return (bRtn);
}


void WszOutputDebugString(
    LPCWSTR lpOutputString
    )
{
    if (UseUnicodeAPI())
    {
        OutputDebugStringW(lpOutputString);
        return;
    }

    LPSTR szOutput = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpOutputString,
                      &szOutput, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    OutputDebugStringA(szOutput);

Exit:
    delete[] szOutput;
}


BOOL WszLookupAccountSid(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cbName,
    LPWSTR DomainName,
    LPDWORD cbDomainName,
    PSID_NAME_USE peUse
    )
{
    if (UseUnicodeAPI())
    {
        return LookupAccountSidW(lpSystemName, Sid, Name, cbName, DomainName, cbDomainName, peUse);
    }

    BOOL retval = FALSE;

    LPSTR szSystemName = NULL;
    LPSTR szName = (LPSTR)new CHAR[*cbName];
    LPSTR szDomainName = (LPSTR)new CHAR[*cbDomainName];
    DWORD cbNameCopy = *cbName;
    DWORD cbDomainNameCopy = *cbDomainName;

    if (szName == NULL || szDomainName == NULL)
    {
        goto Exit;
    }
    
    if (lpSystemName != NULL && FAILED( WszConvertToAnsi( (LPWSTR)lpSystemName, &szSystemName, 0, NULL, TRUE ) ))
    {
        goto Exit;
    }
    
    retval = LookupAccountSidA(szSystemName, Sid, szName, cbName, szDomainName, cbDomainName, peUse);
    
    if (retval)
    {
        if (szName != NULL && FAILED( WszConvertToUnicode( szName, -1, &Name, &cbNameCopy, FALSE ) ))
        {
            retval = FALSE;
            goto Exit;
        }
        
        if (szDomainName != NULL && FAILED( WszConvertToUnicode( szDomainName, -1, &DomainName, &cbDomainNameCopy, FALSE ) ))
        {
            retval = FALSE;
            goto Exit;
        }
    }

Exit:
    delete [] szSystemName;
    delete [] szName;
    delete [] szDomainName;
    
    return retval;
}

BOOL WszLookupAccountName(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR DomainName,
    LPDWORD cbDomainName,
    PSID_NAME_USE peUse
    )
{    
    _ASSERTE(lpAccountName != NULL ); 
    if( !lpAccountName)
        return FALSE;
   
    if (UseUnicodeAPI())
    {
        return LookupAccountNameW(lpSystemName, lpAccountName, Sid, cbSid, DomainName, cbDomainName, peUse);
    }

    BOOL retval = FALSE;

    LPSTR szSystemName = NULL;
    LPSTR szAccountName = NULL;
    LPSTR szDomainName = NULL; 
    DWORD cbDomainNameCopy = 0;
    
    if (lpSystemName != NULL && FAILED( WszConvertToAnsi( (LPWSTR)lpSystemName, &szSystemName, 0, NULL, TRUE ) ))
    {
        goto Exit;
    }

    if (FAILED( WszConvertToAnsi( (LPWSTR)lpAccountName, &szAccountName, 0, NULL, TRUE ) ))
    {
        goto Exit;
    }

    if(DomainName) {
        szDomainName = (LPSTR)new CHAR[*cbDomainName];
        cbDomainNameCopy = *cbDomainName;                
    }
    
    retval = LookupAccountNameA(szSystemName, szAccountName, Sid, cbSid, szDomainName, cbDomainName, peUse);
    
    if (retval)
    {
        if (szDomainName != NULL && FAILED( WszConvertToUnicode( szDomainName, -1, &DomainName, &cbDomainNameCopy, FALSE ) ))
        {
            retval = FALSE; 
            goto Exit;
        }
    }

Exit:
    delete [] szSystemName;
    delete [] szAccountName;
    delete [] szDomainName;
    
    return retval;
}


void WszFatalAppExit(
    UINT uAction,
    LPCWSTR lpMessageText
    )
{
    _ASSERTE(lpMessageText != NULL);

    if (UseUnicodeAPI())
    {
        FatalAppExitW(uAction, lpMessageText);
        return;
    }

    LPSTR szString;
    if( FAILED(WszConvertToAnsi((LPWSTR)lpMessageText,
                      &szString, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    FatalAppExitA(uAction, szString);

Exit:
    delete[] szString;
}
            

HANDLE WszCreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);

    HANDLE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = CreateMutexA(lpMutexAttributes, bInitialOwner, szString);

Exit:
    delete[] szString;
    return h;
}


HANDLE WszCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

    HANDLE h = NULL;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = CreateEventA(lpEventAttributes, bManualReset, bInitialState, szString);

Exit:
    delete[] szString;
    return h;
}


HANDLE WszOpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return OpenEventW(dwDesiredAccess, bInheritHandle, lpName);

    HANDLE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = OpenEventA(dwDesiredAccess, bInheritHandle, szString);

Exit:
    delete[] szString;
    return h;
}


HMODULE WszGetModuleHandle(
    LPCWSTR lpModuleName
    )
{
    if (UseUnicodeAPI())
        return GetModuleHandleW(lpModuleName);

    HMODULE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpModuleName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = GetModuleHandleA(szString);

Exit:
    delete[] szString;
    return h;
}


DWORD
WszGetFileAttributes(
    LPCWSTR lpFileName
    )
{
    _ASSERTE(lpFileName != NULL);

    if (UseUnicodeAPI())
        return GetFileAttributesW(lpFileName);

    DWORD rtn;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpFileName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    rtn = GetFileAttributesA(szString);

Exit:
    delete[] szString;
    return rtn;
}


BOOL
WszSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    _ASSERTE(lpFileName != NULL);

    if (UseUnicodeAPI())
        return SetFileAttributesW(lpFileName, dwFileAttributes);

    BOOL rtn;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpFileName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = FALSE;
        goto Exit;
    }

    rtn = SetFileAttributesA(szString, dwFileAttributes);

Exit:
    delete[] szString;
    return rtn;
}


DWORD
WszGetCurrentDirectory(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    if (UseUnicodeAPI())
        return GetCurrentDirectoryW(nBufferLength, lpBuffer);

    DWORD rtn;
    char *szString;
    CQuickBytes qbBuffer;

    szString = (char *) qbBuffer.Alloc(nBufferLength * 2);
    if (!szString)
        return (0);
    
    rtn = GetCurrentDirectoryA(nBufferLength * 2, szString);
    if (rtn && (rtn < nBufferLength*2))
        rtn = Wsz_mbstowcs(lpBuffer, szString, nBufferLength) - 1;
    else if (lpBuffer && nBufferLength)
        *lpBuffer = 0;
    return rtn;
}


DWORD
WszGetTempPath(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    if (UseUnicodeAPI())
        return GetTempPathW(nBufferLength, lpBuffer);

    DWORD       rtn = 0;
    CQuickBytes qbBuffer;
    LPSTR       szOutput;

    szOutput = (LPSTR) qbBuffer.Alloc(nBufferLength);
    if (szOutput)
    {
        rtn = GetTempPathA(nBufferLength, szOutput);
        if (rtn && rtn < nBufferLength)
            rtn = Wsz_mbstowcs(lpBuffer, szOutput, nBufferLength);
        else if (lpBuffer != NULL)
            *lpBuffer = 0;
    }

    if (!rtn && nBufferLength && lpBuffer)
        *lpBuffer = 0;

    return (rtn);
}


UINT
WszGetTempFileName(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    if (UseUnicodeAPI())
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    DWORD       rtn;
    char        rcPrefix[64];
    LPSTR       rcPathName;
    LPSTR       rcTempFile;

    int rcLen  =  _MAX_PATH*DBCS_MAXWID;
    rcPathName = (LPSTR) alloca(rcLen);
    rcTempFile = (LPSTR) alloca(rcLen);
    VERIFY(Wsz_wcstombs(rcPathName, lpPathName, rcLen));
    VERIFY(Wsz_wcstombs(rcPrefix, lpPrefixString, sizeof(rcPrefix)));
    
    rtn = GetTempFileNameA(rcPathName, rcPrefix, uUnique, rcTempFile);

    if (rtn)
        rtn = Wsz_mbstowcs(lpTempFileName, rcTempFile, _MAX_PATH);
    else if (lpTempFileName)
        *lpTempFileName = 0;
    return rtn;
    
}


LPWSTR
WszGetCommandLine(
    VOID
    )
{
    // It turns out that GetCommandLineW works correctly on Win98.  It's important
    // that we use it, because we don't want to be in the business of correctly
    // selecting the OEM vs. the ANSI code page.

    // For historical reasons, this API returns an allocated copy which clients are
    // responsible for releasing.
    WCHAR   *pwCmdLine = GetCommandLineW();

    // Add one for the null character(s)
    WCHAR   *pwRCmdLine = new WCHAR[wcslen(pwCmdLine)+sizeof(WCHAR)];
    wcscpy(pwRCmdLine, pwCmdLine);
    return pwRCmdLine;
}


LPWSTR
WszGetEnvironmentStrings()
{
    // @TODO: Consider removing this function, if it would make life easier.

    // GetEnvironmentStringsW is what I want to call, but in checked builds on 
    // even numbered days, UseUnicodeAPI switches to be false.  If you call 
    // WszGetEnvironmentStrings on a checked build before midnight then call 
    // WszFreeEnvironmentStrings after midnight, you'll be doing something wrong.
    // So for that reason on Debug builds, we'll allocate a new buffer.
    if (UseUnicodeAPI()) {
#ifndef _DEBUG
        return GetEnvironmentStringsW();
#else // DEBUG
        LPWSTR block = GetEnvironmentStringsW();
        WCHAR* ptr = block;
        while (!(*ptr==0 && *(ptr+1)==0))
        ptr++;
        WCHAR* TmpBuffer = new WCHAR[ptr-block+2];
        memcpy(TmpBuffer, block, ((ptr-block)+2)*sizeof(WCHAR));
        return TmpBuffer;
#endif  // DEBUG
    }

    // You must call WszFreeEnvironmentStrings on the block returned.
    // These two functions are tightly coupled in terms of memory management
    // GetEnvironmentStrings is the "A" version of the function
    LPSTR block = GetEnvironmentStrings();
    if (!block)
        return NULL;

    // Format for GetEnvironmentStrings is:
    // [=HiddenVar=value\0]* [Variable=value\0]* \0
    // See the description of Environment Blocks in MSDN's
    // CreateProcess page (null-terminated array of null-terminated strings).

    // Look for ending \0\0 in block
    char* ptr = block;
    while (!(*ptr==0 && *(ptr+1)==0))
        ptr++;

    // Copy ANSI strings into a Unicode block of memory.
    LPWSTR strings = new WCHAR[ptr-block+2];
    if (!strings) {
        FreeEnvironmentStringsA(block);
        return NULL;
    }
    int numCh = MultiByteToWideChar(CP_ACP, 0, block, ptr-block+2, strings, ptr-block+2);
    _ASSERTE(numCh!=0);

    // Release ANSI block - call WszFreeEnvironmentStrings later to delete memory.
    FreeEnvironmentStringsA(block);
    return strings;
}


BOOL
WszFreeEnvironmentStrings(
    LPWSTR block)
{
    _ASSERTE(block);

    // For the Unicode Free build funkiness, see comments in 
    // WszGetEnvironmentStrings.
    if (UseUnicodeAPI()) {
#ifndef _DEBUG
        return FreeEnvironmentStringsW(block);
#endif // !DEBUG
    }

    delete [] block;
    return true;
}


DWORD
WszGetEnvironmentVariable(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    )
{
    _ASSERTE(lpName != NULL);

    if (UseUnicodeAPI())
        return GetEnvironmentVariableW(lpName, lpBuffer, nSize);

    DWORD rtn;
    LPSTR szString=NULL, szBuffer=NULL;
    CQuickBytes qbBuffer;

    szBuffer = (char *) qbBuffer.Alloc(nSize * 2);
    if (!szBuffer)
        return (0);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = GetEnvironmentVariableA(szString, szBuffer, nSize * 2);

    //They were just calling to see how big to make the buffer.  Tell them.
    if (nSize==0 || rtn > nSize * 2) {  
        goto Exit;
    }
    
    //If we have a real buffer, convert it and return the length.
    //wsz_mbstowcs includes space for a terminating null, which GetEnvironmentVariableW doesn't
    //so we need to subtract one so that we have consistent return values in the ansi and unicode cases.
    if (rtn) {
        rtn = Wsz_mbstowcs(lpBuffer, szBuffer, nSize);
        rtn--;
    } else if (lpBuffer && nSize) {
        *lpBuffer = 0;
    }

Exit:
    delete[] szString;
    return rtn;
}


BOOL
WszSetEnvironmentVariable(
    LPCWSTR lpName,
    LPCWSTR lpValue
    )
{
    _ASSERTE(lpName != NULL);

    if (UseUnicodeAPI())
        return SetEnvironmentVariableW(lpName, lpValue);

    DWORD rtn;
    LPSTR szString = NULL, szValue = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpValue,
                      &szValue, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = SetEnvironmentVariableA(szString, szValue);

Exit:
    delete[] szString;
    delete[] szValue;
    return rtn;
}


//-----------------------------------------------------------------------------
// WszGetClassName
//
// @func Gets the user name for the current thread
//-----------------------------------------------------------------------------

int 
WszGetClassName(
    HWND hwnd,
    LPWSTR lpBuffer, 
    int nMaxCount)
{
    LPSTR szBuffer = NULL;
    int  nRet = 0;

    if (UseUnicodeAPI())
        return GetClassNameW(hwnd, lpBuffer, nMaxCount);

    if (lpBuffer && nMaxCount && ((szBuffer = new char[nMaxCount]) == NULL))
        return 0;

    nRet = GetClassNameA(hwnd, szBuffer, nMaxCount);
    _ASSERTE(nRet <= nMaxCount);

    // convert output to unicode.
    if (lpBuffer)
    {
        if (nRet)
            nRet = MultiByteToWideChar(CP_ACP, 0, szBuffer, -1, lpBuffer, nMaxCount);

        if (!nRet && nMaxCount > 0)
            *lpBuffer = 0;
    }

    delete[] szBuffer;

    return nRet;
}


BOOL 
WszGetComputerName(
    LPWSTR lpBuffer,
    LPDWORD pSize
    )
{
    DWORD nSize = *pSize;
    if( lpBuffer && nSize) 
        lpBuffer[0] = L'\0';
    
    if (UseUnicodeAPI())
        return GetComputerNameW(lpBuffer, pSize);

    LPSTR szBuffer = (LPSTR) _alloca(nSize) ;
    if( szBuffer == NULL)
        return FALSE;

    if(!GetComputerNameA(szBuffer, &nSize))
        return FALSE;
    
    return Wsz_mbstowcs(lpBuffer,  szBuffer,  *pSize);
}


HANDLE
WszCreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

    HANDLE rtn;
    LPSTR szString = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, szString);

Exit:
    delete[] szString;
    return rtn;
}


HANDLE
WszOpenFileMapping(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    if (UseUnicodeAPI())
        return OpenFileMappingW(dwDesiredAccess, bInheritHandle, lpName);

    HANDLE rtn = NULL;
    LPSTR szString = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = OpenFileMappingA(dwDesiredAccess, bInheritHandle, szString);

Exit:
    delete[] szString;
    return rtn;
}


BOOL
WszCreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (UseUnicodeAPI())
        return CreateProcessW(lpApplicationName,
                              lpCommandLine,
                              lpProcessAttributes,
                              lpThreadAttributes,
                              bInheritHandles,
                              dwCreationFlags,
                              lpEnvironment,
                              lpCurrentDirectory,
                              lpStartupInfo,
                              lpProcessInformation);

    BOOL rtn = FALSE;
    LPSTR szAppName = NULL;
    LPSTR szCommandLine = NULL;
    LPSTR szCurrentDir = NULL;
    LPSTR szReserved = NULL;
    LPSTR szDesktop = NULL;
    LPSTR szTitle = NULL;
    STARTUPINFOA infoA = *((LPSTARTUPINFOA)lpStartupInfo);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpApplicationName,
                      &szAppName, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCommandLine,
                      &szCommandLine, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCurrentDirectory,
                      &szCurrentDir, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    if (lpStartupInfo->lpReserved != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpReserved,
                      &szReserved, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpReserved = szReserved;
    }

    if (lpStartupInfo->lpDesktop != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpDesktop,
                      &szDesktop, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpDesktop = szDesktop;
    }

    if (lpStartupInfo->lpTitle != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpTitle,
                      &szTitle, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpTitle = szTitle;
    }

    // Get value and convert back for caller.
    rtn = CreateProcessA(szAppName,
                         szCommandLine,
                         lpProcessAttributes,
                         lpThreadAttributes,
                         bInheritHandles,
                         dwCreationFlags,
                         lpEnvironment,
                         szCurrentDir,
                         &infoA,
                         lpProcessInformation);

Exit:
    delete[] szAppName;
    delete[] szCommandLine;
    delete[] szCurrentDir;
    delete[] szReserved;
    delete[] szDesktop;
    delete[] szTitle;
    return rtn;
}
#endif // _X86_
#endif // PLATFORM_WIN32

//////////////////////////////////////////////
//
// END OF X86-ONLY wrappers
//
//////////////////////////////////////////////

static void xtow (
        unsigned long val,
        LPWSTR buf,
        unsigned radix,
        int is_neg
        )
{
        WCHAR *p;               /* pointer to traverse string */
        WCHAR *firstdig;        /* pointer to first digit */
        WCHAR temp;             /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = (WCHAR) '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to text and store */
            if (digval > 9)
                *p++ = (WCHAR) (digval - 10 + 'A');  /* a letter */
            else
                *p++ = (WCHAR) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = 0;               /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

LPWSTR
Wszltow(
    LONG val,
    LPWSTR buf,
    int radix
    )
{
    xtow((unsigned long)val, buf, radix, (radix == 10 && val < 0));
    return buf;
}

LPWSTR
Wszultow(
    ULONG val,
    LPWSTR buf,
    int radix
    )
{
    xtow(val, buf, radix, 0);
    return buf;
}


//-----------------------------------------------------------------------------
// WszConvertToUnicode
//
// @func Convert a string from Ansi to Unicode
//
// @devnote cbIn can be -1 for Null Terminated string
//
// @rdesc HResult indicating status of Conversion
//      @flag S_OK | Converted to Ansi
//      @flag S_FALSE | Truncation occurred
//      @flag E_OUTOFMEMORY | Allocation problem.
//      @flag ERROR_NO_UNICODE_TRANSLATION | Invalid bytes in this code page.
//-----------------------------------------------------------------------------------
HRESULT WszConvertToUnicode
    (
    LPCSTR          szIn,       //@parm IN | Ansi String
    LONG            cbIn,       //@parm IN | Length of Ansi String in bytest
    LPWSTR*         lpwszOut,   //@parm INOUT | Unicode Buffer
    ULONG*          lpcchOut,   //@parm INOUT | Length of Unicode String in characters -- including '\0'
    BOOL            fAlloc      //@parm IN | Alloc memory or not
    )
{
    ULONG       cchOut;
    ULONG       cbOutJunk = 0;
//  ULONG       cchIn = szIn ? strlen(szIn) + 1 : 0;
            
//  _ASSERTE(lpwszOut);

    if (!(lpcchOut))
        lpcchOut = &cbOutJunk;

    if ((szIn == NULL) || (cbIn == 0))
    {
        *lpwszOut = NULL;
        if( lpcchOut )
            *lpcchOut = 0;
        return ResultFromScode(S_OK);
    }

    // Allocate memory if requested.   Note that we allocate as
    // much space as in the unicode buffer, since all of the input
    // characters could be double byte...
    if (fAlloc)
    {
        // Determine the number of characters needed 
        cchOut = (MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                MB_ERR_INVALID_CHARS,                              
                                szIn,
                                cbIn,
                                NULL,
                                0));

        if (cchOut == 0)
            return ResultFromScode(E_FAIL); // NOTREACHED

        // _ASSERTE( cchOut != 0 );
        *lpwszOut = (LPWSTR) new WCHAR[cchOut];
        *lpcchOut = cchOut;     // Includes '\0'.

        if (!(*lpwszOut))
        {
//          TRACE("WszConvertToUnicode failed to allocate memory");
            return ResultFromScode(E_OUTOFMEMORY);
        }

    } 

    if( !(*lpwszOut) )
        return ResultFromScode(S_OK);
//  _ASSERTE(*lpwszOut);

    cchOut = (MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                MB_ERR_INVALID_CHARS,
                                szIn,
                                cbIn,
                                *lpwszOut,
                                *lpcchOut));

    if (cchOut)
    {
        *lpcchOut = cchOut;
        return ResultFromScode(S_OK);
    }


//  _ASSERTE(*lpwszOut);
    if( fAlloc )
    {
        delete[] *lpwszOut;
        *lpwszOut = NULL;
    }
/*
    switch (GetLastError())
    {
        case    ERROR_NO_UNICODE_TRANSLATION:
        {
            OutputDebugString(TEXT("ODBC: no unicode translation for installer string"));
            return ResultFromScode(E_FAIL);
        }

        default:


        {
            _ASSERTE("Unexpected unicode error code from GetLastError" == NULL);
            return ResultFromScode(E_FAIL);
        }
    }
*/
    return ResultFromScode(E_FAIL); // NOTREACHED
}


//-----------------------------------------------------------------------------
// WszConvertToAnsi
//
// @func Convert a string from Unicode to Ansi
//
// @rdesc HResult indicating status of Conversion
//      @flag S_OK | Converted to Ansi
//      @flag S_FALSE | Truncation occurred
//      @flag E_OUTOFMEMORY | Allocation problem.
//-----------------------------------------------------------------------------------
HRESULT WszConvertToAnsi
    (
    LPCWSTR         szIn,       //@parm IN | Unicode string
    LPSTR*          lpszOut,    //@parm INOUT | Pointer for buffer for ansi string
    ULONG           cbOutMax,   //@parm IN | Max string length in bytes
    ULONG*          lpcbOut,    //@parm INOUT | Count of bytes for return buffer
    BOOL            fAlloc      //@parm IN | Alloc memory or not
    )
{
    ULONG           cchInActual;
    ULONG           cbOutJunk;
//@TODO the following in ODBC DM is never used
//  BOOL            fNTS = FALSE;
//@TODO check ODBC code for this line being wrong
    ULONG           cchIn = szIn ? lstrlenW (szIn) + 1 : 0;

    _ASSERTE(lpszOut != NULL);

    if (!(lpcbOut))
        lpcbOut = &cbOutJunk;

    if ((szIn == NULL) || (cchIn == 0))
    {
        *lpszOut = NULL;
        *lpcbOut = 0;
        return ResultFromScode(S_OK);
    }

    // Allocate memory if requested.   Note that we allocate as
    // much space as in the unicode buffer, since all of the input
    // characters could be double byte...
    cchInActual = cchIn;
    if (fAlloc)
    {
        cbOutMax = (WideCharToMultiByte(CP_ACP,     // XXX Consider: make any cp?
                                    0,                              
                                    szIn,
                                    cchInActual,
                                    NULL,
                                    0,
                                    NULL,
                                    FALSE));

        *lpszOut = (LPSTR) new CHAR[cbOutMax];

        if (!(*lpszOut))
        {
//          TRACE("WszConvertToAnsi failed to allocate memory");
            return ResultFromScode(E_OUTOFMEMORY);
        }

    } 

    if (!(*lpszOut))
        return ResultFromScode(S_OK);

    BOOL usedDefaultChar = FALSE;
    *lpcbOut = (WszWideCharToMultiByte(CP_ACP,     // XXX Consider: make any cp?
                                       WC_NO_BEST_FIT_CHARS,
                                       szIn,
                                       cchInActual,
                                       *lpszOut,
                                       cbOutMax,
                                       NULL,
                                       &usedDefaultChar));

    // If we failed, make sure we clean up.
    if ((*lpcbOut == 0 && cchInActual > 0) || usedDefaultChar)
    {
        if (fAlloc) {
            delete[] *lpszOut;
            *lpszOut = NULL;
        }

        // Don't allow default character replacement (nor best fit character
        // mapping, which we've told WC2MB to treat by using the default
        // character).  This prevents problems with characters like '\'.
        // Note U+2216 (Set Minus) looks like a '\' and may get mapped to
        // a normal backslash (U+005C) implicitly here otherwise, causing
        // a potential security bug.
        if (usedDefaultChar)
            return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
    }

    // Overflow on unicode conversion
    if (*lpcbOut > cbOutMax)
    {
        // If we had data truncation before, we have to guess
        // how big the string could be.   Guess large.
        if (cchIn > cbOutMax)
            *lpcbOut = cchIn * DBCS_MAXWID;

        return ResultFromScode(S_FALSE);
    }

    // handle external (driver-done) truncation
    if (cchIn > cbOutMax)
        *lpcbOut = cchIn * DBCS_MAXWID;
//  _ASSERTE(*lpcbOut);

    return ResultFromScode(S_OK);
}



#ifndef PLATFORM_WIN32  // OnUnicodeSystem is always true on CE.
                        // GetProcAddress is only Ansi, except on CE
                        //   which is only Unicode.
// ***********************************************************
// @TODO - LBS
// This is a real hack and need more error checking and needs to be
// cleaned up.  This is just to get wince to @#$%'ing compile!
FARPROC WszGetProcAddress(HMODULE hMod, LPCSTR szProcName)
{
    _ASSERTE(!"NYI");
    return 0;

    /*
    LPWSTR          wzProcName;
    ULONG           cchOut;
    FARPROC         address;

    cchOut = (MultiByteToWideChar(CP_ACP,0,szProcName,-1,NULL,0));

    wzProcName = (LPWSTR) new WCHAR[cchOut];

    if (!wzProcName)
        return NULL;

    cchOut = (MultiByteToWideChar(CP_ACP,0,szProcName,-1,wzProcName,cchOut));

    address = GetProcAddressW(hMod, wzProcName);

    delete[] wzProcName;
    wzProcName = NULL;
    return address;
    */
}
#endif // !PLATFORM_WIN32

#ifdef PLATFORM_CE
#ifndef EXTFUN
#define EXTFUN
#endif // !EXTFUN
#include "mschr.h"
char *  __cdecl strrchr(const char *p, int ch)
{   // init to null in case not found.
    char *q=0;          
    // process entire string.
    while (*p)
    {   // If a match, remember location.
        if (*p == ch)
            q = const_cast<char*>(p);
        MSCHR::Next(p);
    }
    return (q);
}
#endif // PLATFORM_CE

#ifdef PLATFORM_CE
//char * __cdecl strchr(const char *, int);
int __cdecl _stricmp(const char *p1, const char *p2)
{
    // First check for exact match because code below is slow.
    if (!strcmp(p1, p2))
        return (0);

    while (!MSCHR::CmpI (p1, p2))
    {
        if (*p1 == '\0')
            return (0);
        MSCHR::Next (p1);
        MSCHR::Next (p2);
    }
    return MSCHR::CmpI (p1, p2);
}
#endif // PLATFORM_CE

#ifdef PLATFORM_CE
//int __cdecl _strnicmp(const char *, const char *, size_t);
int __cdecl _strnicmp(const char *p1, const char *p2, size_t Count)
{
    char c1, c2;
    while (Count--)
    {
        c1 = *p1++;
        c2 = *p2++;
        if ((c1 >= 'a') & (c1 <= 'z'))
            c1 &= 0xdf;
        if ((c2 >= 'a') & (c2 <= 'z'))
            c2 &= 0xdf;
        if ((c1 == '\0') & (c2 == '\0'))
            return(0);
        if ((c1 < c2) | (c1 == '\0'))
            return(-1);
        if ((c1 > c2) | (c2 == '\0'))
            return(1);
    }
    return(0);
}
#endif // PLATFORM_CE

#ifndef PLATFORM_WIN32
UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
{
    return 0;

    /*
    if (lpBuffer == NULL || uSize < 9)
        return 9;   // there are 9 unicode chars in L"\\Windows";

    CopyMemory(lpBuffer, L"\\Windows", 18);
    return 8;       // not including the unicode '\0';
    */
}

UINT GetEnvironmentVariableW(LPCWSTR lpName,  LPWSTR lpBuffer, UINT uSize)
{
    return 0;       // don't really support it on CE
}

#endif // !PLATFORM_WIN32


//*****************************************************************************
// Delete a registry key and subkeys.
//*****************************************************************************
DWORD WszRegDeleteKeyAndSubKeys(        // Return code.
    HKEY        hStartKey,              // The key to start with.
    LPCWSTR     wzKeyName)              // Subkey to delete.
{
    DWORD       dwRtn, dwSubKeyLength;      
    CQuickBytes qbSubKey;
    DWORD       dwMaxSize = CQUICKBYTES_BASE_SIZE / sizeof(WCHAR);
    HKEY        hKey;

    qbSubKey.ReSize(dwMaxSize * sizeof(WCHAR));

    // do not allow NULL or empty key name
    if (wzKeyName &&  wzKeyName[0] != '\0')     
    {
        if((dwRtn=WszRegOpenKeyEx(hStartKey, wzKeyName,
             0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey)) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS)
            {
                dwSubKeyLength = dwMaxSize;
                dwRtn = WszRegEnumKeyEx(                        
                               hKey,
                               0,       // always index zero
                               (WCHAR *)qbSubKey.Ptr(),
                               &dwSubKeyLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

                // buffer is not big enough
                if (dwRtn == ERROR_SUCCESS && dwSubKeyLength >= dwMaxSize)
                {
                    // make sure there is room for NULL terminating
                    dwMaxSize = ++dwSubKeyLength;
                    qbSubKey.ReSize(dwMaxSize * sizeof(WCHAR));
                    dwRtn = WszRegEnumKeyEx(                        
                                   hKey,
                                   0,       // always index zero
                                   (WCHAR *)qbSubKey.Ptr(),
                                   &dwSubKeyLength,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
                    _ASSERTE(dwSubKeyLength < dwMaxSize);

                }

                if  (dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = WszRegDeleteKey(hStartKey, wzKeyName);
                    break;
                }
                else if (dwRtn == ERROR_SUCCESS)
                    dwRtn = WszRegDeleteKeyAndSubKeys(hKey, (WCHAR *)qbSubKey.Ptr());
            }
            
            RegCloseKey(hKey);
            // Do not save return code because error
            // has already occurred
        }
    }
    else
        dwRtn = ERROR_BADKEY;
    
    return (dwRtn);
}


//*****************************************************************************
// Convert an Ansi or UTF string to Unicode.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszMultiByteToWideChar( 
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar)
{
    if (UTF78Support() || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        return (MultiByteToWideChar(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
    else
    {
        return (UTFToUnicode(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
}

//*****************************************************************************
// Convert a Unicode string to Ansi or UTF.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar)
{
    // WARNING: There's a bug in the OS's WideCharToMultiByte such that if you pass in a 
    // non-null lpUsedDefaultChar and a code page for a "DLL based encoding" (vs. a table 
    // based one?), WCtoMB will fail and GetLastError will give you E_INVALIDARG.  JulieB
    // said this is by design, mostly because no one got around to fixing it (1/24/2001 
    // in email to JRoxe).  This sucks, but now we know.  -- BrianGru, 2/20/2001
    _ASSERTE(!(CodePage == CP_UTF8 && lpUsedDefaultChar != NULL));

    if (UTF78Support() || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        // WC_NO_BEST_FIT_CHARS is only supported on NT5, XP, and Win98+.
        // For NT4, round-trip the string.
        bool doSlowBestFitCheck = FALSE;
        if ((dwFlags & WC_NO_BEST_FIT_CHARS) != 0 && !WCToMBBestFitMappingSupport()) {
            // Determine whether we're simply checking the string length or
            // really doing a string translation.
            doSlowBestFitCheck = cchMultiByte > 0;
            dwFlags &= ~WC_NO_BEST_FIT_CHARS;
        }

        int ret = WideCharToMultiByte(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar);

        // In the case of passing in -1 for a null-terminated string, make 
        // sure we null-terminate the string properly.
        _ASSERTE(ret == 0 || cchWideChar != -1 || (cchMultiByte == 0 || lpMultiByteStr[ret-1] == '\0'));

        if (ret != 0 && doSlowBestFitCheck) {
            // Convert the string back to Unicode.  If it isn't identical, fail.
            int wLen = (cchWideChar == -1) ? wcslen(lpWideCharStr) + 1 : cchWideChar;
            if (wLen > 0) {
                CQuickBytes qb;
                qb.Alloc((wLen + 1) * sizeof(WCHAR));
                WCHAR* wszStr = (WCHAR*) qb.Ptr();
                int r = MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, ret, wszStr, wLen);
                _ASSERTE(r == wLen);  // If we didn't convert the whole string, why not?
                if (r == 0 || wcsncmp(lpWideCharStr, wszStr, wLen) != 0) {
                    // With best fit mapping disabled, any non-mappable chars
                    // should be replaced with the default char.  The easiest
                    // way to do this appears to be to copy the Unicode string,
                    // replace WCHARs that didn't map 1 to 1 with a known 
                    // unmappable character, then call WCtoMB again.  
                    // Confirmed U+FFFE is not represented in any ANSI code page.
                    int minLen = min(r, wLen);
                    const WCHAR knownUnmappableChar = 0xFFFE;  // Invalid char.
                    // Overwrite wszStr with a copy of the Unicode string, with all
                    // the unmappable characters replaced.
                    for(int i=0; i<wLen; i++) {
                        if (i < r && wszStr[i] != lpWideCharStr[i])
                            wszStr[i] = knownUnmappableChar;
                        else
                            wszStr[i] = lpWideCharStr[i];
                    }
                    wszStr[wLen] = L'\0';
                    ret = WideCharToMultiByte(CodePage, dwFlags, wszStr, wLen, lpMultiByteStr, cchMultiByte, lpDefaultChar, lpUsedDefaultChar);
                    // Make sure we explicitly set lpUsedDefaultChar to true.
                    if (lpUsedDefaultChar != NULL) {
                        // WCtoMB should have guaranteed this, but just in case...
                        _ASSERTE(*lpUsedDefaultChar == TRUE);
                        *lpUsedDefaultChar = true;
                    }
                }
            }
        }

        return ret;
    }
    else
    {
        return (UnicodeToUTF(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar));
    }
}

// It is occasionally necessary to verify a Unicode string can be converted
// to the appropriate ANSI code page without any best fit mapping going on.
// Think of code that checks for a '\' or a '/' to make sure you don't access
// a file in a different directory.  Some unicode characters (ie, U+2044, 
// FRACTION SLASH, looks like '/') look like the ASCII equivalents and will 
// be mapped accordingly.  This can fool code that searches for '/' (U+002F).
// This should help prevent problems with best fit mapping characters, such
// as U+0101 (an 'a' with a bar on it) from mapping to a normal 'a'.
BOOL ContainsUnmappableANSIChars(const WCHAR * const widestr)
{
    _ASSERTE(widestr != NULL);
    BOOL usedDefaultChar = FALSE;
    int r = WszWideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, widestr, -1, NULL, 0, NULL, &usedDefaultChar);
    // Unmappable chars exist if usedDefaultChar was true or if we failed
    // (by returning 0).  Note on an empty string we'll return 1 (for \0)
    // because we passed in -1 for the string length above.
    return usedDefaultChar || r == 0;
}


// Running with an interactive workstation.
BOOL RunningInteractive()
{
    static int fInteractive = -1;
    if (fInteractive != -1)
        return fInteractive != 0;

    // @TODO:  Factor this into server build
    // Win9x does not support service, hence fInteractive is always true
#ifdef PLATFORM_WIN32
    if (!RunningOnWin95())
    {
#ifndef NOWINDOWSTATION
        HWINSTA hwinsta = NULL;

        if ((hwinsta = GetProcessWindowStation() ) != NULL)
        {
            DWORD lengthNeeded;
            USEROBJECTFLAGS flags;

            if (GetUserObjectInformationW (hwinsta, UOI_FLAGS, &flags, sizeof(flags), &lengthNeeded))
            {
                    if ((flags.dwFlags & WSF_VISIBLE) == 0)
                        fInteractive = 0;
            }
        }
#endif // !NOWINDOWSTATION
    }
#endif // PLATFORM_WIN32
    if (fInteractive != 0)
        fInteractive = 1;

    return fInteractive != 0;
}

int WszMessageBoxInternal(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType)
{
    if (hWnd == NULL && !RunningInteractive())
    {
        // @TODO: write to a service log
        // Only in Debugger::BaseExceptionHandler, the return value of WszM