 once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {9491EC16-D609-4814-B12E-D6AAD5B4C603}
DEFINE_GUID( TASKID_Minor_HrInit_ClusterOpenEnum_Failed,
0x9491ec16, 0xd609, 0x4814, 0xb1, 0x2e, 0xd6, 0xaa, 0xd5, 0xb4, 0xc6, 0x3);

// {458045A2-5AA7-45b6-BF44-2F725113E8B0}
DEFINE_GUID( TASKID_Minor_HrInit_InvalidArg,
0x458045a2, 0x5aa7, 0x45b6, 0xbf, 0x44, 0x2f, 0x72, 0x51, 0x13, 0xe8, 0xb0);

// {25434924-9296-458b-B11C-A88739D06A31}
DEFINE_GUID( TASKID_Minor_Next_InvalidPointer,
0x25434924, 0x9296, 0x458b, 0xb1, 0x1c, 0xa8, 0x87, 0x39, 0xd0, 0x6a, 0x31);

// {BEFEE4AE-1520-49e8-A3BB-6AEF91DB21BD}
DEFINE_GUID( TASKID_Minor_HrGetItem_ClusterEnum_Failed,
0xbefee4ae, 0x1520, 0x49e8, 0xa3, 0xbb, 0x6a, 0xef, 0x91, 0xdb, 0x21, 0xbd);

// {B51D6B89-47AB-4521-943B-92964E4395F7}
DEFINE_GUID( TASKID_Minor_HrGetItem_Create_CProxyCfgNetworkInfo_Failed,
0xb51d6b89, 0x47ab, 0x4521, 0x94, 0x3b, 0x92, 0x96, 0x4e, 0x43, 0x95, 0xf7);

// {50ACA86D-7ADA-40ad-A062-64170ADAC8E8}
DEFINE_GUID( TASKID_Minor_HrGetItem_QI_Failed,
0x50aca86d, 0x7ada, 0x40ad, 0xa0, 0x62, 0x64, 0x17, 0xa, 0xda, 0xc8, 0xe8);

// {FACFF7A1-6419-420d-A9D0-16037E87567D}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterResource_Failed,
0xfacff7a1, 0x6419, 0x420d, 0xa9, 0xd0, 0x16, 0x3, 0x7e, 0x87, 0x56, 0x7d);

// {E9BB1785-0CCF-4413-9BFD-45FBA6772F1B}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetResourceProperties_Failed,
0xe9bb1785, 0xccf, 0x4413, 0x9b, 0xfd, 0x45, 0xfb, 0xa6, 0x77, 0x2f, 0x1b);

// {0FBA185E-0F12-48ae-9957-1F40994558AF}
DEFINE_GUID( TASKID_Minor_HrInit_ScMoveToPropertyByName_Failed,
0xfba185e, 0xf12, 0x48ae, 0x99, 0x57, 0x1f, 0x40, 0x99, 0x45, 0x58, 0xaf);

// {9206FB5A-9FF8-4aa6-AB95-6993D5334140}
DEFINE_GUID( TASKID_Minor_W2KProxy_PhysDisk_HrInit_InvalidArg,
0x9206fb5a, 0x9ff8, 0x4aa6, 0xab, 0x95, 0x69, 0x93, 0xd5, 0x33, 0x41, 0x40);

// {232BCA76-98CF-40ca-9E0C-FF0502B7849B}
DEFINE_GUID( TASKID_Minor_HrInit_OutOfMemory,
0x232bca76, 0x98cf, 0x40ca, 0x9e, 0xc, 0xff, 0x5, 0x2, 0xb7, 0x84, 0x9b);

// {7049CE22-11EF-4a09-92B3-5892E9C1BDB4}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetResourceValueList_Failed,
0x7049ce22, 0x11ef, 0x4a09, 0x92, 0xb3, 0x58, 0x92, 0xe9, 0xc1, 0xbd, 0xb4);

// {C48BEE66-BB89-4a04-AB9E-ECEBF3D5A02C}
DEFINE_GUID( TASKID_Minor_HrInit_ClusterResourceControl_Failed,
0xc48bee66, 0xbb89, 0x4a04, 0xab, 0x9e, 0xec, 0xeb, 0xf3, 0xd5, 0xa0, 0x2c);

// {805FA623-96E7-4b8b-A4B6-50AEA0B0A6E1}
DEFINE_GUID( TASKID_HrInit_ScMoveToFirstValue_Failed,
0x805fa623, 0x96e7, 0x4b8b, 0xa4, 0xb6, 0x50, 0xae, 0xa0, 0xb0, 0xa6, 0xe1);

// {F8E8366F-F529-4295-8AB2-F311D4C5E527}
DEFINE_GUID( TASKID_HrInit_ScMoveToNextValue_Failed,
0xf8e8366f, 0xf529, 0x4295, 0x8a, 0xb2, 0xf3, 0x11, 0xd4, 0xc5, 0xe5, 0x27);

// {B25995A4-B839-4723-AB81-1BF9D54FA64D}
DEFINE_GUID( TASKID_HrInit_Create_CResourcePhysicalDiskPartition_Failed,
0xb25995a4, 0xb839, 0x4723, 0xab, 0x81, 0x1b, 0xf9, 0xd5, 0x4f, 0xa6, 0x4d);

// {955F1520-8306-4bc0-A4C3-93278F8A7C03}
DEFINE_GUID( TASKID_HrInit_QI_Failed,
0x955f1520, 0x8306, 0x4bc0, 0xa4, 0xc3, 0x93, 0x27, 0x8f, 0x8a, 0x7c, 0x3);

// {255B04C7-DBA1-4fc5-9EB6-7B48B52793CC}
DEFINE_GUID( TASKID_HrInit_ScMoveToNextValue2_Failed,
0x255b04c7, 0xdba1, 0x4fc5, 0x9e, 0xb6, 0x7b, 0x48, 0xb5, 0x27, 0x93, 0xcc);

// {89190A29-D520-4d53-AB92-679A92A08AE3}
DEFINE_GUID( TASKID_Minor_GetName_ScMoveToPropertyByName_MajorVersion_Failed,
0x89190a29, 0xd520, 0x4d53, 0xab, 0x92, 0x67, 0x9a, 0x92, 0xa0, 0x8a, 0xe3);

// {0F0680A3-27EA-47f2-9D31-FD97174FD7B1}
DEFINE_GUID( TASKID_Minor_GetName_InvalidPointer,
0xf0680a3, 0x27ea, 0x47f2, 0x9d, 0x31, 0xfd, 0x97, 0x17, 0x4f, 0xd7, 0xb1);

// {EC6968DE-9AA7-4905-ABCF-16D3C5FE5A3E}
DEFINE_GUID( TASKID_Minor_GetName_OutOfMemory,
0xec6968de, 0x9aa7, 0x4905, 0xab, 0xcf, 0x16, 0xd3, 0xc5, 0xfe, 0x5a, 0x3e);

// {28D5A7E7-942C-4c81-BA94-9C323E375E95}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToFirstValue_Failed,
0x28d5a7e7, 0x942c, 0x4c81, 0xba, 0x94, 0x9c, 0x32, 0x3e, 0x37, 0x5e, 0x95);

// {5B32EE5E-093D-493e-A001-0C375B4936DD}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToNextValue_Failed,
0x5b32ee5e, 0x93d, 0x493e, 0xa0, 0x1, 0xc, 0x37, 0x5b, 0x49, 0x36, 0xdd);

// {E2D22027-855D-4a3a-84C4-1274CFE9AE78}
DEFINE_GUID( TASKID_Minor_GetUID_InvalidPointer,
0xe2d22027, 0x855d, 0x4a3a, 0x84, 0xc4, 0x12, 0x74, 0xcf, 0xe9, 0xae, 0x78);

// {D34C3403-4440-471f-8188-E73477967B2F}
DEFINE_GUID( TASKID_Minor_GetUID_OutOfMemory,
0xd34c3403, 0x4440, 0x471f, 0x81, 0x88, 0xe7, 0x34, 0x77, 0x96, 0x7b, 0x2f);

// {A496B1F8-C227-4f4f-8E39-06105B37A6A6}
DEFINE_GUID( TASKID_Minor_Next_QI_Failed,
0xa496b1f8, 0xc227, 0x4f4f, 0x8e, 0x39, 0x6, 0x10, 0x5b, 0x37, 0xa6, 0xa6);

// {9BE21DA9-319B-430a-B909-7BBC96AAE3D0}
DEFINE_GUID( TASKID_Minor_W2kProxy_PhysDisk_Next_InvalidPointer,
0x9be21da9, 0x319b, 0x430a, 0xb9, 0x9, 0x7b, 0xbc, 0x96, 0xaa, 0xe3, 0xd0);

// {540B2FB4-A32E-4d9e-86AF-1921E9CFDBF3}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterNetInterface_Failed,
0x540b2fb4, 0xa32e, 0x4d9e, 0x86, 0xaf, 0x19, 0x21, 0xe9, 0xcf, 0xdb, 0xf3);

// {E6D15E2A-2420-4f7c-A6CA-54F59E63F649}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetNetworkProperties_Failed,
0xe6d15e2a, 0x2420, 0x4f7c, 0xa6, 0xca, 0x54, 0xf5, 0x9e, 0x63, 0xf6, 0x49);

// {2F1C8C49-24A8-461b-95BD-01BA3C8E3BC2}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_HrInit_InvalidArg,
0x2f1c8c49, 0x24a8, 0x461b, 0x95, 0xbd, 0x1, 0xba, 0x3c, 0x8e, 0x3b, 0xc2);

// {F418431E-CA79-4824-959C-DFE6B651C451}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToPropetyByName_Address_Failed,
0xf418431e, 0xca79, 0x4824, 0x95, 0x9c, 0xdf, 0xe6, 0xb6, 0x51, 0xc4, 0x51);

// {87F0AEE6-9053-4a96-B7C0-36D700061522}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_Address_Failed,
0x87f0aee6, 0x9053, 0x4a96, 0xb7, 0xc0, 0x36, 0xd7, 0x0, 0x6, 0x15, 0x22);

// {3BAD166A-B3C9-4ba3-B317-DD8F39654971}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_AddressMask_Failed,
0x3bad166a, 0xb3c9, 0x4ba3, 0xb3, 0x17, 0xdd, 0x8f, 0x39, 0x65, 0x49, 0x71);

// {C9AF04B0-761F-4f4a-8DC3-294D3B92B006}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToPropetyByName_AddressMask_Failed,
0xc9af04b0, 0x761f, 0x4f4a, 0x8d, 0xc3, 0x29, 0x4d, 0x3b, 0x92, 0xb0, 0x6);

// {E27B766D-BE66-4f83-93BA-ED1E20B82AC7}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipAddressToString_Failed,
0xe27b766d, 0xbe66, 0x4f83, 0x93, 0xba, 0xed, 0x1e, 0x20, 0xb8, 0x2a, 0xc7);

// {A17BD776-A8F5-4f65-81D9-D34B9351766D}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetUID_InvalidPointer,
0xa17bd776, 0xa8f5, 0x4f65, 0x81, 0xd9, 0xd3, 0x4b, 0x93, 0x51, 0x76, 0x6d);

// {4964954E-E203-497f-B330-00E97C2C732E}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetUID_OutOfMemory,
0x4964954e, 0xe203, 0x497f, 0xb3, 0x30, 0x0, 0xe9, 0x7c, 0x2c, 0x73, 0x2e);

// {96E65D6B-865D-4bdd-BCBE-B7A64B1479BD}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetName_ScMoveToPropertyByName_MajorVersion_Failed,
0x96e65d6b, 0x865d, 0x4bdd, 0xbc, 0xbe, 0xb7, 0xa6, 0x4b, 0x14, 0x79, 0xbd);

// {EE6EB070-06AE-443b-BB93-460C1DF15976}
DEFINE_GUID( TASKID_Minor_W2kProxy_NetworkInfo_GetName_InvalidPointer,
0xee6eb070, 0x6ae, 0x443b, 0xbb, 0x93, 0x46, 0xc, 0x1d, 0xf1, 0x59, 0x76);

// {3D095700-CDF8-4208-A309-7A0594768E74}
DEFINE_GUID( TASKID_Minor_GetDescription_ScMoveToPropertyByName_MajorVersion_Failed,
0x3d095700, 0xcdf8, 0x4208, 0xa3, 0x9, 0x7a, 0x5, 0x94, 0x76, 0x8e, 0x74);

// {34ADDED3-7E50-44c0-B19B-0B254D5B39F6}
DEFINE_GUID( TASKID_Minor_GetDescription_InvalidPointer,
0x34added3, 0x7e50, 0x44c0, 0xb1, 0x9b, 0xb, 0x25, 0x4d, 0x5b, 0x39, 0xf6);

// {ACF05075-7F27-4a46-8764-BC3C4540F47C}
DEFINE_GUID( TASKID_Minor_GetDescription_OutOfMemory,
0xacf05075, 0x7f27, 0x4a46, 0x87, 0x64, 0xbc, 0x3c, 0x45, 0x40, 0xf4, 0x7c);

// {80283A7F-9287-4675-95B0-82A7A86477E8}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_Address_Failed,
0x80283a7f, 0x9287, 0x4675, 0x95, 0xb0, 0x82, 0xa7, 0xa8, 0x64, 0x77, 0xe8);

// {987C78B3-DA64-4564-8A15-FCF7FD11417B}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_Address_Failed,
0x987c78b3, 0xda64, 0x4564, 0x8a, 0x15, 0xfc, 0xf7, 0xfd, 0x11, 0x41, 0x7b);

// {5BBE6DAD-E22F-4739-81CC-1960F0C20AAB}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_AddressMask_Failed,
0x5bbe6dad, 0xe22f, 0x4739, 0x81, 0xcc, 0x19, 0x60, 0xf0, 0xc2, 0xa, 0xab);

// {23D52E63-D12C-43f8-8538-427ED0395580}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_AddressMask_Failed,
0x23d52e63, 0xd12c, 0x43f8, 0x85, 0x38, 0x42, 0x7e, 0xd0, 0x39, 0x55, 0x80);

// {1B9AE821-AF42-4080-A779-3CD755AFCCC8}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_Create_CProxyCfgIPAddressInfo_Failed,
0x1b9ae821, 0xaf42, 0x4080, 0xa7, 0x79, 0x3c, 0xd7, 0x55, 0xaf, 0xcc, 0xc8);

// {5C6C05F3-1090-4e63-9EF2-874802EE278A}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_InvalidPointer,
0x5c6c05f3, 0x1090, 0x4e63, 0x9e, 0xf2, 0x87, 0x48, 0x2, 0xee, 0x27, 0x8a);

// {93796908-CBC9-43e4-9016-2F375806D201}
DEFINE_GUID( TASKID_Minor_HrGetNetworkRole_ScMoveToPropetyByName_Failed,
0x93796908, 0xcbc9, 0x43e4, 0x90, 0x16, 0x2f, 0x37, 0x58, 0x6, 0xd2, 0x1);

// {966039B7-A549-4774-93C6-C16521F85C03}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_HrInit_InvalidArg,
0x966039b7, 0xa549, 0x4774, 0x93, 0xc6, 0xc1, 0x65, 0x21, 0xf8, 0x5c, 0x3);

// {5DB84C20-C71C-4c37-8185-9E954B8DC370}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_ClRtlTcpipAddressToString_Failed,
0x5db84c20, 0xc71c, 0x4c37, 0x81, 0x85, 0x9e, 0x95, 0x4b, 0x8d, 0xc3, 0x70);

// {D2AA1F54-CD22-4a42-B926-8243E8B97FDC}
DEFINE_GUID( TASKID_Minor_W2kProxy_IPAddressInfo_GetName_InvalidPointer,
0xd2aa1f54, 0xcd22, 0x4a42, 0xb9, 0x26, 0x82, 0x43, 0xe8, 0xb9, 0x7f, 0xdc);

// {600F2D37-72EC-40af-8850-16C43E72F83C}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_OutOfMemory,
0x600f2d37, 0x72ec, 0x40af, 0x88, 0x50, 0x16, 0xc4, 0x3e, 0x72, 0xf8, 0x3c);

// {AAC251F6-F902-4824-9C88-72FE3F4F2098}
DEFINE_GUID( TASKID_Minor_GetIPAddress_InvalidPointer,
0xaac251f6, 0xf902, 0x4824, 0x9c, 0x88, 0x72, 0xfe, 0x3f, 0x4f, 0x20, 0x98);

// {458045A2-5AA7-45b6-BF44-2F725113E8B0}
DEFINE_GUID( TASKID_Minor_GetSubnetMask_InvalidPointer,
0x458045a2, 0x5aa7, 0x45b6, 0xbf, 0x44, 0x2f, 0x72, 0x51, 0x13, 0xe8, 0xb0);

// {44EE7A1A-EC06-4d06-AC50-103C201D58FA}
DEFINE_GUID( TASKID_Minor_HrInit_GetClusterInformation_Failed,
0x44ee7a1a, 0xec06, 0x4d06, 0xac, 0x50, 0x10, 0x3c, 0x20, 0x1d, 0x58, 0xfa);

// {BBE9914E-7CA8-4ac2-92BB-5B1CDD536132}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidArg,
0xbbe9914e, 0x7ca8, 0x4ac2, 0x92, 0xbb, 0x5b, 0x1c, 0xdd, 0x53, 0x61, 0x32);

// {ECF5732D-83A1-4cfc-88EF-01701B4A1EBC}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_HrInit_OutOfMemory,
0xecf5732d, 0x83a1, 0x4cfc, 0x88, 0xef, 0x1, 0x70, 0x1b, 0x4a, 0x1e, 0xbc);

// {8C42896F-0B5F-475e-BAF3-2942C9C13B59}
DEFINE_GUID( TASKID_Minor_W2kProxy_ClusterInfo_GetName_InvalidPointer,
0x8c42896f, 0xb5f, 0x475e, 0xba, 0xf3, 0x29, 0x42, 0xc9, 0xc1, 0x3b, 0x59);

// {D5B1D012-04EA-4792-9D24-039B2246C109}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_GetIPAddress_InvalidPointer,
0xd5b1d012, 0x4ea, 0x4792, 0x9d, 0x24, 0x3, 0x9b, 0x22, 0x46, 0xc1, 0x9);

// {C40B09FF-8FB0-465e-ABE9-2B5A958838C3}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_GetSubnetMask_InvalidPointer,
0xc40b09ff, 0x8fb0, 0x465e, 0xab, 0xe9, 0x2b, 0x5a, 0x95, 0x88, 0x38, 0xc3);

// {BF026173-29F7-406b-AE59-DC6E2D2AA6DB}
DEFINE_GUID( TASKID_Minor_GetNetworkInfo_InvalidPointer,
0xbf026173, 0x29f7, 0x406b, 0xae, 0x59, 0xdc, 0x6e, 0x2d, 0x2a, 0xa6, 0xdb);

// {00FE754D-34BD-4e97-BCE4-C39E1D8D4222}
DEFINE_GUID( TASKID_Minor_GetClusterServiceAccountCredentials_InvalidPointer,
0xfe754d, 0x34bd, 0x4e97, 0xbc, 0xe4, 0xc3, 0x9e, 0x1d, 0x8d, 0x42, 0x22);

// {955A0957-DE24-4ad2-B4B8-14F7B0C51A18}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OpenSCManager_Failed,
0x955a0957, 0xde24, 0x4ad2, 0xb4, 0xb8, 0x14, 0xf7, 0xb0, 0xc5, 0x1a, 0x18);

// {B2F03A50-FDFE-48e7-A63E-6472C9EC6AA7}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OpenService_Failed,
0xb2f03a50, 0xfdfe, 0x48e7, 0xa6, 0x3e, 0x64, 0x72, 0xc9, 0xec, 0x6a, 0xa7);

// {C00865C0-EDFD-4691-A9EA-873FAB6BA88B}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_QueryServiceConfig_Failed,
0xc00865c0, 0xedfd, 0x4691, 0xa9, 0xea, 0x87, 0x3f, 0xab, 0x6b, 0xa8, 0x8b);

// {61664807-6139-4652-A819-7DE9EB4B0EAA}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OutOfMemory,
0x61664807, 0x6139, 0x4652, 0xa8, 0x19, 0x7d, 0xe9, 0xeb, 0x4b, 0xe, 0xaa);

// {57E0A0EC-7BED-4fbd-BD26-EEE33FC6054A}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrInit_ClusterOpenEnum_Failed,
0x57e0a0ec, 0x7bed, 0x4fbd, 0xbd, 0x26, 0xee, 0xe3, 0x3f, 0xc6, 0x5, 0x4a);

// {F9885CDE-E29C-40c9-BE63-7FE458EBD663}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_Next_InvalidPointer,
0xf9885cde, 0xe29c, 0x40c9, 0xbe, 0x63, 0x7f, 0xe4, 0x58, 0xeb, 0xd6, 0x63);

// {45F664B7-8219-4457-B3DF-841889D90D5C}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrGetItem_ClusterEnum_Failed,
0x45f664b7, 0x8219, 0x4457, 0xb3, 0xdf, 0x84, 0x18, 0x89, 0xd9, 0xd, 0x5c);

// {0FCE6BB7-FCDB-42d4-B795-9DFC01740268}
DEFINE_GUID( TASKID_Minor_HrGetItem_Create_CResourcePhysicalDisk_Failed,
0xfce6bb7, 0xfcdb, 0x42d4, 0xb7, 0x95, 0x9d, 0xfc, 0x1, 0x74, 0x2, 0x68);

// {98954BD2-0FBF-4017-91C4-F9DA40DFF602}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrGetItem_QI_Failed,
0x98954bd2, 0xfbf, 0x4017, 0x91, 0xc4, 0xf9, 0xda, 0x40, 0xdf, 0xf6, 0x2);

// {07A2104E-0C4C-4661-B19A-18E940421A3B}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetObject_Failed,
0x7a2104e, 0xc4c, 0x4661, 0xb1, 0x9a, 0x18, 0xe9, 0x40, 0x42, 0x1a, 0x3b);

// {6437294D-0338-4482-B773-A19F4E30DEDB}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetName_Failed,
0x6437294d, 0x338, 0x4482, 0xb7, 0x73, 0xa1, 0x9f, 0x4e, 0x30, 0xde, 0xdb);

// {6473FEB0-7BB0-4e38-A4C1-0DEBD9A7FA28}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetType_Failed,
0x6473feb0, 0x7bb0, 0x4e38, 0xa4, 0xc1, 0xd, 0xeb, 0xd9, 0xa7, 0xfa, 0x28);

// {54587A22-FDD4-4df0-ADC1-DCAA2C677313}
DEFINE_GUID( TASKID_Minor_ConnectTo_CreateBinding_Failed,
0x54587a22, 0xfdd4, 0x4df0, 0xad, 0xc1, 0xdc, 0xaa, 0x2c, 0x67, 0x73, 0x13);

// {838A18DC-A2B4-40ce-9914-6C791DCB32E2}
DEFINE_GUID( TASKID_Minor_ConnectTo_OpenCluster_Failed,
0x838a18dc, 0xa2b4, 0x40ce, 0x99, 0x14, 0x6c, 0x79, 0x1d, 0xcb, 0x32, 0xe2);

// {FB3B6700-E3CB-457b-9A90-562A1491DAEB}
DEFINE_GUID( TASKID_Minor_ConnectTo_HrFQNIsFQIP_Failed, 
0xfb3b6700, 0xe3cb, 0x457b, 0x9a, 0x90, 0x56, 0x2a, 0x14, 0x91, 0xda, 0xeb);

// {70787AD3-91D7-42be-94A1-713A8365C77C}
DEFINE_GUID( TASKID_Minor_ConnectTo_HrMakeClusterFQDN_Failed, 
0x70787ad3, 0x91d7, 0x42be, 0x94, 0xa1, 0x71, 0x3a, 0x83, 0x65, 0xc7, 0x7c);

// {2D56C680-8C15-403b-A436-215C4BBC7B3F}
DEFINE_GUID( TASKID_Minor_ConnectTo_SetName_Failed, 
0x2d56c680, 0x8c15, 0x403b, 0xa4, 0x36, 0x21, 0x5c, 0x4b, 0xbc, 0x7b, 0x3f);

// {09706575-33EE-4968-ACE4-5F07908A3008}
DEFINE_GUID( TASKID_Minor_ConnectToObject_GetObject_Failed,
0x9706575, 0x33ee, 0x4968, 0xac, 0xe4, 0x5f, 0x7, 0x90, 0x8a, 0x30, 0x8);

// {16CDA6FF-2F82-40fc-B5D1-2D2B9D5FE2E9}
DEFINE_GUID( TASKID_Minor_ConnectToObject_GetType_Failed,
0x16cda6ff, 0x2f82, 0x40fc, 0xb5, 0xd1, 0x2d, 0x2b, 0x9d, 0x5f, 0xe2, 0xe9);

// {7F6E7CE8-6522-4dc1-8FB3-9642E1DF8F59}
DEFINE_GUID( TASKID_Minor_ConnectToObject_InvalidCookie,
0x7f6e7ce8, 0x6522, 0x4dc1, 0x8f, 0xb3, 0x96, 0x42, 0xe1, 0xdf, 0x8f, 0x59);

// {81A66A97-F1C6-41cd-AE21-4764D8CC8E42}
DEFINE_GUID( TASKID_Minor_ConnectToObject_QI_Failed,
0x81a66a97, 0xf1c6, 0x41cd, 0xae, 0x21, 0x47, 0x64, 0xd8, 0xcc, 0x8e, 0x42);

// {BE3BB350-9357-4ecf-92D7-A544F7E144F6}
DEFINE_GUID( TASKID_Minor_ConnectToObject_NotInitialized,
0xbe3bb350, 0x9357, 0x4ecf, 0x92, 0xd7, 0xa5, 0x44, 0xf7, 0xe1, 0x44, 0xf6);

// {5435EE48-1C10-4e39-95D0-F44A13FC4437}
DEFINE_GUID( TASKID_Minor_GetBindingString_InvalidPointer,
0x5435ee48, 0x1c10, 0x4e39, 0x95, 0xd0, 0xf4, 0x4a, 0x13, 0xfc, 0x44, 0x37);

// {5F883479-8766-4abf-A829-4AEF0FD78E33}
DEFINE_GUID( TASKID_Minor_GetBindingString_OutOfMemory,
0x5f883479, 0x8766, 0x4abf, 0xa8, 0x29, 0x4a, 0xef, 0xf, 0xd7, 0x8e, 0x33);

// {81668FC6-A737-4552-A94B-965F57CBB959}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_Create_CProxyCfgNodeInfo,
0x81668fc6, 0xa737, 0x4552, 0xa9, 0x4b, 0x96, 0x5f, 0x57, 0xcb, 0xb9, 0x59);

// {3EBCC239-9176-48aa-8E52-16FA7816F20E}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_QI_Failed,
0x3ebcc239, 0x9176, 0x48aa, 0x8e, 0x52, 0x16, 0xfa, 0x78, 0x16, 0xf2, 0xe);

// {34F1C706-1044-42e7-9CB5-A7BCBC3CA4D3}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_NotInitialized,
0x34f1c706, 0x1044, 0x42e7, 0x9c, 0xb5, 0xa7, 0xbc, 0xbc, 0x3c, 0xa4, 0xd3);

// {F9103FBD-AAED-4c7e-A630-C3E546B53EEC}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_InvalidPointer,
0xf9103fbd, 0xaaed, 0x4c7e, 0xa6, 0x30, 0xc3, 0xe5, 0x46, 0xb5, 0x3e, 0xec);

// {9535FFD1-58F9-4301-8F54-0DD9F23C6D29}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_HrFindDomainInFQN, 
0x9535ffd1, 0x58f9, 0x4301, 0x8f, 0x54, 0xd, 0xd9, 0xf2, 0x3c, 0x6d, 0x29);

// {86D27D4E-0184-44e1-9A34-3F2DCBF0007B}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_HrExtractPrefixFromFQN, 
0x86d27d4e, 0x184, 0x44e1, 0x9a, 0x34, 0x3f, 0x2d, 0xcb, 0xf0, 0x0, 0x7b);

// {7FABED13-F4DE-47dc-9C80-2A9151DBDC80}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_Create_CEnumCfgResources_Failed,
0x7fabed13, 0xf4de, 0x47dc, 0x9c, 0x80, 0x2a, 0x91, 0x51, 0xdb, 0xdc, 0x80);

// {FD341F3D-0CB5-45f0-BA92-A16DE93803F1}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_QI_Failed,
0xfd341f3d, 0xcb5, 0x45f0, 0xba, 0x92, 0xa1, 0x6d, 0xe9, 0x38, 0x3, 0xf1);

// {C96B12A9-E2F9-4217-BBCA-03F373ED9AAC}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_NotInitialized,
0xc96b12a9, 0xe2f9, 0x4217, 0xbb, 0xca, 0x3, 0xf3, 0x73, 0xed, 0x9a, 0xac);

// {055C2FB6-B334-439f-A6A5-97386371EACC}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_InvalidPointer,
0x55c2fb6, 0xb334, 0x439f, 0xa6, 0xa5, 0x97, 0x38, 0x63, 0x71, 0xea, 0xcc);

// {1604E621-79BF-45cd-8B7B-4BC6EE0216AE}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_Create_CEnumCfgNetworks_Failed,
0x1604e621, 0x79bf, 0x45cd, 0x8b, 0x7b, 0x4b, 0xc6, 0xee, 0x2, 0x16, 0xae);

// {B333E856-117B-46a3-B056-9DFA53781169}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_QI_Failed,
0xb333e856, 0x117b, 0x46a3, 0xb0, 0x56, 0x9d, 0xfa, 0x53, 0x78, 0x11, 0x69);

// {0667C871-C3E0-49ce-B6A7-72DD14D50DCF}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_NotInitialized,
0x667c871, 0xc3e0, 0x49ce, 0xb6, 0xa7, 0x72, 0xdd, 0x14, 0xd5, 0xd, 0xcf);

// {560B07F2-AB0D-4bf9-BDD2-E7F2A1383CC8}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_InvalidPointer,
0x560b07f2, 0xab0d, 0x4bf9, 0xbd, 0xd2, 0xe7, 0xf2, 0xa1, 0x38, 0x3c, 0xc8);

// {47935407-8F64-4971-B35A-1682372D10C7}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterNode_Failed,
0x47935407, 0x8f64, 0x4971, 0xb3, 0x5a, 0x16, 0x82, 0x37, 0x2d, 0x10, 0xc7);

// {76BD3782-7468-4a1e-8193-DDB3885F679F}
DEFINE_GUID( TASKID_Minor_HrInit_ResUtilEnumResourcesEx_Failed,
0x76bd3782, 0x7468, 0x4a1e, 0x81, 0x93, 0xdd, 0xb3, 0x88, 0x5f, 0x67, 0x9f);

// {B4433748-DD2C-4b6d-9C2C-983D488C5E5C}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetNodeProperties_Failed,
0xb4433748, 0xdd2c, 0x4b6d, 0x9c, 0x2c, 0x98, 0x3d, 0x48, 0x8c, 0x5e, 0x5c);

// {303DB937-B3CD-4d20-8062-40764E0DE21E}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_Create_CProxyCfgClusterInfo_Failed,
0x303db937, 0xb3cd, 0x4d20, 0x80, 0x62, 0x40, 0x76, 0x4e, 0xd, 0xe2, 0x1e);

// {4852B640-D2F1-4606-9917-60052BA6F28B}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_QI_Failed,
0x4852b640, 0xd2f1, 0x4606, 0x99, 0x17, 0x60, 0x5, 0x2b, 0xa6, 0xf2, 0x8b);

// {0929C6B4-139C-4528-BC72-3BB2976F6BA2}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_InvalidPointer,
0x929c6b4, 0x139c, 0x4528, 0xbc, 0x72, 0x3b, 0xb2, 0x97, 0x6f, 0x6b, 0xa2);

// {7D09EE97-7AC3-40b7-A11C-85CC947226FD}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MajorVersion_Failed,
0x7d09ee97, 0x7ac3, 0x40b7, 0xa1, 0x1c, 0x85, 0xcc, 0x94, 0x72, 0x26, 0xfd);

// {E2F1D370-E1D7-4dc1-B299-00F78DE652A9}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed,
0xe2f1d370, 0xe1d7, 0x4dc1, 0xb2, 0x99, 0x0, 0xf7, 0x8d, 0xe6, 0x52, 0xa9);

// {6096C19C-CD2D-4849-8CF2-DB158AE891E1}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_CSDVersion_Failed,
0x6096c19c, 0xcd2d, 0x4849, 0x8c, 0xf2, 0xdb, 0x15, 0x8a, 0xe8, 0x91, 0xe1);

// {1B912803-E1F0-4b2d-8C50-B9300EF08F99}
DEFINE_GUID( TASKID_Minor_GetOSVersion_InvalidPointer,
0x1b912803, 0xe1f0, 0x4b2d, 0x8c, 0x50, 0xb9, 0x30, 0xe, 0xf0, 0x8f, 0x99);

// {8DD80E3A-6F49-499f-B2B1-A6A8CE470A05}
DEFINE_GUID( TASKID_Minor_GetOSVersion_OutOfMemory,
0x8dd80e3a, 0x6f49, 0x499f, 0xb2, 0xb1, 0xa6, 0xa8, 0xce, 0x47, 0xa, 0x5);

// {A29910BF-A68D-44cf-8C92-4A0B70964B65}
DEFINE_GUID( TASKID_Minor_W2kProxy_NodeInfo_GetName_InvalidPointer,
0xa29910bf, 0xa68d, 0x44cf, 0x8c, 0x92, 0x4a, 0xb, 0x70, 0x96, 0x4b, 0x65);

// {C4F2FC21-632F-48f0-BC45-2F53C4AA6F93}
DEFINE_GUID( TASKID_Minor_W2KProxy_NodeInfo_GetName_OutOfMemory,
0xc4f2fc21, 0x632f, 0x48f0, 0xbc, 0x45, 0x2f, 0x53, 0xc4, 0xaa, 0x6f, 0x93);

// {7D94E439-54C2-47ab-9E10-28D0A6860E4D}
DEFINE_GUID( TASKID_Minor_W2KProxy_NodeInfo_GetName_HrMakeFQN_Failed, 
0x7d94e439, 0x54c2, 0x47ab, 0x9e, 0x10, 0x28, 0xd0, 0xa6, 0x86, 0xe, 0x4d);

// {82D15E31-DA75-4b1a-8DA6-6937D847EE28}
DEFINE_GUID( TASKID_Minor_GetClusterInformation_Failed,
0x82d15e31, 0xda75, 0x4b1a, 0x8d, 0xa6, 0x69, 0x37, 0xd8, 0x47, 0xee, 0x28);

// {DD9E98ED-3A3C-40f6-B46F-76A7105514D5}
DEFINE_GUID( TASKID_Minor_GetClusterVersion_InvalidPointer,
0xdd9e98ed, 0x3a3c, 0x40f6, 0xb4, 0x6f, 0x76, 0xa7, 0x10, 0x55, 0x14, 0xd5);

// {2B8B9073-2DCB-476e-818B-91146114E0FF}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_InvalidPointer,
0x2b8b9073, 0x2dcb, 0x476e, 0x81, 0x8b, 0x91, 0x14, 0x61, 0x14, 0xe0, 0xff);

// {F38332D5-05EE-4a27-9B79-B9F06C12F54A}
DEFINE_GUID( TASKID_Minor_W2kProxy_ClusterInfo_GetBindingString_InvalidPointer,
0xf38332d5, 0x5ee, 0x4a27, 0x9b, 0x79, 0xb9, 0xf0, 0x6c, 0x12, 0xf5, 0x4a);

// {74703921-E255-43c3-A0E8-2182F6DE34BA}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidDottedQuad,
0x74703921, 0xe255, 0x43c3, 0xa0, 0xe8, 0x21, 0x82, 0xf6, 0xde, 0x34, 0xba);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\w2kproxystrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      W2KProxyStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

/////////////////////////////////////////////////////////////////////
// Error strings
/////////////////////////////////////////////////////////////////////

#define IDS_F_SVR_CONNECT                   ( ID_CCW2K_START +  1 )
#define IDS_F_NODE_CONNECT                  ( ID_CCW2K_START +  2 )
#define IDS_SVR_CONNECT                     ( ID_CCW2K_START +  3 )
#define IDS_SVR_INIT                        ( ID_CCW2K_START +  4 )
#define IDS_INFO_NODE                       ( ID_CCW2K_START +  5 )
#define IDS_F_INFO_NODE                     ( ID_CCW2K_START +  6 )
#define IDS_INFO_RES                        ( ID_CCW2K_START +  7 )
#define IDS_F_INFO_RES                      ( ID_CCW2K_START +  8 )
#define IDS_INFO_NET                        ( ID_CCW2K_START +  9 )
#define IDS_F_INFO_NET                      ( ID_CCW2K_START + 10 )
#define IDS_GINFO_CLUSTER                   ( ID_CCW2K_START + 11 )
#define IDS_F_GINFO_CLUSTER                 ( ID_CCW2K_START + 12 )
#define IDS_GINFO_IPADDR                    ( ID_CCW2K_START + 13 )
#define IDS_F_GINFO_IPADDR                  ( ID_CCW2K_START + 14 )
#define IDS_GINFO_NET                       ( ID_CCW2K_START + 15 )
#define IDS_F_GINFO_NET                     ( ID_CCW2K_START + 16 )
#define IDS_GINFO_NODE                      ( ID_CCW2K_START + 17 )
#define IDS_F_GINFO_NODE                    ( ID_CCW2K_START + 18 )
#define IDS_INFO_CLUSTER                    ( ID_CCW2K_START + 19 )
#define IDS_F_INFO_CLUSTER                  ( ID_CCW2K_START + 20 )
#define IDS_GINFO_PDISK                     ( ID_CCW2K_START + 21 )
#define IDS_F_GINFO_PDISK                   ( ID_CCW2K_START + 22 )
#define IDS_WARNING_MINOR_BAD_CREDENTIALS   ( ID_CCW2K_START + 23 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldiskpartition.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDiskPartition.h
//
//  Description:
//      CResourcePhysicalDiskPartition header.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourcePhysicalDiskPartition
//
//  Description:
//      The class CResourcePhysicalDiskPartition is the enumeration of cluster
//      storage device partitions.
//
//  Interfaces:
//      IClusCfgPartitionInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourcePhysicalDiskPartition
    : public IClusCfgPartitionInfo
{
private:

    LONG    m_cRef;         //  Reference counter

    CResourcePhysicalDiskPartition( void );
    ~CResourcePhysicalDiskPartition( void );

    // Private copy constructor to prevent copying.
    CResourcePhysicalDiskPartition( const CResourcePhysicalDiskPartition & nodeSrc );

    // Private assignment operator to prevent copying.
    const CResourcePhysicalDiskPartition & operator = ( const CResourcePhysicalDiskPartition & nodeSrc );

    HRESULT
        HrInit( void );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** punkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgPartitionInfo Interface
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );
    STDMETHOD( GetSize )( ULONG * pcMegaBytes );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );

}; //*** Class CResourcePhysicalDiskPartition
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldiskpartition.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDiskPartition.cpp
//
//  Description:
//      CResourcePhysicalDiskPartition implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CResourcePhysicalDiskPartition.h"
#include <ClusCfgPrivate.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CResourcePhysicalDiskPartition")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::S_HrCreateInitializedInstance
//
//  Description:
//      Create a CResourcePhysicalDiskPartition instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDiskPartition::S_HrCreateInstance(
    IUnknown **     ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    CResourcePhysicalDiskPartition *    prpdp = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    prpdp = new CResourcePhysicalDiskPartition;
    if ( prpdp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( prpdp->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( prpdp->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( prpdp != NULL )
    {
        prpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::S_HrCreateInitializedInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition
//
//  Description:
//      Constructor of the CResourcePhysicalDiskPartition class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition
//
//  Description:
//      Destructor of the CResourcePhysicalDiskPartition class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition

//
//
//
HRESULT
CResourcePhysicalDiskPartition::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDiskPartition -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgPartitionInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgPartitionInfo) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPartitionInfo, this, 0 );
    } // else if: IClusCfgPartitionInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CResourcePhysicalDiskPartition::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourcePhysicalDiskPartition::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CResourcePhysicalDiskPartition::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourcePhysicalDiskPartition::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CResourcePhysicalDiskPartition::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDiskPartition -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetDescription(
    BSTR * pbstrDescOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetSize
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetSize(
    ULONG * pcMegaBytes
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pcMegaBytes == NULL )
        goto InvalidPointer;

    *pcMegaBytes = 0;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CResourcePhysicalDiskPartition::GetSize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( pdlmDriveLetterUsageOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ZeroMemory( pdlmDriveLetterUsageOut, sizeof(*pdlmDriveLetterUsageOut) );

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetDriveLetterMappings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE = 1
#define _UNICODE = 1

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;


//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>
#include <ClusRtl.h>
#include <clusudef.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>

#include <loadstring.h>
#include <PropList.h>

#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

#include "ClusterUtils.h"

#include "W2KProxyStrings.h"
#include <StatusReports.h>
#include "W2KProxyServerGuids.h"

#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
//  Failure code.
//

#define SSR_W2KPROXY_STATUS( _major, _minor, _hr ) \
    {   \
        HRESULT hrTemp; \
        hrTemp = THR( SendStatusReport( NULL, _major, _minor, 0, 1, 1, _hr, NULL, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) ) \
        {   \
            _hr = hrTemp;   \
        }   \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#endif // DBG==1

#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\addnodeswizard.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      AddNodesWizard.h
//
//  Description:
//      Declaration of the CAddNodesWizard class.
//
//  Maintained By:
//      John Franco    (jfranco)    17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAddNodesWizard
//
//  Description:
//      The Cluster Add Nodes Wizard object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAddNodesWizard
    : public TDispatchHandler< IClusCfgAddNodesWizard >
{
private:

    CClusCfgWizard *    m_pccw;
    LONG                m_cRef;

    // Private constructors and destructors
    CAddNodesWizard( void );
    virtual ~CAddNodesWizard( void );
    virtual HRESULT HrInit( void );

    // Private copy constructor to prevent copying.
    CAddNodesWizard( const CAddNodesWizard & );

    // Private assignment operator to prevent copying.
    CAddNodesWizard & operator=( const CAddNodesWizard & );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, PVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgAddNodesWizard
    //
    STDMETHOD( put_ClusterName )( BSTR    bstrClusterNameIn );
    STDMETHOD( get_ClusterName )( BSTR * pbstrClusterNameOut );

    STDMETHOD( put_ServiceAccountPassword )( BSTR bstrPasswordIn );

    STDMETHOD( put_MinimumConfiguration )( VARIANT_BOOL   fMinConfigIn );
    STDMETHOD( get_MinimumConfiguration )( VARIANT_BOOL * pfMinConfigOut );

    STDMETHOD( AddNodeToList )( BSTR bstrNodeNameIn );
    STDMETHOD( RemoveNodeFromList )( BSTR bstrNodeNameIn );
    STDMETHOD( ClearNodeList )( void );

    STDMETHOD( ShowWizard )( long lParentWindowHandleIn, VARIANT_BOOL * pfCompletedOut );

}; //*** class CAddNodesWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\addnodeswizard.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      AddNodesWizard.cpp
//
//  Description:
//      Implementation of CAddNodesWizard class.
//
//  Maintained By:
//      John Franco    (jfranco)    17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "AddNodesWizard.h"

//****************************************************************************
//
//  CAddNodesWizard
//
//****************************************************************************

DEFINE_THISCLASS( "CAddNodesWizard" )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::S_HrCreateInstance
//
//  Description:
//      Creates a CAddNodesWizard instance.
//
//  Arguments:
//      ppunkOut        - The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Not enough memory to create the object.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesWizard::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CAddNodesWizard *   panw = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    panw = new CAddNodesWizard();
    if ( panw == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( panw->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( panw->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( panw != NULL )
    {
        panw->Release();
    }

    HRETURN( hr );

} //*** CAddNodesWizard::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::CAddNodesWizard
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAddNodesWizard::CAddNodesWizard( void )
    : m_pccw( NULL )
    , m_cRef( 1 )
{
} //*** CAddNodesWizard::CAddNodesWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::~CAddNodesWizard
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAddNodesWizard::~CAddNodesWizard( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }
    TraceFuncExit();

} //*** CAddNodesWizard::~CAddNodesWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::HrInit
//
//  Description:
//      Initialize the object instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesWizard::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    //
    // Initialize the IDispatch handler to support the scripting interface.
    //
    hr = THR( TDispatchHandler< IClusCfgAddNodesWizard >::HrInit( LIBID_ClusCfgWizard ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    // Create the wizard object.
    //
    hr = THR( CClusCfgWizard::S_HrCreateInstance( &m_pccw ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** HRESULT CAddNodesWizard::HrInit


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::QueryInterface(
      REFIID    riidIn
    , PVOID *   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgAddNodesWizard ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgAddNodesWizard, this, 0 );
    } // else if: IClusCfgAddNodesWizard
    else if (   IsEqualIID( riidIn, IID_IDispatch ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatch, this, 0 );
    } // else if: IDispatch
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CAddNodesWizard::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::AddRef
//
//  Description:
//      Add a reference to this instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CAddNodesWizard::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CAddNodesWizard::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::Release
//
//  Description:
//      Release a reference to this instance.  If it is the last reference
//      the object instance will be deallocated.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CAddNodesWizard::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        delete this;
    }

    CRETURN( cRef );

} //*** CAddNodesWizard::Release


//****************************************************************************
//
//  IClusCfgAddNodesWizard
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::put_ClusterName
//
//  Description:
//      Set the cluster name to add nodes to.  If this is not empty, the
//      page asking the user to enter the cluster name will not be displayed.
//
//  Arguments:
//      bstrClusterNameIn   - The name of the cluster.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::put_ClusterName( BSTR bstrClusterNameIn )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->put_ClusterName( bstrClusterNameIn ) );

    HRETURN( hr );

} //*** CAddNodesWizard::put_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::get_ClusterName
//
//  Description:
//      Return the name of the cluster to add nodes to.  This will be either
//      the cluster name specified in a call to put_ClusterName or one entered
//      by the user.
//
//  Arguments:
//      pbstrClusterNameOut - Cluster name used by the wizard.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::get_ClusterName( BSTR * pbstrClusterNameOut )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->get_ClusterName( pbstrClusterNameOut ) );

    HRETURN( hr );

} //*** CAddNodesWizard::get_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::put_ServiceAccountPassword
//
//  Description:
//      Set the cluster service account password.
//
//  Arguments:
//      bstrPasswordIn  - Cluster service account password.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::put_ServiceAccountPassword( BSTR bstrPasswordIn )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->put_ServiceAccountPassword( bstrPasswordIn ) );

    HRETURN( hr );

} //*** CAddNodesWizard::put_ServiceAccountPassword

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::put_MinimumConfiguration
//
//  Description:
//      Specify whether the wizard should operate in full or minimum
//      configuration mode.
//
//  Arguments:
//      fMinConfigIn
//          VARIANT_TRUE  - Put wizard in Minimum Configuration mode.
//          VARIANT_FALSE - Put wizard in Full Configuration mode.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::put_MinimumConfiguration( VARIANT_BOOL fMinConfigIn )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = S_OK;
    BOOL    fMinConfig = ( fMinConfigIn == VARIANT_TRUE? TRUE: FALSE );

    hr = THR( m_pccw->put_MinimumConfiguration( fMinConfig ) );

    HRETURN( hr );

} //*** CAddNodesWizard::put_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::get_MinimumConfiguration
//
//  Description:
//      Get the current configuration mode of the wizard.
//
//  Arguments:
//      pfMinConfigOut
//          Configuration mode of the wizard:
//              VARIANT_TRUE  - Minimum Configuration mode.
//              VARIANT_FALSE - Full Configuration mode.
//          This value could have been set either by a call to the
//          put_MinimumConfiguration method or by the user in the wizard.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::get_MinimumConfiguration( VARIANT_BOOL * pfMinConfigOut )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = S_OK;
    BOOL    fMinConfig = FALSE;

    if ( pfMinConfigOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    
    hr = THR( m_pccw->get_MinimumConfiguration( &fMinConfig ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pfMinConfigOut = ( fMinConfig? VARIANT_TRUE: VARIANT_FALSE );

Cleanup:

    HRETURN( hr );

} //*** CAddNodesWizard::put_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::AddNodeToList
//
//  Description:
//      Add a node to the list of nodes to be added to the cluster.
//
//  Arguments:
//      bstrNodeNameIn  - Node to be added to the cluster.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::AddNodeToList( BSTR bstrNodeNameIn )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->AddComputer( bstrNodeNameIn ) );

    HRETURN( hr );

} //*** CAddNodesWizard::AddNodeToList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::RemoveNodeFromList
//
//  Description:
//      Remove a node from the list of nodes to be added to the cluster.
//
//  Arguments:
//      bstrNodeNameIn  - Node to be removed from the list.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::RemoveNodeFromList( BSTR bstrNodeNameIn )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->RemoveComputer( bstrNodeNameIn ) );

    HRETURN( hr );

} //*** CAddNodesWizard::RemoveNodeFromList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::ClearNodeList
//
//  Description:
//      Remove all entries from the list of nodes to be added to the cluster.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::ClearNodeList( void )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = THR( m_pccw->ClearComputerList() );

    HRETURN( hr );

} //*** CAddNodesWizard::ClearNodeList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::ShowWizard
//
//  Description:
//      Show the wizard.
//
//  Arguments:
//      lParentWindowHandleIn
//          The parent window handle represented as a LONG value.
//
//      pfCompletedOut
//          Return status of the wizard operation itself:
//              VARIANT_TRUE    - Wizard was completed.
//              VARIANT_FALSE   - Wizard was cancelled.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAddNodesWizard::ShowWizard(
      long              lParentWindowHandleIn
    , VARIANT_BOOL *    pfCompletedOut
    )
{
    TraceFunc( "[IClusCfgAddNodesWizard]" );

    HRESULT hr = S_OK;
    BOOL    fCompleted = FALSE;
    HWND    hwndParent = reinterpret_cast< HWND >( LongToHandle( lParentWindowHandleIn ) );

    if ( ( hwndParent != NULL ) && ( IsWindow( hwndParent ) == FALSE ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( m_pccw->AddClusterNodes( hwndParent, &fCompleted ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( pfCompletedOut != NULL )
    {
        *pfCompletedOut = ( fCompleted? VARIANT_TRUE: VARIANT_FALSE );
    }
    
Cleanup:

    HRETURN( hr );

} //*** CAddNodesWizard::ShowWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\advanceddlg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      AdvancedDlg.h
//
//  Maintained By:
//      Galen Barbee    (GalenB)    10-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <clusudef.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAdvancedDlg
//
//  Description:
//      Display the advanced options dialog box.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAdvancedDlg
{
private:

    HWND                m_hwnd;             //  Our HWND
    CClusCfgWizard *    m_pccw;             //  Wizard

private:

    CAdvancedDlg( CClusCfgWizard * pccwIn );
    ~CAdvancedDlg( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

    LRESULT OnInitDialog( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrOnOK( void );

public:

    static HRESULT
        S_HrDisplayModalDialog(
              HWND                  hwndParentIn
            , CClusCfgWizard *      pccwIn
            );

}; //*** class CAdvancedDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include <ClusRtl.h>

DEFINE_MODULE( "W2KPROXYTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IClusCfgServer *    g_pccs      = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto CleanUp;

CleanUp:

    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    goto CleanUp;
}

//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestManagedResourceEnum( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    IEnumClusCfgManagedResources *  pesd    = NULL;
    ULONG                           cReceived = 0;
    IClusCfgManagedResourceInfo *   rgDevices[ 10 ];

    hr = g_pccs->GetManagedResourcesEnum( &pesd );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    while ( hr == S_OK )
    {
        hr = pesd->Next( sizeof( rgDevices ) / sizeof( rgDevices[ 0 ] ), &rgDevices[ 0 ], &cReceived );
        if ( FAILED( hr ) )
        {
            goto CleanUp;
        } // if:

        DebugMsg( "cReceived = %u", cReceived );

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            BSTR    bstr;

            THR( rgDevices[ idx ]->GetUID( &bstr ) );
            DebugMsg( "Device %u, UID = %ws", idx, bstr );
            SysFreeString( bstr );
            rgDevices[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

CleanUp:

    if ( pesd != NULL )
    {
        pesd->Release();
    }

    HRETURN( hr );

} //*** HrTestManagedResourceEnum()


//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestNetworksEnum( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IEnumClusCfgNetworks *  pens    = NULL;
    ULONG                   cReceived = 0;
    IClusCfgNetworkInfo *   rdNetworks[ 10 ];
    BSTR                    bstrUID;
    LPWSTR                  lpsz = NULL;
    ULONG                   ulDottedQuad;
    IClusCfgIPAddressInfo * piccipai = NULL;

    hr = g_pccs->GetNetworksEnum( &pens );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    while ( hr == S_OK )
    {
        hr = STHR( pens->Next( sizeof( rdNetworks ) / sizeof( rdNetworks[ 0 ] ), &rdNetworks[ 0 ], &cReceived ) );
        if ( FAILED( hr ) )
        {
            goto CleanUp;
        } // if:

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            hr = THR( rdNetworks[ idx ]->GetPrimaryNetworkAddress( &piccipai ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( piccipai->GetIPAddress( &ulDottedQuad ) );
                if ( SUCCEEDED( hr ) )
                {
                    DWORD   sc;

                    sc = ClRtlTcpipAddressToString( ulDottedQuad, &lpsz );
                    if ( sc == ERROR_SUCCESS )
                    {
                        LocalFree( lpsz );
                        lpsz = NULL;
                    } // if:
                } // if:

                piccipai->Release();
            } // if:

            hr = THR( rdNetworks[ idx ]->GetUID( &bstrUID ) );
            if ( SUCCEEDED( hr ) )
            {
                SysFreeString( bstrUID );
            } // if:

            rdNetworks[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

CleanUp:

    if ( pens != NULL )
    {
        pens->Release();
    }

    if ( lpsz != NULL )
    {
        LocalFree( lpsz );
    } // if:

    HRETURN( hr );

} //*** HrTestNetworksEnum()


//
//  This tests the node information
//
HRESULT
HrTestNodeInfo( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgNodeInfo *      pccni   = NULL;
    DWORD                   dwNodeHighestVersion;
    DWORD                   dwNodeLowestVersion;
    SDriveLetterMapping     dlmDriveLetterUsage;
    IClusCfgClusterInfo *   pccci = NULL;
    DWORD                   dwMajorVersion;
    DWORD                   dwMinorVersion;
    WORD                    wSuiteMask;
    BYTE                    bProductType;
    BSTR                    bstrCSDVersion = NULL;

    hr = g_pccs->GetClusterNodeInfo( &pccni );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetClusterVersion( &dwNodeHighestVersion, &dwNodeLowestVersion );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetOSVersion( &dwMajorVersion, &dwMinorVersion, &wSuiteMask, &bProductType, &bstrCSDVersion );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetDriveLetterMappings( &dlmDriveLetterUsage );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetClusterConfigInfo( &pccci );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

CleanUp:

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    SysFreeString( bstrCSDVersion );

    HRETURN( hr );

} //*** HrTestNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int _cdecl
main( void )
{
    HRESULT                     hr;
    BSTR                        bstrClusterName = NULL;
    IClusCfgInitialize *        pgcci = NULL;
    IClusCfgCapabilities *      piccc = NULL;
    IClusCfgClusterConnection * picccc = NULL;

    TraceInitializeProcess();

#if 0
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:
#endif

    bstrClusterName = TraceSysAllocString( L"GalenB-Clus.ntdev.microsoft.com" );
    if ( bstrClusterName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    //
    //  Start up the Cluster configuration server
    //

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( CoCreateInstance( CLSID_ConfigClusApi, NULL, CLSCTX_SERVER, TypeSafeParams( IClusCfgServer, &g_pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgInitialize, &pgcci ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pgcci->Initialize( NULL, GetUserDefaultLCID() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgCapabilities, &piccc ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( piccc->CanNodeBeClustered() );
    if ( FAILED( hr ) || ( hr == S_FALSE ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgClusterConnection, &picccc ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( picccc->OpenConnection( bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestManagedResourceEnum() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestNetworksEnum() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

CleanUp:

    TraceSysFreeString( bstrClusterName );

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( picccc != NULL )
    {
        picccc->Release();
    } // if:

    if ( pgcci != NULL )
    {
        pgcci->Release();
    } // if:

    if ( g_pccs != NULL )
    {
        g_pccs->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\analyzepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      AnalyzePage.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "AnalyzePage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CAnalyzePage");

//
//  Special CLSID_Type for completion cookie.
//
#include <initguid.h>

// {C4173DE0-BB94-4869-8C80-1AC2BE84610F}
DEFINE_GUID( CLSID_AnalyzeTaskCompletionCookieType,
0xc4173de0, 0xbb94, 0x4869, 0x8c, 0x80, 0x1a, 0xc2, 0xbe, 0x84, 0x61, 0xf);

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAnalyzePage::CAnalyzePage(
//      CClusCfgWizard *    pccwIn,
//      ECreateAddMode      ecamCreateAddModeIn,
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CAnalyzePage::CAnalyzePage(
      CClusCfgWizard *  pccwIn
    , ECreateAddMode    ecamCreateAddModeIn
    )
    : m_pccw( pccwIn )
{
    TraceFunc( "" );

    // m_hwnd
    Assert( pccwIn != NULL );
    m_pccw->AddRef();
    m_fNext               = FALSE;
    m_fAborted            = FALSE;
    m_ecamCreateAddMode   = ecamCreateAddModeIn;

    m_cRef = 0;

    m_cookieCompletion = 0;
    //  m_fTaskDone
    //  m_hrResult
    m_pttv             = NULL;
    m_bstrLogMsg       = NULL;
    m_ptac             = NULL;
    m_dwCookieCallback = 0;

    m_dwCookieNotify = 0;

    TraceFuncExit();

} //*** CAnalyzePage::CAnalyzePage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAnalyzePage::~CAnalyzePage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CAnalyzePage::~CAnalyzePage( void )
{
    TraceFunc( "" );

    //
    //  Cleanup our cookies.
    //

    THR( HrCleanupAnalysis() );

    //
    //  Now cleanup the object.
    //

    if ( m_pttv != NULL )
    {
        delete m_pttv;
    }

    TraceSysFreeString( m_bstrLogMsg );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    } // if:

    //
    //  Unregister to get UI notification (if needed)
    //

    THR( HrUnAdviseConnections() );

    if ( m_ptac != NULL )
    {
        m_ptac->Release();
    } // if:

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CAnalyzePage::~CAnalyzePage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // didn't set focus
    size_t  cNodes = 0;
    size_t  cInitialTickCount = 500;
    HRESULT hr = S_OK;

    //
    //  Get the node count to get a rough approximation of the initial tick count
    //  for the TaskTreeView.
    //
    hr = THR( m_pccw->HrGetNodeCount( &cNodes ) );
    if ( FAILED( hr ) )
    {
        cNodes = 1;
    }

    //  Numbers based on bulk-add testing.
    cInitialTickCount = 500 + ( 100 * cNodes );

    //
    //  Initialize the tree view
    //
    m_pttv = new CTaskTreeView( m_hwnd, IDC_ANALYZE_TV_TASKS, IDC_ANALYZE_PRG_STATUS, IDC_ANALYZE_S_STATUS, cInitialTickCount );
    if ( m_pttv == NULL )
    {
        goto OutOfMemory;
    }

    THR( m_pttv->HrOnInitDialog() );

Cleanup:
    RETURN( lr );

OutOfMemory:
    goto Cleanup;

} //*** CAnalyzePage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_ANALYZE_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_ANALYZE_PB_DETAILS:
            if ( idNotificationIn == BN_CLICKED )
            {
                Assert( m_pttv != NULL );
                THR( m_pttv->HrDisplayDetails() );
                lr = TRUE;
            }
            break;

        case IDC_ANALYZE_PB_REANALYZE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrCleanupAnalysis() );
                OnNotifySetActive();
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CAnalyzePage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAnalyzePage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAnalyzePage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    BOOL    fEnableCancel = TRUE;

    //
    //  Disable the back & next buttons if the task is not completed yet
    //

    if ( m_fTaskDone == FALSE )
    {
        dwFlags &= ~PSWIZB_BACK;
        dwFlags &= ~PSWIZB_NEXT;
        fEnableCancel = FALSE;
    } // if:

    // Disable the next button if an error occurred
    if ( FAILED( m_hrResult ) )
    {
        dwFlags &= ~PSWIZB_NEXT;
    } // if:

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    EnableWindow( GetDlgItem( m_hwnd, IDC_ANALYZE_PB_REANALYZE ), m_fTaskDone );
    EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), fEnableCancel );

    HRETURN( hr );

} //*** CAnalyzePage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LONG_PTR    lptrCancelState = FALSE;  // allow cancel

    if ( m_fTaskDone == FALSE )
    {
        lptrCancelState = TRUE;   // do not allow cancel
    } // if:
    else
    {
        int iRet;

        iRet = MessageBoxFromStrings( m_hwnd, IDS_QUERY_CANCEL_TITLE, IDS_QUERY_CANCEL_TEXT, MB_YESNO );
        if ( iRet == IDNO )
        {
            lptrCancelState = TRUE;   // do not allow cancel
        }
        else
        {
            THR( m_pccw->HrLaunchCleanupTask() );
            m_fAborted = TRUE;
        } // else:
    } // else:

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, lptrCancelState );

    RETURN( TRUE );     // this must return TRUE!

} //*** CAnalyzePage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_FALSE;
    LRESULT                     lr = TRUE;
    BSTR                        bstrDescription = NULL;
    IUnknown *                  punkTask = NULL;
    OBJECTCOOKIE                cookieCluster = 0;
    GUID *                      pTaskGUID = NULL;
    BOOL                        fMinConfig = FALSE;

    SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0, 0x80 ) );

    if ( m_fNext )
    {
        m_fNext = FALSE;

        hr = THR( HrUpdateWizardButtons() );
        goto Cleanup;
    }

    //
    //  Restore the instructions text.
    //

    m_hrResult = S_OK;

    m_fAborted = FALSE;
    LogMsg( L"[WIZ] Setting analyze page active.  Setting aborted to FALSE." );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ANALYSIS_STARTING_INSTRUCTIONS, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_ANALYZE_S_RESULTS, bstrDescription );

    //
    //  Clear the tree view and status line.
    //

    Assert( m_pttv != NULL );
    hr = THR( m_pttv->HrOnNotifySetActive() );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Add the major root task nodes.
    //

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER,
                                             TASKID_Major_Checking_For_Existing_Cluster
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_ESTABLISH_CONNECTION,
                                             TASKID_Major_Establish_Connection
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY,
                                             TASKID_Major_Check_Node_Feasibility
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_FIND_DEVICES,
                                             TASKID_Major_Find_Devices
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY,
                                             TASKID_Major_Check_Cluster_Feasibility
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( m_pccw->HrAdvise( IID_INotifyUI, static_cast< INotifyUI * >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pccw->HrAdvise( IID_IClusCfgCallback, static_cast< IClusCfgCallback * >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Find the cluster cookie.
    //

    // don't wrap - this can fail
    hr = m_pccw->HrGetClusterCookie( &cookieCluster );
    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    //
    //  Prime the middle tier by asking the object manager to find
    //  each node.
    //
    hr = STHR( m_pccw->HrCreateMiddleTierObjects() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a completion cookie.
    //

    if ( m_cookieCompletion == 0 )
    {
        // Don't wrap - this can fail with E_PENDING
        hr = m_pccw->HrGetCompletionCookie( CLSID_AnalyzeTaskCompletionCookieType, &m_cookieCompletion );
        if ( hr == E_PENDING )
        {
            // no-op.
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }
    }

    //
    //  Create a new analyze task.
    //

    //
    //  Check the state of the minimal config.  If is is not set then create the
    //  normal analyze cluster task.  If it is set then create the new minimal config
    //  analysis task.
    //

    hr = STHR( m_pccw->get_MinimumConfiguration( &fMinConfig ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( fMinConfig )
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeClusterMinConfig );
    } // if:
    else
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeCluster );
    } // else:

    hr = THR( m_pccw->HrCreateTask( *pTaskGUID, &punkTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkTask->TypeSafeQI( ITaskAnalyzeCluster, &m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptac->SetClusterCookie( cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptac->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( m_ecamCreateAddMode == camADDING )
    {
        hr = THR( m_ptac->SetJoiningMode() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else
    {
        Assert( m_ecamCreateAddMode == camCREATING );
    }

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = THR( m_pccw->HrSubmitTask( m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrUpdateWizardButtons() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punkTask != NULL )
    {
        punkTask->Release();
    }

    TraceSysFreeString( bstrDescription );

    RETURN( lr );

} //*** CAnalyzePage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    m_fNext = TRUE;

    RETURN( lr );

} //*** CAnalyzePage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyWizBack( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyWizBack( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    m_fAborted = TRUE;

    LogMsg( L"[WIZ] Back button pressed on the analyze page.  Setting aborted to TRUE." );

    THR( HrCleanupAnalysis() );

    RETURN( lr );

} //*** CAnalyzePage::OnNotifyWizBack

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::HrCleanupAnalysis( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAnalyzePage::HrCleanupAnalysis( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    CWaitCursor WaitCursor;

    if ( m_ptac != NULL )
    {
        LogMsg( L"[WIZ] Calling StopTask() on the analyze cluster task because we are cleaning up." );
        THR( m_ptac->StopTask() );
        m_ptac->Release();
        m_ptac = NULL;
    } // if:

    //
    //  Unregister to get UI notification (if needed)
    //

    hr = THR( HrUnAdviseConnections() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Cleanup our completion cookie.
    //

    if ( m_cookieCompletion != 0 )
    {
        hr = THR( m_pccw->HrReleaseCompletionObject( m_cookieCompletion ) );
        m_cookieCompletion = 0;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Remove the configuration because the user might change the
    //  name of the cluster or the user might be change the node
    //  membership, retrying analyze, etc... This makes sure that
    //  we start from scratch.
    //

    hr = THR( m_pccw->HrReleaseClusterObject() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }


Cleanup:

    RETURN( hr );

} //*** CAnalyzePage::HrCleanupAnalysis

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAnalyzePage::HrUnAdviseConnections(
//      void
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAnalyzePage::HrUnAdviseConnections(
    void
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( m_dwCookieNotify != 0 )
    {
        hr = THR( m_pccw->HrUnadvise( IID_INotifyUI, m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } //if:

        m_dwCookieNotify = 0;
    } //if:

    if ( m_dwCookieCallback != 0 )
    {
        hr = THR( m_pccw->HrUnadvise( IID_IClusCfgCallback, m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_dwCookieCallback = 0;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CAnalyzePage::HrUnAdviseConnections

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            lr = OnNotifyWizBack();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;

        default:
            if (    ( idCtrlIn == IDC_ANALYZE_TV_TASKS )
                &&  ( m_pttv != NULL ) )
            {
                // Pass the notification on to the tree control.
                lr = m_pttv->OnNotify( pnmhdrIn );
            }
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CAnalyzePage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CAnalyzePage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CAnalyzePage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CAnalyzePage * pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CAnalyzePage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CAnalyzePage * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CAnalyzePage::S_DlgProc


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAnalyzePage::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CAnalyzePage::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAnalyzePage::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAnalyzePage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CAnalyzePage::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAnalyzePage::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAnalyzePage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    CRETURN( cRef );

} //*** CAnalyzePage::Release


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAnalyzePage::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;

    if ( cookieIn == m_cookieCompletion )
    {
        hr = THR( m_pccw->HrGetCompletionStatus( m_cookieCompletion, &m_hrResult ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pttv->HrShowStatusAsDone() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_fTaskDone = TRUE;

        hr = THR( HrUpdateWizardButtons() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( SUCCEEDED( m_hrResult ) )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_ANALYSIS_SUCCESSFUL_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0x80, 0 ) );
        }
        else
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_ANALYSIS_FAILED_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );
        }

        SetDlgItemText( m_hwnd, IDC_ANALYZE_S_RESULTS, bstrDescription );

        hr = THR( m_pccw->HrUnadvise( IID_IClusCfgCallback, m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_dwCookieCallback = 0;
    }

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CAnalyzePage::ObjectChanged



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAnalyzePage::SendStatusReport(
//        LPCWSTR    pcszNodeNameIn
//      , CLSID      clsidTaskMajorIn
//      , CLSID      clsidTaskMinorIn
//      , ULONG      ulMinIn
//      , ULONG      ulMaxIn
//      , ULONG      ulCurrentIn
//      , HRESULT    hrStatusIn
//      , LPCWSTR    pcszDescriptionIn
//      , FILETIME * pftTimeIn
//      , LPCWSTR    pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( m_ptac != NULL );
    Assert( m_pttv != NULL );

    HRESULT hr;

    hr = THR( m_pttv->HrOnSendStatusReport(
                                          pcszNodeNameIn
                                        , clsidTaskMajorIn
                                        , clsidTaskMinorIn
                                        , ulMinIn
                                        , ulMaxIn
                                        , ulCurrentIn
                                        , hrStatusIn
                                        , pcszDescriptionIn
                                        , pftTimeIn
                                        , pcszReferenceIn
                                        ) );

    if ( m_fAborted )
    {
        LogMsg( L"[WIZ] Analyze page -- replacing (hr = %#08x) with E_ABORT", hr );
        hr = E_ABORT;
    } // if:

    //
    //  If the minor task ID is TASKID_Minor_Disconnecting_From_Server then we need to cancel the analysis
    //  task and set the cancel button, reanylze, and back are enbabled.
    //

    if ( IsEqualIID( clsidTaskMinorIn, TASKID_Minor_Disconnecting_From_Server ) )
    {
        THR( m_pttv->HrShowStatusAsDone() );
        SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );

        LogMsg( L"[WIZ] Calling StopTask() on the analyze cluster task because we were diconnected from the server." );
        THR( m_ptac->StopTask() );

        PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_BACK );

        EnableWindow( GetDlgItem( m_hwnd, IDC_ANALYZE_PB_REANALYZE ), TRUE );
        EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), TRUE );

        m_fTaskDone = TRUE;    // reset so that the cancel button will actually cancel...
    } // if:

    HRETURN( hr );

} //*** CAnalyzePage::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\analyzepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      AnalyzePage.h
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CAnalyzePage
    :   public INotifyUI
    ,   public IClusCfgCallback
{

private: // data
    HWND                    m_hwnd;                 // Our HWND
    CClusCfgWizard *        m_pccw;                 // Wizard
    BOOL                    m_fNext;                // If Next was pressed...
    BOOL                    m_fAborted;             // Back was pressed and we need to tell the servers to abort.
    ECreateAddMode          m_ecamCreateAddMode;    // Creating or adding?
    ITaskAnalyzeCluster *   m_ptac;

    //  IUnknown
    LONG                    m_cRef;                 // Reference count

    //  IClusCfgCallback
    OBJECTCOOKIE            m_cookieCompletion;     // Completion cookie
    BOOL                    m_fTaskDone;            // Is the task done yet?
    HRESULT                 m_hrResult;             // Result of the analyze task
    CTaskTreeView *         m_pttv;                 // Task TreeView
    BSTR                    m_bstrLogMsg;           // Reusable logging buffer.
    DWORD                   m_dwCookieCallback;     // Notification registration cookie

    //  INotifyUI
    DWORD                   m_dwCookieNotify;       // Notification registration cookie

private: // methods
    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifyWizBack( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrUpdateWizardButtons( void );
    HRESULT HrCleanupAnalysis( void );
    HRESULT HrUnAdviseConnections( void );

public: // methods
    CAnalyzePage(
          CClusCfgWizard *  pccwIn
        , ECreateAddMode    ecamCreateAddModeIn
        );
    ~CAnalyzePage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** class CAnalyzePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\clusdomainpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusDomainPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    21-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CClusDomainPage
    : public ITaskGetDomainsCallback
{

private: // data

    HWND                m_hwnd;             // Our HWND
    CClusCfgWizard *    m_pccw;             // Wizard
    ECreateAddMode      m_ecamCreateAddMode;// Creating? Adding?
    UINT                m_idsDesc;          // Resource ID for domain description string.
    BOOL                m_fDisplayPage;     // Indicates whether page should be displayed or not

    //  IUnknown
    LONG                m_cRef;
    ITaskGetDomains *   m_ptgd;             // Get Domains Task

private: // methods
    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    LRESULT
        OnUpdateWizardButtons( void );

public: // methods
    CClusDomainPage(
          CClusCfgWizard *      pccwIn
        , ECreateAddMode        ecamCreateAddModeIn
        , UINT                  idsDescIn
        );
    virtual ~CClusDomainPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  ITaskGetDomainsCallback
    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( LPCWSTR pcszDomainIn );

}; //*** class CClusDomainPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.cpp
//
//  Description:
//      Implementation of CClusCfgWizard class.
//
//  Maintained By:
//      David Potter        (DavidP)    14-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "AnalyzePage.h"
#include "ClusDomainPage.h"
#include "CommitPage.h"
#include "CompletionPage.h"
#include "CSAccountPage.h"
#include "IPAddressPage.h"
#include "SelNodePage.h"
#include "SelNodesPage.h"
#include "WelcomePage.h"
#include "SummaryPage.h"
#include <initguid.h>


//****************************************************************************
//
//  CClusCfgWizard
//
//****************************************************************************

DEFINE_THISCLASS( "CClusCfgWizard" )

// {AAA8DA17-62C8-40f6-BEC1-3F0326B73388}
DEFINE_GUID( CLSID_CancelCleanupTaskCompletionCookieType,
0xaaa8da17, 0x62c8, 0x40f6, 0xbe, 0xc1, 0x3f, 0x3, 0x26, 0xb7, 0x33, 0x88 );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgWizard instance.
//
//  Arguments:
//      ppccwOut
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::S_HrCreateInstance(
    CClusCfgWizard ** ppccwOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClusCfgWizard *    pccw = NULL;

    Assert( ppccwOut != NULL );
    if ( ppccwOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppccwOut = NULL;

    pccw = new CClusCfgWizard();
    if ( pccw == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pccw->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *ppccwOut = pccw;
    pccw = NULL;


Cleanup:

    if ( pccw != NULL )
    {
        pccw->Release();
    }

    HRETURN( hr );

} //*** CClusCfgWizard::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::CClusCfgWizard
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgWizard::CClusCfgWizard( void )
    : m_cRef( 1 )
    , m_pccc( NULL )
    , m_psp( NULL )
    , m_pcpc( NULL )
    , m_pom( NULL )
    , m_ptm( NULL )
    , m_bstrClusterDomain( NULL )
    , m_fDefaultedDomain( TRUE )
    , m_dwCookieNotify( 0 )
    , m_hCancelCleanupEvent( NULL )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusCfgWizard::CClusCfgWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::~CClusCfgWizard
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgWizard::~CClusCfgWizard( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrNetworkName );
    TraceSysFreeString( m_bstrClusterDomain );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    } // if:

    if ( m_pcpc != NULL )
    {
        m_pcpc->Release();
    } // if:

    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    } // if:

    if ( m_pom != NULL )
    {
        m_pom->Release();
    } // if:

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    } // if:

    if ( m_hRichEdit != NULL )
    {
        FreeLibrary( m_hRichEdit );
    } // if:

    if ( m_hCancelCleanupEvent != NULL )
    {
        CloseHandle( m_hCancelCleanupEvent );
    } // if:

    TraceFuncExit();

} // ~CClusCfgWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrInit
//
//  Description:
//      Initialize a CClusCfgWizard instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrInit( void )
{
    HRESULT hr = S_OK;

    TraceFunc( "" );

    INITCOMMONCONTROLSEX    icex;
    BOOL                    bRet;
//    EConfigurationSettings  ecsConfigType = csFullConfig;

    // IUnknown
    Assert( m_cRef == 1 );

    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_bstrNetworkName == NULL );
    Assert( m_psp == NULL );
    Assert( m_pcpc == NULL );
    Assert( m_pom == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pccc == NULL );
    Assert( m_cookieCompletion == 0 );
    Assert( m_fMinimalConfig == FALSE );

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_INTERNET_CLASSES
                | ICC_PROGRESS_CLASS
                | ICC_TREEVIEW_CLASSES
                | ICC_LISTVIEW_CLASSES;
    bRet = InitCommonControlsEx( &icex );
    Assert( bRet != FALSE );

    hr = THR( CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IServiceProvider
                    , reinterpret_cast< void ** >( &m_psp )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &m_ptm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &m_pcpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ClusCfgCredentials
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IClusCfgCredentials
                    , reinterpret_cast< void ** >( &m_pccc )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Initialize the RichEdit controls.
    //

    m_hRichEdit = LoadLibrary( L"RichEd32.Dll" );
    if ( m_hRichEdit == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    m_hCancelCleanupEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hCancelCleanupEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

//    STHR( HrReadSettings( &ecsConfigType ) );

//    m_fMinimalConfig = ( ecsConfigType == csMinConfig );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrInit


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::QueryInterface(
      REFIID    riidIn
    , PVOID *   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgWizard::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::AddRef
//
//  Description:
//      Add a reference to this instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgWizard::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgWizard::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::Release
//
//  Description:
//      Release a reference to this instance.  If it is the last reference
//      the object instance will be deallocated.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgWizard::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        delete this;
    }

    CRETURN( cRef );

} //*** CClusCfgWizard::Release


//****************************************************************************
//
//  IClusCfgWizard
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::CreateCluster
//
//  Description:
//
//  Arguments:
//      ParentWnd
//      pfDone
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::CreateCluster(
    HWND    lParentWndIn,
    BOOL *  pfDoneOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HPROPSHEETPAGE      rPages[ 9 ];
    PROPSHEETHEADER     pshead;
    BOOL                fSuccess;
    INT_PTR             ipStatus;
    HRESULT             hr = S_OK;
    ILogManager *       plm = NULL;
    TraceFlow1( "[Clcfgsrv] - CClusCfgWizard::CreateCluster - Thread id %d", GetCurrentThreadId() );

    CWelcomePage        dlgWelcomePage( this, camCREATING );
    CClusDomainPage     dlgClusDomainPage(  this, camCREATING, IDS_DOMAIN_DESC_CREATE );
    CSelNodePage        dlgSelNodePage( this );
    CAnalyzePage        dlgAnalyzePage( this, camCREATING );
    CIPAddressPage      dlgIPAddressPage(  this, camCREATING, &m_ulIPAddress, &m_ulIPSubnet, &m_bstrNetworkName );
    CCSAccountPage      dlgCSAccountPage( this, camCREATING, m_pccc );
    CSummaryPage        dlgSummaryPage( this, camCREATING, IDS_SUMMARY_NEXT_CREATE );
    CCommitPage         dlgCommitPage( this, camCREATING );
    CCompletionPage     dlgCompletionPage( IDS_COMPLETION_TITLE_CREATE, IDS_COMPLETION_DESC_CREATE );

    //
    //  TODO:   gpease  14-MAY-2000
    //          Do we really need this?
    //
    if ( pfDoneOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Start the logger.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_LogManager,
                                 ILogManager,
                                 &plm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( plm->StartLogging() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( HrAdvise( IID_INotifyUI, static_cast< INotifyUI * >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    //
    //  Create the Wizard.
    //
    ZeroMemory( &pshead, sizeof( pshead ) );
    pshead.dwSize           = sizeof( pshead );
    pshead.dwFlags          = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance        = g_hInstance;
    pshead.pszCaption       = MAKEINTRESOURCE( IDS_TITLE_FORM );
    pshead.phpage           = rPages;
    pshead.pszbmWatermark   = MAKEINTRESOURCE( IDB_WATERMARK );
    pshead.pszbmHeader      = MAKEINTRESOURCE( IDB_BANNER );
    pshead.hwndParent       = lParentWndIn;

    THR( HrAddWizardPage( &pshead, IDD_WELCOME_CREATE,  CWelcomePage::S_DlgProc,        0,                      0,                      (LPARAM) &dlgWelcomePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CLUSDOMAIN,      CClusDomainPage::S_DlgProc,     IDS_TCLUSTER,           IDS_STCLUSTER_CREATE,   (LPARAM) &dlgClusDomainPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SELNODE,         CSelNodePage::S_DlgProc,        IDS_TSELNODE,           IDS_STSELNODE,          (LPARAM) &dlgSelNodePage ) );
    THR( HrAddWizardPage( &pshead, IDD_ANALYZE,         CAnalyzePage::S_DlgProc,        IDS_TANALYZE,           IDS_STANALYZE,          (LPARAM) &dlgAnalyzePage ) );
    THR( HrAddWizardPage( &pshead, IDD_IPADDRESS,       CIPAddressPage::S_DlgProc,      IDS_TIPADDRESS,         IDS_STIPADDRESS,        (LPARAM) &dlgIPAddressPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CSACCOUNT,       CCSAccountPage::S_DlgProc,      IDS_TCSACCOUNT,         IDS_STCSACCOUNT,        (LPARAM) &dlgCSAccountPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SUMMARY,         CSummaryPage::S_DlgProc,        IDS_TSUMMARY,           IDS_STSUMMARY_CREATE,   (LPARAM) &dlgSummaryPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMMIT,          CCommitPage::S_DlgProc,         IDS_TCOMMIT_CREATE,     IDS_STCOMMIT,           (LPARAM) &dlgCommitPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMPLETION,      CCompletionPage::S_DlgProc,     0,                      0,                      (LPARAM) &dlgCompletionPage ) );

    AssertMsg( pshead.nPages == ARRAYSIZE( rPages ), "Not enough or too many PROPSHEETPAGEs." );

    ipStatus = PropertySheet( &pshead );
    if ( ipStatus == -1 )
    {
        TW32( GetLastError() );
    }
    fSuccess = ipStatus != NULL;
    if ( pfDoneOut != NULL )
    {
        *pfDoneOut = fSuccess;
    }

Cleanup:

    if ( plm != NULL )
    {
        THR( plm->StopLogging() );
        plm->Release();
    } // if:

    if ( m_dwCookieNotify != 0 )
    {
        THR( HrUnadvise( IID_INotifyUI, m_dwCookieNotify ) );
        m_dwCookieNotify = 0;
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::CreateCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::AddClusterNodes
//
//  Description:
//      Launch the Cluster Wizard in Add Cluster Nodes mode.
//
//  Parameters
//      ParentWnd           - Handle to the parent window (default NULL).
//                          If not NULL, the wizard will be positionned
//                          in the center of this window.
//      Done                - return TRUE if committed, FALSE if cancelled.
//
//  Return Values:
//      S_OK                - The call succeeded.
//      other HRESULTs      - The call failed.
//      E_POINTER
//      E_OUTOFMEMORY
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::AddClusterNodes(
    HWND    lParentWndIn,
    BOOL *  pfDoneOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HPROPSHEETPAGE  rPages[ 8 ];
    PROPSHEETHEADER pshead;

    BOOL            fSuccess;
    INT_PTR         ipStatus;

    HRESULT         hr = S_OK;

    ILogManager *   plm = NULL;

    CWelcomePage        dlgWelcomePage( this, camADDING );
    CClusDomainPage     dlgClusDomainPage( this, camADDING, IDS_DOMAIN_DESC_ADD );
    CSelNodesPage       dlgSelNodesPage( this );
    CAnalyzePage        dlgAnalyzePage( this, camADDING );
    CCSAccountPage      dlgCSAccountPage( this, camADDING,   m_pccc );
    CSummaryPage        dlgSummaryPage( this, camADDING, IDS_SUMMARY_NEXT_ADD );
    CCommitPage         dlgCommitPage( this, camADDING );
    CCompletionPage     dlgCompletionPage( IDS_COMPLETION_TITLE_ADD, IDS_COMPLETION_DESC_ADD );

    //
    //  TODO:   gpease  12-JUL-2000
    //          Do we really need this? Or can we have the script implement an event
    //          sink that we signal?
    //
    if ( pfDoneOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Start the logger.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_LogManager,
                                 ILogManager,
                                 &plm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( plm->StartLogging() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( HrAdvise( IID_INotifyUI, static_cast< INotifyUI * >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    //
    //  Create the Wizard.
    //
    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize           = sizeof(pshead);
    pshead.dwFlags          = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance        = g_hInstance;
    pshead.pszCaption       = MAKEINTRESOURCE( IDS_TITLE_JOIN );
    pshead.phpage           = rPages;
    pshead.pszbmWatermark   = MAKEINTRESOURCE( IDB_WATERMARK );
    pshead.pszbmHeader      = MAKEINTRESOURCE( IDB_BANNER );
    pshead.hwndParent       = lParentWndIn;

    THR( HrAddWizardPage( &pshead, IDD_WELCOME_ADD,     CWelcomePage::S_DlgProc,        0,                      0,                      (LPARAM) &dlgWelcomePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CLUSDOMAIN,      CClusDomainPage::S_DlgProc,     IDS_TCLUSTER,           IDS_STCLUSTER_ADD,      (LPARAM) &dlgClusDomainPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SELNODES,        CSelNodesPage::S_DlgProc,       IDS_TSELNODES,          IDS_STSELNODES,         (LPARAM) &dlgSelNodesPage ) );
    THR( HrAddWizardPage( &pshead, IDD_ANALYZE,         CAnalyzePage::S_DlgProc,        IDS_TANALYZE,           IDS_STANALYZE,          (LPARAM) &dlgAnalyzePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CSACCOUNT,       CCSAccountPage::S_DlgProc,      IDS_TCSACCOUNT,         IDS_STCSACCOUNT,        (LPARAM) &dlgCSAccountPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SUMMARY,         CSummaryPage::S_DlgProc,        IDS_TSUMMARY,           IDS_STSUMMARY_ADD,      (LPARAM) &dlgSummaryPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMMIT,          CCommitPage::S_DlgProc,         IDS_TCOMMIT_ADD,        IDS_STCOMMIT,           (LPARAM) &dlgCommitPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMPLETION,      CCompletionPage::S_DlgProc,     0,                      0,                      (LPARAM) &dlgCompletionPage ) );

    AssertMsg( pshead.nPages == ARRAYSIZE( rPages ), "Not enough or too many PROPSHEETPAGEs." );

    ipStatus = PropertySheet( &pshead );
    fSuccess = ipStatus != NULL;
    if ( pfDoneOut != NULL )
    {
        *pfDoneOut = fSuccess;
    }

Cleanup:

    if ( plm != NULL )
    {
        THR( plm->StopLogging() );
        plm->Release();
    } // if:

    if ( m_dwCookieNotify != 0 )
    {
        THR( HrUnadvise( IID_INotifyUI, m_dwCookieNotify ) );
        m_dwCookieNotify = 0;
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::AddClusterNodes

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ClusterName
//
//  Description:
//
//  Arguments:
//      pbstrNameOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterName(
    BSTR * pbstrNameOut
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "[IClusCfgWizard]" );

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_ncCluster.bstrName == NULL )
    {
        hr = S_FALSE;
        *pbstrNameOut = NULL;
        goto Cleanup;
    }

    //  Return either an IP address or an FQDN.
    hr = STHR( HrIsValidFQN( m_ncCluster.bstrName, true ) );
    if ( hr == S_OK ) // Name is fully-qualified.
    {
        HRESULT hrFQIPTest = STHR( HrFQNIsFQIP( m_ncCluster.bstrName ) );
        if ( hrFQIPTest == S_OK ) // Name is an FQIP.
        {
            //  If the name is an FQIP, return just the IP address.
            hr = HrExtractPrefixFromFQN( m_ncCluster.bstrName, pbstrNameOut );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            TraceMemoryDelete( *pbstrNameOut, false ); // Prevent false reports of memory leaks.
        } // If name is FQIP.
        else if ( hrFQIPTest == S_FALSE ) // Name is an FQDN.
        {
            //  Otherwise, the name is an FQDN, so return the whole thing.
            *pbstrNameOut = SysAllocString( m_ncCluster.bstrName );
            if ( *pbstrNameOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        } // If name is FQDN.
        else if ( FAILED( hrFQIPTest ) )
        {
            hr = hrFQIPTest;
            goto Cleanup;
        }
    } // If name is fully-qualified.
    else if ( hr == S_FALSE ) // Name is not fully-qualified.
    {
        HRESULT hrIPTest = STHR( HrIsValidIPAddress( m_ncCluster.bstrName ) );
        if ( hrIPTest == S_OK )
        {
            //  If the name is an IP address, return it.
            *pbstrNameOut = SysAllocString( m_ncCluster.bstrName );
            if ( *pbstrNameOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        } // If name is an IP address.
        else if ( hrIPTest == S_FALSE ) // Name is hostname label.
        {
            //  Otherwise, append the cluster domain and return the result.
            hr = THR( HrMakeFQN( m_ncCluster.bstrName, m_bstrClusterDomain, true, pbstrNameOut ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            TraceMemoryDelete( *pbstrNameOut, false ); // Prevent false reports of memory leaks.
        } // If name is hostname label.
        else if ( FAILED( hrIPTest ) )
        {
            hr = hrIPTest;
            goto Cleanup;
        }
    } // If name is not fully-qualified.
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::get_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ClusterName
//
//  Description:
//
//  Arguments:
//      bstrNameIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterName(
    BSTR bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNameIn = %'ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( HrSetClusterName( bstrNameIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ServiceAccountUserName
//
//  Description:
//
//  Arguments:
//      pbstrNameOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ServiceAccountUserName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    BSTR    bstrDomain = NULL;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_pccc->GetIdentity( pbstrNameOut, &bstrDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    if ( SysStringLen( *pbstrNameOut ) == 0 )
    {
        hr = S_FALSE;
    }

Cleanup:

    SysFreeString( bstrDomain );

    HRETURN( hr );

} //*** CClusCfgWizard::get_ServiceAccountUserName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ServiceAccountUserName
//
//  Description:
//
//  Arguments:
//      bstrNameIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountUserName(
    BSTR bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    hr = THR( m_pccc->SetCredentials( bstrNameIn, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ServiceAccountUserName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ServiceAccountPassword
//
//  Description:
//
//  Arguments:
//      bstrPasswordIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountPassword(
    BSTR bstrPasswordIn
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    hr = THR( m_pccc->SetCredentials( NULL, NULL, bstrPasswordIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ServiceAccountPassword

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ServiceAccountDomainName
//
//  Description:
//
//  Arguments:
//      pbstrDomainOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ServiceAccountDomainName(
    BSTR * pbstrDomainOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if ( pbstrDomainOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_pccc->GetIdentity( &bstrName, pbstrDomainOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    if ( SysStringLen( *pbstrDomainOut ) == 0 )
    {
        hr = S_FALSE;
    }

Cleanup:

    SysFreeString( bstrName );

    HRETURN( hr );

} //*** CClusCfgWizard::get_ServiceAccountDomainName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ServiceAccountDomainName
//
//  Description:
//
//  Arguments:
//      bstrDomainIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountDomainName(
    BSTR bstrDomainIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrDomainIn = '%ls'", bstrDomainIn == NULL ? L"<null>" : bstrDomainIn );

    HRESULT hr = S_OK;

    hr = THR( m_pccc->SetCredentials( NULL, bstrDomainIn, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ServiceAccountDomainName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ClusterIPAddress
//
//  Description:
//
//  Arguments:
//      pbstrIPAddressOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPAddress(
    BSTR * pbstrIPAddressOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    DWORD   dwStatus;
    LPWSTR  pwszIPAddress = NULL;

    if ( pbstrIPAddressOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_ulIPAddress == 0 )
    {
        hr = S_FALSE;
        *pbstrIPAddressOut = NULL;
        goto Cleanup;
    }

    dwStatus = TW32( ClRtlTcpipAddressToString( m_ulIPAddress, &pwszIPAddress ) );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

    *pbstrIPAddressOut = SysAllocString( pwszIPAddress );
    if ( *pbstrIPAddressOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    if ( pwszIPAddress != NULL )
    {
        LocalFree( pwszIPAddress );
    }

    HRETURN( hr );

} //*** CClusCfgWizard::get_ClusterIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ClusterIPAddress
//
//  Description:
//
//  Arguments:
//      bstrIPAddressIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPAddress(
    BSTR bstrIPAddressIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrIPAddressIn = '%ls'", bstrIPAddressIn == NULL ? L"<null>" : bstrIPAddressIn );

    HRESULT hr = S_OK;
    DWORD   dwStatus;

    if ( bstrIPAddressIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    dwStatus = TW32( ClRtlTcpipStringToAddress( bstrIPAddressIn, &m_ulIPAddress ) );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ClusterIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ClusterIPSubnet
//
//  Description:
//
//  Arguments:
//      pbstrIPSubnetOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPSubnet(
    BSTR * pbstrIPSubnetOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  pwszIPSubnet = NULL;

    if ( pbstrIPSubnetOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrIPSubnetOut = NULL;

    if ( m_ulIPSubnet == 0 )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    dwStatus = TW32( ClRtlTcpipAddressToString( m_ulIPSubnet, &pwszIPSubnet ) );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

    *pbstrIPSubnetOut = SysAllocString( pwszIPSubnet );
    if ( *pbstrIPSubnetOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    if ( pwszIPSubnet != NULL )
    {
        LocalFree( pwszIPSubnet );
    }

    HRETURN( hr );

} //*** CClusCfgWizard::get_ClusterIPSubnet

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ClusterIPSubnet
//
//  Description:
//
//  Arguments:
//      bstrSubnetMaskIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPSubnet(
    BSTR bstrIPSubnetIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrIPSubnetIn = '%ls'", bstrIPSubnetIn );

    HRESULT hr = S_OK;
    DWORD   dwStatus;

    if ( bstrIPSubnetIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    dwStatus = TW32( ClRtlTcpipStringToAddress( bstrIPSubnetIn, &m_ulIPSubnet ) );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ClusterIPSubnet

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_ClusterIPAddressNetwork
//
//  Description:
//
//  Arguments:
//      pbstrNetworkNameOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPAddressNetwork(
    BSTR * pbstrNetworkNameOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    if ( pbstrNetworkNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrNetworkNameOut = NULL;

    if ( m_bstrNetworkName == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    *pbstrNetworkNameOut = SysAllocString( m_bstrNetworkName );
    if ( *pbstrNetworkNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::get_ClusterIPAddressNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_ClusterIPAddressNetwork
//
//  Description:
//
//  Arguments:
//      bstrNetworkNameIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPAddressNetwork(
    BSTR bstrNetworkNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNetworkNameIn = '%ls'", bstrNetworkNameIn == NULL ? L"<null>" : bstrNetworkNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewNetworkName;

    if ( bstrNetworkNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewNetworkName = TraceSysAllocString( bstrNetworkNameIn );
    if ( bstrNewNetworkName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    if ( m_bstrNetworkName != NULL )
    {
        TraceSysFreeString( m_bstrNetworkName );
    }

    m_bstrNetworkName = bstrNewNetworkName;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::put_ClusterIPAddressNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::get_MinimumConfiguration
//
//  Description:
//
//  Arguments:
//      pfMinimumConfigurationOut
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_MinimumConfiguration(
    BOOL * pfMinimumConfigurationOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( pfMinimumConfigurationOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pfMinimumConfigurationOut = m_fMinimalConfig;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::get_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::put_MinimumConfiguration
//
//  Description:
//
//  Arguments:
//      fMinimumConfigurationIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_MinimumConfiguration(
    BOOL fMinimumConfigurationIn
    )
{
    TraceFunc1( "[IClusCfgWizard] fMinimalConfigurationIn = '%ls'", fMinimumConfigurationIn ? L"TRUE" : L"FALSE" );

    HRESULT hr = S_OK;

    m_fMinimalConfig = fMinimumConfigurationIn;

    HRETURN( hr );

} //*** CClusCfgWizard::put_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::AddComputer
//
//  Description:
//
//  Arguments:
//      bstrNameIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::AddComputer(
    BSTR    bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] pcszNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;
    if ( bstrNameIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( HrAddNode( bstrNameIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::AddComputer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::RemoveComputer
//
//  Description:
//
//  Arguments:
//      pcszNameIn
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::RemoveComputer(
    BSTR bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] pcszNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_FALSE;

    NamedCookieArray::Iterator itNode = m_ncaNodes.ItBegin();

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Look for a node that has the same name.
    while ( ( itNode != m_ncaNodes.ItEnd() ) && ( NBSTRCompareNoCase( ( *itNode ).bstrName, bstrNameIn ) != 0 ) )
    {
        ++itNode;
    }

    //  If a node with the same name exists, remove it.
    if ( itNode != m_ncaNodes.ItEnd() )
    {
        if ( ( *itNode ).FHasCookie() )
        {
            THR( m_pom->RemoveObject( ( *itNode ).ocObject ) );
        }
        hr = THR( m_ncaNodes.HrRemove( itNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else // No node has the same name.
    {
        hr = S_FALSE;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::RemoveComputer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::ClearComputerList
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::ClearComputerList( void )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    hr = THR( HrReleaseNodeObjects() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_ncaNodes.Clear();

Cleanup:

    HRETURN( hr );
} //*** CClusCfgWizard::ClearComputerList



//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrAddWizardPage
//
//  Description:
//      Fills in the PROPSHEETPAGE structure, create the page and adds it to
//      the wizard's PROPSHEETHEADER.
//
//  Arguments:
//      ppshInout
//          LPPROPSHEETHEADER structure to add page to.
//
//      idTemplateIn
//          The dialog template ID of the page.
//
//      pfnDlgProcIn
//          The dialog proc for the page.
//
//      idCaptionIn
//          The page's caption.
//
//      idTitleIn
//          The page's title.
//
//      idSubtitleIn
//          The page's sub-title.
//
//      lParam
//          The lParam to be put into the PROPSHEETPAGE stucture's lParam.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrAddWizardPage(
    LPPROPSHEETHEADER   ppshInout,
    UINT                idTemplateIn,
    DLGPROC             pfnDlgProcIn,
    UINT                idTitleIn,
    UINT                idSubtitleIn,
    LPARAM              lParam
    )
{
    TraceFunc( "" );

    PROPSHEETPAGE psp;

    TCHAR szTitle[ 256 ];
    TCHAR szSubTitle[ 256 ];

    ZeroMemory( &psp, sizeof(psp) );

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USETITLE;
    psp.pszTitle    = ppshInout->pszCaption;
    psp.hInstance   = ppshInout->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE( idTemplateIn );
    psp.pfnDlgProc  = pfnDlgProcIn;
    psp.lParam      = lParam;

    if (    ( idTemplateIn == IDD_WELCOME_CREATE )
        ||  ( idTemplateIn == IDD_WELCOME_ADD )
        ||  ( idTemplateIn == IDD_COMPLETION )
       )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        if ( idTitleIn != 0 )
        {
            DWORD dw;
            dw = LoadString( g_hInstance, idTitleIn, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
            psp.dwFlags |= PSP_USEHEADERTITLE;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitleIn != 0 )
        {
            DWORD dw;
            dw = LoadString( g_hInstance, idSubtitleIn, szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
            psp.dwFlags |= PSP_USEHEADERSUBTITLE;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }

    ppshInout->phpage[ ppshInout->nPages ] = CreatePropertySheetPage( &psp );
    Assert( ppshInout->phpage[ ppshInout->nPages ] != NULL );
    if ( ppshInout->phpage[ ppshInout->nPages ] != NULL )
    {
        ppshInout->nPages++;
    }

    HRETURN( S_OK );

} //*** CClusCfgWizard::HrAddWizardPage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrIsCompatibleNodeDomain
//
//  Description:
//      Determine whether the domain of a node being added to the cluster
//      matches that already established for the cluster.
//
//  Arguments:
//      pcwszDomainIn   - The domain of the proposed node.
//
//  Return Values:
//      S_OK
//          Either the domain matches, or the cluster is empty.
//
//      S_FALSE
//          The domain does not match the cluster's.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrIsCompatibleNodeDomain(
    LPCWSTR pcwszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT hr  = S_OK;

    if ( ( m_bstrClusterDomain != NULL ) && ( ClRtlStrICmp( pcwszDomainIn, m_bstrClusterDomain ) != 0 ) )
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CClusCfgWizard::HrIsCompatibleNodeDomain



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLaunchCleanupTask
//
//  Description:
//      When the wizard has been canceled after analysis has completed
//      the cancel cleanup task needs to be run to ensure that all
//      cleanup has occured.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success
//
//      HRESULT errors
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrLaunchCleanupTask( void )
{
    TraceFunc( "" );
    Assert( m_cookieCompletion == 0 );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    ITaskCancelCleanup *    ptcc = NULL;
    OBJECTCOOKIE            cookieCluster;
    ULONG                   ulCurrent;
    DWORD                   sc;

    hr = HrGetCompletionCookie( CLSID_CancelCleanupTaskCompletionCookieType, &m_cookieCompletion );
    if ( hr == E_PENDING )
    {
        // no-op.
    } // if:
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // else if:

    hr = THR( HrCreateTask( TASK_CancelCleanup, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( ITaskCancelCleanup, &ptcc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterCookie( &cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( ptcc->SetCompletionCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSubmitTask( ptcc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Wait for task to complete.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; ( sc != WAIT_OBJECT_0 )
        ; ulCurrent++
        )
    {
        MSG msg;

        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        } // while:

        sc = MsgWaitForMultipleObjectsEx(
                  1
                , &m_hCancelCleanupEvent
                , INFINITE
                , QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE
                , 0
                );
    } // while: sc == WAIT_OBJECT_0

Cleanup:

    if ( m_cookieCompletion != 0 )
    {
        THR( HrReleaseCompletionObject( m_cookieCompletion ) );
        m_cookieCompletion = 0;
    } // if:

    if ( ptcc != NULL )
    {
        ptcc->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::HrLaunchCleanupTask


//****************************************************************************
//
//  Non-COM public methods: cluster access
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrSetClusterName
//
//  Description:
//      Sets the cluster name, overwriting any current name.
//
//  Arguments:
//      pwcszClusterNameIn      - The new cluster name.
//      fAcceptNonRFCCharsIn    - Allow the name to contain non-RFC chars.
//
//  Return Values:
//      S_OK
//          Changing the cluster name succeeded.
//
//      S_FALSE
//          The cluster already has this name.
//
//      Other errors
//          Something went wrong, and the cluster's name hasn't changed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrSetClusterName(
      LPCWSTR   pwcszClusterNameIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    BSTR    bstrClusterFQN = NULL;
    BSTR    bstrClusterDisplay = NULL;
    BSTR    bstrClusterDomain = NULL;

    Assert( pwcszClusterNameIn != NULL );
    if ( pwcszClusterNameIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Determine whether the caller is providing a fully-qualified name,
    //  and remember the result, so that the cluster name and domain page knows
    //  whether to obtain the domain from the user.
    //
    hr = STHR( HrIsValidFQN( pwcszClusterNameIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_fDefaultedDomain = ( hr == S_FALSE );

    //  Make corresponding FQName.
    hr = THR( HrMakeFQN(
                  pwcszClusterNameIn
                , NULL // Default to local machine's domain.
                , fAcceptNonRFCCharsIn
                , &bstrClusterFQN
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Get domain name from FQName.
    {
        size_t  idxClusterDomain = 0;
        hr = THR( HrFindDomainInFQN( bstrClusterFQN, &idxClusterDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        bstrClusterDomain = TraceSysAllocString( ( bstrClusterFQN + idxClusterDomain ) );
        if ( bstrClusterDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    //  If bstrClusterFQN is an FQIP,
    hr = STHR( HrFQNIsFQIP( bstrClusterFQN ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_OK ) //   set display name to IP address;
    {
        hr = THR( HrExtractPrefixFromFQN( bstrClusterFQN, &bstrClusterDisplay ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else // otherwise, set display name to pwcszClusterNameIn.
    {
        hr = S_OK;
        bstrClusterDisplay = TraceSysAllocString( pwcszClusterNameIn );
        if ( bstrClusterDisplay == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    //  If already have a cluster name,
    if ( FHasClusterName() )
    {
        //  if names are equal, bail out with S_FALSE;
        if ( ( NBSTRCompareNoCase( m_ncCluster.bstrName, bstrClusterDisplay ) == 0 )
            && ( NBSTRCompareNoCase( m_bstrClusterDomain, bstrClusterDomain ) == 0 ) )
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        else //  otherwise, dump current cluster.
        {
            hr = THR( HrReleaseClusterObject() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            m_ncCluster.Erase();
            TraceSysFreeString( m_bstrClusterDomain );
            m_bstrClusterDomain = NULL;
        }
    }

    //  Set cluster names.
    m_bstrClusterDomain = bstrClusterDomain;
    bstrClusterDomain = NULL;
    m_ncCluster.bstrName = bstrClusterDisplay;
    bstrClusterDisplay = NULL;

Cleanup:

    TraceSysFreeString( bstrClusterFQN );
    TraceSysFreeString( bstrClusterDisplay );
    TraceSysFreeString( bstrClusterDomain );

    HRETURN( hr );

} //*** CClusCfgWizard::HrSetClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetClusterDomain
//
//  Description:
//      Retrieve the cluster's domain.
//
//  Arguments:
//      pbstrDomainOut  - The cluster's domain.
//
//  Return Values:
//      S_OK
//          *pbstrDomainOut is a BSTR containing the cluster's domain; the
//          caller needs to free it with TraceSysFreeString.
//
//      S_FALSE
//          Same as S_OK, except that the cluster's domain was not specified
//          by the caller who set it, and so it defaulted to the local machine's.
//
//      E_POINTER
//          pbstrDomainOut was null.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME )
//          The cluster's name and domain are not yet defined.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetClusterDomain(
    BSTR* pbstrDomainOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( pbstrDomainOut != NULL );
    if ( pbstrDomainOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrDomainOut = NULL;

    if ( !FHasClusterName() )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DOMAINNAME ) );
        goto Cleanup;
    }

    *pbstrDomainOut = TraceSysAllocString( m_bstrClusterDomain );
    if ( *pbstrDomainOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = ( m_fDefaultedDomain? S_FALSE: S_OK );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetClusterDomain


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetClusterObject
//
//  Description:
//      Retrieve the CClusCfgServer object representing the cluster,
//      creating it if necessary.
//
//  Arguments:
//      ppClusterOut
//          A pointer to the CClusCfgServer object; can be null if the
//          caller wants just to ensure the object exists.
//
//  Return Values:
//      S_OK
//          The cluster object exists; if ppClusterOut is not null,
//          *ppClusterOut points to the object and the caller must
//          release it.
//
//      E_PENDING
//          The cluster object has not been initialized,
//          and *ppClusterOut is null.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_ACCOUNT_NAME )
//          The cluster's name has not yet been set.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetClusterObject(
    IClusCfgClusterInfo ** ppClusterOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( ppClusterOut != NULL )
    {
        *ppClusterOut = NULL;
    }

    if ( !m_ncCluster.FHasObject() )
    {
        if ( !m_ncCluster.FHasCookie() )
        {
            hr = STHR( HrGetClusterCookie( NULL ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        hr = THR( m_pom->GetObject( DFGUID_ClusterConfigurationInfo, m_ncCluster.ocObject, &m_ncCluster.punkObject ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // m_ncCluster currently has no object pointer.

    if ( ppClusterOut != NULL )
    {
        hr = THR( m_ncCluster.punkObject->QueryInterface( IID_IClusCfgClusterInfo, reinterpret_cast< void ** >( ppClusterOut ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetClusterObject


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetClusterCookie
//
//  Description:
//      Retrieve the ObjectManager cookie corresponding to the cluster,
//      creating it if necessary.
//
//  Arguments:
//      pocClusterOut
//          A pointer to the ObjectManager cookie; can be null if the
//          caller wants just to ensure the cookie exists.
//
//  Return Values:
//      S_OK
//          The cookie exists; if pocClusterOut is not null,
//          *pocClusterOut holds the value of the cookie.
//
//      S_FALSE
//          Same as S_OK except that the corresponding object is known not
//          to be initialized.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_ACCOUNT_NAME )
//          The cluster's name has not yet been set.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetClusterCookie(
    OBJECTCOOKIE * pocClusterOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrClusterFQN = NULL;

    //  Clear *pocClusterOut in case of failure.
    if ( pocClusterOut != NULL )
    {
        *pocClusterOut = 0;
    }

    Assert( FHasClusterName() );
    if ( !FHasClusterName() )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_ACCOUNT_NAME ) );
        goto Cleanup;
    }

    //  Get the cookie from the object manager if necessary.
    if ( !m_ncCluster.FHasCookie() )
    {
        //  Make FQName for cluster.
        hr = THR( HrMakeFQN( m_ncCluster.bstrName, m_bstrClusterDomain, true, &bstrClusterFQN ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = m_pom->FindObject(
                  CLSID_ClusterConfigurationType
                , 0
                , bstrClusterFQN
                , DFGUID_ClusterConfigurationInfo
                , &m_ncCluster.ocObject
                , &m_ncCluster.punkObject
                );
        if ( hr == E_PENDING )
        {
            hr = S_FALSE;
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }
    }  // m_ncCluster currently has no cookie.

    //  Set the cookie if the caller wants it.
    if ( pocClusterOut != NULL )
    {
        *pocClusterOut = m_ncCluster.ocObject;
    }

Cleanup:
    TraceSysFreeString( bstrClusterFQN );
    HRETURN( hr );

} //*** CClusCfgWizard::HrGetClusterCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetClusterChild
//
//  Description:
//      Retrieve an object which the ObjectManager regards as a child of
//      the cluster.
//
//  Arguments:
//      rclsidChildIn   - The child's class.
//      rguidFormatIn   - The child's "data format."
//      ppunkChildOut   - A pointer to the child object.
//
//  Return Values:
//      S_OK
//          The call succeeded and *ppunkChildOut points to a valid object,
//          which the caller must release.
//
//      Failure
//          *ppunkChildOut is null.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetClusterChild(
      REFCLSID      rclsidChildIn
    , REFGUID       rguidFormatIn
    , IUnknown **   ppunkChildOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    OBJECTCOOKIE    ocChild = 0;

    Assert( ppunkChildOut != NULL );
    if ( ppunkChildOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppunkChildOut = NULL;

    if ( !m_ncCluster.FHasCookie() )
    {
        hr = STHR( HrGetClusterCookie( NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    hr = THR( m_pom->FindObject(
                          rclsidChildIn
                        , m_ncCluster.ocObject
                        , NULL
                        , rguidFormatIn
                        , &ocChild
                        , ppunkChildOut
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetClusterChild


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrReleaseClusterObject
//
//  Description:
//      Discard the cluster object (if one exists) and all nodes, and
//      ask the object manager to do the same, but preserve the cluster's
//      name (as well as the node names).
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrReleaseClusterObject( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( m_ncCluster.FHasCookie() )
    {
        hr = THR( HrReleaseNodeObjects() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pom->RemoveObject( m_ncCluster.ocObject ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_ncCluster.ocObject = 0;
        m_ncCluster.ReleaseObject();
    } // If: cluster cookie exists.

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrReleaseClusterObject


//****************************************************************************
//
//  Non-COM public methods: node access
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrAddNode
//
//  Description:
//      Add a node for the wizard to include in its action.
//
//  Arguments:
//      pwcszNodeNameIn
//          The node's name; can be anything accepted as the first
//          argument to HrMakeFQN.
//
//      fAcceptNonRFCCharsIn
//          Allow the node name to contain non-RFC characters.
//
//  Return Values:
//      S_OK
//          The name is valid and the corresponding machine will be
//          included in the wizard's action.
//
//      S_FALSE
//          The node is already in the wizard's list.
//
//      HRESULT_FROM_WIN32( ERROR_CURRENT_DOMAIN_NOT_ALLOWED )
//          The node's domain conflicts either with the cluster's or with
//          that of other nodes in the cluster.
//
//      Other failures
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrAddNode(
      LPCWSTR   pwcszNodeNameIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrNodeFQN = NULL;
    BSTR    bstrNodeDisplay = NULL;

    NamedCookieArray::Iterator it = m_ncaNodes.ItBegin();

    Assert( pwcszNodeNameIn != NULL );
    if ( pwcszNodeNameIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Make corresponding FQName, using cluster domain (or local machine's) as default.
    hr = THR( HrMakeFQN( pwcszNodeNameIn, m_bstrClusterDomain, fAcceptNonRFCCharsIn, &bstrNodeFQN ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  If bstrNodeFQN is an FQIP,
    hr = STHR( HrFQNIsFQIP( bstrNodeFQN ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_OK ) //   set display name to IP address;
    {
        hr = THR( HrExtractPrefixFromFQN( bstrNodeFQN, &bstrNodeDisplay ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else // otherwise, set display name to pwcszNodeNameIn.
    {
        bstrNodeDisplay = TraceSysAllocString( pwcszNodeNameIn );
        if ( bstrNodeDisplay == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    //  If name already exists, bail out with S_FALSE;
    while ( it != m_ncaNodes.ItEnd() )
    {
        if ( NBSTRCompareNoCase( ( *it ).bstrName, bstrNodeDisplay ) == 0 )
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        ++it;
    } // For each node currently in the list.

    //  Add to node list.
    {
        SNamedCookie ncNewNode;

        ncNewNode.bstrName = bstrNodeDisplay;
        bstrNodeDisplay = NULL;

        hr = THR( m_ncaNodes.HrPushBack( ncNewNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    TraceSysFreeString( bstrNodeFQN );
    TraceSysFreeString( bstrNodeDisplay );

    HRETURN( hr );

} //*** CClusCfgWizard::HrAddNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetNodeCount
//
//  Description:
//      Retrieve the number of nodes currently in the wizard's list.
//
//  Arguments:
//      pcNodesOut  - The node count.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetNodeCount(
    size_t* pcNodesOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( pcNodesOut != NULL );
    if ( pcNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pcNodesOut = m_ncaNodes.Count();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetNodeCount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetNodeObject
//
//  Description:
//      Retrieve the CClusCfgServer object representing a node in the
//      list, creating it if necessary.
//
//  Arguments:
//      idxNodeIn
//          The zero-based index of the node in the list.
//
//      ppNodeOut
//          A pointer to the CClusCfgServer object; can be null if the
//          caller wants just to ensure the object exists.
//
//  Return Values:
//      S_OK
//          The node object exists; if ppNodeOut is not null,
//          *ppNodeOut points to the object and the caller must
//          release it.
//
//      E_PENDING
//          The node object has not been initialized,
//          and *ppNodeOut is null.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetNodeObject(
      size_t                idxNodeIn
    , IClusCfgNodeInfo **   ppNodeOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  Clear *ppNodeOut in case of failure.
    if ( ppNodeOut != NULL )
    {
        *ppNodeOut = NULL;
    }

    //  Make sure index is within bounds.
    Assert( idxNodeIn < m_ncaNodes.Count() );
    if ( idxNodeIn >= m_ncaNodes.Count() )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  Obtain the object from the object manager if necessary.
    if ( !m_ncaNodes[ idxNodeIn ].FHasObject() )
    {
        hr = STHR( HrGetNodeCookie( idxNodeIn, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pom->GetObject(
                              DFGUID_NodeInformation
                            , m_ncaNodes[ idxNodeIn ].ocObject
                            , &m_ncaNodes[ idxNodeIn ].punkObject
                            ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // If: need to obtain object from object manager.

    //  QI for the interface if the caller wants it.
    if ( ppNodeOut != NULL )
    {
        hr = THR( m_ncaNodes[ idxNodeIn ].punkObject->QueryInterface(
                                                              IID_IClusCfgNodeInfo
                                                            , reinterpret_cast< void** >( ppNodeOut )
                                                            ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetNodeObject


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetNodeCookie
//
//  Description:
//      Retrieve the ObjectManager cookie corresponding to the node,
//      creating it if necessary.
//
//  Arguments:
//      idxNodeIn
//          The zero-based index of the node in the list.
//
//      pocNodeOut
//          A pointer to the ObjectManager cookie; can be null if the
//          caller wants just to ensure the cookie exists.
//
//  Return Values:
//      S_OK
//          The cookie exists; if pocNodeOut is not null,
//          *pocNodeOut holds the value of the cookie.
//
//      S_FALSE
//          Same as S_OK except that the corresponding object is known not
//          to be initialized.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetNodeCookie(
      size_t            idxNodeIn
    , OBJECTCOOKIE *    pocNodeOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrNodeFQN = NULL;

    //  Clear *pocNodeOut in case of failure.
    if ( pocNodeOut != NULL )
    {
        *pocNodeOut = 0;
    }

    //  Make sure index is within bounds.
    Assert( idxNodeIn < m_ncaNodes.Count() );
    if ( idxNodeIn >= m_ncaNodes.Count() )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  Get the cookie from the object manager if necessary.
    if ( !m_ncaNodes[ idxNodeIn ].FHasCookie() )
    {
        hr = STHR( HrGetClusterCookie( NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrMakeFQN( m_ncaNodes[ idxNodeIn ].bstrName, m_bstrClusterDomain, true, &bstrNodeFQN ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = m_pom->FindObject(
                  CLSID_NodeType
                , m_ncCluster.ocObject
                , bstrNodeFQN
                , DFGUID_NodeInformation
                , &m_ncaNodes[ idxNodeIn ].ocObject
                , &m_ncaNodes[ idxNodeIn ].punkObject
                );
        if ( hr == E_PENDING )
        {
            hr = S_FALSE;
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }
    } // If: node doesn't already have a cookie.

    //  Set the cookie if the caller wants it.
    if ( pocNodeOut != NULL )
    {
        *pocNodeOut = m_ncaNodes[ idxNodeIn ].ocObject;
    }

Cleanup:

    TraceSysFreeString( bstrNodeFQN );
    HRETURN( hr );

} //*** CClusCfgWizard::HrGetNodeCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetNodeName
//
//  Description:
//      Retrieve the node's name.
//
//  Arguments:
//      idxNodeIn           - The zero-based index of the node in the list.
//      pbstrNodeNameOut    - The node's name.
//
//  Return Values:
//      S_OK
//          *pbstrNodeNameOut is a BSTR containing the node's name; the
//          caller needs to free it with TraceSysFreeString.
//
//      E_POINTER
//          pbstrNodeNameOut was null.
//
//      E_INVALIDARG
//          The index was out of range for the current set of nodes.
//
//      Other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetNodeName(
      size_t    idxNodeIn
    , BSTR *    pbstrNodeNameOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  Check out-parameter and set to null in case of failure.
    Assert( pbstrNodeNameOut != NULL );
    if ( pbstrNodeNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrNodeNameOut = NULL;

    //  Make sure index is within bounds.
    Assert( idxNodeIn < m_ncaNodes.Count() );
    if ( idxNodeIn >= m_ncaNodes.Count() )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    *pbstrNodeNameOut = TraceSysAllocString( m_ncaNodes[ idxNodeIn ].bstrName );
    if ( *pbstrNodeNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetNodeName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetNodeChild
//
//  Description:
//      Retrieve an object which the ObjectManager regards as a child of
//      the node.
//
//  Arguments:
//      idxNodeIn       - The zero-based index of the node in the list.
//      rclsidChildIn   - The child's class.
//      rguidFormatIn   - The child's "data format."
//      ppunkChildOut   - A pointer to the child object.
//
//  Return Values:
//      S_OK
//          The call succeeded and *ppunkChildOut points to a valid object,
//          which the caller must release.
//
//      Failure
//          *ppunkChildOut is null.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetNodeChild(
      size_t        idxNodeIn
    , REFCLSID      rclsidChildIn
    , REFGUID       rguidFormatIn
    , IUnknown **   ppunkChildOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    OBJECTCOOKIE    ocChild = 0;

    //  Check out-parameter and set to null in case of failure.
    Assert( ppunkChildOut != NULL );
    if ( ppunkChildOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppunkChildOut = NULL;

    //  Make sure index is within bounds.
    Assert( idxNodeIn < m_ncaNodes.Count() );
    if ( idxNodeIn >= m_ncaNodes.Count() )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  Get the node's cookie if necessary.
    if ( !m_ncaNodes[ idxNodeIn ].FHasCookie() )
    {
        hr = STHR( HrGetNodeCookie( idxNodeIn, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //  Ask the object manager for the child object.
    hr = THR( m_pom->FindObject(
                          rclsidChildIn
                        , m_ncaNodes[ idxNodeIn ].ocObject
                        , NULL
                        , rguidFormatIn
                        , &ocChild
                        , ppunkChildOut
                        ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetNodeChild


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrReleaseNodeObjects
//
//  Description:
//      Discard all node objects, and ask the object manager to do
//      the same, but preserve the list of names.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrReleaseNodeObjects( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    for ( NamedCookieArray::Iterator it = m_ncaNodes.ItBegin(); it != m_ncaNodes.ItEnd(); ++it)
    {
        if ( ( *it ).FHasCookie() )
        {
            hr = THR( m_pom->RemoveObject( ( *it ).ocObject ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            ( *it ).ocObject = 0;

            ( *it ).ReleaseObject();
        }
    } // For each node in the list.

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrReleaseNodeObjects


//****************************************************************************
//
//  Non-COM public methods: task access
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrCreateTask
//
//  Description:
//      Get a new task from the task manager.
//
//  Arguments:
//      rguidTaskIn - The type of task.
//      ppunkOut    - A pointer to the new task.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrCreateTask(
      REFGUID       rguidTaskIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( m_ptm->CreateTask( rguidTaskIn, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrCreateTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrSubmitTask
//
//  Description:
//      Submit a task to the task manager.
//
//  Arguments:
//      pTaskIn - A pointer to the task to submit.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrSubmitTask(
    IDoTask * pTaskIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( m_ptm->SubmitTask( pTaskIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrSubmitTask


//****************************************************************************
//
//  Non-COM public methods: completion task access
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetCompletionCookie
//
//  Description:
//      Get an object manager cookie for referring to a completion task.
//
//  Arguments:
//      rguidTaskIn - The type of completion task.
//      pocTaskOut  - The task's cookie.
//
//  Return Values:
//      S_OK
//      E_PENDING   - An expected value; the task is not yet complete.
//      Other failures.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetCompletionCookie(
      REFGUID           rguidTaskIn
    , OBJECTCOOKIE *    pocTaskOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    IUnknown* punk = NULL;

    hr = m_pom->FindObject(
                    rguidTaskIn
                  , NULL
                  , m_ncCluster.bstrName
                  , IID_NULL
                  , pocTaskOut
                  , &punk // dummy
                  );
    if ( FAILED( hr ) && ( hr != E_PENDING ) )
    {
        THR( hr );
        goto Cleanup;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    HRETURN( hr );

} //*** CClusCfgWizard::HrGetCompletionCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrGetCompletionStatus
//
//  Description:
//      Get the status of a completion task.
//
//  Arguments:
//      ocTaskIn
//          The task's cookie, obtained from HrGetCompletionCookie.
//
//      phrStatusOut
//          The task's current status.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrGetCompletionStatus(
      OBJECTCOOKIE  ocTaskIn
    , HRESULT *     phrStatusOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    IStandardInfo*  psi = NULL;
    IUnknown*       punk = NULL;

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, ocTaskIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psi->GetStatus( phrStatusOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

} //*** CClusCfgWizard::HrGetCompletionStatus


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrReleaseCompletionObject
//
//  Description:
//      Release a completion task that's no longer needed.
//
//  Arguments:
//      ocTaskIn
//          The task's cookie, obtained from HrGetCompletionCookie.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrReleaseCompletionObject(
    OBJECTCOOKIE ocTaskIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( m_pom->RemoveObject( ocTaskIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrReleaseCompletionObject



//****************************************************************************
//
//  Non-COM public methods: connection point access
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrAdvise
//
//  Description:
//      Hook up an event sink to receive notifications from the middle tier.
//
//  Arguments:
//      riidConnectionIn    - The type of event sink.
//      punkConnectionIn    - The event sink instance to connect.
//      pdwCookieOut        - The cookie to use for disconnecting.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrAdvise(
      REFIID        riidConnectionIn
    , IUnknown *    punkConnectionIn
    , DWORD *       pdwCookieOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IConnectionPoint *  pConnection = NULL;

    hr = THR( m_pcpc->FindConnectionPoint( riidConnectionIn, &pConnection ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pConnection->Advise( punkConnectionIn, pdwCookieOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pConnection != NULL )
    {
        pConnection->Release();
    }

    HRETURN( hr );

} //*** CClusCfgWizard::HrAdvise


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrUnadvise
//
//  Description:
//      Disconnect an event sink from the middle tier.
//
//  Arguments:
//      riidConnectionIn    - The type of event sink.
//      dwCookieIn          - The event sink's cookie from HrAdvise.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrUnadvise(
      REFIID    riidConnectionIn
    , DWORD     dwCookieIn
    )
{
    TraceFunc( "" );

    HRESULT             hr              = S_OK;
    IConnectionPoint *  pConnection     = NULL;

    hr = THR( m_pcpc->FindConnectionPoint( riidConnectionIn, &pConnection ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pConnection->Unadvise( dwCookieIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pConnection != NULL )
    {
        pConnection->Release();
    }

    HRETURN( hr );

} //*** CClusCfgWizard::HrUnadvise


//****************************************************************************
//
//  Non-COM public methods: miscellaneous
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrCreateMiddleTierObjects
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrCreateMiddleTierObjects()
{
    TraceFunc( "" );

    HRESULT hr  = S_OK;
    size_t  idxNode = 0;

    hr = STHR( HrGetClusterCookie( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    for ( idxNode = 0; idxNode < m_ncaNodes.Count(); ++idxNode )
    {
        hr = STHR( HrGetNodeCookie( idxNode, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrCreateMiddleTierObjects


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::FHasClusterName
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CClusCfgWizard::FHasClusterName() const
{
    TraceFunc( "" );

    RETURN( m_ncCluster.FHasName() );

} //*** CClusCfgWizard::FHasClusterName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::FDefaultedClusterDomain
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CClusCfgWizard::FDefaultedClusterDomain() const
{
    TraceFunc( "" );

    RETURN( m_fDefaultedDomain );

} //*** CClusCfgWizard::FHasClusterName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrFilterNodesWithBadDomains
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::HrFilterNodesWithBadDomains( BSTR* pbstrBadNodesOut )
{
    TraceFunc( "" );

    HRESULT hr  = S_OK;
    BSTR    bstrCurrentList = NULL;

    NamedCookieArray ncaUnfilteredNodes;

    Assert( pbstrBadNodesOut != NULL );
    if ( pbstrBadNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrBadNodesOut = NULL;

    ncaUnfilteredNodes.Swap( m_ncaNodes );

    for ( NamedCookieArray::Iterator it = ncaUnfilteredNodes.ItBegin(); it != ncaUnfilteredNodes.ItEnd(); ++it )
    {
        bool fDomainValid = true;

        hr = STHR( HrIsValidFQN( ( *it ).bstrName, true ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        else if ( hr == S_OK )
        {
            size_t idxNodeDomain = 0;
            hr = THR( HrFindDomainInFQN( ( *it ).bstrName, &idxNodeDomain ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = STHR( HrIsCompatibleNodeDomain( ( *it ).bstrName + idxNodeDomain ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            fDomainValid = ( hr == S_OK );

            if ( fDomainValid )
            {
                //  KB: 18-Oct-2001 jfranco bug #477514
                //  The wizard's supposed to show node domains to the user only when they're invalid,
                //  so remove the domain from the node name.

                BSTR bstrShortName = NULL;
                hr = THR( HrExtractPrefixFromFQN( ( *it ).bstrName, &bstrShortName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                TraceSysFreeString( ( *it ).bstrName );
                ( *it ).bstrName = bstrShortName;
            }
        } // if: node name has a domain

        if ( fDomainValid ) // Domain is okay, so put into filtered array.
        {
            hr = THR( m_ncaNodes.HrPushBack( ( *it ) ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
        else // Domain doesn't match; add to bad list.
        {
            if ( *pbstrBadNodesOut == NULL ) // First name in bad list.
            {
                *pbstrBadNodesOut = TraceSysAllocString( ( *it ).bstrName );
                if ( *pbstrBadNodesOut == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }
            }
            else // Append another name to non-empty bad list.
            {
                TraceSysFreeString( bstrCurrentList );
                bstrCurrentList = *pbstrBadNodesOut;
                *pbstrBadNodesOut = NULL;
                hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!; %2!ws!"
                            , pbstrBadNodesOut
                            , bstrCurrentList
                            , ( *it ).bstrName
                            ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            } // else: append name to bad list
        } // else: mismatched domain
    } // for: each unfiltered node


Cleanup:

    TraceSysFreeString( bstrCurrentList );

    HRETURN( hr );

} //*** CClusCfgWizard::HrFilterNodesWithBadDomains

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrReadSettings
//
//  Description:
//      Read the saved settings from the registry.  If there are no saved
//      setting then we want to do a full configuration.
//
//  Arguments:
//      pecsSettingOut
//          What is the saved setting?
//
//      pfValuePresentOut
//          Was the value present in the registry?
//
//  Return Values:
//      S_OK
//          Success
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrReadSettings(
      EConfigurationSettings *  pecsSettingOut
    , BOOL *                    pfValuePresentOut // = NULL
    )
{
    TraceFunc( "" );
    Assert( pecsSettingOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    HKEY    hKey = NULL;
    DWORD   dwType;
    DWORD   dwData;
    DWORD   cbData = sizeof( dwData );

    //
    //  Default to doing a full config.
    //

    *pecsSettingOut = csFullConfig;

    //
    //  Default to the value not being present.
    //

    if ( pfValuePresentOut != NULL )
    {
        *pfValuePresentOut = FALSE;
    } // if:

    sc = RegOpenKeyExW( HKEY_CURRENT_USER, USER_REGISTRY_SETTINGS_KEY, 0, KEY_READ, &hKey );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  If we fail for any other reason log it and leave.
    //

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[WIZ] RegOpenKeyEx() for %ws failed. (hr = %#08x)", USER_REGISTRY_SETTINGS_KEY, HRESULT_FROM_WIN32( TW32( sc ) ) );
        goto Cleanup;
    } // if:

    //
    //  Now that the key is open we need to read the value.
    //

    sc = RegQueryValueExW( hKey, CONFIGURATION_TYPE, NULL, &dwType, (LPBYTE) &dwData, &cbData );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        //
        //  It's okay if the value is not found.
        //

        goto Cleanup;
    } // if:
    else if ( sc == ERROR_SUCCESS )
    {
        Assert( dwType == REG_DWORD )

        //
        //  The value was present.  Tell the caller if they cared to ask...
        //

        if ( pfValuePresentOut != NULL )
        {
            *pfValuePresentOut = TRUE;
        } // if:

        //
        //  If there was a stored value then we need to return it to the caller.
        //

        *pecsSettingOut = (EConfigurationSettings) dwData;
    } // else if:
    else
    {
        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // else:

Cleanup:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::HrReadSettings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::HrWriteSettings
//
//  Description:
//      Write the settings into the registry.
//
//  Arguments:
//      ecsSettingIn
//          The setting to write.
//
//      fDeleteValueIn
//          Should the value be deleted and therefore stop being the default
//          setting.
//
//  Return Values:
//      S_OK
//          Success
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrWriteSettings(
      EConfigurationSettings    ecsSettingIn
    , BOOL                      fDeleteValueIn  // = FALSE
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    HKEY    hKey = NULL;

    sc = RegCreateKeyExW( HKEY_CURRENT_USER, USER_REGISTRY_SETTINGS_KEY, NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( L"[WIZ] RegCreateKeyExW() for %ws failed. (hr = %#08x)", USER_REGISTRY_SETTINGS_KEY, hr );
        goto Cleanup;
    } // if:

    //
    //  Only save the data if we are not going to delete the value from the registry.
    //

    if ( fDeleteValueIn == FALSE )
    {
        //
        //  Now that the key is open we need to write the value.
        //

        sc = RegSetValueExW( hKey, CONFIGURATION_TYPE, NULL, REG_DWORD, (LPBYTE) &ecsSettingIn, sizeof( ecsSettingIn ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        sc = RegDeleteValueW( hKey, CONFIGURATION_TYPE );
        if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_FILE_NOT_FOUND ) )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    } // else:

Cleanup:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::HrWriteSettings
*/

//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::ObjectChanged
//
//  Description:
//
//  Arguments:
//      cookieIn
//
//  Return Values:
//      S_OK
//      Failure
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    HRESULT hr = S_OK;
    HRESULT hrResult;
    BOOL    fSuccess;

    if ( cookieIn == m_cookieCompletion )
    {
        THR( HrGetCompletionStatus( m_cookieCompletion, &hrResult ) );

        fSuccess = SetEvent( m_hCancelCleanupEvent );
        if ( fSuccess == FALSE )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CClusCfgWizard::ObjectChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\commitpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CommitPage.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "CommitPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS( "CCommitPage" );

//
//  Special CLSID_Type for completion cookie.
//
#include <initguid.h>
// {FC4D0128-7BAB-4c76-9C38-E3C042F15822}
DEFINE_GUID( CLSID_CommitTaskCompletionCookieType,
0xfc4d0128, 0x7bab, 0x4c76, 0x9c, 0x38, 0xe3, 0xc0, 0x42, 0xf1, 0x58, 0x22);

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommitPage::CCommitPage(
//      CClusCfgWizard *   pccwIn,
//      ECreateAddMode     ecamCreateAddModeIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCommitPage::CCommitPage(
      CClusCfgWizard *  pccwIn
    , ECreateAddMode    ecamCreateAddModeIn
    )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );

    m_hwnd                      = NULL;
    pccwIn->AddRef();
    m_pccw                      = pccwIn;
    m_fNext                     = FALSE;
    m_fDisableBack              = FALSE;
    m_fAborted                  = FALSE;
    m_fPassedPointOfNoReturn    = FALSE;
    m_ecamCreateAddMode         = ecamCreateAddModeIn;
    m_htiReanalyze              = NULL;
    m_rgfSubReanalyzeAdded[ 0 ] = FALSE;
    m_rgfSubReanalyzeAdded[ 1 ] = FALSE;
    m_rgfSubReanalyzeAdded[ 2 ] = FALSE;
    m_rgfSubReanalyzeAdded[ 3 ] = FALSE;
    m_rgfSubReanalyzeAdded[ 4 ] = FALSE;
    m_ptccc                     = NULL;

    m_cRef = 0;

    m_cookieCompletion = NULL;
    // m_fTaskDone
    // m_hrResult
    m_pttv             = NULL;
    m_bstrLogMsg       = NULL;
    m_dwCookieCallback = 0;

    m_dwCookieNotify = 0;

    TraceFuncExit();

} //*** CCommitPage::CCommitPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommitPage::~CCommitPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCommitPage::~CCommitPage( void )
{
    TraceFunc( "" );

    THR( HrCleanupCommit() );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    //
    //  Unregister UI notification (if needed)
    //

    THR( HrUnAdviseConnections() );

    if ( m_pttv != NULL )
    {
        delete m_pttv;
    } // if:

    TraceSysFreeString( m_bstrLogMsg );

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCommitPage::~CCommitPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // didn't set focus
    size_t  cNodes = 0;
    size_t  cInitialTickCount = 400;
    HRESULT hr = S_OK;

    //
    //  Get the node count to get a rough approximation of the initial tick count
    //  for the TaskTreeView.
    //
    hr = THR( m_pccw->HrGetNodeCount( &cNodes ) );
    if ( FAILED( hr ) )
    {
        cNodes = 1;
    }

    //  Numbers based on bulk-add testing.
    cInitialTickCount = 120 + ( 280 * cNodes );

    //
    //  Initialize the tree view
    //
    m_pttv = new CTaskTreeView( m_hwnd, IDC_COMMIT_TV_TASKS, IDC_COMMIT_PRG_STATUS, IDC_COMMIT_S_STATUS, cInitialTickCount );
    if ( m_pttv == NULL )
    {
        goto OutOfMemory;
    }

    THR( m_pttv->HrOnInitDialog() );

Cleanup:
    RETURN( lr );

OutOfMemory:
    goto Cleanup;

} //*** CCommitPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_COMMIT_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_COMMIT_PB_DETAILS:
            if ( idNotificationIn == BN_CLICKED )
            {
                Assert( m_pttv != NULL );
                THR( m_pttv->HrDisplayDetails() );
                lr = TRUE;
            }
            break;

        case IDC_COMMIT_PB_RETRY:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrCleanupCommit() );
                OnNotifySetActive();
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CCommitPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCommitPage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCommitPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   dwFlags       = 0;
    BOOL    fEnableRetry  = FALSE;
    BOOL    fEnableCancel = FALSE;

    if ( m_fDisableBack == FALSE )
    {
        dwFlags = PSWIZB_BACK;
    }

    if ( m_fTaskDone == TRUE )
    {
        //
        //  The retry, cancel, and back buttons can only be enabled if we
        //  haven't passed the point of no return.
        //

        if (    FAILED( m_hrResult )
            &&  ( m_fPassedPointOfNoReturn == FALSE )
            )
        {
            fEnableRetry  = TRUE;
            fEnableCancel = TRUE;
            dwFlags |= PSWIZB_BACK;
        }
        else
        {
            dwFlags |= PSWIZB_NEXT;
        }
    } // if: commit task has completed
    else
    {
        //
        //  Disable the back button if task is not completed yet
        //

        dwFlags &= ~PSWIZB_BACK;
        fEnableCancel = FALSE;
    } // else: commit task has not completed

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), fEnableCancel );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMMIT_PB_RETRY ), fEnableRetry );

    HRETURN( hr );

} //*** CCommitPage::HrUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LONG_PTR    lptrCancelState = FALSE;  // allow cancel

    if ( m_fTaskDone == FALSE )
    {
        lptrCancelState = TRUE;   // do not allow cancel
    } // if:
    else
    {
        int iRet;

        iRet = MessageBoxFromStrings( m_hwnd, IDS_QUERY_CANCEL_TITLE, IDS_QUERY_CANCEL_TEXT, MB_YESNO );
        if ( iRet == IDNO )
        {
            lptrCancelState = TRUE;   // do not allow cancel
        }
        else
        {
            THR( m_pccw->HrLaunchCleanupTask() );
            m_fAborted = TRUE;
        } // else:
    } // else:

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, lptrCancelState );

    RETURN( TRUE );     // this must return TRUE!

} //*** CCommitPage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    OBJECTCOOKIE    cookieCluster = 0;
    LRESULT         lr = TRUE;
    IUnknown *      punkTask  = NULL;

    if ( m_fNext )
    {
        m_fNext = FALSE;

        hr = THR( HrUpdateWizardButtons() );

        goto Cleanup;
    }

    //
    //  Make sure things were cleaned up from the last commit.
    //

    m_hrResult = S_OK;

    m_fAborted = FALSE;
    LogMsg( L"[WIZ] Setting commit page active.  Setting aborted to FALSE." );

    Assert( m_dwCookieNotify == 0 );
    Assert( m_cookieCompletion == NULL );

    //
    //  Reset the progress bar's color.
    //

    SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0, 0x80 ) );

    //
    //  Clear the tree view and status line. Disable the retry button.
    //

    Assert( m_pttv != NULL );
    hr = THR( m_pttv->HrOnNotifySetActive() );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Add the major root task nodes.
    //  (Minor reanalyze tasks are added dynamically.)
    //

    hr = THR( m_pttv->HrAddTreeViewItem(
                              &m_htiReanalyze
                            , IDS_TASKID_MAJOR_REANALYZE
                            , TASKID_Major_Reanalyze
                            , IID_NULL
                            , TVI_ROOT
                            , TRUE      // fParentToAllNodeTasksIn
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES
                            , TASKID_Major_Configure_Cluster_Services
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES
                            , TASKID_Major_Configure_Resource_Types
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_RESOURCES
                            , TASKID_Major_Configure_Resources
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Find the cluster cookie.
    //

    hr = THR( m_pccw->HrGetClusterCookie( &cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a completion cookie.
    //

    // Don't wrap - this can fail with E_PENDING
    hr = m_pccw->HrGetCompletionCookie( CLSID_CommitTaskCompletionCookieType, &m_cookieCompletion );
    if ( hr == E_PENDING )
    {
        // no-op.
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( m_pccw->HrAdvise( IID_INotifyUI, static_cast< INotifyUI* >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pccw->HrAdvise( IID_IClusCfgCallback, static_cast< IClusCfgCallback* >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Create a new analyze task.
    //

    hr = THR( m_pccw->HrCreateTask( TASK_CommitClusterChanges, &punkTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkTask->TypeSafeQI( ITaskCommitClusterChanges, &m_ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptccc->SetClusterCookie( cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptccc->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = THR( m_pccw->HrSubmitTask( m_ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrUpdateWizardButtons() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punkTask != NULL )
    {
        punkTask->Release();
    }

    RETURN( lr );

} //*** CCommitPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyWizBack( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyWizBack( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    m_fAborted = TRUE;

    LogMsg( L"[WIZ] Back button pressed on the commit page.  Setting aborted to TRUE." );

    THR( HrCleanupCommit() );

    RETURN( lr );

} //*** CCommitPage::OnNotifyWizBack

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    RETURN( lr );

} //*** CCommitPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            lr = OnNotifyWizBack();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;

        default:
            if (    ( idCtrlIn == IDC_COMMIT_TV_TASKS )
                &&  ( m_pttv != NULL ) )
            {
                // Pass the notification on to the tree control.
                lr = m_pttv->OnNotify( pnmhdrIn );
            }
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CCommitPage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCommitPage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCommitPage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCommitPage * pPage = reinterpret_cast< CCommitPage * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCommitPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // No default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CCommitPage::S_DlgProc


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommitPage::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCommitPage::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCommitPage::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCommitPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCommitPage::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCommitPage::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCommitPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // Do nothing -- COM interface does not control object lifetime
    }

    CRETURN( cRef );

} //*** CCommitPage::Release


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCommitPage::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    HRESULT hr = S_OK;

    BSTR    bstrDescription  = NULL;

    if ( cookieIn == m_cookieCompletion )
    {
        hr = THR( m_pccw->HrGetCompletionStatus( m_cookieCompletion, &m_hrResult ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pttv->HrShowStatusAsDone() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // [GorN] added m_fPassedPointOfNoReturn as
        // a fix for bug#546011
        if ( SUCCEEDED( m_hrResult ) || m_fPassedPointOfNoReturn )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0x80, 0 ) );
        }
        else
        {
            if ( !m_fDisableBack )
            {
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_COMMIT_FAILED_INSTRUCTIONS_BACK_ENABLED,
                                                &bstrDescription
                                                ) );
            }
            else
            {
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_COMMIT_FAILED_INSTRUCTIONS,
                                                &bstrDescription
                                                ) );
            }

            SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );
        }

        SetDlgItemText( m_hwnd, IDC_COMMIT_S_RESULTS, bstrDescription );

        m_fTaskDone = TRUE;

        THR( m_pccw->HrReleaseCompletionObject( m_cookieCompletion ) );
        //  Don't care if it fails.
        m_cookieCompletion = NULL;

        THR( HrUpdateWizardButtons() );

        hr = THR( m_pccw->HrUnadvise( IID_IClusCfgCallback, m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_dwCookieCallback = 0;
    } // if: received the completion cookie

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CCommitPage::ObjectChanged



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCommitPage::SendStatusReport(
//        LPCWSTR    pcszNodeNameIn
//      , CLSID      clsidTaskMajorIn
//      , CLSID      clsidTaskMinorIn
//      , ULONG      ulMinIn
//      , ULONG      ulMaxIn
//      , ULONG      ulCurrentIn
//      , HRESULT    hrStatusIn
//      , LPCWSTR    pcszDescriptionIn
//      , FILETIME * pftTimeIn
//      , LPCWSTR    pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( m_ptccc != NULL );
    Assert( m_pttv != NULL );

    HRESULT hr;
    ULONG   idx;

    static const GUID * rgclsidAnalysis[] =
    {
          &TASKID_Major_Checking_For_Existing_Cluster
        , &TASKID_Major_Establish_Connection
        , &TASKID_Major_Check_Node_Feasibility
        , &TASKID_Major_Find_Devices
        , &TASKID_Major_Check_Cluster_Feasibility
    };
    static const UINT rgidsAnalysis[] =
    {
          IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER
        , IDS_TASKID_MAJOR_ESTABLISH_CONNECTION
        , IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY
        , IDS_TASKID_MAJOR_FIND_DEVICES
        , IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY
    };

    //
    //  If this is an analyze task, add it below the Reanalyze task item
    //  if it hasn't been added yet.
    //

    for ( idx = 0 ; idx < ARRAYSIZE( rgclsidAnalysis ) ; idx ++ )
    {
        if ( clsidTaskMajorIn == *rgclsidAnalysis[ idx ] )
        {
            if ( m_rgfSubReanalyzeAdded[ idx ] == FALSE )
            {
                Assert( m_htiReanalyze != NULL );
                hr = THR( m_pttv->HrAddTreeViewItem(
                                          NULL  // phtiOut
                                        , rgidsAnalysis[ idx ]
                                        , *rgclsidAnalysis[ idx ]
                                        , TASKID_Major_Reanalyze
                                        , m_htiReanalyze
                                        , TRUE  // fParentToAllNodeTasksIn
                                        ) );
                if ( SUCCEEDED( hr ) )
                {
                    m_rgfSubReanalyzeAdded[ idx ] = TRUE;
                }
            } // if: major ID not added yet
            break;
        } // if: found known major ID
    } // for: each known major task ID

    //
    //  Remove the "back" button as an option if the tasks have made it past re-analyze.
    //
    if (    ( m_fDisableBack == FALSE )
        &&  ( clsidTaskMajorIn == TASKID_Major_Configure_Cluster_Services )
        )
    {
        BSTR  bstrDescription  = NULL;

        m_fDisableBack = TRUE;

        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS_BACK_DISABLED, &bstrDescription ) );
        if ( SUCCEEDED( hr ) )
        {
            SetDlgItemText( m_hwnd, IDC_COMMIT_S_RESULTS, bstrDescription );
            TraceSysFreeString( bstrDescription );
        }

        THR( HrUpdateWizardButtons() );
    } // if: finished re-analyze


    //
    //  If we are at the point of no return.
    //
    if (    ( clsidTaskMajorIn == TASKID_Major_Configure_Cluster_Services )
        &&  ( clsidTaskMinorIn == TASKID_Minor_Errors_To_Warnings_Point )
        )
    {
        //
        // Tell the tree view to treat errors as warnings since we are now
        // past the point of no return.
        //

        m_pttv->SetDisplayErrorsAsWarnings( TRUE /* fDisplayErrorsAsWarningsIn */ );
        m_fPassedPointOfNoReturn = TRUE;
    }

    hr = THR( m_pttv->HrOnSendStatusReport( pcszNodeNameIn,
                                            clsidTaskMajorIn,
                                            clsidTaskMinorIn,
                                            ulMinIn,
                                            ulMaxIn,
                                            ulCurrentIn,
                                            hrStatusIn,
                                            pcszDescriptionIn,
                                            pftTimeIn,
                                            pcszReferenceIn
                                            ) );

    if ( m_fAborted )
    {
        LogMsg( L"[WIZ] Commit page -- replacing (hr = %#08x) with E_ABORT", hr );
        hr = E_ABORT;
    } // if:

    //
    //  If the minor task ID is TASKID_Minor_Disconnecting_From_Server then we need to cancel the commit
    //  task and set the cancel button, reanylze, and back are enbabled.
    //

    if ( IsEqualIID( clsidTaskMinorIn, TASKID_Minor_Disconnecting_From_Server ) )
    {
        THR( m_pttv->HrShowStatusAsDone() );
        SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );

        LogMsg( L"[WIZ] Calling StopTask() on the commit changes task because we were disconnected from the server." );
        THR( m_ptccc->StopTask() );

        PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_BACK );

        EnableWindow( GetDlgItem( m_hwnd, IDC_COMMIT_PB_RETRY ), TRUE );
        EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), TRUE );

        m_fTaskDone = TRUE;    // reset so that the cancel button will actually cancel...
    } // if:

    HRETURN( hr );

} //*** CCommitPage::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCommitPage::HrCleanupCommit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCommitPage::HrCleanupCommit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    UINT    idx;

    if ( m_ptccc != NULL )
    {
        LogMsg( L"[WIZ] Calling StopTask() on the commit changes task becasue we are cleaning up." );
        THR( m_ptccc->StopTask() );
        m_ptccc->Release();
        m_ptccc = NULL;
    } // if:

    //
    //  Unregister UI notification (if needed)
    //

    THR( HrUnAdviseConnections() );

    //
    //  Delete the completion cookie.
    //

    if ( m_cookieCompletion != NULL )
    {
        // Don't care if this fails.
        THR( m_pccw->HrReleaseCompletionObject( m_cookieCompletion ) );
        m_cookieCompletion = NULL;
    }

    //
    //  Clear out the array that indicates whether reanalysis top-level task
    //  IDs have been added yet.
    //

    for ( idx = 0 ; idx < ARRAYSIZE( m_rgfSubReanalyzeAdded ) ; idx++ )
    {
        m_rgfSubReanalyzeAdded[ idx ] = FALSE;
    } // for: each entry in the array

    HRETURN( hr );

} //*** CCommitPage::HrCleanupCommit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAnalyzePage::HrUnAdviseConnections(
//      void
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCommitPage::HrUnAdviseConnections(
    void
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( m_dwCookieNotify != 0 )
    {
        hr = THR( m_pccw->HrUnadvise( IID_INotifyUI, m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } //if:

        m_dwCookieNotify = 0;
    } //if:

    if ( m_dwCookieCallback != 0 )
    {
        hr = THR( m_pccw->HrUnadvise( IID_IClusCfgCallback, m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_dwCookieCallback = 0;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CAnalyzePage::HrUnAdviseConnections
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\clusdomainpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusDomainPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusDomainPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CClusDomainPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::CClusDomainPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn              - CClusCfgWizard
//      ecamCreateAddModeIn - Creating cluster or adding nodes to cluster
//      idsDescIn           - Resource ID for the domain description string.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDomainPage::CClusDomainPage(
    CClusCfgWizard *    pccwIn,
    ECreateAddMode      ecamCreateAddModeIn,
    UINT                idsDescIn
    )
    : m_pccw( pccwIn )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );
    Assert( idsDescIn != 0 );

    // m_hwnd
    m_pccw->AddRef();
    m_ecamCreateAddMode = ecamCreateAddModeIn;
    m_idsDesc           = idsDescIn;

    if (    ( ecamCreateAddModeIn == camADDING )
        &&  ( m_pccw->FHasClusterName() )
        &&  ( !m_pccw->FDefaultedClusterDomain() ) )
    {
        //
        //  Don't show the cluster name/domain page if we are joining
        //  and the cluster name has been filled in by the caller.
        //
        m_fDisplayPage = FALSE;
    }
    else
    {
        m_fDisplayPage = TRUE;
    }

    m_cRef = 0;
    m_ptgd = NULL;

    TraceFuncExit();

} //*** CClusDomainPage::CClusDomainPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::~CClusDomainPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDomainPage::~CClusDomainPage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    if ( m_ptgd != NULL )
    {
        //  Make sure we don't get called anymore.
        THR( m_ptgd->SetCallback( NULL ) );

        m_ptgd->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CClusDomainPage::~CClusDomainPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;
    LRESULT lr = FALSE; // didn't set focus

    BSTR    bstrClusterName = NULL;
    BSTR    bstrClusterLabel = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrDomainDesc = NULL;
    PCWSTR  pwcszLabelToUse = NULL;
    BSTR    bstrNodeName = NULL;

    IUnknown *      punkTask = NULL;

    //
    // (jfranco, bugs #373331 and #480246) Limit cluster name length to max( MAX_CLUSTERNAME_LENGTH, INET_ADDRSTRLEN - 1 )
    // Use INET_ADDRSTRLEN - 1 because INET_ADDRSTRLEN seems to include terminating null.
    // According to MSDN, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns.
    //

    SendDlgItemMessage( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME, EM_SETLIMITTEXT, max( MAX_CLUSTERNAME_LENGTH, INET_ADDRSTRLEN - 1 ), 0 );

    //
    // (jfranco, bug #462673) Limit cluster domain length to ADJUSTED_DNS_MAX_NAME_LENGTH
    // According to MSDN, the return value of CB_LIMITTEXT is always true, so ignore what SendDlgItemMessage returns
    //

    SendDlgItemMessage( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN, CB_LIMITTEXT, ADJUSTED_DNS_MAX_NAME_LENGTH, 0 );

    //
    // Kick off the GetDomains task.
    //

    hr = THR( m_pccw->HrCreateTask( TASK_GetDomains, &punkTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //TraceMoveFromMemoryList( punkTask, g_GlobalMemoryList );

    hr = THR( punkTask->TypeSafeQI( ITaskGetDomains, &m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptgd->SetCallback( static_cast< ITaskGetDomainsCallback * >( this ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccw->HrSubmitTask( m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // If a cluster name has already been specified, set it to the page.
    //

    hr = STHR( m_pccw->get_ClusterName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( bstrClusterName != NULL )
    {
        TraceMemoryAddBSTR( bstrClusterName );
        hr = STHR( HrIsValidFQN( bstrClusterName, true ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        else if ( hr == S_OK )
        {
            hr = THR( HrExtractPrefixFromFQN( bstrClusterName, &bstrClusterLabel ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            pwcszLabelToUse = bstrClusterLabel;
        }
        else
        {
            pwcszLabelToUse = bstrClusterName;
        }

        SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME, pwcszLabelToUse );

        if ( !m_pccw->FDefaultedClusterDomain() )
        {
            hr = STHR( m_pccw->HrGetClusterDomain( &bstrDomain ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
    } // if: cluster name specified already
    else
    {
        size_t cNodes = 0;
        hr = THR( m_pccw->HrGetNodeCount( &cNodes ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  If a node FQN has been specified, use its domain.
        if ( cNodes > 0 )
        {
            hr = THR( m_pccw->HrGetNodeName( 0, &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            hr = STHR( HrIsValidFQN( bstrNodeName, true ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            else if ( hr == S_OK )
            {
                size_t idxDomain = 0;
                hr = THR( HrFindDomainInFQN( bstrNodeName, &idxDomain ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                bstrDomain = TraceSysAllocString( ( bstrNodeName + idxDomain ) );
                if ( bstrDomain == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }
            }
        } // if the wizard already has some nodes.

        if ( bstrDomain == NULL )
        {
            //
            //  Get the domain of the local computer.
            //

            hr = THR( HrGetComputerName(
                              ComputerNameDnsDomain
                            , &bstrDomain
                            , FALSE // fBestEffortIn
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // cNodes == 0 or node name is not fully qualified

    } // else: don't have a cluster name

    SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN, ( bstrDomain == NULL? L"": bstrDomain ) );

    //
    // Set the text of the domain description control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsDesc, &bstrDomainDesc );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_S_DOMAIN_DESC, bstrDomainDesc );

Cleanup:
    TraceSysFreeString( bstrClusterLabel );
    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrDomainDesc );
    TraceSysFreeString( bstrDomain );
    TraceSysFreeString( bstrNodeName );

    if ( punkTask != NULL )
    {
        punkTask->Release();
    }

    RETURN( lr );

} //*** CClusDomainPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    if ( m_fDisplayPage )
    {
        lr = OnUpdateWizardButtons();
    }
    else
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CClusDomainPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    LRESULT     lr = TRUE;

    BSTR        bstrDomainName = NULL;
    BSTR        bstrClusterNameLabel = NULL;
    BSTR        bstrClusterFQN = NULL;
    int         idcFocus = 0;

    PFN_LABEL_VALIDATOR  pfnLabelValidator = ( m_ecamCreateAddMode == camCREATING? HrValidateClusterNameLabel: HrValidateFQNPrefix );
    EFQNErrorOrigin efeo = feoSYSTEM;

    //  Get the cluster domain.
    hr = THR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ), &bstrDomainName ) );
    if ( hr != S_OK )
    {
        //  Next is supposed to be disabled when control is empty.
        goto Error;
    }

    //  Get the cluster hostname label.
    hr = THR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME ), &bstrClusterNameLabel ) );
    if ( hr != S_OK )
    {
        //  Next is supposed to be disabled when control is empty.
        goto Error;
    }

    //  Weed out IP addresses when creating.
    if ( m_ecamCreateAddMode == camCREATING )
    {
        hr = STHR( HrIsValidIPAddress( bstrClusterNameLabel ) );
        if ( hr == S_OK )
        {
            MessageBoxFromStrings(
                  m_hwnd
                , IDS_ERR_VALIDATING_NAME_TITLE
                , IDS_ERR_CLUSTER_CREATE_IP_TEXT
                , MB_OK | MB_ICONSTOP
                );
            goto Error;
        }
        else if ( FAILED( hr ) )
        {
            goto Error;
        }
    }

    //  Make the cluster FQN.
    hr = THR( HrCreateFQN( m_hwnd, bstrClusterNameLabel, bstrDomainName, pfnLabelValidator, &bstrClusterFQN, &efeo ) );
    if ( FAILED( hr ) )
    {
        if ( efeo == feoLABEL )
        {
            idcFocus = IDC_CLUSDOMAIN_E_CLUSTERNAME;
        }
        else if ( efeo == feoDOMAIN )
        {
            idcFocus = IDC_CLUSDOMAIN_CB_DOMAIN;
        }
        goto Error;
    }

    hr = STHR( m_pccw->HrSetClusterName( bstrClusterFQN, true ) );
    if ( FAILED( hr ) )
    {
        THR( HrMessageBoxWithStatus(
                  m_hwnd
                , IDS_ERR_CLUSTER_RENAME_TITLE
                , IDS_ERR_CLUSTER_RENAME_TEXT
                , hr
                , 0
                , MB_OK | MB_ICONSTOP
                , NULL
                ) );
        goto Error;
    }

Cleanup:
    TraceSysFreeString( bstrClusterFQN );
    TraceSysFreeString( bstrDomainName );
    TraceSysFreeString( bstrClusterNameLabel );

    RETURN( lr );

Error:
    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }

    //  Don't go to the next page.
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

} //*** CClusDomainPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch ( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            //
            //  Disable the wizard buttons.
            //
            PropSheet_SetWizButtons( GetParent( m_hwnd ), 0 );
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CClusDomainPage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_CLUSDOMAIN_E_CLUSTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                lr = OnUpdateWizardButtons();
            }
            break;

        case IDC_CLUSDOMAIN_CB_DOMAIN:
            if ( ( idNotificationIn == CBN_EDITCHANGE ) || ( idNotificationIn == CBN_SELENDOK ) )
            {
                //  KB: jfranco 24-oct-2001 bug 481636
                //  Need to update wizard buttons, but only after combo box has a chance to update itself.
                if ( PostMessage( m_hwnd, WM_CCW_UPDATEBUTTONS, 0, 0 ) == 0 )
                {
                    TW32( GetLastError() );
                }
                lr = TRUE;
            }
            break;

    } // switch: control ID

    RETURN( lr );

} //*** CClusDomainPage::OnCommand


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnUpdateWizardButtons( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    HRESULT hrName = S_OK;
    HRESULT hrDomain = S_OK;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;
    DWORD   mEnabledButtons = PSWIZB_BACK;

    hrName = STHR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME ), &bstrName ) );
    hrDomain = STHR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ), &bstrDomain ) );
    if ( ( hrName == S_OK ) && ( hrDomain == S_OK ) )
    {
        mEnabledButtons |= PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), mEnabledButtons );

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDomain );

    RETURN( lr );

} //*** CClusDomainPage::OnUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CClusDomainPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CClusDomainPage::S_DlgProc(
    HWND    hDlgIn,
    UINT    MsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CClusDomainPage * pPage = reinterpret_cast< CClusDomainPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CClusDomainPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            case WM_CCW_UPDATEBUTTONS:
                lr = pPage->OnUpdateWizardButtons();
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CClusDomainPage::S_DlgProc


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      This QI implementation does not use the interface tracing macros due
//      to problems with CITracker's marshalling support.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomainsCallback ) )
    {
        *ppvOut = static_cast< ITaskGetDomainsCallback * >( this );
    } // else if: ITaskGetDomainsCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    HRETURN( hr );

} //*** CClusDomainPage::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::AddRef
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusDomainPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusDomainPage::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::Release
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusDomainPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    CRETURN( cRef );

} //*** CClusDomainPage::Release


//****************************************************************************
//
//  ITaskGetDomainsCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [ITaskGetDomainsCallback]
//  CClusDomainPage::ReceiveDomainResult
//
//  Description:
//
//  Arguments:
//      hrIn
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr;

    hr = THR( m_ptgd->SetCallback( NULL ) );

    HRETURN( hr );

} //*** CClusDomainPage::ReceiveResult

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [ITaskGetDomainsCallback]
//  CClusDomainPage::ReceiveDomainName
//
//  Description:
//
//  Arguments:
//      bstrDomainIn
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::ReceiveDomainName(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr = S_OK;

    ComboBox_AddString( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ), pcszDomainIn );

    HRETURN( hr );

} //*** CClusDomainPage::ReceiveName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.h
//
//  Description:
//      Declaration of the CClusCfgWizard class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Geoffrey Pease  (GPease)    11-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "NamedCookie.h"

//
//  Creating / Adding enum
//
enum ECreateAddMode {
    camUNKNOWN = 0,
    camCREATING,
    camADDING
};
/*
#define USER_REGISTRY_SETTINGS_KEY  L"Software\\Microsoft\\Cluster Configuration Wizard\\Settings"
#define CONFIGURATION_TYPE          L"ConfigurationType"

typedef enum EConfigurationSettings
{
    csUnknown = 0,
    csFullConfig,           // Full analysis and configuration
    csMinConfig,            // Minimal analysis and configuraion
    csMax
} EConfigurationSettings;
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgWizard
//
//  Description:
//      The Cluster Configuration Wizard object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgWizard
    : INotifyUI
{
private:
    //  IUnknown
    LONG                m_cRef;                             // Reference count

    //  IClusCfgWizard
    IClusCfgCredentials *   m_pccc;                             //  Cluster Service Account Credentials
    ULONG                   m_ulIPAddress;                      //  IP Address for the cluster
    ULONG                   m_ulIPSubnet;                       //  Subnet mask for the cluster
    BSTR                    m_bstrNetworkName;                  //  Name of network for IP address
    HANDLE                  m_hCancelCleanupEvent;              //  Used to signal when the cancel cleanup task is complete

    IServiceProvider  * m_psp;                              //  Middle Tier Service Manager

    HMODULE             m_hRichEdit;                        //  RichEdit's module handle

    SNamedCookie            m_ncCluster;
    BSTR                    m_bstrClusterDomain;
    BOOL                    m_fDefaultedDomain;
    NamedCookieArray        m_ncaNodes;
    OBJECTCOOKIE            m_cookieCompletion;
    BOOL                    m_fMinimalConfig;               // Minimal analysis and config chosen?

    IConnectionPointContainer *     m_pcpc;
    ITaskManager *                  m_ptm;
    IObjectManager *                m_pom;

    // INotifyUI
    DWORD                           m_dwCookieNotify;       // Notification registration cookie

private:
    CClusCfgWizard( void );
    ~CClusCfgWizard( void );

    HRESULT HrInit( void );

    // Private copy constructor to prevent copying.
    CClusCfgWizard( const CClusCfgWizard & );

    // Private assignment operator to prevent copying.
    CClusCfgWizard & operator=( const CClusCfgWizard & );

    HRESULT
        HrAddWizardPage( LPPROPSHEETHEADER  ppshInout,
                         UINT               idTemplateIn,
                         DLGPROC            pfnDlgProcIn,
                         UINT               idTitleIn,
                         UINT               idSubtitleIn,
                         LPARAM             lParam
                         );

public:
    static HRESULT S_HrCreateInstance( CClusCfgWizard ** ppccwOut );
    HRESULT HrLaunchCleanupTask( void );
    BOOL    FHasClusterName( void ) const;
    BOOL    FDefaultedClusterDomain( void ) const;

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, PVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWizard methods
    //
    STDMETHOD( CreateCluster )( HWND lParentWndIn, BOOL * pfDoneOut );
    STDMETHOD( AddClusterNodes )( HWND lParentWndIn, BOOL * pfDoneOut );
    STDMETHOD( get_ClusterName )( BSTR * pbstrClusterNameOut );
    STDMETHOD( put_ClusterName )( BSTR bstrClusterNameIn );
    STDMETHOD( get_ServiceAccountUserName )( BSTR * pbstrAccountNameOut );
    STDMETHOD( put_ServiceAccountUserName )( BSTR bstrAccountNameIn );
    STDMETHOD( put_ServiceAccountPassword )( BSTR bstrPasswordIn );
    STDMETHOD( get_ServiceAccountDomainName )( BSTR * pbstrDomainOut );
    STDMETHOD( put_ServiceAccountDomainName )( BSTR bstrDomainIn );
    STDMETHOD( get_ClusterIPAddress )( BSTR * pbstrIPAddressOut );
    STDMETHOD( put_ClusterIPAddress )( BSTR bstrIPAddressIn );
    STDMETHOD( get_ClusterIPSubnet )( BSTR * pbstrIPSubnetOut );
    STDMETHOD( put_ClusterIPSubnet )( BSTR bstrIPSubnetIn );
    STDMETHOD( get_ClusterIPAddressNetwork )( BSTR * pbstrNetworkNameOut );
    STDMETHOD( put_ClusterIPAddressNetwork )( BSTR bstrNetworkNameIn );
    STDMETHOD( AddComputer )( BSTR bstrComputerNameIn );
    STDMETHOD( RemoveComputer )( BSTR bstrComputerNameIn );
    STDMETHOD( ClearComputerList )( void );
    STDMETHOD( get_MinimumConfiguration )( BOOL * pfMinimumConfigurationOut );
    STDMETHOD( put_MinimumConfiguration )( BOOL fMinimumConfigurationIn );

    //
    //  Non-COM public methods: cluster access
    //
    STDMETHOD( HrSetClusterName )( LPCWSTR pwcszClusterNameIn, bool fAcceptNonRFCCharsIn );
    STDMETHOD( HrGetClusterDomain )( BSTR* pbstrDomainOut );
    STDMETHOD( HrGetClusterObject )( IClusCfgClusterInfo ** ppClusterOut );
    STDMETHOD( HrGetClusterCookie )( OBJECTCOOKIE * pocClusterOut );
    STDMETHOD( HrGetClusterChild )( REFCLSID rclsidChildIn, REFGUID rguidFormatIn, IUnknown ** ppunkChildOut );
    STDMETHOD( HrReleaseClusterObject )( void );

    //
    //  Non-COM public methods: node access
    //
    STDMETHOD( HrAddNode )( LPCWSTR pwcszNodeNameIn, bool fAcceptNonRFCCharsIn );
    STDMETHOD( HrGetNodeCount )( size_t* pcNodesOut );
    STDMETHOD( HrGetNodeObject )( size_t idxNodeIn, IClusCfgNodeInfo ** ppNodeOut );
    STDMETHOD( HrGetNodeCookie )( size_t idxNodeIn, OBJECTCOOKIE * pocNodeOut );
    STDMETHOD( HrGetNodeName )( size_t idxNodeIn, BSTR * pbstrNodeNameOut );
    STDMETHOD( HrGetNodeChild )( size_t idxNodeIn, REFCLSID rclsidChildIn, REFGUID rguidFormatIn, IUnknown** ppunkChildOut );
    STDMETHOD( HrReleaseNodeObjects )( void );

    //
    //  Non-COM public methods: task access
    //
    STDMETHOD( HrCreateTask )( REFGUID rguidTaskIn, IUnknown** ppunkOut );
    STDMETHOD( HrSubmitTask)( IDoTask* pTaskIn );

    //
    //  Non-COM public methods: completion task access
    //
    STDMETHOD( HrGetCompletionCookie )( REFGUID rguidTaskIn, OBJECTCOOKIE * pocTaskOut );
    STDMETHOD( HrGetCompletionStatus )( OBJECTCOOKIE ocTaskIn, HRESULT * phrStatusOut );
    STDMETHOD( HrReleaseCompletionObject )( OBJECTCOOKIE ocTaskIn );

    //
    //  Non-COM public methods: connection point access
    //
    STDMETHOD( HrAdvise )( REFIID riidConnectionIn, IUnknown * punkConnectionIn, DWORD * pdwCookieOut );
    STDMETHOD( HrUnadvise )( REFIID riidConnectionIn, DWORD dwCookieIn );

    //
    //  Non-COM public methods: miscellaneous
    //
    STDMETHOD( HrIsCompatibleNodeDomain )( LPCWSTR pcwszDomainIn );
    STDMETHOD( HrCreateMiddleTierObjects )( void );
    STDMETHOD( HrFilterNodesWithBadDomains )( BSTR * pbstrBadNodesOut );
//    STDMETHOD( HrReadSettings )( EConfigurationSettings * pecsSettingIn, BOOL * pfValuePresentOut = NULL );
//    STDMETHOD( HrWriteSettings )( EConfigurationSettings ecsSettingIn, BOOL fDeleteValueIn = FALSE );

    //
    //  INotifyUI
    //
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; //*** class CClusCfgWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\advanceddlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 20002 Microsoft Corporation
//
//  Module Name:
//      AdvancedDlg.cpp
//
//  Maintained By:
//      Galen Barbee    (GalenB)    10-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "AdvancedDlg.h"
#include "WizardUtils.h"
#include "WizardHelp.h"
#include "SummaryPage.h"
#include <HtmlHelp.h>


//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////


DEFINE_THISCLASS("AdvancedDlg");

//////////////////////////////////////////////////////////////////////////////
//  Context-sensitive help table.
//////////////////////////////////////////////////////////////////////////////
const DWORD g_rgidAdvancedDlgHelpIDs[] =
{
    IDC_ADVANCED_RB_FULL_CONFIG,        IDH_ADVANCED_RB_FULL_CONFIG,
    IDC_ADVANCED_S_FULL_CONFIG_DESC,    IDH_ADVANCED_RB_FULL_CONFIG,
    IDC_ADVANCED_RB_MIN_CONFIG,         IDH_ADVANCED_RB_MIN_CONFIG,
    IDC_ADVANCED_S_MIN_CONFIG_DESC,     IDH_ADVANCED_RB_MIN_CONFIG,
    IDC_ADVANCED_S_MIN_CONFIG_DESC2,    IDH_ADVANCED_RB_MIN_CONFIG,
    IDC_ADVANCED_S_MIN_CONFIG_DESC3,    IDH_ADVANCED_RB_MIN_CONFIG,
    0, 0
};

//////////////////////////////////////////////////////////////////////////////
//  Static Function Prototypes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::S_HrDisplayModalDialog
//
//  Description:
//      Display the dialog box.
//
//  Arguments:
//      hwndParentIn    - Parent window for the dialog box.
//      pccwIn          - CClusCfgWizard pointer for talking to the middle tier.
//      pssaOut         - array of all the initial IsManaged states
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAdvancedDlg::S_HrDisplayModalDialog(
      HWND              hwndParentIn
    , CClusCfgWizard *  pccwIn
    )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );

    HRESULT hr = S_OK;
    INT_PTR dlgResult = IDOK;

    //
    //  Display the dialog.
    //

    {
        CAdvancedDlg  dlg( pccwIn );

        dlgResult = DialogBoxParam(
              g_hInstance
            , MAKEINTRESOURCE( IDD_ADVANCED )
            , hwndParentIn
            , CAdvancedDlg::S_DlgProc
            , (LPARAM) &dlg
            );

        if ( dlgResult == IDOK )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:
    }

    HRETURN( hr );

} //*** CAdvancedDlg::S_HrDisplayModalDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::CAdvancedDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn  - CClusCfgWizard for talking to the middle tier.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAdvancedDlg::CAdvancedDlg(
      CClusCfgWizard * pccwIn
    )
    : m_pccw( pccwIn )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );

    // m_hwnd
    m_pccw->AddRef();

    TraceFuncExit();

} //*** CAdvancedDlg::CAdvancedDlg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::~CAdvancedDlg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAdvancedDlg::~CAdvancedDlg( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    } // if:

    TraceFuncExit();

} //*** CAdvancedDlg::~CAdvancedDlg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::S_DlgProc
//
//  Description:
//      Dialog proc for the Quorum dialog box.
//
//  Arguments:
//      hwndDlgIn   - Dialog box window handle.
//      nMsgIn      - Message ID.
//      wParam      - Message-specific parameter.
//      lParam      - Message-specific parameter.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//  Remarks:
//      It is expected that this dialog box is invoked by a call to
//      DialogBoxParam() with the lParam argument set to the address of the
//      instance of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CAdvancedDlg::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CAdvancedDlg *  pdlg;

    //
    // Get a pointer to the class.
    //

    if ( nMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, lParam );
        pdlg = reinterpret_cast< CAdvancedDlg * >( lParam );
        pdlg->m_hwnd = hwndDlgIn;
    } // if:
    else
    {
        pdlg = reinterpret_cast< CAdvancedDlg * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    } // else:

    if ( pdlg != NULL )
    {
        Assert( hwndDlgIn == pdlg->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pdlg->OnInitDialog();
                break;

            case WM_COMMAND:
                lr = pdlg->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            case WM_HELP:
                WinHelp(
                        (HWND)((LPHELPINFO) lParam)->hItemHandle,
                        CLUSCFG_HELP_FILE,
                        HELP_WM_HELP,
                        (ULONG_PTR) g_rgidAdvancedDlgHelpIDs
                       );
                break;

            case WM_CONTEXTMENU:
                WinHelp(
                        (HWND)wParam,
                        CLUSCFG_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) g_rgidAdvancedDlgHelpIDs
                       );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CAdvancedDlg::S_DlgProc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Focus has been set.
//      FALSE       Focus has not been set.
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAdvancedDlg::OnInitDialog( void )
{
    TraceFunc( "" );
    Assert( m_pccw != NULL );

    LRESULT                 lr = FALSE; // did not set focus
    HRESULT                 hr = S_OK;
//    EConfigurationSettings  ecsConfigType = csFullConfig;
//    BOOL                    fValuePresent = FALSE;
    BOOL                    fMinConfig = FALSE;

    //
    //  It's no big deal if we cannot read the settings from the registry
    //  since everything defaults to full config.
    //

//    STHR( m_pccw->HrReadSettings( &ecsConfigType, &fValuePresent ) );

    //
    //  If the value is not present then we have to get the minconfig state from
    //  the wizard.
    //
/*
    if ( fValuePresent == FALSE )
    {
        BOOL    fMinConfig;

        hr = THR( m_pccw->get_MinimalConfiguration( &fMinConfig ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( fMinConfig )
        {
            ecsConfigType = csMinConfig;
        } // if:
    } // if:

    SendDlgItemMessage( m_hwnd, IDC_ADVANCED_RB_MIN_CONFIG, BM_SETCHECK, ecsConfigType == csMinConfig ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( m_hwnd, IDC_ADVANCED_RB_FULL_CONFIG, BM_SETCHECK, ecsConfigType != csMinConfig ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( m_hwnd, IDC_ADVANCED_CB_MAKE_DEFAULT, BM_SETCHECK, fValuePresent ? BST_CHECKED : BST_UNCHECKED, 0 );
*/

    hr = THR( m_pccw->get_MinimumConfiguration( &fMinConfig ) );
    if ( FAILED( hr ) )
    {
        fMinConfig = FALSE;
    } // if:

    SendDlgItemMessage( m_hwnd, IDC_ADVANCED_RB_MIN_CONFIG, BM_SETCHECK, fMinConfig ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( m_hwnd, IDC_ADVANCED_RB_FULL_CONFIG, BM_SETCHECK, fMinConfig ? BST_UNCHECKED : BST_CHECKED, 0 );

//Cleanup:

    RETURN( lr );

} //*** CAdvancedDlg::OnInitDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::OnCommand
//
//  Description:
//      Handler for the WM_COMMAND message.
//
//  Arguments:
//      idNotificationIn    - Notification code.
//      idControlIn         - Control ID.
//      hwndSenderIn        - Handle for the window that sent the message.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAdvancedDlg::OnCommand(
      UINT  idNotificationIn
    , UINT  idControlIn
    , HWND  hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDOK:
            THR( HrOnOK() );
            EndDialog( m_hwnd, IDOK );
            break;

        case IDCANCEL:
            EndDialog( m_hwnd, IDCANCEL );
            break;

        case IDHELP:
            HtmlHelp( m_hwnd, L"mscsconcepts.chm::/SAG_MSCS3setup_21.htm", HH_DISPLAY_TOPIC, 0 );
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CAdvancedDlg::OnCommand


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAdvancedDlg::HrOnOK
//
//  Description:
//      Processing to be done when OK is pressed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAdvancedDlg::HrOnOK( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    LRESULT lr;
    BOOL    fMinimalConfig = FALSE;
//    BOOL    fMakeDefault = FALSE;

    lr = SendDlgItemMessage( m_hwnd, IDC_ADVANCED_RB_MIN_CONFIG, BM_GETCHECK, 0, 0 );
    fMinimalConfig = ( lr == BST_CHECKED );

//    lr = SendDlgItemMessage( m_hwnd, IDC_ADVANCED_CB_MAKE_DEFAULT, BM_GETCHECK, 0, 0 );
//    fMakeDefault = ( lr == BST_CHECKED );

    hr = THR( m_pccw->put_MinimumConfiguration( fMinimalConfig ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  It's okay if this fails because we have already set the config choice for this
    //  session.  It's no big deal if we cannot write the settings into the registry
    //  since everything defaults to full config.
    //

//    THR( m_pccw->HrWriteSettings( fMinimalConfig ? csMinConfig : csFullConfig, !fMakeDefault ) );

Cleanup:

    HRETURN( hr );

} //*** CAdvancedDlg::HrOnOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\commitpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CommitPage.h
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCommitPage
    : public INotifyUI
    , public IClusCfgCallback
{

private: // data
    HWND                        m_hwnd;                     // Our HWND
    CClusCfgWizard *            m_pccw;                     // Wizard
    BOOL                        m_fNext;                    // If Next was pressed...
    BOOL                        m_fDisableBack;             // When we passed the point of no return.
    BOOL                        m_fAborted;                 // Back was pressed and we need to tell the servers to abort.
    BOOL                        m_fPassedPointOfNoReturn;   // If we passed the point of no return
    ECreateAddMode              m_ecamCreateAddMode;        // Creating or Adding?
    HTREEITEM                   m_htiReanalyze;             // Reanalyze tree item handle.
    ITaskCommitClusterChanges * m_ptccc;

    BOOL                    m_rgfSubReanalyzeAdded[ 5 ];

    //  IUnknown
    LONG                    m_cRef;             // Reference count

    //  IClusCfgCallback
    OBJECTCOOKIE            m_cookieCompletion; // Completion cookie
    BOOL                    m_fTaskDone;        // Is the task done yet?
    HRESULT                 m_hrResult;         // Result of the analyze task
    CTaskTreeView *         m_pttv;             // Task TreeView
    BSTR                    m_bstrLogMsg;       // Logging message buffer
    DWORD                   m_dwCookieCallback; // Notification registration cookie

    //  INotifyUI
    DWORD                   m_dwCookieNotify;   // Notification registration cookie

private: // methods
    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifyWizBack( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrUpdateWizardButtons( void );
    HRESULT HrCleanupCommit( void );
    HRESULT HrUnAdviseConnections( void );

public: // methods
    CCommitPage(
              CClusCfgWizard *  pccwIn
            , ECreateAddMode    ecamCreateAddModeIn
             );
    ~CCommitPage( void );

    static INT_PTR CALLBACK S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                  LPCWSTR    pcszNodeNameIn
                , CLSID      clsidTaskMajorIn
                , CLSID      clsidTaskMinorIn
                , ULONG      ulMinIn
                , ULONG      ulMaxIn
                , ULONG      ulCurrentIn
                , HRESULT    hrStatusIn
                , LPCWSTR    pcszDescriptionIn
                , FILETIME * pftTimeIn
                , LPCWSTR    pcszReferenceIn
                );

}; //*** class CCommitPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\completionpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CompletionPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CompletionPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CCompletionPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCompletionPage::CCompletionPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      idsTitleIn      -- Resource ID for the title string.
//      idsDescIn       -- Resource ID for the description string.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCompletionPage::CCompletionPage(
      UINT  idsTitleIn
    , UINT  idsDescIn
    )
{
    TraceFunc( "" );

    Assert( idsTitleIn != 0 );
    Assert( idsDescIn != 0 );

    //  m_hwnd
    m_hFont = NULL;

    m_idsTitle = idsTitleIn;
    m_idsDesc  = idsDescIn;

    TraceFuncExit();

} //*** CCompletionPage::CCompletionPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCompletionPage::~CCompletionPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCompletionPage::~CCompletionPage( void )
{
    TraceFunc( "" );
    
    if ( m_hFont != NULL )
    {
        DeleteObject( m_hFont );
    }

    TraceFuncExit();

} //*** CCompletionPage::~CCompletionPage( void )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr      = FALSE;
    HDC     hdc     = NULL;
    HRESULT hr;

    NONCLIENTMETRICS ncm;

    LOGFONT LogFont;
    INT     iSize;

    DWORD   dw;
    BOOL    fRet;
    BSTR    bstr = NULL;

    WCHAR   szFontSize[ 3 ];    // shouldn't be bigger than 2 digits!!

    //
    //  TODO:   gpease  12-MAY-2000
    //          Fill in the summary control.
    //

    //
    //  Make the Title static BIG and BOLD. Why the wizard control itself can't
    //  do this is beyond me!
    //

    ZeroMemory( &ncm, sizeof( ncm ) );
    ZeroMemory( &LogFont, sizeof( LOGFONT ) );

    //
    //  Find out the system default font metrics.
    //
    ncm.cbSize = sizeof( ncm );
    fRet = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    if ( ! fRet )
    {
        goto Win32Error;
    }

    //
    //  Copy it.
    //
    LogFont = ncm.lfMessageFont;

    //
    //  Make it BOLD.
    //
    LogFont.lfWeight = FW_BOLD;

    //
    //  Find out what we want it to look like.
    //
    dw = LoadString( g_hInstance, IDS_LARGEFONTNAME, LogFont.lfFaceName, ARRAYSIZE( LogFont.lfFaceName) );
    AssertMsg( dw != 0, "String missing!" );

    dw = LoadString( g_hInstance, IDS_LARGEFONTSIZE, szFontSize, ARRAYSIZE( szFontSize ) );
    AssertMsg( dw != 0, "String missing!" );

    iSize = wcstoul( szFontSize, NULL, 10 );

    //
    //  Grab the DC.
    //
    hdc = GetDC( m_hwnd );
    if ( hdc == NULL )
    {
        goto Win32Error;
    }

    //
    //  Use the magic equation....
    //
    LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * iSize / 72 );

    //
    //  Create the font.
    //
    m_hFont = CreateFontIndirect( &LogFont );
    if ( m_hFont == NULL )
    {
        goto Win32Error;
    }

    //
    //  Apply the font.
    //
    SetWindowFont( GetDlgItem( m_hwnd, IDC_COMPLETION_S_TITLE ), m_hFont, TRUE );

    //
    // Set the text of the title control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsTitle, &bstr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_COMPLETION_S_TITLE, bstr );

    //
    // Set the text of the description control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsDesc, &bstr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_COMPLETION_S_DESC, bstr );

    goto Cleanup;

Win32Error:
    TW32( GetLastError() );

Cleanup:
    TraceSysFreeString( bstr );
    if ( hdc != NULL )
    {
        ReleaseDC( m_hwnd, hdc);
    }

    RETURN( lr );

} //*** CCompletionPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            // Disable cancel
            EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), FALSE );

            // Show Finish
            PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_FINISH );
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CCompletionPage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_COMPLETION_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CCompletionPage::OnCommand()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR 
//  CALLBACK
//  CCompletionPage::S_DlgProc( 
//      HWND    hwndDlgIn, 
//      UINT    nMsgIn, 
//      WPARAM  wParam, 
//      LPARAM  lParam 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR 
CALLBACK
CCompletionPage::S_DlgProc( 
    HWND    hwndDlgIn, 
    UINT    nMsgIn, 
    WPARAM  wParam, 
    LPARAM  lParam 
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCompletionPage * pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCompletionPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CCompletionPage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CCompletionPage::S_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\csaccountpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CSAccountPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CSAccountPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CCSAccountPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::CCSAccountPage(
//      CClusCfgWizard *    pccwIn,
//      ECreateAddMode      ecamCreateAddModeIn,
//      BSTR *              pbstrUsernameIn,
//      BSTR *              pbstrPasswordIn,
//      BSTR *              pbstrDomainIn,
//      BSTR *              pbstrClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCSAccountPage::CCSAccountPage(
    CClusCfgWizard *        pccwIn,
    ECreateAddMode          ecamCreateAddModeIn,
    IClusCfgCredentials *   pcccIn
    )
    : m_pccw( pccwIn )
    , m_pccc( pcccIn )
{
    TraceFunc( "" );

    //  m_hwnd
    Assert( pccwIn != NULL );
    m_pccw->AddRef();

    Assert( pcccIn != NULL );
    m_pccc->AddRef();

    m_ecamCreateAddMode = ecamCreateAddModeIn;

    m_cRef = 0;
    m_ptgd = NULL;

    TraceFuncExit();

} //*** CCSAccountPage::CCSAccountPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::~CCSAccountPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCSAccountPage::~CCSAccountPage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    }

    if ( m_ptgd != NULL )
    {
        //  Make sure we don't get called anymore.
        THR( m_ptgd->SetCallback( NULL ) );

        m_ptgd->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCSAccountPage::~CCSAccountPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;

    BSTR    bstrUser = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrPassword = NULL;

    IUnknown * punkTask = NULL;

    LRESULT lr = FALSE;

    //
    // (jfranco, bug #477671) Limit user name length to ADJUSTED_DNS_MAX_NAME_LENGTH
    // according to msdn, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns
    //
    SendDlgItemMessage( m_hwnd, IDC_CSACCOUNT_E_USERNAME, EM_SETLIMITTEXT, ADJUSTED_DNS_MAX_NAME_LENGTH, 0 );

    //
    // (jfranco, bug #462673) Limit domain length to ADJUSTED_DNS_MAX_NAME_LENGTH.
    // According to MSDN, the return value of CB_LIMITTEXT is always true, so ignore what SendDlgItemMessage returns
    //

    SendDlgItemMessage( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN, CB_LIMITTEXT, ADJUSTED_DNS_MAX_NAME_LENGTH, 0 );

    //
    //  Create the task to get the domains.
    //

    hr = THR( m_pccw->HrCreateTask( TASK_GetDomains, &punkTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkTask->TypeSafeQI( ITaskGetDomains, &m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptgd->SetCallback( static_cast< ITaskGetDomainsCallback * >( this ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccw->HrSubmitTask( m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Default to the script supplied information.
    //
    hr = THR( m_pccc->GetCredentials( &bstrUser, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_USERNAME, bstrUser );
    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_PASSWORD, bstrPassword );
    SecureZeroMemory( bstrPassword, SysStringLen( bstrPassword ) * sizeof( *bstrPassword ) );

    if ( SysStringLen( bstrDomain ) > 0 )
    {
        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN, bstrDomain );
        TraceMemoryAddBSTR( bstrDomain );
    }
    else
    {
        //
        //  Use the cluster's domain.
        //

        hr = THR( m_pccw->HrGetClusterDomain( &bstrDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN, bstrDomain );
    }

Cleanup:

    OnUpdateWizardButtons(); // Ignore return value because OnUpdateWizardButtons always returns true, but we want OnInitDialog to return false.

    if ( punkTask != NULL )
    {
        punkTask->Release();
    }

    SysFreeString( bstrUser );
    TraceSysFreeString( bstrDomain );
    SysFreeString( bstrPassword );

    RETURN( lr );

} //*** CCSAccountPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_CSACCOUNT_E_PASSWORD:
        case IDC_CSACCOUNT_E_USERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                lr = OnUpdateWizardButtons();
            }
            break;

        case IDC_CSACCOUNT_CB_DOMAIN:
            if ( ( idNotificationIn == CBN_EDITCHANGE ) || ( idNotificationIn == CBN_SELENDOK ) )
            {
                if ( PostMessage( m_hwnd, WM_CCW_UPDATEBUTTONS, 0, 0 ) == 0 )
                {
                    TW32( GetLastError() );
                }
                lr = TRUE;
            }
            break;

    }

    RETURN( lr );

} //*** CCSAccountPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnUpdateWizardButtons( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;
    DWORD   mEnabledButtons = PSWIZB_BACK;
    HWND    hwndUser = GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME );
    HWND    hwndDomain = GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN );
    BOOL    fUserIsDNSName = FALSE;

    //
    //  Password could be blank so don't count on it!
    //

    hr = STHR( HrGetPrincipalName( hwndUser, hwndDomain, &bstrName, &bstrDomain, &fUserIsDNSName ) );
    if ( hr == S_OK )
    {
        mEnabledButtons |= PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), mEnabledButtons );
    EnableWindow( hwndDomain, !fUserIsDNSName );

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDomain );

    RETURN( lr );
} //*** CCSAccountPage::OnUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    } // if:
    else
    {
        THR( m_pccw->HrLaunchCleanupTask() );
    } // else:

    RETURN( lr );

} //*** CCSAccountPage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT hr;

    LRESULT lr = TRUE;

    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;

    BSTR    bstrUsername    = NULL;
    BSTR    bstrDomain      = NULL;

    if ( m_ecamCreateAddMode == camADDING )
    {
        //
        //  See if the cluster configuration information has something
        //  different.
        //

        hr = THR( m_pccw->HrGetClusterObject( &pccci ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( piccc->GetIdentity( &bstrUsername, &bstrDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrUsername );
        TraceMemoryAddBSTR( bstrDomain );

        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_USERNAME, bstrUsername );
        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN,  bstrDomain );

        //
        //  Disable the username and domain windows.
        //

        EnableWindow( GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME ), FALSE );
        EnableWindow( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ), FALSE );
    }

Cleanup:
    lr = OnUpdateWizardButtons();

    if ( piccc != NULL )
    {
        piccc->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrDomain );

    RETURN( lr );

} //*** CCSAccountPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT hr;
    HWND    hwnd;
    DWORD   dwLen;

    BSTR    bstrUsername = NULL;
    BSTR    bstrPassword = NULL;
    BSTR    bstrDomain = NULL;

    LRESULT lr = TRUE;

    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;

    //
    //  Get the user and domain names from the UI.
    //
    hr = THR( HrGetPrincipalName(
          GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME )
        , GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN )
        , &bstrUsername
        , &bstrDomain
        ) );
    if ( hr != S_OK )
    {
        goto Error;
    }

    //
    //  Get the password from the UI.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_PASSWORD );
    Assert( hwnd != NULL );

    dwLen = GetWindowTextLength( hwnd );


    bstrPassword = TraceSysAllocStringLen( NULL, dwLen );
    if ( bstrPassword == NULL )
    {
        goto OutOfMemory;
    }

    GetWindowText( hwnd, bstrPassword, dwLen + 1 );

    THR( m_pccc->SetCredentials( bstrUsername, bstrDomain, bstrPassword ) );
    SecureZeroMemory( bstrPassword, SysStringLen( bstrPassword ) * sizeof( *bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Get the cluster configuration info.
    //

    hr = THR( m_pccw->HrGetClusterObject( &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Set the cluster service account credentials...
    //

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_pccc->AssignTo( piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

Cleanup:

    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrPassword );
    TraceSysFreeString( bstrDomain );

    if ( piccc != NULL )
    {
        piccc->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    RETURN( lr );

Error:

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

OutOfMemory:

    goto Error;

} //*** CCSAccountPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive();
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext();
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel();
        break;
    }

    RETURN( lr );

} //*** CCSAccountPage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCSAccountPage::S_DlgProc(
//      HWND hDlgIn,
//      UINT MsgIn,
//      WPARAM wParam,
//      LPARAM lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCSAccountPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCSAccountPage * pPage = reinterpret_cast< CCSAccountPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCSAccountPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog();
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_COMMAND:
            lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
            break;

        case WM_CCW_UPDATEBUTTONS:
            lr = pPage->OnUpdateWizardButtons();
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CCSAccountPage::S_DlgProc



// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGetDomainsCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomainsCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGetDomainsCallback, this, 0 );
    } // else if: ITaskGetDomainsCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCSAccountPage::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCSAccountPage::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCSAccountPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCSAccountPage::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCSAccountPage::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCSAccountPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    CRETURN( cRef );

} //*** CCSAccountPage::Release


//****************************************************************************
//
//  ITaskGetDomainsCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCSAccountPage::ReceiveDomainResult(
//      HRESULT hrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr;

    hr = THR( m_ptgd->SetCallback( NULL ) );

    HRETURN( hr );

} //*** CCSAccountPage::ReceiveResult

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCSAccountPage::ReceiveDomainName(
//      LPCWSTR pcszDomainIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::ReceiveDomainName(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr = S_OK;

    ComboBox_AddString( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ), pcszDomainIn );

    HRETURN( hr );

} //*** CCSAccountPage::ReceiveName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\delimitediterator.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DelimitedIterator.cpp
//
//  Header Files:
//      DelimitedIterator.h
//
//  Description:
//      This file contains the implementation of the CDelimitedIterator class.
//
//  Maintained By:
//      John Franco (jfranco) 26-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "DelimitedIterator.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CDelimitedIterator" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CDelimitedIterator class
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDelimitedIterator::CDelimitedIterator
//
//  Description:
//
//  Arguments:
//      pwszDelimitersIn
//          A null-terminated string consisting of those characters to treat
//          as delimiters.
//      pwszDelimitedListIn
//          The null-terminated string containing the delimited items.
//      cchListIn
//          The number of characters in pwszDelimitedListIn.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CDelimitedIterator::CDelimitedIterator(
      LPCWSTR   pwszDelimitersIn
    , LPWSTR    pwszDelimitedListIn
    , size_t    cchListIn
    )
    : m_pwszDelimiters( pwszDelimitersIn )
    , m_pwszList( pwszDelimitedListIn )
    , m_cchList( cchListIn )
    , m_idxCurrent( 0 )
    , m_idxNext( 0 )
{
    Assert( pwszDelimitersIn != NULL );
    Assert( pwszDelimitedListIn != NULL );
    IsolateCurrent();

} //*** CDelimitedIterator::CDelimitedIterator


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDelimitedIterator::IsolateCurrent
//
//  Description:
//      Advance the current pointer to the next item (if any) in the list,
//      null out the first delimiter (if any) following the item, and advance
//      the next pointer to where the search for the next item should begin
//      after the iterator has advanced.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDelimitedIterator::IsolateCurrent( void )
{
    //  Skip any initial delimiters.
    while ( ( m_idxCurrent < m_cchList ) && ( wcschr( m_pwszDelimiters, m_pwszList[ m_idxCurrent ] ) != NULL ) )
    {
        m_idxCurrent += 1;
    }
    
    //  Null next delimiter, if one exists, and remember its location (for finding next delimited item).
    if ( m_idxCurrent < m_cchList )
    {
        WCHAR * pwchNextDelimiter = wcspbrk( m_pwszList + m_idxCurrent, m_pwszDelimiters );
        if ( pwchNextDelimiter != NULL )
        {
            *pwchNextDelimiter = L'\0';
            m_idxNext = ( pwchNextDelimiter - m_pwszList ) + 1; // +1 means start after char that's null.
        }
        else // No more delimiters in string.
        {
            m_idxNext = m_cchList;
        }
    } // if not yet at end of string

} //*** CDelimitedIterator::IsolateCurrent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\completionpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CompletionPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCompletionPage
{

private: // data
    HWND            m_hwnd;         // Our HWND
    HFONT           m_hFont;        // Title font
    UINT            m_idsTitle;     // Resource ID for the title string
    UINT            m_idsDesc;      // Resource ID for the description string.

private: // methods
    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

public: // methods
    CCompletionPage( UINT idsTitleIn, UINT idsDescIn );
    virtual ~CCompletionPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CCompletionPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\createclusterwizard.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CreateClusterWizard.h
//
//  Description:
//      Declaration of the CCreateClusterWizard class.
//
//  Maintained By:
//      John Franco    (jfranco)    17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCreateClusterWizard
//
//  Description:
//      The Create Cluster Wizard object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCreateClusterWizard
    : public TDispatchHandler< IClusCfgCreateClusterWizard >
{
private:

    CClusCfgWizard *    m_pccw;
    BSTR                m_bstrFirstNodeInCluster;
    LONG                m_cRef;

    // Private constructors and destructors
    CCreateClusterWizard( void );
    virtual ~CCreateClusterWizard( void );
    virtual HRESULT HrInit( void );    

    // Private copy constructor to prevent copying.
    CCreateClusterWizard( const CCreateClusterWizard & );

    // Private assignment operator to prevent copying.
    CCreateClusterWizard & operator=( const CCreateClusterWizard & );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, PVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgCreateClusterWizard
    //
    STDMETHOD( put_ClusterName )( BSTR    bstrClusterNameIn );
    STDMETHOD( get_ClusterName )( BSTR * pbstrClusterNameOut );

    STDMETHOD( put_ServiceAccountName )( BSTR      bstrServiceAccountNameIn );
    STDMETHOD( get_ServiceAccountName )( BSTR * pbstrServiceAccountNameOut );

    STDMETHOD( put_ServiceAccountDomain )( BSTR      bstrServiceAccountDomainIn );
    STDMETHOD( get_ServiceAccountDomain )( BSTR * pbstrServiceAccountDomainOut );

    STDMETHOD( put_ServiceAccountPassword )( BSTR bstrPasswordIn );

    STDMETHOD( put_ClusterIPAddress )( BSTR      bstrClusterIPAddressIn );
    STDMETHOD( get_ClusterIPAddress )( BSTR * pbstrClusterIPAddressOut );

    STDMETHOD( get_ClusterIPSubnet )( BSTR * pbstrClusterIPSubnetOut );
    STDMETHOD( get_ClusterIPAddressNetwork )( BSTR * pbstrClusterNetworkNameOut );

    STDMETHOD( put_FirstNodeInCluster )( BSTR     bstrFirstNodeInClusterIn );
    STDMETHOD( get_FirstNodeInCluster )( BSTR * pbstrFirstNodeInClusterOut );

    STDMETHOD( put_MinimumConfiguration )( VARIANT_BOOL   fMinConfigIn );
    STDMETHOD( get_MinimumConfiguration )( VARIANT_BOOL * pfMinConfigOut );

    STDMETHOD( ShowWizard )( long lParentWindowHandleIn, VARIANT_BOOL * pfCompletedOut );
    
}; //*** class CCreateClusterWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\createclusterwizard.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CreateClusterWizard.cpp
//
//  Description:
//      Implementation of CCreateClusterWizard class.
//
//  Maintained By:
//      John Franco    (jfranco)    17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CreateClusterWizard.h"

//****************************************************************************
//
//  CCreateClusterWizard
//
//****************************************************************************

DEFINE_THISCLASS( "CCreateClusterWizard" )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::S_HrCreateInstance
//
//  Description:
//      Creates a CCreateClusterWizard instance.
//
//  Arguments:
//      ppunkOut        - The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Not enough memory to create the object.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateClusterWizard::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CCreateClusterWizard *   pccw = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pccw = new CCreateClusterWizard();
    if ( pccw == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pccw->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccw->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pccw != NULL )
    {
        pccw->Release();
    }

    HRETURN( hr );

} //*** CCreateClusterWizard::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::CCreateClusterWizard
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCreateClusterWizard::CCreateClusterWizard( void )
    : m_pccw( NULL )
    , m_bstrFirstNodeInCluster( NULL )
    , m_cRef( 1 )
{
} //*** CCreateClusterWizard::CCreateClusterWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::~CCreateClusterWizard
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCreateClusterWizard::~CCreateClusterWizard( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    TraceSysFreeString( m_bstrFirstNodeInCluster );
    TraceFuncExit();

} //*** CCreateClusterWizard::~CCreateClusterWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesWizard::HrInit
//
//  Description:
//      Initialize the object instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateClusterWizard::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    // Initialize the IDispatch handler to support the scripting interface.
    //
    hr = THR( TDispatchHandler< IClusCfgCreateClusterWizard >::HrInit( LIBID_ClusCfgWizard ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    // Create the wizard object.
    //
    hr = THR( CClusCfgWizard::S_HrCreateInstance( &m_pccw ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CCreateClusterWizard::HrInit


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::QueryInterface(
      REFIID    riidIn
    , PVOID *   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCreateClusterWizard ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCreateClusterWizard, this, 0 );
    } // else if: IClusCfgCreateClusterWizard
    else if (   IsEqualIID( riidIn, IID_IDispatch ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatch, this, 0 );
    } // else if: IDispatch
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCreateClusterWizard::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::AddRef
//
//  Description:
//      Add a reference to this instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CCreateClusterWizard::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCreateClusterWizard::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::Release
//
//  Description:
//      Release a reference to this instance.  If it is the last reference
//      the object instance will be deallocated.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CCreateClusterWizard::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        delete this;
    }

    CRETURN( cRef );

} //*** CCreateClusterWizard::Release


//****************************************************************************
//
//  IClusCfgCreateClusterWizard
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_ClusterName
//
//  Description:
//      Set the cluster name to create.
//
//  Arguments:
//      bstrClusterNameIn   - The name of the cluster.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_ClusterName( BSTR bstrClusterNameIn )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = S_OK;
    BSTR    bstrClusterLabel = NULL;
    PCWSTR  pwcszClusterLabel = NULL;

    if ( bstrClusterNameIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  If the name is fully-qualified, split out just the label for validity test;
    //  otherwise, use the given name in the validity test.
    //
    hr = STHR( HrIsValidFQN( bstrClusterNameIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_OK )
    {
        //
        //  Name is fully-qualified.
        //
        hr = THR( HrExtractPrefixFromFQN( bstrClusterNameIn, &bstrClusterLabel ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        pwcszClusterLabel = bstrClusterLabel;
    }
    else
    {
        //
        //  Name is NOT fully-qualified.
        //
        pwcszClusterLabel = bstrClusterNameIn;
    }

    //
    //  Can't use an IP address for cluster name when creating;
    //  also, cluster label must be compatible with netbios.
    //
    hr = HrValidateClusterNameLabel( pwcszClusterLabel, true ); // don't trace; name might not be valid.
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccw->put_ClusterName( bstrClusterNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    TraceSysFreeString( bstrClusterLabel );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ClusterName
//
//  Description:
//      Return the name of the cluster to create.  This will be either the
//      cluster name specified in a call to put_ClusterName or one entered
//      by the user.
//
//  Arguments:
//      pbstrClusterNameOut - Cluster name used by the wizard.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ClusterName( BSTR * pbstrClusterNameOut )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ClusterName( pbstrClusterNameOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ClusterName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_ServiceAccountName
//
//  Description:
//      Set the name of the cluster service account.
//
//  Arguments:
//      bstrServiceAccountNameIn    - Cluster service account name.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_ServiceAccountName( BSTR bstrServiceAccountNameIn )
{

    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->put_ServiceAccountUserName( bstrServiceAccountNameIn ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_ServiceAccountName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ServiceAccountName
//
//  Description:
//      Get the name of the cluster service account.
//
//  Arguments:
//      pbstrServiceAccountNameIn   - Cluster service account name.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ServiceAccountName( BSTR * pbstrServiceAccountNameOut )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ServiceAccountUserName( pbstrServiceAccountNameOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ServiceAccountName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_ServiceAccountDomain
//
//  Description:
//      Set the domain name of the cluster service account.
//
//  Arguments:
//      bstrServiceAccountDomainIn  - Cluster service account domain name.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_ServiceAccountDomain( BSTR bstrServiceAccountDomainIn )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->put_ServiceAccountDomainName( bstrServiceAccountDomainIn ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_ServiceAccountDomain

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ServiceAccountDomain
//
//  Description:
//      Get the domain name of the cluster service account.
//
//  Arguments:
//      pbstrServiceAccountDomainOut    - Cluster service account domain name.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ServiceAccountDomain( BSTR * pbstrServiceAccountDomainOut )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ServiceAccountDomainName( pbstrServiceAccountDomainOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ServiceAccountDomain

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_ServiceAccountPassword
//
//  Description:
//      Set the cluster service account password.
//
//  Arguments:
//      bstrPasswordIn  - Cluster service account password.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_ServiceAccountPassword( BSTR bstrPasswordIn )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->put_ServiceAccountPassword( bstrPasswordIn ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_ServiceAccountPassword

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_ClusterIPAddress
//
//  Description:
//      Set the IP address to use for the cluster name.
//
//  Arguments:
//      bstrClusterIPAddressIn  - Cluster IP address in string form.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_ClusterIPAddress( BSTR bstrClusterIPAddressIn )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->put_ClusterIPAddress( bstrClusterIPAddressIn ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_ClusterIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ClusterIPAddress
//
//  Description:
//      Get the IP address to use for the cluster name.
//
//  Arguments:
//      pbstrClusterIPAddressOut    - Cluster IP address in string form.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ClusterIPAddress( BSTR * pbstrClusterIPAddressOut )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ClusterIPAddress( pbstrClusterIPAddressOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ClusterIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ClusterIPSubnet
//
//  Description:
//      Get the IP address subnet mask for the cluster name calculated by
//      the wizard.
//
//  Arguments:
//      pbstrClusterIPSubnetOut - Cluster IP address subnet mask in string form.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ClusterIPSubnet(
    BSTR * pbstrClusterIPSubnetOut
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ClusterIPSubnet( pbstrClusterIPSubnetOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ClusterIPSubnet

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_ClusterIPAddressNetwork
//
//  Description:
//      Get the name of the network connection (cluster network) on which the
//      cluster IP address is published.
//
//  Arguments:
//      pbstrClusterNetworkNameOut  - Network connection name.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_ClusterIPAddressNetwork(
    BSTR * pbstrClusterNetworkNameOut
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = THR( m_pccw->get_ClusterIPAddressNetwork( pbstrClusterNetworkNameOut ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::get_ClusterIPAddressNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_FirstNodeInCluster
//
//  Description:
//      Set the name of the first node in the cluster.
//
//  Arguments:
//      bstrFirstNodeInClusterIn    - Name of the first node.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_FirstNodeInCluster(
    BSTR bstrFirstNodeInClusterIn
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );
    HRESULT hr = S_OK;
    BSTR    bstrNode = NULL;

    if ( m_bstrFirstNodeInCluster != NULL )
    {
        hr = THR( m_pccw->ClearComputerList() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        TraceSysFreeString( m_bstrFirstNodeInCluster );
        m_bstrFirstNodeInCluster = NULL;
    }

    if ( SysStringLen( bstrFirstNodeInClusterIn ) > 0 )
    {
        bstrNode = TraceSysAllocString( bstrFirstNodeInClusterIn );
        if ( bstrNode == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( m_pccw->AddComputer( bstrFirstNodeInClusterIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        m_bstrFirstNodeInCluster = bstrNode;
        bstrNode = NULL;
    }
    
Cleanup:

    TraceSysFreeString( bstrNode );
    
    HRETURN( hr );

} //*** CCreateClusterWizard::put_FirstNodeInCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_FirstNodeInCluster
//
//  Description:
//      Get the name of the first node in the cluster.
//
//  Arguments:
//      pbstrFirstNodeInClusterIn   - Name of the first node.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_FirstNodeInCluster(
    BSTR * pbstrFirstNodeInClusterOut
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );
    HRESULT hr = S_OK;
    
    if ( pbstrFirstNodeInClusterOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrFirstNodeInClusterOut = NULL;

    if ( m_bstrFirstNodeInCluster != NULL )
    {
        *pbstrFirstNodeInClusterOut = SysAllocString( m_bstrFirstNodeInCluster );
        if ( *pbstrFirstNodeInClusterOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    } // if: first node has been set
    
Cleanup:

    HRETURN( hr );

} //*** CCreateClusterWizard::get_FirstNodeInCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::put_MinimumConfiguration
//
//  Description:
//      Specify whether the wizard should operate in full or minimum
//      configuration mode.
//
//  Arguments:
//      fMinConfigIn
//          VARIANT_TRUE  - Put wizard in Minimum Configuration mode.
//          VARIANT_FALSE - Put wizard in Full Configuration mode.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::put_MinimumConfiguration(
    VARIANT_BOOL fMinConfigIn
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = S_OK;
    BOOL    fMinConfig = ( fMinConfigIn == VARIANT_TRUE? TRUE: FALSE );

    hr = THR( m_pccw->put_MinimumConfiguration( fMinConfig ) );

    HRETURN( hr );

} //*** CCreateClusterWizard::put_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::get_MinimumConfiguration
//
//  Description:
//      Get the current configuration mode of the wizard.
//
//  Arguments:
//      pfMinConfigOut
//          Configuration mode of the wizard:
//              VARIANT_TRUE  - Minimum Configuration mode.
//              VARIANT_FALSE - Full Configuration mode.
//          This value could have been set either by a call to the
//          put_MinimumConfiguration method or by the user in the wizard.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::get_MinimumConfiguration(
    VARIANT_BOOL * pfMinConfigOut
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = S_OK;
    BOOL    fMinConfig = FALSE;

    if ( pfMinConfigOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    
    hr = THR( m_pccw->get_MinimumConfiguration( &fMinConfig ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pfMinConfigOut = ( fMinConfig? VARIANT_TRUE: VARIANT_FALSE );

Cleanup:

    HRETURN( hr );

} //*** CCreateClusterWizard::get_MinimumConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateClusterWizard::ShowWizard
//
//  Description:
//      Show the wizard.
//
//  Arguments:
//      lParentWindowHandleIn
//          The parent window handle represented as a LONG value.
//
//      pfCompletedOut
//          Return status of the wizard operation itself:
//              VARIANT_TRUE    - Wizard was completed.
//              VARIANT_FALSE   - Wizard was cancelled.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateClusterWizard::ShowWizard(
      long              lParentWindowHandleIn
    , VARIANT_BOOL *    pfCompletedOut
    )
{
    TraceFunc( "[IClusCfgCreateClusterWizard]" );

    HRESULT hr = S_OK;
    BOOL    fCompleted = FALSE;
    HWND    hwndParent = reinterpret_cast< HWND >( LongToHandle( lParentWindowHandleIn ) );

    if ( ( hwndParent != NULL ) && ( IsWindow( hwndParent ) == FALSE ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( m_pccw->CreateCluster( hwndParent, &fCompleted ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( pfCompletedOut != NULL )
    {
        *pfCompletedOut = ( fCompleted ? VARIANT_TRUE : VARIANT_FALSE );
    }
    
Cleanup:

    HRETURN( hr );

} //*** CCreateClusterWizard::ShowWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\delimitediterator.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DelimitedIterator.h
//
//  Description:
//      This file contains the declaration of the CDelimitedIterator class.
//
//  Documentation:
//
//  Implementation Files:
//      DelimitedIterator.cpp
//
//  Maintained By:
//      John Franco (jfranco) 26-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CDelimitedIterator
//
//  Description:
//
//      This class iterates through delimited items in a string.
//      Multiple delimiters are possible, and any number of them can precede,
//      follow, or be interspersed among the items in the string.
//
//      The class does not make private copies of the item string or of the
//      string that specifies the delimiters, so the client must ensure that
//      the strings are valid throughout the iterator's lifetime.
//
//      The class modifies the string of delimited items as it iterates.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CDelimitedIterator
{
public:

    CDelimitedIterator(
          LPCWSTR   pwszDelimitersIn
        , LPWSTR    pwszDelimitedListIn
        , size_t    cchListIn
        );

    LPCWSTR Current( void ) const;
    void    Next( void );
    
private:

    //  Hide copy constructor and assignment operator.
    CDelimitedIterator( const CDelimitedIterator & );
    CDelimitedIterator & operator=( const CDelimitedIterator & );

    void    IsolateCurrent( void );

    LPCWSTR m_pwszDelimiters;
    LPWSTR  m_pwszList;
    size_t  m_cchList;
    size_t  m_idxCurrent;
    size_t  m_idxNext;

}; //*** CDelimitedIterator


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDelimitedIterator::Current
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//      A pointer to the current item in the list, or NULL if the iterator
//      has reached the list's end.
//
//  Remarks:
//      The pointer refers to part of the original string, so the caller must
//      NOT delete the pointer.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
LPCWSTR
CDelimitedIterator::Current( void ) const
{
    LPCWSTR pwszCurrent = NULL;
    if ( m_idxCurrent < m_cchList )
    {
        pwszCurrent = m_pwszList + m_idxCurrent;
    }
    return pwszCurrent;

} //*** CDelimitedIterator::Current


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDelimitedIterator::Next
//
//  Description:
//      Advance to the next item in the string, if one exists and
//      the iterator has not already passed the last one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
void
CDelimitedIterator::Next( void )
{
    m_idxCurrent = m_idxNext;
    IsolateCurrent();

} //*** CDelimitedIterator::Next
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\csaccountpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CSAccountPage.h
//
//  Maintained By:
//      John Franco     (JFranco)   10-SEP-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCSAccountPage
    : public ITaskGetDomainsCallback
{

private: // data
    HWND                    m_hwnd;                 // Our HWND
    CClusCfgWizard *        m_pccw;                 // Wizard
    ECreateAddMode          m_ecamCreateAddMode;    // Creating or Adding?
    IClusCfgCredentials *   m_pccc;                 // Service Account Credentials

    //  IUnknown
    LONG                m_cRef;
    ITaskGetDomains *   m_ptgd;                 // Get Domains Task

private: // methods

    // Private copy constructor to prevent copying.
    CCSAccountPage( const CCSAccountPage & );

    // Private assignment operator to prevent copying.
    CCSAccountPage & operator=( const CCSAccountPage & );

    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    LRESULT OnUpdateWizardButtons( void );

public: // methods
    CCSAccountPage(
          CClusCfgWizard *      pccwIn
        , ECreateAddMode        ecamCreateAddModeIn
        , IClusCfgCredentials * pcccIn
        );
    virtual ~CCSAccountPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  ITaskGetDomainsCallback
    //
    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( LPCWSTR pcszDomainIn );

};  //*** class CCSAccountPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\ipaddresspage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      IPAddressPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    14-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CIPAddressPage
    : public INotifyUI
{

private: // data
    HWND                m_hwnd;             // Our HWND
    CClusCfgWizard *    m_pccw;             // Wizard
    ULONG *             m_pulIPAddress;     // External storage of IPAddress
    ULONG *             m_pulIPSubnet;      // Subnet mask
    BSTR *              m_pbstrNetworkName; // Network name for address
    OBJECTCOOKIE        m_cookieCompletion; // Completion cookie
    HANDLE              m_event;            // Event when verify IP address task is completed

    //  IUnknown
    LONG                m_cRef;             // Reference count

private: // methods
    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

    HRESULT HrUpdateWizardButtons( void );

    HRESULT 
        HrFindNetworkForIPAddress(
            IClusCfgNetworkInfo **  ppccniOut
            );
    HRESULT
        HrMatchNetwork(
            IClusCfgNetworkInfo *   pccniIn,
            BSTR                    bstrNetworkNameIn
            );

public: // methods
    CIPAddressPage(
          CClusCfgWizard *      pccwIn
        , ECreateAddMode        ecamCreateAddModeIn
        , ULONG *               pulIPAddressInout
        , ULONG *               pulIPSubnetInout
        , BSTR *                pbstrNetworkNameInout
        );
    virtual ~CIPAddressPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

}; //*** class CIPAddressPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\ipsubnetpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      IPSubnetPage.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CIPSubnetPage
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             // Our HWND
    IServiceProvider *  m_psp;              // Service Manager
    ULONG *             m_pulIPSubnet;      // Subnet mask
    BSTR *              m_pbstrNetworkName; // Network name for address
    ULONG *             m_pulIPAddress;     // IP Address
    BSTR *              m_pbstrClusterName; // Cluster Name

private: // methods
    CIPSubnetPage( IServiceProvider *   pspIn,
                   ECreateAddMode       ecamCreateAddModeIn,
                   ULONG *              pulIPSubnetInout,
                   BSTR *               pbstrNetworkNameInout,
                   ULONG *              pulIPAddressIn,
                   BSTR *               pbstrClusterNameIn
                   );
    virtual ~CIPSubnetPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyKillActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( void );

    HRESULT
        HrAddNetworksToComboBox( HWND hwndCBIn );
    HRESULT
        HrMatchNetwork( IClusCfgNetworkInfo * pccniIn, BSTR bstrNetworkNameIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

}; //*** class CIPSubnetPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\ipaddresspage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      IPAddressPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IPAddressPage.h"

DEFINE_THISCLASS("CIPAddressPage");

#define CONVERT_ADDRESS( _addrOut, _addrIn ) \
    _addrOut = ( FIRST_IPADDRESS( _addrIn ) ) | ( SECOND_IPADDRESS( _addrIn ) << 8 ) | ( THIRD_IPADDRESS( _addrIn ) << 16 ) | ( FOURTH_IPADDRESS( _addrIn ) << 24 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  FIsValidIPAddress
//
//  Description:
//      Determine whether an IP address is compatible with a given adapter's
//      address and subnet
//
//  Arguments:
//      ulAddressToTest
//      ulAdapterAddress
//      ulAdapterSubnet
//
//  Return Values:
//
//      TRUE    - The address is compatible.
//      FALSE   - The address is not compatible.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
static
BOOL
FIsValidIPAddress(
      ULONG ulAddressToTest
    , ULONG ulAdapterAddress
    , ULONG ulAdapterSubnet
    )
{
    TraceFunc( "" );

    BOOL    fAddressIsValid = FALSE;

    if ( !ClRtlIsValidTcpipAddress( ulAddressToTest ) )
    {
        TraceFlow4(
              "Invalid IP address: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAddressToTest )
            , SECOND_IPADDRESS( ulAddressToTest )
            , THIRD_IPADDRESS( ulAddressToTest )
            , FOURTH_IPADDRESS( ulAddressToTest )
            );
        goto Exit;
    }

    if ( !ClRtlIsValidTcpipSubnetMask( ulAdapterSubnet ) )
    {
        TraceFlow4(
              "Invalid subnet mask: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAdapterSubnet )
            , SECOND_IPADDRESS( ulAdapterSubnet )
            , THIRD_IPADDRESS( ulAdapterSubnet )
            , FOURTH_IPADDRESS( ulAdapterSubnet )
            );
        goto Exit;
    }

    if ( !ClRtlIsValidTcpipAddressAndSubnetMask( ulAddressToTest, ulAdapterSubnet ) )
    {
        TraceFlow( "Mismatched IP address and subnet mask..." );
        TraceFlow4(
              "IP address: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAddressToTest )
            , SECOND_IPADDRESS( ulAddressToTest )
            , THIRD_IPADDRESS( ulAddressToTest )
            , FOURTH_IPADDRESS( ulAddressToTest )
            );
        TraceFlow4(
              "Subnet mask: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAdapterSubnet )
            , SECOND_IPADDRESS( ulAdapterSubnet )
            , THIRD_IPADDRESS( ulAdapterSubnet )
            , FOURTH_IPADDRESS( ulAdapterSubnet )
            );
        goto Exit;
    }

    if ( !ClRtlAreTcpipAddressesOnSameSubnet( ulAddressToTest, ulAdapterAddress, ulAdapterSubnet ) )
    {
        TraceFlow( "IP address on different subnet mask than adapter..." );
        TraceFlow4(
              "IP address: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAddressToTest )
            , SECOND_IPADDRESS( ulAddressToTest )
            , THIRD_IPADDRESS( ulAddressToTest )
            , FOURTH_IPADDRESS( ulAddressToTest )
            );
        TraceFlow4(
              "Adapter address: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAdapterAddress )
            , SECOND_IPADDRESS( ulAdapterAddress )
            , THIRD_IPADDRESS( ulAdapterAddress )
            , FOURTH_IPADDRESS( ulAdapterAddress )
            );
        TraceFlow4(
              "Subnet mask: %d.%d.%d.%d"
            , FIRST_IPADDRESS( ulAdapterSubnet )
            , SECOND_IPADDRESS( ulAdapterSubnet )
            , THIRD_IPADDRESS( ulAdapterSubnet )
            , FOURTH_IPADDRESS( ulAdapterSubnet )
            );
        goto Exit;
    }

    fAddressIsValid = TRUE;

Exit:

    RETURN( fAddressIsValid );
} //*** FIsValidIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::CIPAddressPage
//
//  Descriptor:
//      Constructor.
//
//  Arguments:
//      pccwIn                  -- CClusCfgWizard
//      ecamCreateAddModeIn     -- Creating cluster or adding nodes to cluster.
//      pulIPAddressInout       -- Pointer to IP address fill in.
//      pulIPSubnetInout        -- Pointer to subnet mask to fill in.
//      pbstrNetworkNameInout   -- Pointer to network name string to fill in.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressPage::CIPAddressPage(
    CClusCfgWizard *    pccwIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pulIPAddressInout,
    ULONG *             pulIPSubnetInout,
    BSTR *              pbstrNetworkNameInout
    )
    : m_pccw( pccwIn )
{
    TraceFunc( "" );

    Assert( pulIPAddressInout != NULL );
    Assert( pulIPSubnetInout != NULL );
    Assert( pbstrNetworkNameInout != NULL );

    //  m_hwnd
    Assert( pccwIn != NULL );
    m_pccw->AddRef();

    m_pulIPAddress     = pulIPAddressInout;
    m_pulIPSubnet      = pulIPSubnetInout;
    m_pbstrNetworkName = pbstrNetworkNameInout;

    m_cookieCompletion = NULL;
    m_event = NULL;

    m_cRef = 0;

    TraceFuncExit();

} //*** CIPAddressPage::CIPAddressPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::~CIPAddressPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressPage::~CIPAddressPage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CIPAddressPage::~CIPAddressPage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnInitDialog
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    if ( *m_pulIPAddress != 0 )
    {
        ULONG   ulIPAddress;
        CONVERT_ADDRESS( ulIPAddress, *m_pulIPAddress );
        SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_SETADDRESS, 0, ulIPAddress );
    }

    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    Assert( m_event != NULL );

    RETURN( lr );

} //*** CIPAddressPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_IPADDRESS_IP_ADDRESS:
            if ( idNotificationIn == IPN_FIELDCHANGED
              || idNotificationIn == EN_CHANGE
               )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CIPAddressPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    LRESULT lr;
    ULONG   ulIPAddress;

    lr = SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_ISBLANK, 0, 0 );
    if ( lr != 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_GETADDRESS, 0, (LPARAM) &ulIPAddress );
    if (    ( ulIPAddress == 0)                                     // Bad IP
        ||  ( ulIPAddress == MAKEIPADDRESS( 255, 255, 255, 255 ) )  // Bad IP
        )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CIPAddressPage::HrUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    } // if:
    else
    {
        THR( m_pccw->HrLaunchCleanupTask() );
    } // else:

    RETURN( lr );

} //*** CIPAddressPage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    // Enable controls on the page.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, TRUE, 0 );

    THR( HrUpdateWizardButtons() );

    RETURN( lr );

} //*** CIPAddressPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT hr;
    HRESULT hrStatus;
    BOOL    fRet;
    DWORD   ulAddress;

    LRESULT lr             = TRUE;
    DWORD   dwCookieNotify = 0;

    IUnknown *                  punkTask    = NULL;
    IClusCfgClusterInfo *       pccci   = NULL;
    IClusCfgNetworkInfo *       pccni   = NULL;
    ITaskVerifyIPAddress *      ptvipa  = NULL;

    CWaitCursor WaitCursor;

    // Disable controls on the page.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, FALSE, 0 );

    //
    //  Get the IP address from the UI.
    //

    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_GETADDRESS, 0, (LPARAM) &ulAddress );
    CONVERT_ADDRESS( *m_pulIPAddress, ulAddress );

    //
    //  See if this IP address can be matched to a network.

    hr = THR( HrFindNetworkForIPAddress( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }
    if ( hr == S_FALSE )
    {
        MessageBoxFromStrings(
              m_hwnd
            , IDS_CANNOT_FIND_MATCHING_NETWORK_TITLE
            , IDS_CANNOT_FIND_MATCHING_NETWORK_TEXT
            , MB_OK
            );
        goto Error;
    }

    //
    //  Get the cluster configuration info.
    //

    hr = THR( m_pccw->HrGetClusterObject( &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Set the IP adddress.
    //

    hr = THR( pccci->SetIPAddress( *m_pulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Set the IP subnet mask.
    //

    hr = THR( pccci->SetSubnetMask( *m_pulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Set the network.
    //

    hr = THR( pccci->SetNetworkInfo( pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Register to get UI notification (if needed)
    //

    hr = THR( m_pccw->HrAdvise( IID_INotifyUI, this, &dwCookieNotify ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  See the IP address is already present on the network.
    //

    hr = THR( m_pccw->HrCreateTask( TASK_VerifyIPAddress, &punkTask ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punkTask->TypeSafeQI( ITaskVerifyIPAddress, &ptvipa ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( ptvipa->SetIPAddress( *m_pulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    // Don't wrap - this can fail with E_PENDING
    hr = m_pccw->HrGetCompletionCookie( CLSID_TaskVerifyIPAddressCompletionCookieType, &m_cookieCompletion );
    if ( hr == E_PENDING )
    {
        // no-op.
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Error;
    }

    hr = THR( ptvipa->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    // reset the event before submitting.
    if ( m_event != NULL )
    {
        fRet = ResetEvent( m_event );
        Assert( fRet );
    }

    hr = THR( m_pccw->HrSubmitTask( ptvipa ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Now wait for the work to be done.
    //

    if ( m_event != NULL )
    {
        MSG     msg;
        DWORD   dwErr;

        for ( dwErr = (DWORD) -1; dwErr != WAIT_OBJECT_0; )
        {
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            } // while: PeekMessage

            CWaitCursor Wait2;

            dwErr = MsgWaitForMultipleObjects( 1,
                                               &m_event,
                                               FALSE,
                                               10000, // wait at most 10 seconds
                                               QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE
                                               );
            AssertMsg( dwErr != WAIT_TIMEOUT, "Need to bump up the timeout period." );
            if ( dwErr == WAIT_TIMEOUT )
            {
                break;  // give up and continue
            }

        } // for: dwErr
    }

    hr = THR( m_pccw->HrGetCompletionStatus( m_cookieCompletion, &hrStatus ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hrStatus == S_FALSE )
    {
        int iAnswer;

        //
        //  We detected a duplicate IP address on the network. Ask the user if
        //  they want to go back and change the IP or continue on.
        //

        iAnswer = MessageBoxFromStrings( m_hwnd,
                                         IDS_ERR_IPADDRESS_ALREADY_PRESENT_TITLE,
                                         IDS_ERR_IPADDRESS_ALREADY_PRESENT_TEXT,
                                         MB_YESNO
                                         );
        if ( iAnswer == IDYES )
        {
            goto Error;
        }
    }

    goto Cleanup;

Error:
    // Enable controls on the page again.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, TRUE, 0 );
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_SETFOCUS, 0, 0 );

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );

    goto Cleanup;

Cleanup:
    if ( punkTask != NULL )
    {
        punkTask->Release();
    }
    if ( ptvipa != NULL )
    {
        ptvipa->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( dwCookieNotify != 0 )
    {
        THR( m_pccw->HrUnadvise( IID_INotifyUI, dwCookieNotify ) );
    }

    Assert( m_cRef == 0 );

    RETURN( lr );

} //*** CIPAddressPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotify
//
//  Description:
//      Handle the WM_NOTIFY windows message.
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    }

    RETURN( lr );

} //*** CIPAddressPage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CIPAddressPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CIPAddressPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CIPAddressPage * pPage = reinterpret_cast< CIPAddressPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CIPAddressPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CIPAddressPage::S_DlgProc

// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      This QI implementation does not use the interface tracing macros due
//      to problems with CITracker's marshalling support.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressPage::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    HRETURN( hr );

} //*** CIPAddressPage::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::AddRef
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CIPAddressPage::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::Release
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    CRETURN( cRef );

} //*** CIPAddressPage::Release


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [INotifyUI]
//  CIPAddressPage::ObjectChanged
//
//  Description:
//
//  Arguments:
//      cookieIn
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressPage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    BOOL    fRet;
    HRESULT hr = S_OK;

    if ( cookieIn == m_cookieCompletion
      && m_event != NULL
       )
    {
        fRet = SetEvent( m_event );
        Assert( fRet );
    }

    HRETURN( hr );

} //*** CIPAddressPage::ObjectChanged


//****************************************************************************
//
//  Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrFindNetworkForIPAddress
//
//  Description:
//      Find the network for the saved IP address.
//
//  Arguments:
//      ppccniOut   -- Network info to return.
//
//  Return Values:
//      S_OK
//      S_FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrFindNetworkForIPAddress(
    IClusCfgNetworkInfo **  ppccniOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr          = S_OK;
    IUnknown *              punk        = NULL;
    IEnumClusCfgNetworks *  peccn       = NULL;
    IClusCfgNetworkInfo *   pccni       = NULL;
    BSTR                    bstrNetName = NULL;
    ULONG                   celtDummy;
    bool                    fFoundNetwork = false;

    Assert( ppccniOut != NULL );

    //
    // Get the network enumerator for the first node in the cluster.
    //

    hr = THR( m_pccw->HrGetNodeChild( 0, CLSID_NetworkType, DFGUID_EnumManageableNetworks, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Add each network to the combobox.
    //

    for ( ;; )
    {
        // Get the next network.
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Skip this network if it isn't public.
        hr = STHR( pccni->IsPublic() );
        if ( hr == S_OK )
        {
            // Get the name of the network.
            hr = THR( pccni->GetName( &bstrNetName ) );
            if ( SUCCEEDED( hr ) )
            {
                TraceMemoryAddBSTR( bstrNetName );

                // Determine if this network matches the user's IP address.
                // If it is, select it in the combobox.
                if ( ! fFoundNetwork )
                {
                    hr = STHR( HrMatchNetwork( pccni, bstrNetName ) );
                    if ( hr == S_OK )
                    {
                        fFoundNetwork = true;
                        *ppccniOut = pccni;
                        (*ppccniOut)->AddRef();
                        break;
                    }
                }

                // Cleanup.
                TraceSysFreeString( bstrNetName );
                bstrNetName = NULL;

            } // if: name retrieved successfully
        } // if: network is public

        pccni->Release();
        pccni = NULL;
    } // forever

    if ( fFoundNetwork )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    TraceSysFreeString( bstrNetName );
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }

    HRETURN( hr );

} //*** CIPAddressPage::HrFindNetworkForIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrMatchNetwork
//
//  Description:
//      Match a network to the saved IP address.
//
//  Arguments:
//      pccniIn
//      bstrNetworkNameIn
//
//  Return Values:
//      S_OK
//      S_FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrMatchNetwork(
    IClusCfgNetworkInfo *   pccniIn,
    BSTR                    bstrNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr      = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;

    Assert( pccniIn != NULL );
    Assert( bstrNetworkNameIn != NULL );

    //
    // Get the IP Address Info for the network.
    //

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the address and subnet of the network.
    //

    hr = THR( pccipai->GetIPAddress( &ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetSubnetMask( &ulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Determine if these match.
    //

    if ( FIsValidIPAddress( *m_pulIPAddress, ulIPAddress, ulIPSubnet) )
    {
        // Save the subnet mask.
        *m_pulIPSubnet = ulIPSubnet;

        // Save the name of the network.
        if ( *m_pbstrNetworkName == NULL )
        {
            *m_pbstrNetworkName = TraceSysAllocString( bstrNetworkNameIn );
            if ( *m_pbstrNetworkName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        }
        else
        {
            INT iRet = TraceSysReAllocString( m_pbstrNetworkName, bstrNetworkNameIn );
            if ( ! iRet )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        }
    } // if: match found
    else
    {
        hr = S_FALSE;
    }

    goto Cleanup;

Cleanup:

    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    HRETURN( hr );

} //*** CIPAddressPage::HrMatchNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\messagebox.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      MessageBox.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    15-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

int
MessageBoxFromStrings( HWND hParent, UINT idsCaption, UINT idsText, UINT uType );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\messagebox.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      MessageBox.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    15-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  int
//  MessageBoxFromStrings(
//      HWND    hParentIn,
//      UINT    idsCaptionIn,
//      UINT    idsTextIn,
//      UINT    uTypeIn 
//      )
//
//  Description:
//      Create a message box from resource strings.
//
//  Parameters:
//      hParentIn
//          HWND of the parent window.
//
//      idsCaptionIn
//          Resource ID of the caption for the message box.
//
//      idsTextIn
//          Resource ID of the text for the message box.
//
//      uTypeIn
//          Flags for the message box style.
//
//  Return Values:
//      Whatever ::MessageBox( ) can return.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
MessageBoxFromStrings(
    HWND hParentIn,
    UINT idsCaptionIn,
    UINT idsTextIn,
    UINT uTypeIn 
    )
{
    TraceFunc4( "hParentIn = 0x%p, idsCaptionIn = %u, idsTextIn = %u, uTypeIn = 0x%p",
                hParentIn, idsCaptionIn, idsTextIn, uTypeIn );

    DWORD dw;
    int   iRet;

    TCHAR szText[ 256 ];
    TCHAR szCaption[ 2048 ];

    dw = LoadString( g_hInstance, idsCaptionIn, szCaption, ARRAYSIZE(szCaption) );
    Assert( dw != 0 );
    dw = LoadString( g_hInstance, idsTextIn, szText, ARRAYSIZE(szText) );
    Assert( dw != 0 );

    iRet = MessageBox( hParentIn, szText, szCaption, uTypeIn );

    RETURN( iRet );

} //*** MessageBoxFromStrings( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\detailsdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DetailsDlg.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "DetailsDlg.h"
#include "WizardUtils.h"
#include "WizardHelp.h"

DEFINE_THISCLASS("DetailsDlg");

//////////////////////////////////////////////////////////////////////////////
//  Context-sensitive help table.
//////////////////////////////////////////////////////////////////////////////
const DWORD g_rgidDetailsDlgHelpIDs[] =
{
    IDC_DETAILS_S_DATE,         IDH_DETAILS_S_DATE,
    IDC_DETAILS_E_DATE,         IDH_DETAILS_S_DATE,
    IDC_DETAILS_S_TIME,         IDH_DETAILS_S_TIME,
    IDC_DETAILS_E_TIME,         IDH_DETAILS_S_TIME,
    IDC_DETAILS_S_COMPUTER,     IDH_DETAILS_S_COMPUTER,
    IDC_DETAILS_E_COMPUTER,     IDH_DETAILS_S_COMPUTER,
    IDC_DETAILS_S_MAJOR_ID,     IDH_DETAILS_S_MAJOR_ID,
    IDC_DETAILS_E_MAJOR_ID,     IDH_DETAILS_S_MAJOR_ID,
    IDC_DETAILS_S_MINOR_ID,     IDH_DETAILS_S_MINOR_ID,
    IDC_DETAILS_E_MINOR_ID,     IDH_DETAILS_S_MINOR_ID,
    IDC_DETAILS_S_PROGRESS,     IDH_DETAILS_S_PROGRESS,
    IDC_DETAILS_E_PROGRESS,     IDH_DETAILS_S_PROGRESS,
    IDC_DETAILS_S_PROGRESS_UNITS,   IDH_DETAILS_S_PROGRESS,
    IDC_DETAILS_S_STATUS,       IDH_DETAILS_S_STATUS,
    IDC_DETAILS_RE_STATUS,      IDH_DETAILS_S_STATUS,
    IDC_DETAILS_S_DESCRIPTION,  IDH_DETAILS_S_DESCRIPTION,
    IDC_DETAILS_RE_DESCRIPTION, IDH_DETAILS_S_DESCRIPTION,
    IDC_DETAILS_S_REFERENCE,    IDH_DETAILS_S_REFERENCE,
    IDC_DETAILS_RE_REFERENCE,   IDH_DETAILS_S_REFERENCE,
    IDC_DETAILS_PB_PREV,        IDH_DETAILS_PB_PREV,
    IDC_DETAILS_PB_NEXT,        IDH_DETAILS_PB_NEXT,
    IDC_DETAILS_PB_COPY,        IDH_DETAILS_PB_COPY,
    0, 0
};

//////////////////////////////////////////////////////////////////////////////
//  Static Function Prototypes
//////////////////////////////////////////////////////////////////////////////

static
BOOL
ButtonFaceColorIsDark( void );

static
void
SetButtonImage(
      HWND  hwndBtnIn
    , ULONG idIconIn
    );

static
void
FreeButtonImage(
    HWND hwndBtnIn
    );

static
HRESULT
HrAppendStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , LPCWSTR   pszDataIn
    , bool      fNewlineBeforeTextIn
    );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::S_HrDisplayModalDialog
//
//  Description:
//      Display the dialog box.
//
//  Arguments:
//      hwndParentIn    - Parent window for the dialog box.
//      pttvIn          - Task tree view control.
//      htiSelectedIn   - Handle to the selected item.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::S_HrDisplayModalDialog(
      HWND              hwndParentIn
    , CTaskTreeView *   pttvIn
    , HTREEITEM         htiSelectedIn
    )
{
    TraceFunc( "" );

    Assert( pttvIn != NULL );
    Assert( htiSelectedIn != NULL );

    HRESULT         hr      = S_OK;
    CDetailsDlg     dlg( pttvIn, htiSelectedIn );

    DialogBoxParam(
          g_hInstance
        , MAKEINTRESOURCE( IDD_DETAILS )
        , hwndParentIn
        , CDetailsDlg::S_DlgProc
        , (LPARAM) &dlg
        );

    HRETURN( hr );

} //*** CDetailsDlg::S_HrDisplayModalDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::CDetailsDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pttvIn          - Tree view to traverse.
//      htiSelectedIn   - Handle to the selected item in the tree control.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CDetailsDlg::CDetailsDlg(
      CTaskTreeView *   pttvIn
    , HTREEITEM         htiSelectedIn
    )
{
    TraceFunc( "" );

    Assert( pttvIn != NULL );
    Assert( htiSelectedIn != NULL );

    // m_hwnd
    m_hiconWarn     = NULL;
    m_hiconError    = NULL;
    m_pttv          = pttvIn;
    m_htiSelected   = htiSelectedIn;

    m_fControlDown  = FALSE;
    m_fAltDown      = FALSE;

    TraceFuncExit();

} //*** CDetailsDlg::CDetailsDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::~CDetailsDlg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CDetailsDlg::~CDetailsDlg( void )
{
    TraceFunc( "" );

    if ( m_hiconWarn != NULL )
    {
        DeleteObject( m_hiconWarn );
    }

    if ( m_hiconError != NULL )
    {
        DeleteObject( m_hiconError );
    }

    TraceFuncExit();

} //*** CDetailsDlg::~CDetailsDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::S_DlgProc
//
//  Description:
//      Dialog proc for the Details dialog box.
//
//  Arguments:
//      hwndDlgIn   - Dialog box window handle.
//      nMsgIn      - Message ID.
//      wParam      - Message-specific parameter.
//      lParam      - Message-specific parameter.
//
//  Return Values:
//      TRUE        - Message was processed by this procedure.
//      FALSE       - Message was NOT processed by this procedure.
//
//  Remarks:
//      It is expected that this dialog box is invoked by a call to
//      DialogBoxParam() with the lParam argument set to the address of the
//      instance of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CDetailsDlg::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CDetailsDlg *   pdlg;

    //
    // Get a pointer to the class.
    //

    if ( nMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, lParam );
        pdlg = reinterpret_cast< CDetailsDlg * >( lParam );
        pdlg->m_hwnd = hwndDlgIn;
    }
    else
    {
        pdlg = reinterpret_cast< CDetailsDlg * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pdlg != NULL )
    {
        Assert( hwndDlgIn == pdlg->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pdlg->OnInitDialog();
                break;

            case WM_DESTROY:
                pdlg->OnDestroy();
                break;

            case WM_SYSCOLORCHANGE:
                pdlg->OnSysColorChange();
                break;

            case WM_NOTIFY:
                lr = pdlg->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pdlg->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            case WM_KEYDOWN:
                lr = pdlg->OnKeyDown( lParam );
                break;

            case WM_KEYUP:
                lr = pdlg->OnKeyUp( lParam );
                break;

            case WM_HELP:
                WinHelp(
                        (HWND)((LPHELPINFO) lParam)->hItemHandle,
                        CLUSCFG_HELP_FILE,
                        HELP_WM_HELP,
                        (ULONG_PTR) g_rgidDetailsDlgHelpIDs
                       );
                break;

            case WM_CONTEXTMENU:
                WinHelp(
                        (HWND)wParam,
                        CLUSCFG_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) g_rgidDetailsDlgHelpIDs
                       );
                break;

            default:
                lr = FALSE;
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CDetailsDlg::S_DlgProc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Focus has been set.
//      FALSE       Focus has not been set.
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE; // did set focus
    HWND    hwnd;

    //
    // Tell the rich edit controls we want to receive notifications of clicks
    // on text that has the link (hyperlink, aka URL) format.   Also, set the
    // background color of the rich edit to match the background color of
    // the dialog.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_DESCRIPTION );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_STATUS );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_REFERENCE );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    //
    // Set the icons for the icon pushbuttons
    //

    OnSysColorChange();
    SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_COPY ), IDI_COPY );

    //
    // Load the status icons.
    //

    m_hiconWarn = (HICON) LoadImage(
                              g_hInstance
                            , MAKEINTRESOURCE( IDI_WARN )
                            , IMAGE_ICON
                            , 16
                            , 16
                            , LR_SHARED
                             );
    Assert( m_hiconWarn != NULL );
    m_hiconError = (HICON) LoadImage(
                              g_hInstance
                            , MAKEINTRESOURCE( IDI_FAIL )
                            , IMAGE_ICON
                            , 16
                            , 16
                            , LR_SHARED
                             );
    Assert( m_hiconError != NULL );

    //
    // Display the selected item.
    //

    THR( HrDisplayItem( m_htiSelected ) );

    //
    // Update the buttons based on what is selected.
    //

    UpdateButtons();

    //
    // Set focus to the OK button.
    //

    SetFocus( GetDlgItem( m_hwnd, IDOK ) );

    RETURN( lr );

} //*** CDetailsDlg::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnDestroy
//
//  Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::OnDestroy( void )
{
    TraceFunc( "" );

    //
    // Destroy the images loaded for the icon pushbuttons
    //

    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ) );
    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ) );
    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_COPY ) );

    TraceFuncExit();

} //*** CDetailsDlg::OnDestroy()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnSysColorChange
//
//  Description:
//      Handler for the WM_SYSCOLORCHANGE message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::OnSysColorChange( void )
{
    TraceFunc( "" );

    if ( ButtonFaceColorIsDark() )
    {
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), IDI_PREVIOUS_HC );
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), IDI_NEXT_HC );
    }
    else
    {
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), IDI_PREVIOUS );
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), IDI_NEXT );
    }

    SendDlgItemMessage(
          m_hwnd
        , IDC_DETAILS_RE_DESCRIPTION
        , EM_SETBKGNDCOLOR
        , 0
        , GetSysColor( COLOR_BTNFACE )
        );

    TraceFuncExit();

} //*** CDetailsDlg::OnSysColorChange()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnKeyDown
//
//  Description:
//      Handler for the WM_KEYDOWN message.
//
//  Arguments:
//      lParamIn    - Parameter containing information about the key.
//
//  Return Values:
//      TRUE        - Message was processed.
//      FALSE       - Message was not processed.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnKeyDown(
    LPARAM  lParamIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    union
    {
        LPARAM  lParam;
        struct
        {
            BYTE        cRepeat;
            BYTE        nScanCode;
            unsigned    fExtendedKey    : 1;
            unsigned    reserved        : 4;
            unsigned    fIsAltKeyDown   : 1;    // always 0 for WM_KEYDOWN
            unsigned    fKeyDownBefore  : 1;
            unsigned    fKeyReleased    : 1;    // always 0 for WM_KEYDOWN
        };
    } uFlags;

    uFlags.lParam = lParamIn;

    switch ( uFlags.nScanCode )
    {
        case VK_CONTROL:
            m_fControlDown = TRUE;
            lr = TRUE;
            break;

        case VK_MENU:   // ALT
            m_fAltDown = TRUE;
            lr = TRUE;
            break;

        case 'c':
        case 'C':
            if ( m_fControlDown )
            {
                OnCommandBnClickedCopy();
                lr = TRUE;
            }
            break;
    } // switch: scan code

    RETURN( lr );

} //*** CDetailsDlg::OnKeyDown()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnKeyUp
//
//  Description:
//      Handler for the WM_KEYUP message.
//
//  Arguments:
//      lParamIn    - Parameter containing information about the key.
//
//  Return Values:
//      TRUE        - Message was processed.
//      FALSE       - Message was not processed.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnKeyUp(
    LPARAM  lParamIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    union
    {
        LPARAM  lParam;
        struct
        {
            BYTE        cRepeat;
            BYTE        nScanCode;
            unsigned    fExtendedKey    : 1;
            unsigned    reserved        : 4;
            unsigned    fIsAltKeyDown   : 1;    // always 0 for WM_KEYDOWN
            unsigned    fKeyDownBefore  : 1;
            unsigned    fKeyReleased    : 1;    // always 0 for WM_KEYDOWN
        };
    } uFlags;

    uFlags.lParam = lParamIn;

    switch ( uFlags.nScanCode )
    {
        case VK_CONTROL:
            m_fControlDown = FALSE;
            lr = TRUE;
            break;

        case VK_MENU:   // ALT
            m_fAltDown = FALSE;
            lr = TRUE;
            break;
    } // switch: scan code

    RETURN( lr );

} //*** CDetailsDlg::OnKeyUp()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommand
//
//  Description:
//      Handler for the WM_COMMAND message.
//
//  Arguments:
//      idNotificationIn    - Notification code.
//      idControlIn         - Control ID.
//      hwndSenderIn        - Handle for the window that sent the message.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommand(
      UINT  idNotificationIn
    , UINT  idControlIn
    , HWND  hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_DETAILS_PB_PREV:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedPrev();
            }
            break;

        case IDC_DETAILS_PB_NEXT:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedNext();
            }
            break;

        case IDC_DETAILS_PB_COPY:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedCopy();
            }
            break;

        case IDCANCEL:
            EndDialog( m_hwnd, IDCANCEL );
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CDetailsDlg::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedPrev
//
//  Description:
//      Handler for the BN_CLICKED notification on the Prev button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedPrev( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    HTREEITEM   htiPrev;

    //
    // Find the previous item.
    //

    hr = STHR( m_pttv->HrFindPrevItem( &htiPrev ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Select that item.
    //

    hr = THR( m_pttv->HrSelectItem( htiPrev ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Display the newly selected item.
    //

    if ( htiPrev != NULL )
    {
        hr = THR( HrDisplayItem( htiPrev ) );
    }

    //
    // Update the buttons based on our new position.
    //

    UpdateButtons();

    lr = TRUE;

Cleanup:
    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedPrev()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedNext
//
//  Description:
//      Handler for the BN_CLICKED notification on the Next button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedNext( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    HTREEITEM   htiNext;

    //
    // Find the next item.
    //

    hr = STHR( m_pttv->HrFindNextItem( &htiNext ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Select that item.
    //

    hr = THR( m_pttv->HrSelectItem( htiNext ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Display the newly selected item.
    //

    if ( htiNext != NULL )
    {
        hr = THR( HrDisplayItem( htiNext ) );
    }

    //
    // Update the buttons based on our new position.
    //

    UpdateButtons();

    lr = TRUE;

Cleanup:
    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedCopy
//
//  Description:
//      Handler for the BN_CLICKED notification on the Copy button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedCopy( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    DWORD       sc;
    BSTR        bstrClipboard = NULL;
    HGLOBAL     hgbl = NULL;
    LPWSTR      pszGlobal = NULL;
    BOOL        fOpenedClipboard;

    //
    // Open the clipboard.
    //

    fOpenedClipboard = OpenClipboard( m_hwnd );

    if ( ! fOpenedClipboard )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        TraceFlow2( "Can't open clipboard (error = %#08x), currently owned by %#x", sc, GetClipboardOwner() );
        goto Cleanup;
    }

    if ( ! EmptyClipboard() )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    //
    // Construct the text to put on the clipboard.
    //

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_DATE
                    , IDC_DETAILS_E_DATE
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_TIME
                    , IDC_DETAILS_E_TIME
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_COMPUTER
                    , IDC_DETAILS_E_COMPUTER
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_MAJOR
                    , IDC_DETAILS_E_MAJOR_ID
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_MINOR
                    , IDC_DETAILS_E_MINOR_ID
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_PROGRESS
                    , IDC_DETAILS_E_PROGRESS
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_DESC
                    , IDC_DETAILS_RE_DESCRIPTION
                    , true      // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_STATUS
                    , IDC_DETAILS_E_STATUS
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , 0
                    , IDC_DETAILS_RE_STATUS
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_INFO
                    , IDC_DETAILS_RE_REFERENCE
                    , true      // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the string onto the clipboard.
    //

    {
        //
        // Allocate a global buffer for the string, since
        // clipboard needs this as HGLOBAL.
        //

        SIZE_T cchClipboardAndNull = SysStringLen( bstrClipboard ) + 1;
        hgbl = GlobalAlloc(
                      GMEM_MOVEABLE | GMEM_DDESHARE
                    , cchClipboardAndNull * sizeof( *bstrClipboard )
                    );
        if ( hgbl == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        pszGlobal = (LPWSTR) GlobalLock( hgbl );
        if ( pszGlobal == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }

        hr = THR( StringCchCopyW( pszGlobal, cchClipboardAndNull, bstrClipboard ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Put it on the clipboard.
        //

        if ( SetClipboardData( CF_UNICODETEXT, hgbl ) )
        {
            // System owns it now.
            pszGlobal = NULL;
            hgbl = NULL;
        }
    } // Set the string onto the clipboard

Cleanup:

    TraceSysFreeString( bstrClipboard );

    if ( pszGlobal != NULL )
    {
        GlobalUnlock( hgbl );
    }
    GlobalFree( hgbl );

    if ( fOpenedClipboard )
    {
        CloseClipboard();
    }

    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedCopy()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrAppendControlStringToClipboardString
//
//  Description:
//      Append a string from a control on the dialog box to the clipboard string.
//
//  Arguments:
//      pbstrClipboardInout - Clipboard string.
//      idsLabelIn          - ID for the label string resource.
//      idcDataIn           - ID for the control to read the text from.
//      fNewlineBeforeTextIn- TRUE if a newline should be added before the data.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::HrAppendControlStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , UINT      idcDataIn
    , bool      fNewlineBeforeTextIn
    )
{
    TraceFunc( "" );

    HRESULT hr          = S_OK;
    LPWSTR  pszData     = NULL;
    HWND    hwndControl = GetDlgItem( m_hwnd, idcDataIn );
    int     cch;

    //
    // Get the string from the control.
    //

    cch = GetWindowTextLength( hwndControl );

    pszData = new WCHAR[ cch + 1 ];
    if ( pszData == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    GetWindowText( hwndControl, pszData, cch + 1 );

    //
    // Append the string to the clipboard string.
    //

    hr = THR( HrAppendStringToClipboardString( pbstrClipboard, idsLabelIn, pszData, fNewlineBeforeTextIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    delete [] pszData;

    HRETURN( hr );

} //*** HrAppendControlStringToClipboardString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAppendStringToClipboardString
//
//  Description:
//      Append a label and data string to the clipboard string.
//
//  Arguments:
//      pbstrClipboardInout - Clipboard string.
//      idsLabelIn          - ID for the label string resource.
//      pszDataIn           - Data string.
//      fNewlineBeforeTextIn- TRUE if a newline should be added before the data.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAppendStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , LPCWSTR   pszDataIn
    , bool      fNewlineBeforeTextIn
    )
{
    TraceFunc( "" );

    HRESULT     hr          = S_OK;
    BSTR        bstrLabel   = NULL;
    BSTR        bstr        = NULL;
    LPCWSTR     pszLabel;
    LPCWSTR     pszFmt;

    static const WCHAR  s_szBlank[]         = L"";
    static const WCHAR  s_szNoNewlineFmt[]  = L"%1!ws!%2!ws!\n";
    static const WCHAR  s_szNewlineFmt[]    = L"%1!ws!\n%2!ws!\n";

    //
    // Load the label string.
    //

    if ( idsLabelIn == 0 )
    {
        pszLabel = s_szBlank;
    }
    else
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsLabelIn, &bstrLabel ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        pszLabel = bstrLabel;
    }

    //
    // Get the right format string.
    //

    if ( fNewlineBeforeTextIn )
    {
        pszFmt = s_szNewlineFmt;
    }
    else
    {
        pszFmt = s_szNoNewlineFmt;
    }

    //
    // Get the string from the dialog.
    //
    //
    // Format the new label + string.
    //

    hr = THR( HrFormatStringIntoBSTR( pszFmt, &bstr, pszLabel, pszDataIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Concatenate the resulting string onto the end of the clipboard string.
    //

    hr = THR( HrConcatenateBSTRs( pbstrClipboard, bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    TraceSysFreeString( bstrLabel );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** HrAppendStringToClipboardString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnNotify
//
//  Description:
//      Handle the WM_NOTIFY message.
//
//  Arguments:
//      idCtrlIn    - Control ID.
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnNotify(
      WPARAM    idCtrlIn
    , LPNMHDR   pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch( pnmhdrIn->code )
    {
        case EN_LINK:
            lr = OnNotifyEnLink( idCtrlIn, pnmhdrIn );
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CDetailsDlg::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnNotifyEnLink
//
//  Description:
//      Handle the WM_NOTIFY message.
//
//  Arguments:
//      idCtrlIn    - Control ID.
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnNotifyEnLink(
      WPARAM    idCtrlIn
    , LPNMHDR   pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    ENLINK *    penl = (ENLINK *) pnmhdrIn;

    switch( idCtrlIn )
    {
        case IDC_DETAILS_RE_DESCRIPTION:
        case IDC_DETAILS_RE_STATUS:
        case IDC_DETAILS_RE_REFERENCE:
            if ( penl->msg == WM_LBUTTONDOWN )
            {
                //
                // Rich edit notification user has left clicked on link
                //

                m_chrgEnLinkClick = penl->chrg;
            } // if: left button down
            else if ( penl->msg == WM_LBUTTONUP )
            {
                if (    ( penl->chrg.cpMax == m_chrgEnLinkClick.cpMax )
                    &&  ( penl->chrg.cpMin == m_chrgEnLinkClick.cpMin )
                    )
                {
                    ZeroMemory( &m_chrgEnLinkClick, sizeof m_chrgEnLinkClick );
                    HandleLinkClick( penl, idCtrlIn );
                }
            } // else if: left button up
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CDetailsDlg::OnNotifyEnLink()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HandleLinkClick
//
//  Description:
//      Handle notification that the user has clicked on text in a richedit
//      control that is marked with the hyperlink attribute.
//
//  Arguments:
//      penlIn      - Contains information about link clicked.
//      idCtrlIn    - Control in which user clicked.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::HandleLinkClick(
      ENLINK *  penlIn
    , WPARAM    idCtrlIn
    )
{
    TraceFunc( "" );

    Assert( penlIn->chrg.cpMax > penlIn->chrg.cpMin );

    PWSTR       pszLink = NULL;
    ULONG       cch;
    TEXTRANGE   tr;
    DWORD       sc;

    //
    // Get the text of the link.
    //

    cch = penlIn->chrg.cpMax - penlIn->chrg.cpMin + 1;

    pszLink = new WCHAR[ cch ];
    if ( pszLink == NULL )
    {
        goto Cleanup;
    }

    pszLink[ 0 ] = '\0';

    ZeroMemory( &tr, sizeof( tr ) );
    tr.chrg = penlIn->chrg;
    tr.lpstrText = pszLink;

    cch = (ULONG) SendDlgItemMessage(
                      m_hwnd
                    , (int) idCtrlIn
                    , EM_GETTEXTRANGE
                    , 0
                    , (LPARAM) &tr
                    );
    Assert( cch > 0 );

    //
    // Pass the URL straight through to ShellExecute.
    //
    // Note that ShellExecute returns an HINSTANCE for historical reasons,
    // but actually only returns integers.  Any value greater than 32
    // indicates success.
    //

    TraceFlow1( "Calling ShellExecute on %hs", pszLink );
    sc = HandleToULong( ShellExecute( NULL, NULL, pszLink, NULL, NULL, SW_NORMAL ) );
    if ( sc <= 32 )
    {
        TW32( sc );
        THR( HrMessageBoxWithStatus(
                          m_hwnd
                        , IDS_ERR_INVOKING_LINK_TITLE
                        , IDS_ERR_INVOKING_LINK_TEXT
                        , sc
                        , 0         // idsSubStatusIn
                        , ( MB_OK
                          | MB_ICONEXCLAMATION )
                        , NULL      // pidReturnOut
                        , pszLink
                        ) );
    } // if: error from ShellExecute

Cleanup:
    delete [] pszLink;

    TraceFuncExit();

} //*** CDetailsDlg::HandleLinkClick()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::UpdateButtons
//
//  Description:
//      Update the buttons based on whether there is a previous or next
//      item or not.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::UpdateButtons( void )
{
    TraceFunc( "" );

    Assert( m_pttv != NULL );

    HTREEITEM   hti = NULL;
    BOOL        fEnablePrev;
    BOOL        fEnableNext;

    STHR( m_pttv->HrFindPrevItem( &hti ) );
    // ignore error
    fEnablePrev = ( hti != NULL );

    STHR( m_pttv->HrFindNextItem( &hti ) );
    // ignore error
    fEnableNext = ( hti != NULL );

    EnableWindow( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), fEnablePrev );
    EnableWindow( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), fEnableNext );

    TraceFuncExit();

} //*** CDetailsDlg::UpdateButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrDisplayItem
//
//  Description:
//      Display an item in the details dialog.
//
//  Arguments:
//      htiIn   - Handle to the item to display.
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      S_FALSE - Item not displayed.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::HrDisplayItem(
    HTREEITEM   htiIn
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );

    HRESULT                 hr = S_FALSE;
    DWORD                   sc = ERROR_SUCCESS;
    BOOL                    fRet;
    BOOL                    fDisplayIcon = FALSE;
    STreeItemLParamData *   ptipd;
    BSTR                    bstr = NULL;
    BSTR                    bstrAdditionalInfo = NULL;
    WCHAR                   wszText[ 64 ];
    FILETIME                filetime;
    SYSTEMTIME              systemtime;
    int                     cch;
    HICON                   hicon;
    HRESULT                 hrNewStatus = S_OK;

    //
    // Get information about the selected item to see if it has details.
    //

    fRet = m_pttv->FGetItem( htiIn, &ptipd );
    if ( ! fRet )
    {
        goto Cleanup;
    }

    //
    // Set the date and time information from the structure into
    // the dialog box.
    //

    if (    ( ptipd->ftTime.dwHighDateTime == 0 )
        &&  ( ptipd->ftTime.dwLowDateTime == 0 )
        )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, L"" );
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, L"" );
    } // if: no date time specified
    else
    {
        //
        // Convert the date time to local time, then to something we can
        // use to display it.
        //

        if ( ! FileTimeToLocalFileTime( &ptipd->ftTime, &filetime ) )
        {
            sc = TW32( GetLastError() );
        }
        else if ( ! FileTimeToSystemTime( &filetime, &systemtime ) )
        {
            sc = TW32( GetLastError() );
        }
        if ( sc == ERROR_SUCCESS )
        {
            //
            // Get the date string and display it.
            //

            cch = GetDateFormat(
                          LOCALE_USER_DEFAULT
                        , DATE_SHORTDATE
                        , &systemtime
                        , NULL          // lpFormat
                        , wszText
                        , ARRAYSIZE( wszText )
                        );
            if ( cch == 0 )
            {
                sc = TW32( GetLastError() );
            }
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, wszText );

            //
            // Get the time string and display it.
            //

            cch = GetTimeFormat(
                          LOCALE_USER_DEFAULT
                        , 0
                        , &systemtime
                        , NULL      // lpFormat
                        , wszText
                        , ARRAYSIZE( wszText )
                        );
            if ( cch == 0 )
            {
                sc = TW32( GetLastError() );
            }
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, wszText );
        } // if: time converted successfully
        else
        {
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, L"" );
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, L"" );
        }
    } // else: date time specified

    //
    // Set the task IDs.
    //

    THR( HrFormatGuidIntoBSTR( &ptipd->clsidMajorTaskId, &bstr ) );
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_MAJOR_ID, bstr );
    }

    hr = THR( HrFormatGuidIntoBSTR( &ptipd->clsidMinorTaskId, &bstr ) );
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_MINOR_ID, bstr );
    }

    //
    // Set the progress information.
    //

    hr = THR( HrFormatStringIntoBSTR( L"%1!d!, %2!d!, %3!d!", &bstr, ptipd->nMin, ptipd->nMax, ptipd->nCurrent ) );
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_PROGRESS, bstr );
    }
    else
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_PROGRESS, L"" );
    }

    //
    // Set the text information.
    //

    // Node name.
    if ( ptipd->bstrNodeName == NULL )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_COMPUTER, L"" );
    }
    else
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_COMPUTER, ptipd->bstrNodeName );
    }

    // Description.
    if ( ptipd->bstrDescription == NULL )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_DESCRIPTION, L"" );
    }
    else
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_DESCRIPTION, ptipd->bstrDescription );
    }

    // Reference.
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_DEFAULT_DETAILS_REFERENCE, &bstrAdditionalInfo ) );
    if ( SUCCEEDED( hr ) )
    {
        if (    ( ptipd->bstrReference == NULL )
            ||  ( *ptipd->bstrReference == L'\0' )
            )
        {
            TraceSysFreeString( bstr );

            bstr = bstrAdditionalInfo;
            bstrAdditionalInfo = NULL;
        } // if: no reference specified
        else
        {
            hr = THR( HrFormatStringIntoBSTR( L"%1!ws!\n\n%2!ws!", &bstr, ptipd->bstrReference, bstrAdditionalInfo ) );
        } // else: reference specified
    }

    SetDlgItemText( m_hwnd, IDC_DETAILS_RE_REFERENCE, bstr );

    //
    // Set the status information.
    //

    if ( ptipd->hr == S_FALSE )
    {
        hr = THR( HrFormatStringIntoBSTR( L"S_FALSE", &bstr ) );
        hrNewStatus = S_FALSE;
    }
    else
    {
        hr = THR( HrFormatErrorIntoBSTR( ptipd->hr, &bstr, &hrNewStatus ) );
    } // else: hr not S_FALSE

    //
    //  If we got an updated status code then we need to use a new format
    //  string that shows both the old and the new status codes.
    //

    if ( hrNewStatus != ptipd->hr )
    {
        THR( StringCchPrintfW( wszText, ARRAYSIZE( wszText ), L"%#08x (%#08x)", ptipd->hr, hrNewStatus ) );
    } // if:
    else
    {
        THR( StringCchPrintfW( wszText, ARRAYSIZE( wszText ), L"%#08x", ptipd->hr ) );
    } // else:

    SetDlgItemText( m_hwnd, IDC_DETAILS_E_STATUS, wszText );

    if ( SUCCEEDED( hr ) )
    {
        Assert( bstr != NULL );

        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_STATUS, bstr );
        if ( ptipd->hr == S_OK )
        {
            fDisplayIcon = FALSE;
        }
        else
        {
            fDisplayIcon = TRUE;
            if ( FAILED( ptipd->hr ) )
            {
                hicon = m_hiconError;
            }
            else
            {
                hicon = m_hiconWarn;
            }

            SendDlgItemMessage( m_hwnd, IDC_DETAILS_I_STATUS, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hicon );
        } // else: status not informational
    }

    ShowWindow( GetDlgItem( m_hwnd, IDC_DETAILS_I_STATUS ), fDisplayIcon ? SW_SHOW : SW_HIDE );

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrAdditionalInfo );

    HRETURN( hr );

} //*** CDetailsDlg::HrDisplayItem()


//****************************************************************************
//
//  Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ButtonFaceColorIsDark
//
//  Description:
//      Return TRUE if the button face color is dark (implying that
//      the light colored button icons should be used).
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Button face color is dark.
//      FALSE       - Button face color is light.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
ButtonFaceColorIsDark( void )
{
    TraceFunc( "" );

    COLORREF    rgbBtnFace = GetSysColor( COLOR_BTNFACE );

    ULONG   nColors =  GetRValue( rgbBtnFace ) +
                       GetGValue( rgbBtnFace ) +
                       GetBValue( rgbBtnFace );

    RETURN( nColors < 300 );  // arbitrary threshold

} //*** ButtonFaceColorIsDark()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SetButtonImage
//
//  Description:
//      Set an image on a button.
//
//  Arguments:
//      hwndBtnIn   - Handle to the button window.
//      idIconIn    - ID for the icon resource.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
SetButtonImage(
      HWND  hwndBtnIn
    , ULONG idIconIn
    )
{
    TraceFunc( "" );

    HICON hIcon = (HICON) LoadImage( g_hInstance,
                                     MAKEINTRESOURCE( idIconIn ),
                                     IMAGE_ICON,
                                     16,
                                     16,
                                     LR_DEFAULTCOLOR
                                     );
    if ( hIcon != NULL )
    {
        HICON hIconPrev = (HICON) SendMessage( hwndBtnIn,
                                               BM_SETIMAGE,
                                               (WPARAM) IMAGE_ICON,
                                               (LPARAM) hIcon
                                               );

        if ( hIconPrev )
        {
            DestroyIcon( hIconPrev );
        }
    }

    TraceFuncExit();

} //*** SetButtonImage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  FreeButtonImage
//
//  Description:
//      Free an image used by button.
//
//  Arguments:
//      hwndBtnIn   - Handle to the button window.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
FreeButtonImage(
    HWND hwndBtnIn
    )
{
    HANDLE hIcon = (HANDLE) SendMessage( hwndBtnIn, BM_GETIMAGE, IMAGE_ICON, 0 );

    if ( hIcon != NULL )
    {
        SendMessage( hwndBtnIn, BM_SETIMAGE, IMAGE_ICON, 0 );
        DestroyIcon( (HICON) hIcon );
    }

} //*** FreeButtonImage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\detailsdlg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DetailsDlg.h
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CDetailsDlg
//
//  Description:
//      Class to handle the Details dialog which is displayed to show
//      details for an item in a tree control on the Analysis or Commit
//      pages.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CDetailsDlg
{
    friend class CAnalayzePage;
    friend class CCommitPage;
    friend class CTaskTreeView;

private: // data
    HWND                m_hwnd;             // Our HWND
    HICON               m_hiconWarn;        // Warning icon
    HICON               m_hiconError;       // Error icon
    CTaskTreeView *     m_pttv;             // Tree view to traverse
    HTREEITEM           m_htiSelected;      // Selected item when dialog was created.

    CHARRANGE           m_chrgEnLinkClick;  // Character range for EN_LINK messages.

    unsigned int        m_fControlDown : 1; // TRUE if a control key is down.
    unsigned int        m_fAltDown : 1;     // TRUE if an alt key is down.

private: // methods
    CDetailsDlg(
          CTaskTreeView *   pttvIn
        , HTREEITEM         htiSelectedIn
        );
    ~CDetailsDlg( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

    LRESULT OnInitDialog( void );
    void OnDestroy( void );
    void OnSysColorChange( void );
    LRESULT OnKeyDown( LPARAM lParamIn );
    LRESULT OnKeyUp( LPARAM lParamIn );

    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    LRESULT OnCommandBnClickedPrev( void );
    LRESULT OnCommandBnClickedNext( void );
    LRESULT OnCommandBnClickedCopy( void );

    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyEnLink( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );

    void HandleLinkClick( ENLINK * penlIn, WPARAM idCtrlIn );
    void UpdateButtons( void );

    HRESULT HrDisplayItem( HTREEITEM htiIn );

    HRESULT
        HrAppendControlStringToClipboardString(
              BSTR *    pbstrClipboard
            , UINT      idsLabelIn
            , UINT      idcDataIn
            , bool      fNewlineBeforeTextIn
            );

public: // methods
    static HRESULT
        S_HrDisplayModalDialog(
              HWND              hwndParentIn
            , CTaskTreeView *   pttvIn
            , HTREEITEM         htiSelectedIn
            );

}; //*** class CDetailsDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\ipsubnetpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      IPSubnetPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IPSubnetPage.h"

DEFINE_THISCLASS("CIPSubnetPage");

#define CONVERT_ADDRESS( _addrOut, _addrIn ) \
    _addrOut = ( FIRST_IPADDRESS( _addrIn ) ) | ( SECOND_IPADDRESS( _addrIn ) << 8 ) | ( THIRD_IPADDRESS( _addrIn ) << 16 ) | ( FOURTH_IPADDRESS( _addrIn ) << 24 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPSubnetPage::CIPSubnetPage(
//      IServiceProvider *  pspIn,
//      ECreateAddMode      ecamCreateAddModeIn
//      LONG *              pulIPSubnetInout,
//      BSTR *              pbstrNetworkNameInout,
//      ULONG *             pulIPAddressIn,
//      BSTR *              pbstrClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPSubnetPage::CIPSubnetPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pulIPSubnetInout,
    BSTR *              pbstrNetworkNameInout,
    ULONG *             pulIPAddressIn,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pulIPSubnetInout != NULL );
    Assert( pbstrNetworkNameInout != NULL );
    Assert( pulIPAddressIn != NULL );
    Assert( pbstrClusterNameIn != NULL );

    // m_hwnd = NULL;
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pulIPSubnet = pulIPSubnetInout;
    m_pbstrNetworkName = pbstrNetworkNameInout;
    m_pulIPAddress = pulIPAddressIn;
    m_pbstrClusterName = pbstrClusterNameIn;

    TraceFuncExit();

} //*** CIPSubnetPage::CIPSubnetPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPSubnetPage::~CIPSubnetPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////

CIPSubnetPage::~CIPSubnetPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    TraceFuncExit();

} //*** CIPSubnetPage::~CIPSubnetPage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnInitDialog( void )
{
    TraceFunc( "" );

    BOOL bRet;

    LRESULT lr = FALSE; // Didn't set focus

    if ( *m_pulIPSubnet != 0 )
    {
        ULONG   ulIPSubnet;
        CONVERT_ADDRESS( ulIPSubnet, *m_pulIPSubnet );
        SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_SETADDRESS, 0, ulIPSubnet );
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
    case IDC_IP_SUBNETMASK:
        if ( idNotificationIn == IPN_FIELDCHANGED
          || idNotificationIn == EN_CHANGE
           )
        {
            THR( HrUpdateWizardButtons() );
            lr = TRUE;
        }
        break;

    case IDC_CB_NETWORKS:
        if ( idNotificationIn == CBN_SELCHANGE )
        {
            THR( HrUpdateWizardButtons() );
            lr = TRUE;
        }
        break;

    }

    RETURN( lr );

} //*** CIPSubnetPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    LRESULT lr;
    ULONG   ulIPSubnet;

    HRESULT hr = S_OK;
    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

    lr = SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_ISBLANK, 0, 0 );
    if ( lr != 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    lr = ComboBox_GetCurSel( GetDlgItem( m_hwnd, IDC_CB_NETWORKS ) );
    if ( lr == CB_ERR )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CIPSubnetPage::HrUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive();
        break;

    case PSN_KILLACTIVE:
        lr = OnNotifyKillActive();
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext();
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel();
        break;
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnNotify

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    } // if:
    else
    {
        THR( HrLaunchCleanupTask( m_pccw ) );
    } // else:

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr      = TRUE;
    HWND    hwndIP  = GetDlgItem( m_hwnd, IDC_IP_SUBNETMASK );
    HWND    hwndCB  = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );
    WCHAR   szIPAddress[ ARRAYSIZE( "255 . 255 . 255 . 255" ) ];
    LRESULT lrCB;
    HRESULT hr;

    THR( HrUpdateWizardButtons() );

    //
    // Set the IP address string.
    //

    THR( StringCchPrintfW( szIPAddress,
               ARRAYSIZE( szIPAddress ),
               L"%u . %u . %u . %u",
               FOURTH_IPADDRESS( *m_pulIPAddress ),
               THIRD_IPADDRESS( *m_pulIPAddress ),
               SECOND_IPADDRESS( *m_pulIPAddress ),
               FIRST_IPADDRESS( *m_pulIPAddress )
               ) );
    SetDlgItemText( m_hwnd, IDC_E_IPADDRESS, szIPAddress );

    //
    // Add networks to the combobox.
    //

    hr = STHR( HrAddNetworksToComboBox( hwndCB ) );

    //
    // Set the subnet mask based on what was found from
    // the networks added to the combobox.
    //

    if ( *m_pulIPSubnet != 0 )
    {
        ULONG ulIPSubnet;
        CONVERT_ADDRESS( ulIPSubnet, *m_pulIPSubnet );
        SendMessage( hwndIP, IPM_SETADDRESS, 0, ulIPSubnet );
    }

    //
    // If there isn't a selected network, select the first one.
    //

    lrCB = ComboBox_GetCurSel( hwndCB );
    if ( lrCB == CB_ERR )
    {
        ComboBox_SetCurSel( hwndCB, 0 );
    }

    //
    // Determine if we need to show this page.
    //

    if ( hr == S_OK )
    {
        OnNotifyWizNext();
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyKillActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyKillActive( void )
{
    TraceFunc( "" );

    LRESULT lr      = TRUE;
    HWND    hwndCB  = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );
    LRESULT citems;

    //
    // Release all the network info interfaces stored in the combobox.
    //

    citems = ComboBox_GetCount( hwndCB );
    Assert( citems != CB_ERR );

    if ( ( citems != CB_ERR )
      && ( citems > 0 ) )
    {
        LRESULT                 idx;
        LRESULT                 lrItemData;
        IClusCfgNetworkInfo *   pccni;

        for ( idx = 0 ; idx < citems ; idx++ )
        {
            lrItemData = ComboBox_GetItemData( hwndCB, idx );
            Assert( lrItemData != CB_ERR );

            pccni = reinterpret_cast< IClusCfgNetworkInfo * >( lrItemData );
            pccni->Release();
        } // for: each item in the combobox
    } // if: retrieved combobox count and combobox not empty

    ComboBox_ResetContent( hwndCB );

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifyKillActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    OBJECTCOOKIE    cookieDummy;

    LRESULT lr = TRUE;
    LRESULT lrCB;
    HRESULT hr;
    ULONG   ulIPSubnet;
    HWND    hwndCB = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;

    SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_GETADDRESS, 0, (LPARAM) &ulIPSubnet );
    CONVERT_ADDRESS( *m_pulIPSubnet, ulIPSubnet );

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Get the cluster configuration info.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               *m_pbstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Set the IP subnet mask.
    //

    hr = THR( pccci->SetSubnetMask( *m_pulIPSubnet ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    // Get the selected network.
    //

    //
    // Set the network.
    //

    lrCB = ComboBox_GetCurSel( hwndCB );
    Assert( lrCB != CB_ERR );

    lrCB = ComboBox_GetItemData( hwndCB, lrCB );
    Assert( lrCB != CB_ERR );

    pccni = reinterpret_cast< IClusCfgNetworkInfo * >( lrCB );

    hr = THR( pccci->SetNetworkInfo( pccni ) );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pom != NULL )
    {
        pom->Release();
    }

    RETURN( lr );

Error:
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

} //*** CIPSubnetPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrAddNetworksToComboBox( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrAddNetworksToComboBox(
    HWND hwndCBIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr          = S_OK;
    IUnknown *              punk        = NULL;
    IObjectManager *        pom         = NULL;
    IEnumCookies *          pec         = NULL;
    IEnumClusCfgNetworks *  peccn       = NULL;
    IClusCfgNetworkInfo *   pccni       = NULL;
    BSTR                    bstrNetName = NULL;
    OBJECTCOOKIE            cookieCluster;
    OBJECTCOOKIE            cookieNode;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   celtDummy;
    bool                    fFoundNetwork = false;
    LRESULT                 lr;
    LRESULT                 lrIndex;

    Assert( hwndCBIn != NULL );

    ComboBox_ResetContent( hwndCBIn );

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS(
                    CLSID_ObjectManager,
                    IObjectManager,
                    &pom
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the cluster configuration info cookie.
    //

    hr = THR( pom->FindObject(
                        CLSID_ClusterConfigurationType,
                        NULL,
                        *m_pbstrClusterName,
                        IID_NULL,
                        &cookieCluster,
                        &punk
                        ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the enumeration of nodes whose parent is this cluster.
    // We want the enumeration of cookies (indicated by using
    // DFGUID_EnumCookies) because we want to use the cookie of the
    // node to search for all networks on that node.
    //

    hr = THR( pom->FindObject(
                        CLSID_NodeType,
                        cookieCluster,
                        NULL,
                        DFGUID_EnumCookies,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CIPSubnetPage!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    // Get the cookie for the first node in the node enumeration.
    //

    hr = THR( pec->Next( 1, &cookieNode, &celtDummy ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the network enumerator.
    //

    hr = THR( pom->FindObject(
                        CLSID_NetworkType,
                        cookieNode,
                        NULL,
                        DFGUID_EnumManageableNetworks,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release();
    punk = NULL;

    //
    // Add each network to the combobox.
    //

    for ( ;; )
    {
        // Get the next network.
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;
        if ( FAILED( hr ) )
            goto Cleanup;

        // Skip this network if it isn't public.
        hr = STHR( pccni->IsPublic() );
        if ( hr == S_OK )
        {
            // Get the name of the network.
            hr = THR( pccni->GetName( &bstrNetName ) );
            if ( SUCCEEDED( hr ) )
            {
                TraceMemoryAddBSTR( bstrNetName );

                // Add the network to the combobox.
                lrIndex = ComboBox_AddString( hwndCBIn, bstrNetName );
                Assert( ( lrIndex != CB_ERR )
                     && ( lrIndex != CB_ERRSPACE )
                     );

                // Add the netinfo interface to the combobox as well.
                if ( ( lrIndex != CB_ERR )
                  && ( lrIndex != CB_ERRSPACE ) )
                {
                    pccni->AddRef();
                    lr = ComboBox_SetItemData( hwndCBIn, lrIndex, pccni );
                    Assert( lr != CB_ERR );
                }

                // Determine if this network matches the user's IP address.
                // If it is, select it in the combobox.
                if ( ! fFoundNetwork )
                {
                    hr = STHR( HrMatchNetwork( pccni, bstrNetName ) );
                    if ( hr == S_OK )
                    {
                        fFoundNetwork = true;
                        lr = ComboBox_SetCurSel( hwndCBIn, lrIndex );
                        Assert( lr != CB_ERR );
                    }
                }

                // Cleanup.
                TraceSysFreeString( bstrNetName );
                bstrNetName = NULL;

            } // if: name retrieved successfully
        } // if: network is public

        pccni->Release();
        pccni = NULL;
    } // forever

    if ( fFoundNetwork )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrNetName );

    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }

    HRETURN( hr );

} //*** CIPSubnetPage::HrAddNetworksToComboBox

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrMatchNetwork(
//      IClusCfgNetworkInfo *   pccniIn,
//      BSTR                    bstrNetworkNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrMatchNetwork(
    IClusCfgNetworkInfo *   pccniIn,
    BSTR                    bstrNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr      = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;

    Assert( pccniIn != NULL );
    Assert( bstrNetworkNameIn != NULL );

    //
    // Get the IP Address Info for the network.
    //

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the address and subnet of the network.
    //

    hr = THR( pccipai->GetIPAddress( &ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetSubnetMask( &ulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Determine if these match.
    //

    if ( ClRtlAreTcpipAddressesOnSameSubnet( *m_pulIPAddress, ulIPAddress, ulIPSubnet) )
    {
        // Save the subnet mask.
        *m_pulIPSubnet = ulIPSubnet;

        // Save the name of the network.
        if ( *m_pbstrNetworkName == NULL )
        {
            *m_pbstrNetworkName = TraceSysAllocString( bstrNetworkNameIn );
            if ( *m_pbstrNetworkName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        }
        else
        {
            INT iRet = TraceSysReAllocString( m_pbstrNetworkName, bstrNetworkNameIn );
            if ( ! iRet )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        }
    } // if: match found
    else
    {
        hr = S_FALSE;
    }

Cleanup:

    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    HRETURN( hr );

} //*** CIPSubnetPage::HrMatchNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [static]
//  INT_PTR
//  CALLBACK
//  CIPSubnetPage::S_DlgProc(
//      HWND hDlgIn,
//      UINT MsgIn,
//      WPARAM wParam,
//      LPARAM lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CIPSubnetPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CIPSubnetPage * pPage = reinterpret_cast< CIPSubnetPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CIPSubnetPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog();
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_COMMAND:
            lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CIPSubnetPage::S_DlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\quorumdlg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      QuorumDlg.h
//
//  Maintained By:
//      David Potter    (DavidP)    03-APR-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "summarypage.h"
#include <clusudef.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CQuorumDlg
//
//  Description:
//      Display the Quorum dialog box.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CQuorumDlg
{
private: // data
    HWND                m_hwnd;             //  Our HWND
    CClusCfgWizard *    m_pccw;             //  Wizard
    SStateArray *       m_pssa;             //  The initial managed state of all the quorum capable resources.
    HWND                m_hComboBox;        //  combo box handle

    IClusCfgManagedResourceInfo **  m_rgpResources; // quorum capable and joinable resources
    DWORD                           m_cValidResources;    // number of items in m_rgpResources array
    DWORD                           m_idxQuorumResource;    // resource to set as quorum on return
    bool                            m_fQuorumAlreadySet; // one of the resources was already marked on entry

private: // methods
    CQuorumDlg(
          CClusCfgWizard *      pccwIn
        , SStateArray *         pssaOut
        );
    ~CQuorumDlg( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

    LRESULT OnInitDialog( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrCreateResourceList( void );
    void    UpdateButtons( void );
    HRESULT HrInitQuorumResource( IClusCfgManagedResourceInfo * pResourceIn );
    HRESULT HrCleanupQuorumResource( IClusCfgManagedResourceInfo * pResourceIn );

public: // methods
    static HRESULT
        S_HrDisplayModalDialog(
              HWND                  hwndParentIn
            , CClusCfgWizard *      pccwIn
            , SStateArray *         pssaOut
            );

}; //*** class CQuorumDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClusCfgWizard.rc
//
#define IDD_WELCOME_CREATE              1001
#define IDD_WELCOME_ADD                 1002
#define IDD_CLUSDOMAIN                  1003
#define IDD_SELNODE                     1006
#define IDD_SELNODES                    1007
#define IDD_ANALYZE                     1008
#define IDD_IPADDRESS                   1009
#define IDD_IPSUBNET                    1010
#define IDD_CSACCOUNT                   1011
#define IDD_SUMMARY                     1012
#define IDD_COMMIT                      1013
#define IDD_COMPLETION                  1014
#define IDD_DETAILS                     1020
#define IDD_QUORUM                      1021
#define IDD_ADVANCED                    1022


#define IDI_PENDING                     1101
#define IDI_SEL                         1102
#define IDI_CHECK                       1103
#define IDI_QUEST                       1104
#define IDI_INFO                        1105
#define IDI_FAIL                        1106
#define IDI_WARN                        1107
#define IDI_PREVIOUS                    1108
#define IDI_NEXT                        1109
#define IDI_PREVIOUS_HC                 1110
#define IDI_NEXT_HC                     1111
#define IDI_COPY                        1112

#define IDB_BANNER                      1201
#define IDB_WATERMARK                   1202

#define IDC_WELCOME_S_TITLE             1500
#define IDC_WELCOME_S_DESC_1            1501
#define IDC_WELCOME_S_DESC_2            1502
#define IDC_WELCOME_S_REQ_TITLE         1503
#define IDC_WELCOME_S_REQUIREMENTS      1504
#define IDC_WELCOME_S_CLICK_NEXT        1509
#define IDC_CLUSDOMAIN_S_DOMAIN_DESC    1520
#define IDC_CLUSDOMAIN_S_DOMAIN         1521
#define IDC_CLUSDOMAIN_CB_DOMAIN        1522
#define IDC_CLUSDOMAIN_S_CLUSTERNAME_DESC 1523
#define IDC_CLUSDOMAIN_S_CLUSTERNAME    1524
#define IDC_CLUSDOMAIN_E_CLUSTERNAME    1525
#define IDC_SELNODE_S_DESC              1550
#define IDC_SELNODE_S_COMPUTERNAME      1551
#define IDC_SELNODE_E_COMPUTERNAME      1552
#define IDC_SELNODE_PB_BROWSE           1553
#define IDC_SELNODE_S_NODES             1554
#define IDC_SELNODE_LB_NODES            1555
#define IDC_SELNODE_PB_ADD              1556
#define IDC_SELNODE_PB_REMOVE           1557
#define IDC_SELNODE_PB_ADVANCED         1558
#define IDC_ANALYZE_TV_TASKS            1560
#define IDC_ANALYZE_S_STATUS            1561
#define IDC_ANALYZE_PRG_STATUS          1562
#define IDC_ANALYZE_S_RESULTS           1563
#define IDC_ANALYZE_PB_VIEW_LOG         1564
#define IDC_ANALYZE_PB_DETAILS          1565
#define IDC_ANALYZE_PB_REANALYZE        1566
#define IDC_IPADDRESS_S_ADDRESS         1570
#define IDC_IPADDRESS_IP_ADDRESS        1571
#define IDC_CSACCOUNT_S_DESC            1580
#define IDC_CSACCOUNT_S_USERNAME        1581
#define IDC_CSACCOUNT_E_USERNAME        1582
#define IDC_CSACCOUNT_S_PASSWORD        1583
#define IDC_CSACCOUNT_E_PASSWORD        1584
#define IDC_CSACCOUNT_S_DOMAIN          1585
#define IDC_CSACCOUNT_CB_DOMAIN         1586
#define IDC_CSACCOUNT_S_LAWARN          1587
#define IDC_CSACCOUNT_I_LAWARN          1588
#define IDC_SUMMARY_RE_SUMMARY          1590
#define IDC_SUMMARY_S_NEXT              1591
#define IDC_SUMMARY_PB_VIEW_LOG         1592
#define IDC_SUMMARY_PB_QUORUM           1593
#define IDC_COMMIT_TV_TASKS             1600
#define IDC_COMMIT_S_STATUS             1601
#define IDC_COMMIT_PRG_STATUS           1602
#define IDC_COMMIT_S_RESULTS            1603
#define IDC_COMMIT_PB_VIEW_LOG          1604
#define IDC_COMMIT_PB_DETAILS           1605
#define IDC_COMMIT_PB_RETRY             1606
#define IDC_COMPLETION_S_TITLE          1610
#define IDC_COMPLETION_S_DESC           1611
#define IDC_COMPLETION_PB_VIEW_LOG      1612
#define IDC_COMPLETION_S_NEXT           1613
#define IDC_DETAILS_S_DATE              1620
#define IDC_DETAILS_E_DATE              1621
#define IDC_DETAILS_S_TIME              1622
#define IDC_DETAILS_E_TIME              1623
#define IDC_DETAILS_S_COMPUTER          1624
#define IDC_DETAILS_E_COMPUTER          1625
#define IDC_DETAILS_S_MAJOR_ID          1626
#define IDC_DETAILS_E_MAJOR_ID          1627
#define IDC_DETAILS_S_MINOR_ID          1628
#define IDC_DETAILS_E_MINOR_ID          1629
#define IDC_DETAILS_PB_PREV             1630
#define IDC_DETAILS_PB_NEXT             1631
#define IDC_DETAILS_PB_COPY             1632
#define IDC_DETAILS_S_DESCRIPTION       1633
#define IDC_DETAILS_RE_DESCRIPTION      1634
#define IDC_DETAILS_S_STATUS            1635
#define IDC_DETAILS_E_STATUS            1636
#define IDC_DETAILS_I_STATUS            1637
#define IDC_DETAILS_RE_STATUS           1638
#define IDC_DETAILS_S_REFERENCE         1639
#define IDC_DETAILS_RE_REFERENCE        1640
#define IDC_DETAILS_S_PROGRESS          1641
#define IDC_DETAILS_E_PROGRESS          1642
#define IDC_DETAILS_S_PROGRESS_UNITS    1643
#define IDC_QUORUM_S_QUORUM             1650
#define IDC_QUORUM_CB_QUORUM            1651
#define IDC_ADVANCED_RB_FULL_CONFIG     1660
#define IDC_ADVANCED_S_FULL_CONFIG_DESC 1661
#define IDC_ADVANCED_RB_MIN_CONFIG      1662
#define IDC_ADVANCED_S_MIN_CONFIG_DESC  1663
#define IDC_ADVANCED_S_MIN_CONFIG_DESC2 1664
#define IDC_ADVANCED_S_MIN_CONFIG_DESC3 1665
//#define IDC_ADVANCED_CB_MAKE_DEFAULT    1666

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2103
#define _APS_NEXT_COMMAND_VALUE         2600
#define _APS_NEXT_CONTROL_VALUE         1535
#define _APS_NEXT_SYMED_VALUE           2800
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\namedcookie.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      NamedCookie.cpp
//
//  Description:
//      This file contains the definition of the SNamedCookie struct.
//
//  Maintained By:
//      John Franco (jfranco) 23-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NamedCookie.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "SNamedCookie" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// SNamedCookie struct
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::SNamedCookie
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
SNamedCookie::SNamedCookie():
      bstrName( NULL )
    , ocObject( 0 )
    , punkObject( NULL )
{
    TraceFunc( "" );
    TraceFuncExit();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::~SNamedCookie
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
SNamedCookie::~SNamedCookie()
{
    TraceFunc( "" );
    Erase();
    TraceFuncExit();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::HrAssign
//
//  Description:
//
//  Arguments:
//      crSourceIn
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT SNamedCookie::HrAssign( const SNamedCookie& crSourceIn )
{
    TraceFunc( "" );
    
    HRESULT hr = S_OK;
    if ( this != &crSourceIn )
    {
        BSTR    bstrNameCache = NULL;

        if ( crSourceIn.bstrName != NULL )
        {
            bstrNameCache = TraceSysAllocString( crSourceIn.bstrName );
            if ( bstrNameCache == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        if ( bstrName != NULL )
        {
            TraceSysFreeString( bstrName );
        }
        bstrName = bstrNameCache;
        bstrNameCache = NULL;

        if ( punkObject != NULL )
        {
            punkObject->Release();
        }
        punkObject = crSourceIn.punkObject;
        if ( punkObject != NULL )
        {
            punkObject->AddRef();
        }

        ocObject = crSourceIn.ocObject;

    Cleanup:
    
        TraceSysFreeString( bstrNameCache );
    }
    
    HRETURN( hr );

} //*** SNamedCookie::HrAssign
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodePage.h
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "SelNodesPageCommon.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSelNodePage
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSelNodePage
    : public CSelNodesPageCommon
{

private: // data
    HWND                m_hwnd;     // Our HWND
    CClusCfgWizard *    m_pccw;     // Wizard

private: // methods
    LRESULT OnInitDialog( HWND hDlgIn );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

    HRESULT HrUpdateWizardButtons( void );

protected:

    virtual void OnProcessedNodeWithBadDomain( PCWSTR pwcszNodeNameIn );
    virtual void OnProcessedValidNode( PCWSTR pwcszNodeNameIn );

    virtual HRESULT HrSetDefaultNode( PCWSTR pwcszNodeNameIn );

public: // methods
    CSelNodePage( CClusCfgWizard *  pccwIn );
    virtual ~CSelNodePage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

};  //*** class CSelNodePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//      Include file for standard system include files, or project specific
//      include files that are used frequently, but are changed infrequently.
//
//  Maintained By:
//      Galen Barbee  (GalenB)    14-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <objbase.h>
#include <objidl.h>
#include <ocidl.h>
#include <ComCat.h>
#include <tchar.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wbemcli.h>
#include <windns.h>
#include <ObjSel.h>
#include <richedit.h>
#include <clusrtl.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <htmlhelp.h>
#include <strsafe.h>

#include <Guids.h>
#include <Common.h>
#include <CFactory.h>
#include <Dll.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>

#include <ObjectCookie.h>
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgDef.h>
#include <LoadString.h>
#include <DispatchHandler.h>
#include <ClusCfg.h>
#include <NameUtil.h>

#include "resource.h"
#include "WizardStrings.h"
#include <CommonStrings.h>
#include "MessageBox.h"
#include "WaitCursor.h"
#include "WizardHelp.h"

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////

#define WM_CCW_UPDATEBUTTONS ( WM_APP + 1 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\namedcookie.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      NamedCookie.h
//
//  Implementation Files:
//      NamedCookie.cpp
//
//  Description:
//      This file contains the declaration of the SNamedCookie structure.
//
//      This is a helper for CClusCfgWizard, but has its own file
//      due to the one-class-per-file restriction.      
//
//  Maintained By:
//      John Franco (jfranco) 23-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <DynamicArray.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  struct SNamedCookie
//
//  Description:
//      Struct for associating a cluster or node display name with the
//      name used by the middle tier objects, and caching the cookie and
//      interface pointer so that the middle tier object manager's FindObject
//      method need not be called more than once.
//
//--
//////////////////////////////////////////////////////////////////////////////

struct SNamedCookie
{
    BSTR            bstrName;
    OBJECTCOOKIE    ocObject;
    IUnknown*       punkObject;

    SNamedCookie();
    ~SNamedCookie();

    void    Erase( void );
    void    ReleaseObject( void );
    bool    FHasObject( void ) const;
    bool    FHasCookie( void ) const;
    bool    FHasName( void ) const;
    HRESULT HrAssign( const SNamedCookie& crSourceIn );
    
    struct AssignmentOperator   // For use with DynamicArray template.
    {
        HRESULT operator()( SNamedCookie& rDestInOut, const SNamedCookie& rSourceIn ) const
        {
            return rDestInOut.HrAssign( rSourceIn );
        }
    };

    private:

        SNamedCookie( const SNamedCookie& );
            SNamedCookie& operator=( const SNamedCookie& );

}; //*** struct SNamedCookie

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::Erase
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline void SNamedCookie::Erase( void )
{
    TraceFunc( "" );
    
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
        bstrName = NULL;
    }

    ReleaseObject();
    ocObject = 0;
    
    TraceFuncExit();
} //*** SNamedCookie::Erase

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::ReleaseObject
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline void SNamedCookie::ReleaseObject( void )
{
    TraceFunc( "" );
    if ( punkObject != NULL )
    {
        punkObject->Release();
        punkObject = NULL;
    }
    TraceFuncExit();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::FHasObject
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      true
//      false
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline bool SNamedCookie::FHasObject( void ) const
{
    TraceFunc( "" );
    RETURN( punkObject != NULL );
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::FHasCookie
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      true
//      false
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline bool SNamedCookie::FHasCookie( void ) const
{
    TraceFunc( "" );
    RETURN( ocObject != 0 );
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SNamedCookie::FHasName
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      true
//      false
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
inline bool SNamedCookie::FHasName( void ) const
{
    TraceFunc( "" );
    RETURN( bstrName != NULL );
}

typedef Generics::DynamicArray< SNamedCookie, SNamedCookie::AssignmentOperator > NamedCookieArray;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      SelNodePage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SelNodePage.h"
#include "WizardUtils.h"
#include "AdvancedDlg.h"

DEFINE_THISCLASS("CSelNodePage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::CSelNodePage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn                   - CClusCfgWizard
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodePage::CSelNodePage(
      CClusCfgWizard *  pccwIn
    )
    : m_hwnd( NULL )
    , m_pccw( pccwIn )
{
    TraceFunc( "" );
    Assert( m_pccw !=  NULL );
    m_pccw->AddRef();

    TraceFuncExit();

} //*** CSelNodePage::CSelNodePage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::~CSelNodePage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodePage::~CSelNodePage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    TraceFuncExit();

} //*** CSelNodePage::~CSelNodePage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      hDlgIn
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnInitDialog(
    HWND hDlgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // Didn't set the focus.

    //
    // (jfranco, bug #462673) Limit node name length to ADJUSTED_DNS_MAX_NAME_LENGTH.
    // According to MSDN, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns
    //

    SendDlgItemMessage( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, EM_SETLIMITTEXT, ADJUSTED_DNS_MAX_NAME_LENGTH, 0 );

    //
    // Call the base class function.
    // This must be called before any other base class methods are called.
    //

    CSelNodesPageCommon::OnInitDialog( hDlgIn, m_pccw );

    RETURN( lr );

} //*** CSelNodePage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_SELNODE_E_COMPUTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_BROWSE:
            if ( idNotificationIn == BN_CLICKED )
            {
                //
                //  TODO:   26-JUN-2000 GalenB
                //
                //  Need to set lr properly.
                //
                THR( HrBrowse( false /* fMultipleNodesIn */ ) );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_ADVANCED:
            if ( idNotificationIn == BN_CLICKED )
            {
                HRESULT hr;

                hr = STHR( CAdvancedDlg::S_HrDisplayModalDialog( m_hwnd, m_pccw ) );
                if ( hr == S_OK )
                {
                    OnNotifySetActive();
                } // if:

                lr = TRUE;
            } // if:
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CSelNodePage::OnCommand


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrUpdateWizardButtons( void )
{

    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrComputerName = NULL;
    DWORD   mEnabledButtons = PSWIZB_BACK;

    hr = STHR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ), &bstrComputerName ) );

    if ( hr == S_OK )
    {
        mEnabledButtons |= PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), mEnabledButtons );

    TraceSysFreeString( bstrComputerName );

    HRETURN( hr );
} //*** CSelNodePage::HrUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    STHR( HrUpdateWizardButtons() );

    //
    //  TODO:   gpease  23-MAY-2000
    //          Figure out: If the user clicks back and changes the computer
    //          name, how do we update the middle tier?
    //

    RETURN( lr );

} //*** CSelNodePage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CSelNodePage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    int     idcFocus = 0;
    BSTR    bstrComputerName = NULL;
    LRESULT lr = TRUE;

    //  Get machine name from edit control.
    hr = THR( HrGetTrimmedText( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ), &bstrComputerName ) );
    if ( hr != S_OK )
    {
        goto Error;
    }

    //  Check the machine name.
    hr = THR( HrValidateFQNPrefix( bstrComputerName ) );
    if ( FAILED( hr ) )
    {
        THR( HrShowInvalidLabelPrompt( m_hwnd, bstrComputerName, hr ) );
        idcFocus = IDC_SELNODE_E_COMPUTERNAME;
        goto Error;
    }

    //
    //  Free old list (if any)
    //
    hr = THR( m_pccw->ClearComputerList() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //  Make this machine the sole entry in the list.
    hr = THR( m_pccw->HrAddNode( bstrComputerName, true ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrComputerName );

    RETURN( lr );

Error:
    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }
    // Don't go to the next page.
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

} //*** CSelNodePage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CSelNodePage::OnNotify

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CSelNodePage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSelNodePage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CSelNodePage *  pPage = reinterpret_cast< CSelNodePage * >( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        Assert( lParam != NULL );

        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSelNodePage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog( hDlgIn );
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CSelNodePage::S_DlgProc


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnProcessedNodeWithBadDomain
//
//  Description:
//
//  Arguments:
//      pwcszNodeNameIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodePage::OnProcessedNodeWithBadDomain( PCWSTR pwcszNodeNameIn )
{
    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pwcszNodeNameIn );
    
} //*** CSelNodePage::OnProcessedNodeWithBadDomain

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnProcessedValidNode
//
//  Description:
//
//  Arguments:
//      pwcszNodeNameIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodePage::OnProcessedValidNode( PCWSTR pwcszNodeNameIn )
{
    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pwcszNodeNameIn );
    
} //*** CSelNodePage::OnProcessedValidNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrSetDefaultNode
//
//  Description:
//
//  Arguments:
//      pwcszNodeNameIn
//
//  Return Values:
//      S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrSetDefaultNode( PCWSTR pwcszNodeNameIn )
{
    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pwcszNodeNameIn );
    return S_OK;
    
} //*** CSelNodePage::HrSetDefaultNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\quorumdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      QuorumDlg.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    03-APR-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "QuorumDlg.h"
#include "WizardUtils.h"
#include "WizardHelp.h"
#include "SummaryPage.h"
#include <HtmlHelp.h>


//////////////////////////////////////////////////////////////////////////////
//  Context-sensitive help table.
//////////////////////////////////////////////////////////////////////////////

const DWORD g_rgidQuorumDlgHelpIDs[] =
{
    IDC_QUORUM_S_QUORUM,  IDH_QUORUM_S_QUORUM,
    IDC_QUORUM_CB_QUORUM, IDH_QUORUM_S_QUORUM,
    0, 0
};

//////////////////////////////////////////////////////////////////////////////
//  Static Function Prototypes
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::S_HrDisplayModalDialog
//
//  Description:
//      Display the dialog box.
//
//  Arguments:
//      hwndParentIn    - Parent window for the dialog box.
//      pccwIn          - CClusCfgWizard pointer for talking to the middle tier.
//      pssaOut         - array of all the initial IsManaged states
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::S_HrDisplayModalDialog(
      HWND                  hwndParentIn
    , CClusCfgWizard *      pccwIn
    , SStateArray *         pssaOut
    )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );
    Assert( pssaOut != NULL );

    HRESULT hr = S_OK;
    INT_PTR dlgResult = IDOK;

    // Display the dialog.
    {
        CQuorumDlg  dlg( pccwIn, pssaOut );

        dlgResult = DialogBoxParam(
              g_hInstance
            , MAKEINTRESOURCE( IDD_QUORUM )
            , hwndParentIn
            , CQuorumDlg::S_DlgProc
            , (LPARAM) &dlg
            );

        if ( dlgResult == IDOK )
            hr = S_OK;
        else
            hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CQuorumDlg::S_HrDisplayModalDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  FIsValidResource
//
//  Description:
//      Determines whether the resource is a valid selection as a quorum
//      resource.
//
//  Arguments:
//      pResourceIn    - the resource in question.
//
//  Return Values:
//      true        - the resource is valid.
//      false       - the resource is not valid.
//
//  Remarks:
//      A resource is valid if it is quorum capable and it is not an "unknown"
//      quorum.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
bool
FIsValidResource(
    IClusCfgManagedResourceInfo * pResourceIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    bool    fValid = false;
    BSTR    bstrDeviceID = NULL;

    hr = STHR( pResourceIn->IsQuorumCapable() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  The resource is not quorum capable so there is no reason
    //  to continue.
    //

    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = THR( pResourceIn->GetUID( &bstrDeviceID ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[WIZ] FIsValidResource() cannot get the UID for the passed in managed resource. (hr = %#08x)" );
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrDeviceID );

    //
    //  If this is the "Unknown Quorum" resource then we don't want to show it
    //  in the drop down list.
    //

    if ( NStringCchCompareCase( g_szUnknownQuorumUID, RTL_NUMBER_OF( g_szUnknownQuorumUID ), bstrDeviceID, SysStringLen( bstrDeviceID ) + 1 ) == 0 )
    {
        goto Cleanup;
    } // if:

    fValid = true;

Cleanup:

    TraceSysFreeString( bstrDeviceID );

    RETURN( fValid );

} //*** FIsValidResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::CQuorumDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn  - CClusCfgWizard for talking to the middle tier.
//      pssaOut - array of all the initial IsManaged states.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CQuorumDlg::CQuorumDlg(
      CClusCfgWizard *      pccwIn
    , SStateArray *         pssaOut
    )
    : m_pccw( pccwIn )
    , m_pssa( pssaOut )
    , m_rgpResources( NULL )
    , m_cValidResources( 0 )
    , m_idxQuorumResource( 0 )
    , m_hComboBox( NULL )
    , m_fQuorumAlreadySet( false )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );
    Assert( pssaOut != NULL );

    // m_hwnd
    m_pccw->AddRef();

    TraceFuncExit();

} //*** CQuorumDlg::CQuorumDlg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::~CQuorumDlg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CQuorumDlg::~CQuorumDlg( void )
{
    TraceFunc( "" );

    DWORD idxResource = 0;

    for ( idxResource = 0; idxResource < m_cValidResources; idxResource += 1 )
        m_rgpResources[ idxResource ]->Release();

    delete [] m_rgpResources;

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    TraceFuncExit();

} //*** CQuorumDlg::~CQuorumDlg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::S_DlgProc
//
//  Description:
//      Dialog proc for the Quorum dialog box.
//
//  Arguments:
//      hwndDlgIn   - Dialog box window handle.
//      nMsgIn      - Message ID.
//      wParam      - Message-specific parameter.
//      lParam      - Message-specific parameter.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//  Remarks:
//      It is expected that this dialog box is invoked by a call to
//      DialogBoxParam() with the lParam argument set to the address of the
//      instance of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CQuorumDlg::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CQuorumDlg *    pdlg;

    //
    // Get a pointer to the class.
    //

    if ( nMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, lParam );
        pdlg = reinterpret_cast< CQuorumDlg * >( lParam );
        pdlg->m_hwnd = hwndDlgIn;
    }
    else
    {
        pdlg = reinterpret_cast< CQuorumDlg * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pdlg != NULL )
    {
        Assert( hwndDlgIn == pdlg->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pdlg->OnInitDialog();
                break;

            case WM_COMMAND:
                lr = pdlg->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            case WM_HELP:
                WinHelp(
                        (HWND)((LPHELPINFO) lParam)->hItemHandle,
                        CLUSCFG_HELP_FILE,
                        HELP_WM_HELP,
                        (ULONG_PTR) g_rgidQuorumDlgHelpIDs
                       );
                break;

            case WM_CONTEXTMENU:
                WinHelp(
                        (HWND)wParam,
                        CLUSCFG_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) g_rgidQuorumDlgHelpIDs
                       );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CQuorumDlg::S_DlgProc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Focus has been set.
//      FALSE       Focus has not been set.
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CQuorumDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE; // did set focus

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   idxResource = 0;
    BSTR    bstrResourceName = NULL;

    //
    //  create resource list
    //

    hr = THR( HrCreateResourceList() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  get combo box handle
    //

    m_hComboBox = GetDlgItem( m_hwnd, IDC_QUORUM_CB_QUORUM );
    if ( m_hComboBox == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Error;
    }

    //
    //  fill combo box
    //

    for ( idxResource = 0 ; idxResource < m_cValidResources ; idxResource++ )
    {
        hr = THR( m_rgpResources[ idxResource ]->GetName( &bstrResourceName ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        TraceMemoryAddBSTR( bstrResourceName );

        sc = (DWORD) SendMessage( m_hComboBox, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>( bstrResourceName ) );
        if ( ( sc == CB_ERR ) || ( sc == CB_ERRSPACE ) )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            goto Error;
        }
        TraceSysFreeString( bstrResourceName );
        bstrResourceName = NULL;

        //  - remember which is quorum resource
        hr = STHR( m_rgpResources[ idxResource ]->IsQuorumResource() );
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        else if ( hr == S_OK )
        {
            m_idxQuorumResource = idxResource;
            m_fQuorumAlreadySet = true;
        }
    } // for: each resource

    //
    //  set combo box selection to current quorum resource
    //

    sc = (DWORD) SendMessage( m_hComboBox, CB_SETCURSEL, m_idxQuorumResource, 0 );
    if ( sc == CB_ERR )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Error;
    }

    //
    // Update the buttons based on what is selected.
    //

    UpdateButtons();

    //
    // Set focus to the combo box.
    //

    SetFocus( m_hComboBox );

    goto Cleanup;

Error:

    HrMessageBoxWithStatus(
          m_hwnd
        , IDS_ERR_RESOURCE_GATHER_FAILURE_TITLE
        , IDS_ERR_RESOURCE_GATHER_FAILURE_TEXT
        , hr
        , 0
        , MB_OK | MB_ICONERROR
        , 0
        );

    EndDialog( m_hwnd, IDCANCEL ); // show message box?
    lr = FALSE;
    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrResourceName );

    RETURN( lr );

} //*** CQuorumDlg::OnInitDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::OnCommand
//
//  Description:
//      Handler for the WM_COMMAND message.
//
//  Arguments:
//      idNotificationIn    - Notification code.
//      idControlIn         - Control ID.
//      hwndSenderIn        - Handle for the window that sent the message.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CQuorumDlg::OnCommand(
      UINT  idNotificationIn
    , UINT  idControlIn
    , HWND  hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT                         lr = FALSE;
    size_t                          idxCurrentSelection = 0;
    HRESULT                         hr = S_OK;
    BOOL                            fState;
    IClusCfgManagedResourceInfo *   pQuorum = NULL;
    IClusCfgManagedResourceInfo *   pCurrent = NULL;
    BSTR                            bstrTemp = NULL;
    BOOL                            bLocalQuorum;

    switch ( idControlIn )
    {
        case IDOK:

            //
            //  get selection from combo box
            //

            idxCurrentSelection = SendMessage( m_hComboBox, CB_GETCURSEL, 0, 0 );
            if ( idxCurrentSelection == CB_ERR )
            {
                hr = HRESULT_FROM_WIN32( TW32( (DWORD) CB_ERR ) );
                goto Error;
            }

            //
            //  if original quorum resource is different, or had not been set.
            //

            if ( ( idxCurrentSelection != m_idxQuorumResource ) || !m_fQuorumAlreadySet )
            {
                pQuorum = m_rgpResources[ m_idxQuorumResource ];
                pCurrent = m_rgpResources[ idxCurrentSelection ];

                //
                //  First, is the new resource Local Quorum?  (Special processing -
                //  unfortunate but necessary.)
                //

                hr = THR( pCurrent->GetUID( &bstrTemp ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                } // if:

                bLocalQuorum = ( NStringCchCompareCase( bstrTemp, SysStringLen( bstrTemp ) + 1, CLUS_RESTYPE_NAME_LKQUORUM, RTL_NUMBER_OF( CLUS_RESTYPE_NAME_LKQUORUM ) ) == 0 );

                SysFreeString( bstrTemp );
                bstrTemp = NULL;

                //
                //  Clear original quorum resource.
                //

                hr = THR( pQuorum->SetQuorumResource( FALSE ) );

                //
                //  Set the managed state back to it's original state.
                //

                if ( SUCCEEDED( hr ) )
                {
                    fState = m_pssa->prsArray[ m_idxQuorumResource ].fState;
                    hr = THR( pQuorum->SetManaged( fState ) );
                } // if:

                //
                //  If we successfully ran PrepareToHostQuorum on this resource the last time
                //  this dialog was up we now need to clean it up.
                //

                if ( m_pssa->prsArray[ m_idxQuorumResource ].fNeedCleanup )
                {
                    THR( HrCleanupQuorumResource( pQuorum ) );
                } // if:

                //
                //  Set new quorum resource.
                //

                if ( SUCCEEDED( hr ) )
                {
                    //
                    //  This function returns S_FALSE when the resource does not support
                    //  the IClusCfgVerifyQuorum interface.  If the resource doesn't
                    //  support the interface then there is no need to clean it up later.
                    //

                    hr = STHR( HrInitQuorumResource( pCurrent ) );
                    if ( FAILED( hr ) )
                    {
                        goto Error;
                    } // if:

                    if ( hr == S_OK )
                    {
                        m_pssa->prsArray[ idxCurrentSelection ].fNeedCleanup = TRUE;
                        hr = THR( pCurrent->SetQuorumResource( TRUE ) );
                    } // if:
                } // if:

                //
                //  Local Quorum resources should never be SetManaged( TRUE ).
                //

                if ( SUCCEEDED( hr ) && !bLocalQuorum )
                {
                    hr = THR( m_rgpResources[ idxCurrentSelection ]->SetManaged( TRUE ) );
                } // if:

                if ( FAILED( hr ) )
                {
                    fState = m_pssa->prsArray[ idxCurrentSelection ].fState;
                    THR( pCurrent->SetManaged( fState ) );
                    THR( pCurrent->SetQuorumResource( FALSE ) );
                    THR( pQuorum->SetQuorumResource( TRUE ) );
                    THR( pQuorum->SetManaged( bLocalQuorum == FALSE ) );

                    goto Error;
                } // if:

                EndDialog( m_hwnd, IDOK );
            }
            else // (combo box selection is same as original)
            {
                EndDialog( m_hwnd, IDCANCEL );
            }
            break;

        case IDCANCEL:
            EndDialog( m_hwnd, IDCANCEL );
            break;

        case IDHELP:
            HtmlHelp( m_hwnd, L"mscsconcepts.chm::/SAG_MSCS2planning_6.htm", HH_DISPLAY_TOPIC, 0 );
            break;

    } // switch: idControlIn

    goto Cleanup;

Error:

    HrMessageBoxWithStatus(
          m_hwnd
        , IDS_ERR_QUORUM_COMMIT_FAILURE_TITLE
        , IDS_ERR_QUORUM_COMMIT_FAILURE_TEXT
        , hr
        , 0
        , MB_OK | MB_ICONERROR
        , 0
        );

    goto Cleanup;

Cleanup:

    RETURN( lr );

} //*** CQuorumDlg::OnCommand


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::HrCreateResourceList
//
//  Description:
//      Allocates and fills m_rgpResources array with quorum capable and
//      joinable resources, and sets m_idxQuorumResource to the index of the
//      resource that's currently the quorum resource.
//
//      Supposedly at least one quorum capable and joinable resource always
//      exists, and exactly one is marked as the quorum resource.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK            - Success.
//      S_FALSE         - Didn't find current quorum resource.
//      E_OUTOFMEMORY   - Couldn't allocate memory for the list.
//
//      Other possible error values from called methods.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::HrCreateResourceList( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IUnknown *                      punkEnum = NULL;
    IEnumClusCfgManagedResources *  peccmr = NULL;
    DWORD                           idxResCurrent = 0;
    ULONG                           cFetchedResources = 0;
    DWORD                           cTotalResources = 0;
    BOOL                            fState;

    Assert( m_pccw != NULL );

    //
    // get resource enumerator
    //

    hr = THR( m_pccw->HrGetClusterChild( CLSID_ManagedResourceType, DFGUID_EnumManageableResources, &punkEnum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkEnum->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // find out how many resources exist
    //

    hr = THR( peccmr->Count( &cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // allocate memory for resources
    //

    m_rgpResources = new IClusCfgManagedResourceInfo*[ cTotalResources ];
    if ( m_rgpResources == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }
    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        m_rgpResources[ idxResCurrent ] = NULL;
    }

    //
    // allocate the m_pssa arrays
    //

    if ( m_pssa->bInitialized == FALSE )
    {
        m_pssa->prsArray = new SResourceState[ cTotalResources ];
        if ( m_pssa->prsArray == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
        {
            m_pssa->prsArray[ idxResCurrent ].fState = FALSE;
            m_pssa->prsArray[ idxResCurrent ].fNeedCleanup = FALSE;
        }
    } // if: m_pssa ! already initialized

    //
    // copy resources into array
    //

    hr = THR( peccmr->Next( cTotalResources, m_rgpResources, &cFetchedResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( cFetchedResources == cTotalResources ); // if not, something's wrong with the enum
    cTotalResources = min( cTotalResources, cFetchedResources ); // playing it safe

    //
    // filter out invalid resources
    //

    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        if ( !FIsValidResource( m_rgpResources[ idxResCurrent ] ) )
        {
            m_rgpResources[ idxResCurrent ]->Release();
            m_rgpResources[ idxResCurrent ] = NULL;
        }
    }

    //
    // compact array; might leave some non-null pointers after end,
    //  so always use m_cValidResources to determine length hereafter
    //

    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        if ( m_rgpResources[ idxResCurrent ] != NULL )
        {
            m_rgpResources[ m_cValidResources ] = m_rgpResources[ idxResCurrent ];

            if ( m_pssa->bInitialized == FALSE )
            {
                fState = ( m_rgpResources[ m_cValidResources ]->IsManaged() == S_OK ) ? TRUE : FALSE;
                m_pssa->prsArray[ m_cValidResources ].fState = fState;
            }

            m_cValidResources++;
        } // if: current element !NULL
    } // for: compact the array

    if ( m_pssa->bInitialized == FALSE )
    {
        m_pssa->cCount = m_cValidResources;
        m_pssa->bInitialized = TRUE;
    }

Cleanup:

    if ( m_pssa->bInitialized == FALSE )
    {
        delete [] m_pssa->prsArray;
        m_pssa->prsArray = NULL;

        m_pssa->cCount = 0;
    }

    if ( punkEnum != NULL )
    {
        punkEnum->Release();
    }

    if ( peccmr != NULL )
    {
        peccmr->Release();
    }

    HRETURN( hr );

} //*** CQuorumDlg::HrCreateResourceList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::UpdateButtons
//
//  Description:
//      Update the OK and Cancel buttons.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CQuorumDlg::UpdateButtons( void )
{
    TraceFunc( "" );

    BOOL    fEnableOK;
    LRESULT lrCurSel;

    lrCurSel = SendMessage( GetDlgItem( m_hwnd, IDC_QUORUM_CB_QUORUM ),  CB_GETCURSEL, 0, 0 );

    fEnableOK = ( lrCurSel != CB_ERR );

    EnableWindow( GetDlgItem( m_hwnd, IDOK ), fEnableOK );

    TraceFuncExit();

} //*** CQuorumDlg::UpdateButtons


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrInitQuorumResource
//
//  Description:
//      Initialize the just chosen quorum resource.
//
//  Arguments:
//      pResourceIn
//          The resource that was chosen as the quorum.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT failures.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::HrInitQuorumResource(
    IClusCfgManagedResourceInfo * pResourceIn
    )
{
    TraceFunc( "" );
    Assert( pResourceIn != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  piccvq = NULL;
    BSTR                    bstrResource = NULL;

    //
    //  Does this resource implement the IClusCfgVerifyQuorum interface?
    //

    hr = pResourceIn->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
    if ( hr == E_NOINTERFACE )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // else if:

    hr = THR( pResourceIn->GetName( &bstrResource ) );
    if ( FAILED( hr ) )
    {
        bstrResource = TraceSysAllocString( L"<unknown>" );
    } // if:
    else
    {
        TraceMemoryAddBSTR( bstrResource );
    } // else:

    //
    //  The resource did implement the IClusCfgVerifyQuorum interface...
    //

    Assert( ( hr == S_OK ) && ( piccvq != NULL ) );

    hr = STHR( piccvq->PrepareToHostQuorumResource() );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[WIZ] PrepareToHostQuorum() failed for resource %ws. (hr = %#08x)", bstrResource, hr );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrResource );

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    HRETURN( hr );

} //*** CQuorumDlg::HrInitQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrCleanupQuorumResource
//
//  Description:
//      Cleanup the passed in quorum resource.
//
//  Arguments:
//      pResourceIn
//          The resource that used to be selected as the quorum.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT failures.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::HrCleanupQuorumResource(
    IClusCfgManagedResourceInfo * pResourceIn
    )
{
    TraceFunc( "" );
    Assert( pResourceIn != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  piccvq = NULL;
    BSTR                    bstrResource = NULL;

    //
    //  Does this resource implement the IClusCfgVerifyQuorum interface?
    //

    hr = pResourceIn->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
    if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
        goto Cleanup;
    } // if:
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // else if:

    hr = THR( pResourceIn->GetName( &bstrResource ) );
    if ( FAILED( hr ) )
    {
        bstrResource = TraceSysAllocString( L"<unknown>" );
    } // if:
    else
    {
        TraceMemoryAddBSTR( bstrResource );
    } // else:

    //
    //  The resource did implement the IClusCfgVerifyQuorum interface...
    //

    Assert( ( hr == S_OK ) && ( piccvq != NULL ) );

    hr = STHR( piccvq->Cleanup( crCANCELLED ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[WIZ] Cleanup() failed for resource %ws. (hr = %#08x)", bstrResource, hr );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrResource );

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    HRETURN( hr );

} //*** CQuorumDlg::HrCleanupQuorumResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodespage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodesPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "SelNodesPageCommon.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSelNodesPage
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSelNodesPage
    : public CSelNodesPageCommon
{

private: // data
    HWND                m_hwnd;     // Our HWND
    CClusCfgWizard *    m_pccw;     // Wizard

private: // methods
    LRESULT OnInitDialog( HWND hDlgIn );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

    HRESULT HrUpdateWizardButtons( bool fSetActiveIn = false );
    HRESULT HrAddNodeToList( void );
    HRESULT HrRemoveNodeFromList( void );

protected:

    virtual void OnFilteredNodesWithBadDomains( PCWSTR pwcszNodeListIn );
    virtual void OnProcessedValidNode( PCWSTR pwcszNodeNameIn );

    virtual HRESULT HrSetDefaultNode( PCWSTR pwcszNodeNameIn );

public: // methods
    CSelNodesPage( CClusCfgWizard *  pccwIn );
    virtual ~CSelNodesPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

}; //*** class CSelNodesPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodespagecommon.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodesPageCommon.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    05-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SelNodesPageCommon.h"
#include "WizardUtils.h"
#include "DelimitedIterator.h"

DEFINE_THISCLASS("CSelNodesPageCommon");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::CSelNodesPageCommon
//
//  Description:
//      Constructor.
//
//  Arguments:
//      idcBrowseButtonIn   - ID of the Browse pushbutton control.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPageCommon::CSelNodesPageCommon( void )
    : m_hwnd( NULL )
    , m_cfDsObjectPicker( 0 )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CSelNodesPageCommon::CSelNodesPageCommon

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::~CSelNodesPageCommon
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPageCommon::~CSelNodesPageCommon( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CSelNodesPageCommon::~CSelNodesPageCommon

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      hDlgIn
//      pccwIn
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//-
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPageCommon::OnInitDialog(
      HWND hDlgIn
    , CClusCfgWizard* pccwIn
    )
{
    TraceFunc( "" );
    Assert( m_hwnd == NULL );
    Assert( hDlgIn != NULL );

    LRESULT lr = FALSE; // Didn't set the focus.

    m_hwnd = hDlgIn;

    //
    // Get the Object Picker clipboard format.
    // Enable or disable the Browse button based on the success of that operation.
    //

    m_cfDsObjectPicker = RegisterClipboardFormat( CFSTR_DSOP_DS_SELECTION_LIST );
    if ( m_cfDsObjectPicker == 0 )
    {
        TW32( GetLastError() );
        //
        //  If registering the clipboard format fails, then disable the Browse
        //  button.
        //
        EnableWindow( GetDlgItem( hDlgIn, IDC_SELNODE_PB_BROWSE ), FALSE );

    } // if: failed to get the object picker clipboard format

    THR( HrInitNodeSelections( pccwIn ) );

    RETURN( lr );

} //*** CSelNodesPageCommon::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::HrBrowse
//
//  Description:
//      Browse for a computer or multiple computers using the Object Picker.
//
//  Arguments:
//      fMultipleNodesIn    - TRUE = allow multiple nodes to be selected.
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPageCommon::HrBrowse(
    bool    fMultipleNodesIn
    )
{
    TraceFunc( "" );
    Assert( m_hwnd != NULL );

    HRESULT             hr = S_OK;
    IDsObjectPicker *   piop = NULL;
    IDataObject *       pido = NULL;
    HCURSOR             hOldCursor = NULL;

    hOldCursor = SetCursor( LoadCursor( g_hInstance, IDC_WAIT ) );

    // Create an instance of the object picker.
    hr = THR( CoCreateInstance( CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (void **) &piop ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the object picker instance.
    hr = THR( HrInitObjectPicker( piop, fMultipleNodesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Restore the old cursor.
    SetCursor( hOldCursor );
    hOldCursor = NULL;

    // Invoke the modal dialog.
    hr = THR( piop->InvokeDialog( m_hwnd, &pido ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrGetSelections( pido, fMultipleNodesIn ) );
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = S_OK;                  // don't want to squawk in the caller...
    } // else if:

Cleanup:

    if ( pido != NULL )
    {
        pido->Release();
    } // if:

    if ( piop != NULL )
    {
        piop->Release();
    } // if:

    if ( hOldCursor != NULL )
    {
        SetCursor( hOldCursor );
    }

    HRETURN( hr );

} //*** CSelNodesPageCommon::HrBrowse

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::HrInitObjectPicker
//
//  Description:
//      Initialize the Object Picker dialog.
//
//  Arguments:
//      piopIn              - IDsObjectPicker
//      fMultipleNodesIn    - TRUE = allow multiple nodes to be selected.
//
//  Return Values:
//      HRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPageCommon::HrInitObjectPicker(
      IDsObjectPicker * piopIn
    , bool              fMultipleNodesIn
    )
{
    TraceFunc( "" );
    Assert( piopIn != NULL );

    DSOP_SCOPE_INIT_INFO    rgScopeInit[ 1 ];
    DSOP_INIT_INFO          iiInfo;

    ZeroMemory( rgScopeInit, sizeof( rgScopeInit ) );

    rgScopeInit[ 0 ].cbSize  = sizeof( DSOP_SCOPE_INIT_INFO );
    rgScopeInit[ 0 ].flType  = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                             | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    rgScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    rgScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    rgScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    ZeroMemory( &iiInfo, sizeof( iiInfo ) );

    iiInfo.cbSize            = sizeof( iiInfo );
    iiInfo.pwzTargetComputer = NULL;
    iiInfo.cDsScopeInfos     = 1;
    iiInfo.aDsScopeInfos     = rgScopeInit;

    if ( fMultipleNodesIn )
    {
        iiInfo.flOptions = DSOP_FLAG_MULTISELECT;
    }
    else
    {
        iiInfo.flOptions = 0;
    }

    HRETURN( piopIn->Initialize( &iiInfo ) );

} //*** CSelNodesPageCommon::HrInitObjectPicker

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::HrGetSelections
//
//  Description:
//      Get selections from the Object Picker dialog.
//
//  Arguments:
//      pidoIn              - IDataObject
//      fMultipleNodesIn    - TRUE = allow multiple nodes to be selected.
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//      Other HRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPageCommon::HrGetSelections(
      IDataObject *     pidoIn
    , bool              fMultipleNodesIn
    )
{
    TraceFunc( "" );
    Assert( pidoIn != NULL );
    Assert( m_hwnd != NULL );

    HRESULT             hr;
    STGMEDIUM           stgmedium = { TYMED_HGLOBAL, NULL, NULL };
    FORMATETC           formatetc = { (CLIPFORMAT) m_cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PDS_SELECTION_LIST  pds = NULL;
    DWORD               sc;
    HWND                hwndEdit = GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME );
    BSTR                bstrSelectionList = NULL;
    BSTR                bstrOldSelectionList = NULL;

    //
    // Get the data from the data object.
    //

    hr = THR( pidoIn->GetData( &formatetc, &stgmedium ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pds = (PDS_SELECTION_LIST) GlobalLock( stgmedium.hGlobal );
    if ( pds == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    // Construct the string to write into the edit control.
    //

    Assert( pds->cItems > 0 );

    if ( ! fMultipleNodesIn )
    {
        Assert( pds->cItems == 1 );
        Edit_SetText( hwndEdit, pds->aDsSelection[ 0 ].pwzName );
    } // if: multiple items are NOT supported
    else
    {
        ULONG   idx;

        for ( idx = 0 ; idx < pds->cItems; idx++ )
        {
            if ( bstrSelectionList == NULL ) // First name in list.
            {
                bstrSelectionList = TraceSysAllocString( pds->aDsSelection[ idx ].pwzName );
                if ( bstrSelectionList == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }
            }
            else // Append another name to non-empty list.
            {
                TraceSysFreeString( bstrOldSelectionList );
                bstrOldSelectionList = bstrSelectionList;
                bstrSelectionList = NULL;
                hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!; %2!ws!"
                            , &bstrSelectionList
                            , bstrOldSelectionList
                            , pds->aDsSelection[ idx ].pwzName
                            ) );                
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            } // else: append name to non-empty list.
        } // for each item in list

        Edit_SetText( hwndEdit, bstrSelectionList );
    } // else: multiple items are supported

    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrSelectionList );
    TraceSysFreeString( bstrOldSelectionList );

    if ( pds != NULL )
    {
        GlobalUnlock( stgmedium.hGlobal );
    } // if:

    if ( stgmedium.hGlobal != NULL )
    {
        ReleaseStgMedium( &stgmedium );
    } // if:

    HRETURN( hr );

} //*** CSelNodesPageCommon::HrGetSelections

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::HrInitNodeSelections
//
//  Description:
//      Validate node selections the wizard had on startup, and populate the
//      page's controls appropriately.
//
//  Arguments:
//      pccwIn              - The wizard containing this page.
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//      Other HRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPageCommon::HrInitNodeSelections( CClusCfgWizard* pccwIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrNodeName = NULL;
    BSTR    bstrComputerName = NULL;
    BSTR    bstrBadNodeList = NULL;
    BSTR    bstrLocalDomain = NULL;
    BSTR    bstrShortName = NULL;
    bool    fDefaultToLocalMachine = true;
    size_t  cNodes = 0;

    //
    //  Filter out any pre-loaded node FQDNs with bad domains.
    //
    hr = THR( pccwIn->HrFilterNodesWithBadDomains( &bstrBadNodeList ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    if ( bstrBadNodeList != NULL )
    {
        fDefaultToLocalMachine = false;
        
        //  Give subclasses a look at the whole list.
        OnFilteredNodesWithBadDomains( bstrBadNodeList );

        //  Loop through the list, notifying the user of each invalid node.
        //  This is destroys the list as it walks through it, so writing the
        //  list to the edit box needs to happen first.
        {
            CDelimitedIterator it( L" ,;", bstrBadNodeList, SysStringLen( bstrBadNodeList ) );
            while ( it.Current() != NULL )
            {
                THR( HrMessageBoxWithStatusString(
                                  m_hwnd
                                , IDS_ERR_VALIDATING_NAME_TITLE
                                , IDS_ERR_VALIDATING_NAME_TEXT
                                , IDS_ERR_HOST_DOMAIN_DOESNT_MATCH_CLUSTER
                                , 0
                                , MB_OK | MB_ICONSTOP
                                , NULL
                                , it.Current()
                                ) );

                //  Give subclasses a look at the bad node.
                OnProcessedNodeWithBadDomain( it.Current() );
                
                it.Next();
            }; // for each bad node
        } // Notify user of each bad node.
    } // if: some nodes have bad domains

    //
    //  Process any remaining valid nodes.
    //

    hr = THR( pccwIn->HrGetNodeCount( &cNodes ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    if ( cNodes > 0 )
    {
        for ( size_t idxNode = 0; idxNode < cNodes; ++idxNode )
        {
            hr = THR( pccwIn->HrGetNodeName( idxNode, &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if

            hr = THR( HrGetFQNDisplayName( bstrNodeName, &bstrShortName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if

            //  Give subclasses a look at the good node.
            OnProcessedValidNode( bstrShortName );

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;
            TraceSysFreeString( bstrShortName );
            bstrShortName = NULL;
        } // for each valid node.
        
        fDefaultToLocalMachine = false;
    } // if any valid nodes remain.

    //
    //  Decide whether defaulting to the local machine is appropriate at this time.
    //
    
    if ( fDefaultToLocalMachine )
    {
        DWORD dwStatus;
        DWORD dwClusterState;

        //
        //  If the node is already in a cluster, don't have it default in the edit box.
        //  If there is an error getting the "NodeClusterState", then default the node
        //  name (it could be in the middle of cleaning up the node).
        //

        dwStatus = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
        fDefaultToLocalMachine = ( ( dwStatus != ERROR_SUCCESS ) || ( dwClusterState == ClusterStateNotConfigured ) );

        if ( !fDefaultToLocalMachine )
        {
            goto Cleanup;
        } // if

        //
        //  ...but don't default if the local machine is not in the cluster's domain.
        //
        hr = THR( HrGetComputerName(
                          ComputerNamePhysicalDnsDomain
                        , &bstrLocalDomain
                        , TRUE // fBestEffortIn
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if

        hr = STHR( pccwIn->HrIsCompatibleNodeDomain( bstrLocalDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if

        fDefaultToLocalMachine = ( hr == S_OK );
        if ( !fDefaultToLocalMachine )
        {
            goto Cleanup;
        } // if

        //
        //  Now have cleared all the obstacles to defaulting to the local machine--hooray!
        //
        hr = THR( HrGetComputerName(
                          ComputerNameDnsHostname
                        , &bstrComputerName
                        , TRUE // fBestEffortIn
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if

        THR( HrSetDefaultNode( bstrComputerName ) );
    } // if defaulting to local machine is still an option.

Cleanup:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrComputerName );
    TraceSysFreeString( bstrBadNodeList );
    TraceSysFreeString( bstrLocalDomain );
    TraceSysFreeString( bstrShortName );

    HRETURN( hr );

} //*** CSelNodesPageCommon::HrInitNodeSelections

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::OnFilteredNodesWithBadDomains
//
//  Description:
//      Tells the subclass that the wizard had nodes with bad domains, and
//      allows the subclass to inspect the list before the base class
//      iterates through them.
//
//  Arguments:
//      pwcszNodeListIn
//          The nodes with clashing domains, delimited by spaces, commas, or
//          semicolons.
//
//  Return Values:
//      None.
//
//  Remarks:
//      This do-nothing default implementation allows subclasses
//      to avoid having to implement do-nothing responses themselves if they
//      don't want to do anything with the whole list at once.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodesPageCommon::OnFilteredNodesWithBadDomains( PCWSTR pwcszNodeListIn )
{
    UNREFERENCED_PARAMETER( pwcszNodeListIn );
    
} //*** CSelNodesPageCommon::OnFilteredNodesWithBadDomains

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::OnProcessedNodeWithBadDomain
//
//  Description:
//      Allows the subclass to process each node in the list of nodes with
//      bad domains as the base class iterates through it.
//
//  Arguments:
//      pwcszNodeNameIn
//          The node with a clashing domain.
//
//  Return Values:
//      None.
//
//  Remarks:
//      The base class notifies the user of each bad node name before calling
//      this method, so the base class provides also this default do-nothing
//      implementation for subclasses that don't need to do anything more.
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodesPageCommon::OnProcessedNodeWithBadDomain( PCWSTR pwcszNodeNameIn )
{
    UNREFERENCED_PARAMETER( pwcszNodeNameIn );
    
} //*** CSelNodesPageCommon::OnProcessedNodeWithBadDomain


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPageCommon::OnProcessedValidNode
//
//  Description:
//      Allows the subclass to process each node remaining in the wizard's
//      list after those with bad domains have been removed.
//
//  Arguments:
//      pwcszNodeNameIn
//          The IP address or hostname (NOT the FQDN) of a valid node in
//          the wizard's list.
//
//  Return Values:
//      None.
//
//  Remarks:
//      This default do-nothing implementation allows subclasses to
//      ignore the node if they choose.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodesPageCommon::OnProcessedValidNode( PCWSTR pwcszNodeNameIn )
{
    UNREFERENCED_PARAMETER( pwcszNodeNameIn );
    
} //*** CSelNodesPageCommon::OnProcessedValidNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodespage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      SelNodesPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SelNodesPage.h"
#include "WizardUtils.h"
#include "Nameutil.h"
#include "AdvancedDlg.h"
#include "DelimitedIterator.h"

DEFINE_THISCLASS("CSelNodesPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::CSelNodesPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn                   - CClusCfgWizard
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPage::CSelNodesPage(
      CClusCfgWizard *    pccwIn
    )
    : m_hwnd( NULL )
    , m_pccw( pccwIn )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );
    m_pccw->AddRef();

    TraceFuncExit();

} //*** CSelNodesPage::CSelNodesPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::~CSelNodesPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPage::~CSelNodesPage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    TraceFuncExit();

} //*** CSelNodesPage::~CSelNodesPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      hDlgIn
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//-
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnInitDialog(
    HWND hDlgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // Didn't set the focus.

    //
    // Call the base class function.
    // This must be called before any other base class methods are called.
    //

    CSelNodesPageCommon::OnInitDialog( hDlgIn, m_pccw );

    RETURN( lr );

} //*** CSelNodesPage::OnInitDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_SELNODE_E_COMPUTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_LB_NODES:
            if ( idNotificationIn == LBN_SELCHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_BROWSE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrBrowse( true /* fMultipleNodesIn */ ) );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_ADD:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrAddNodeToList() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_REMOVE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrRemoveNodeFromList() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_ADVANCED:
            if ( idNotificationIn == BN_CLICKED )
            {
                HRESULT hr;

                hr = STHR( CAdvancedDlg::S_HrDisplayModalDialog( m_hwnd, m_pccw ) );
                if ( hr == S_OK )
                {
                    OnNotifySetActive();
                } // if:

                lr = TRUE;
            } // if:
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CSelNodesPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      fSetActiveIn    - TRUE = called while handling PSN_SETACTIVE.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrUpdateWizardButtons(
    bool    fSetActiveIn    // = false
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HWND    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    DWORD   dwLen;
    LRESULT lr;

    // Disable the Next button if there are no entries in the list box
    // or if the edit control is not empty.
    lr = ListBox_GetCount( hwndList );
    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ) );
    if (    ( lr == 0 )
        ||  ( dwLen != 0 ) )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    // This cannot be done synchronously if called while handling
    // PSN_SETACTIVE.  Otherwise, do it synchronously.
    if ( fSetActiveIn )
    {
        PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );
    }
    else
    {
        SendMessage( GetParent( m_hwnd ), PSM_SETWIZBUTTONS, 0, (LPARAM) dwFlags );
    }

    // Enable or disable the Add button based on whether there is text
    // in the edit control or not.
    if ( dwLen == 0 )
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_ADD ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_ADD ), TRUE );
        SendMessage( m_hwnd, DM_SETDEFID, IDC_SELNODE_PB_ADD, 0 );
    }

    // Enable or disable the Remove button based whether an item is
    // selected in the list box or not.
    lr = ListBox_GetCurSel( hwndList );
    if ( lr == LB_ERR )
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_REMOVE ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_REMOVE ), TRUE );
    }

    HRETURN( hr );

} //*** CSelNodesPage::HrUpdateWizardButtons

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrAddNodeToList
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrAddNodeToList( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   dwLen = 0;
    int     idcFocus = 0;
    BSTR    bstrErrorMessage = NULL;
    BSTR    bstrErrorTitle = NULL;
    LPWSTR  pszComputerList = NULL;

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ) );
    if ( dwLen == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_SUCCESS ) )
        {
            AssertMsg( dwLen != 0, "How did we get here?!" );
        }
        goto Error;
    }

    pszComputerList = new WCHAR[ dwLen + 1 ];
    if ( pszComputerList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    dwLen = GetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pszComputerList, dwLen + 1 );
    AssertMsg( dwLen != 0, "How did we get here?!" );

    //
    // Validate each computer name entered.
    //
    {
        CDelimitedIterator it( L",; ", pszComputerList, dwLen );
        while (  it.Current() != NULL )
        {
            int dwIndex = ListBox_FindStringExact( 
                    GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES ), 
                    -1, it.Current()); // case insensitive search

            // add the string only if it is not already there
            if ( dwIndex == LB_ERR )
            {
                hr = THR( HrValidateFQNPrefix( it.Current() ) );
                if ( FAILED( hr ) )
                {
                    THR( HrShowInvalidLabelPrompt( m_hwnd, it.Current(), hr ) );
                    idcFocus = IDC_SELNODE_E_COMPUTERNAME;
                    goto Error;
                }

                hr = STHR( m_pccw->HrAddNode( it.Current(), true /*accept non-RFC characters*/ ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                if ( hr == S_OK )
                {
                    ListBox_AddString( GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES ), it.Current() );
                }
                else if ( hr == S_FALSE )
                {
                    hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_ERR_DUPLICATE_NODE_TEXT, &bstrErrorMessage, it.Current() ) );
                    if ( FAILED( hr ) )
                    {
                        goto Error;
                    }

                    hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_ERR_DUPLICATE_NODE_TITLE, &bstrErrorTitle ) );
                    if ( FAILED( hr ) )
                    {
                        goto Error;
                    }

                    MessageBox( m_hwnd, bstrErrorTitle, bstrErrorMessage, MB_OK | MB_ICONSTOP );

                    TraceSysFreeString( bstrErrorTitle );
                    bstrErrorTitle = NULL;

                    TraceSysFreeString( bstrErrorMessage );
                    bstrErrorMessage = NULL;
                }
            }
            it.Next();
        } // for each computer name entered
    } // validating each computer name

    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, L"" );

    hr = THR( HrUpdateWizardButtons() );
    goto Cleanup;

Error:

    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }
    goto Cleanup;

Cleanup:

    if ( pszComputerList != NULL )
    {
        delete[] pszComputerList;
    }

    TraceSysFreeString( bstrErrorMessage );
    TraceSysFreeString( bstrErrorTitle );
    
    HRETURN( hr );
} //*** CSelNodesPage::HrAddNodeToList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrRemoveNodeFromList
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrRemoveNodeFromList( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrNodeName = NULL;
    HWND    hwndList;
    LRESULT lr;
    int     cchName = 0;

    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );
    lr = ListBox_GetCurSel( hwndList );
    if ( lr != LB_ERR )
    {
        cchName = ListBox_GetTextLen( hwndList, lr );
        Assert( cchName != LB_ERR );
        cchName++;  // Add one for NULL
        bstrNodeName = TraceSysAllocStringLen( NULL, cchName );
        if( bstrNodeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        ListBox_GetText( hwndList, lr, bstrNodeName );
        hr = THR( m_pccw->RemoveComputer( bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        ListBox_DeleteString( hwndList, lr );
    } // if: lr != LB_ERR

    hr = THR( HrUpdateWizardButtons() );

Cleanup:
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CSelNodesPage::HrRemoveNodeFromList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    THR( HrUpdateWizardButtons( true ) );

    RETURN( lr );

} //*** CSelNodesPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CSelNodesPage::OnNotifyQueryCancel

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//      LB_ERR
//      Other LRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    RETURN( lr );
} //*** CSelNodesPage::OnNotifyWizNext

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CSelNodesPage::OnNotify

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CSelNodesPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSelNodesPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CSelNodesPage * pPage = reinterpret_cast< CSelNodesPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        Assert( lParam != NULL );

        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSelNodesPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog( hDlgIn );
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CSelNodesPage::S_DlgProc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnFilteredNodesWithBadDomains
//
//  Description:
//
//  Arguments:
//      pwcszNodeListIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodesPage::OnFilteredNodesWithBadDomains( PCWSTR pwcszNodeListIn )
{
    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pwcszNodeListIn );
    
} //*** CSelNodesPage::OnFilteredNodesWithBadDomains

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnProcessedValidNode
//
//  Description:
//
//  Arguments:
//      pwcszNodeNameIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CSelNodesPage::OnProcessedValidNode( PCWSTR pwcszNodeNameIn )
{
    ListBox_AddString( GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES ), pwcszNodeNameIn );
    
} //*** CSelNodesPage::OnProcessedValidNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrSetDefaultNode
//
//  Description:
//
//  Arguments:
//      pwcszNodeNameIn
//
//  Return Values:
//      S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrSetDefaultNode( PCWSTR pwcszNodeNameIn )
{
    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pwcszNodeNameIn );
    return S_OK;
    
} //*** CSelNodesPage::HrSetDefaultNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\selnodespagecommon.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      SelNodesPageCommon.h
//
//  Maintained By:
//      David Potter    (DavidP)    05-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSelNodesPage
//
//  Description:
//      Class to implement base functionality for selecting nodes to be
//      added to the cluster or for creating the cluster.  This class
//      assumes the control ID for the browse button and the computer
//      name edit control.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSelNodesPageCommon
{

private: // data
    HWND    m_hwnd;                 // Our HWND.
    UINT    m_cfDsObjectPicker;     // Object picker clipboard format.

    HRESULT HrInitNodeSelections( CClusCfgWizard* pccwIn );
    
protected: // methods
    CSelNodesPageCommon( void );
    virtual ~CSelNodesPageCommon( void );

    LRESULT OnInitDialog( HWND hDlgIn, CClusCfgWizard* pccwIn );

    HRESULT HrBrowse( bool fMultipleNodesIn );
    HRESULT HrInitObjectPicker( IDsObjectPicker * piopIn, bool fMultipleNodesIn );
    HRESULT HrGetSelections( IDataObject * pidoIn, bool fMultipleNodesIn );

    virtual void OnFilteredNodesWithBadDomains( PCWSTR pwcszNodeListIn );
    virtual void OnProcessedNodeWithBadDomain( PCWSTR pwcszNodeNameIn );
    virtual void OnProcessedValidNode( PCWSTR pwcszNodeNameIn );

    virtual HRESULT HrSetDefaultNode( PCWSTR pwcszNodeNameIn ) = 0;

public: // methods

}; //*** class CSelNodesPageCommon
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\waitcursor.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      WaitCursor.h
//
//  Description:
//      Wait Cursor stack class.
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CWaitCursor
{
private:
    HCURSOR m_hOldCursor;

public:
    explicit CWaitCursor( ) { m_hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( m_hOldCursor ); };

}; // class CWaitCursor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\summarypage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SummaryPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    06-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

struct SResourceState
{
    BOOL fState;        //  The initial state of the resource.
    BOOL fNeedCleanup;  //  Was PrepareToHostQuorum() successfully called?  If so then we need to call cleanup;
};

struct SStateArray
{
    BOOL                bInitialized;   //  Has the array been initialized.
    DWORD               cCount;         //  How big is the array.
    SResourceState *    prsArray;       //  The initial states of the resources.
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSummaryPage
//
//  Description:
//      Display the Summary page.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSummaryPage
{

private: // data
    HWND                m_hwnd;             //  Our HWND
    CClusCfgWizard *    m_pccw;             // Wizard
    ECreateAddMode      m_ecamCreateAddMode;//  Creating? Adding?
    UINT                m_idsNext;          //  Resource ID for Click Next string.
    SStateArray         m_ssa;              //  Initial managed state of each resource.

private: // methods
    LRESULT OnInitDialog( void );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifySetActive( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

    HRESULT HrFormatNetworkInfo( IClusCfgNetworkInfo * pccniIn, BSTR * pbstrOut );
    HRESULT HrCredentialsSummary( HWND hwndIn, SETTEXTEX * pstexIn, IClusCfgClusterInfo * piccciIn );
    HRESULT HrNodeSummary( HWND hwndIn, SETTEXTEX * pstexIn );
    HRESULT HrResourceSummary( HWND hwndIn, SETTEXTEX * pstexIn );
    HRESULT HrNetworkSummary( HWND hwndIn, SETTEXTEX * pstexIn );

public: // methods
    CSummaryPage(
          CClusCfgWizard *  pccwIn
        , ECreateAddMode    ecamCreateAddModeIn
        , UINT              idsNextIn
        );
    virtual ~CSummaryPage( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CSummaryPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\tasktreeview.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskTreeView.h
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//      Geoffrey Pease  (GPease)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CAnalyzePage;
class CCommitPage;

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
//  This structure is on the lParam of all tree view items.
//
typedef struct STreeItemLParamData
{
    // Data collected from SendStatusReport.
    CLSID       clsidMajorTaskId;
    CLSID       clsidMinorTaskId;
    BSTR        bstrNodeName;
    ULONG       nMin;
    ULONG       nMax;
    ULONG       nCurrent;
    HRESULT     hr;
    BSTR        bstrDescription;
    FILETIME    ftTime;
    BSTR        bstrReference;

    // Data not collected from SendStatusReport.
    BOOL        fParentToAllNodeTasks;
    BSTR        bstrNodeNameWithoutDomain;
} STreeItemLParamData, * PSTreeItemLParamData;

typedef enum ETaskStatus
{
    tsUNKNOWN = 0,
    tsPENDING,      // E_PENDING
    tsDONE,         // S_OK
    tsWARNING,      // S_FALSE
    tsFAILED,       // FAILED( hr )
    tsMAX
} ETaskStatus;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskTreeView
//
//  Description:
//      Handles the tree view control that displays tasks.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskTreeView
{
friend class CAnalyzePage;
friend class CCommitPage;

private: // data
    HWND        m_hwndParent;
    HWND        m_hwndTV;
    HWND        m_hwndProg;
    HWND        m_hwndStatus;
    HIMAGELIST  m_hImgList;                 //  Image list of icons for tree view
    ULONG       m_nRangeHigh;               //  Progress bar high range
    ULONG       m_nInitialTickCount;        //  Initial count passed in via constructor
    ULONG       m_nCurrentPos;              //  Remember the current position
    BOOL        m_fThresholdBroken;         //  Has the initial count threshold been broken?
    ULONG       m_nRealPos;                 //  Real position on the progress bar.
    HTREEITEM   m_htiSelected;              //  Selected item in the tree
    BSTR        m_bstrClientMachineName;    //  Default node name for SendStatusReport
    BOOL        m_fDisplayErrorsAsWarnings; //  If TRUE, uses yellow bang icon for errors instead of red x

    PSTreeItemLParamData *  m_ptipdProgressArray;   //  Dynamic sparse array of tasks that reported a progress_update.
    size_t                  m_cPASize;              //  The currently allocated size of the array.
    size_t                  m_cPACount;             //  The number of entries currently stored in the array.

private: // methods
    CTaskTreeView(
          HWND  hwndParentIn
        , UINT      uIDTVIn
        , UINT      uIDProgressIn
        , UINT      uIDStatusIn
        , size_t    uInitialTickCount
        );
    virtual ~CTaskTreeView( void );

    void    OnNotifyDeleteItem( LPNMHDR pnmhdrIn );
    void    OnNotifySelChanged( LPNMHDR pnmhdrIn );
    HRESULT HrInsertTaskIntoTree(
              HTREEITEM             htiFirstIn
            , STreeItemLParamData * ptipdIn
            , int                   nImageIn
            , BSTR                  bstrDescriptionIn
            );

    HRESULT HrProcessUpdateProgressTask( const STreeItemLParamData * ptipdIn );
             
    HRESULT HrUpdateProgressBar(
              const STreeItemLParamData * ptipdPrevIn
            , const STreeItemLParamData * ptipdNewIn
            );
    HRESULT HrPropagateChildStateToParents(
              HTREEITEM htiChildIn
            , int       nImageIn
            , BOOL      fOnlyUpdateProgressIn
            );

public:  // methods
    HRESULT HrOnInitDialog( void );
    HRESULT HrOnSendStatusReport(
              LPCWSTR       pcszNodeNameIn
            , CLSID         clsidTaskMajorIn
            , CLSID         clsidTaskMinorIn
            , ULONG         nMinIn
            , ULONG         nMaxIn
            , ULONG         nCurrentIn
            , HRESULT       hrStatusIn
            , LPCWSTR       pcszDescriptionIn
            , FILETIME *    pftTimeIn
            , LPCWSTR       pcszReferenceIn
            );
    HRESULT HrAddTreeViewRootItem( UINT idsIn, REFCLSID rclsidTaskIDIn )
    {
        return THR( HrAddTreeViewItem(
                              NULL      // phtiOut
                            , idsIn
                            , rclsidTaskIDIn
                            , IID_NULL
                            , TVI_ROOT
                            , TRUE      // fParentToAllNodeTasksIn
                            ) );

    } //*** CTaskTreeView::HrAddTreeViewRootItem
    HRESULT HrAddTreeViewItem(
              HTREEITEM *   phtiOut
            , UINT          idsIn
            , REFCLSID      rclsidMinorTaskIDIn
            , REFCLSID      rclsidMajorTaskIDIn     = IID_NULL
            , HTREEITEM     htiParentIn             = TVI_ROOT
            , BOOL          fParentToAllNodeTasksIn = FALSE
            );
    HRESULT HrOnNotifySetActive( void );

    LRESULT OnNotify( LPNMHDR pnmhdrIn );

    HRESULT HrShowStatusAsDone( void );
    HRESULT HrDisplayDetails( void );
    BOOL    FGetItem( HTREEITEM htiIn, STreeItemLParamData ** pptipdOut );
    HRESULT HrFindPrevItem( HTREEITEM * phtiOut );
    HRESULT HrFindNextItem( HTREEITEM * phtiOut );
    HRESULT HrSelectItem( HTREEITEM htiIn );

    void SetDisplayErrorsAsWarnings( BOOL fDisplayErrorsAsWarningsIn )
    {
        m_fDisplayErrorsAsWarnings = fDisplayErrorsAsWarningsIn;

    } //*** CTaskTreeView::SetDisplayErrorsAsWarnings

    BOOL FDisplayErrorsAsWarnings( void )
    {
        return m_fDisplayErrorsAsWarnings;

    } //*** CTaskTreeView::FDisplayErrorsAsWarnings

}; //*** class CTaskTreeView
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\welcomepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      WelcomePage.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "WelcomePage.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
DEFINE_THISCLASS("CWelcomePage");


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CWelcomePage class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::CWelcomePage
//
//  Description:
//      Constructor
//
//  Arguments:
//      ecamCreateAddModeIn
//          Creating cluster or adding nodes to cluster.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWelcomePage::CWelcomePage(
      CClusCfgWizard *  pccwIn
    , ECreateAddMode    ecamCreateAddModeIn
    ) : m_pccw( pccwIn )
{
    TraceFunc( "" );

    //
    //  Cannot Assert that these are in a zero state since this page
    //  is allocated on the stack and not by our zero-initing heap alloc
    //  function...
    //

    m_hwnd = NULL;
    m_hFont = NULL;

    Assert( m_pccw != NULL );
    m_pccw->AddRef();

    m_ecamCreateAddMode = ecamCreateAddModeIn;

    TraceFuncExit();

} //*** CWelcomePage::CWelcomePage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::~CWelcomePage
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWelcomePage::~CWelcomePage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    } // if:

    if ( m_hFont != NULL )
    {
        DeleteObject( m_hFont );
    } // if:

    TraceFuncExit();

} //*** CWelcomePage::~CWelcomePage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::OnInitDialog
//
//  Description:
//      Process the WM_INIT_DIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      LRESULT TRUE all the time...
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CWelcomePage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT             lr = TRUE;
    HDC                 hdc = NULL;
    HRESULT             hr;
    NONCLIENTMETRICS    ncm;
    LOGFONT             LogFont;
    INT                 iSize;
    DWORD               dw;
    BOOL                fRet;
    WCHAR               szFontSize[ 3 ];    // shouldn't be bigger than 2 digits!!
    BSTR                bstrRequirement  = NULL;
    BSTR                bstrFormattedReq = NULL;
    BSTR                bstrRequirements = NULL;
    int                 idxids;
    int                 cidsRequirements;
    UINT *              pidsRequirements;

    static UINT rgidsCreateRequirements[] =
    {
          IDS_WELCOME_CREATE_REQ_1
        , IDS_WELCOME_CREATE_REQ_2
        , IDS_WELCOME_CREATE_REQ_3
        , IDS_WELCOME_CREATE_REQ_4
        , IDS_WELCOME_CREATE_REQ_5
    };

    static UINT rgidsAddRequirements[] =
    {
          IDS_WELCOME_ADD_REQ_1
        , IDS_WELCOME_ADD_REQ_2
    };

    //
    //  Make the Title static BIG and BOLD. Why the wizard control itself can't
    //  do this is beyond me!
    //

    ZeroMemory( &ncm, sizeof( ncm ) );
    ZeroMemory( &LogFont, sizeof( LogFont ) );

    //
    //  Find out the system default font metrics.
    //
    ncm.cbSize = sizeof( ncm );
    fRet = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    if ( fRet == FALSE )
    {
        TW32( GetLastError() );
        goto Cleanup;
    } // if:

    //
    //  Copy it.
    //
    LogFont = ncm.lfMessageFont;

    //
    //  Make it BOLD.
    //
    LogFont.lfWeight = FW_BOLD;

    //
    //  Find out what we want it to look like.
    //
    dw = LoadString( g_hInstance, IDS_LARGEFONTNAME, LogFont.lfFaceName, ARRAYSIZE( LogFont.lfFaceName ) );
    AssertMsg( dw != 0, "String missing!" );

    dw = LoadString( g_hInstance, IDS_LARGEFONTSIZE, szFontSize, ARRAYSIZE( szFontSize ) );
    AssertMsg( dw != 0, "String missing!" );

    iSize = wcstoul( szFontSize, NULL, 10 );

    //
    //  Grab the DC.
    //
    hdc = GetDC( m_hwnd );
    if ( hdc == NULL )
    {
        TW32( GetLastError() );
        goto Cleanup;
    } // if:

    //
    //  Use the magic equation....
    //
    LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * iSize / 72 );

    //
    //  Create the font.
    //
    m_hFont = CreateFontIndirect( &LogFont );
    if ( m_hFont == NULL )
    {
        TW32( GetLastError() );
        goto Cleanup;
    } // if:

    //
    //  Apply the font.
    //
    SetWindowFont( GetDlgItem( m_hwnd, IDC_WELCOME_S_TITLE ), m_hFont, TRUE );

    //
    // Load the requirement text.
    //

    if ( m_ecamCreateAddMode == camCREATING )
    {
        pidsRequirements = rgidsCreateRequirements;
        cidsRequirements = ARRAYSIZE( rgidsCreateRequirements );
    } // if: creating a new cluster
    else
    {
        pidsRequirements = rgidsAddRequirements;
        cidsRequirements = ARRAYSIZE( rgidsAddRequirements );
    } // else: adding nodes to an existing cluster

    for ( idxids = 0 ; idxids < cidsRequirements ; idxids++ )
    {
        hr = HrLoadStringIntoBSTR( g_hInstance, pidsRequirements[ idxids ], &bstrRequirement );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = HrFormatStringIntoBSTR( L"  - %1!ws!\n", &bstrFormattedReq, bstrRequirement );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = HrConcatenateBSTRs( &bstrRequirements, bstrFormattedReq );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( bstrRequirement );
        bstrRequirement = NULL;
    } // for: each requirement string

    SetDlgItemText( m_hwnd, IDC_WELCOME_S_REQUIREMENTS, bstrRequirements );

Cleanup:

    if ( hdc != NULL )
    {
        ReleaseDC( m_hwnd, hdc );
    } // if:

    TraceSysFreeString( bstrRequirement );
    TraceSysFreeString( bstrFormattedReq );
    TraceSysFreeString( bstrRequirements );

    RETURN( lr );

} //*** CWelcomePage::OnInitDialog


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::OnNotifyWizNext
//
//  Description:
//      Process the PSN_WIZNEXT notification message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      LRESULT TRUE all the time...
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CWelcomePage::OnNotifyWizNext( void )
{
    TraceFunc( "" );
    Assert( m_pccw != NULL );

    RETURN( (LRESULT) TRUE );

} //*** CWelcomePage::OnNotifyWizNext


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::OnNotify
//
//  Description:
//      Process the WM_NOTIFY message.
//
//  Arguments:
//      idCtrlIn
//
//      pnmhdrIn
//
//  Return Values:
//      LRESULT TRUE or FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CWelcomePage::OnNotify(
      WPARAM  idCtrlIn
    , LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_NEXT );
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;
    } // switch:

    RETURN( lr );

} //*** CWelcomePage::OnNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::OnInitDialog
//
//  Description:
//      Dialog proc for the Welcome page in the Wizard.
//
//  Arguments:
//      hwndDlgIn
//          Window handle to this page.
//
//      nMsgIn
//          The windows message that was sent to this page.
//
//      wParam
//          The WPARAM of the message above.  This is different for
//          different messages.
//
//      lParam
//          The LPARAM of the message above.  This is different for
//          different messages.
//
//  Return Values:
//      LRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
CWelcomePage::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CWelcomePage *  pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );

        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CWelcomePage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    } // if:
    else
    {
        pPage = reinterpret_cast< CWelcomePage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    } // else:

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch ( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CWelcomePage::S_DlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\summarypage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      SummaryPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    06-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SummaryPage.h"
#include "QuorumDlg.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CSummaryPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage::CSummaryPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pccwIn              -- CClusCfgWizard
//      ecamCreateAddModeIn -- Creating cluster or adding nodes to cluster
//      idsNextIn           -- Resource ID for the Click Next string.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSummaryPage::CSummaryPage(
    CClusCfgWizard *    pccwIn,
    ECreateAddMode      ecamCreateAddModeIn,
    UINT                idsNextIn
    )
    : m_pccw( pccwIn )
{
    TraceFunc( "" );

    Assert( pccwIn != NULL );
    Assert( idsNextIn != 0 );

    m_pccw->AddRef();
    m_ecamCreateAddMode = ecamCreateAddModeIn;
    m_idsNext           = idsNextIn;

    m_ssa.bInitialized  = FALSE;
    m_ssa.cCount        = 0;
    m_ssa.prsArray      = NULL;

    TraceFuncExit();

} //*** CSummaryPage::CSummaryPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage::~CSummaryPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CSummaryPage::~CSummaryPage( void )
{
    TraceFunc( "" );

    if ( m_pccw != NULL )
    {
        m_pccw->Release();
    }

    delete [] m_ssa.prsArray;

    TraceFuncExit();

} //*** CSummaryPage::~CSummaryPage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // don't have Windows set default focus
    HRESULT hr;
    BSTR    bstrNext = NULL;
    BOOL    fShowQuorumButton;

    //
    //  Set the background color.
    //

    SendDlgItemMessage(
          m_hwnd
        , IDC_SUMMARY_RE_SUMMARY
        , EM_SETBKGNDCOLOR
        , 0
        , GetSysColor( COLOR_3DFACE )
        );

    //
    // Set the text of the Click Next control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsNext, &bstrNext );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_SUMMARY_S_NEXT, bstrNext );

    //
    // Hide the Quorum button if not creating a cluster.
    //

    fShowQuorumButton = ( m_ecamCreateAddMode == camCREATING );
    ShowWindow( GetDlgItem( m_hwnd, IDC_SUMMARY_PB_QUORUM ), fShowQuorumButton ? SW_SHOW : SW_HIDE );

Cleanup:
    TraceSysFreeString( bstrNext );

    RETURN( lr );

} //*** CSummaryPage::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HWND        hwnd = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwClusterIPAddress = 0;
    DWORD       dwClusterSubnetMask = 0;
    SETTEXTEX   stex;
    CHARRANGE   charrange;
    LRESULT     lr = TRUE;
    BSTR        bstr = NULL;
    BSTR        bstrClusterName = NULL;

    IClusCfgClusterInfo *   pcci  = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;

    //
    //  We're going to be using the control a lot. Grab the HWND to use.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_SUMMARY_RE_SUMMARY );

    //
    //  Empty the window
    //

    SetWindowText( hwnd, L"" );

    //
    //  Initilize some stuff.
    //

    stex.flags = ST_SELECTION;
    stex.codepage = 1200;   // no translation/unicode

    //
    //  Find the cluster configuration information.
    //

    hr = THR( m_pccw->HrGetClusterObject( &pcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Name
    //

    hr = THR( m_pccw->get_ClusterName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    TraceMemoryAddBSTR( bstrClusterName );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_CLUSTER_NAME, &bstr, bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr);

    //
    //  IPAddress
    //

    hr = THR( pcci->GetIPAddress( &dwClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcci->GetSubnetMask( &dwClusterSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( dwClusterIPAddress != 0 );
    Assert( dwClusterSubnetMask != 0 );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_IPADDRESS,
                                       &bstr,
                                       FOURTH_IPADDRESS( dwClusterIPAddress ),
                                       THIRD_IPADDRESS( dwClusterIPAddress ),
                                       SECOND_IPADDRESS( dwClusterIPAddress ),
                                       FIRST_IPADDRESS( dwClusterIPAddress ),
                                       FOURTH_IPADDRESS( dwClusterSubnetMask ),
                                       THIRD_IPADDRESS( dwClusterSubnetMask ),
                                       SECOND_IPADDRESS( dwClusterSubnetMask ),
                                       FIRST_IPADDRESS( dwClusterSubnetMask )
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Network
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_CLUSTER_NETWORK, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    hr = THR( pcci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrFormatNetworkInfo( pccni, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Credentials
    //

    hr = THR( HrCredentialsSummary( hwnd, &stex, pcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Members of cluster
    //

    hr = THR( HrNodeSummary( hwnd, &stex ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Resources
    //

    hr = THR( HrResourceSummary( hwnd, &stex ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Networks
    //

    hr = THR( HrNetworkSummary( hwnd, &stex ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Done.
    //

    charrange.cpMax = 0;
    charrange.cpMin = 0;
    SendMessage( hwnd, EM_EXSETSEL, 0, (LPARAM) &charrange );

    PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_BACK | PSWIZB_NEXT );

Cleanup:
    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrClusterName );

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( pcci != NULL )
    {
        pcci->Release();
    }

    RETURN( lr );

} //*** CSummaryPage::OnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd, IDS_QUERY_CANCEL_TITLE, IDS_QUERY_CANCEL_TEXT, MB_YESNO );
    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    } // if:
    else
    {
        THR( m_pccw->HrLaunchCleanupTask() );
    } // else:

    RETURN( lr );

} //*** CSummaryPage::OnNotifyQueryCancel


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch ( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CSummaryPage::OnNotify

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
    HRESULT hr = S_OK;

    switch ( idControlIn )
    {
        case IDC_SUMMARY_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_SUMMARY_PB_QUORUM:
            if ( idNotificationIn == BN_CLICKED )
            {
                hr = STHR( CQuorumDlg::S_HrDisplayModalDialog( m_hwnd, m_pccw, &m_ssa ) );
                if ( hr == S_OK )
                {
                    OnNotifySetActive();
                }
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CSummaryPage::OnCommand

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CSummaryPage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSummaryPage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CSummaryPage *  pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSummaryPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CSummaryPage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch ( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is available

    return lr;

} //*** CSummaryPage::S_DlgProc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CSummaryPage::HrFormatNetworkInfo(
//      IClusCfgNetworkInfo * pccniIn,
//      BSTR * pbstrOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrFormatNetworkInfo(
    IClusCfgNetworkInfo * pccniIn,
    BSTR * pbstrOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    DWORD   dwNetworkIPAddress;
    DWORD   dwNetworkSubnetMask;

    BSTR    bstrNetworkName = NULL;
    BSTR    bstrNetworkDescription = NULL;
    BSTR    bstrNetworkUsage = NULL;

    IClusCfgIPAddressInfo * pccipai = NULL;

    hr = THR( pccniIn->GetName( &bstrNetworkName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( ( bstrNetworkName != NULL ) && ( *bstrNetworkName != L'\0' ) );
    TraceMemoryAddBSTR( bstrNetworkName );

    hr = THR( pccniIn->GetDescription( &bstrNetworkDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrNetworkDescription );

    hr = STHR( pccniIn->IsPublic() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORK_PUBLIC, &bstrNetworkUsage ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: public network

    hr = STHR( pccniIn->IsPrivate() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        if ( bstrNetworkUsage == NULL )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORK_PRIVATE, &bstrNetworkUsage ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: not public network
        else
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORK_BOTH, &bstrNetworkUsage ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // else: public network

    } // if: private network
    else if ( bstrNetworkUsage == NULL )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORK_NOTUSED, &bstrNetworkUsage ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // else: not private or public network

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetIPAddress( &dwNetworkIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetSubnetMask( &dwNetworkSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( dwNetworkIPAddress != 0 );
    Assert( dwNetworkSubnetMask != 0 );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_NETWORK_INFO,
                                       pbstrOut,
                                       bstrNetworkName,
                                       bstrNetworkDescription,
                                       bstrNetworkUsage,
                                       FOURTH_IPADDRESS( dwNetworkIPAddress ),
                                       THIRD_IPADDRESS( dwNetworkIPAddress ),
                                       SECOND_IPADDRESS( dwNetworkIPAddress ),
                                       FIRST_IPADDRESS( dwNetworkIPAddress ),
                                       FOURTH_IPADDRESS( dwNetworkSubnetMask ),
                                       THIRD_IPADDRESS( dwNetworkSubnetMask ),
                                       SECOND_IPADDRESS( dwNetworkSubnetMask ),
                                       FIRST_IPADDRESS( dwNetworkSubnetMask )
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    TraceSysFreeString( bstrNetworkUsage );
    TraceSysFreeString( bstrNetworkName );
    TraceSysFreeString( bstrNetworkDescription );

    HRETURN( hr );

} //*** CSummaryPage::HrEditStreamCallback

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrCredentialsSummary
//
//  Description:
//      Format and display the credentials summary.
//
//  Arguments:
//      hwndIn
//          The window to display the text in.
//
//      pstexIn
//          Dunno?  We just need it?!
//
//      piccciIn
//          Pointer to the cluster info object.
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrCredentialsSummary(
      HWND                  hwndIn
    , SETTEXTEX *           pstexIn
    , IClusCfgClusterInfo * piccciIn
    )
{
    TraceFunc( "" );
    Assert( hwndIn != NULL );
    Assert( pstexIn != NULL );
    Assert( piccciIn != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgCredentials *   pccc = NULL;
    BSTR                    bstr = NULL;
    BSTR                    bstrUsername        = NULL;
    BSTR                    bstrDomain          = NULL;

    hr = THR( piccciIn->GetClusterServiceAccountCredentials( &pccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccc->GetIdentity( &bstrUsername, &bstrDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrUsername );
    TraceMemoryAddBSTR( bstrDomain );

    Assert( ( bstrUsername != NULL ) && ( *bstrUsername != L'\0' ) );
    Assert( ( bstrDomain != NULL ) && ( *bstrDomain != L'\0' ) );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_CREDENTIALS, &bstr, bstrUsername, bstrDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

Cleanup:

    if ( pccc != NULL )
    {
        pccc->Release();
    } // if:

    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrDomain );

    HRETURN( hr );

} //*** CSummaryPage::HrCredentialsSummary

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrNodeSummary
//
//  Description:
//      Format and display the node summary.
//
//  Arguments:
//      hwndIn
//          The window to display the text in.
//
//      pstexIn
//          Dunno?  We just need it?!
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrNodeSummary(
      HWND              hwndIn
    , SETTEXTEX *       pstexIn
    )
{
    TraceFunc( "" );
    Assert( hwndIn != NULL );
    Assert( pstexIn != NULL );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;
    BSTR    bstrNodeName = NULL;
    size_t  cNodes = 0;
    size_t  idxNode = 0;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_MEMBERSHIP_BEGIN, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

    hr = THR( m_pccw->HrGetNodeCount( &cNodes ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    for ( idxNode = 0; idxNode < cNodes; ++idxNode )
    {
        hr = THR( m_pccw->HrGetNodeName( idxNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_MEMBERSHIP_SEPARATOR, &bstr, bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );
        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;
    }

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_MEMBERSHIP_END, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

Cleanup:
    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CSummaryPage::HrNodeSummary


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrResourceSummary
//
//  Description:
//      Format and display the resources summary.
//
//  Arguments:
//      hwndIn
//          The window to display the text in.
//
//      pstexIn
//          Dunno?  We just need it?!
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrResourceSummary(
      HWND              hwndIn
    , SETTEXTEX *       pstexIn
    )
{
    TraceFunc( "" );
    Assert( hwndIn != NULL );
    Assert( pstexIn != NULL );

    HRESULT                         hr = S_OK;
    IUnknown *                      punkResEnum = NULL;
    IEnumClusCfgManagedResources *  peccmr  = NULL;
    IClusCfgManagedResourceInfo *   pccmri  = NULL;
    BSTR                            bstr = NULL;
    BSTR                            bstrResourceName = NULL;
    BSTR                            bstrUnknownQuorum   = NULL;
    ULONG                           celtDummy = 0;
    BSTR                            bstrTemp = NULL;
    BOOL                            fFoundQuorum = FALSE;
    BOOL                            fIsLocalQuorum = FALSE;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_UNKNOWN_QUORUM, &bstrUnknownQuorum ) );
    if ( FAILED( hr ) )
    {
        //
        //  If we cannot load the resource string then make a simple string that will work for english...
        //

        hr = S_OK;

        bstrUnknownQuorum = TraceSysAllocString( L"Unknown Quorum" );
        if ( bstrUnknownQuorum == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCES_BEGIN, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

    hr = THR( m_pccw->HrGetClusterChild( CLSID_ManagedResourceType, DFGUID_EnumManageableResources, &punkResEnum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkResEnum->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Need to see if there is a quorum chosen
    //

    for ( ; ; )
    {
        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }

        hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = STHR( pccmri->IsManaged() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            hr = STHR( pccmri->IsQuorumResource() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                fFoundQuorum = TRUE;
                break;
            } // if:
        } // if:
    } // for:

    hr = THR( peccmr->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }

        TraceSysFreeString( bstrResourceName );
        bstrResourceName = NULL;

        TraceSysFreeString( bstrTemp );
        bstrTemp = NULL;

        TraceSysFreeString( bstr );
        bstr = NULL;

        hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pccmri->GetName( &bstrResourceName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        Assert( ( bstrResourceName != NULL ) && ( *bstrResourceName != L'\0' ) );
        TraceMemoryAddBSTR( bstrResourceName );

        //
        //  If this resource is still called "Unknown Quorum" then we need to skip showing it
        //  in this summary.
        //

        if ( NBSTRCompareCase( bstrUnknownQuorum, bstrResourceName ) == 0 )
        {
            continue;
        } // if:

        hr = THR( pccmri->GetUID( &bstrTemp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        Assert( ( bstrTemp != NULL ) && ( *bstrTemp != L'\0' ) );
        TraceMemoryAddBSTR( bstrTemp );

        fIsLocalQuorum = ( NStringCchCompareNoCase(
                              CLUS_RESTYPE_NAME_LKQUORUM
                            , RTL_NUMBER_OF( CLUS_RESTYPE_NAME_LKQUORUM )
                            , bstrTemp
                            , SysStringLen( bstrTemp ) + 1
                            ) == 0 );

        //
        //  Display the information about the local quorum resource.  If there
        //  is not another quorum resource chosen then we need to "fake out"
        //  the info shown about local quorum since it will become the quorum.
        //  The problem is that we don't want to set the local quorum resource
        //  to be managed or as the quorum since it will automatically become
        //  managed and the quorum.
        //

        if ( ( fIsLocalQuorum == TRUE ) && ( fFoundQuorum == FALSE ) )
        {
            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_QUORUM_DEVICE, &bstr, bstrResourceName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

            continue;
        } // if:

        hr = STHR( pccmri->IsManaged() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            hr = STHR( pccmri->IsQuorumResource() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_QUORUM_DEVICE, &bstr, bstrResourceName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if: quorum resource
            else
            {
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_MANAGED, &bstr, bstrResourceName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // else: not quorum resource
        } // if: resource is managed
        else
        {
            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_NOT_MANAGED, &bstr, bstrResourceName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // else:

        SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );
    } // for:

    TraceSysFreeString( bstr );
    bstr = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCES_END, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

Cleanup:

    if ( punkResEnum != NULL )
    {
        punkResEnum->Release();
    } // if:

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    TraceSysFreeString( bstrTemp );
    TraceSysFreeString( bstrUnknownQuorum );
    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrResourceName );

    HRETURN( hr );

} //*** CSummaryPage::HrResourceSummary

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrResourceSummary
//
//  Description:
//      Format and display the resources summary.
//
//  Arguments:
//      hwndIn
//          The window to display the text in.
//
//      pstexIn
//          Dunno?  We just need it?!
//
//      pomIn
//          Pointer to the object manager.
//
//      ocClusterIn
//          The cookie for the cluster object.
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrResourceSummary(
      HWND              hwndIn
    , SETTEXTEX *       pstexIn
    , IObjectManager *  pomIn
    , OBJECTCOOKIE      ocClusterIn
    )
{
    TraceFunc( "" );
    Assert( hwndIn != NULL );
    Assert( pstexIn != NULL );
    Assert( pomIn != NULL );

    HRESULT                         hr = S_OK;
    IUnknown *                      punk = NULL;
    IEnumClusCfgManagedResources *  peccmr  = NULL;
    IClusCfgManagedResourceInfo *   pccmri  = NULL;
    BSTR                            bstr = NULL;
    BSTR                            bstrResourceName = NULL;
    BSTR                            bstrUnknownQuorum   = NULL;
    BSTR                            bstrNodeName = NULL;
    BSTR                            bstrNewLine = NULL;
    ULONG                           celtDummy;
    OBJECTCOOKIE                    cookieDummy;
    OBJECTCOOKIE                    cookieNode;
    IEnumCookies *                  pecNodes = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCES_END, &bstrNewLine ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_UNKNOWN_QUORUM, &bstrUnknownQuorum ) );
    if ( FAILED( hr ) )
    {
        //
        //  If we cannot load the resource string then make a simple string that will work for english...
        //

        hr = S_OK;

        bstrUnknownQuorum = TraceSysAllocString( L"Unknown Quorum" );
        if ( bstrUnknownQuorum == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCES_BEGIN, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

    //
    //  Get the node cookie enumerator.
    //

    hr = THR( pomIn->FindObject( CLSID_NodeType, ocClusterIn, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    for ( ; ; )
    {
        //
        //  Cleanup
        //

        if ( peccmr != NULL )
        {
            peccmr->Release();
            peccmr = NULL;
        } // if:

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break;  // exit condition
        } // if:

        //
        //  Retrieve the node's name.
        //

        hr = THR( HrRetrieveCookiesName( pomIn, cookieNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_NODE_RESOURCES_BEGIN, &bstr, bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

        //
        //  Retrieve the managed resources enumer.
        //

        hr = THR( pomIn->FindObject(
                              CLSID_ManagedResourceType
                            , cookieNode
                            , NULL
                            , DFGUID_EnumManageableResources
                            , &cookieDummy
                            , &punk
                            ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            //hr = THR( HrSendStatusReport(
            //                  bstrNodeName
            //                , TASKID_Major_Find_Devices
            //                , TASKID_Minor_No_Managed_Resources_Found
            //                , 0
            //                , 1
            //                , 1
            //                , MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND )
            //                , IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND
            //                ) );
            //if ( FAILED( hr ) )
            //{
            //    goto Cleanup;
            //}

            continue;   // skip this node
        } // if: no manageable resources for the node are available
        else if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // else if: error finding manageable resources for the node

        hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        //
        //  Loop thru the managed resources that the node has.
        //

        for ( ; ; )
        {
            if ( pccmri != NULL )
            {
                pccmri->Release();
                pccmri = NULL;
            } // if:

            TraceSysFreeString( bstrResourceName );
            bstrResourceName = NULL;

            hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_FALSE )
            {
                hr = S_OK;
                break;  // exit condition
            } // if:

            hr = THR( pccmri->GetName( &bstrResourceName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            Assert( ( bstrResourceName != NULL ) && ( *bstrResourceName != L'\0' ) );
            TraceMemoryAddBSTR( bstrResourceName );

            //
            //  If this resource is still called "Unknown Quorum" then we need to skip showing it
            //  in this summary.
            //

            if ( NBSTRCompareCase( bstrUnknownQuorum, bstrResourceName ) == 0 )
            {
                continue;
            } // if:

            hr = STHR( pccmri->IsManaged() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = STHR( pccmri->IsQuorumResource() );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                if ( hr == S_OK )
                {
                    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_QUORUM_DEVICE, &bstr, bstrResourceName ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:
                } // if: quorum resource
                else
                {
                    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_MANAGED, &bstr, bstrResourceName ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:
                } // else: not quorum resource
            } // if: resource is managed
            else
            {
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_SUMMARY_RESOURCE_NOT_MANAGED, &bstr, bstrResourceName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // else:

            SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );
        } // for:

        SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstrNewLine );
    } // for:

Cleanup:

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    TraceSysFreeString( bstrNewLine );
    TraceSysFreeString( bstrUnknownQuorum );
    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrResourceName );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CSummaryPage::HrResourceSummary
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrNetworkSummary
//
//  Description:
//      Format and display the networks summary.
//
//  Arguments:
//      hwndIn
//          The window to display the text in.
//
//      pstexIn
//          Dunno?  We just need it?!
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrNetworkSummary(
      HWND              hwndIn
    , SETTEXTEX *       pstexIn
    )
{
    TraceFunc( "" );
    Assert( hwndIn != NULL );
    Assert( pstexIn != NULL );

    HRESULT                         hr = S_OK;
    IUnknown *                      punkNetEnum = NULL;
    BSTR                            bstr = NULL;
    ULONG                           celtDummy = 0;
    IEnumClusCfgNetworks *          peccn   = NULL;
    IClusCfgNetworkInfo *           pccni   = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORKS_BEGIN, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

    hr = THR( m_pccw->HrGetClusterChild(
                          CLSID_NetworkType
                        , DFGUID_EnumManageableNetworks
                        , &punkNetEnum
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkNetEnum->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    while( true )
    {
        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( HrFormatNetworkInfo( pccni, &bstr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );
    } // while:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_SUMMARY_NETWORKS_END, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwndIn, EM_SETTEXTEX, (WPARAM) pstexIn, (LPARAM) bstr );

Cleanup:

    if ( punkNetEnum != NULL )
    {
        punkNetEnum->Release();
    } // if:

    if ( peccn != NULL )
    {
        peccn->Release();
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CSummaryPage::HrNetworkSummary


/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage:HrRetrieveCookiesName
//
//  Description:
//      Get the name of the passed in cookie.
//
//  Arguments:
//      pomIn
//          Pointer to the object manager.
//
//      cookieIn
//          The cookie whose name we want.
//
//      pbstrNameOut
//          Used to send the name back out.
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrRetrieveCookiesName(
      IObjectManager *  pomIn
    , OBJECTCOOKIE      cookieIn
    , BSTR *            pbstrNameOut
    )
{
    TraceFunc( "" );
    Assert( pomIn != NULL );
    Assert( cookieIn != NULL );
    Assert( pbstrNameOut != NULL );


    HRESULT         hr;
    IUnknown *      punk = NULL;
    IStandardInfo * psi = NULL;

    hr = THR( pomIn->GetObject( DFGUID_StandardInfo, cookieIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psi->GetName( pbstrNameOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( *pbstrNameOut );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( psi != NULL )
    {
        psi->Release();
    } // if:

    HRETURN( hr );

} //*** CSummaryPage::HrRetrieveCookiesName
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\tasktreeview.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskTreeView.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "DetailsDlg.h"

DEFINE_THISCLASS( "CTaskTreeView" )


//****************************************************************************
//
//  Constants
//
//****************************************************************************

#define PROGRESSBAR_CONTROL_TICK_COUNT   1000
#define PROGRESSBAR_INITIAL_POSITION       10
#define PROGRESSBAR_RESIZE_PERCENT          5

//****************************************************************************
//
//  Static Function Prototypes
//
//****************************************************************************
static
HRESULT
HrCreateTreeItem(
      TVINSERTSTRUCT *          ptvisOut
    , STreeItemLParamData *     ptipdIn
    , HTREEITEM                 htiParentIn
    , int                       nImageIn
    , BSTR                      bstrTextIn
    );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::CTaskTreeView
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTreeView::CTaskTreeView(
      HWND      hwndParentIn
    , UINT      uIDTVIn
    , UINT      uIDProgressIn
    , UINT      uIDStatusIn
    , size_t    nInitialTickCount
    )
{
    TraceFunc( "" );

    m_hwndParent        = hwndParentIn;
    m_hwndTV = GetDlgItem( hwndParentIn, uIDTVIn );
    Assert( m_hwndTV != NULL );

    m_hwndProg = GetDlgItem( hwndParentIn, uIDProgressIn );
    Assert( m_hwndProg != NULL );

    m_hwndStatus = GetDlgItem( hwndParentIn, uIDStatusIn );
    Assert( m_hwndStatus != NULL );

    m_hImgList = NULL;

    Assert( m_htiSelected == NULL );
    Assert( m_bstrClientMachineName == NULL );
    Assert( m_fDisplayErrorsAsWarnings == FALSE );

    //
    // Most of these get set in HrOnNotifySetActive, so just init them to zero.
    //
    m_nInitialTickCount = (ULONG) nInitialTickCount;
    m_nCurrentPos       = 0;
    m_nRealPos          = 0;
    m_fThresholdBroken = FALSE;

    m_cPASize = 0;
    m_cPACount = 0;
    m_ptipdProgressArray = NULL;

    TraceFuncExit();

} //*** CTaskTreeView::CTaskTreeView()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::~CTaskTreeView( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTreeView::~CTaskTreeView( void )
{
    TraceFunc( "" );

    size_t                  idx;
    STreeItemLParamData *   ptipdTemp;

    TreeView_DeleteAllItems( m_hwndTV );

    if ( m_hImgList != NULL )
    {
        ImageList_Destroy( m_hImgList );
    } // if:

    TraceSysFreeString( m_bstrClientMachineName );

    // Cleanup the progress array and delete any allocated entries.
    for ( idx = 0; idx < m_cPASize; idx++ )
    {
        if ( m_ptipdProgressArray[ idx ] != NULL )
        {
            ptipdTemp = m_ptipdProgressArray[ idx ];
            TraceSysFreeString( ptipdTemp->bstrNodeName );
            delete ptipdTemp;
        }  // if: element is not NULL
    } // for: each element of the array

    delete [] m_ptipdProgressArray;

    TraceFuncExit();

} //*** CTaskTreeView::~CTaskTreeView

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrOnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTS.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HICON   hIcon;
    int     idx;

    Assert( m_bstrClientMachineName == NULL );
    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrClientMachineName
                    , TRUE // fBestFit
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Build image list for icons in tree view.
    //

    m_hImgList = ImageList_Create( 16, 16, ILC_MASK, tsMAX, 0);
    if ( m_hImgList == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    //
    //  Unknown Icon - Task Unknown.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_SEL ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsUNKNOWN );

    //
    //  Pending Icon - Task Pending.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_PENDING ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsPENDING );

    //
    //  Checkmark Icon - Task Done.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_CHECK ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsDONE );

    //
    //  Warning Icon - Task Warning.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_WARN ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsWARNING );

    //
    //  Fail Icon - Task Failed.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_FAIL ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsFAILED );

    Assert( ImageList_GetImageCount( m_hImgList ) == tsMAX );

    //
    //  Set the image list and background color.
    //

    TreeView_SetImageList( m_hwndTV, m_hImgList, TVSIL_NORMAL );
    TreeView_SetBkColor( m_hwndTV, GetSysColor( COLOR_3DFACE ) );

Cleanup:

    HRETURN( hr );

} //*** CTaskTreeView::HrOnInitDialog

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrAddTreeViewItem
//
//  Description:
//      Add a tree view item.  This method will return the item handle and
//      allows the caller to specify the parent item.
//
//  Arguments:
//      phtiOut
//          Handle to the item being added (optional).
//
//      idsIn
//          String resource ID for description of the new item.
//
//      rclsidMinorTaskIDIn
//          Minor task ID for the item.
//
//      rclsidMajorTaskIDIn
//          Major task ID for the item.  Defaults to IID_NULL.
//
//      htiParentIn
//          Parent item.  Defaults to the root.
//
//      fParentToAllNodeTasksIn
//          TRUE = allow item to be parent to tasks from all nodes.
//          FALSE = only allow item to be parent to tasks from the local node.
//          Defaults to FALSE.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrAddTreeViewItem(
      HTREEITEM *   phtiOut
    , UINT          idsIn
    , REFCLSID      rclsidMinorTaskIDIn
    , REFCLSID      rclsidMajorTaskIDIn     // = IID_NULL
    , HTREEITEM     htiParentIn             // = TVI_ROOT
    , BOOL          fParentToAllNodeTasksIn // = FALSE
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    STreeItemLParamData *   ptipd;
    SYSTEMTIME              systemtime;
    TVINSERTSTRUCT          tvis;
    HTREEITEM               hti = NULL;

    //
    // Allocate an item data structure.
    //

    ptipd = new STreeItemLParamData;
    if ( ptipd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    // Set the node name to the local computer name.
    //

    hr = THR( HrGetComputerName(
                      ComputerNamePhysicalDnsFullyQualified
                    , &ptipd->bstrNodeName
                    , TRUE // fBestFitIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetFQNDisplayName( ptipd->bstrNodeName, &ptipd->bstrNodeNameWithoutDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Set the desription from the string resource ID.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsIn, &ptipd->bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Set the date/time to the current date/time.
    //

    GetSystemTime( &systemtime );
    if ( ! SystemTimeToFileTime( &systemtime, &ptipd->ftTime ) )
    {
        DWORD sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    // Set the task IDs.
    //

    CopyMemory( &ptipd->clsidMajorTaskId, &rclsidMajorTaskIDIn, sizeof( ptipd->clsidMajorTaskId ) );
    CopyMemory( &ptipd->clsidMinorTaskId, &rclsidMinorTaskIDIn, sizeof( ptipd->clsidMinorTaskId ) );

    //
    // Set the flag describing which items this item can be a parent to.
    //

    ptipd->fParentToAllNodeTasks = fParentToAllNodeTasksIn;

    //
    // Initialize the insert structure and insert the item into the tree.
    //

    tvis.hParent               = htiParentIn;
    tvis.hInsertAfter          = TVI_LAST;
    tvis.itemex.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvis.itemex.cchTextMax     = SysStringLen( ptipd->bstrDescription );
    tvis.itemex.pszText        = ptipd->bstrDescription;
    tvis.itemex.iImage         = tsUNKNOWN;
    tvis.itemex.iSelectedImage = tsUNKNOWN;
    tvis.itemex.lParam         = reinterpret_cast< LPARAM >( ptipd );

    hti = TreeView_InsertItem( m_hwndTV, &tvis );
    Assert( hti != NULL );

    ptipd = NULL;

    if ( phtiOut != NULL )
    {
        *phtiOut = hti;
    } // if:

    goto Cleanup;

Cleanup:

    if ( ptipd != NULL )
    {
        TraceSysFreeString( ptipd->bstrNodeName );
        TraceSysFreeString( ptipd->bstrNodeNameWithoutDomain );
        TraceSysFreeString( ptipd->bstrDescription );
        delete ptipd;
    } // if: ptipd != NULL

    HRETURN( hr );

} //*** CTaskTreeView::HrAddTreeViewItem

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotify
//
//  Description:
//      Handler for the WM_NOTIFY message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      Notification-specific return code.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CTaskTreeView::OnNotify(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    switch( pnmhdrIn->code )
    {
        case TVN_DELETEITEM:
            OnNotifyDeleteItem( pnmhdrIn );
            break;

        case TVN_SELCHANGED:
            OnNotifySelChanged( pnmhdrIn );
            break;

    } // switch: notify code

    RETURN( lr );

} //*** CTaskTreeView::OnNotify

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotifyDeleteItem
//
//  Description:
//      Handler for the TVN_DELETEITEM notification message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure for the item being deleted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskTreeView::OnNotifyDeleteItem(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LPNMTREEVIEW pnmtv = reinterpret_cast< LPNMTREEVIEW >( pnmhdrIn );

    if ( pnmtv->itemOld.lParam != NULL )
    {
        STreeItemLParamData * ptipd = reinterpret_cast< STreeItemLParamData * >( pnmtv->itemOld.lParam );
        TraceSysFreeString( ptipd->bstrNodeName );
        TraceSysFreeString( ptipd->bstrNodeNameWithoutDomain );
        TraceSysFreeString( ptipd->bstrDescription );
        TraceSysFreeString( ptipd->bstrReference );
        delete ptipd;
    } // if: lParam != NULL

    TraceFuncExit();

} //*** CTaskTreeView::OnNotifyDeleteItem

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotifySelChanged
//
//  Description:
//      Handler for the TVN_SELCHANGED notification message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure for the item being deleted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskTreeView::OnNotifySelChanged(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LPNMTREEVIEW pnmtv = reinterpret_cast< LPNMTREEVIEW >( pnmhdrIn );

    Assert( pnmtv->itemNew.mask & TVIF_HANDLE );

    m_htiSelected = pnmtv->itemNew.hItem;

    TraceFuncExit();

} //*** CTaskTreeView::OnNotifySelChanged

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskTreeView::HrShowStatusAsDone( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrShowStatusAsDone( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;
    PBRANGE pbrange;

    SendMessage( m_hwndProg, PBM_GETRANGE, FALSE, (LPARAM) &pbrange );
    SendMessage( m_hwndProg, PBM_SETPOS, pbrange.iHigh, 0 );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKS_COMPLETED, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        SetWindowText( m_hwndStatus, L"" );
        goto Cleanup;
    } // if:

    SetWindowText( m_hwndStatus, bstrDescription );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CTaskTreeView::HrShowStatusAsDone

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskTreeView::HrOnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnNotifySetActive( void )
{
    TraceFunc( "" );

    STreeItemLParamData * ptipdTemp;
    HRESULT hr = S_OK;
    size_t  idx;

    TreeView_DeleteAllItems( m_hwndTV );
    SetWindowText( m_hwndStatus, L"" );

    // Cleanup the progress array and delete any allocated entries.
    for ( idx = 0; idx < m_cPASize; idx++ )
    {
        if ( m_ptipdProgressArray[ idx ] != NULL )
        {
            ptipdTemp = m_ptipdProgressArray[ idx ];
            TraceSysFreeString( ptipdTemp->bstrNodeName );
            delete ptipdTemp;
        } // if: element != NULL
    } // for: each element in the array

    m_cPASize = 0;
    m_cPACount = 0;
    delete [] m_ptipdProgressArray;
    m_ptipdProgressArray = NULL;

    m_nRangeHigh    = 1;    // We don't have any reported tasks yet.  Choose 1 to avoid any div/0 errors.
    m_nCurrentPos   = PROGRESSBAR_INITIAL_POSITION;
    m_nRealPos      = PROGRESSBAR_INITIAL_POSITION;
    m_fThresholdBroken = FALSE;

    SendMessage( m_hwndProg, PBM_SETRANGE, 0, MAKELPARAM( 0, PROGRESSBAR_CONTROL_TICK_COUNT ) );
    SendMessage( m_hwndProg, PBM_SETPOS, m_nCurrentPos, 0 );

    HRETURN( hr );

} //*** CTaskTreeView::HrOnNotifySetActive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrOnSendStatusReport
//
//  Description:
//      Handle a status report call.
//
//  Arguments:
//      pcszNodeNameIn      -
//      clsidTaskMajorIn    -
//      clsidTaskMinorIn    -
//      nMinIn              -
//      nMaxIn              -
//      nCurrentIn          -
//      hrStatusIn          -
//      pcszDescriptionIn   -
//      pftTimeIn           -
//      pcszReferenceIn     -
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnSendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         nMinIn
    , ULONG         nMaxIn
    , ULONG         nCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc( "" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT                 hr = S_OK;
    int                     nImageChild;
    STreeItemLParamData     tipd;
    HTREEITEM               htiRoot;
    BSTR                    bstrStatus = NULL;
    BSTR                    bstrDisplayName = NULL;
    LPCWSTR                 pcszNameToUse = pcszNodeNameIn;

    ZeroMemory( &tipd, sizeof( tipd ) );

    //
    //  If no node name was supplied then provide this machine's name so
    //  we have something to use as the node name key part when placing
    //  this tree item in the tree.
    //

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrClientMachineName;
    } // if:

    //
    //  If the node name is fully-qualified, use just the prefix.
    //
    hr = STHR( HrGetFQNDisplayName( pcszNodeNameIn, &bstrDisplayName ) );
    if ( SUCCEEDED( hr ) )
    {
        pcszNameToUse = bstrDisplayName;
    } // if:

    //////////////////////////////////////////////////////////////////////////
    //
    //  Update status text.
    //  Don't do this if it is a log-only message.
    //
    //////////////////////////////////////////////////////////////////////////

    if (    ( pcszDescriptionIn != NULL )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log )
        )
    {
        BOOL    fReturn;

        if ( pcszNodeNameIn != NULL )
        {
            hr = THR( HrFormatMessageIntoBSTR(
                              g_hInstance
                            , IDS_FORMAT_STATUS
                            , &bstrStatus
                            , pcszNameToUse
                            , pcszDescriptionIn
                            ) );
            //
            // Handle the formatting error if there was one.
            //

            if ( FAILED( hr ) )
            {
                // TODO: Display default description instead of exiting this function
                goto Error;
            } // if:
        } // if: node name was specified
        else
        {
            bstrStatus = TraceSysAllocString( pcszDescriptionIn );
            if ( bstrStatus == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Error;
            } // if:
        } // else: node name wasn't specified

        Assert( bstrStatus!= NULL );
        Assert( *bstrStatus!= L'\0' );
        fReturn = SetWindowText( m_hwndStatus, bstrStatus );
        Assert( fReturn );
    } // if: description specified, not log-only

    //////////////////////////////////////////////////////////////////////////
    //
    //  Select the right icon.
    //
    //////////////////////////////////////////////////////////////////////////

    switch ( hrStatusIn )
    {
        case S_OK:
            if ( nCurrentIn == nMaxIn )
            {
                nImageChild = tsDONE;
            } // if:
            else
            {
                nImageChild = tsPENDING;
            } // else:
            break;

        case S_FALSE:
            nImageChild = tsWARNING;
            break;

        case E_PENDING:
            nImageChild = tsPENDING;
            break;

        default:
            if ( FAILED( hrStatusIn ) && ( m_fDisplayErrorsAsWarnings == FALSE ) )
            {
                nImageChild = tsFAILED;
            } // if:
            else
            {
                nImageChild = tsWARNING;
            } // else:
            break;
    } // switch: hrStatusIn

    //////////////////////////////////////////////////////////////////////////
    //
    //  Loop through each item at the top of the tree looking for an item
    //  whose minor ID matches this report's major ID.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Fill in the param data structure.
    //

    tipd.hr         = hrStatusIn;
    tipd.nMin       = nMinIn;
    tipd.nMax       = nMaxIn;
    tipd.nCurrent   = nCurrentIn;

    CopyMemory( &tipd.clsidMajorTaskId, &clsidTaskMajorIn, sizeof( tipd.clsidMajorTaskId ) );
    CopyMemory( &tipd.clsidMinorTaskId, &clsidTaskMinorIn, sizeof( tipd.clsidMinorTaskId ) );
    CopyMemory( &tipd.ftTime, pftTimeIn, sizeof( tipd.ftTime ) );

    // tipd.bstrDescription is set above.
    tipd.bstrNodeName = TraceSysAllocString( pcszNodeNameIn );
    if ( tipd.bstrNodeName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    } // if:
    tipd.bstrNodeNameWithoutDomain = bstrDisplayName;
    bstrDisplayName = NULL; //    tipd now owns this string.

    if ( pcszDescriptionIn == NULL )
    {
        tipd.bstrDescription = NULL;
    } // if:
    else
    {
        tipd.bstrDescription = TraceSysAllocString( pcszDescriptionIn );
        if ( tipd.bstrDescription == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Error;
        } // if:
    } // else: pcszDescritionIn != NULL
    if ( pcszReferenceIn == NULL )
    {
        tipd.bstrReference = NULL;
    } // if:
    else
    {
        tipd.bstrReference = TraceSysAllocString( pcszReferenceIn );
        if ( tipd.bstrReference == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Error;
        } // if:
    } // else: pcszReferenceIn != NULL

    if ( IsEqualIID( tipd.clsidMajorTaskId, TASKID_Major_Update_Progress ) )
    {
        // It's an update_progress task so just call HrProcessUpdateProgressTask.
        hr = STHR( HrProcessUpdateProgressTask( &tipd ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        } // if:
    } // if: major == update_progress
    else
    {
        // Start with the first item in the tree view.
        htiRoot = TreeView_GetRoot( m_hwndTV );
        if ( htiRoot == NULL )
        {
            TW32( ERROR_NOT_FOUND );
            // Don't return an error result since doing so will prevent the report
            // from being propagated to other subscribers.
            hr = S_OK;
            goto Cleanup;
        } // if: htiRoot is NULL

        // Insert the status report into the tree view.
        hr = STHR( HrInsertTaskIntoTree( htiRoot, &tipd, nImageChild, bstrStatus ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[WIZ] Error inserting status report into the tree control. hr=%.08x, %ws", tipd.hr, pcszDescriptionIn );
            goto Error;
        } // if:
    } // else: not an update_progress task

    if ( hr == S_FALSE )
    {
        // Don't return S_FALSE to the caller since it won't mean anything there.
        hr = S_OK;
        // TODO: Should this be written to the log?

#if defined( DEBUG )
        //
        // Check to make sure that if the major task ID wasn't recognized
        // that it is one of the known exceptions.
        //

        if (    ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
            &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
            &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log ) )
        {
            BSTR    bstrMsg = NULL;

            THR( HrFormatStringIntoBSTR(
                              g_hInstance
                            , IDS_UNKNOWN_TASK
                            , &bstrMsg
                            , clsidTaskMajorIn.Data1        // 1
                            , clsidTaskMajorIn.Data2        // 2
                            , clsidTaskMajorIn.Data3        // 3
                            , clsidTaskMajorIn.Data4[ 0 ]   // 4
                            , clsidTaskMajorIn.Data4[ 1 ]   // 5
                            , clsidTaskMajorIn.Data4[ 2 ]   // 6
                            , clsidTaskMajorIn.Data4[ 3 ]   // 7
                            , clsidTaskMajorIn.Data4[ 4 ]   // 8
                            , clsidTaskMajorIn.Data4[ 5 ]   // 9
                            , clsidTaskMajorIn.Data4[ 6 ]   // 10
                            , clsidTaskMajorIn.Data4[ 7 ]   // 11
                            ) );
            AssertString( 0, bstrMsg );

            TraceSysFreeString( bstrMsg );
        } // if: log only
#endif // DEBUG
    } // if: S_FALSE returned from HrInsertTaskIntoTree

    goto Cleanup;

Error:
    // Don't return an error result since doing so will prevent the report
    // from being propagated to other subscribers.
    hr = S_OK;
    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrDisplayName );
    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( tipd.bstrNodeName );
    TraceSysFreeString( tipd.bstrNodeNameWithoutDomain );
    TraceSysFreeString( tipd.bstrDescription );
    TraceSysFreeString( tipd.bstrReference );

    HRETURN( hr );

} //*** CTaskTreeView::HrOnSendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrInsertTaskIntoTree
//
//  Description:
//      Insert the specified task into the tree based on the node, major
//      task, and minor task.
//
//  Arguments:
//      htiFirstIn          - First tree item to examine.
//      ptipdIn             - Tree item parameter data for the task to be inserted.
//      nImageIn            - Image identifier for the child item.
//      bstrDescriptionIn   - Description string to display.
//
//  Return Values:
//      S_OK        - Task inserted successfully.
//      S_FALSE     - Task not inserted.
//      hr          - The operation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrInsertTaskIntoTree(
      HTREEITEM             htiFirstIn
    , STreeItemLParamData * ptipdIn
    , int                   nImageIn
    , BSTR                  bstrDescriptionIn
    )
{
    TraceFunc( "" );

    Assert( htiFirstIn != NULL );
    Assert( ptipdIn != NULL );

    //
    //  LOCAL VARIABLES
    //

    HRESULT                 hr;
    HTREEITEM               htiParent;
    HTREEITEM               htiChild  = NULL;
    TVITEMEX                tviParent;
    TVITEMEX                tviChild;
    BOOL                    fReturn;
    BOOL                    fSameNode;
    STreeItemLParamData *   ptipdParent = NULL;
    STreeItemLParamData *   ptipdChild = NULL;

    //
    // Loop through each item to determine if the task should be added below
    // that item.  If not, attempt to traverse its children.
    //

    for ( htiParent = htiFirstIn, hr = S_FALSE
        ; ( htiParent != NULL ) && ( hr == S_FALSE )
        ; )
    {
        //
        // Get the information about this item in the tree.
        //

        tviParent.mask  = TVIF_PARAM | TVIF_IMAGE;
        tviParent.hItem = htiParent;

        fReturn = TreeView_GetItem( m_hwndTV, &tviParent );
        if ( fReturn == FALSE )
        {
            hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
            goto Cleanup;
        } // if:

        ptipdParent = reinterpret_cast< STreeItemLParamData * >( tviParent.lParam );
        Assert( ptipdParent != NULL );

        //
        // Determine if either the parent can be a parent to tasks from any
        // node or, if not, the parent and input tasks are from the same node.
        //

        if ( ptipdParent->fParentToAllNodeTasks == TRUE )
        {
            fSameNode = TRUE;
        } // if: parent task can host tasks from any node
        else
        {
            fSameNode = ( NBSTRCompareNoCase( ptipdIn->bstrNodeNameWithoutDomain, ptipdParent->bstrNodeNameWithoutDomain ) == 0 );
        } // else: parent task's node must match input task's node

        //
        //  Reset hr to S_FALSE because it is the return value when a tree item is
        //  to be added to the tree because it was not found.
        //

        hr = S_FALSE;

        //
        // See if this item could be the parent.
        // If not, recurse through child items.
        //

        if (    IsEqualIID( ptipdIn->clsidMajorTaskId, ptipdParent->clsidMinorTaskId )
            &&  ( fSameNode == TRUE )
            )
        {
            //
            //  FOUND THE PARENT ITEM
            //

            BOOL    fMinorTaskIdMatches;
            BOOL    fBothNodeNamesPresent;
            BOOL    fBothNodeNamesEmpty;
            BOOL    fNodeNamesEqual;

            //////////////////////////////////////////////////////////////
            //
            //  Loop through the child items looking for an item with
            //  the same minor ID.
            //
            //////////////////////////////////////////////////////////////

            htiChild = TreeView_GetChild( m_hwndTV, htiParent );
            while ( htiChild != NULL )
            {
                //
                // Get the child item details.
                //

                tviChild.mask  = TVIF_PARAM | TVIF_IMAGE;
                tviChild.hItem = htiChild;

                fReturn = TreeView_GetItem( m_hwndTV, &tviChild );
                if ( fReturn == FALSE )
                {
                    hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
                    goto Cleanup;
                } // if:

                ptipdChild = reinterpret_cast< STreeItemLParamData * >( tviChild.lParam );
                Assert( ptipdChild != NULL );

                //
                // Does this child item match the minor ID and node name?
                //

                fMinorTaskIdMatches   = IsEqualIID( ptipdIn->clsidMinorTaskId, ptipdChild->clsidMinorTaskId );
                fBothNodeNamesPresent = ( ptipdIn->bstrNodeNameWithoutDomain != NULL ) && ( ptipdChild->bstrNodeNameWithoutDomain != NULL );
                fBothNodeNamesEmpty   = ( ptipdIn->bstrNodeNameWithoutDomain == NULL ) && ( ptipdChild->bstrNodeNameWithoutDomain == NULL );

                if ( fBothNodeNamesPresent == TRUE )
                {
                    fNodeNamesEqual = ( NBSTRCompareNoCase( ptipdIn->bstrNodeNameWithoutDomain, ptipdChild->bstrNodeNameWithoutDomain ) == 0 );
                } // if:
                else if ( fBothNodeNamesEmpty == TRUE )
                {
                    fNodeNamesEqual = TRUE;
                } // else if:
                else
                {
                    fNodeNamesEqual = FALSE;
                } // else:

                if ( ( fMinorTaskIdMatches == TRUE ) && ( fNodeNamesEqual == TRUE ) )
                {
                    //
                    //  CHILD ITEM MATCHES.
                    //  Update the child item.
                    //

                    //
                    //  Update the progress bar.
                    //

                    STHR( HrUpdateProgressBar( ptipdIn, ptipdChild ) );
                    // ignore failure.

                    //
                    //  Copy data from the report.
                    //  This must be done after the call to
                    //  HrUpdateProgressBar so that the previous values
                    //  can be compared to the new values.
                    //

                    ptipdChild->nMin        = ptipdIn->nMin;
                    ptipdChild->nMax        = ptipdIn->nMax;
                    ptipdChild->nCurrent    = ptipdIn->nCurrent;
                    CopyMemory( &ptipdChild->ftTime, &ptipdIn->ftTime, sizeof( ptipdChild->ftTime ) );

                    // Update the error code if needed.
                    if ( ptipdChild->hr == S_OK )
                    {
                        ptipdChild->hr = ptipdIn->hr;
                    } // if:

                    //
                    // If the new state is worse than the last state,
                    // update the state of the item.
                    //

                    if ( tviChild.iImage < nImageIn )
                    {
                        tviChild.mask           = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tviChild.iImage         = nImageIn;
                        tviChild.iSelectedImage = nImageIn;
                        TreeView_SetItem( m_hwndTV, &tviChild );
                    } // if: new state is worse than the last state

                    //
                    // Update the text of the child item if needed.
                    //

                    if (    ( ptipdIn->bstrDescription != NULL )
                        &&  (   ( ptipdChild->bstrDescription == NULL )
                            ||  ( NBSTRCompareCase( ptipdIn->bstrDescription, ptipdChild->bstrDescription ) != 0 )
                            )
                        )
                    {
                        fReturn = TraceSysReAllocString( &ptipdChild->bstrDescription, ptipdIn->bstrDescription );
                        if ( fReturn == FALSE )
                        {
                            hr = THR( E_OUTOFMEMORY );
                            goto Cleanup;
                        } // if:
                        tviChild.mask       = TVIF_TEXT;
                        tviChild.pszText    = bstrDescriptionIn;
                        tviChild.cchTextMax = (int) wcslen( tviChild.pszText );
                        TreeView_SetItem( m_hwndTV, &tviChild );
                    } // if: description was specified and is different

                    //
                    // Copy the reference if it is different.
                    //

                    if (    ( ptipdIn->bstrReference != NULL )
                        &&  (   ( ptipdChild->bstrReference == NULL )
                            ||  ( NBSTRCompareCase( ptipdChild->bstrReference, ptipdIn->bstrReference ) != 0 )
                            )
                        )
                    {
                        fReturn = TraceSysReAllocString( &ptipdChild->bstrReference, ptipdIn->bstrReference );
                        if ( fReturn == FALSE )
                        {
                            hr = THR( E_OUTOFMEMORY );
                            goto Cleanup;
                        } // if:
                    } // if: reference is different

                    break; // exit loop

                } // if: found a matching child item

                //
                //  Get the next item.
                //

                htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );

            } // while: more child items

            //////////////////////////////////////////////////////////////
            //
            //  If the tree item was not found and the description was
            //  specified, then we need to create the child item.
            //
            //////////////////////////////////////////////////////////////

            if (    ( htiChild == NULL )
                &&  ( ptipdIn->bstrDescription != NULL )
                )
            {
                //
                //  ITEM NOT FOUND AND DESCRIPTION WAS SPECIFIED
                //
                //  Insert a new item in the tree under the major's task.
                //

                TVINSERTSTRUCT  tvis;

                // Create the item.
                hr = THR( HrCreateTreeItem(
                                  &tvis
                                , ptipdIn
                                , htiParent
                                , nImageIn
                                , bstrDescriptionIn
                                ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                // Insert the item in the tree.
                htiChild = TreeView_InsertItem( m_hwndTV, &tvis );
                Assert( htiChild != NULL );

                //
                //  Update the progress bar.
                //

                ptipdChild = reinterpret_cast< STreeItemLParamData * >( tvis.itemex.lParam );
                Assert( ptipdChild != NULL );
                STHR( HrUpdateProgressBar( ptipdIn, ptipdChild ) );
                // ignore failure.

            } // if: need to add new child

            //////////////////////////////////////////////////////////////
            //
            //  If the child item was created and the child has an error
            //  condition, then create a child of the child item
            //  indicating the error code and system string.
            //
            //////////////////////////////////////////////////////////////

            if (    ( ptipdChild != NULL )
                &&  (   FAILED( ptipdIn->hr )
                    ||  (   ( ptipdIn->hr != S_OK )
                        &&  ( ptipdIn->hr != S_FALSE )
                        )
                    )
                )
            {
                //
                //  CHILD ITEM FOUND OR CREATED FOR ERROR REPORT
                //  CREATE ERROR ITEM IN THE TREE
                //

                BSTR            bstrError = NULL;
                BSTR            bstrErrorDescription = NULL;
                HRESULT         hrFormat;
                TVINSERTSTRUCT  tvis;
                HTREEITEM       htiChildStatus;
                DWORD           dwSeverity;
                HRESULT         hrNewStatus = S_OK;

                dwSeverity = SCODE_SEVERITY( ptipdIn->hr );

                THR( HrFormatErrorIntoBSTR( ptipdIn->hr, &bstrError, &hrNewStatus ) );

                //
                //  If we got an updated status code then we need to choose
                //  a new format string that shows both the old and the new
                //  status codes.
                //

                if ( hrNewStatus != ptipdIn->hr )
                {
                    Assert( bstrError != NULL );

                    hrFormat = THR( HrFormatMessageIntoBSTR(
                                          g_hInstance
                                        , dwSeverity == 0 ? IDS_TASK_RETURNED_NEW_STATUS : IDS_TASK_RETURNED_NEW_ERROR
                                        , &bstrErrorDescription
                                        , ptipdIn->hr
                                        , hrNewStatus
                                        , bstrError
                                        ) );
                } // if:
                else
                {
                    hrFormat = THR( HrFormatMessageIntoBSTR(
                                          g_hInstance
                                        , dwSeverity == 0 ? IDS_TASK_RETURNED_STATUS : IDS_TASK_RETURNED_ERROR
                                        , &bstrErrorDescription
                                        , ptipdIn->hr
                                        , ( bstrError == NULL ? L"" : bstrError )
                                        ) );
                } // else:

                if ( SUCCEEDED( hrFormat ) )
                {
                    //
                    //  Insert a new item in the tree under the minor's
                    //  task explaining the ptipdIn->hr.
                    //

                    // Create the item.
                    hr = THR( HrCreateTreeItem(
                                      &tvis
                                    , ptipdIn
                                    , htiChild
                                    , nImageIn
                                    , bstrErrorDescription
                                    ) );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // Failures are handled below to make sure we free
                        // all the strings allocated by this section of
                        // the code.
                        //

                        // Insert the item.
                        htiChildStatus = TreeView_InsertItem( m_hwndTV, &tvis );
                        Assert( htiChildStatus != NULL );
                    } // if: tree item created successfully

                    TraceSysFreeString( bstrErrorDescription );

                } // if: message formatted successfully

                TraceSysFreeString( bstrError );

                //
                // This error handling is for the return value from
                // HrCreateTreeItem above.  It is here so that all the strings
                // can be cleaned up without having to resort to hokey
                // boolean variables or move the bstrs to a more global scope.
                //

                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

            } // if: child and error

            //////////////////////////////////////////////////////////////
            //
            //  If a child was found or created, propagate its state to
            //  the parent items.
            //
            //////////////////////////////////////////////////////////////

            if ( htiChild != NULL )
            {
                hr = STHR( HrPropagateChildStateToParents(
                                          htiChild
                                        , nImageIn
                                        , FALSE     // fOnlyUpdateProgressIn
                                        ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if: found or created a child

            //
            // Return success since we found the parent for this report.
            //

            hr = S_OK;
            break;

        } // if: found an item to be the parent
        else
        {
            //
            //  PARENT ITEM NOT FOUND
            //
            //  Recurse through all the child items.
            //

            htiChild = TreeView_GetChild( m_hwndTV, htiParent );
            while ( htiChild != NULL )
            {
                hr = STHR( HrInsertTaskIntoTree( htiChild, ptipdIn, nImageIn, bstrDescriptionIn ) );
                if ( hr == S_OK )
                {
                    // Found a match, so exit the loop.
                    break;
                } // if:

                htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );
            } // while: more child items
        } // else: item not the parent

        //
        // Get the next sibling of the parent.
        //

        htiParent = TreeView_GetNextSibling( m_hwndTV, htiParent );

    } // for: each item at this level in the tree

Cleanup:

    RETURN( hr );

} //*** CTaskTreeView::HrInsertTaskIntoTree


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrProcessUpdateProgressTask
//
//  Description:
//      Update the progress bar based on new tree item data.
//
//  Arguments:
//      ptipdNewIn      - New values of the tree item data.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Failure allocating memory
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrProcessUpdateProgressTask(
      const STreeItemLParamData * ptipdIn
      )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    STreeItemLParamData *   ptipdPrev = NULL;
    size_t                  idx;
    size_t                  cPassed;
    size_t                  idxPrev = 0;
    BOOL                    fNewTask = FALSE;   // Are ptipdPrev && ptipdIn the same task?

    Assert( ptipdIn != NULL );
    Assert( IsEqualIID( ptipdIn->clsidMajorTaskId, TASKID_Major_Update_Progress ) );

    //
    //  Is this a one-off event?  min == max == current
    //
    if ( ( ptipdIn->nMin == ptipdIn->nMax ) && ( ptipdIn->nMax == ptipdIn->nCurrent ) )
    {
        // Yes - don't bother mucking with the array.
        STHR( HrUpdateProgressBar( ptipdIn, ptipdIn ) );
        hr = S_OK;
        goto Cleanup;
    } // if: one-off event

    //
    //  Check to see if this task is in the array.
    //
    for ( idx = 0, cPassed = 0;
          ( idx < m_cPASize ) && ( cPassed < m_cPACount );
          idx++ )
    {
        if ( m_ptipdProgressArray[ idx ] != NULL )
        {
            // Check the minors and make sure this is the same node.
            if (    IsEqualIID( m_ptipdProgressArray[ idx ]->clsidMinorTaskId, ptipdIn->clsidMinorTaskId )
                 && ( NBSTRCompareNoCase( m_ptipdProgressArray[ idx ]->bstrNodeName, ptipdIn->bstrNodeName ) == 0 ) )
            {
                ptipdPrev = m_ptipdProgressArray[ idx ];
                idxPrev = idx;
                break;
            } // if:

            //  If the array is X elements long and we have Y elements, stop after looking at Y elements.
            cPassed++;
        } // if: current slot is null
    } // for: each item in the array until we find a match

    if ( ptipdPrev == NULL )
    {
        //
        //  We didn't find it in the list - we'll have to insert it.
        //
        if ( m_ptipdProgressArray == NULL )
        {
            Assert( m_cPACount == 0 );
            //
            //  We have to allocate the array.
            //
            m_cPASize = 10;     //  Pick a reasonable initial array size.
            m_ptipdProgressArray = new PSTreeItemLParamData[ m_cPASize ];
            if ( m_ptipdProgressArray == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            ZeroMemory( m_ptipdProgressArray, m_cPASize * sizeof( m_ptipdProgressArray[ 0 ] ) );

            // We just allocated the array so we know the first slot is open.
            idx = 0;
        } // if: we need to allocate the array
        else if ( m_cPACount == m_cPASize )
        {
            STreeItemLParamData ** ptipdTempArray = NULL;

            Assert( m_cPASize != 0 );

            //
            //  We need to increase the size of the array.
            //
            ptipdTempArray = new STreeItemLParamData* [ m_cPASize * 2 ];
            if ( ptipdTempArray == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            // Copy the old array over the first half of the new array.
            CopyMemory( ptipdTempArray, m_ptipdProgressArray, m_cPASize * sizeof( m_ptipdProgressArray[ 0 ] ) );

            // Zero out the second half of the new array.
            ZeroMemory( &ptipdTempArray[ m_cPASize ], m_cPASize * sizeof( ptipdTempArray[ 0 ] ) );

            //
            // Update member variables to reflect the changes.
            //

            m_cPASize *= 2; // We doubled the array length.

            delete [] m_ptipdProgressArray;
            m_ptipdProgressArray = ptipdTempArray;
            ptipdTempArray = NULL;

            // We know the first open slot is at index m_cPACount.
            idx = m_cPACount;
        } // else: we've used all available slots
        else
        {
            // Else we have a spot open somewhere in the existing array.  Start searching from 0.
            idx = 0;
        } // else: there's an available slot

        //
        //  Find an empty slot and allocate a new task to put in it.
        //
        for ( ; idx < m_cPASize; idx++ )
        {
            if ( m_ptipdProgressArray[ idx ] == NULL )
            {
                //
                //  Found an empty slot - allocate the new task.
                //
                ptipdPrev = new STreeItemLParamData;
                if ( ptipdPrev == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                ptipdPrev->bstrNodeName = TraceSysAllocString( ptipdIn->bstrNodeName );
                if ( ( ptipdIn->bstrNodeName != NULL ) && ( ptipdPrev->bstrNodeName == NULL ) )
                {
                    hr = THR( E_OUTOFMEMORY );
                    delete ptipdPrev;
                    ptipdPrev = NULL;
                    goto Cleanup;
                } // if:

                CopyMemory( &ptipdPrev->clsidMajorTaskId, &ptipdIn->clsidMajorTaskId, sizeof( ptipdIn->clsidMajorTaskId ) );
                CopyMemory( &ptipdPrev->clsidMinorTaskId, &ptipdIn->clsidMinorTaskId, sizeof( ptipdIn->clsidMinorTaskId ) );
                ptipdPrev->nMin = ptipdIn->nMin;
                ptipdPrev->nMax = ptipdIn->nMax;
                ptipdPrev->nCurrent = ptipdIn->nCurrent;
                ptipdPrev->fParentToAllNodeTasks = ptipdIn->fParentToAllNodeTasks;

                m_ptipdProgressArray[ idx ] = ptipdPrev;
                m_cPACount++;
                fNewTask = TRUE;
                idxPrev = idx;
                break;
            } // if:
        } // for: find an emtpy slot
    } // if: couldn't find a matching task in the array

    Assert( ptipdPrev != NULL );
    Assert( ptipdIn->bstrReference == NULL );
    Assert( ptipdIn->nMin < ptipdIn->nMax );
    Assert( ptipdIn->nMin <= ptipdIn->nCurrent );
    Assert( ptipdIn->nCurrent <= ptipdIn->nMax );

    //
    //  Update the progress bar.
    //
    STHR( HrUpdateProgressBar( ptipdIn, ptipdPrev ) );   // Ignore failure.

    //
    //  If the task has completed, remove it from the array.
    //
    if ( ptipdIn->nMax == ptipdIn->nCurrent )
    {
        TraceSysFreeString( ptipdPrev->bstrNodeName );
        delete ptipdPrev;
        m_ptipdProgressArray[ idxPrev ] = NULL;
        m_cPACount--;
    } // if: task complete
    else if ( fNewTask == FALSE )
    {
        //
        //  Else, update ptipdPrev only if we didn't just copy the array.
        //

        //  This could have been a range-changing event, so copy the min, max, current.
        ptipdPrev->nMin = ptipdIn->nMin;
        ptipdPrev->nMax = ptipdIn->nMax;
        ptipdPrev->nCurrent = ptipdIn->nCurrent;
    } // else if: not a new task

Cleanup:

    RETURN( hr );

} //*** CTaskTreeView::HrProcessUpdateProgressTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrUpdateProgressBar
//
//  Description:
//      Update the progress bar based on new tree item data.
//
//  Arguments:
//      ptipdNewIn      - New values of the tree item data.
//      ptipdPrevIn     - Previous values of the tree item data.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrUpdateProgressBar(
      const STreeItemLParamData * ptipdNewIn
    , const STreeItemLParamData * ptipdPrevIn
    )
{
    TraceFunc( "" );

    HRESULT hr          = S_OK;
    ULONG   nRealPos    = 0;
    ULONG   nShrink     = 0;
    ULONG   nExpand     = 0;
    ULONG   nProgress   = 0;

    //
    //  Verify parameters.
    //
    Assert( m_hwndProg != NULL );
    Assert( ptipdNewIn != NULL );
    Assert( ptipdPrevIn != NULL );
    Assert( (ptipdPrevIn->nCurrent <= ptipdPrevIn->nMax) && (ptipdNewIn->nCurrent <= ptipdNewIn->nMax) );
    Assert( (ptipdPrevIn->nCurrent >= ptipdPrevIn->nMin) && (ptipdNewIn->nCurrent >= ptipdNewIn->nMin) );

    //
    //  Make sure we're only passed a task update that we can analyze.
    //
    Assert( IsEqualIID( ptipdPrevIn->clsidMajorTaskId, IID_NULL ) == FALSE );
    Assert( IsEqualIID( ptipdPrevIn->clsidMajorTaskId, ptipdNewIn->clsidMajorTaskId ) == TRUE )     //    Majors match
    Assert( IsEqualIID( ptipdPrevIn->clsidMinorTaskId, ptipdNewIn->clsidMinorTaskId ) == TRUE )     // && Minors match

    if (    IsEqualIID( ptipdPrevIn->clsidMajorTaskId, ptipdNewIn->clsidMajorTaskId ) == FALSE      //    Majors don't match
         || IsEqualIID( ptipdPrevIn->clsidMinorTaskId, ptipdNewIn->clsidMinorTaskId ) == FALSE )    // or Minors don't match
    {
        //  This update is meaningless because we don't know how to compare the two IN params.
        WCHAR   szNewMajor[ 64 ];
        WCHAR   szNewMinor[ 64 ];
        WCHAR   szPrevMajor[ 64 ];
        WCHAR   szPrevMinor[ 64 ];
        int     cch;

        cch = StringFromGUID2( ptipdNewIn->clsidMajorTaskId, szNewMajor, RTL_NUMBER_OF( szNewMajor ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        cch = StringFromGUID2( ptipdNewIn->clsidMinorTaskId, szNewMinor, RTL_NUMBER_OF( szNewMinor ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        cch = StringFromGUID2( ptipdPrevIn->clsidMajorTaskId, szPrevMajor, RTL_NUMBER_OF( szPrevMajor ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        cch = StringFromGUID2( ptipdPrevIn->clsidMinorTaskId, szPrevMinor, RTL_NUMBER_OF( szPrevMinor ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        LogMsg(
              L"[WIZ] Ignoring invalid progress -- major and minor task IDs do not match. new major = %ws, new minor = %ws, prev major = %ws, prev minor = %ws"
            , szNewMajor
            , szNewMinor
            , szPrevMajor
            , szPrevMinor
            );
        hr = THR( S_FALSE );
        goto Cleanup;
    } // if: the two tipd's don't match

    if ( ( ptipdNewIn->nMin == ptipdNewIn->nMax ) && ( ptipdNewIn->nCurrent == ptipdNewIn->nMax ) )
    {
        // This is a one-off: min == max && current == max.
        nExpand   = ptipdNewIn->nCurrent;
        nProgress = ptipdNewIn->nCurrent;
    } // else: this is a one-off
    else if ( ( ptipdNewIn->nMax != ptipdPrevIn->nMax ) || ( ptipdNewIn->nMin != ptipdPrevIn->nMin ) )
    {
        //
        //  The min's and/or maxes changed. Verify that it follows the rules.
        //
        //  Rules:
        //      Max:    If the max changes then min and current need to stay the same.
        //              Resizing max can not cause the current to exceed max.
        //
        //      Min:    If the min changes then max can't change and the difference
        //              between current and min has to remain the same.
        //
        //      In no case should a resizing cause min == max == current - this
        //      will be treated as a one-off event and may orphan a task in the
        //      update progress array.
        //
        if ( ptipdNewIn->nMax != ptipdPrevIn->nMax )                    // Maxes changed
        {
            if (    ( ptipdNewIn->nCurrent != ptipdPrevIn->nCurrent )   //    Currents changed
                ||  ( ptipdNewIn->nMin != ptipdPrevIn->nMin )           // or Mins changed
                ||  ( ptipdNewIn->nCurrent > ptipdNewIn->nMax ) )       // or current exceeded the max
            {
                LogMsg(
                      L"[WIZ] Ignoring invalid progress -- mins and/or maxes are invalid. new min = %d, prev min = %d, new max = %d, prev max = %d, new current = %d, prev current = %d"
                    , ptipdNewIn->nMin
                    , ptipdPrevIn->nMin
                    , ptipdNewIn->nMax
                    , ptipdPrevIn->nMax
                    , ptipdNewIn->nCurrent
                    , ptipdPrevIn->nCurrent
                    );
                hr = THR( S_FALSE );
                goto Cleanup;
            } // if:

            //
            //  The max changed, meaning we'll need to modify the range by that much.
            //
            if ( ptipdNewIn->nMax > ptipdPrevIn->nMax )
            {
                nExpand = ptipdNewIn->nMax - ptipdPrevIn->nMax;
            } // if:
            else
            {
                nShrink = ptipdPrevIn->nMax - ptipdNewIn->nMax;
            } // else:
        } // if: maxes differ
        else    // Mins changed
        {
            // If the difference between min & current varies between the two, or if the new current > new max then fail.
            if (    ( ptipdNewIn->nCurrent - ptipdNewIn->nMin ) != ( ptipdPrevIn->nCurrent - ptipdPrevIn->nMin )
                ||  ( ptipdNewIn->nCurrent > ptipdNewIn->nMax ) )
            {
                LogMsg(
                      L"[WIZ] Ignoring invalid progress -- the range between current and max is incorrect. new current - new min = %d, prev current - prev min = %d, new current %d > new max %d"
                    , ( ptipdNewIn->nCurrent - ptipdNewIn->nMin )
                    , ( ptipdPrevIn->nCurrent - ptipdPrevIn->nMin )
                    , ptipdNewIn->nCurrent
                    , ptipdNewIn->nMax
                    );
                hr = THR( S_FALSE );
                goto Cleanup;
            } // if:

            //
            //  The min changed, meaning we need to modify the range by the difference.
            //
            if ( ptipdNewIn->nMin > ptipdPrevIn->nMin )
            {
                nShrink = ptipdNewIn->nMin - ptipdPrevIn->nMin;
            } // if:
            else
            {
                nExpand = ptipdPrevIn->nMin - ptipdNewIn->nMin;
            } // else:
        } // else: mins changed
    } // else if: min or max changed
    else if (   ( ptipdNewIn->nMax == ptipdPrevIn->nMax )           //      max didn't change
            &&  ( ptipdNewIn->nMin == ptipdPrevIn->nMin )           //  and min didn't change
            &&  ( ptipdNewIn->nCurrent == ptipdPrevIn->nCurrent )   //  and current didn't change
            &&  ( ptipdNewIn->nCurrent == ptipdNewIn->nMin ) )      //  and current equals min
    {
        nExpand = ptipdNewIn->nMax - ptipdNewIn->nMin;              //  We have a new task.
    } // else if: we're adding a new task
    else if (   ( ptipdNewIn->nMax == ptipdPrevIn->nMax )           //      max didn't change
            &&  ( ptipdNewIn->nMin == ptipdPrevIn->nMin )           //  and min didn't change
            &&  ( ptipdNewIn->nCurrent > ptipdPrevIn->nCurrent )    //  and current increased
            &&  ( ptipdNewIn->nCurrent <= ptipdNewIn->nMax ) )      //  and current didn't exceed max
    {
        nProgress = ptipdNewIn->nCurrent - ptipdPrevIn->nCurrent;   //  We have an update.
    } // else if: we're updating a known task
    else
    {
        //  This event broke the rules - toss it out.
        LogMsg(
              L"[WIZ] Ignoring invalid progress -- min, max or current are invalid. new min = %d, prev min = %d, new max = %d, prev max = %d, new current = %d, prev current = %d"
            , ptipdNewIn->nMin
            , ptipdPrevIn->nMin
            , ptipdNewIn->nMax
            , ptipdPrevIn->nMax
            , ptipdNewIn->nCurrent
            , ptipdPrevIn->nCurrent
            );
        hr = THR( S_FALSE );
        goto Cleanup;
    } // else if: the two tipd's don't conform to the rules of a progress bar update

    m_nRangeHigh += nExpand;
    Assert( m_nRangeHigh >= nShrink )
    m_nRangeHigh -= nShrink;
    if ( m_nRangeHigh > m_nInitialTickCount )
    {
        m_fThresholdBroken = TRUE;
    } // if: exceeded the initial tick count

    m_nCurrentPos += nProgress;

    if ( m_nCurrentPos >= m_nRangeHigh )
    {
        //
        //  Something went wrong - our position is now somehow greater than
        //  the range (multi-threading issue?).  Simple fix - set our new range
        //  to be PROGRESSBAR_RESIZE_PERCENT percent greater than our new position
        //
        m_nRangeHigh = ( m_nCurrentPos * (100 + PROGRESSBAR_RESIZE_PERCENT) ) / 100;
    } // if: current pos caught up to the upper range

    // Adjust to the progress bar's scale (PROGRESSBAR_CONTROL_TICK_COUNT).
    nRealPos = m_nCurrentPos * PROGRESSBAR_CONTROL_TICK_COUNT;
    if ( m_fThresholdBroken )
    {
        nRealPos /= m_nRangeHigh;
    } // if: use threshold
    else
    {
        nRealPos /= m_nInitialTickCount;
    } // else: use initial tick count

    //
    //  If our progress bar position actually moved forward - update the control.
    //  This isn't always the case because we may have a new task come in and
    //  report a large number of steps, thereby moving our real position
    //  backwards, but we don't want to show reverse progress - just a steady
    //  advancement towards being done.
    //
    if ( nRealPos > m_nRealPos )
    {
        m_nRealPos = nRealPos;
        SendMessage( m_hwndProg, PBM_SETPOS, m_nRealPos, 0 );
    } // if: forward progress

Cleanup:

    HRETURN( hr );

} //*** CTaskTreeView::HrUpdateProgressBar

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrPropagateChildStateToParents
//
//  Description:
//      Extend the state of a child item to its parent items.
//      If the state of the child is worse (higher priority) than the
//      parent's, update the state of the parent.
//
//  Arguments:
//      htiChildIn      - Child item whose state is to be extended.
//      nImageIn        - Image of the child item.
//      fOnlyUpdateProgressIn - TRUE = only updating progress.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      S_FALSE         - No parent item.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrPropagateChildStateToParents(
      HTREEITEM htiChildIn
    , int       nImageIn
    , BOOL      fOnlyUpdateProgressIn
    )
{
    TraceFunc( "" );

    Assert( htiChildIn != NULL );

    HRESULT     hr = S_OK;
    BOOL        fReturn;
    TVITEMEX    tviParent;
    TVITEMEX    tviChild;
    HTREEITEM   htiParent;
    HTREEITEM   htiChild;

    //
    // Get the parent item.
    //

    htiParent = TreeView_GetParent( m_hwndTV, htiChildIn );
    if ( htiParent == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    tviParent.mask = TVIF_PARAM | TVIF_IMAGE;
    tviParent.hItem = htiParent;

    fReturn = TreeView_GetItem( m_hwndTV, &tviParent );
    if ( ! fReturn )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    } // if:

    //
    //  If the state of the child is worse (higher priority) than the
    //  parent's, update the state of the parent.
    //

    if (    ( tviParent.iImage < nImageIn )
        ||  (   ( tviParent.iImage == tsDONE )
            &&  ( nImageIn == tsPENDING )
            )
        )
    {
        //
        //  Special Case:   For the parent to be set to tsDONE, all
        //                  the children must be set to tsDONE as well.
        //
        if (    ( nImageIn == tsDONE )
            &&  ! fOnlyUpdateProgressIn
            )
        {
            //
            //  Enum the children to see if they all have tsDONE as their images.
            //

            htiChild = TreeView_GetChild( m_hwndTV, tviParent.hItem );
            while ( htiChild != NULL )
            {
                tviChild.mask   = TVIF_IMAGE;
                tviChild.hItem  = htiChild;

                fReturn = TreeView_GetItem( m_hwndTV, &tviChild );
                if ( ! fReturn )
                {
                    hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
                    goto Cleanup;
                } // if:

                if ( tviChild.iImage != tsDONE )
                {
                    //
                    //  Not all tsDONE! Skip setting parent's image!
                    //  This can occur if the child is displaying a warning
                    //  or error state image.
                    //
                    goto Cleanup;
                } // if:

                //  Get next child
                htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );
            } // while: more children
        } // if: special case (see above)

        //
        //  Set the parent's icon.
        //

        tviParent.mask           = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tviParent.iImage         = nImageIn;
        tviParent.iSelectedImage = nImageIn;
        TreeView_SetItem( m_hwndTV, &tviParent );
    } // if: need to update parent's image

    //
    // Traverse up the tree.
    //

    hr = STHR( HrPropagateChildStateToParents( htiParent, nImageIn, fOnlyUpdateProgressIn ) );
    if ( hr == S_FALSE )
    {
        // S_FALSE means that there wasn't a parent.
        hr = S_OK;
    } // if:

    goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrPropagateChildStateToParents

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrDisplayDetails
//
//  Description:
//      Display the Details dialog box.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrDisplayDetails( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    HTREEITEM       hti;
    HWND            hwndPropertyPage;

    //
    // If no item is selected, select the first item.
    //

    if ( m_htiSelected == NULL )
    {
        hti = TreeView_GetRoot( m_hwndTV );
        Assert( hti != NULL );
        hr = THR( HrSelectItem( hti ) );
        if ( FAILED( hr ) )
        {
            // TODO: Display message box
            goto Cleanup;
        } // if:
    } // if: no items are selected

    //
    // Display the dialog box.
    //

    hwndPropertyPage = GetParent( m_hwndTV );
    Assert( hwndPropertyPage != NULL );
    hr = THR( CDetailsDlg::S_HrDisplayModalDialog( hwndPropertyPage, this, m_htiSelected ) );

    SetFocus( m_hwndTV );

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrDisplayDetails

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::FGetItem
//
//  Description:
//      Get the data for an item.
//
//  Arguments:
//      htiIn       - Handle for the item to get.
//      pptipdOut   - Pointer in which to return the data structure.
//
//  Return Values:
//      TRUE        - Item returned successfully.
//      FALSE       - Item not returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CTaskTreeView::FGetItem(
      HTREEITEM                 htiIn
    , STreeItemLParamData **    pptipd
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );
    Assert( pptipd != NULL );

    BOOL        fRet;
    TVITEMEX    tvi;

    ZeroMemory( &tvi, sizeof( tvi ) );

    tvi.mask    = TVIF_PARAM;
    tvi.hItem   = htiIn;

    fRet = TreeView_GetItem( m_hwndTV, &tvi );
    if ( fRet == FALSE )
    {
        goto Cleanup;
    } // if:

    Assert( tvi.lParam != NULL );
    *pptipd = reinterpret_cast< STreeItemLParamData * >( tvi.lParam );

Cleanup:
    RETURN( fRet );

} //*** CTaskTreeView::FGetItem

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrFindPrevItem
//
//  Description:
//      Find the previous item.  The previous item could be at a deeper
//      level than this item.
//
//  Arguments:
//      phtiOut     - Handle to previous item (optional).
//
//  Return Values:
//      S_OK        - Previous item found successfully.
//      S_FALSE     - No previous item found.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrFindPrevItem(
    HTREEITEM *     phtiOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    HTREEITEM   htiCur;
    HTREEITEM   htiPrev;

    htiCur = m_htiSelected;

    if ( phtiOut != NULL )
    {
        *phtiOut = NULL;
    } // if:

    //
    // Find the previous sibling item.
    //

    htiPrev = TreeView_GetPrevSibling( m_hwndTV, htiCur );
    if ( htiPrev == NULL )
    {
        //
        // NO PREVIOUS SIBLING ITEM FOUND.
        //
        // Find the parent item.
        // If there isn't a parent, then there isn't a previous item.
        //

        htiPrev = TreeView_GetParent( m_hwndTV, htiCur );
        if ( htiPrev == NULL )
        {
            goto Cleanup;
        } // if: no parent item

        //
        // The parent is the previous item.
        //

    } // if: no previous sibling
    else
    {
        //
        // PREVIOUS SIBLING ITEM FOUND.
        //
        // Find the deepest child of the last child item.
        //

        for ( ;; )
        {
            //
            // Find the first child item.
            //

            htiCur = TreeView_GetChild( m_hwndTV, htiPrev );
            if ( htiCur == NULL )
            {
                //
                // NO CHILD ITEM FOUND.
                //
                // This is the previous item.
                //

                break;

            } // if: no children

            //
            // CHILD ITEM FOUND.
            //
            // Find the last sibling of this child item.
            //

            for ( ;; )
            {
                //
                // Find the next sibling item.
                //

                htiPrev = TreeView_GetNextSibling( m_hwndTV, htiCur );
                if ( htiPrev == NULL )
                {
                    //
                    // No next sibling item found.
                    // Exit this loop and continue the outer loop
                    // to find this item's children.
                    //

                    htiPrev = htiCur;
                    break;
                } // if: no next sibling item found

                //
                // Found a next sibling item.
                //

                htiCur = htiPrev;
            } // forever: find the last child item
        } // forever: find the deepest child item
    } // else: previous sibling item found

    //
    // Return the item we found.
    //

    Assert( htiPrev != NULL );

    if ( phtiOut != NULL )
    {
        *phtiOut = htiPrev;
    } // if:

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrFindPrevItem

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrFindNextItem
//
//  Description:
//      Find the next item.  The next item could be at a different level than
//      this item.
//
//  Arguments:
//      phtiOut     - Handle to next item (optional).
//
//  Return Values:
//      S_OK        - Next item found successfully.
//      S_FALSE     - No next item found.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrFindNextItem(
    HTREEITEM *     phtiOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    HTREEITEM   htiCur;
    HTREEITEM   htiNext;

    htiCur = m_htiSelected;

    if ( phtiOut != NULL )
    {
        *phtiOut = NULL;
    } // if:

    //
    // Find the first child item.
    //

    htiNext = TreeView_GetChild( m_hwndTV, htiCur );
    if ( htiNext == NULL )
    {
        //
        // NO CHILD ITEM FOUND.
        //

        for ( ;; )
        {
            //
            // Get the next sibling item.
            //

            htiNext = TreeView_GetNextSibling( m_hwndTV, htiCur );
            if ( htiNext == NULL )
            {
                //
                // NO SIBLING ITEM FOUND.
                //
                // Find the parent item so we can find its next sibling.
                //

                htiNext = TreeView_GetParent( m_hwndTV, htiCur );
                if ( htiNext == NULL )
                {
                    //
                    // NO PARENT ITEM FOUND.
                    //
                    // At the end of the tree.
                    //

                    goto Cleanup;
                } // if: no parent found

                //
                // PARENT ITEM FOUND.
                //
                // Find the parent item's next sibling.
                //

                htiCur = htiNext;
                continue;
            } // if: no next sibling item

            //
            // SIBLING ITEM FOUND.
            //
            // Found the next item.
            //

            break;
        } // forever: find the next sibling or parent's sibling
    } // if: no child item found
    else
    {
        //
        // CHILD ITEM FOUND.
        //
        // Found the next item.
        //
    } // else: child item found

    //
    // Return the item we found.
    //

    Assert( htiNext != NULL );

    if ( phtiOut != NULL )
    {
        *phtiOut = htiNext;
    } // if:

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrFindNextItem

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrSelectItem
//
//  Description:
//      Select the specified item.
//
//  Arguments:
//      htiIn       - Handle to item to select.
//
//  Return Values:
//      S_OK        - Item selected successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrSelectItem(
    HTREEITEM   htiIn
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );

    HRESULT     hr = S_OK;

    TreeView_SelectItem( m_hwndTV, htiIn );

    HRETURN( hr );

} //*** CTaskTreeView::HrSelectItem

//****************************************************************************
//
//  Static Functions
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateTreeItem
//
//  Description:
//      Create a tree item.
//
//  Arguments:
//      ptvisOut        - Tree view insert structure to fill in.
//      ptipdIn         - Input tree item LParam data to create this item from.
//      htiParentIn     - Parent tree view item.
//      nImageIn        - Image index.
//      bstrTextIn      - Text to display.
//
//  Return Values:
//      S_OK            - Operation was successful.
//      E_OUTOFMEMORY   - Error allocating memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateTreeItem(
      TVINSERTSTRUCT *          ptvisOut
    , STreeItemLParamData *     ptipdIn
    , HTREEITEM                 htiParentIn
    , int                       nImageIn
    , BSTR                      bstrTextIn
    )
{
    TraceFunc( "" );

    Assert( ptvisOut != NULL );
    Assert( ptipdIn != NULL );
    Assert( htiParentIn != NULL );
    Assert( bstrTextIn != NULL );

    // LOCAL VARIABLES
    HRESULT                 hr = S_OK;
    STreeItemLParamData *   ptipdNew = NULL;

    //
    // Allocate the tree view LParam data and initialize it.
    //

    ptipdNew = new STreeItemLParamData;
    if ( ptipdNew == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    CopyMemory( &ptipdNew->clsidMajorTaskId, &ptipdIn->clsidMajorTaskId, sizeof( ptipdNew->clsidMajorTaskId ) );
    CopyMemory( &ptipdNew->clsidMinorTaskId, &ptipdIn->clsidMinorTaskId, sizeof( ptipdNew->clsidMinorTaskId ) );
    CopyMemory( &ptipdNew->ftTime, &ptipdIn->ftTime, sizeof( ptipdNew->ftTime ) );
    ptipdNew->nMin      = ptipdIn->nMin;
    ptipdNew->nMax      = ptipdIn->nMax;
    ptipdNew->nCurrent  = ptipdIn->nCurrent;
    ptipdNew->hr        = ptipdIn->hr;

    if ( ptipdIn->bstrNodeName != NULL )
    {
        ptipdNew->bstrNodeName = TraceSysAllocString( ptipdIn->bstrNodeName );
        if ( ptipdNew->bstrNodeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        Assert( ptipdIn->bstrNodeNameWithoutDomain != NULL );
        ptipdNew->bstrNodeNameWithoutDomain = TraceSysAllocString( ptipdIn->bstrNodeNameWithoutDomain );
        if ( ptipdNew->bstrNodeNameWithoutDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if: node name specified

    if ( ptipdIn->bstrDescription != NULL )
    {
        ptipdNew->bstrDescription = TraceSysAllocString( ptipdIn->bstrDescription );
        if ( ptipdNew->bstrDescription == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if: description specified

    if ( ptipdIn->bstrReference != NULL )
    {
        ptipdNew->bstrReference = TraceSysAllocString( ptipdIn->bstrReference );
        if ( ptipdNew->bstrReference == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if: reference specified

    //
    // Initialize the tree view insert structure.
    //

    ptvisOut->hParent                = htiParentIn;
    ptvisOut->hInsertAfter           = TVI_LAST;
    ptvisOut->itemex.mask            = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    ptvisOut->itemex.cchTextMax      = SysStringLen( bstrTextIn );
    ptvisOut->itemex.pszText         = bstrTextIn;
    ptvisOut->itemex.iImage          = nImageIn;
    ptvisOut->itemex.iSelectedImage  = nImageIn;
    ptvisOut->itemex.lParam          = reinterpret_cast< LPARAM >( ptipdNew );

    Assert( ptvisOut->itemex.cchTextMax > 0 );

    // Release ownership to the tree view insert structure.
    ptipdNew = NULL;

    goto Cleanup;

Cleanup:

    if ( ptipdNew != NULL )
    {
        TraceSysFreeString( ptipdNew->bstrNodeName );
        TraceSysFreeString( ptipdNew->bstrNodeNameWithoutDomain );
        TraceSysFreeString( ptipdNew->bstrDescription );
        TraceSysFreeString( ptipdNew->bstrReference );
        delete ptipdNew;
    } // if:
    HRETURN( hr );

} //*** HrCreateTreeItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\wizardhelp.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      WizardHelp.h
//
//  Maintained By:
//      George Potts (gpotts)   23-July-2001 
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define CLUSCFG_HELP_FILE           L"cluadmin.hlp"

#define IDH_DETAILS_S_DATE          700001701   // The date on which the event occurred.
#define IDH_DETAILS_S_TIME          700001702   // The time at which the event occurred.
#define IDH_DETAILS_S_COMPUTER      700001703   // The computer to which the event applies.
#define IDH_DETAILS_S_MAJOR_ID      700001704   // This typically indicates the class of events to which this event belongs.
#define IDH_DETAILS_S_MINOR_ID      700001705   // This typically indicates the subclass of events to which this event belongs. 
#define IDH_DETAILS_S_PROGRESS      700001706   // The first value specifies the minimum step number.  The second value specifies the maximum step number.  The third value specifies the step number for this event.
#define IDH_DETAILS_S_STATUS        700001707   // The completion status.
#define IDH_DETAILS_S_DESCRIPTION   700001708   // Specific information about this event.  This will be the same text that appears in the wizard.
#define IDH_DETAILS_S_REFERENCE     700001709   // Specifies additional information about the event to help troubleshoot the problem, if any.
#define IDH_DETAILS_PB_PREV         700001710   // Displays details about the previous configuration task.
#define IDH_DETAILS_PB_NEXT         700001711   // Displays details about the next configuration task.
#define IDH_DETAILS_PB_COPY         700001712   // Copies details of the configuration task to the Clipboard.

#define IDH_QUORUM_S_QUORUM         700001750   // Resource or Resource Type that will be used for the quorum.

#define IDH_ADVANCED_RB_FULL_CONFIG 700001760   // Full configuration.
#define IDH_ADVANCED_RB_MIN_CONFIG  700001761   // Minimum configuration
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\welcomepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      WelcomePage.h
//
//  Maintained By:
//      David Potter    (DavidP)    26-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWelcomePage
//
//  Description:
//      The class CWelcomePage is class the for the welcome page in the
//      wizard.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWelcomePage
{
private:

    //
    // Private member functions and data
    //

    HWND                m_hwnd;                 // Our HWND
    HFONT               m_hFont;                // Title font
    CClusCfgWizard *    m_pccw;                 // Wizard
    ECreateAddMode      m_ecamCreateAddMode;    // Creating? Adding?

    // Private copy constructor to prevent copying.
    CWelcomePage( const CWelcomePage & nodeSrc );

    // Private assignment operator to prevent copying.
    const CWelcomePage & operator = ( const CWelcomePage & nodeSrc );

    LRESULT OnInitDialog( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );

public:

    //
    // Public, non interface methods.
    //

    CWelcomePage( CClusCfgWizard * pccwIn, ECreateAddMode ecamCreateAddModeIn );

    virtual ~CWelcomePage( void );

    static INT_PTR CALLBACK S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CWelcomePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\wizardstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 16-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

/////////////////////////////////////////////////////////////////////
// Strings
/////////////////////////////////////////////////////////////////////

#define IDS_LARGEFONTNAME                                   ( ID_WIZ_START +   0 )
#define IDS_LARGEFONTSIZE                                   ( ID_WIZ_START +   1 )

#define IDS_TITLE_FORM                                      ( ID_WIZ_START +  11 )
#define IDS_TITLE_JOIN                                      ( ID_WIZ_START +  12 )
#define IDS_TCLUSTER                                        ( ID_WIZ_START +  13 )
#define IDS_STCLUSTER_CREATE                                ( ID_WIZ_START +  14 )
#define IDS_STCLUSTER_ADD                                   ( ID_WIZ_START +  15 )
#define IDS_TSELNODE                                        ( ID_WIZ_START +  10 )
#define IDS_STSELNODE                                       ( ID_WIZ_START +  21 )
#define IDS_TSELNODES                                       ( ID_WIZ_START +  22 )
#define IDS_STSELNODES                                      ( ID_WIZ_START +  23 )
#define IDS_TANALYZE                                        ( ID_WIZ_START +  24 )
#define IDS_STANALYZE                                       ( ID_WIZ_START +  25 )
#define IDS_TIPADDRESS                                      ( ID_WIZ_START +  26 )
#define IDS_STIPADDRESS                                     ( ID_WIZ_START +  27 )
#define IDS_TIPADDRESS2                                     ( ID_WIZ_START +  28 )
#define IDS_STIPADDRESS2                                    ( ID_WIZ_START +  29 )
#define IDS_TCSACCOUNT                                      ( ID_WIZ_START +  20 )
#define IDS_STCSACCOUNT                                     ( ID_WIZ_START +  31 )
#define IDS_TSUMMARY                                        ( ID_WIZ_START +  32 )
#define IDS_STSUMMARY_CREATE                                ( ID_WIZ_START +  33 )
#define IDS_STSUMMARY_ADD                                   ( ID_WIZ_START +  34 )
#define IDS_TCOMMIT_CREATE                                  ( ID_WIZ_START +  35 )
#define IDS_TCOMMIT_ADD                                     ( ID_WIZ_START +  36 )
#define IDS_STCOMMIT                                        ( ID_WIZ_START +  37 )
#define IDS_QUERY_CANCEL_TITLE                              ( ID_WIZ_START +  38 )
#define IDS_QUERY_CANCEL_TEXT                               ( ID_WIZ_START +  39 )
#define IDS_TASKS_COMPLETED                                 ( ID_WIZ_START +  40 )

#define IDS_DOMAIN_DESC_CREATE                              ( ID_WIZ_START +  60 )
#define IDS_DOMAIN_DESC_ADD                                 ( ID_WIZ_START +  61 )
#define IDS_SUMMARY_NEXT_CREATE                             ( ID_WIZ_START +  62 )
#define IDS_SUMMARY_NEXT_ADD                                ( ID_WIZ_START +  63 )
#define IDS_COMPLETION_TITLE_CREATE                         ( ID_WIZ_START +  64 )
#define IDS_COMPLETION_TITLE_ADD                            ( ID_WIZ_START +  65 )
#define IDS_COMPLETION_DESC_CREATE                          ( ID_WIZ_START +  66 )
#define IDS_COMPLETION_DESC_ADD                             ( ID_WIZ_START +  67 )

#define IDS_WELCOME_CREATE_REQ_1                            ( ID_WIZ_START +  80 )
#define IDS_WELCOME_CREATE_REQ_2                            ( ID_WIZ_START +  81 )
#define IDS_WELCOME_CREATE_REQ_3                            ( ID_WIZ_START +  82 )
#define IDS_WELCOME_CREATE_REQ_4                            ( ID_WIZ_START +  83 )
#define IDS_WELCOME_CREATE_REQ_5                            ( ID_WIZ_START +  84 )
#define IDS_WELCOME_ADD_REQ_1                               ( ID_WIZ_START +  85 )
#define IDS_WELCOME_ADD_REQ_2                               ( ID_WIZ_START +  86 )

#define IDS_ANALYSIS_SUCCESSFUL_INSTRUCTIONS                ( ID_WIZ_START + 101 )
#define IDS_ANALYSIS_FAILED_INSTRUCTIONS                    ( ID_WIZ_START + 102 )
#define IDS_ANALYSIS_STARTING_INSTRUCTIONS                  ( ID_WIZ_START + 103 )
#define IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS                  ( ID_WIZ_START + 104 )
#define IDS_COMMIT_FAILED_INSTRUCTIONS_BACK_ENABLED         ( ID_WIZ_START + 105 )
#define IDS_COMMIT_FAILED_INSTRUCTIONS                      ( ID_WIZ_START + 106 )
#define IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS_BACK_DISABLED    ( ID_WIZ_START + 107 )

#define IDS_DEFAULT_DETAILS_REFERENCE                       ( ID_WIZ_START + 120 )

#define IDS_DETAILS_CLP_DATE                                ( ID_WIZ_START + 131 )
#define IDS_DETAILS_CLP_TIME                                ( ID_WIZ_START + 132 )
#define IDS_DETAILS_CLP_COMPUTER                            ( ID_WIZ_START + 133 )
#define IDS_DETAILS_CLP_MAJOR                               ( ID_WIZ_START + 134 )
#define IDS_DETAILS_CLP_MINOR                               ( ID_WIZ_START + 135 )
#define IDS_DETAILS_CLP_DESC                                ( ID_WIZ_START + 136 )
#define IDS_DETAILS_CLP_STATUS                              ( ID_WIZ_START + 137 )
#define IDS_DETAILS_CLP_INFO                                ( ID_WIZ_START + 138 )
#define IDS_DETAILS_CLP_PROGRESS                            ( ID_WIZ_START + 139 )

#define IDS_CANNOT_FIND_MATCHING_NETWORK_TITLE              ( ID_WIZ_START + 150 )
#define IDS_CANNOT_FIND_MATCHING_NETWORK_TEXT               ( ID_WIZ_START + 151 )

#define IDS_UNKNOWN_TASK                                    ( ID_WIZ_START + 160 )

#define IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER      ( ID_WIZ_START + 170 )
#define IDS_TASKID_MAJOR_ESTABLISH_CONNECTION               ( ID_WIZ_START + 171 )
#define IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY             ( ID_WIZ_START + 172 )
#define IDS_TASKID_MAJOR_FIND_DEVICES                       ( ID_WIZ_START + 173 )
#define IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY          ( ID_WIZ_START + 174 )
#define IDS_TASKID_MAJOR_REANALYZE                          ( ID_WIZ_START + 175 )
#define IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES         ( ID_WIZ_START + 176 )
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES           ( ID_WIZ_START + 177 )
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCES                ( ID_WIZ_START + 178 )

#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_FAILED            ( ID_WIZ_START + 201 )
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_FAILED     ( ID_WIZ_START + 202 )
#define IDS_TASKID_MINOR_NETBIOS_RESET_FAILED               ( ID_WIZ_START + 203 )
#define IDS_TASKID_MINOR_NETBIOS_BINDING_SUCCEEDED          ( ID_WIZ_START + 204 )
#define IDS_TASKID_MINOR_NETBIOS_BINDING_FAILED             ( ID_WIZ_START + 205 )
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_SUCCEEDED  ( ID_WIZ_START + 206 )
#define IDS_TASKID_MINOR_MULTIPLE_DNS_RECORDS_FOUND         ( ID_WIZ_START + 207 )
#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_SUCCEEDED         ( ID_WIZ_START + 208 )
#define IDS_TASKID_MINOR_NETBIOS_LANAENUM_FAILED            ( ID_WIZ_START + 209 )

#define IDS_ERR_NO_SUCH_DOMAIN_TITLE                        ( ID_WIZ_START + 220 )
#define IDS_ERR_NO_SUCH_DOMAIN_TEXT                         ( ID_WIZ_START + 221 )
#define IDS_ERR_INVALID_DNS_DOMAIN_NAME_TITLE               ( ID_WIZ_START + 222 )
#define IDS_ERR_INVALID_DNS_DOMAIN_NAME_TEXT                ( ID_WIZ_START + 223 )
#define IDS_ERR_VALIDATING_NAME_TITLE                       ( ID_WIZ_START + 224 )
#define IDS_ERR_VALIDATING_NAME_TEXT                        ( ID_WIZ_START + 225 )
#define IDS_ERR_INVOKING_LINK_TITLE                         ( ID_WIZ_START + 226 )
#define IDS_ERR_INVOKING_LINK_TEXT                          ( ID_WIZ_START + 227 )
#define IDS_ERR_IPADDRESS_ALREADY_PRESENT_TEXT              ( ID_WIZ_START + 228 )
#define IDS_ERR_IPADDRESS_ALREADY_PRESENT_TITLE             ( ID_WIZ_START + 229 )
#define IDS_ERR_VIEW_LOG_TITLE                              ( ID_WIZ_START + 230 )
#define IDS_ERR_VIEW_LOG_TEXT                               ( ID_WIZ_START + 231 )

#define IDS_ERR_INVALID_DNS_NAME_TEXT                       ( ID_WIZ_START + 250 )
#define IDS_ERR_FULL_DNS_NAME_INFO_TEXT                     ( ID_WIZ_START + 251 )
#define IDS_ERR_DNS_HOSTNAME_LABEL_NO_NETBIOS               ( ID_WIZ_START + 252 )
#define IDS_ERR_NON_RFC_NAME_QUERY                          ( ID_WIZ_START + 253 )
#define IDS_ERR_DNS_NAME_INVALID_CHAR                       ( ID_WIZ_START + 254 )
#define IDS_ERR_DNS_HOSTNAME_LABEL_NUMERIC                  ( ID_WIZ_START + 255 )
#define IDS_ERR_FULL_DNS_NAME_NUMERIC                       ( ID_WIZ_START + 256 )
#define IDS_TASK_RETURNED_ERROR                             ( ID_WIZ_START + 257 )
#define IDS_TASK_RETURNED_STATUS                            ( ID_WIZ_START + 258 )
#define IDS_ERR_HOST_DOMAIN_DOESNT_MATCH_CLUSTER            ( ID_WIZ_START + 259 )
#define IDS_ERR_DNS_HOSTNAME_LABEL_EMPTY_TEXT               ( ID_WIZ_START + 260 )
#define IDS_ERR_DNS_HOSTNAME_LABEL_LONG_TEXT                ( ID_WIZ_START + 261 )
#define IDS_ERR_NON_RFC_NAME_STATUS                         ( ID_WIZ_START + 262 )
#define IDS_ERR_NON_RFC_NAME_TITLE                          ( ID_WIZ_START + 263 )
#define IDS_ERR_NON_RFC_NAME_TEXT                           ( ID_WIZ_START + 264 )
#define IDS_ERR_FQN_CREATE_TITLE                            ( ID_WIZ_START + 265 )
#define IDS_ERR_FQN_CREATE_TEXT                             ( ID_WIZ_START + 266 )
#define IDS_ERR_CLUSTER_RENAME_TITLE                        ( ID_WIZ_START + 267 )
#define IDS_ERR_CLUSTER_RENAME_TEXT                         ( ID_WIZ_START + 268 )
#define IDS_ERR_CLUSTER_CREATE_IP_TEXT                      ( ID_WIZ_START + 269 )
#define IDS_ERR_DNS_HOSTNAME_INVALID_CHAR                   ( ID_WIZ_START + 270 )
#define IDS_ERR_DUPLICATE_NODE_TITLE                        ( ID_WIZ_START + 271 )
#define IDS_ERR_DUPLICATE_NODE_TEXT                         ( ID_WIZ_START + 272 )

#define IDS_CLUSTERIPADDRESS                                ( ID_WIZ_START + 280 )
#define IDS_QUORUMRESOURCE                                  ( ID_WIZ_START + 281 )

#define IDS_SUMMARY_CLUSTER_NAME                            ( ID_WIZ_START + 300 )
#define IDS_SUMMARY_IPADDRESS                               ( ID_WIZ_START + 301 )
#define IDS_SUMMARY_CREDENTIALS                             ( ID_WIZ_START + 302 )
#define IDS_SUMMARY_MEMBERSHIP_BEGIN                        ( ID_WIZ_START + 303 )
#define IDS_SUMMARY_RESOURCES_BEGIN                         ( ID_WIZ_START + 304 )
#define IDS_SUMMARY_RESOURCE_QUORUM_DEVICE                  ( ID_WIZ_START + 305 )
#define IDS_SUMMARY_RESOURCE_MANAGED                        ( ID_WIZ_START + 306 )
#define IDS_SUMMARY_RESOURCE_NOT_MANAGED                    ( ID_WIZ_START + 307 )
#define IDS_SUMMARY_RESOURCES_END                           ( ID_WIZ_START + 308 )
#define IDS_SUMMARY_NETWORKS_BEGIN                          ( ID_WIZ_START + 309 )
#define IDS_SUMMARY_NETWORKS_END                            ( ID_WIZ_START + 310 )
#define IDS_SUMMARY_NETWORK_INFO                            ( ID_WIZ_START + 311 )
#define IDS_SUMMARY_NETWORK_PRIVATE                         ( ID_WIZ_START + 312 )
#define IDS_SUMMARY_NETWORK_BOTH                            ( ID_WIZ_START + 313 )
#define IDS_SUMMARY_NETWORK_NOTUSED                         ( ID_WIZ_START + 314 )
#define IDS_SUMMARY_NETWORK_PUBLIC                          ( ID_WIZ_START + 315 )
#define IDS_SUMMARY_MEMBERSHIP_SEPARATOR                    ( ID_WIZ_START + 316 )
#define IDS_SUMMARY_MEMBERSHIP_END                          ( ID_WIZ_START + 317 )
#define IDS_SUMMARY_CLUSTER_NETWORK                         ( ID_WIZ_START + 318 )
#define IDS_SUMMARY_NODE_RESOURCES_BEGIN                    ( ID_WIZ_START + 319 )

#define IDS_ERR_RESOURCE_GATHER_FAILURE_TITLE               ( ID_WIZ_START + 330 )
#define IDS_ERR_QUORUM_COMMIT_FAILURE_TITLE                 ( ID_WIZ_START + 331 )
#define IDS_ERR_QUORUM_COMMIT_FAILURE_TEXT                  ( ID_WIZ_START + 332 )
#define IDS_ERR_RESOURCE_GATHER_FAILURE_TEXT                ( ID_WIZ_START + 333 )

#define IDS_FORMAT_STATUS                                   ( ID_WIZ_START + 350 )

#define IDS_TASK_RETURNED_NEW_ERROR                         ( ID_WIZ_START + 360 )
#define IDS_TASK_RETURNED_NEW_STATUS                        ( ID_WIZ_START + 361 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter        (DavidP)    20-JUL-2000
//      Cristian Scutaru    (CScutaru)  28-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#endif // DBG==1

#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <wchar.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <CITracker.h>
#include <guids.h>
#include <CLusCfgPrivate.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Debugging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//          Original version.
//
//      Vij Vasu (VVasu) 29-AUG-2000
//          Modified this file to remove dependency on Shell API since they
//          may not be present on the OS that this DLL runs in.
//          Removed WMI related functions for the same reason.
//
//      David Potter (DavidP) 12-OCT-2000
//          Reverted back to use the standard DebugSrc.cpp and modified
//          it to support NT4.
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\wizardutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardUtils.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "WizardUtils.h"
#include "Nameutil.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateFQN
//
//  Description:
//      Validate a label (or IP address) and domain by creating an FQN from
//      them, prompting the user to choose whether to accept any non-RFC
//      characters present.
//
//  Arguments:
//      hwndParentIn
//          Parent window for user prompts.
//
//      pcwszLabelIn
//          The label (or IP address) of the FQN.
//
//      pcwszDomainIn
//          The domain of the FQN.
//
//      pfnLabelValidatorIn
//          Pointer to a function that determines whether the label is valid.
//
//      pbstrFQNOut
//          Upon success, the created FQN.
//
//      pefeoOut
//          Upon failure, indicates whether the problem arose from the label,
//          the domain, or a system call (such as allocating memory).
//
//  Return Values:
//      S_OK
//          The label and domain are valid, and *pbstrFQNOut is a BSTR that
//          contains the resulting FQN; the caller must free *pbstrFQNOut with
//          SysFreeString.
//
//      Failure
//          pefeoOut provides additional information regarding the source of
//          the failure.
//
//  Remarks:
//
//      This function enforces the UI policy of prohibiting users from
//      entering FQDNs for machine names; the label must be only a label.
//
//      pefeoOut lets the caller take further action (such as setting the
//      focus on a control) according to the source of an error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateFQN(
      HWND                  hwndParentIn
    , LPCWSTR               pcwszLabelIn
    , LPCWSTR               pcwszDomainIn
    , PFN_LABEL_VALIDATOR   pfnLabelValidatorIn           
    , BSTR *                pbstrFQNOut
    , EFQNErrorOrigin *     pefeoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    bool    fTryAgain = true;
    bool    fAcceptNonRFCLabel = false;
    bool    fAcceptNonRFCDomain = false;

    EFQNErrorOrigin efeo = feoSYSTEM;

    Assert( pcwszLabelIn != NULL );
    //  pcwszDomainIn can be null, which means to use local machine's domain.
    Assert( pfnLabelValidatorIn != NULL );
    Assert( pbstrFQNOut != NULL );
    Assert( *pbstrFQNOut == NULL );
    //  pefeoOut can be null, which means the caller doesn't care about the source of failure.

    //  Disallow FQDNs for the label, and allow IP addresses.
    hr = THR( ( *pfnLabelValidatorIn )( pcwszLabelIn, true ) );
    if ( FAILED( hr ) )
    {
        efeo = feoLABEL;
        THR( HrShowInvalidLabelPrompt( hwndParentIn, pcwszLabelIn, hr, &fAcceptNonRFCLabel ) );
        goto Error;
    }

    //
    //  Make the FQN, trying first without RFC chars, and again if it makes a difference.
    //
    while ( fTryAgain )
    {
        hr = THR( HrMakeFQN( pcwszLabelIn, pcwszDomainIn, fAcceptNonRFCLabel || fAcceptNonRFCDomain, pbstrFQNOut, &efeo ) );
        if ( FAILED( hr ) )
        {
            if ( efeo == feoLABEL )
            {
                HRESULT hrPrompt = S_OK;
                hrPrompt = THR( HrShowInvalidLabelPrompt( hwndParentIn, pcwszLabelIn, hr, &fAcceptNonRFCLabel ) );
                if ( FAILED( hrPrompt ) )
                {
                    goto Error;
                }
                fTryAgain = fAcceptNonRFCLabel;
            }
            else if ( efeo == feoDOMAIN )
            {
                HRESULT hrPrompt = S_OK;
                hrPrompt = THR( HrShowInvalidDomainPrompt( hwndParentIn, pcwszDomainIn, hr, &fAcceptNonRFCDomain ) );
                if ( FAILED( hrPrompt ) )
                {
                    goto Error;
                }
                fTryAgain = fAcceptNonRFCDomain;
            }
            else // efeo is neither feoLABEL nor feoDOMAIN
            {
                THR( HrMessageBoxWithStatus(
                          hwndParentIn
                        , IDS_ERR_FQN_CREATE_TITLE
                        , IDS_ERR_FQN_CREATE_TEXT
                        , hr
                        , 0
                        , MB_OK | MB_ICONSTOP
                        , NULL
                        , pcwszLabelIn
                        , pcwszDomainIn
                        ) );
                fTryAgain = false;
            }
        }
        else // FQN creation succeeded, so trying again is not necessary.
        {
            fTryAgain = false;
        }
    } // Loop to attempt FQN creation.
    goto Cleanup;

Error:

    if ( pefeoOut != NULL )
    {
        *pefeoOut = efeo;
    }
    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** HrCreateFQN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrShowInvalidLabelPrompt
//
//  Description:
//      Show a message box to the user indicating a problem with the given
//      label; if the label contains non-RFC characters, allow the user to
//      choose to proceed with the label.
//
//  Arguments:
//      hwndParentIn
//          Parent window for the message box.
//
//      pcwszLabelIn
//          The label of interest.
//
//      hrErrorIn
//          The error that arose when validating the label.
//
//      pfAcceptedNonRFCOut
//          The user chose to accept non-RFC characters.
//
//  Return Values:
//      S_OK
//          The message box displayed successfully, and if the error was that
//          the label contained non-RFC characters, *pfAcceptedNonRFCOut
//          indicates whether the user chose to accept them.
//
//      Failure
//          The message box did not display successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrShowInvalidLabelPrompt(
      HWND      hwndParentIn
    , LPCWSTR   pcwszLabelIn
    , HRESULT   hrErrorIn
    , bool *    pfAcceptedNonRFCOut
    )
{
    TraceFunc1( "pcwszLabelIn = '%1!ws!", pcwszLabelIn );

    HRESULT     hr              = S_OK;
    int         iRet            = IDNO;
    UINT        idsStatus       = 0;
    UINT        idsSubStatus    = 0;
    UINT        idsMsgTitle     = IDS_ERR_VALIDATING_NAME_TITLE;
    UINT        idsMsgText      = IDS_ERR_VALIDATING_NAME_TEXT;
    UINT        nMsgBoxType     = MB_OK | MB_ICONSTOP;

    Assert( pcwszLabelIn != NULL );
    //  pfAcceptedNonRFCOut can be NULL, which means the caller doesn't expect
    //      or care about the non-RFC case.
    Assert( FAILED( hrErrorIn ) );

    if ( pfAcceptedNonRFCOut != NULL )
    {
        *pfAcceptedNonRFCOut = false;
    }

    // Format the error message string for the message box.
    switch ( hrErrorIn )
    {
        case HRESULT_FROM_WIN32( ERROR_NOT_FOUND ):
            idsStatus       = IDS_ERR_INVALID_DNS_NAME_TEXT;
            idsSubStatus    = IDS_ERR_DNS_HOSTNAME_LABEL_EMPTY_TEXT;
            break;

        case HRESULT_FROM_WIN32( ERROR_DS_NAME_TOO_LONG ):
            idsStatus       = IDS_ERR_DNS_HOSTNAME_LABEL_NO_NETBIOS;
            idsSubStatus    = IDS_ERR_DNS_HOSTNAME_LABEL_LONG_TEXT;
            break;

        case HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME ):
            idsStatus       = IDS_ERR_NON_RFC_NAME_STATUS;
            idsSubStatus    = IDS_ERR_NON_RFC_NAME_QUERY;
            idsMsgTitle     = IDS_ERR_NON_RFC_NAME_TITLE;
            idsMsgText      = IDS_ERR_NON_RFC_NAME_TEXT;
            nMsgBoxType     = MB_YESNO | MB_ICONQUESTION;
            break;

        case HRESULT_FROM_WIN32( DNS_ERROR_INVALID_NAME_CHAR ):
        default:
            idsStatus       = 0;
            idsSubStatus    = IDS_ERR_DNS_HOSTNAME_INVALID_CHAR;
            break;
    }// end switch ( hrErrorIn )

    // Display the error message box.
    if ( idsStatus == 0 )
    {
        hr = THR( HrMessageBoxWithStatus(
                              hwndParentIn
                            , idsMsgTitle
                            , idsMsgText
                            , hrErrorIn
                            , idsSubStatus
                            , nMsgBoxType
                            , &iRet
                            , pcwszLabelIn
                            ) );
    } // end if ( idsStatus == 0 )
    else // idsStatus != 0
    {
        hr = THR( HrMessageBoxWithStatusString(
                              hwndParentIn
                            , idsMsgTitle
                            , idsMsgText
                            , idsStatus
                            , idsSubStatus
                            , nMsgBoxType
                            , &iRet
                            , pcwszLabelIn
                            ) );
    } // end idsStatus != 0

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ( iRet == IDYES ) && ( pfAcceptedNonRFCOut != NULL ) )
    {
        *pfAcceptedNonRFCOut = true;
    }

Cleanup:

    HRETURN( hr );

} //*** HrShowInvalidLabelPrompt


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrShowInvalidDomainPrompt
//
//  Description:
//      Show a message box to the user indicating a problem with the given
//      domain; if the domain contains non-RFC characters, allow the user to
//      choose to proceed with the domain.
//
//  Arguments:
//      hwndParentIn
//          Parent window for the message box.
//
//      pcwszDomainIn
//          The domain of interest.
//
//      hrErrorIn
//          The error that arose when validating the domain.
//
//      pfAcceptedNonRFCOut
//          The user chose to accept non-RFC characters.
//
//  Return Values:
//      S_OK
//          The message box displayed successfully, and if the error was that
//          the domain contained non-RFC characters, *pfAcceptedNonRFCOut
//          indicates whether the user chose to accept them.
//
//      Failure
//          The message box did not display successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrShowInvalidDomainPrompt(
      HWND      hwndParentIn
    , LPCWSTR   pcwszDomainIn
    , HRESULT   hrErrorIn
    , bool *    pfAcceptedNonRFCOut
    )
{
    TraceFunc1( "pcwszDomainIn = '%1!ws!", pcwszDomainIn );

    HRESULT     hr              = S_OK;
    int         iRet            = IDNO;
    UINT        idsStatus       = 0;
    UINT        idsSubStatus    = 0;
    UINT        idsMsgTitle     = IDS_ERR_VALIDATING_NAME_TITLE;
    UINT        idsMsgText      = IDS_ERR_VALIDATING_NAME_TEXT;
    UINT        nMsgBoxType     = MB_OK | MB_ICONSTOP;

    Assert( pcwszDomainIn != NULL );
    Assert( pfAcceptedNonRFCOut != NULL );
    Assert( FAILED( hrErrorIn ) );

    *pfAcceptedNonRFCOut = false;

    // Format the error message string for the message box.
    switch ( hrErrorIn )
    {
        case HRESULT_FROM_WIN32( ERROR_INVALID_NAME ):
            idsStatus       = IDS_ERR_INVALID_DNS_NAME_TEXT;
            idsSubStatus    = IDS_ERR_FULL_DNS_NAME_INFO_TEXT;
            break;

        case HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME ):
            idsStatus       = IDS_ERR_NON_RFC_NAME_STATUS;
            idsSubStatus    = IDS_ERR_NON_RFC_NAME_QUERY;
            idsMsgTitle     = IDS_ERR_NON_RFC_NAME_TITLE;
            idsMsgText      = IDS_ERR_NON_RFC_NAME_TEXT;
            nMsgBoxType     = MB_YESNO | MB_ICONQUESTION;
            break;

        case HRESULT_FROM_WIN32( DNS_ERROR_NUMERIC_NAME ):
            idsStatus       = IDS_ERR_INVALID_DNS_NAME_TEXT;
            idsSubStatus    = IDS_ERR_FULL_DNS_NAME_NUMERIC;
            break;

        case HRESULT_FROM_WIN32( DNS_ERROR_INVALID_NAME_CHAR ):
        default:
            idsStatus       = 0;
            idsSubStatus    = IDS_ERR_DNS_NAME_INVALID_CHAR;
            break;
    }// end switch ( hrErrorIn )

    // Display the error message box.
    if ( idsStatus == 0 )
    {
        hr = THR( HrMessageBoxWithStatus(
                              hwndParentIn
                            , idsMsgTitle
                            , idsMsgText
                            , hrErrorIn
                            , idsSubStatus
                            , nMsgBoxType
                            , &iRet
                            , pcwszDomainIn
                            ) );
    } // end if ( idsStatus == 0 )
    else // idsStatus != 0
    {
        hr = THR( HrMessageBoxWithStatusString(
                              hwndParentIn
                            , idsMsgTitle
                            , idsMsgText
                            , idsStatus
                            , idsSubStatus
                            , nMsgBoxType
                            , &iRet
                            , pcwszDomainIn
                            ) );
    } // end idsStatus != 0

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( iRet == IDYES )
    {
        *pfAcceptedNonRFCOut = true;
    }

Cleanup:

    HRETURN( hr );

} //*** HrShowInvalidDomainPrompt


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMessageBoxWithStatus
//
//  Description:
//      Display an error message box.
//
//  Arguments:
//      hwndParentIn
//      idsTitleIn
//      idsOperationIn
//      hrStatusIn
//      idsSubStatusIn
//      uTypeIn
//      pidReturnOut        -- IDABORT on error or any return value from MessageBox()
//      ...
//
//  Return Values:
//      Any return values from the MessageBox() Win32 API.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrMessageBoxWithStatus(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , HRESULT   hrStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    )
{
    TraceFunc( "" );

    HRESULT     hr                  = S_OK;
    int         idReturn            = IDABORT; // Default in case of error.
    BSTR        bstrTitle           = NULL;
    BSTR        bstrOperation       = NULL;
    BSTR        bstrStatus          = NULL;
    BSTR        bstrSubStatus       = NULL;
    BSTR        bstrFullText        = NULL;
    va_list     valist;

    va_start( valist, pidReturnOut );

    // Load the title string if one is specified.
    if ( idsTitleIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsTitleIn, &bstrTitle ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Load the text string.
    hr = THR( HrFormatStringWithVAListIntoBSTR( g_hInstance, idsOperationIn, &bstrOperation, valist ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Format the status.
    hr = THR( HrFormatErrorIntoBSTR( hrStatusIn, &bstrStatus ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Load the substatus string if specified.
    if ( idsSubStatusIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsSubStatusIn, &bstrSubStatus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Format all the strings into a single string.
    if ( bstrSubStatus == NULL )
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            ) );
    }
    else
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!\n\n%3!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            , bstrSubStatus
                            ) );
    }
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Display the status.
    idReturn = MessageBox( hwndParentIn, bstrFullText, bstrTitle, uTypeIn );

Cleanup:
    TraceSysFreeString( bstrTitle );
    TraceSysFreeString( bstrOperation );
    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( bstrSubStatus );
    TraceSysFreeString( bstrFullText );
    va_end( valist );

    if ( pidReturnOut != NULL )
    {
        *pidReturnOut = idReturn;
    }

    HRETURN( hr );

} //*** HrMessageBoxWithStatus( hrStatusIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMessageBoxWithStatusString
//
//  Description:
//      Display an error message box.
//
//  Arguments:
//      hwndParentIn
//      idsTitleIn
//      idsOperationIn
//      idsStatusIn
//      idsSubStatusIn
//      uTypeIn
//      pidReturnOut        -- IDABORT on error or any return value from MessageBox()
//      ...
//
//  Return Values:
//      Any return values from the MessageBox() Win32 API.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrMessageBoxWithStatusString(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , UINT      idsStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    )
{
    TraceFunc( "" );

    HRESULT     hr                  = S_OK;
    int         idReturn            = IDABORT; // Default in case of error.
    BSTR        bstrTitle           = NULL;
    BSTR        bstrOperation       = NULL;
    BSTR        bstrStatus          = NULL;
    BSTR        bstrSubStatus       = NULL;
    BSTR        bstrFullText        = NULL;
    va_list     valist;

    va_start( valist, pidReturnOut );

    // Load the title string if one is specified.
    if ( idsTitleIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsTitleIn, &bstrTitle ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Load the text string.
    hr = THR( HrFormatStringWithVAListIntoBSTR( g_hInstance, idsOperationIn, &bstrOperation, valist ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Format the status.
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsStatusIn, &bstrStatus ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Load the substatus string if specified.
    if ( idsSubStatusIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsSubStatusIn, &bstrSubStatus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Format all the strings into a single string.
    if ( bstrSubStatus == NULL )
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            ) );
    }
    else
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!\n\n%3!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            , bstrSubStatus
                            ) );
    }
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Display the status.
    idReturn = MessageBox( hwndParentIn, bstrFullText, bstrTitle, uTypeIn );

Cleanup:
    TraceSysFreeString( bstrTitle );
    TraceSysFreeString( bstrOperation );
    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( bstrSubStatus );
    TraceSysFreeString( bstrFullText );
    va_end( valist );

    if ( pidReturnOut != NULL )
    {
        *pidReturnOut = idReturn;
    }

    HRETURN( hr );

} //*** HrMessageBoxWithStatusString( idsStatusTextIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrViewLogFile
//
//  Description:
//      View the log file.
//
//  Arguments:
//      hwndParentIn
//
//  Return Values:
//      S_OK    - Operation completed successfully
//      Other HRESULT values from ShellExecute().
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrViewLogFile(
    HWND hwndParentIn
    )
{
    TraceFunc( "" );

    static const WCHAR  s_szVerb[]          = L"open";
    static LPCTSTR s_pszLogFileName         = PszLogFilePath();

    HRESULT     hr = S_OK;
    DWORD       sc;
    DWORD       cch;
    DWORD       cchRet;
    LPWSTR      pszFile = NULL;

    //
    // Expand environment variables in the file to open.
    //

    // Get the size of the output buffer.
    cch = 0;
    cchRet = ExpandEnvironmentStrings( s_pszLogFileName, NULL, cch );
    if ( cchRet == 0 )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    } // if: error getting length of the expansion string

    // Allocate the output buffer.
    cch = cchRet;
    pszFile = new WCHAR[ cch ];
    if ( pszFile == NULL )
    {
        sc = TW32( ERROR_OUTOFMEMORY );
        goto Win32Error;
    }

    // Expand the string into the output buffer.
    cchRet = ExpandEnvironmentStrings( s_pszLogFileName, pszFile, cch );
    if ( cchRet == 0 )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }
    Assert( cchRet == cch );

    //
    // Execute the file.
    //

    sc = HandleToULong( ShellExecute(
                              hwndParentIn      // hwnd
                            , s_szVerb          // lpVerb
                            , pszFile           // lpFile
                            , NULL              // lpParameters
                            , NULL              // lpDirectory
                            , SW_SHOWNORMAL     // nShowCommand
                            ) );
    if ( sc < 32 )
    {
        // Values less than 32 indicate an error occurred.
        TW32( sc );
        goto Win32Error;
    } // if: error executing the file

    goto Cleanup;

Win32Error:

    THR( HrMessageBoxWithStatus(
                      hwndParentIn
                    , IDS_ERR_VIEW_LOG_TITLE
                    , IDS_ERR_VIEW_LOG_TEXT
                    , sc
                    , 0         // idsSubStatusIn
                    , ( MB_OK
                      | MB_ICONEXCLAMATION )
                    , NULL      // pidReturnOut
                    , s_pszLogFileName
                    ) );
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:

    delete [] pszFile;

    HRETURN( hr );

} //*** HrViewLogFile()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetTrimmedText
//
//  Description:
//      Extract a control's text, if any, with leading and trailing spaces
//      removed.
//
//  Arguments:
//      hwndControlIn -         The control.
//      pbstrTrimmedTextOut -   On success, the trimmed text.
//
//  Return Values:
//      S_OK
//          *pbstrTrimmedTextOut points to the trimmed text and the caller
//          must free it.
//
//      S_FALSE
//          Either the control is empty or it contains only spaces, and
//          *pbstrTrimmedTextOut is null.
//
//      E_POINTER
//          pbstrTrimmedTextOut was null.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory for *pbstrTrimmedTextOut.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetTrimmedText(
      HWND  hwndControlIn
    , BSTR* pbstrTrimmedTextOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       cchControlText = 0;
    LPWSTR      wszUntrimmedText = NULL;

    Assert( pbstrTrimmedTextOut != NULL );
    if ( pbstrTrimmedTextOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrTrimmedTextOut = NULL;

    cchControlText = GetWindowTextLength( hwndControlIn );
    if ( cchControlText == 0 )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    wszUntrimmedText = new WCHAR[ cchControlText + 1 ];
    if ( wszUntrimmedText == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    cchControlText = GetWindowText( hwndControlIn, wszUntrimmedText, cchControlText + 1 );
    if ( cchControlText == 0 )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    {
        DWORD idxNonBlankStart = 0;
        DWORD idxNonBlankEnd = cchControlText - 1;
        while ( ( idxNonBlankStart < cchControlText ) && ( wszUntrimmedText[ idxNonBlankStart ] == L' ' ) )
        {
            idxNonBlankStart += 1;
        }

        while ( ( idxNonBlankEnd > idxNonBlankStart ) && ( wszUntrimmedText[ idxNonBlankEnd ] == L' ' ) )
        {
            idxNonBlankEnd -= 1;
        }

        if ( idxNonBlankStart <= idxNonBlankEnd )
        {
            DWORD cchTrimmedText = idxNonBlankEnd - idxNonBlankStart + 1;
            *pbstrTrimmedTextOut = TraceSysAllocStringLen( wszUntrimmedText + idxNonBlankStart, cchTrimmedText );
            if ( *pbstrTrimmedTextOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }
        }
        else
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

Cleanup:

    if ( wszUntrimmedText != NULL )
    {
        delete [] wszUntrimmedText;
    }

    HRETURN( hr );
} //*** HrGetTrimmedText


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetPrincipalName
//
//  Description:
//      Form a user-domain pair from a given pair of controls, ignoring the
//      second control and using the domain from the first if the first has
//      a string in the user@domain format.
//
//  Arguments:
//      hwndUserNameControlIn
//          The control for either the user name or the user@domain pair.
//
//      hwndDomainControlIn
//          The control for the domain name in the non-user@domain case.
//
//      pbstrUserNameOut
//          On success, the user name.
//
//      pbstrDomainNameOut
//          On success, the domain name.
//
//      pfUserIsDNSNameOut
//          Tells the caller whether hwndUserNameControlIn has text in the
//          user@domain format.  Can be null if the caller doesn't care.
//
//  Return Values:
//      S_OK
//          *pbstrUserNameOut and *pbstrDomainNameOut point to the
//          corresponding names, and the caller must free them.
//
//      S_FALSE
//          Either the user control is empty, or it does not have a user@domain
//          pair and the domain control is empty.
//          The two BSTR out parameters are null.
//
//      E_POINTER
//          pbstrUserNameOut or pbstrDomainNameOut was null.
//
//      E_OUTOFMEMORY
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetPrincipalName(
      HWND  hwndUserNameControlIn
    , HWND  hwndDomainControlIn
    , BSTR* pbstrUserNameOut
    , BSTR* pbstrDomainNameOut
    , BOOL* pfUserIsDNSNameOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    BSTR        bstrFullUserText = NULL;
    BSTR        bstrUserName = NULL;
    BSTR        bstrDomainName = NULL;
    BOOL        fUserIsDNSName = FALSE;
    LPWSTR      wszDNSDelimiter = NULL;

    Assert( pbstrUserNameOut != NULL );
    if ( pbstrUserNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrUserNameOut = NULL;

    Assert( pbstrDomainNameOut != NULL );
    if ( pbstrDomainNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrDomainNameOut = NULL;

    //  pfUserIsDNSNameOut can be null, which means the caller doesn't care.

    //  Get text from user control.
    hr = STHR( HrGetTrimmedText( hwndUserNameControlIn, &bstrFullUserText ) );
    if ( hr != S_OK )
    {
        goto Cleanup;
    }

    //  If the user text has an @ sign,
    wszDNSDelimiter = wcschr( bstrFullUserText, L'@' );
    if ( wszDNSDelimiter != NULL )
    {
        //  Split user text into user name and domain name.
        DWORD  cchUserName = (DWORD)( wszDNSDelimiter - bstrFullUserText );
        DWORD  cchDomainName = SysStringLen( bstrFullUserText ) - cchUserName - 1; // -1 to account for the @ sign.
        LPWSTR wszDomainStart = wszDNSDelimiter + 1; // +1 to skip the @ sign.
        fUserIsDNSName = TRUE;

        //  If either user or domain are empty, bail out.
        if ( ( cchUserName == 0 ) || ( cchDomainName == 0 ) )
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        bstrUserName = TraceSysAllocStringLen( bstrFullUserText, cchUserName );
        if ( bstrUserName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        bstrDomainName = TraceSysAllocString( wszDomainStart );
        if ( bstrDomainName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    } // if: the user text has an @ sign.
    else
    {
        //  Set user name to full user control text.
        bstrUserName = bstrFullUserText;
        bstrFullUserText = NULL;

        //  Get domain name from domain control.
        hr = STHR( HrGetTrimmedText( hwndDomainControlIn, &bstrDomainName ) );
        if ( hr != S_OK )
        {
            goto Cleanup;
        }
    }

    //  Transfer ownership of the strings to the caller.
    *pbstrUserNameOut = bstrUserName;
    bstrUserName = NULL;

    *pbstrDomainNameOut = bstrDomainName;
    bstrDomainName = NULL;

Cleanup:

    if ( pfUserIsDNSNameOut != NULL )
    {
        *pfUserIsDNSNameOut = fUserIsDNSName;
    }

    TraceSysFreeString( bstrFullUserText );
    TraceSysFreeString( bstrUserName );
    TraceSysFreeString( bstrDomainName );

    HRETURN( hr );
} //*** HrGetPrincipalName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\wizardutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardUtils.h
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef HRESULT ( *PFN_LABEL_VALIDATOR )( PCWSTR, bool );

HRESULT
HrCreateFQN(
      HWND                  hwndParentIn
    , LPCWSTR               pcwszLabelIn
    , LPCWSTR               pcwszDomainIn
    , PFN_LABEL_VALIDATOR   pfnLabelValidatorIn           
    , BSTR *                pbstrFQNOut
    , EFQNErrorOrigin *     pefeoOut
    );
    
HRESULT
HrShowInvalidLabelPrompt(
      HWND      hwndParentIn
    , LPCWSTR   pcwszLabelIn
    , HRESULT   hrErrorIn
    , bool *    pfAcceptedNonRFCOut = NULL
    );    

HRESULT
HrShowInvalidDomainPrompt(
      HWND      hwndParentIn
    , LPCWSTR   pcwszDomainIn
    , HRESULT   hrErrorIn
    , bool *    pfAcceptedNonRFCOut
    );    

HRESULT
HrMessageBoxWithStatus(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , HRESULT   hrStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    );

HRESULT
HrMessageBoxWithStatusString(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , UINT      idsStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    );

HRESULT
HrViewLogFile(
    HWND hwndParentIn
    );

HRESULT
HrGetTrimmedText(
      HWND  hwndControlIn
    , BSTR* pbstrTrimmedTextOut
    );

HRESULT
HrGetPrincipalName(
      HWND  hwndUserNameControlIn
    , HWND  hwndDomainControlIn
    , BSTR* pbstrUserNameOut
    , BSTR* pbstrDomainNameOut
    , BOOL* pfUserIsDNSNameOut = NULL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\wizard\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Maintained By:
//      Galen Barbee    (GalenB)    30-Nov-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <initguid.h>
#include <guids.h>

DEFINE_MODULE("WizardTest")

#define CCS_LIB         L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll"

// Typedefs
typedef HRESULT (*PDLLREGISTERSERVER)( void );

HINSTANCE               g_hInstance = NULL;
LONG                    g_cObjects  = 0;

BOOL    g_fCreate   = FALSE;

LPCWSTR g_pszCluster = NULL;
LPCWSTR g_pszDomain = NULL;
LPCWSTR g_pszCSUser = NULL;
LPCWSTR g_pszCSPassword = NULL;
LPCWSTR g_pszCSDomain = NULL;
LPCWSTR g_pszNode = NULL;
void *  g_GlobalMemoryList = NULL;    // Global memory tracking list

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations:
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrRegisterTheDll( void );

HRESULT
HrParseCommandLine(
    int     argc,
    WCHAR * argv[]
    );

void
Usage( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterTheDll( void )
//
//  Description:
//      Register the DLL.
//
//  Arguments:
//      None.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterTheDll( void )
{
    HRESULT             hr;
    PDLLREGISTERSERVER  pDllRegisterServer;
    HMODULE             hLib = NULL;

    TraceFunc( "" );

    //  Make sure the DLL is properly registered.
    hLib = LoadLibrary( CCS_LIB );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer =
        reinterpret_cast< PDLLREGISTERSERVER >(
            GetProcAddress( hLib, "DllRegisterServer" )
            );

    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

} //*** HrRegisterTheDll()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrParseCommandLine(
//      int     argc,
//      WCHAR * argv[]
//      )
//
//  Description:
//      Parse the command line.
//
//  Arguments:
//      None.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrParseCommandLine(
    int     argc,
    WCHAR * argv[]
    )
{
    HRESULT     hr = NOERROR;
    int         idx;
    WCHAR       wch;
    WCHAR *     pwsz;
    WCHAR       szMsg[ 2048 ];
    int         cchMsg = ARRAYSIZE( szMsg );

    for ( idx = 1 ; idx < argc ; idx++ )
    {
        wch = *argv[ idx ];
        pwsz = &argv[ idx ][ 1 ];
        if ( wch == L'/' || wch == L'-' )
        {
            if ( ClRtlStrICmp( pwsz, L"Create" ) == 0 )
            {
                g_fCreate = TRUE;
                continue;
            }
            else if ( ClRtlStrICmp( pwsz, L"Cluster" ) == 0 )
            {
                g_pszCluster = argv[ idx + 1 ];
                idx += 2;
            } // if: create switch
            else if ( ClRtlStrICmp( pwsz, L"CSUser" ) == 0 )
            {
                g_pszCSUser = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( ClRtlStrICmp( pwsz, L"CSPassword" ) == 0 )
            {
                g_pszCSPassword = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( ClRtlStrICmp( pwsz, L"CSDomain" ) == 0 )
            {
                g_pszCSDomain = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( ClRtlStrICmp( pwsz, L"?" ) == 0 )
            {
                Usage();
                goto Cleanup;
            }
        } // if: '/' or '-'
        else
        {
            wnsprintf( szMsg, cchMsg, L"Unknown command line option '%ls'.", argv[ idx ] );
            szMsg[ ARRAYSIZE( szMsg ) - 1 ] = L'\0';
            MessageBox( NULL, szMsg, __MODULE__, MB_OK );
            hr = E_INVALIDARG;
            goto Cleanup;

        } // else: not a switch

    } // for: each character in the command line

Cleanup:
    return hr;

} //*** HrParseCommandLine()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  Usage( void )
//
//  Description:
//      Show usage information.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
Usage( void )
{
    WCHAR   szMsg[ 2048 ] =
        L"WizardTest [/Create ]\n"
        L"           [/Cluster name]\n"
        L"           [/CSUser user]\n"
        L"           [/CSPassword password]\n"
        L"           [/CSDomain domain]\n";

    MessageBoxW( NULL, szMsg, __MODULE__, MB_OK );

} //*** Usage()

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  wmain( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      argc    -- Count of arguments on the command line.
//      argv    -- Argument string array.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
wmain( int argc, WCHAR * argv[] )
{
    HRESULT             hr;
    BOOL                fDone;
    BOOL                fRet;
    IClusCfgWizard *    pClusCfgWizard = NULL;
    BSTR                bstrTmp = NULL;

    TraceInitializeProcess( NULL );

#if 0
    // Register the DLL
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    // Parse the command line.
    hr = THR( HrParseCommandLine( argc, argv ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Start up the wizard
    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Create instance of the wizard
    hr = THR( CoCreateInstance( CLSID_ClusCfgWizard,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IClusCfgWizard, &pClusCfgWizard )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //  Create empty buffer so SysReAllocString doesn't scream at us.
    bstrTmp = TraceSysAllocString( L" " );
    if ( bstrTmp == NULL )
        goto OutOfMemory;

    if ( g_pszCluster != NULL )
    {
        DebugMsg( "Entering %s for cluster name.", g_pszCluster );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCluster );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ClusterName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSUser != NULL )
    {
        DebugMsg( "Entering %s for cluster account username.", g_pszCSUser );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSUser );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountUserName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSPassword != NULL )
    {
        DebugMsg( "Entering %s for cluster account password.", g_pszCSPassword );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSPassword );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountPassword( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSDomain != NULL )
    {
        DebugMsg( "Entering %s for cluster account domain.", g_pszCSDomain );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSDomain );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountDomainName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_fCreate )
    {
        DebugMsg( "Creating cluster..." );

        hr = THR( pClusCfgWizard->CreateCluster( NULL, &fDone ) );
        if ( FAILED( hr ) )
            goto Cleanup;

    } // if: creating a new cluster
    else
    {
        DebugMsg( "Add to cluster..." );

        hr = THR( pClusCfgWizard->AddClusterNodes( NULL, &fDone ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    // check returned indicator
    DebugMsg( "Return status: %s", BOOLTOSTRING( fDone ) );

Cleanup:
    if ( bstrTmp != NULL )
    {
        TraceSysFreeString( bstrTmp );
    }

    if ( pClusCfgWizard != NULL )
    {
        pClusCfgWizard->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    ExitProcess( 0 );

OutOfMemory:
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} //*** main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\cluscompresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusCompResources.h
//
//  Description:
//      Contains the definition of the string ids used by this DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 25-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define ID_COMP_START    0

#define IDS_ERROR_UPGRADE_OTHER_NODES         ( ID_COMP_START + 0 )
#define IDS_ERROR_TCB_CHECK_FAILED            ( ID_COMP_START + 1 )
#define IDS_ERROR_TCB_PRIVILEGE_NEEDED        ( ID_COMP_START + 2 )

// The ending ID for these strings.
#define ID_COMP_END      1999
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//
//      Vij Vasu (VVasu) 29-AUG-2000
//          Modified this file to remove dependency on Shell API since they
//          may not be present on the OS that this DLL runs in.
//          Removed unnecessary functions for the same reason.
//
//      Geoffrey Pease (GPease) 22-NOV-1999
//          Original version.
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// For tracing
DEFINE_MODULE("CLUSCOMP")

#include <DllSrc.cpp>

#if 0
//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

#if !defined(NO_DLL_MAIN) || defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
// BOOL
// WINAPI
// DLLMain(
//      HANDLE  hInstIn,
//      ULONG   ulReasonIn,
//      LPVOID  lpReservedIn
//      )
//
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
DllMain(
    HANDLE  hInstIn,
    ULONG   ulReasonIn,
    LPVOID  // lpReservedIn
    )
{
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
        case DLL_PROCESS_ATTACH:
        {
            TraceInitializeProcess( TRUE );
            TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_PROCESS_ATTACH - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( TRUE );
#endif // DEBUG
            g_hInstance = (HINSTANCE) hInstIn;


            GetModuleFileNameW( g_hInstance, g_szDllFilename, MAX_PATH );
            break;
        }

        case DLL_PROCESS_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]",
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceTerminateMemoryList( g_GlobalMemoryList );
            TraceTerminateProcess();
            break;
        }

        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
#if defined( DEBUG )
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"The thread 0x%x has started.",
                          GetCurrentThreadId( ) );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]",
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }

        case DLL_THREAD_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]",
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceThreadRundown( );;
            break;
        }

        default:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]",
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }
    }

    return TRUE;

#else // !NO_THREAD_OPTIMIZATIONS
    BOOL fResult;
    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );
#if defined(DEBUG)
    TraceInitializeProcess( TRUE );
#endif // DEBUG
    g_hInstance = (HINSTANCE) hInstIn;
    GetModuleFileNameW( g_hInstance, g_szDllFilename, MAX_PATH );
    fResult = DisableThreadLibraryCalls( g_hInstance );
    AssertMsg( fResult, "*ERROR* DisableThreadLibraryCalls( ) failed." );
    return TRUE;
#endif // NO_THREAD_OPTIMIZATIONS

} //*** DllMain()
#endif // !defined(NO_DLL_MAIN) && !defined(DEBUG)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\dll.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Dll.h
//
//  Description:
//      DLL globals definitions and macros.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern TCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\cluscomp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusComp.cpp
//
//  Header File:
//      There is no header file for this source file.
//
//  Description:
//      This file implements that function that is called by WinNT32.exe before
//      an upgrade to ensure that no incompatibilities occur as a result of the
//      upgrade. For example, in a cluster of two NT4 nodes, one node cannot
//      be upgraded to Whistler while the other is still at NT4. The user is
//      warned about such problems by this function.
//
//      NOTE: This function is called by WinNT32.exe on the OS *before* an
//      upgrade. If OS version X is being upgraded to OS version X+1, then
//      the X+1 verion of this DLL is loaded on OS version X. To make sure
//      that this DLL can function properly in an downlevel OS, it is linked
//      against only the indispensible libraries.
//
//  Maintained By:
//      David Potter    (DavidP)    24-MAY-2001
//      Vij Vasu        (Vvasu)     25-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "Pch.h"
#include "Common.h"

// For LsaClose, LSA_HANDLE, etc.
#include <ntsecapi.h>

// For the compatibility check function and types
#include <comp.h>

// For the cluster API
#include <clusapi.h>

// For the names of several cluster service related registry keys and values
#include <clusudef.h>


//////////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////////

DWORD ScIsClusterServiceRegistered( bool & rfIsRegisteredOut );
DWORD ScLoadString( UINT nStringIdIn, WCHAR *& rpszDestOut );
DWORD ScWriteOSVersionInfo( const OSVERSIONINFO & rcosviOSVersionInfoIn );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  InitLsaString
//
//  Description:
//      Initialize a LSA_UNICODE_STRING structure
//
//  Arguments:
//      pszSourceIn
//          The string used to initialize the unicode string structure.
//
//      plusUnicodeStringOut,
//          The output unicode string structure.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
      LPWSTR pszSourceIn
    , PLSA_UNICODE_STRING plusUnicodeStringOut
    )
{
    TraceFunc( "" );

    if ( pszSourceIn == NULL )
    {
        plusUnicodeStringOut->Buffer = NULL;
        plusUnicodeStringOut->Length = 0;
        plusUnicodeStringOut->MaximumLength = 0;

    } // if: input string is NULL
    else
    {
        plusUnicodeStringOut->Buffer = pszSourceIn;
        plusUnicodeStringOut->Length = static_cast< USHORT >( wcslen( pszSourceIn ) * sizeof( *pszSourceIn ) );
        plusUnicodeStringOut->MaximumLength = static_cast< USHORT >( plusUnicodeStringOut->Length + sizeof( *pszSourceIn ) );

    } // else: input string is not NULL

    TraceFuncExit();

} //*** InitLsaString

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterCheckForTCBPrivilege
//
//  Description:
//      Determine if the cluster service account has TCB
//      privilege granted. We assume all other privileges
//      are intact. "Borrowed" from base cluster code in cluscfg
//
//  Arguments:
//      bool & rfTCBIsNotGranted
//          True if TCB is not granted to the CSA. Only valid if
//          return value is ERROR_SUCCESS.
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//      
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
ClusterCheckForTCBPrivilege( bool & rfTCBIsNotGranted )
{
    TraceFunc( "" );

    // typedefs for Smart resource handles/pointers
    //
    typedef CSmartResource<
        CHandleTrait<
              PLSA_UNICODE_STRING
            , NTSTATUS
            , reinterpret_cast< NTSTATUS (*)( PLSA_UNICODE_STRING ) >( LsaFreeMemory )
            , reinterpret_cast< PLSA_UNICODE_STRING >( NULL )
            >
        >
        SmartLsaUnicodeStringPtr;

    typedef CSmartResource<
        CHandleTrait<
              LSA_HANDLE
            , NTSTATUS
            , LsaClose
            >
        >
        SmartLSAHandle;

    typedef CSmartGenericPtr< CPtrTrait< SID > >  SmartSIDPtr;

    typedef CSmartResource< CHandleTrait< SC_HANDLE, BOOL, CloseServiceHandle > > SmartServiceHandle;

    typedef CSmartGenericPtr< CArrayPtrTrait< QUERY_SERVICE_CONFIG > > SmartServiceConfig;

    // automatic vars
    //
    NTSTATUS                ntStatus;
    PLSA_UNICODE_STRING     plusAccountRights = NULL;
    ULONG                   clusOriginalRightsCount = 0;
    ULONG                   ulIndex;
    DWORD                   dwReturnValue = ERROR_SUCCESS;

    // Initial size of the QUERY_SERVICE_CONFIG buffer. If not large enough, we'll loop through after
    // capturing the correct size.
    DWORD                   cbServiceConfigBufSize = 512;
    DWORD                   cbRequiredSize = 0;

    DWORD                   cbSidSize = 0;
    DWORD                   cchDomainSize = 0;
    SID_NAME_USE            snuSidNameUse;

    // smart resources: we need to declare them at the beginning since we use
    // a goto as the clean up mechanism
    //
    SmartLSAHandle              slsahPolicyHandle;
    SmartServiceHandle          shServiceMgr;
    SmartServiceHandle          shService;
    SmartServiceConfig          spscServiceConfig;
    SmartSIDPtr                 sspClusterAccountSid;
    SmartSz                     sszDomainName;
    SmartLsaUnicodeStringPtr    splusOriginalRights;

    // initialize return value to reflect the default and have the code prove
    // that it is granted.
    rfTCBIsNotGranted = true;

    // Open a handle to the LSA policy so we can eventually enumerate the
    // account rights for the cluster service account
    //
    {
        LSA_OBJECT_ATTRIBUTES       loaObjectAttributes;
        LSA_HANDLE                  hPolicyHandle;

        LogMsg( "Getting a handle to the Local LSA Policy." );

        ZeroMemory( &loaObjectAttributes, sizeof( loaObjectAttributes ) );

        ntStatus = THR( LsaOpenPolicy(
                              NULL                                  // System name
                            , &loaObjectAttributes                  // Object attributes.
                            , POLICY_ALL_ACCESS                     // Desired Access
                            , &hPolicyHandle                        // Policy handle
                            )
                      );

        if ( ntStatus != STATUS_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to open the LSA Policy.", ntStatus );

            dwReturnValue = ntStatus;
            goto Cleanup;
        } // if LsaOpenPolicy failed.

        // Store the opened handle in smart variable.
        slsahPolicyHandle.Assign( hPolicyHandle );
    }

    LogMsg( "Getting the Cluster Service Account from SCM." );

    // Connect to the Service Control Manager
    shServiceMgr.Assign( OpenSCManager( NULL, NULL, GENERIC_READ ) );

    // Was the service control manager database opened successfully?
    if ( shServiceMgr.HHandle() == NULL )
    {
        dwReturnValue = TW32( GetLastError() );
        LogMsg( "Error %#08x occurred trying to open a connection to the local service control manager.", dwReturnValue );
        goto Cleanup;
    } // if: opening the SCM was unsuccessful


    // Open a handle to the Cluster Service.
    shService.Assign( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );

    // Was the handle to the service opened?
    if ( shService.HHandle() == NULL )
    {
        dwReturnValue = TW32( GetLastError() );
        if ( dwReturnValue == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            // cluster service not found
            LogMsg( "Cluster Service not registered on this node." );
            rfTCBIsNotGranted = false;
            dwReturnValue = ERROR_SUCCESS;
        } // if: the cluster service wasn't found
        else
        {
            LogMsg( "Error %#08x occurred trying to open a handle to the cluster service.", dwReturnValue );
        } // else: couldn't determine if the cluster service was installed

        goto Cleanup;
    } // if: the handle could not be opened

    // Allocate memory for the service configuration info buffer. The memory is automatically freed when the
    // object is destroyed.

    for ( ; ; ) { // ever
        spscServiceConfig.Assign( reinterpret_cast< QUERY_SERVICE_CONFIG * >( new BYTE[ cbServiceConfigBufSize ] ) );

        // Did the memory allocation succeed
        if ( spscServiceConfig.FIsEmpty() )
        {
            dwReturnValue = TW32( ERROR_OUTOFMEMORY );
            LogMsg( "Error: There was not enough memory to get the cluster service configuration information." );
            break;
        } // if: memory allocation failed

        // Get the configuration information.
        if ( QueryServiceConfig(
                   shService.HHandle()
                 , spscServiceConfig.PMem()
                 , cbServiceConfigBufSize
                 , &cbRequiredSize
                 )
                == FALSE
           )
        {
            dwReturnValue = GetLastError();
            if ( dwReturnValue != ERROR_INSUFFICIENT_BUFFER )
            {
                TW32( dwReturnValue );
                LogMsg( "Error %#08x occurred trying to get the cluster service configuration information.", dwReturnValue );
                break;
            } // if: something has really gone wrong
            else
            {
                // We need to allocate more memory - try again
                dwReturnValue = ERROR_SUCCESS;
                cbServiceConfigBufSize = cbRequiredSize;
            }
        } // if: QueryServiceConfig() failed
        else
        {
            break;
        }
    } // forever

    if ( dwReturnValue != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Lookup the cluster service account SID.
    LogMsg( "Getting the SID of the Cluster Service Account." );

    // Find out how much space is required by the SID.
    if ( LookupAccountName(
              NULL
            , spscServiceConfig->lpServiceStartName
            , NULL
            , &cbSidSize
            , NULL
            , &cchDomainSize
            , &snuSidNameUse
            )
         ==  FALSE
       )
    {
        dwReturnValue = GetLastError();
        if ( dwReturnValue != ERROR_INSUFFICIENT_BUFFER )
        {
            TW32( dwReturnValue );
            LogMsg( "LookupAccountName() failed with error %#08x while querying for required buffer size.", dwReturnValue );
            goto Cleanup;
        } // if: something else has gone wrong.
        else
        {
            // This is expected.
            dwReturnValue = ERROR_SUCCESS;
        } // if: ERROR_INSUFFICIENT_BUFFER was returned.
    } // if: LookupAccountName failed

    // Allocate memory for the new SID and the domain name.
    sspClusterAccountSid.Assign( reinterpret_cast< SID * >( new BYTE[ cbSidSize ] ) );
    sszDomainName.Assign( new WCHAR[ cchDomainSize ] );

    if ( sspClusterAccountSid.FIsEmpty() || sszDomainName.FIsEmpty() )
    {
        dwReturnValue = TW32( ERROR_OUTOFMEMORY );
        goto Cleanup;
    } // if: there wasn't enough memory for this SID.

    // Fill in the SID
    if ( LookupAccountName(
              NULL
            , spscServiceConfig->lpServiceStartName
            , sspClusterAccountSid.PMem()
            , &cbSidSize
            , sszDomainName.PMem()
            , &cchDomainSize
            , &snuSidNameUse
            )
         ==  FALSE
       )
    {
        dwReturnValue = TW32( GetLastError() );
        LogMsg( "LookupAccountName() failed with error %#08x while attempting to get the cluster account SID.", dwReturnValue );
        goto Cleanup;
    } // if: LookupAccountName failed

    LogMsg( "Determining the rights that need to be granted to the cluster service account." );

    // Get the list of rights already granted to the cluster service account.
    ntStatus = THR( LsaEnumerateAccountRights(
                          slsahPolicyHandle
                        , sspClusterAccountSid.PMem()
                        , &plusAccountRights
                        , &clusOriginalRightsCount
                        ));

    if ( ntStatus != STATUS_SUCCESS )
    {
        //
        // LSA returns this error code if the account has no rights granted or denied to it
        // locally. Post the warning since this is dreadfully wrong.
        //
        if ( ntStatus == STATUS_OBJECT_NAME_NOT_FOUND  )
        {
            LogMsg( "The account has no locally assigned rights." );
            dwReturnValue = ERROR_SUCCESS;
        } // if: the account does not have any rights assigned locally to it.
        else
        {
            dwReturnValue = THR( ntStatus );
            LogMsg( "Error %#08x occurred trying to enumerate the cluster service account rights.", ntStatus );
        } // else: something went wrong.

        goto Cleanup;
    } // if: LsaEnumerateAccountRights() failed

    // Store the account rights just enumerated in a smart pointer for automatic release.
    splusOriginalRights.Assign( plusAccountRights );

    // Determine if TCB is present
    for ( ulIndex = 0; ulIndex < clusOriginalRightsCount; ++ulIndex )
    {
        const WCHAR *   pchGrantedRight         = plusAccountRights[ ulIndex ].Buffer;
        USHORT          usCharCount             = plusAccountRights[ ulIndex ].Length / sizeof( WCHAR );
        size_t          cchTCBNameLength        = wcslen( SE_TCB_NAME );

        if ( ClRtlStrNICmp( SE_TCB_NAME, pchGrantedRight, min( cchTCBNameLength, usCharCount )) == 0 )
        {
            rfTCBIsNotGranted = false;
            break;
        }

    } // for: loop through the list of rights that we want to grant the account

Cleanup:
    LogMsg( "Return Value is %#08x. rfTCBIsNotGranted is %d", dwReturnValue, rfTCBIsNotGranted );

    RETURN( dwReturnValue );

} //*** ClusterCheckForTCBPrivilege

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterUpgradeCompatibilityCheck
//
//  Description:
//      This function is called by WinNT32.exe before an upgrade to ensure that
//      no incompatibilities occur as a result of the upgrade. For example,
//      in a cluster of two NT4 nodes, one node cannot be upgraded to Whistler
//      while the other is still at NT4.
//
//  Arguments:
//      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
//          Points to the callback function used to supply compatibility
//          information to WinNT32.exe
//
//      LPVOID pvContextIn
//          Pointer to the context buffer supplied by WinNT32.exe
//
//  Return Values:
//      TRUE if there were no errors or no compatibility problems.
//      FALSE otherwise.
//
//--
//////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL
ClusterUpgradeCompatibilityCheck(
      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
    , LPVOID pvContextIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering function " __FUNCTION__ "()" );

    BOOL    fCompatCallbackReturnValue = TRUE;
    BOOL    fTCBCheckFailed = FALSE;
    bool    fNT4WarningRequired = true;
    bool    fTCBWarningRequired = false;
    DWORD   dwError = ERROR_SUCCESS;

    do
    {
        typedef CSmartResource< CHandleTrait< HCLUSTER, BOOL, CloseCluster > > SmartClusterHandle;

        OSVERSIONINFO       osviOSVersionInfo;
        SmartClusterHandle  schClusterHandle;
        DWORD               cchBufferSize = 256;

        osviOSVersionInfo.dwOSVersionInfoSize = sizeof( osviOSVersionInfo );

        //
        // First of all, get and store the OS version info into the registry.
        //

        // Cannot call VerifyVerionInfo as this requires Win2k.
        if ( GetVersionEx( &osviOSVersionInfo ) == FALSE )
        {
            // We could not get OS version info.
            // Show the warning, just in case.
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to get the OS version info.", dwError );
            break;
        } // if: GetVersionEx() failed

        // Write the OS version info to the registry. This data will be used later by ClusOCM
        // to figure out which OS version we are upgrading from.
        dwError = TW32( ScWriteOSVersionInfo( osviOSVersionInfo ) );
        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying to store the OS version info. This is not a fatal error.", dwError );

            // This is not a fatal error. So reset the error code.
            dwError = ERROR_SUCCESS;
        } // if: there was an error writing the OS version info
        else
        {
            TraceFlow( "The OS version info was successfully written to the registry." );
        } // else: the OS version info was successfully written to the registry


        // Check if the cluster service is registered.
        dwError = TW32( ScIsClusterServiceRegistered( fNT4WarningRequired ) );
        if ( dwError != ERROR_SUCCESS )
        {
            // We could not get the state of the cluster service
            // Show the warning, just in case.
            LogMsg( "Error %#x occurred trying to check if the cluster service is registered.", dwError );
            break;
        } // if: ScIsClusterServiceRegistered() returned an error

        if ( !fNT4WarningRequired )
        {
            // If the cluster service was not registered, no warning is needed.
            LogMsg( "The cluster service is not registered." );
            break;
        } // if: no warning is required

        LogMsg( "The cluster service is registered. Checking the node versions." );

        // Check if this is an NT4 node
        if ( osviOSVersionInfo.dwMajorVersion < 5 )
        {
            LogMsg( "This is a Windows NT 4.0 node." );
            fNT4WarningRequired = true;
            break;
        } // if: this is an NT4 node

        TraceFlow( "This is not a Windows NT 4.0 node." );

        // Check if the OS version is Whistler or if it is a non-NT OS
        if (    ( osviOSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT )
             || (    ( osviOSVersionInfo.dwMajorVersion >= 5 )
                  && ( osviOSVersionInfo.dwMinorVersion >= 1 )
                )
           )
        {
            // If the OS not of the NT family or if the OS version of this
            // node is Whistler or greater, no warning is required.
            LogMsg(
                  "The version of the OS on this node is %d.%d, which is Windows Server 2003 or later (or is not running NT)."
                , osviOSVersionInfo.dwMajorVersion
                , osviOSVersionInfo.dwMinorVersion
                );
            LogMsg( "No Windows NT 4.0 nodes can exist in this cluster." );
            fNT4WarningRequired = false;
            break;
        } // if: the OS is not NT or if it is Win2k or greater

        TraceFlow( "This is not a Windows Server 2003 node - this must to be a Windows 2000 node." );
        TraceFlow( "Trying to check if there are any Windows NT 4.0 nodes in the cluster." );

        //
        // Get the cluster version information
        //

        // Open a handle to the local cluster
        schClusterHandle.Assign( OpenCluster( NULL ) );
        if ( schClusterHandle.HHandle() == NULL )
        {
            // Show the warning, just to be safe.
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to get information about the cluster.", dwError );
            break;
        } // if: we could not get the cluster handle

        TraceFlow( "OpenCluster() was successful." );

        // Get the cluster version info
        for ( ;; ) // forever
        {
            // Allocate the buffer - this memory is automatically freed when this object
            // goes out of scope ( or during the next iteration ).
            SmartSz             sszClusterName( new WCHAR[ cchBufferSize ] );

            CLUSTERVERSIONINFO  cviClusterVersionInfo;
            
            if ( sszClusterName.FIsEmpty() )
            {
                dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
                LogMsg( "Error %#x occurred while allocating a buffer for the cluster name.", dwError );
                break;
            } // if: memory allocation failed

            TraceFlow( "Memory for the cluster name has been allocated." );

            cviClusterVersionInfo.dwVersionInfoSize = sizeof( cviClusterVersionInfo );
            dwError = GetClusterInformation( 
                  schClusterHandle.HHandle()
                , sszClusterName.PMem()
                , &cchBufferSize
                , &cviClusterVersionInfo
                );

            if ( dwError == ERROR_SUCCESS )
            {
                // A warning is required if this node version is less than Win2k or
                // if there is a node in the cluster whose version is less than Win2k
                // NOTE: cviClusterVersionInfo.MajorVersion is the OS version
                //       while cviClusterVersionInfo.dwClusterHighestVersion is the cluster version.
                fNT4WarningRequired = 
                    (    ( cviClusterVersionInfo.MajorVersion < 5 )
                      || ( CLUSTER_GET_MAJOR_VERSION( cviClusterVersionInfo.dwClusterHighestVersion ) < NT5_MAJOR_VERSION )
                    );

                if ( fNT4WarningRequired )
                {
                    LogMsg( "There is at least one node in the cluster whose OS version is earlier than Windows 2000." );
                } // if: a warning will be shown
                else
                {
                    LogMsg( "The OS versions of all the nodes in the cluster are Windows 2000 or later." );
                } // else: a warning will not be shown

                break;
            } // if: we got the cluster version info
            else
            {
                if ( dwError == ERROR_MORE_DATA )
                {
                    // Insufficient buffer - try again
                    ++cchBufferSize;
                    dwError = ERROR_SUCCESS;
                    TraceFlow1( "The buffer size is insufficient. Need %d bytes. Reallocating.", cchBufferSize );
                    continue;
                } // if: the size of the buffer was insufficient

                // If we are here, something has gone wrong - show the warning
                TW32( dwError );
                LogMsg( "Error %#x occurred trying to get cluster information.", dwError );
               break;
            } // else: we could not get the cluster version info
        } // forever get cluster information (loop for allocation)

        // We are done.
        //break;
    }
    while( false ); // Dummy do-while loop to avoid gotos

    // make sure the cluster service account has the necessary privileges on the upgraded system
    dwError = ClusterCheckForTCBPrivilege( fTCBWarningRequired );
    if ( dwError != ERROR_SUCCESS )
    {
        fTCBCheckFailed = TRUE;
    } // if: there was an error checking for TCB privilege

    if ( fNT4WarningRequired ) 
    {
        SmartSz                 sszWarningTitle;
        COMPATIBILITY_ENTRY     ceCompatibilityEntry;

        LogMsg( "The NT4 compatibility warning is required." );

        {
            WCHAR * pszWarningTitle = NULL;

            dwError = TW32( ScLoadString( IDS_ERROR_UPGRADE_OTHER_NODES, pszWarningTitle ) );
            if ( dwError != ERROR_SUCCESS )
            {
                // We cannot show the warning
                LogMsg( "Error %#x occurred trying to show the warning.", dwError );
            } // if: the load string failed
            else
            {
                sszWarningTitle.Assign( pszWarningTitle );
            } // else: assign the pointer to a smart pointer
        }

        if ( !sszWarningTitle.FIsEmpty() ) {

            //
            // Call the callback function
            //

            ceCompatibilityEntry.Description = sszWarningTitle.PMem();
            ceCompatibilityEntry.HtmlName = L"CompData\\ClusComp.htm";
            ceCompatibilityEntry.TextName = L"CompData\\ClusComp.txt";
            ceCompatibilityEntry.RegKeyName = NULL;
            ceCompatibilityEntry.RegValName = NULL ;
            ceCompatibilityEntry.RegValDataSize = 0;
            ceCompatibilityEntry.RegValData = NULL;
            ceCompatibilityEntry.SaveValue =  NULL;
            ceCompatibilityEntry.Flags = 0;
            ceCompatibilityEntry.InfName = NULL;
            ceCompatibilityEntry.InfSection = NULL;

            TraceFlow( "About to call the compatibility callback function." );

            // This function returns TRUE if the compatibility warning data was successfully set.
            fCompatCallbackReturnValue = pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn );

            TraceFlow1( "The compatibility callback function returned %d.", fCompatCallbackReturnValue );

        }
    } // while: we need to show the warning

    if ( !fNT4WarningRequired )
    {
        LogMsg( "The NT4 compatibility warning need not be shown." );
    } // if: we did not need to show the warning

    // If the check for TCB failed, it has precedence over the TCB privilege check
    if ( fTCBCheckFailed ) 
    {
        SmartSz                 sszWarningTitle;
        COMPATIBILITY_ENTRY     ceCompatibilityEntry;

        LogMsg( "The TCB check failed warning is required." );

        {
            WCHAR * pszWarningTitle = NULL;

            dwError = TW32( ScLoadString( IDS_ERROR_TCB_CHECK_FAILED, pszWarningTitle ) );
            if ( dwError != ERROR_SUCCESS )
            {
                // We cannot show the warning
                LogMsg( "Error %#x occurred trying to show the warning.", dwError );
            } // if: the load string failed
            else
            {
                sszWarningTitle.Assign( pszWarningTitle );
            } // else: assign the pointer to a smart pointer
        }

        if ( !sszWarningTitle.FIsEmpty() )
        {

            //
            // Call the callback function
            //

            ceCompatibilityEntry.Description = sszWarningTitle.PMem();
            ceCompatibilityEntry.HtmlName = L"CompData\\ClusTCBF.htm";
            ceCompatibilityEntry.TextName = L"CompData\\ClusTCBF.txt";
            ceCompatibilityEntry.RegKeyName = NULL;
            ceCompatibilityEntry.RegValName = NULL ;
            ceCompatibilityEntry.RegValDataSize = 0;
            ceCompatibilityEntry.RegValData = NULL;
            ceCompatibilityEntry.SaveValue =  NULL;
            ceCompatibilityEntry.Flags = 0;
            ceCompatibilityEntry.InfName = NULL;
            ceCompatibilityEntry.InfSection = NULL;

            TraceFlow( "About to call the compatibility callback function." );

            // This function returns TRUE if the compatibility warning data was successfully set.
            fCompatCallbackReturnValue = pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn );

            TraceFlow1( "The compatibility callback function returned %d.", fCompatCallbackReturnValue );
        } // if: the warning title string wasn't empty
    } // if: the TCB check failed
    else if ( fTCBWarningRequired ) 
    {
        SmartSz                 sszWarningTitle;
        COMPATIBILITY_ENTRY     ceCompatibilityEntry;

        LogMsg( "The TCB privilege error is required." );

        {
            WCHAR * pszWarningTitle = NULL;

            dwError = TW32( ScLoadString( IDS_ERROR_TCB_PRIVILEGE_NEEDED, pszWarningTitle ) );
            if ( dwError != ERROR_SUCCESS )
            {
                // We cannot show the warning
                LogMsg( "Error %#x occurred trying to show the warning.", dwError );
            } // if: the load string failed
            else
            {
                sszWarningTitle.Assign( pszWarningTitle );
            }
        }

        if ( !sszWarningTitle.FIsEmpty() ) {

            //
            // Call the callback function
            //

            ceCompatibilityEntry.Description = sszWarningTitle.PMem();
            ceCompatibilityEntry.HtmlName = L"CompData\\ClusTCB.htm";
            ceCompatibilityEntry.TextName = L"CompData\\ClusTCB.txt";
            ceCompatibilityEntry.RegKeyName = NULL;
            ceCompatibilityEntry.RegValName = NULL ;
            ceCompatibilityEntry.RegValDataSize = 0;
            ceCompatibilityEntry.RegValData = NULL;
            ceCompatibilityEntry.SaveValue =  NULL;
            ceCompatibilityEntry.Flags = 0;
            ceCompatibilityEntry.InfName = NULL;
            ceCompatibilityEntry.InfSection = NULL;

            TraceFlow( "About to call the compatibility callback function." );

            // This function returns TRUE if the compatibility warning data was successfully set.
            fCompatCallbackReturnValue = pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn );

            TraceFlow1( "The compatibility callback function returned %d.", fCompatCallbackReturnValue );
        }
    } // else: the TCB error is required
    else
    {
        LogMsg( "Neither TCB message was shown." );
    } // else: we did not need to show either message

    LogMsg( "Exiting function ClusterUpgradeCompatibilityCheck(). Return value is %d.", fCompatCallbackReturnValue );
    RETURN( fCompatCallbackReturnValue );

} //*** ClusterUpgradeCompatibilityCheck


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsClusterServiceRegistered
//
//  Description:
//      This function determines whether the Cluster Service has been registered
//      with the Service Control Manager or not. It is not possible to use the 
//      GetNodeClusterState() API to see if this node is a member of a cluster
//      or not, since this API was not available on NT4 SP3.
//
//  Arguments:
//      bool & rfIsRegisteredOut
//          If true, Cluster Service (ClusSvc) is registered with the Service 
//          Control Manager (SCM). Else, Cluster Service (ClusSvc) is not 
//          registered with SCM
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
ScIsClusterServiceRegistered( bool & rfIsRegisteredOut )
{
    TraceFunc( "" );

    DWORD   dwError = ERROR_SUCCESS;

    // Initialize the output
    rfIsRegisteredOut = false;

    // dummy do-while loop to avoid gotos
    do
    {
        // Instantiate the SmartServiceHandle smart handle class.
        typedef CSmartResource< CHandleTrait< SC_HANDLE, BOOL, CloseServiceHandle, NULL > > SmartServiceHandle;


        // Connect to the Service Control Manager
        SmartServiceHandle shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying open a handle to the service control manager.", dwError );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );

        // Was the handle to the service opened?
        if ( shService.HHandle() != NULL )
        {
            TraceFlow( "Successfully opened a handle to the cluster service. Therefore, it is registered." );
            rfIsRegisteredOut = true;
            break;
        } // if: handle to clussvc could be opened


        dwError = GetLastError();
        if ( dwError == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            TraceFlow( "The cluster service is not registered." );
            dwError = ERROR_SUCCESS;
            break;
        } // if: the handle could not be opened because the service did not exist.

        // If we are here, then some error occurred.
        TW32( dwError );
        LogMsg( "Error %#x occurred trying open a handle to the cluster service.", dwError );

        // Handles are closed by the CSmartHandle destructor.
    }
    while ( false ); // dummy do-while loop to avoid gotos

    RETURN( dwError );

} //*** ScIsClusterServiceRegistered


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScLoadString
//
//  Description:
//      Allocate memory for and load a string from the string table.
//
//  Arguments:
//      uiStringIdIn
//          Id of the string to look up
//
//      rpszDestOut
//          Reference to the pointer that will hold the address of the
//          loaded string. The memory will have to be freed by the caller
//          by using the delete operator.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other Win32 error codes
//          If the call failed.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
ScLoadString(
      UINT      nStringIdIn
    , WCHAR *&  rpszDestOut
    )
{
    TraceFunc( "" );

    DWORD     dwError = ERROR_SUCCESS;

    UINT        uiCurrentSize = 0;
    SmartSz     sszCurrentString;
    UINT        uiReturnedStringLen = 0;

    // Initialize the output.
    rpszDestOut = NULL;

    do
    {
        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        sszCurrentString.Assign( new WCHAR[ uiCurrentSize ] );
        if ( sszCurrentString.FIsEmpty() )
        {
            dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
            LogMsg( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadStringW(
                                  g_hInstance
                                , nStringIdIn
                                , sszCurrentString.PMem()
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    if ( dwError == ERROR_SUCCESS )
    {
        // Detach the smart pointer from the string, so that it is not freed by this function.
        // Store the string pointer in the output.
        rpszDestOut = sszCurrentString.PRelease();

    } // if: there were no errors in this function
    else
    {
        rpszDestOut = NULL;
    } // else: something went wrong

    RETURN( dwError );

} //*** ScLoadString


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWriteOSVersionInfo
//
//  Description:
//      This function writes the OS major and minor version information into the
//      registry. This information will be used later by ClusOCM to determine the
//      OS version before the upgrade.
//
//  Arguments:
//      const OSVERSIONINFO & rcosviOSVersionInfoIn
//          Reference to the OSVERSIONINFO structure that has information about the
//          OS version of this node.
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
ScWriteOSVersionInfo( const OSVERSIONINFO & rcosviOSVersionInfoIn )
{
    TraceFunc( "" );

    DWORD               dwError = ERROR_SUCCESS;
    HKEY                hkey;
    DWORD               cbData;
    DWORD               dwType;
    NODE_CLUSTER_STATE  ncsNodeClusterState;

    // Instantiate the SmartRegistryKey smart handle class.
    typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;
    SmartRegistryKey srkClusSvcSW;
    SmartRegistryKey srkOSInfoKey;

    //
    // If the InstallationState value does not exist, set it to the
    // NotConfigured value.  This is required due to a bug in the Win2K
    // version of GetNodeClusterState which doesn't handle the case where
    // the key exists but the value doesn't.
    //

    // Open the Cluster Service SOFTWARE key.
    // Don't use TW32 here since we are checking for a specific return value.
    dwError = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA
                    , 0                 // ulOptions
                    , KEY_ALL_ACCESS    // samDesired
                    , &hkey
                    );
    if ( dwError == ERROR_FILE_NOT_FOUND )
    {
        // Create the Cluster Service key.
        dwError = TW32( RegCreateKeyExW(
                              HKEY_LOCAL_MACHINE
                            , CLUSREG_KEYNAME_NODE_DATA
                            , 0         // Reserved
                            , L""       // lpClass
                            , REG_OPTION_NON_VOLATILE
                            , KEY_ALL_ACCESS
                            , NULL      // lpSecurityAttributes
                            , &hkey
                            , NULL      // lpdwDisposition
                            ) );
        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred attempting to create the '%ws' registry key.", dwError, CLUSREG_KEYNAME_NODE_DATA );
            goto Cleanup;
        } // if: error creating the Cluster Service key
    } // if: Cluster Service key doesn't exist
    else if ( dwError != ERROR_SUCCESS )
    {
        TW32( dwError );
        LogMsg( "Error %#x occurred attempting to open the '%ws' registry key.", dwError, CLUSREG_KEYNAME_NODE_DATA );
        goto Cleanup;
    } // else if: error opening the Cluster Service key

    // Assign the key to the smart handle.
    srkClusSvcSW.Assign( hkey );

    //
    // Get the InstallationState value.  If it is not set, set it to
    // NotConfigured.
    //

    // Get the current value.
    // Don't use TW32 here since we are checking for a specific return value.
    cbData = sizeof( ncsNodeClusterState );
    dwError = RegQueryValueExW(
                      srkClusSvcSW.HHandle()
                    , CLUSREG_NAME_INSTALLATION_STATE
                    , 0         // lpReserved
                    , &dwType   // lpType
                    , reinterpret_cast< BYTE * >( &ncsNodeClusterState )
                    , &cbData
                    );
    if ( dwError == ERROR_FILE_NOT_FOUND )
    {
        ncsNodeClusterState = ClusterStateNotInstalled;

        // Write the InstallationState value.
        dwError = TW32( RegSetValueExW(
                              srkClusSvcSW.HHandle()
                            , CLUSREG_NAME_INSTALLATION_STATE
                            , 0         // lpReserved
                            , REG_DWORD
                            , reinterpret_cast< const BYTE * >( &ncsNodeClusterState )
                            , sizeof( DWORD )
                            ) );
        if ( dwError != ERROR_SUCCESS )
        {
#define INSTALLSTATEVALUE CLUSREG_KEYNAME_NODE_DATA L"\\" CLUSREG_NAME_INSTALLATION_STATE
            LogMsg( "Error %#x occurred attempting to set the '%ws' value on the '%ws' registry value to '%d'.", dwError, CLUSREG_NAME_INSTALLATION_STATE, INSTALLSTATEVALUE, ClusterStateNotInstalled );
            goto InstallStateError;
        } // if: error creating the Cluster Service key
    } // if: InstallationState value didn't exist before
    else if ( dwError != ERROR_SUCCESS )
    {
        TW32( dwError );
        LogMsg( "Error %#x occurred attempting to query for the '%ws' value on the registry key.", dwError, CLUSREG_NAME_INSTALLATION_STATE, INSTALLSTATEVALUE );
        goto InstallStateError;
    } // else if: error querying for the InstallationState value
    else
    {
        Assert( dwType == REG_DWORD );
    }

    //
    // Open the node version info registry key.
    // If it doesn't exist, create it.
    //

    dwError = TW32( RegCreateKeyExW(
                          srkClusSvcSW.HHandle()
                        , CLUSREG_KEYNAME_PREV_OS_INFO
                        , 0
                        , L""
                        , REG_OPTION_NON_VOLATILE
                        , KEY_ALL_ACCESS
                        , NULL
                        , &hkey
                        , NULL
                        ) );
    if ( dwError != ERROR_SUCCESS )
    {
#define PREVOSINFOKEY CLUSREG_KEYNAME_NODE_DATA L"\\" CLUSREG_KEYNAME_PREV_OS_INFO
        LogMsg( "Error %#x occurred attempting to create the registry key where the node OS info is stored (%ws).", dwError, PREVOSINFOKEY );
        goto Cleanup;
    } // if: RegCreateKeyEx() failed

    srkOSInfoKey.Assign( hkey );

    // Write the OS major version
    dwError = TW32( RegSetValueExW(
                          srkOSInfoKey.HHandle()
                        , CLUSREG_NAME_NODE_MAJOR_VERSION
                        , 0
                        , REG_DWORD
                        , reinterpret_cast< const BYTE * >( &rcosviOSVersionInfoIn.dwMajorVersion )
                        , sizeof( rcosviOSVersionInfoIn.dwMajorVersion )
                        ) );
    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#x occurred trying to store the OS major version info.", dwError );
        goto Cleanup;
    } // if: RegSetValueEx() failed while writing rcosviOSVersionInfoIn.dwMajorVersion

    // Write the OS minor version
    dwError = TW32( RegSetValueExW(
                          srkOSInfoKey.HHandle()
                        , CLUSREG_NAME_NODE_MINOR_VERSION
                        , 0
                        , REG_DWORD
                        , reinterpret_cast< const BYTE * >( &rcosviOSVersionInfoIn.dwMinorVersion )
                        , sizeof( rcosviOSVersionInfoIn.dwMinorVersion )
                        ) );
    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#x occurred trying to store the OS minor version info.", dwError );
        goto Cleanup;
    } // if: RegSetValueEx() failed while writing rcosviOSVersionInfoIn.dwMinorVersion

    LogMsg( "OS version information successfully stored in the registry." );

    goto Cleanup;

InstallStateError:

    //
    // Attempt to delete the key, since having the key around without the
    // InstallationState value causes GetNodeClusterState to break on a
    // Win2K machine.
    //
    TW32( RegDeleteKey( HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_NODE_DATA ) );
    goto Cleanup;

Cleanup:

    RETURN( dwError );

} //*** ScWriteOSVersionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <LogSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscomp\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file for the ClusComp DLL.
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

//
// KB: DEBUG_SUPPORT_NT4 DavidP 05-OCT-2000
//      Defining this to make sure that the debug macros don't do something
//      that won't work for NT4.
#define DEBUG_SUPPORT_NT4

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Status values for LSA APIs
#include <ntstatus.h>
#define WIN32_NO_STATUS

#include <Pragmas.h>

#include <windows.h>

#include <StrSafe.h>
#include "clstrcmp.h"

// For a few global variables
#include "Dll.h"

// For tracing and debugging functions
#include "Debug.h"

// For logging functions
#include <Log.h>

// For the definition of smart pointer and handle templates
#include "SmartClasses.h"

// For the string ids
#include "ClusCompResources.h"


//////////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////////

// Smart pointer to a character string.
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >  SmartSz;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocmapp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2003 Microsoft Corporation
//
//  Module Name:
//      CClusOCMApp.cpp
//
//  Header File:
//      CClusOCMApp.h
//
//  Description:
//      ClusOCM.DLL is an Optional Components Manager DLL for installation of
//      Microsoft Cluster Server. This file contains the definition of the
//      class ClusOCMApp, which is the main class of the ClusOCM DLL.
//
//  Documentation:
//      [1] 2001 Setup - Architecture.doc
//          Architecture of the DLL for Whistler (Windows 2001)
//
//      [2] 2000 Setup - FuncImpl.doc
//          Contains description of the previous version of this DLL (Windows 2000)
//
//      [3] http://winweb/setup/ocmanager/OcMgr1.doc
//          Documentation about the OC Manager API
//
//  Maintained By:
//      David Potter    (DavidP)    15-AUG-2001
//
//      Vij Vasu        (Vvasu)     03-MAR-2000
//          Adapted for Windows Server 2003.
//          See documentation for more complete details. Major changes are:
//
//          - This DLL no longer uses MFC. Class structure has changed.
//
//          - Cluster binaries are always installed. So, uninstall functionality
//            has been removed from this DLL.
//
//          - Upgrade on a computer that does not have the cluster binaries
//            should now install the binaries.
//
//          - CluAdmin completely functional by the end of install of binaries.
//
//          - Time Service no longer installed.
//
//          - Complete change in coding and commenting style.
//
//      C. Brent Thomas (a-brentt)  01-JAN-1998
//          Created the original version.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"

// The header file for this module.
#include "CClusOCMApp.h"

// For the CTaskCleanInstall class
#include "CTaskCleanInstall.h"

// For the CTaskUpgradeNT4 class
#include "CTaskUpgradeNT4.h"

// For the CTaskUpgradeWindows2000 class
#include "CTaskUpgradeWin2k.h"

// For the CTaskUpgradeWindowsDotNet class
#include "CTaskUpgradeWhistler.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CClusOCMApp" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMApp::CClusOCMApp
//
//  Description:
//      Constructor of the CClusOCMApp class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMApp::CClusOCMApp( void )
    : m_fIsUnattendedSetup( false )
    , m_fIsUpgrade( false )
    , m_fIsGUIModeSetup( false )
    , m_fAttemptedTaskCreation( false )
    , m_cisCurrentInstallState( eClusterInstallStateUnknown )
    , m_dwFirstError( NO_ERROR )
{
    TraceFunc( "" );

    memset( &m_sicSetupInitComponent, 0, sizeof( m_sicSetupInitComponent ) );
    TraceFuncExit();

} //*** CClusOCMApp::CClusOCMApp


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMApp::~CClusOCMApp
//
//  Description:
//      Destructor of the CClusOCMApp class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMApp::~CClusOCMApp( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusOCMApp::CClusOCMApp


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwClusOcmSetupProc
//
//  Description:
//      This function is called by the entry point of this DLL, DwClusOcmSetupProc.
//      See document [3] in the header of this file for details.
//
//      This function determines what actions need to be taken (upgrade, clean
//      install, etc., and pass control accordingly to the correct routines.
//
//  Arguments:
//      LPCVOID pvComponentIdIn
//          Pointer to a string that uniquely identifies the component.
//
//      LPCVOID pvSubComponentIdIn
//          Pointer to a string that uniquely identifies a sub-component in 
//          the component's hiearchy.
//
//      UINT uiFunctionCodeIn
//          A numeric value indicating which function is to be perfomed.
//          See ocmanage.h for the macro definitions.
//
//      UINT uiParam1In
//          Supplies a function specific parameter.
//
//      PVOID pvParam2Inout
//          Pointer to a function specific parameter (either input or output).
//
//  Return Value:
//      A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwClusOcmSetupProc(
      LPCVOID    pvComponentIdIn
    , LPCVOID    pvSubComponentIdIn
    , UINT       uiFunctionCodeIn
    , UINT       uiParam1In
    , PVOID      pvParam2Inout 
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Switch based on the function code passed in by OC Manager.
    switch ( uiFunctionCodeIn )
    {
        // This is the first function that OC Manager calls.
        case OC_PREINITIALIZE:
        {
            LogMsg( "OC Manager called OC_PREINITIALIZE." );

            // Return OCFLAG_UNICODE to indicate that only UNICODE is to be used.
            dwReturnValue = OCFLAG_UNICODE;

        } // case OC_PREINITIALIZE
        break;


        //
        // This function is called soon after the component's setup dll is
        // loaded. This function provides initialization information to the
        // dll, instructs the dll to initialize itself, and provides a
        // mechanism for the dll to return information to OC Manager.
        //
        case OC_INIT_COMPONENT:
        {
            LogMsg( 
                  "OC Manager called OC_INIT_COMPONENT for the component '%s'."
                , reinterpret_cast< LPCWSTR >( pvComponentIdIn )
                );

            dwReturnValue = TW32( DwOcInitComponentHandler( reinterpret_cast< PSETUP_INIT_COMPONENT >( pvParam2Inout ) ) );

        } // case OC_INIT_COMPONENT
        break;


        // Get the initial, current and final state of the component.
        case OC_QUERY_STATE:
        {
            LogMsg( "OC Manager called OC_QUERY_STATE." );

            dwReturnValue = DwOcQueryStateHandler( uiParam1In );

        } // case OC_QUERY_STATE
        break;


        // OC Manager is asking approval for a user selection of installation state.
        case OC_QUERY_CHANGE_SEL_STATE:
        {
            LogMsg( "OC Manager called OC_QUERY_CHANGE_SEL_STATE." );

            //
            // The cluster service has to be always installed. So, disallow any state
            // change that deselects the cluster service (by returning FALSE).
            //

            // The component has been deselected if uiParam1In is 0.
            if ( uiParam1In == 0 )
            {
                LogMsg( "Disallowing deselection of the Cluster Service." );
                dwReturnValue = FALSE;
            }
            else
            {
                LogMsg( "Allowing selection of the Cluster Service." );
                dwReturnValue = TRUE;
            }

        } // case OC_QUERY_CHANGE_SEL_STATE
        break;


        // Instructs the component to change to a given language if it can.
        case OC_SET_LANGUAGE:
        {
            LogMsg( "OC Manager called OC_SET_LANGUAGE." );

            dwReturnValue = SetThreadLocale( MAKELCID( PRIMARYLANGID( uiParam1In ), SORT_DEFAULT ) );

        } // case OC_SET_LANGUAGE
        break;


        //
        // Directs the component to manipulate a Setup API Disk Space List, 
        // placing files on it or removing files from it, to mirror what will be 
        // actually installed later via a Setup API file queue.
        //
        case OC_CALC_DISK_SPACE:
        {
            CClusOCMTask * pCurrentTask = NULL;

            LogMsg( "OC Manager called OC_CALC_DISK_SPACE." );

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32(
                    pCurrentTask->DwOcCalcDiskSpace(
                          ( uiParam1In != 0 )         // non-zero uiParam1In means "add to disk space requirements"
                        , reinterpret_cast< HDSKSPC >( pvParam2Inout )
                        )
                    );

                // Note: Do not call DwSetError() here if the above function failed. Failure to calculate disk space
                // is to be expected if the binaries are not accessible at this time (for example, they are on a
                // network share and the credentials for this share have not been entered yet). This is not fatal and
                // hence should not trigger a cleanup.

            } // if: there is something to do
            else
            {
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_CALC_DISK_SPACE
        break;


        //
        // Directs the component to queue file operations for installation, based on
        // user interaction with the wizard pages and other component-specific factors.
        // 
        case OC_QUEUE_FILE_OPS:
        {
            CClusOCMTask * pCurrentTask = NULL;

            LogMsg( "OC Manager called OC_QUEUE_FILE_OPS." );

            if ( DwGetError() != NO_ERROR )
            {
                // If an error has occurred previously, do not do this operation.
                LogMsg( "An error has occurred earlier in this task. Nothing will be done here." );
                break;
            } // if: an error has occurred previously

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( 
                    DwSetError( 
                        pCurrentTask->DwOcQueueFileOps( 
                            reinterpret_cast< HSPFILEQ >( pvParam2Inout )
                            )
                        )
                    );
            } // if: there is something to do
            else
            {
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_QUEUE_FILE_OPS
        break;


        //
        // Allows the component to perform any additional operations needed
        // to complete installation, for example registry manipulations, and
        // so forth.
        //
        case OC_COMPLETE_INSTALLATION:
        {
            CClusOCMTask * pCurrentTask = NULL;

            LogMsg( "OC Manager called OC_COMPLETE_INSTALLATION." );

            if ( DwGetError() != NO_ERROR )
            {
                // If an error has occurred previously, do not do this operation.
                LogMsg( "An error has occurred earlier in this task. Nothing will be done here." );
                break;
            } // if: an error has occurred previously

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( DwSetError( pCurrentTask->DwOcCompleteInstallation() ) );
            } // if: there is something to do
            else
            {
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_COMPLETE_INSTALLATION
        break;


        //
        // Informs the component that it is about to be unloaded.
        //
        case OC_CLEANUP:
        {
            CClusOCMTask * pCurrentTask = NULL;

            LogMsg( "OC Manager called OC_CLEANUP." );

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( DwSetError( pCurrentTask->DwOcCleanup() ) );

                // Once the cleanup is done, we have nothing else to do. Free the task object.
                ResetCurrentTask();
            } // if: there is something to do
            else
            {
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_CLEANUP
        break;


        default:
        {
            LogMsg( "OC Manager called unknown function. Function code is %#x.", uiFunctionCodeIn );
        } // case: default
    } // switch( uiFunctionCodeIn )


    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwClusOcmSetupProc


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwOcInitComponentHandler
//
//  Description:
//      This function handles the OC_INIT_COMPONENT messages from the Optional
//      Components Manager.
//
//      This function is called soon after the component's setup dll is
//      loaded. This checks OS and OC Manager versions, initializes CClusOCMApp
//      data members, determines the cluster service installation state, etc.
//
//  Arguments:
//      PSETUP_INIT_COMPONENT pSetupInitComponentInout
//          Pointer to a SETUP_INIT_COMPONENT structure.
//
//  Return Value:
//      NO_ERROR
//          Call was successful.
//
//      ERROR_CALL_NOT_IMPLEMENTED
//          The OC Manager and this DLLs versions are not compatible.
//
//      ERROR_CANCELLED
//          Any other error occurred. No other error codes are returned.
//          The actual error is logged.
//
//  Remarks:
//      The SETUP_INIT_COMPONENT structure pointed to by pSetupInitComponentInout
//      is not persistent. It is therefore necessary to save a copy locally.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwOcInitComponentHandler(
    PSETUP_INIT_COMPONENT pSetupInitComponentInout
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD                   dwReturnValue = NO_ERROR;
    UINT                    uiStatus;
    eClusterInstallState    cisTempState = eClusterInstallStateUnknown;


    // Dummy do-while loop to avoid gotos.
    do
    {
        if ( pSetupInitComponentInout == NULL )
        {
            LogMsg( "Error: Pointer to the SETUP_INIT_COMPONENT structure is NULL." );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: pSetupInitComponentInout is NULL


        // Indicate to OC Manager which version of OC Manager this dll expects.
        pSetupInitComponentInout->ComponentVersion = OCMANAGER_VERSION;

        // Save the SETUP_INIT_COMPONENT structure.
        SetSetupState( *pSetupInitComponentInout );


        //
        // Determine if the OC Manager version is correct.
        //
        if ( OCMANAGER_VERSION > RsicGetSetupInitComponent().OCManagerVersion )
        {
            // Indicate failure.

            LogMsg( 
                "Error: OC Manager version mismatch. Version %d is required, Version %d was reported.",
                OCMANAGER_VERSION, 
                RsicGetSetupInitComponent().OCManagerVersion 
                );

            dwReturnValue = TW32( ERROR_CALL_NOT_IMPLEMENTED );
            break;
        } // if: the OC Manager version is incorrect.


        LogMsg( "The OC Manager version matches with the version of this component." );

#if 0
/*
        // KB: 06-DEC-2000 DavidP
        //      Since ClusOCM only copies files and registers some COM objects,
        //      there is no longer any reason to perform an OS check.  We now
        //      depend on this happening in the service when the node is added
        //      to a cluster.

        //
        // Check OS version and suite information.
        //
        LogMsg( "Checking if OS version and Product Suite are compatible..." );
        if ( ClRtlIsOSValid() == FALSE )
        {
            // The OS version and/or Product Suite are not compatible

            DWORD dwErrorCode = TW32( GetLastError() );

            LogMsg( "Cluster Service cannot be installed on this computer. The version or product suite of the operating system is incorrect." );
            LogMsg( "ClRtlIsOSValid failed with error code %#x.", dwErrorCode );
            dwReturnValue = ERROR_CANCELLED;
            break;
        } // if: OS version and/or Product Suite are not compatible

        LogMsg( "OS version and product suite are correct." );
*/
#endif


        // Is the handle to the component INF valid?
        if (    ( RsicGetSetupInitComponent().ComponentInfHandle == INVALID_HANDLE_VALUE ) 
             || ( RsicGetSetupInitComponent().ComponentInfHandle == NULL ) 
           )
        {
            // Indicate failure.
            LogMsg( "Error: ComponentInfHandle is invalid." );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: the INF file handle is not valid.


        //
        // The following call to SetupOpenAppendInfFile ensures that layout.inf
        // gets appended to ClusOCM.inf. This is required for several reasons
        // dictated by the Setup API. In theory OC Manager should do this, but
        // as per Andrew Ritz, 8/24/98, OC manager neglects to do it and it is
        // harmless to do it here after OC Manager is revised.
        //
        // Note that passing NULL as the first parameter causes SetupOpenAppendInfFile
        // to append the file(s) listed on the LayoutFile entry in clusocm.inf.
        //
        // The above comment was written by Brent.
        // TODO: Check if this is still needed. (Vij Vasu, 05-MAR-2000)
        //
        SetupOpenAppendInfFile(
            NULL, 
            RsicGetSetupInitComponent().ComponentInfHandle,
            &uiStatus 
            );


        //
        // Determine the current installation state of the cluster service. This can
        // be done by calling the function ClRtlGetClusterInstallState.
        // However, on machines that are upgrading from NT4, this will not work and
        // the correct installation state can be found out only by checking if the 
        // cluster service is registered (ClRtlGetClusterInstallState will return
        // eClusterInstallStateUnknown in this case)
        //
        dwReturnValue = ClRtlGetClusterInstallState( NULL, &cisTempState );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred calling ClRtlGetClusterInstallState(). Cluster Service installation state cannot be determined.", dwReturnValue );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: ClRtlGetClusterInstallState failed

        if ( cisTempState == eClusterInstallStateUnknown )
        {
            bool fRegistered = false;

            dwReturnValue = TW32( DwIsClusterServiceRegistered( &fRegistered ) );
            if ( dwReturnValue != ERROR_SUCCESS )
            {
                LogMsg( "Error %#x: Could not check if the cluster service was registered or not.", dwReturnValue );
                dwReturnValue = ERROR_CANCELLED;
                break;
            }

            LogMsg( "ClRtlGetClusterInstallState() returned eClusterInstallStateUnknown. Trying to see if the service is registered." );
            if ( fRegistered )
            {
                LogMsg( "The Cluster Service is registered. Setting current installation state to eClusterInstallStateConfigured." );
                cisTempState = eClusterInstallStateConfigured;
            }
            else
            {
                LogMsg( "The Cluster Service is not registered." );
            } // else: Cluster Service is not registered.
        } // if: ClRtlGetClusterInstallState returned eClusterInstallStateUnknown

        LogMsg( "The current installation state of the cluster service is %#x.", cisTempState );

        // Store the current cluster installation state.
        CisStoreClusterInstallState( cisTempState );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    LogMsg( "Return Value is %#x.", dwReturnValue );
    
    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwOcInitComponentHandler


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwOcQueryStateHandler
//
//  Description:
//      This function handles the OC_QUERY_STATE messages from the Optional
//      Components Manager.
//
//      This function is called called at least thrice, once each to get the 
//      initial, current and the final installation states.
//
//      The initial state is the state before ClusOCM was called.
//
//      The current state is the current selection state. This is always
//      'On' because the cluster binaries are always installed.
//
//      The final state is the state after ClusOCM has done its tasks.
//
//  Arguments:
//      UINT uiSelStateQueryTypeIn
//          The type of query - OCSELSTATETYPE_ORIGINAL, OCSELSTATETYPE_CURRENT
//          or OCSELSTATETYPE_FINAL.
//
//  Return Value:
//      SubcompOn
//          Indicates that the checkbox next to the component in the OC
//          Manager UI should be set.
//
//      SubcompOff
//          Indicates that the checkbox should be cleared.
//
//      SubcompUseOcManagerDefault
//          OC Manager should set the state of the checkbox.
//
//  Remarks:
//      This function has to be called after DwOcInitComponentHandler, otherwise
//      the initial installation state may not be set correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwOcQueryStateHandler( UINT uiSelStateQueryTypeIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = SubcompUseOcManagerDefault;

    switch( uiSelStateQueryTypeIn )
    {
        case OCSELSTATETYPE_ORIGINAL:
        {
            LogMsg( "OC Manager is querying for the original state." );

            //
            // If the cluster binaries have been installed or if cluster service
            // has been configured, then the original installation state is on.
            //
            dwReturnValue =   ( CisGetClusterInstallState() == eClusterInstallStateUnknown )
                            ? SubcompOff
                            : SubcompOn;
        } // case: OCSELSTATETYPE_ORIGINAL
        break;

        case OCSELSTATETYPE_CURRENT:
        {
            // The current state is always on.
            LogMsg( "OC Manager is querying for the current state." );

            dwReturnValue = SubcompOn;
        } // case: OCSELSTATETYPE_CURRENT
        break;

        case OCSELSTATETYPE_FINAL:
        {
            LogMsg( "OC Manager is querying for the final state." );

            //
            // If we are here, then the OC_COMPLETE_INSTALLATION has already
            // been called. At this stage CisStoreClusterInstallState() reflects
            // the state after ClusOCM has done its tasks.
            //
            dwReturnValue =   ( CisGetClusterInstallState() == eClusterInstallStateUnknown )
                            ? SubcompOff
                            : SubcompOn;
        } // case: OCSELSTATETYPE_FINAL
        break;

    }; // switch: based on uiSelStateQueryTypeIn

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwOcQueryStateHandler


/////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusOCMApp::SetSetupState
//
//  Description:
//      Set the SETUP_INIT_COMPONENT structure. Use this structure and set
//      various setup state variables.
//
//  Arguments:
//      const SETUP_INIT_COMPONENT & sicSourceIn
//          The source SETUP_INIT_COMPONENT structure, usually passed in by
//          the OC Manager.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CClusOCMApp::SetSetupState( const SETUP_INIT_COMPONENT & sicSourceIn )
{
    TraceFunc( "" );

    m_sicSetupInitComponent = sicSourceIn;

    m_fIsUnattendedSetup = ( 
                             (   m_sicSetupInitComponent.SetupData.OperationFlags 
                               & (DWORDLONG) SETUPOP_BATCH
                             ) 
                             !=
                             (DWORDLONG) 0L
                           );

    m_fIsUpgrade = (
                     (   m_sicSetupInitComponent.SetupData.OperationFlags
                       & (DWORDLONG) SETUPOP_NTUPGRADE
                     ) 
                     !=
                     (DWORDLONG) 0L
                   );

    m_fIsGUIModeSetup = ( 
                          (   m_sicSetupInitComponent.SetupData.OperationFlags 
                            & (DWORDLONG) SETUPOP_STANDALONE
                          ) 
                          ==
                          (DWORDLONG) 0L
                        );

    // Log setup state.
    LogMsg( 
          "This is an %s, %s setup session. This is%s an upgrade."
        , FIsUnattendedSetup() ? L"unattended" : L"attended"
        , FIsGUIModeSetup() ? L"GUI mode" : L"standalone"
        , FIsUpgrade() ? L"" : L" not"
        );

    TraceFuncExit();

} //*** CClusOCMApp::SetSetupState


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwIsClusterServiceRegistered
//
//  Description:
//      This function determines whether the Cluster Service has been registered
//      with the Service Control Manager. If it is, it means that it has already
//      been configured. This check is required in nodes being upgraded from NT4
//      where ClRtlGetClusterInstallState() will not work.
//
//  Arguments:
//      bool * pfIsRegisteredOut
//          If true, Cluster Service (ClusSvc) is registered with the Service 
//          Control Manager (SCM). Else, Cluster Service (ClusSvc) is not 
//          registered with SCM
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwIsClusterServiceRegistered( bool * pfIsRegisteredOut ) const
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    bool    fIsRegistered = false;
    DWORD   dwReturnValue = ERROR_SUCCESS;

    // dummy do-while loop to avoid gotos
    do
    {
        // Connect to the Service Control Manager
        SmartServiceHandle shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );


        // Was the handle to the service opened?
        if ( shService.HHandle() != NULL )
        {
            LogMsg( "The cluster service is registered." );
            fIsRegistered = true;
            break;
        } // if: handle to clussvc could be opened


        dwReturnValue = GetLastError();
        if ( dwReturnValue == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            dwReturnValue = ERROR_SUCCESS;
            LogMsg( "ClusSvc does not exist as a service." );
            break;
        } // if: the handle could not be opened because the service did not exist.


        // Some error occurred.
        TW32( dwReturnValue);
        LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );

        // Handles are closed by the CSmartHandle destructor.
    }
    while ( false ); // dummy do-while loop to avoid gotos

    if ( pfIsRegisteredOut != NULL )
    {
        *pfIsRegisteredOut = fIsRegistered;
    }

    LogMsg( "fIsRegistered is %d. Return Value is %#x.", fIsRegistered, dwReturnValue );
    
    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwIsClusterServiceRegistered


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwGetCurrentTask
//
//  Description:
//      This function returns a pointer to the current task object. If a task
//      object has not been created yet, it creates the appropriate task.
//
//  Arguments:
//      CClusOCMTask *& rpTaskOut
//          Reference to the pointer to the current task. Do not try to 
//          free this memory.
//
//          If no task needs to be performed, a NULL pointer is returned.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//
//  Remarks:
//      This function will work properly only after the member variables which
//      indicate which task will be performed have been initialized correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwGetCurrentTask( CClusOCMTask *& rpTaskOut )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD           dwReturnValue = NO_ERROR;

    // Initialize the output.
    rpTaskOut = NULL;

    do
    {
        eClusterInstallState ecisCurrentState;

        if ( m_fAttemptedTaskCreation )
        {
            // A task object already exists - just return it.
            LogMsg( "A task object already exists. Returning it." );

            rpTaskOut = m_sptaskCurrentTask.PMem();
            break;
        } // if: the task object has already been created.

        LogMsg( "Creating a new task object." );

        // Make note of the fact that we have started our attempt to create a task object.
        m_fAttemptedTaskCreation = true;

        // Reset the task pointer.
        m_sptaskCurrentTask.Assign( NULL );

        // Get the current installation state to deduce what operation to perform.
        ecisCurrentState = CisGetClusterInstallState();

        // The task object has not been created yet - create one now.
        if ( ( ecisCurrentState == eClusterInstallStateUnknown ) || ( ecisCurrentState == eClusterInstallStateFilesCopied ) )
        {
            LogMsg( "The cluster installation state is %ws. Assuming that a clean install is required."
                , ( ( ecisCurrentState == eClusterInstallStateUnknown ) ? L"not known" : L"files copied" ) );

            // If the installation state is unknown, assume that the cluster binaries
            // are not installed.
            rpTaskOut = new CTaskCleanInstall( *this );
            if ( rpTaskOut == NULL )
            {
                LogMsg( "Error: There was not enough memory to start a clean install." );
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                break;
            } // if: memory allocation failed
        } // if: the cluster installation state is eClusterInstallStateUnknown or eClusterInstallStateFilesCopied
        else if ( m_fIsUpgrade )
        {
            //
            // If we are here, it means that an upgrade is in progress and the cluster binaries
            // have already been installed on the OS being upgraded. Additionally, this node may
            // already be part of a cluster.
            //

            DWORD dwNodeClusterMajorVersion = 0;

            // Find out which version of the cluster service we are upgrading.
            dwReturnValue = TW32( DwGetNodeClusterMajorVersion( dwNodeClusterMajorVersion ) );
            if ( dwReturnValue != NO_ERROR )
            {
                LogMsg( "Error %#x occurred trying to determine the version of the cluster service that we are upgrading.", dwReturnValue );
                break;
            } // if: an error occurred trying to determine the version of the cluster service that we are upgrading

            // Check if the returned cluster version is valid
            if (    ( dwNodeClusterMajorVersion != NT51_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT5_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT4SP4_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT4_MAJOR_VERSION )
               )
            {
                LogMsg( "The version of the cluster service before the upgrade (%d) is invalid.", dwNodeClusterMajorVersion ); 
                break;
            } // if: the cluster version is not valid

            // Based on the previous version of the cluster service, create the correct task object.
            if ( dwNodeClusterMajorVersion == NT5_MAJOR_VERSION )
            {
                LogMsg( "We are upgrading a Windows 2000 node." );
                rpTaskOut = new CTaskUpgradeWindows2000( *this );
            } // if: we are upgrading from Windows 2000
            else if ( dwNodeClusterMajorVersion == NT51_MAJOR_VERSION )
            {
                LogMsg( "We are upgrading a Windows Server 2003 node." );
                rpTaskOut = new CTaskUpgradeWindowsDotNet( *this );
            } // else if: we are upgrading from Windows Server 2003
            else
            {
                LogMsg( "We are upgrading an NT4 node." );
                rpTaskOut = new CTaskUpgradeNT4( *this );
            } // else: we are upgrading from NT4 (either SP3 or SP4)

            if ( rpTaskOut == NULL )
            {
                LogMsg( "Error: There was not enough memory to create the required task." );
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                break;
            } // if: memory allocation failed
        } // else if: an upgrade is in progress

        if ( rpTaskOut != NULL )
        {
            LogMsg( "A task object was successfully created." );

            // Store the pointer to the newly created task in the member variable.
            m_sptaskCurrentTask.Assign( rpTaskOut );
        } // if: the task object was successfully created
        else
        {
            LogMsg( "No task object was created." );
        } // else: no task object was created
    }
    while( false ); // dummy do-while loop to avoid gotos

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwGetCurrentTask


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwGetNodeClusterMajorVersion
//
//  Description:
//      This function returns the major version of the cluster service that
//      we are upgrading. The version that this function returns is the version
//      of the service before the upgrade. If there was a problem reading this
//      information, this function lies and says that the previous version was
//      NT4, since this is the safest thing to say and is better than aborting
//      the upgrade.
//
//      Note: This function can only be called during an upgrade.
//
//  Arguments:
//      DWORD & rdwNodeClusterMajorVersionOut
//          Reference to DWORD that will hold the major version of the cluster
//          service that we are upgrading.
//
//  Return Value:
//      NO_ERROR if all went well.
//      ERROR_NODE_NOT_AVAILABLE if an upgrade is not in progress.
//      ERROR_CLUSTER_INCOMPATIBLE_VERSIONS if the node is not NT4, Windows
//          2000, or Windows Server 2003.
//      Other Win32 error codes on failure.
//
//
//  Remarks:
//      This function will work properly only after the member variables which
//      indicate which task will be performed have been initialized correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwGetNodeClusterMajorVersion( DWORD & rdwNodeClusterMajorVersionOut )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD   dwReturnValue = NO_ERROR;
    DWORD   dwPrevOSMajorVersion = 0;
    DWORD   dwPrevOSMinorVersion = 0;

    do
    {
        SmartRegistryKey    srkOSInfoKey;
        DWORD               dwRegValueType = 0;
        DWORD               cbBufferSize = 0;

        // Initialize the output.
        rdwNodeClusterMajorVersionOut = 0;

        if ( !m_fIsUpgrade )
        {
            LogMsg( "Error: This function cannot be called when an upgrade is not in progress." );
            dwReturnValue = TW32( ERROR_NODE_NOT_AVAILABLE );
            break;
        } // if: an upgrade is not in progress

        //
        // Read the registry to get what the OS version was before the upgrade.
        // This information was written here by ClusComp.dll. From the OS version information,
        // try and deduce the cluster version info.
        // NOTE: At this point, it is not possible to differentiate between NT4_MAJOR_VERSION 
        // and NT4SP4_MAJOR_VERSION, and, for the purposes of the upgrade, I don't think we need
        // to either - so, just treat all NT4 cluster nodes the same.
        //
        {
            HKEY hTempKey = NULL;

            // Open the node version info registry key
            dwReturnValue = TW32(
                RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA L"\\" CLUSREG_KEYNAME_PREV_OS_INFO
                    , 0
                    , KEY_READ
                    , &hTempKey
                    )
                );

            if ( dwReturnValue != ERROR_SUCCESS )
            {
                LogMsg( "Error %#x occurred trying open the registry key where where info about the previous OS is stored.", dwReturnValue );
                break;
            } // if: RegOpenKeyEx() failed

            // Store the opened key in a smart pointer for automatic close.
            srkOSInfoKey.Assign( hTempKey );
        }

        // Read the OS major version
        cbBufferSize = sizeof( dwPrevOSMajorVersion );
        dwReturnValue = TW32(
            RegQueryValueExW(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MAJOR_VERSION
                , 0
                , &dwRegValueType
                , reinterpret_cast< LPBYTE >( &dwPrevOSMajorVersion )
                , &cbBufferSize
                )
            );
        Assert( dwRegValueType == REG_DWORD );

        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying to read the previous OS major version info.", dwReturnValue );
            break;
        } // if: RegQueryValueEx() failed while reading dwPrevOSMajorVersion

        // Read the OS minor version
        cbBufferSize = sizeof( dwPrevOSMinorVersion );
        dwReturnValue = TW32(
            RegQueryValueExW(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MINOR_VERSION
                , 0
                , &dwRegValueType
                , reinterpret_cast< LPBYTE >( &dwPrevOSMinorVersion )
                , &cbBufferSize
                )
            );
        Assert( dwRegValueType == REG_DWORD );

        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying to read the previous OS minor version info.", dwReturnValue );
            break;
        } // if: RegQueryValueEx() failed while reading dwPrevOSMinorVersion

        LogMsg( "Previous OS major and minor versions were %d and %d respectively.", dwPrevOSMajorVersion, dwPrevOSMinorVersion );
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( dwReturnValue != NO_ERROR )
    {
        LogMsg( "An error occurred trying to read the version information of the previous OS. Proceeding assuming that it was NT4." );
        dwReturnValue = NO_ERROR;
        rdwNodeClusterMajorVersionOut = NT4_MAJOR_VERSION;
    } // if: an error occurred trying to determine the previous OS version
    else
    {
        if ( dwPrevOSMajorVersion == 4 )
        {
            // The previous OS version was NT4 (it does not matter if it was SP3 or SP4 - we will treat
            // both the same way.

            LogMsg( "The previous OS was NT4. We are going to treat NT4SP3 and NT4SP4 nodes the same way for upgrades." );
            rdwNodeClusterMajorVersionOut = NT4_MAJOR_VERSION;
        } // if: the previous OS version was NT4
        else if ( dwPrevOSMajorVersion == 5 )
        {
            if ( dwPrevOSMinorVersion == 0 )
            {
                LogMsg( "The previous OS was Windows 2000." );
                rdwNodeClusterMajorVersionOut = NT5_MAJOR_VERSION;
            } // if: this was a Windows 2000 node
            else if ( dwPrevOSMinorVersion >= 1 )
            {
                LogMsg( "The previous OS was Windows Server 2003." );
                rdwNodeClusterMajorVersionOut = NT51_MAJOR_VERSION;
            } // else if: this was a Windows Server 2003 node
            else
            {
                LogMsg( "The previous OS was neither Windows NT 4.0, Windows 2000, nor Windows Server 2003. An error must have occurred." );
                dwReturnValue = TW32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS );
            } // else: the previous OS was neither NT4, Windows 2000 nor Windows Server 2003
        } // else if: the previous OS major version is 5
        else
        {
            LogMsg( "The previous OS was neither Windows NT 4.0, Windows 2000, nor Windows Server 2003. An error must have occurred." );
            dwReturnValue = TW32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS );
        } // else: the previous OS was neither NT4, Windows 2000 nor Windows Server 2003
    } // if; we read the previous OS version info

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwGetNodeClusterMajorVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCM.cpp
//
//  Description:
//      This file contains the implementation of the entry point used by OC
//      Manager.
//
//  Documentation:
//      [1] 2001 Setup - Architecture.doc
//          Architecture of the DLL for Whistler (Windows 2001)
//
//      [2] 2000 Setup - FuncImpl.doc
//          Contains description of the previous version of this DLL (Windows 2000)
//
//      [3] http://winweb/setup/ocmanager/OcMgr1.doc
//          Documentation about the OC Manager API
//
//  Header File:
//      There is no header file for this source file.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//          Created the original version.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
// Global variables
//////////////////////////////////////////////////////////////////////////////

// The global application object.
CClusOCMApp g_coaTheApp;


/////////////////////////////////////////////////////////////////////////////
//++
//
//  extern "C"
//  DWORD
//  ClusOcmSetupProc
//
//  Description:
//      This is an exported function that the OC Manager uses to communicate
//      with ClusOCM. See document [3] in the header of this file for details.
//
//      This function is just a stub for CClusOCMApp::DwClusOcmSetupProc.
//
//  Arguments:
//      LPCVOID pvComponentIdIn
//          Pointer to a string that uniquely identifies the component.
//
//      LPCVOID pvSubComponentIdIn
//          Pointer to a string that uniquely identifies a sub-component in
//          the component's hiearchy.
//
//      UINT uiFunctionCodeIn
//          A numeric value indicating which function is to be perfomed.
//          See ocmanage.h for the macro definitions.
//
//      UINT uiParam1In
//          Supplies a function specific parameter.
//
//      PVOID pvParam2Inout
//          Pointer to a function specific parameter (either input or
//          output).
//
//  Return Value:
//      A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
DWORD
ClusOcmSetupProc(
      IN        LPCVOID    pvComponentIdIn
    , IN        LPCVOID    pvSubComponentIdIn
    , IN        UINT       uiFunctionCodeIn
    , IN        UINT       uiParam1In
    , IN OUT    PVOID      pvParam2Inout
    )
{
    return g_coaTheApp.DwClusOcmSetupProc(
          pvComponentIdIn
        , pvSubComponentIdIn
        , uiFunctionCodeIn
        , uiParam1In
        , pvParam2Inout
        );
} //*** ClusOcmSetupProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocmapp.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCMApp.inl
//
//  Description:
//      This file contains the definition of the inline functions of the 
//      ClusOCMApp class.
//
//  Header File:
//      ClusOCMApp.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  eClusterInstallState
//  CClusOCMApp::CisSetClusterInstallState
//
//  Description:
//      Set the current cluster installation state.
//
//  Arguments:
//      cisNewStateIn
//          The new installation state.
//
//  Return Value:
//      The previous installation state.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
eClusterInstallState
CClusOCMApp::CisStoreClusterInstallState( eClusterInstallState cisNewStateIn )
{
    eClusterInstallState cisOldState = m_cisCurrentInstallState;

    m_cisCurrentInstallState = cisNewStateIn;

    return cisOldState;
} //*** CClusOCMApp::CisSetClusterInstallState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\clusocmresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCMResources.h
//
//  Description:
//      Contains the definition of the string ids used by this DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define IDS_OCM_START       0

//
// NOTE: Do not change the string ids of the next two strings.
// ClusOCM.inf relies on them being 1 and 2.
//

// Cluster Administrator
#define IDS_CLUADMIN_SHORTCUT                   ( IDS_OCM_START + 1 )

// Configures and manages server clusters
#define IDS_CLUADMIN_INFO_TIP                   ( IDS_OCM_START + 2 )

// Cluster Service
#define IDS_CLUSSVC_DISPLAY_NAME                ( IDS_OCM_START + 3 )

// Enables servers to work together as a cluster to keep server-based applications highly available, regardless of individual component failures.
#define IDS_CLUSSVC_SERVICE_DESC                ( IDS_OCM_START + 4 )

// The ending ID for these strings.
#define IDS_OCM_END         1999
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocmapp.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMApp.h
//
//  Description:
//      ClusOCM.DLL is an Optional Components Manager DLL for installation of
//      Microsoft Cluster Server. This file contains the declaration of the
//      class ClusOCMApp, which is the main class of the ClusOCM DLL.
//
//  Implementation Files:
//      CClusOCMApp.cpp
//      CClusOCMApp.inl
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Contains setup API function declarations
#include <setupapi.h>
 
// For OC Manager definitions, macros, etc.
#include <ocmanage.h>

// For the class CClusOCMTask
#include "CClusOCMTask.h"

// For the smart classes
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusOCMApp
//
//  Description:
//      This is the main class of the ClusOCM DLL. This class receives messages
//      from the OC Manager, takes high level decisions about the installation
//      and passes control appropriately to subobjects.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and Destructors
    //////////////////////////////////////////////////////////////////////////

    CClusOCMApp( void );
    ~CClusOCMApp( void );


    // Receives messages from the OC Manager and dispatches them.
    DWORD
        DwClusOcmSetupProc(
            IN        LPCVOID    pvComponentId
          , IN        LPCVOID    pvSubComponentId
          , IN        UINT       uiFunctionCode
          , IN        UINT       uiParam1
          , IN OUT    PVOID      pvParam2 
          );


    //////////////////////////////////////////////////////////////////////////
    // Public Accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the SETUP_INIT_COMPONENT passed in by OC Manager
    const SETUP_INIT_COMPONENT &
        RsicGetSetupInitComponent( void ) const { return m_sicSetupInitComponent; }

    //
    // Setup state functions
    //

    // Is this an unattended setup?
    bool
        FIsUnattendedSetup( void )  const { return m_fIsUnattendedSetup; }

    // Is this an upgrade?
    bool
        FIsUpgrade( void )  const { return m_fIsUpgrade; }

    // Is this GUI mode setup?
    bool
        FIsGUIModeSetup( void )  const { return m_fIsGUIModeSetup; }

    // Get the current installation state.
    eClusterInstallState
        CisGetClusterInstallState( void )  const { return m_cisCurrentInstallState; }

    // Get the error code of the first error that occurred
    DWORD
        DwGetError( void ) const
    {
        return m_dwFirstError;
    }

    // Report that an error occurred. If an error had already occurred, the new error code is not stored.
    DWORD
        DwSetError( DWORD dwError )
    {
        if ( m_dwFirstError == NO_ERROR )
        {
            m_dwFirstError = dwError;
        }

        return m_dwFirstError;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CClusOCMApp( const CClusOCMApp & );

    // Private assignment operator.
    const CClusOCMApp & operator =(  const CClusOCMApp & );


    //////////////////////////////////////////////////////////////////////////
    // Private Utility Functions.
    //////////////////////////////////////////////////////////////////////////

    // Check if the cluster service exists as a registered service.
    DWORD
        DwIsClusterServiceRegistered( bool * pfIsRegisteredOut ) const;


    // Set the setup init component data and other setup state variables
    void
        SetSetupState( const SETUP_INIT_COMPONENT & sicSourceIn );

    // Store the current installation state.
    eClusterInstallState
        CisStoreClusterInstallState( eClusterInstallState cisNewStateIn );


    // Get a pointer to the current task object. Create it if necessary.
    DWORD
        DwGetCurrentTask( CClusOCMTask *& rpTaskOut );

    // Free the current task object.
    void
        ResetCurrentTask( void )
    {
        m_sptaskCurrentTask.Assign( NULL );
    }

    // Get the major version of the cluster service that we are upgrading.
    // This function call only be called during an upgrade.
    DWORD
        DwGetNodeClusterMajorVersion( DWORD & rdwNodeClusterMajorVersionOut );


    //////////////////////////////////////////////////////////////////////////
    // Private Message Handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_INIT_COMPONENT message.
    DWORD
        DwOcInitComponentHandler(
            PSETUP_INIT_COMPONENT pSetupInitComponentInout
            );

    // Handler for the OC_QUERY_STATE message.
    DWORD
        DwOcQueryStateHandler( UINT uiSelStateQueryTypeIn );


    //////////////////////////////////////////////////////////////////////////
    // Private Data
    //////////////////////////////////////////////////////////////////////////
private:

    // Contains information about this setup session.
    SETUP_INIT_COMPONENT                             m_sicSetupInitComponent;

    // Setup state variables.
    bool                                             m_fIsUnattendedSetup;
    bool                                             m_fIsUpgrade;
    bool                                             m_fIsGUIModeSetup;

    // The current installation state of the cluster service
    eClusterInstallState                             m_cisCurrentInstallState;

    // This variable stores the error code of the first error that occurred.
    DWORD               m_dwFirstError;

    // A smart pointer holding a pointer to the current task being performed.
    CSmartGenericPtr< CPtrTrait< CClusOCMTask > >   m_sptaskCurrentTask;

    // Indicates if the task object has been created or not.
    bool                                             m_fAttemptedTaskCreation;

}; //*** class CClusOCMApp


//////////////////////////////////////////////////////////////////////////////
// Inline Files
//////////////////////////////////////////////////////////////////////////////

#include "CClusOCMApp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocmtask.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMTask.h
//
//  Description:
//      This file contains the declaration of the class CClusOCMTask.
//      This class represents a task performed by ClusOCM. For example, an
//      upgrade of the cluster binaries is a task performed by ClusOCM. It is
//      intended to be used as a base class for other task related classes.
//
//  Implementation Files:
//      CClusOCMTask.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the definition of a few basic types
#include <windows.h>

// Contains setup API function and type declarations
#include <setupapi.h>
 

//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusOCMTask
//
//  Description:
//      This class represents a task performed by ClusOCM. For example, an
//      upgrade of the cluster binaries is a task performed by ClusOCM. It is
//      intended to be used as a base class for other task related classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusOCMTask
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusOCMTask( const CClusOCMApp & rAppIn );

    // Destructor.
    virtual ~CClusOCMTask( void );


    //////////////////////////////////////////////////////////////////////////
    // Virtual message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_CALC_DISK_SPACE message.
    // Note: this handler is not a pure virutal function since its functionality
    // has to remain the same regardless of whether an upgrade or a clean install
    // is in progress. As a result an implementation is provided in this class.
    DWORD
        DwOcCalcDiskSpace(
          bool          fAddFilesIn
        , HDSKSPC       hDiskSpaceListIn
        );

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn ) = 0;

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void ) = 0;

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void ) = 0;


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected accessor functions
    //////////////////////////////////////////////////////////////////////////

    // Get a pointer to the main application object.
    const CClusOCMApp &
        RGetApp( void ) const
    {
        return m_rApp;
    }


    //////////////////////////////////////////////////////////////////////////
    // Other protected virtual methods
    //////////////////////////////////////////////////////////////////////////

    // A helper function that calls the DwSetDirectoryIds() function to set the
    // directory ids and processes the files listed in the input section.
    virtual DWORD
        DwOcQueueFileOps(
          HSPFILEQ hSetupFileQueueIn
        , const WCHAR * pcszInstallSectionNameIn
        );

    // A helper function that performs some of the more common operations
    // done by handlers of the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( const WCHAR * pcszInstallSectionNameIn );

    // A helper function that processes registry operations, COM component
    // registrations, creation of servies, etc., listed in the input section.
    DWORD
    DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn );

    // A helper function that maps the directory id CLUSTER_DEFAULT_INSTALL_DIRID
    // to the  default cluster installation directory CLUSTER_DEFAULT_INSTALL_DIR.
    virtual DWORD
        DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CClusOCMTask( const CClusOCMTask & );

    // Private assignment operator.
    const CClusOCMTask & operator =(  const CClusOCMTask & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The app object
    const CClusOCMApp & m_rApp;

}; //*** class CClusOCMTask
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\commondefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CommonDefs.h
//
//  Description:
//      This file contains a few definitions common to many classes and files.
//
//  Implementation Files:
//      None
//
//  Maintained By:
//      Vij Vasu (Vvasu) 12-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For some basic types
#include <windows.h>

// For smart classes
#include "SmartClasses.h"

// For DIRID_USER
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// The INF section for the clean install of cluster binaries.
#define INF_SECTION_CLEAN_INSTALL L"Clean_Install"

// The INF section for cleaning upon an error during a clean install.
#define INF_SECTION_CLEAN_INSTALL_CLEANUP L"Clean_Install_Cleanup"

// The INF section for the upgrade of cluster binaries from Windows Server 2003 when
// the node is already part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE L"WindowsDotNet_Upgrade"

// The INF section for cleaning upon an error during an upgrade from Windows
// Server 2003 when the node is already part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_CLEANUP L"WindowsDotNet_Upgrade_Cleanup"

// The INF section for the upgrade of cluster binaries from Windows Server 2003 when
// the node is not part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE L"WindowsDotNet_Upgrade_Unclustered"

// The INF section for cleaning upon an error during an upgrade from Windows
// Server 2003 when the node is not part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE_CLEANUP L"WindowsDotNet_Upgrade_Unclustered_Cleanup"

// The INF section for the upgrade of cluster binaries from Windows 2000 when
// the node is already part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE L"Windows2000_Upgrade"

// The INF section for cleaning upon an error during an upgrade from Windows
// 2000 when the node is already partof a cluster.
#define INF_SECTION_WIN2K_UPGRADE_CLEANUP L"Windows2000_Upgrade_Cleanup"

// The INF section for the upgrade of cluster binaries from Windows 2000 when
// the node is not part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE L"Windows2000_Upgrade_Unclustered"

// The INF section for cleaning upon an error during an upgrade from Windows
// 2000 when the node is not part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE_CLEANUP L"Windows2000_Upgrade_Unclustered_Cleanup"

// The INF section for the upgrade of cluster binaries from Windows NT 4.0.
#define INF_SECTION_NT4_UPGRADE L"NT4_Upgrade"

// The INF section for cleaning upon an error during an upgrade from Windows
// NT 4.0.
#define INF_SECTION_NT4_UPGRADE_CLEANUP L"NT4_Upgrade_Cleanup"

// Directory where the cluster files are intalled by default.
#define CLUSTER_DEFAULT_INSTALL_DIR     L"%SystemRoot%\\Cluster"

// Directory id of the above directory.
#define CLUSTER_DEFAULT_INSTALL_DIRID   ( DIRID_USER + 0 )


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

//
// Smart classes
//

// Smart WCHAR array
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >  SmartSz;

// Smart registry handle
typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;

// Smart service handle.
typedef CSmartResource< CHandleTrait< SC_HANDLE, BOOL, CloseServiceHandle > > SmartServiceHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskcleaninstall.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskCleanInstall.h
//
//  Description:
//      This file contains the declaration of the class CTaskCleanInstall.
//      which encapsulates a clean installation of cluster binaries.
//
//  Implementation Files:
//      CTaskCleanInstall.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CClusOCMTask.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskCleanInstall
//
//  Description:
//      This class encapsulates a clean installation of cluster binaries.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskCleanInstall : public CClusOCMTask
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskCleanInstall( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskCleanInstall( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusOCMTask BaseClass;

}; //*** class CTaskCleanInstall
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\cclusocmtask.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusOCMTask.cpp
//
//  Description:
//      Implementation file for the CClusOCMTask class.
//
//  Header File:
//      CClusOCMTask.h
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)    18-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"

// The header file for this module.
#include "CClusOCMTask.h"

// For CClusOCMApp
#include "CClusOCMApp.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CClusOCMTask" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMTask::CClusOCMTask
//
//  Description:
//      Constructor of the CClusOCMTask class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMTask::CClusOCMTask( const CClusOCMApp & rAppIn )
    : m_rApp( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusOCMTask::CClusOCMTask()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMTask::~CClusOCMTask
//
//  Description:
//      Destructor of the CClusOCMTask class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMTask::~CClusOCMTask( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusOCMTask::CClusOCMTask()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCalcDiskSpace
//
//  Description:
//      This funcion handles the OC_CALC_DISK_SPACE messages from the Optional
//      Components Manager. It either adds or removes disk space requirements
//      from the disk space list maintained by the OC Manager. 
//
//      Note that it is important that components should report disk space
//      consistently, and they should not report disk space differently if the
//      component is being installed or uninstalled. As a result, the clean
//      install section of the INF file is always used by this function to
//      calculate disk space.
//
//  Arguments:
//      bool fAddFilesIn
//          If true space requirements are added to the OC Manager disk space
//          list. Requirements are removed from the list otherwise.
//
//      HDSKSPC hDiskSpaceListIn
//          Handle to the OC Manager disk space list.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCalcDiskSpace(
      bool          fAddFilesIn
    , HDSKSPC       hDiskSpaceListIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    if ( fAddFilesIn )
    {
        TraceFlow( "Adding space requirements to disk space list." );
        LogMsg( "Adding space requirements to disk space list." );

        if ( SetupAddInstallSectionToDiskSpaceList(
              hDiskSpaceListIn
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , NULL
            , INF_SECTION_CLEAN_INSTALL
            , 0
            , 0
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to add to disk space requirements list.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to add to disk space requirements list.", dwReturnValue );
        } // if: SetupAddInstallSectionToDiskSpaceList failed
    } // if: the space requirements are to be added
    else
    {
        TraceFlow( "Removing space requirements from disk space list." );
        LogMsg( "Removing space requirements from disk space list." );

        if ( SetupRemoveInstallSectionFromDiskSpaceList(
              hDiskSpaceListIn
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , NULL
            , INF_SECTION_CLEAN_INSTALL
            , 0
            , 0
            ) == FALSE )
        {
            // See Note: above
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to remove disk space requirements from list.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to remove disk space requirements from list.", dwReturnValue );
        } // if: SetupRemoveInstallSectionFromDiskSpaceList failed
    } // else: the space requirements are to be deleted.

    TraceFlow1( "Return Value is 0x%X.", dwReturnValue );
    LogMsg( "Return Value is 0x%X.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCalcDiskSpace()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcQueueFileOps
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_QUEUE_FILE_OPS message.
//
//      This function calls the DwSetDirectoryIds() function to set the
//      directory ids and processes the files listed in the input section.
//      It is meant to be called by derived classes only.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details of the files to be
//          set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcQueueFileOps(
      HSPFILEQ hSetupFileQueueIn
    , const WCHAR * pcszInstallSectionNameIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        dwReturnValue = TW32( DwSetDirectoryIds() );
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow1( "Error %#x occurred while trying to set the directory ids.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to set the directory ids.", dwReturnValue );
            break;
        } // if: DwSetDirectoryIds() failed

        TraceFlow1( "Attempting to queue file operations using section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to queue file operations using section '%ws'.", pcszInstallSectionNameIn );

        if ( SetupInstallFilesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , NULL                                                      // optional, layout INF handle
            , hSetupFileQueueIn                                         // handle to the file queue
            , pcszInstallSectionNameIn                                  // name of the Install section
            , NULL                                                      // optional, root path to source files
            , SP_COPY_NEWER                                             // optional, specifies copy behavior
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to install files.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to install files.", dwReturnValue );
            break;
        } // if: SetupInstallFilesFromInfSection() failed

        TraceFlow( "File ops successfully queued." );
        LogMsg( "File ops successfully queued." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCompleteInstallation
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_COMPLETE_INSTALLATION message.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. listed in the input section are processed by this function.
//      This function is meant to be called by derived classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details registry entries,
//          COM components, etc., that need to be set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        TraceFlow1( "Attempting to setup using the section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to setup using the section '%ws'.", pcszInstallSectionNameIn );

        // Create the required registry entries, register the COM components and
        // create the profile items.
        if ( SetupInstallFromInfSection(
              NULL                                                      // optional, handle of a parent window
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , pcszInstallSectionNameIn                                  // name of the Install section
            , SPINST_REGISTRY | SPINST_REGSVR | SPINST_PROFILEITEMS     // which lines to install from section
            , NULL                                                      // optional, key for registry installs
            , NULL                                                      // optional, path for source files
            , NULL                                                      // optional, specifies copy behavior
            , NULL                                                      // optional, specifies callback routine
            , NULL                                                      // optional, callback routine context
            , NULL                                                      // optional, device information set
            , NULL                                                      // optional, device info structure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to create registry entries.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to create registry entries.", dwReturnValue );
            break;
        } // if: SetupInstallFromInfSection() failed
        
        // Create the required services.
        if ( SetupInstallServicesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the open INF file
            , pcszInstallSectionNameIn                                  // name of the Service section
            , 0                                                         // controls installation procedure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to create the required services.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to create the required services.", dwReturnValue );
            break;
        } // if: SetupInstallServicesFromInfSection() failed

        TraceFlow( "Registry entries and services successfully configured." );
        LogMsg( "Registry entries and services successfully configured." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCleanup
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_CLEANUP message.
//
//      This function processes the registry, COM and profile registration and
//      service entries in the input section. It is meant to be used by derived
//      classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains the entries to be processed
//          during cleanup.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCleanup( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        if ( RGetApp().DwGetError() == NO_ERROR )
        {
            TraceFlow( "No errors have occurred during this task. There is nothing to do during cleanup." );
            LogMsg( "No errors have occurred during this task. There is nothing to do during cleanup." );
            break;
        } // if: this task was error-free

        TraceFlow1( "Attempting to cleanup using section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to cleanup using section '%ws'.", pcszInstallSectionNameIn );

        // Create the required registry entries, register the COM components and
        // create the profile items.
        if ( SetupInstallFromInfSection(
              NULL                                                      // optional, handle of a parent window
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , pcszInstallSectionNameIn                                  // name of the Install section
            , SPINST_REGISTRY | SPINST_REGSVR | SPINST_PROFILEITEMS     // which lines to install from section
            , NULL                                                      // optional, key for registry installs
            , NULL                                                      // optional, path for source files
            , NULL                                                      // optional, specifies copy behavior
            , NULL                                                      // optional, specifies callback routine
            , NULL                                                      // optional, callback routine context
            , NULL                                                      // optional, device information set
            , NULL                                                      // optional, device info structure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to setup registry entries.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to setup registry entries.", dwReturnValue );
            break;
        } // if: SetupInstallFromInfSection() failed

        // Delete the created services.
        if ( SetupInstallServicesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the open INF file
            , pcszInstallSectionNameIn                                  // name of the Service section
            , 0                                                         // controls installation procedure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to setup the services.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to setup the services.", dwReturnValue );
            break;
        } // if: SetupInstallServicesFromInfSection() failed

        TraceFlow( "Cleanup was successful." );
        LogMsg( "Cleanup was successful." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwSetDirectoryIds
//
//  Description:
//      This is a helper function that maps the directory id 
//      CLUSTER_DEFAULT_INSTALL_DIRID to the default cluster installation 
//      directory CLUSTER_DEFAULT_INSTALL_DIR.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwSetDirectoryIds( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        DWORD dwRequiredSize = 0;

        // Determine the size of the buffer needed to hold the cluster directory name.
        dwRequiredSize = ExpandEnvironmentStringsW(
              CLUSTER_DEFAULT_INSTALL_DIR
            , NULL
            , 0
            );

        // Did we get the required size?
        if ( dwRequiredSize == 0 )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to determine the required size of the expanded environment string.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to determine the required size of the expanded environment string.", dwReturnValue );
            break;
        } // if: we could not determine the required size of the buffer

        // Allocate memory for the buffer.
        SmartSz sszDirName( new WCHAR[ dwRequiredSize ] );

        if ( sszDirName.FIsEmpty() )
        {
            dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
            TraceFlow1( "Error: Could not allocate %d bytes for the directory name.", dwRequiredSize );
            LogMsg( "Error: Could not allocate %d bytes for the directory name.", dwRequiredSize );
            break;
        } // if: memory allocation failed

        // Expand any variables in the cluster directory name string.
        dwRequiredSize = ExpandEnvironmentStringsW(
              CLUSTER_DEFAULT_INSTALL_DIR
            , sszDirName.PMem()
            , dwRequiredSize
            );

        // Did we get the required size?
        if ( dwRequiredSize == 0 )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying expand environment variables in the cluster directory name.", dwReturnValue );
            LogMsg( "Error %#x occurred trying expand environment variables in the cluster directory name.", dwReturnValue );
            break;
        } // if: we could not determine the required size of the buffer

        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , sszDirName.PMem()
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying set the default cluster install directory id.", dwReturnValue );
            LogMsg( "Error %#x occurred trying set the default cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        TraceFlow2( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszDirName.PMem() );
        LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszDirName.PMem() );
    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgrade.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgrade.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgrade.
//      This class encapsulates an upgrade of cluster binaries and is
//      meant to be used as a base class by other classes that handle
//      upgrades from a particular OS version.
//
//  Implementation Files:
//      CTaskUpgrade.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CClusOCMTask.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgrade
//
//  Description:
//      This class encapsulates an upgrade of cluster binaries and is
//      meant to be used as a base class by other classes that handle
//      upgrades from a particular OS version.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgrade : public CClusOCMTask
{
public:

protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgrade( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgrade( void );


    //////////////////////////////////////////////////////////////////////////
    // Other protected members
    //////////////////////////////////////////////////////////////////////////

    // Get the directory in which the cluster service binary resides from the
    // Service Control Manager
    DWORD
        DwGetClusterServiceDirectory( const WCHAR *& rpcszDirNamePtrIn );

    // A helper function that processes registry operations, COM component
    // registrations, creation of servies, etc., listed in the input section.
    DWORD
        DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn );

    // Registers a COM component for receiving cluster startup notifications
    HRESULT
        HrRegisterForStartupNotifications( const CLSID & rclsidComponentIn );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusOCMTask BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    
    // Pointer to the cluster service directory.
    SmartSz     m_sszClusterServiceDir;

    // Flag that indicates if the we know the cluster service directory or not.
    bool        m_fClusDirFound;

}; //*** class CTaskUpgrade
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskcleaninstall.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2003 Microsoft Corporation
//
//  Module Name:
//      CTaskCleanInstall.cpp
//
//  Description:
//      Implementation file for the CTaskCleanInstall class.
//
//  Header File:
//      CTaskCleanInstall.h
//
//  Maintained By:
//      David Potter    (DavidP)    18-FEB-2003
//      Vij Vasu        (Vvasu)     18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskCleanInstall.h"



//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskCleanInstall" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCleanInstall::CTaskCleanInstall
//
//  Description:
//      Constructor of the CTaskCleanInstall class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskCleanInstall::CTaskCleanInstall( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );

    //
    // Make sure that this object is being instatiated only when required.
    //

    // Assert that we will install binaries only when none were installed
    // previously.
    Assert( ( rAppIn.CisGetClusterInstallState() == eClusterInstallStateUnknown )
        ||  ( rAppIn.CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
        );


    TraceFuncExit();

} //*** CTaskCleanInstall::CTaskCleanInstall()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCleanInstall::~CTaskCleanInstall
//
//  Description:
//      Destructor of the CTaskCleanInstall class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskCleanInstall::~CTaskCleanInstall( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskCleanInstall::~CTaskCleanInstall()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for a clean install.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_CLEAN_INSTALL ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during a clean install.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_CLEAN_INSTALL ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during a clean install.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_CLEAN_INSTALL_CLEANUP ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcCleanup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradent4.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeNT4.cpp
//
//  Description:
//      Implementation file for the CTaskUpgradeNT4 class.
//
//  Header File:
//      CTaskUpgradeNT4.h
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     18-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"

// The header file for this module.
#include "CTaskUpgradeNT4.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeNT4" )

// Name of the cluster service executable
#define CLUSSVC_EXECUTABLE_NAME             L"ClusSvc.exe"

// Multi-sz string of cluster service dependencies
#define CLUSSVC_DEPENDENCY_MULTISZ          L"ClusNet\0RpcSs\0W32Time\0NetMan"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeNT4::CTaskUpgradeNT4
//
//  Description:
//      Constructor of the CTaskUpgradeNT4 class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeNT4::CTaskUpgradeNT4( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeNT4::CTaskUpgradeNT4()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeNT4::~CTaskUpgradeNT4
//
//  Description:
//      Destructor of the CTaskUpgradeNT4 class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeNT4::~CTaskUpgradeNT4( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeNT4::~CTaskUpgradeNT4()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_NT4_UPGRADE ) );

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Call the base class helper function to perform some registry and service
    // related configuration from the INF file.
    dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_NT4_UPGRADE ) );

    //
    // Change the cluster service display name, description, dependencies, failure actions
    // and executable name.
    //
    while( dwReturnValue == NO_ERROR )
    {
        // Pointer the the cluster service directory.
        const WCHAR *           pcszInstallDir = NULL;

        // Smart pointer to the cluster service display name string.
        SmartSz                 sszClusSvcDispName;

        // Smart pointer to the cluster service description string.
        SmartSz                 sszClusSvcDesc;

        // Smart pointer to the cluster service binary path string.
        SmartSz                 sszClusSvcBinPath;

        // Smart pointer to the cluster service.
        SmartServiceHandle      shClusSvc;

        // Connect to the Service Control Manager
        SmartServiceHandle      shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE ) );
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful

        // Open a handle to the Cluster Service.
        shClusSvc.Assign( OpenService( shServiceMgr, L"ClusSvc", SERVICE_ALL_ACCESS ) );
        if ( shClusSvc.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            break;
        } // if: the handle could not be opened

        // Load the cluster service name string.
        dwReturnValue = DwLoadString( IDS_CLUSSVC_DISPLAY_NAME, sszClusSvcDispName );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying load the display name of the cluster service.", dwReturnValue );
            break;
        } // if: we could not load the cluster service display name string
        LogMsg( "The new cluster service display name is '%ws'.", sszClusSvcDispName.PMem() );

        // Load the cluster service description string.
        dwReturnValue = DwLoadString( IDS_CLUSSVC_SERVICE_DESC, sszClusSvcDesc );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying load the description of the cluster service.", dwReturnValue );
            break;
        } // if: we could not load the cluster service description string
        LogMsg( "The new cluster service description is '%ws'.", sszClusSvcDesc.PMem() );

        //
        // Form the service binary path by appending the name of the cluster service executable to
        // the cluster service directory.
        //

        // Do not free the pointer returned by this call.
        dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
        if ( dwReturnValue != NO_ERROR )
        {
            LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            break;
        } // if: we could not get the cluster service installation directory
        LogMsg( "The cluster service directory is '%ws'.", pcszInstallDir );


        {
            WCHAR *     pszTempPtr;

            // Length of the the install directory string, not including the terminating L'\0'
            size_t      cchInstallDirLen = wcslen( pcszInstallDir );
            
            // Length of the cluster service executable name, including the terminating L'\0'
            size_t      cchClusSvcExeLen = RTL_NUMBER_OF( CLUSSVC_EXECUTABLE_NAME );

            size_t      cchRemaining = cchInstallDirLen + 1 + cchClusSvcExeLen;

            // Allocate memory for the cluster service binary path (the extra character is for the intervening L'\\'.
            sszClusSvcBinPath.Assign( new WCHAR[ cchInstallDirLen + 1 + cchClusSvcExeLen ] );
            if ( sszClusSvcBinPath.FIsEmpty() )
            {
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                LogMsg( "An error occurred trying to allocate memory for the cluster service binary path." );
                break;
            } // if: an error occurred trying to allocate memory for the cluster service binary path

            pszTempPtr = sszClusSvcBinPath.PMem();

            // Copy the install directory string to the newly allocated buffer.
            THR( StringCchCopyNExW( pszTempPtr, cchRemaining, pcszInstallDir, cchInstallDirLen, &pszTempPtr, &cchRemaining, 0 ) );

            // Copy the trailing L'\\' character
            *(pszTempPtr++) = L'\\';
            cchRemaining--;

            // Copy the cluster service executable name.
            THR( StringCchCopyNW( pszTempPtr, cchRemaining, CLUSSVC_EXECUTABLE_NAME, cchClusSvcExeLen ) );

            LogMsg( "The new cluster service binary path is '%ws'.", sszClusSvcBinPath.PMem() );
        }

        // Change the binary path, dependency list and display name.
        if (    ChangeServiceConfig(
                      shClusSvc.HHandle()           // handle to service
                    , SERVICE_NO_CHANGE             // type of service
                    , SERVICE_NO_CHANGE             // when to start service
                    , SERVICE_NO_CHANGE             // severity of start failure
                    , sszClusSvcBinPath.PMem()      // service binary file name
                    , NULL                          // load ordering group name
                    , NULL                          // tag identifier
                    , CLUSSVC_DEPENDENCY_MULTISZ    // array of dependency names
                    , NULL                          // account name
                    , NULL                          // account password
                    , sszClusSvcDispName.PMem()     // display name
                    )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying to change the cluster service configuration.", dwReturnValue );
            break;
        } // if: ChangeServiceConfig() failed
        LogMsg( "The cluster service binary path, dependency list and display name have been changed." );

        // Change the service description
        {
            SERVICE_DESCRIPTION sdServiceDescription;

            sdServiceDescription.lpDescription = sszClusSvcDesc.PMem();
            if (    ChangeServiceConfig2(
                          shClusSvc.HHandle()           // handle to service
                        , SERVICE_CONFIG_DESCRIPTION    // information level
                        , &sdServiceDescription         // new data
                        )
                 == FALSE
               )
            {
                dwReturnValue = TW32( GetLastError() );
                LogMsg( "Error %#x occurred trying to change the cluster service description.", dwReturnValue );
                break;
            } // if: ChangeServiceConfig2() failed
        }

        LogMsg( "The cluster service description has been changed." );

        // Change the cluster service failure actions.
        dwReturnValue = TW32( ClRtlSetSCMFailureActions( NULL ) );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying to set the cluster service failure actions.", dwReturnValue );
            break;
        } // if: ClRtlSetSCMFailureActions() failed
        LogMsg( "The cluster service failure actions have been changed." );

        LogMsg( "The cluster service configuration has been changed." );
        break;
    } // while: the call to the base class function has succeeded

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_NT4_UPGRADE_CLEANUP ) );

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The cluster installation directory is got from the service control
//      manager, since it is possible the the cluster binaries are installed
//      in a non-default location.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwSetDirectoryIds()
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        const WCHAR * pcszInstallDir = NULL;

        // If we are here, the this node is already a part of a cluster. So, get the
        // installation directory from SCM.

        LogMsg( "This node is part of a cluster. Trying to determine the installation directory." );

        // Do not free the pointer returned by this call.
        dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
        if ( dwReturnValue != NO_ERROR )
        {
            LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            break;
        } // if: we could not get the cluster service installation directory


        LogMsg( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );

        // Create the mapping between the directory id and the path
        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , pcszInstallDir
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgrade.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgrade.cpp
//
//  Description:
//      Implementation file for the CTaskUpgrade class.
//
//  Header File:
//      CTaskUpgrade.h
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     18-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"
#include <Common.h>

// The header file for this module.
#include "CTaskUpgrade.h"

// For COM category operations
#include <comcat.h>

// To define guid values
#include <initguid.h>

// For CLSID_ClusCfgResTypeGenScript and CLSID_ClusCfgResTypeMajorityNodeSet
#include <guids.h>

// For CATID_ClusCfgStartupListeners
#include <ClusCfgGuids.h>


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgrade" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgrade::CTaskUpgrade
//
//  Description:
//      Constructor of the CTaskUpgrade class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgrade::CTaskUpgrade( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
    , m_fClusDirFound( false )
{
    TraceFunc( "" );

    //
    // Make sure that this object is being instatiated only when required.
    //

    // Assert that this is an upgrade.
    Assert( rAppIn.FIsUpgrade() != false );

    // Assert that we will upgrade binaries only if they were previously
    // installed
    Assert( rAppIn.CisGetClusterInstallState() != eClusterInstallStateUnknown );

    TraceFuncExit();

} //*** CTaskUpgrade::CTaskUpgrade()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgrade::~CTaskUpgrade
//
//  Description:
//      Destructor of the CTaskUpgrade class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgrade::~CTaskUpgrade( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgrade::~CTaskUpgrade()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgrade::DwOcCompleteInstallation
//
//  Description:
//      This is a helper function that performs some of the more common
//      operations done by handlers of the OC_COMPLETE_INSTALLATION message.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. listed in the input section are processed by this function.
//      This function is meant to be called by derived classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details registry entries,
//          COM components, etc., that need to be set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgrade::DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Call the base class helper function to perform some registry and service
    // related configuration from the INF file.
    dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( pcszInstallSectionNameIn ) );

    //
    // Register the Generic Script resource type extension for cluster startup notifications
    //

    if ( dwReturnValue == NO_ERROR )
    {
        HRESULT hrTemp;

        TraceFlow( "Attempting to register the Generic Script resource type extension for cluster startup notifications." );
        LogMsg( "Attempting to register the Generic Script resource type extension for cluster startup notifications." );

        hrTemp = THR( HrRegisterForStartupNotifications( CLSID_ClusCfgResTypeGenScript ) );
        if ( FAILED( hrTemp ) )
        {
            // This is not a fatal error. So, log it and continue.
            TraceFlow1( "Non-fatal error %#x occurred registering the Generic Script resource type extension for cluster startup notifications." , hrTemp );
            LogMsg( "Non-fatal error %#x occurred registering the Generic Script resource type extension for cluster startup notifications." , hrTemp );

        } // if: we could not register the Generic Script resource type extension for cluster startup notifications
        else
        {
            TraceFlow( "Successfully registered the Generic Script resource type extension for cluster startup notifications." );
            LogMsg( "Successfully registered the Generic Script resource type extension for cluster startup notifications." );
        } // else: the registration was successful
    } // if: the call to the base class function succeeded

    //
    // Register the Majority Node Set resource type extension for cluster startup notifications
    //

    if ( dwReturnValue == NO_ERROR )
    {
        HRESULT hrTemp;

        TraceFlow( "Attempting to register the Majority Node Set resource type extension for cluster startup notifications." );
        LogMsg( "Attempting to register the Majority Node Set resource type extension for cluster startup notifications." );

        hrTemp = THR( HrRegisterForStartupNotifications( CLSID_ClusCfgResTypeMajorityNodeSet ) );
        if ( FAILED( hrTemp ) )
        {
            // This is not a fatal error. So, log it and continue.
            TraceFlow1( "Non-fatal error %#x occurred registering the Majority Node Set resource type extension for cluster startup notifications." , hrTemp );
            LogMsg( "Non-fatal error %#x occurred registering the Majority Node Set resource type extension for cluster startup notifications." , hrTemp );

        } // if: we could not register the Majority Node Set resource type extension for cluster startup notifications
        else
        {
            TraceFlow( "Successfully registered the Majority Node Set resource type extension for cluster startup notifications." );
            LogMsg( "Successfully registered the Majority Node Set resource type extension for cluster startup notifications." );
        } // else: the registration was successful
    } // if: the call to the base class function succeeded

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgrade::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgrade::DwGetClusterServiceDirectory
//
//  Description:
//      This function returns a pointer to the directory in which the cluster
//      service binaries are installed. This memory pointed to by this pointer
//      should not be freed by the caller.
//
//  Arguments:
//      const WCHAR *& rpcszDirNamePtrIn
//          Reference to the pointer to install directory. The caller should not
//          free this memory.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgrade::DwGetClusterServiceDirectory( const WCHAR *& rpcszDirNamePtrIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD           dwReturnValue = NO_ERROR;

    // Check if we have already got the cluster service directory. If we already have,
    // then return this value.
    while( !m_fClusDirFound )
    {
        // Instantiate a smart pointer to the QUERY_SERVICE_CONFIG structure.
        typedef CSmartGenericPtr< CPtrTrait< QUERY_SERVICE_CONFIG > > SmartServiceConfig;

        // Connect to the Service Control Manager
        SmartServiceHandle      shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Some arbitrary value.
        DWORD                   cbServiceConfigBufSize = 256;

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );

        // Was the handle to the service opened?
        if ( shService.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            break;
        } // if: the handle could not be opened

        do
        {
            DWORD               cbRequiredSize = 0;

            // Allocate memory for the service configuration info buffer. The memory is automatically freed when the
            // object is destroyed.
            SmartServiceConfig  spscServiceConfig( reinterpret_cast< QUERY_SERVICE_CONFIG * >( new BYTE[ cbServiceConfigBufSize ] ) );

            // Did the memory allocation succeed
            if ( spscServiceConfig.FIsEmpty() )
            {
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                TraceFlow( "Error: There was not enough memory to get the cluster service configuration information." );
                LogMsg( "Error: There was not enough memory to get the cluster service configuration information." );
                break;
            } // if: memory allocation failed

            // Get the configuration information.
            if (    QueryServiceConfig(
                          shService.HHandle()
                        , spscServiceConfig.PMem()
                        , cbServiceConfigBufSize
                        , &cbRequiredSize
                        )
                 == FALSE
               )
            {
                dwReturnValue = GetLastError();
                if ( dwReturnValue != ERROR_INSUFFICIENT_BUFFER )
                {
                    TW32( dwReturnValue );
                    TraceFlow1( "Error %#x occurred trying to get the cluster service configuration information.", dwReturnValue );
                    LogMsg( "Error %#x occurred trying to get the cluster service configuration information.", dwReturnValue );
                    break;
                } // if: something has really gone wrong

                // We need to allocate more memory - try again
                dwReturnValue = NO_ERROR;
                cbServiceConfigBufSize = cbRequiredSize;
            } // if: QueryServiceConfig() failed
            else
            {
                // Find the last backslash character in the service binary path.
                WCHAR * pszPathName = spscServiceConfig.PMem()->lpBinaryPathName;
                WCHAR * pszLastBackslash = wcsrchr( pszPathName, L'\\' );

                if ( pszLastBackslash != NULL )
                {
                    // Terminate the string here.
                    *pszLastBackslash = L'\0';
                } // if: we found the last backslash

                // Move the service binary path to the beginning of the buffer.
                MoveMemory( spscServiceConfig.PMem(), pszPathName, ( wcslen( pszPathName ) + 1 ) * sizeof( *pszPathName ) );

                // Store the pointer to the buffer in the member variable and
                // detach this memory from the smart pointer (this will not delete the memory).
                m_sszClusterServiceDir.Assign( reinterpret_cast< WCHAR * >( spscServiceConfig.PRelease() ) );

                // Indicate the we have successfully found the cluster service directory.
                m_fClusDirFound = true;

                break;
            } // else: QueryServiceConfig() has succeeded
        }
        while( true ); // while: loop infinitely

        // We are done
        break;
    }

    // Initialize the output.
    rpcszDirNamePtrIn = m_sszClusterServiceDir.PMem();


    LogMsg( "Return Value is %#x.", dwReturnValue );
    TraceFlow1( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgrade::DwGetClusterServiceDirectory()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskUpgrade::HrRegisterForStartupNotifications
//
//  Description:
//      This function registers a COM component for receiving cluster startup
//      notifications.
//
//  Arguments:
//      const CLSID & rclsidComponentIn
//          Reference to the CLSID of the component that is to receive cluster
//          startup notifications.
//
//  Return Value:
//      S_OK if all went well.
//      Other HRESULTS failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskUpgrade::HrRegisterForStartupNotifications( const CLSID & rclsidComponentIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    HRESULT hr = S_OK;

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    do
    {
        CSmartIfacePtr< ICatRegister > spcrCatReg;

        {
            ICatRegister * pcrCatReg = NULL;

            hr = THR(
                CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , __uuidof( pcrCatReg )
                    , reinterpret_cast< void ** >( &pcrCatReg )
                    )
                );

            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to create the StdComponentCategoriesMgr component.", hr );
                TraceFlow1( "Error %#x occurred trying to create the StdComponentCategoriesMgr component.", hr );
                break;
            } // if: we could not create the StdComponentCategoriesMgr component

            // Assign to a smart pointer for automatic release.
            spcrCatReg.Attach( pcrCatReg );
        }

        {
            CATID   rgCatId[ 1 ];

            rgCatId[ 0 ] = CATID_ClusCfgStartupListeners;

            hr = THR(
                spcrCatReg->RegisterClassImplCategories( rclsidComponentIn, ARRAYSIZE( rgCatId ), rgCatId ) );

            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to register the component for cluster startup notifications.", hr );
                TraceFlow1( "Error %#x occurred during the call to ICatRegister::UnRegisterClassImplCategories().", hr );
                break;
            } // if: we could not register the component for startup notifications
        }

        LogMsg( "Successfully registered for startup notifications." );
        TraceFlow( "Successfully registered for startup notifications." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    CoUninitialize();

    LogMsg( "Return Value is %#x.", hr );
    TraceFlow1( "Return Value is %#x.", hr );

    HRETURN( hr );

} //*** CTaskUpgrade::HrRegisterForStartupNotifications()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradewhistler.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWhistler.cpp
//
//  Header File:
//      CTaskUpgradeWhistler.h
//
//  Description:
//      Implementation file for the CTaskUpgradeWindowsDotNet class.
//
//  Maintained By:
//      David Potter    (DavidP)    07-SEP-2001
//      Vij Vasu        (Vvasu)     18-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"

// The header file for this module.
#include "CTaskUpgradeWhistler.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeWindowsDotNet" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::CTaskUpgradeWindowsDotNet
//
//  Description:
//      Constructor of the CTaskUpgradeWindowsDotNet class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWindowsDotNet::CTaskUpgradeWindowsDotNet(
    const CClusOCMApp & rAppIn
    )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWindowsDotNet::CTaskUpgradeWindowsDotNet


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::~CTaskUpgradeWindowsDotNet
//
//  Description:
//      Destructor of the CTaskUpgradeWindowsDotNet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWindowsDotNet::~CTaskUpgradeWindowsDotNet( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWindowsDotNet::~CTaskUpgradeWindowsDotNet


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindowsDotNet::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WHISTLER_UPGRADE ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindowsDotNet::DwOcQueueFileOps


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindowsDotNet::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WHISTLER_UPGRADE ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindowsDotNet::DwOcCompleteInstallation


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindowsDotNet::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE_CLEANUP ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WHISTLER_UPGRADE_CLEANUP ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindowsDotNet::DwOcCleanup


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindowsDotNet::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The location of the cluster binaries is read from the registry
//      and the cluster installation directory is mapped to this value.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindowsDotNet::DwSetDirectoryIds( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD               dwReturnValue = NO_ERROR;
    SmartRegistryKey    srkNodeDataKey;
    SmartSz             sszInstallDir;
    DWORD               cbBufferSize    = 0;
    DWORD               dwType          = REG_SZ;

    {
        HKEY hTempKey = NULL;

        // Open the node data registry key
        dwReturnValue = TW32(
            RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE
                , CLUSREG_KEYNAME_NODE_DATA
                , 0
                , KEY_READ
                , &hTempKey
                )
            );

        if ( dwReturnValue != NO_ERROR )
        {
            LogMsg( "Error %#x occurred trying open the registry key where the cluster install path is stored.", dwReturnValue );
            goto Cleanup;
        } // if: RegOpenKeyEx() failed

        // Store the opened key in a smart pointer for automatic close.
        srkNodeDataKey.Assign( hTempKey );
    }

    // Get the required size of the buffer.
    dwReturnValue = TW32(
        RegQueryValueExW(
              srkNodeDataKey.HHandle()          // handle to key to query
            , CLUSREG_INSTALL_DIR_VALUE_NAME    // name of value to query
            , 0                                 // reserved
            , NULL                              // address of buffer for value type
            , NULL                              // address of data buffer
            , &cbBufferSize                     // address of data buffer size
            )
        );

    if ( dwReturnValue != NO_ERROR )
    {
        LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
        goto Cleanup;
    } // if: an error occurred trying to read the CLUSREG_INSTALL_DIR_VALUE_NAME registry value

    // Allocate the required buffer.
    sszInstallDir.Assign( reinterpret_cast< WCHAR * >( new BYTE[ cbBufferSize ] ) );
    if ( sszInstallDir.FIsEmpty() )
    {
        LogMsg( "An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
        dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
        goto Cleanup;
    } // if: a memory allocation failure occurred

    // Read the value.
    dwReturnValue = TW32( 
        RegQueryValueExW(
              srkNodeDataKey.HHandle()                              // handle to key to query
            , CLUSREG_INSTALL_DIR_VALUE_NAME                        // name of value to query
            , 0                                                     // reserved
            , &dwType                                               // address of buffer for value type
            , reinterpret_cast< LPBYTE >( sszInstallDir.PMem() )    // address of data buffer
            , &cbBufferSize                                         // address of data buffer size
            )
        );
    Assert( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) );

    // Was the key read properly?
    if ( dwReturnValue != NO_ERROR )
    {
        LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
        goto Cleanup;
    } // if: RegQueryValueEx failed.

    // Create the mapping between the directory id and the path
    if ( SetupSetDirectoryId(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , CLUSTER_DEFAULT_INSTALL_DIRID
            , sszInstallDir.PMem()
            )
         == FALSE
       )
    {
        dwReturnValue = TW32( GetLastError() );
        LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
        goto Cleanup;
    } // if: SetupSetDirectoryId() failed

    LogMsg( "The id %d maps to '%s'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszInstallDir.PMem() );

Cleanup:

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindowsDotNet::DwSetDirectoryIds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <LogSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradent4.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeNT4.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeNT4.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Implementation Files:
//      CTaskUpgradeNT4.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeNT4
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeNT4 : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeNT4( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeNT4( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CTaskUpgradeNT4( const CTaskUpgradeNT4 & );

    // Private assignment operator.
    const CTaskUpgradeNT4 & operator =( const CTaskUpgradeNT4 & );

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)        25-MAR-2002
//      Vij Vasu        (Vvasu)         25-JAN-2001
//      Geoff Pease     (GPease)        18-OCT-1999
//
//  Notes:
//      The file Mgmt\Inc\DllSrc.cpp is not included in this file
//      because the inclusion of that file requires that the library
//      Mgmt\ClusCfg\Common\$(O)\Common.lib be linked with this DLL. Also,
//      the header file Guids.h from Mgmt\ClusCfg\Inc will be needed.
//      (DllSrc.cpp requires CFactorySrc.cpp which requires CITrackerSrc.cpp
//      which requires InterfaceTableSrc.cpp which needs Guids.h)
//
//      Since I didn't wan't to "reach across" to the ClusCfg directory (and
//      since this DLL does not need class factories, interface tracking, etc.)
//      ClusOCM has it's own Dll.cpp.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "Pch.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// For tracing
DEFINE_MODULE("CLUSOCM")

#include <DllSrc.cpp>

#if 0
//////////////////////////////////////////////////////////////////////////////
// Global Variables
//////////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL.
HINSTANCE g_hInstance = NULL;

LPVOID g_GlobalMemoryList = NULL;

// Name of the DLL
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };


#if !defined(NO_DLL_MAIN) || defined(ENTRY_PREFIX) || defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
// __declspec( dllexport )
// BOOL
// WINAPI
// DLLMain(
//      HANDLE  hInstIn,
//      ULONG   ulReasonIn,
//      LPVOID  lpReservedIn
//      )
//
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
__declspec( dllexport ) BOOL WINAPI
DllMain(
    HANDLE  hInstIn,
    ULONG   ulReasonIn,
    LPVOID  // lpReservedIn
    )
{
     BOOL fReturnValue = TRUE;
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
        case DLL_PROCESS_ATTACH:
        {
#if defined(USE_WMI_TRACING)
            TraceInitializeProcess( g_rgTraceControlGuidList, RTL_NUMBER_OF( g_rgTraceControlGuidList ), TRUE );
#else
            TraceInitializeProcess( TRUE );
#endif

#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_PROCESS_ATTACH - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
            g_hInstance = (HINSTANCE) hInstIn;

#if defined( ENTRY_PREFIX )
             hProxyDll = g_hInstance;
#endif

            GetModuleFileNameW( g_hInstance, g_szDllFilename, RTL_NUMBER_OF( g_szDllFilename ) );

            //
            // Create a global memory list so that memory allocated by one
            // thread and handed to another can be tracked without causing
            // unnecessary trace messages.
            //
            TraceCreateMemoryList( g_GlobalMemoryList );

        } // case: DLL_PROCESS_ATTACH
        break;


        case DLL_PROCESS_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_PROCESS_DETACH - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG

            //
            // Cleanup the global memory list used to track memory allocated
            // in one thread and then handed to another.
            //
            TraceTerminateMemoryList( g_GlobalMemoryList );

#if defined(USE_WMI_TRACING)
            TraceTerminateProcess( g_rgTraceControlGuidList, RTL_NUMBER_OF( g_rgTraceControlGuidList ) );
#else
            TraceTerminateProcess();
#endif

        } // case: DLL_PROCESS_DETACH
        break;


        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
#if defined( DEBUG )
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"The thread %#x has started.",
                          GetCurrentThreadId( ) );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_THREAD_ATTACH - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
        } // case: DLL_THREAD_ATTACH
        break;


        case DLL_THREAD_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: DLL_THREAD_DETACH - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
            TraceThreadRundown( );
        } // case: DLL_THREAD_DETACH
        break;


        default:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          L"DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x",
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
        } // case: default
        break;
    }

    return fReturnValue;

#else // !NO_THREAD_OPTIMIZATIONS

    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );
#if defined(DEBUG)
#if defined(USE_WMI_TRACING)
    TraceInitializeProcess( g_rgTraceControlGuidList,
                            RTL_NUMBER_OF( g_rgTraceControlGuidList )
                            );
#else
    TraceInitializeProcess();
#endif
#endif // DEBUG

    g_hInstance = (HINSTANCE) hInstIn;

#if defined( ENTRY_PREFIX )
     hProxyDll = g_hInstance;
#endif

    GetModuleFileNameW( g_hInstance, g_szDllFilename, RTL_NUMBER_OF( g_szDllFilename ) );
    fReturnValue = DisableThreadLibraryCalls( g_hInstance );
    AssertMsg( fReturnValue, "*ERROR* DisableThreadLibraryCalls( ) failed."  );

    return fReturnValue;

#endif // NO_THREAD_OPTIMIZATIONS

} //*** DllMain()
#endif // !defined(NO_DLL_MAIN) && !defined(ENTRY_PREFIX) && !defined(DEBUG)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradewhistler.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWhistler.h
//
//  Implementation Files:
//      CTaskUpgradeWhistler.cpp
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeWindowsDotNet.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Maintained By:
//      David Potter    (DavidP)    07-SEP-2001
//      Vij Vasu        (Vvasu)     26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CTaskUpgradeWindowsDotNet;

//////////////////////////////////////////////////////////////////////////////
// External Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeWindowsDotNet
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeWindowsDotNet : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeWindowsDotNet( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeWindowsDotNet( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CTaskUpgradeWindowsDotNet( const CTaskUpgradeWindowsDotNet & );

    // Private assignment operator.
    const CTaskUpgradeWindowsDotNet & operator =( const CTaskUpgradeWindowsDotNet & );

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeWindowsDotNet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradewin2k.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWin2k.cpp
//
//  Header File:
//      CTaskUpgradeWin2k.h
//
//  Description:
//      Implementation file for the CTaskUpgradeWindows2000 class.
//
//  Maintained By:
//      David Potter    (DavidP)    07-SEP-2001
//      Vij Vasu        (Vvasu)     18-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "Pch.h"

// The header file for this module.
#include "CTaskUpgradeWin2k.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeWindows2000" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::CTaskUpgradeWindows2000
//
//  Description:
//      Constructor of the CTaskUpgradeWindows2000 class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWindows2000::CTaskUpgradeWindows2000( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWindows2000::CTaskUpgradeWindows2000


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::~CTaskUpgradeWindows2000
//
//  Description:
//      Destructor of the CTaskUpgradeWindows2000 class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWindows2000::~CTaskUpgradeWindows2000( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWindows2000::~CTaskUpgradeWindows2000


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindows2000::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WIN2K_UPGRADE ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindows2000::DwOcQueueFileOps


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindows2000::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WIN2K_UPGRADE ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindows2000::DwOcCompleteInstallation


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindows2000::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE_CLEANUP ) );
    } // if: the node is not part of a cluster
    else
    {
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WIN2K_UPGRADE_CLEANUP ) );
    } // else: the node is part of a cluster

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindows2000::DwOcCleanup


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWindows2000::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The behavior of this function is different for different cluster
//      installation states.
//      
//      If the cluster binaries are installed, but the node is not part
//      of a cluster, the cluster installation directory is set to the
//      default value.
//
//      If the node is already a part of a cluster, the cluster installation
//      directory is got from the service control manager, since it is possible
//      the the cluster binaries are installed in a non-default location if
//      this node was upgraded from NT4 previously.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWindows2000::DwSetDirectoryIds( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD           dwReturnValue = NO_ERROR;
    const WCHAR *   pcszInstallDir = NULL;

    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        // If the cluster binaries have been install previously, and the node is
        // not part of a cluster, the binaries have to be installed in the default
        // location. This is because the binaries were always installed in the 
        // default location in Win2k and it is not possible to be in this state
        // on a Win2k node by upgrading from NT4.

        // The base class helper function does everything that we need to do here.
        // So, just call it.


        LogMsg( "This node is not part of a cluster. Upgrading files in the default directory." );

        dwReturnValue = TW32( BaseClass::DwSetDirectoryIds() );

        // We are done.
        goto Cleanup;
    } // if: the node is not part of a cluster

    // If we are here, the this node is already a part of a cluster. So, get the
    // installation directory from SCM.

    LogMsg( "This node is part of a cluster. Trying to determine the installation directory." );

    // Do not free the pointer returned by this call.
    dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
    if ( dwReturnValue != NO_ERROR )
    {
        LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
        goto Cleanup;
    } // if: we could not get the cluster service installation directory

    LogMsg( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );

    // Create the mapping between the directory id and the path
    if ( SetupSetDirectoryId(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , CLUSTER_DEFAULT_INSTALL_DIRID
            , pcszInstallDir
            )
         == FALSE
       )
    {
        dwReturnValue = TW32( GetLastError() );
        LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
        goto Cleanup;
    } // if: SetupSetDirectoryId() failed

    LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );

Cleanup:

    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWindows2000::DwSetDirectoryIds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\ctaskupgradewin2k.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWin2k.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeWindows2000.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Implementation Files:
//      CTaskUpgradeWin2k.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    07-SEP-2001
//      Vij Vasu        (Vvasu)     26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CTaskUpgradeWindows2000;

//////////////////////////////////////////////////////////////////////////////
// External Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeWindows2000
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeWindows2000 : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeWindows2000( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeWindows2000( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CTaskUpgradeWindows2000( const CTaskUpgradeWindows2000 & );

    // Private assignment operator.
    const CTaskUpgradeWindows2000 & operator =( const CTaskUpgradeWindows2000 & );

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeWindows2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\globalfuncs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.h
//
//  Description:
//      Contains the declarations of a few unrelated global functions
//      and variables
//
//  Implementation Files:
//      GlobalFuncs.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 06-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the SmartSz type
#include "CommonDefs.h"


//////////////////////////////////////////////////////////////////////////
// Global variable declarations.
//////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL.
extern HINSTANCE g_hInstance;


//////////////////////////////////////////////////////////////////////////
// Global function declarations.
//////////////////////////////////////////////////////////////////////////

// Allocate memory for and load a string from the string table.
DWORD
DwLoadString(
      UINT      nStringIdIn
    , SmartSz & rsszDestOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\globalfuncs.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.cpp
//
//  Description:
//      Contains the definitions of a few unrelated global functions
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     06-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DwLoadString()
//
//  Description:
//      Allocate memory for and load a string from the string table.
//
//  Arguments:
//      uiStringIdIn
//          Id of the string to look up
//
//      rsszDestOut
//          Reference to the smart pointer to the loaded string.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other Win32 error codes
//          If the call failed.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwLoadString(
      UINT      nStringIdIn
    , SmartSz & rsszDestOut
    )
{
    TraceFunc( "" );

    DWORD     dwError = ERROR_SUCCESS;

    UINT        uiCurrentSize = 0;
    SmartSz     sszCurrentString;
    UINT        uiReturnedStringLen = 0;

    do
    {
        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        sszCurrentString.Assign( new WCHAR[ uiCurrentSize ] );
        if ( sszCurrentString.FIsEmpty() )
        {
            dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
            TraceFlow2( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadStringW(
                                  g_hInstance
                                , nStringIdIn
                                , sszCurrentString.PMem()
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            dwError = TW32( GetLastError() );
            TraceFlow2( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    if ( dwError == ERROR_SUCCESS )
    {
        rsszDestOut = sszCurrentString;
    } // if: there were no errors in this function
    else
    {
        rsszDestOut.PRelease();
    } // else: something went wrong

    RETURN( dwError );

} //*** DwLoadString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\loadstring.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoadString.cpp
//
//  Description:
//      LoadStringIntoBSTR implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    01-FEB-2001
//      Geoffrey Pease  (GPease)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"

#include "LoadStringSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\clusocm\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the ClusOCM DLL.
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )

#define DEBUG
#endif


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

#include <windows.h>

// Contains setup API function declarations
#include <setupapi.h>

// For OC Manager definitions, macros, etc.
#include <ocmanage.h>

#include <StrSafe.h>

// For tracing and debugging functions
#include <Debug.h>

// For Logging functions
#include <Log.h>

// A few common definitions, macros, etc.
#include "CommonDefs.h"

// For resource ids
#include "ClusOCMResources.h"

// For ClusRtl functions
#include "ClusRTL.h"

// For the names of several cluster service related registry keys and values
#include "clusudef.h"

// For CClusOCMApp
#include "CClusOCMApp.h"

// For the declarations of a few unrelated global functions and variables
#include "GlobalFuncs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\getcomputername.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GetComputerName.cpp
//
//  Description:
//      Getting and setting the computer name.
//
//  Maintained By:
//      Galen Barbee (GalenB)   31-MAR-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#include "GetComputerNameSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;

//#define CELEMENTS( x )  RTL_NUMBER_OF( x )


//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <wchar.h>
#include <Dsgetdc.h>
#include <Lm.h>

#include <StrSafe.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>

#include <LoadString.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\formaterrormessage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      FormatErrorMessage.cpp
//
//  Description:
//      Error message formatting routines.
//
//  Maintained By:
//      David Potter (davidp)   31-MAR-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <wchar.h>

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  WINAPI
//  HrFormatErrorMessage(
//      LPWSTR  pszErrorOut,
//      UINT    nMxErrorIn,
//      DWORD   scIn
//      )
//
//  Routine Description:
//      Format the error message represented by the status code.  Works for
//      HRESULTS as well.
//
//  Arguments:
//      pszErrorOut -- Unicode string in which to return the error message.
//      nMxErrorIn  -- Maximum length of the output string.
//      scIn        -- Status code.
//
//  Return Value:
//      S_OK        Status code formatted successfully.
//      Other HRESULTs from FormatMessageW().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
HrFormatErrorMessage(
    LPWSTR  pszErrorOut,
    UINT    nMxErrorIn,
    DWORD   scIn
    )
{
    HRESULT     hr = S_OK;
    DWORD       cch;

    TraceFunc( "" );

    // Format the NT status code from the system.
    cch = FormatMessageW(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    scIn,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                    pszErrorOut,
                    nMxErrorIn,
                    0
                    );
    if ( cch == 0 )
    {
        hr = GetLastError();
        hr = THR( HRESULT_FROM_WIN32( hr ) );
        //Trace( g_tagError, _T("Error %d getting message from system for error code %d"), GetLastError(), sc );

        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        cch = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        GetModuleHandleW( L"NTDLL.DLL" ),
                        scIn,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                        pszErrorOut,
                        nMxErrorIn,
                        0
                        );
        if ( cch == 0 )
        {
            hr = GetLastError();
            hr = THR( HRESULT_FROM_WIN32( hr ) );
#ifdef _DEBUG

            //DWORD   _sc = GetLastError();
            //Trace( g_tagError, _T("Error %d getting message from NTDLL.DLL for error code %d"), _sc, sc );

#endif

            pszErrorOut[ 0 ] = L'\0';

        } // if: error formatting status code from NTDLL
        else
        {
            hr = S_OK;
        } // else: successfully formatted the status code
    } // if: error formatting status code from system

    HRETURN( hr );

} //*** HrFormatErrorMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  __cdecl
//  HrFormatErrorMessageBoxText(
//      LPWSTR  pszMessageOut,
//      UINT    nMxMessageIn,
//      HRESULT hrIn,
//      LPCWSTR pszOperationIn,
//      ...
//      )
//
//  Routine Description:
//      Format the error message represented by the status code.  Works for
//      HRESULTS as well.
//
//  Arguments:
//      pszMessageOut   -- Unicode string in which to return the message.
//      nMxMessageIn    -- Size of the output buffer.
//      hrIn            -- Status code.
//      pszOperationIn  -- Operational format message
//      ...             -- Arguments for the operational format string.
//
//  Return Value:
//      S_OK        Text formatted successfully.
//      Other HRESULTs from FormatErrorMessage().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
__cdecl
HrFormatErrorMessageBoxText(
    LPWSTR  pszMessageOut,
    UINT    nMxMessageIn,
    HRESULT hrIn,
    LPCWSTR pszOperationIn,
    ...
    )
{
    HRESULT     hr = S_OK;
    va_list     valMarker;

    TraceFunc( "" );

    WCHAR   szErrorMsg[ 1024 ];
    WCHAR   szOperation[ 2048 ];

    hr = HrFormatErrorMessage( szErrorMsg, ARRAYSIZE( szErrorMsg ), hrIn );

    va_start( valMarker, pszOperationIn );  // Initialize variable arguments.
    THR( StringCchVPrintfW(
                  szOperation
                , ARRAYSIZE( szOperation )
                , pszOperationIn
                , valMarker
                ) );

    THR( StringCchPrintfW(
                  pszMessageOut
                , nMxMessageIn
                , L"%ls:\r\n\r\n%ls\r\nError ID %d (%#x)" // BUGBUG needs to be a string resource
                , szOperation
                , szErrorMsg
                , hrIn
                , hrIn
                ) );

    HRETURN( hr );

} //*** HrFormatErrorMessageBoxText()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\directoryutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      DirectoryUtils.cpp
//
//  Description:
//      Useful functions for manipulating directies.
//
//  Maintained By:
//      Galen Barbee (GalenB)   05-DEC-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Structure used to pass parameters between recursive calls to the
// gs_RecursiveEmptyDirectory() function.
//
struct SDirRemoveParams
{
    WCHAR *     m_pszDirName;       // Pointer to the directory name buffer.
    size_t      m_cchDirNameLen;     // Length of string currently in buffer (does not include '\0')
    size_t      m_cchDirNameMax;     // Max length of string in buffer (does not include '\0')
    signed int  m_iMaxDepth;        // Maximum recursion depth.
};


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations.
//////////////////////////////////////////////////////////////////////////////

DWORD
DwRecursiveEmptyDirectory( SDirRemoveParams * pdrpParamsInOut );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwRecursiveEmptyDirectory
//
//  Description:
//      Recursively removes the target directory and everything underneath it.
//      This is a recursive function.
//
//  Arguments:
//      pdrpParamsInout
//          Pointer to the object that contains the parameters for this recursive call.
//
//  Return Value:
//      ERROR_SUCCESS
//          The directory was deleted
//
//      Other Win32 error codes
//          If something went wrong
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwRecursiveEmptyDirectory( SDirRemoveParams * pdrpParamsInout )
{
    DWORD dwError = ERROR_SUCCESS;

    do
    {
        typedef CSmartResource<
            CHandleTrait<
                  HANDLE
                , BOOL
                , FindClose
                , INVALID_HANDLE_VALUE
                >
            > SmartFindFileHandle;

        WIN32_FIND_DATA     wfdCurFile;
        size_t              cchCurDirNameLen = pdrpParamsInout->m_cchDirNameLen;

        ZeroMemory( &wfdCurFile, sizeof( wfdCurFile ) );

        if ( pdrpParamsInout->m_iMaxDepth < 0 )
        {
            dwError = TW32( ERROR_DIR_NOT_EMPTY );
            break;
        } // if: the recursion is too deep.

        //
        // Check if the target directory name is too long. The two extra characters
        // being checked for are '\\' and '*'.
        //
        if ( cchCurDirNameLen > ( pdrpParamsInout->m_cchDirNameMax - 2 ) )
        {
            dwError = TW32( ERROR_BUFFER_OVERFLOW );
            break;
        } // if: the target directory name is too long.

        // Append "\*" to the end of the directory name
        pdrpParamsInout->m_pszDirName[ cchCurDirNameLen ] = L'\\';
        pdrpParamsInout->m_pszDirName[ cchCurDirNameLen + 1 ] = L'*';
        pdrpParamsInout->m_pszDirName[ cchCurDirNameLen + 2 ] = L'\0';

        ++cchCurDirNameLen;

        SmartFindFileHandle sffhFindFileHandle( FindFirstFile( pdrpParamsInout->m_pszDirName, &wfdCurFile ) );

        if ( sffhFindFileHandle.FIsInvalid() )
        {
            dwError = TW32( GetLastError() );
            break;
        }

        do
        {
            size_t cchFileNameLen;

            // If the current file is a directory, make a recursive call to delete it.
            if ( ( wfdCurFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                if (    ( wcscmp( wfdCurFile.cFileName, L"." ) != 0 )
                     && ( wcscmp( wfdCurFile.cFileName, L".." ) != 0 )
                   )
                {
                    cchFileNameLen = wcslen( wfdCurFile.cFileName );

                    // Append the subdirectory name past the last '\\' character.
                    THR( StringCchCopyW(
                                  pdrpParamsInout->m_pszDirName + cchCurDirNameLen
                                , pdrpParamsInout->m_cchDirNameMax - cchCurDirNameLen
                                , wfdCurFile.cFileName
                                ) );

                    // Update the parameter object.
                    --pdrpParamsInout->m_iMaxDepth;
                    pdrpParamsInout->m_cchDirNameLen = cchCurDirNameLen + cchFileNameLen;

                    // Delete the subdirectory.
                    dwError = TW32( DwRecursiveEmptyDirectory( pdrpParamsInout ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        break;
                    } // if: an error occurred trying to empty this directory.

                    // Restore the parameter object. There is no need to restore m_cchDirNameLen
                    // since it is never used again in the RHS in this function.
                    ++pdrpParamsInout->m_iMaxDepth;

                    if ( RemoveDirectory( pdrpParamsInout->m_pszDirName ) == FALSE )
                    {
                        dwError = TW32( GetLastError() );
                        break;
                    } // if: the current directory could not be removed.
                } // if: the current directory is not "." or ".."
            } // if: current file is a directory.
            else
            {
                //
                // This file is not a directory. Delete it.
                //

                cchFileNameLen = wcslen( wfdCurFile.cFileName );

                if ( cchFileNameLen > ( pdrpParamsInout->m_cchDirNameMax - cchCurDirNameLen ) )
                {
                    dwError = TW32( ERROR_BUFFER_OVERFLOW );
                    break;
                }

                // Append the file name to the directory name.
                THR( StringCchCopyW(
                              pdrpParamsInout->m_pszDirName + cchCurDirNameLen
                            , pdrpParamsInout->m_cchDirNameMax - cchCurDirNameLen
                            , wfdCurFile.cFileName
                            ) );

                if ( DeleteFile( pdrpParamsInout->m_pszDirName ) == FALSE )
                {
                    dwError = TW32( GetLastError() );
                    break;
                } // if: DeleteFile failed.
            } // else: current file is not a directory.

            if ( FindNextFile( sffhFindFileHandle.HHandle(), &wfdCurFile ) == FALSE )
            {
                dwError = GetLastError();

                if ( dwError == ERROR_NO_MORE_FILES )
                {
                    // We have deleted all the files in this directory.
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    TW32( dwError );
                }

                // If FindNextFile has failed, we are done.
                break;
            } // if: FindNextFile fails.
        }
        while( true ); // loop infinitely.

        if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // if: something went wrong.

        //
        // If we are here, then all the files in this directory have been deleted.
        //

        // Truncate the directory name at the last '\'
        pdrpParamsInout->m_pszDirName[ cchCurDirNameLen - 1 ] = L'\0';
    }
    while( false ); // dummy do while loop to avoid gotos.

    return dwError;

} //*** DwRecursiveEmptyDirectory


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwRemoveDirectory
//
//  Description:
//      Remove the target directory and everything underneath it.
//      Calls DwRecursiveEmptyDirectory to do the actual work.
//
//  Arguments:
//      pcszTargetDirIn
//          The directory to be removed. Note, this name cannot have trailing
//          backslash '\' characters.
//
//      iMaxDepthIn
//          The maximum depth of the subdirectories that will be removed.
//          Default value is 32. If this depth is exceeded, an exception
//          is thrown.
//
//  Return Value:
//      ERROR_SUCCESS
//          The directory was deleted
//
//      Other Win32 error codes
//          If something went wrong
//
//  Remarks:
//      If the length of the name of any of the files under pcszTargetDirIn
//      exceeds MAX_PATH - 1, an error is returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwRemoveDirectory( const WCHAR * pcszTargetDirIn, signed int iMaxDepthIn )
{
    WCHAR                       szDirBuffer[ MAX_PATH ];
    SDirRemoveParams            drpParams;
    DWORD                       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA   wfadDirAttributes;

    if ( pcszTargetDirIn == NULL )
    {
        goto Cleanup;
    } // if: the directory name is NULL

    ZeroMemory( &wfadDirAttributes, sizeof( wfadDirAttributes ) );

    //
    // Check if the directory exists.
    //
    if ( GetFileAttributesEx( pcszTargetDirIn, GetFileExInfoStandard, &wfadDirAttributes ) == FALSE )
    {
        dwError = GetLastError();
        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            dwError = ERROR_SUCCESS;
        } // if: the directory does not exist, this is not an error
        else
        {
            TW32( dwError );
        }

        goto Cleanup;
    } // if: we could not get the file attributes

    if ( ( wfadDirAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
    {
        // We are not going to delete files
        goto Cleanup;
    } // if: the path does not point to a directory

    // Copy the input string to our buffer.
    THR( StringCchCopyW( szDirBuffer, RTL_NUMBER_OF( szDirBuffer ), pcszTargetDirIn ) );

    // Initialize the object that holds the parameters for the recursive call.
    drpParams.m_pszDirName = szDirBuffer;
    drpParams.m_cchDirNameLen = static_cast< UINT >( wcslen( szDirBuffer ) );
    drpParams.m_cchDirNameMax = RTL_NUMBER_OF( szDirBuffer ) - 1;
    drpParams.m_iMaxDepth = iMaxDepthIn;

    // Call the actual recursive function to empty the directory.
    dwError = TW32( DwRecursiveEmptyDirectory( &drpParams ) );

    // If the directory was emptied, delete it.
    if ( ( dwError == ERROR_SUCCESS ) && ( RemoveDirectory( pcszTargetDirIn ) == FALSE ) )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: the current directory could not be removed.

Cleanup:
    return dwError;

} //*** DwRemoveDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\common\registryutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      RegistryUtils.cpp
//
//  Description:
//      Useful functions for manipulating directies.
//
//  Maintained By:
//      Galen Barbee (GalenB)   10-SEP-2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "Pch.h"


//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations.
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetDefaultComponentNameFromRegistry
//
//  Description:
//      Get the default name for the passed in COM component CLSID from
//      the registry.
//
//  Arguments:
//      pclsidIn
//          CLSID whose default name is requested.
//
//      pbstrComponentNameOut
//          Buffer to receive the name.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetDefaultComponentNameFromRegistry(
      CLSID * pclsidIn
    , BSTR *  pbstrComponentNameOut
    )
{
    TraceFunc( "" );
    Assert( pclsidIn != NULL );
    Assert( pbstrComponentNameOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc = ERROR_SUCCESS;
    BSTR    bstrSubKey = NULL;
    HKEY    hKey = NULL;
    WCHAR   szGUID[ 64 ];
    int     cch = 0;
    DWORD   dwType = 0;
    WCHAR * pszName = NULL;
    DWORD   cbName = 0;

    cch = StringFromGUID2( *pclsidIn, szGUID, RTL_NUMBER_OF( szGUID ) );
    Assert( cch > 0 );  // 64 chars should always hold a guid!

    //
    //  Create the subkey string.
    //

    hr = THR( HrFormatStringIntoBSTR( L"CLSID\\%1!ws!", &bstrSubKey, szGUID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Open the key under HKEY_CLASSES_ROOT.
    //

    sc = TW32( RegOpenKeyEx( HKEY_CLASSES_ROOT, bstrSubKey, 0, KEY_READ, &hKey ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    //  Get the length of the default value.
    //

    sc = TW32( RegQueryValueExW( hKey, L"", NULL, &dwType, NULL, &cbName ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    //  Allocate some space for the string.
    //

    pszName = new WCHAR[ ( cbName / sizeof( WCHAR ) ) + 1 ];
    if ( pszName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    //  Get the default value which should be the name of the component.
    //

    sc = TW32( RegQueryValueExW( hKey, L"", NULL, &dwType, (LPBYTE) pszName, &cbName ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    Assert( dwType == REG_SZ );

    *pbstrComponentNameOut = TraceSysAllocString( pszName );
    if ( *pbstrComponentNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    TraceSysFreeString( bstrSubKey );
    delete [] pszName;

    HRETURN( hr );

} //*** HrGetDefaultComponentNameFromRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\cfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CFactory.h
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef HRESULT (*PFN_FACTORY_METHOD)( IUnknown ** );
typedef HRESULT (*PFN_CATEGORY_REGISTRAR)( ICatRegister *, BOOL );

enum EAppIDRunAsIdentity
{
    airaiInvalid,
    airaiMinimum = airaiInvalid,
    airaiLaunchingUser,
    airaiInteractiveUser,
    airaiNetworkService,
    airaiLocalService,
    airaiMaximum
};

struct SAppIDInfo
{
    const GUID *        pAppID;
    PCWSTR              pcszName;
    size_t              cchName;
    UINT                idsLaunchPermission;
    UINT                idsAccessPermission;
    DWORD               nAuthenticationLevel;
    EAppIDRunAsIdentity eairai;
};

struct SPrivateClassInfo
{
    PFN_FACTORY_METHOD  pfnCreateInstance;
    const CLSID *       pClassID;
    PCWSTR              pcszName;
    size_t              cchName;
};

enum EClassThreadingModel
{
    ctmInvalid,
    ctmMinimum = ctmInvalid,
    ctmFree,
    ctmApartment,
    ctmCreator,
    ctmMaximum
};

struct SPublicClassInfo
{
    PFN_FACTORY_METHOD      pfnCreateInstance;
    const CLSID *           pClassID;
    PCWSTR                  pcszName;
    size_t                  cchName;
    PCWSTR                  pcszProgID;
    size_t                  cchProgID;
    EClassThreadingModel    ectm;
    const GUID *            pAppID;
    PFN_CATEGORY_REGISTRAR  pfnRegisterCatID;
};


struct SCatIDInfo
{
    const CATID *  pcatid;
    PCWSTR         pcszName;
};


struct STypeLibInfo
{
    DWORD   idTypeLibResource;
    BOOL    fAtEnd;
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CFactory
//
//  Description:
//      Class implementing a COM class factory.
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CFactory
    : public IClassFactory
{
private:
    // IUnknown
    LONG        m_cRef;

    // IClassFactory data
    PFN_FACTORY_METHOD m_pfnCreateInstance;

private: // Methods
    CFactory( void );
    ~CFactory( void );
    STDMETHOD( HrInit )( PFN_FACTORY_METHOD lpfn );

public: // Methods

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( PFN_FACTORY_METHOD lpfn, CFactory ** ppFactoryInstanceOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IClassFactory
    //
    STDMETHOD( CreateInstance )( IUnknown * punkOuterIn, REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD( LockServer )( BOOL fLock );

}; //*** class CFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\citrackersrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CITracker.CPP
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    19-NOV-1999
//
//  Notes:
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//      Define FULL_TRACE_INTERFACES_ENABLED to enable full interface
//      tracking in RETAIL builds.  Full interface tracking is enabled if
//      interface tracking is enabled and building for X86.
//      Full interface tracking is X86 specific for now. It can be adapted for
//      other platforms as required. Since today, most of our developement is
//      done on the X86 platform, there is not a need to do this (yet).
//
//////////////////////////////////////////////////////////////////////////////

//#include "pch.h"
#include <shlwapi.h>
#include <StrSafe.h>

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN TRACE_INTERFACES_ENABLED
//

#if defined( DEBUG )

//////////////////////////////////////////////////////////////////////////////
//
//  PszDebugFindInterface
//
//  Description:
//      Uses the Interface Tracking Table (g_itTable) to lookup a human
//      readable name for the riidIn. If no matching interface is found. it
//      will use the pszBufOut to format a GUID string and return it.
//
//  Arguments:
//      riidIn      - The interface ID to lookup.
//      pszBufOut   - Buffer to use if interface not found to format GUID.
//
//  Return Values:
//      Never NULL. It will always a valid string pointer to either the
//      interface name or to pszBufOut.
//
//  Notes:
//      pszBufOut must be at least cchGUID_STRING_SIZE in size.
//
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPWSTR      pszBufOut
    )
{
    if ( IsTraceFlagSet( mtfQUERYINTERFACE ) )
    {
        int idx;

        for ( idx = 0; g_itTable[ idx ].riid != NULL; idx++ )
        {
            if ( riidIn == *g_itTable[ idx ].riid )
            {
                return g_itTable[ idx ].pszName;

            } // if: found interface

        } // for: searching for interface

        THR( StringCchPrintfW(
                      pszBufOut
                    , cchGUID_STRING_SIZE
                    , L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"
                    , riidIn.Data1
                    , riidIn.Data2
                    , riidIn.Data3
                    , riidIn.Data4[0]
                    , riidIn.Data4[1]
                    , riidIn.Data4[2]
                    , riidIn.Data4[3]
                    , riidIn.Data4[4]
                    , riidIn.Data4[5]
                    , riidIn.Data4[6]
                    , riidIn.Data4[7]
                    ) );
    } // if: query interface is on
    else
    {
        return L"riid";
    } // else: just print riid

    return pszBufOut;

} //*** PszDebugFindInterface
#endif // DEBUG

//
// END TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED


// ************************************************************************


#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN FULL_TRACE_INTERFACES_ENABLED
//

//
// Globals
//
static IDeadObjTracker * g_pidoTracker = NULL;  // dead object - there is only one.

#ifndef NOISY_TRACE_INTERFACES
///////////////////////////////////////
//
// DEBUG !NOISY_TRACE_INTERFACES
//

//
// Undefining these macros to make the CITracker quiet.
//
#undef  TraceFunc
#define TraceFunc       1 ? (void)0 : (void)
#undef  TraceFunc1
#define TraceFunc1      1 ? (void)0 : (void)
#undef  TraceFunc2
#define TraceFunc2      1 ? (void)0 : (void)
#undef  TraceFunc3
#define TraceFunc3      1 ? (void)0 : (void)
#undef  TraceFunc4
#define TraceFunc4      1 ? (void)0 : (void)
#undef  TraceFunc5
#define TraceFunc5      1 ? (void)0 : (void)
#undef  TraceFunc6
#define TraceFunc6      1 ? (void)0 : (void)
#undef  TraceQIFunc
#define TraceQIFunc     1 ? (void)0 : (void)
#undef  TraceFuncExit
#define TraceFuncExit()
#undef  FRETURN
#define FRETURN( _u )
#undef  HRETURN
#define HRETURN(_hr)    return(_hr)
#undef  RETURN
#define RETURN(_fn)     return(_fn)
#undef  RRETURN
#define RRETURN( _fn )  return(_fn)

//
// END !NOISY_TRACE_INTERFACES
//
///////////////////////////////////////
#endif // NOISY_TRACE_INTERFACES

#if defined( DEBUG )

//
// These are internal to debug.cpp but not published in debug.h.
//
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
DebugInitializeBuffer(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPWSTR      pszBufIn,
    INT *       pcchInout,
    LPWSTR *    ppszBufOut
    );
#endif // DEBUG

///////////////////////////////////////
//
// CITracker Definition
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS CITracker*

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// Special new() for CITracker
//
// Description:
//      Creates an object the size of the object plus nExtraIn bytes. This
//      allows the Vtable that the CITracker object is tracking to be
//      appended to the end of the CITracker object.
//
//////////////////////////////////////////////////////////////////////////////
#ifdef new
#undef new
#endif
void*
__cdecl
operator new(
    unsigned int    nSizeIn,
    LPCWSTR         pszFileIn,
    const int       nLineIn,
    LPCWSTR         pszModuleIn,
    UINT            nExtraIn,
    LPCWSTR         pszNameIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), 0, nSizeIn + nExtraIn );

    return TraceMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, nSizeIn + nExtraIn, L"CITracker" );

} //*** operator new

//////////////////////////////////////////////////////////////////////////////
//
//  DebugTrackInterface
//
//  Description:
//      Create an interface tracker for the given interface.
//
//  Arguments:
//      pszNameIn   - Name to associate with object that the punk references.
//      riidIn      - Interface IID of the interface to be tracked.
//      punkIn      - Interface pointer to track.
//      cRefIn      - Initialize ref count on the interface.
//
//  Return Values:
//      On failure, this will be punkIn.
//      On success, pointer to an object that implements the interface to
//          be tracked.
//
//////////////////////////////////////////////////////////////////////////////
LPUNKNOWN
DebugTrackInterface(
    LPCWSTR   pszFileIn,
    const int nLineIn,
    LPCWSTR   pszModuleIn,
    LPCWSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN punkIn,
    LONG      cRefIn
    )
{
    TraceFunc3( "pszNameIn = '%ws', riidIn, punkIn = 0x%08x, cRefIn = %u",
                pszNameIn,
                punkIn,
                cRefIn
                );

    UINT      nEntry  = 0;
    LPUNKNOWN punkOut = punkIn;

    //
    // Scan the table looking for the matching interface definition.
    //
    for( nEntry = 0; g_itTable[ nEntry ].riid != NULL; nEntry++ )
    {
        if ( riidIn == *g_itTable[ nEntry ].riid )
        {
            //
            // Figure out how much "extra" to allocate onto the CITracker.
            //
            UINT nExtra = ( 3 + g_itTable[ nEntry ].cFunctions ) * sizeof(LPVOID);

            //
            // Create a name for the tracker.
            //
            // TODO:    gpease  19-NOV-1999
            //          Maybe merge this in with the nExtra(??).
            //
            LPWSTR  pszName;
            DWORD   cch = ( wcslen( g_itTable[ nEntry ].pszName ) + wcslen( pszNameIn ) + 3 + 2 ); // '::[' + ']' + NULL

            pszName = (LPWSTR) HeapAlloc( GetProcessHeap(), 0, cch * sizeof( *pszName ) );

            THR( StringCchPrintfW( pszName, cch, L"%ws::[%ws]", pszNameIn, g_itTable[ nEntry ].pszName ) );

            //
            // Create the tracker.
            //
            LPTHISCLASS pc = new( pszFileIn, nLineIn, pszModuleIn, nExtra, pszName ) THISCLASS();
            if ( pc != NULL )
            {
                HRESULT hr;

                //
                // Initialize the tracker.
                //
                hr = THR( pc->Init( &punkOut, punkIn, &g_itTable[ nEntry ], pszName, cRefIn ) );
                if ( FAILED( hr ) )
                {
                    //
                    // If it failed, delete it.
                    //
                    delete pc;

                } // if: failed to initialize

            } // if: got memory

            break; // exit loop

        } // if: matched interface

    } // for: more entries in table

    AssertMsg( g_itTable[ nEntry ].riid != NULL, "There has been a request to track an interface that is not in the interface table." );

    RETURN( punkOut );

} //*** DebugTrackInterface

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::CITracker( void )
//
//////////////////////////////////////////////////////////////////////////////
CITracker::CITracker( void )
{
    TraceFunc( "" );

    //
    // KB: gpease 10-OCT-1998
    // This class will leak objects to help catch bad components
    // that call back into released interfaces therefore this
    // DLL will not be able to be released.
    //
    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        InterlockedIncrement( &g_cObjects );
    }

    TraceFuncExit();

} //*** CITracker::ctor

//////////////////////////////////////////////////////////////////////////////
//
//  CITracker::Init
//
//  Description:
//      Initializes the CITracker object. It creates a copy of the VTable
//      of the interface to be tracked replacing the QI, AddRef and Release
//      methods with its own IUnknown. This allows CITracker to be "in the
//      loop" for those calls.
//
//  Arguments:
//      ppunkOut    - The "punk" to be passed around.
//      punkIn      - The interface to be copied and tracked.
//      piteIn      - The interface table entry for the interface.
//      pszNameIn   - The name to be given to this CITracker.
//      fAddRefIn   - TRUE is the CITracker should start with a Ref Count of 1.
//
//  Return Values:
//      S_OK        - Success.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CITracker::Init(
    LPUNKNOWN *                     ppunkOut,
    LPUNKNOWN                       punkIn,
    const INTERFACE_TABLE_ENTRY *   piteIn,
    LPCWSTR                         pszNameIn,
    LONG                            cRefIn
    )
{
    HRESULT hr = S_OK;

    TraceFunc5( "ppunkOut = 0x%08x, punkIn = 0x%08x, iteIn = %ws, pszNameIn = '%ws', cRefIn = %u",
                ppunkOut,
                punkIn,
                piteIn->pszName,
                pszNameIn,
                cRefIn
                );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID * pthisVtbl  = (LPVOID*) (IUnknownTracker *) this;
    DWORD    dwSize     = ( 3 + piteIn->cFunctions ) * sizeof( LPVOID );

    AssertMsg( dwSize < 30 * sizeof( LPVOID ), "Need to make Dead Obj and IUnknownTracker larger!" );

    //
    // Interface tracking information initialization
    //
    m_vtbl.cRef         = cRefIn;
    m_vtbl.pszInterface = pszNameIn;
    m_vtbl.dwSize       = dwSize;

    //
    // Copy our IUnknownTracker vtbl to our "fix-up-able" vtbl
    //
    CopyMemory( &m_vtbl.lpfnQueryInterface, *pthisVtbl, dwSize );

    //
    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    //
    m_vtbl.punk = (LPUNKNOWN) punkIn;

    //
    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    //
    m_vtbl.pNewVtbl = (VTBL *) &m_vtbl.lpfnQueryInterface;
    *pthisVtbl      = m_vtbl.pNewVtbl;
    *ppunkOut       = (LPUNKNOWN) (IUnknownTracker *) this;

    TraceMsg( mtfCITRACKERS, L"TRACK: Tracking %ws Interface (%#x)", m_vtbl.pszInterface, punkIn );

    HRETURN( hr );

} //*** CITracker::Init

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::~CITracker( void )
//
//////////////////////////////////////////////////////////////////////////////
CITracker::~CITracker( void )
{
    TraceFunc1( "for %ws", m_vtbl.pszInterface );

    if ( m_vtbl.pszInterface != NULL )
    {
        HeapFree( GetProcessHeap(), 0, (LPVOID) m_vtbl.pszInterface );
    } // if: have interface pointer

    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        InterlockedDecrement( &g_cObjects );
    }

    TraceFuncExit();

} //*** CITracker::dtor

// ************************************************************************
//
// IUnknownTracker
//
// ************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CITracker::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CITracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    TraceFunc1( "{%ws}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %ws::QueryInterface()", m_vtbl.pszInterface );

    //
    // Call the punk's QueryInterface().
    //
    HRESULT hr = m_vtbl.punk->QueryInterface( riid, ppv );

    //
    // KB:  TRACK_ALL_QIED_INTERFACES   gpease 25-NOV-1999
    //      Thinking out loud, should we track all interfaces QI'ed from
    //      a tracked interface auto-magically? If so, turn this #define
    //      on.
    //
    // #define TRACK_ALL_QIED_INTERFACES
#if defined( TRACK_ALL_QIED_INTERFACES )
    if ( !IsEqualIID( riid, IID_IUnknown )
       )
    {
        *ppv = DebugTrackInterface( L"<Unknown>",
                                    0,
                                    __MODULE__,
                                    m_vtbl.pszInterface,
                                    riid,
                                    (IUnknown*) *ppv,
                                    TRUE
                                    );
    } // if: not the IUnknown
#endif

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %ws::QueryInterface() [ *ppv = %#x ]",
              m_vtbl.pszInterface,
              *ppv
              );

    HRETURN( hr );

} //*** CITracker::QueryInterface

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// CITracker::AddRef( void )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CITracker::AddRef( void )
{
    TraceFunc1( "{%ws}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %ws AddRef() [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's AddRef().
    //
    ULONG ul = m_vtbl.punk->AddRef();

    //
    // Increment our counter.
    //
    ULONG ulvtbl = InterlockedIncrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %ws AddRef() [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    RETURN( ul );

} //*** CITracker::AddRef

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// CITracker::Release( void )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CITracker::Release( void )
{
    TraceFunc1( "{%ws}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %ws Release() [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's Release().
    //
    ULONG ul = m_vtbl.punk->Release();

    //
    // Decrement our counter.
    //
    ULONG ulvtbl = InterlockedDecrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %ws Release() [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    //
    // Our ref count should always be less than the punk's ref count.
    //
    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    if ( ulvtbl )
    {
        RETURN( ulvtbl );
    } // if: we still have a ref

    if ( g_pidoTracker == NULL )
    {
        //
        // Create a dead object - if more than one is created at a time, we might leak it.
        //
        // TODO:    gpease 19-NOV-1999
        //          Work on not leaking "extra" dead objects.
        //
        g_pidoTracker = new( TEXT(__FILE__), __LINE__, __MODULE__, 0, L"Dead Object" ) IDeadObjTracker();

        // Don't track this object
        TraceMemoryDelete( g_pidoTracker, FALSE );

    } // if: no dead object

    Assert( g_pidoTracker != NULL );
    if ( g_pidoTracker != NULL )
    {
        LPVOID * pthisVtbl  = (LPVOID *) (IUnknownTracker *) this;
        LPVOID * ppthatVtbl = (LPVOID *) (IDeadObjTracker *) g_pidoTracker;

        // Copy the DeadObj vtbl.
        CopyMemory( &m_vtbl.lpfnQueryInterface, *ppthatVtbl, m_vtbl.dwSize );

        //
        // Don't really delete it, but fake the debug output as if we did.
        //
        TraceFunc1( "for %ws", m_vtbl.pszInterface );
        TraceMsg( mtfCITRACKERS, "TRACK: # %ws set to dead object [ punk = %#08x ]", m_vtbl.pszInterface, pthisVtbl );
        FRETURN( 0 );

        // Stop tracking this object.
        TraceMemoryDelete( this, FALSE );

    } // if: dead object created
    else
    {
        //
        // No dead object; nuke ourselves. This will at least cause an AV if
        // the program tries to call on our interface alerting the programmer
        // that somethings wrong.
        //
        delete this;

    } // else: no dead object

    RETURN(0);

} //*** CITracker::Release

//****************************************************************************
//
// IDeadObjTracker - The dead interface object tracker.
//
// This object is shunted into release interfaces that were being tracked by
// the CITracker class. Any calls to a released interface will end up causing
// an Assert and if execution continues it will return E_FAIL.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// IDeadObjTracker:Stub(x)
//
//////////////////////////////////////////////////////////////////////////////
#define IDeadObjTrackerStub( _iStubNum ) \
STDMETHODIMP \
IDeadObjTracker::Stub##_iStubNum( LPVOID * punk ) \
{ \
    const int   cchDebugMessageSize = 255; \
    WCHAR       szMessage[ cchDebugMessageSize ]; \
    LRESULT     lResult;\
    \
    DebugMsg( "*ERROR* %ws: Entered %ws (%#08x) after it was released. Returning E_FAIL.", \
              __MODULE__, \
              m_vtbl.pszInterface, \
              this \
              ); \
\
    THR( StringCchPrintfW( \
                  szMessage \
                , cchDebugMessageSize \
                , L"Entered %ws (%#08p) after it was released.\n\nDo you want to break here?\n\n(If you do not break, E_FAIL will be returned.)" \
                , m_vtbl.pszInterface \
                , this \
                ) ); \
\
    lResult = MessageBox( NULL, szMessage, L"Dead Interface", MB_YESNO | MB_ICONWARNING );\
    if ( lResult == IDYES \
       ) \
    { \
        DEBUG_BREAK; \
    } \
\
    return E_FAIL; \
}

IDeadObjTrackerStub(0);
IDeadObjTrackerStub(1);
IDeadObjTrackerStub(2);
IDeadObjTrackerStub(3);
IDeadObjTrackerStub(4);
IDeadObjTrackerStub(5);
IDeadObjTrackerStub(6);
IDeadObjTrackerStub(7);
IDeadObjTrackerStub(8);
IDeadObjTrackerStub(9);
IDeadObjTrackerStub(10);
IDeadObjTrackerStub(11);
IDeadObjTrackerStub(12);
IDeadObjTrackerStub(13);
IDeadObjTrackerStub(14);
IDeadObjTrackerStub(15);
IDeadObjTrackerStub(16);
IDeadObjTrackerStub(17);
IDeadObjTrackerStub(18);
IDeadObjTrackerStub(19);
IDeadObjTrackerStub(20);
IDeadObjTrackerStub(21);
IDeadObjTrackerStub(22);
IDeadObjTrackerStub(23);
IDeadObjTrackerStub(24);
IDeadObjTrackerStub(25);
IDeadObjTrackerStub(26);
IDeadObjTrackerStub(27);
IDeadObjTrackerStub(28);
IDeadObjTrackerStub(29);
IDeadObjTrackerStub(30);

//****************************************************************************
//
// IUnknownTracker stub
//
// This merely directs the incoming call back to the orginal object. The
// IUnknown methods will be remapped the the CITracker methods.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// IUnknownTracker::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
IUnknownTracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return E_FAIL;

} //*** IUnknownTracker::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// IUnknownTracker::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
IUnknownTracker::AddRef( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return static_cast< ULONG >( -1 );

} //*** IUnknownTracker::AddRef

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// IUnknownTracker::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
IUnknownTracker::Release( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return static_cast< ULONG >( -1 );

} //*** IUnknownTracker::Release

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(void)
// IUnknownTracker::Stub(x)
//
// These are just stubs to redirect the call to the "real" method on the punk.
// We actually dissappear from the call stack.
//
//////////////////////////////////////////////////////////////////////////////
#define IUnknownTrackerStub( i ) \
void \
_declspec(naked) \
IUnknownTracker::Stub##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

IUnknownTrackerStub(3);
IUnknownTrackerStub(4);
IUnknownTrackerStub(5);
IUnknownTrackerStub(6);
IUnknownTrackerStub(7);
IUnknownTrackerStub(8);
IUnknownTrackerStub(9);
IUnknownTrackerStub(10);
IUnknownTrackerStub(11);
IUnknownTrackerStub(12);
IUnknownTrackerStub(13);
IUnknownTrackerStub(14);
IUnknownTrackerStub(15);
IUnknownTrackerStub(16);
IUnknownTrackerStub(17);
IUnknownTrackerStub(18);
IUnknownTrackerStub(19);
IUnknownTrackerStub(20);
IUnknownTrackerStub(21);
IUnknownTrackerStub(22);
IUnknownTrackerStub(23);
IUnknownTrackerStub(24);
IUnknownTrackerStub(25);
IUnknownTrackerStub(26);
IUnknownTrackerStub(27);
IUnknownTrackerStub(28);
IUnknownTrackerStub(29);
IUnknownTrackerStub(30);


//
// END FULL_TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\common.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Common definitions.
//
//  Maintained By:
//      David Potter (DavidP) 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if !defined( ARRAYSIZE )
#define ARRAYSIZE( _x ) RTL_NUMBER_OF( _x )
#define NULLTERMINATEARRAY( _x ) ( _x[ RTL_NUMBER_OF( _x ) - 1 ] = NULL )
#endif // ! defined( ARRAYSIZE )

#if !defined( PtrToByteOffset )
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)
#endif // !defined( PtrToByteOffset )

//
// COM Macros to gain type checking.
//
#if !defined( TypeSafeParams )
#define TypeSafeParams( _interface, _ppunk ) \
    IID_##_interface, reinterpret_cast< void ** >( static_cast< _interface ** >( _ppunk ) )
#endif // !defined( TypeSafeParams )

#if !defined( TypeSafeQI )
#define TypeSafeQI( _interface, _ppunk ) \
    QueryInterface( TypeSafeParams( _interface, _ppunk ) )
#endif // !defined( TypeSafeQI )

#if !defined( TypeSafeQS )
#define TypeSafeQS( _clsid, _interface, _ppunk ) \
    QueryService( _clsid, TypeSafeParams( _interface, _ppunk ) )
#endif // !defined( TypeSafeQS )

//
//  COM Constants for string manipulation.
//
#define MAX_COM_GUID_STRING_LEN 39      // "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" + NULL
#define MAX_UUID_STRING_LEN     37      // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" + NULL

//
//  Count to use for spin locks.
//
#define RECOMMENDED_SPIN_COUNT 4000

/////////////////////////////////////////////////////////////////////////////
//  Global Functions from FormatErrorMessage.cpp
/////////////////////////////////////////////////////////////////////////////

HRESULT
WINAPI
HrFormatErrorMessage(
      LPWSTR    pszErrorOut
    , UINT      nMxErrorIn
    , DWORD     scIn
    );

HRESULT
__cdecl
HrFormatErrorMessageBoxText(
      LPWSTR    pszMessageOut
    , UINT      nMxMessageIn
    , HRESULT   hrIn
    , LPCWSTR   pszOperationIn
    , ...
    );

HRESULT
WINAPI
HrGetComputerName(
      COMPUTER_NAME_FORMAT  cnfIn
    , BSTR *                pbstrComputerNameOut
    , BOOL                  fBestEffortIn
    );

/////////////////////////////////////////////////////////////////////////////
//  Global Functions from DirectoryUtils.cpp
/////////////////////////////////////////////////////////////////////////////

HRESULT
HrCreateDirectoryPath(
    LPWSTR pszDirectoryPath
    );

DWORD
DwRemoveDirectory(
      const WCHAR * pcszTargetDirIn
    , signed int    iMaxDepthIn = 32
    );

/////////////////////////////////////////////////////////////////////////////
//  Global Functions from RegistryUtils.cpp
/////////////////////////////////////////////////////////////////////////////

HRESULT
HrGetDefaultComponentNameFromRegistry(
      CLSID * pclsidIn
    , BSTR * pbstrComponentNameOut
    );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  NStringCchCompareCase
//
//  Description:
//      General strsafe-style strncmp wrapper.
//
//  Arguments:
//      psz1In and psz2In
//          The strings to compare.  Either or both can be null, which is
//          treated as equivalent to an empty string.
//
//      cchsz1In and cchsz2In
//          The lengths of psz1In and psz2In, INCLUDING their terminating nulls.
//          Ignored if the corresponding sz parameter is null.
//
//  Return Values:
//          Less than zero: psz1In is less than psz2In.
//                    Zero: psz1In and psz2In are the same.
//       Greater than zero: psz1In is greater than psz2In.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
INT
NStringCchCompareCase(
      LPCWSTR   psz1In
    , size_t    cchsz1In
    , LPCWSTR   psz2In
    , size_t    cchsz2In
    )
{
    INT     nComparison = 0;
    size_t  cchsz1 = ( psz1In == NULL? 0: cchsz1In );
    size_t  cchsz2 = ( psz2In == NULL? 0: cchsz2In );
    size_t  cchShorterString = min( cchsz1, cchsz2 );

    if ( cchsz1 > 0 )
    {
        if ( cchsz2 > 0 )
        {
            nComparison = wcsncmp( psz1In, psz2In, cchShorterString );
        }
        else // psz2 is empty
        {
            //  psz1 is not empty, but psz2 is.
            //  Any non-empty string is greater than an empty one.
            nComparison = 1;
        }
    }
    else if ( cchsz2 > 0 )
    {
        //  psz1 is empty, but psz2 is not.
        //  An empty string is less than any non-empty one.
        nComparison = -1;
    }
    // Otherwise, both strings are empty, so leave nComparison at zero.

    return nComparison;
} //*** NStringCchCompareCase


//////////////////////////////////////////////////////////////////////////////
//++
//
//  NStringCchCompareNoCase
//
//  Description:
//      General strsafe-style strnicmp wrapper.
//
//  Arguments:
//      psz1In and psz2In
//          The strings to compare.  Either or both can be null, which is
//          treated as equivalent to an empty string.
//
//      cchsz1In and cchsz2In
//          The lengths of psz1In and psz2In, INCLUDING their terminating nulls.
//          Ignored if the corresponding sz parameter is null.
//
//  Return Values:
//          Less than zero: psz1In is less than psz2In.
//                    Zero: psz1In and psz2In are the same.
//       Greater than zero: psz1In is greater than psz2In.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
INT
NStringCchCompareNoCase(
      LPCWSTR   psz1In
    , size_t    cchsz1In
    , LPCWSTR   psz2In
    , size_t    cchsz2In
    )
{
    INT     nComparison = 0;
    size_t  cchsz1 = ( psz1In == NULL? 0: cchsz1In );
    size_t  cchsz2 = ( psz2In == NULL? 0: cchsz2In );
    size_t  cchShorterString = min( cchsz1, cchsz2 );

    if ( cchsz1 > 0 )
    {
        if ( cchsz2 > 0 )
        {
            nComparison = _wcsnicmp( psz1In, psz2In, cchShorterString );
        }
        else // psz2 is empty
        {
            //  psz1 is not empty, but psz2 is.
            //  Any non-empty string is greater than an empty one.
            nComparison = 1;
        }
    }
    else if ( cchsz2 > 0 )
    {
        //  psz1 is empty, but psz2 is not.
        //  An empty string is less than any non-empty one.
        nComparison = -1;
    }
    // Otherwise, both strings are empty, so leave nComparison at zero.

    return nComparison;
} //*** NStringCchCompareNoCase


//////////////////////////////////////////////////////////////////////////////
//++
//
//  NBSTRCompareCase
//
//  Description:
//      strcmp for BSTRs.
//
//  Arguments:
//      bstr1 and bstr2
//          The strings to compare.  Either or both can be NULL, which is
//          equivalent to an empty string.
//
//  Return Values:
//          Less than zero: bstr1 is less than bstr2.
//                    Zero: bstr1 and bstr2 are the same.
//       Greater than zero: bstr1 is greater than bstr2.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
INT
NBSTRCompareCase(
      BSTR bstr1
    , BSTR bstr2
    )
{
    return NStringCchCompareCase( bstr1, SysStringLen( bstr1 ) + 1, bstr2, SysStringLen( bstr2 ) + 1 );
} //*** NBSTRCompareCase


//////////////////////////////////////////////////////////////////////////////
//++
//
//  NBSTRCompareNoCase
//
//  Description:
//      stricmp for BSTRs.
//
//  Arguments:
//      bstr1 and bstr2
//          The strings to compare.  Either or both can be NULL, which is
//          equivalent to an empty string.
//
//  Return Values:
//          Less than zero: bstr1 is less than bstr2.
//                    Zero: bstr1 and bstr2 are the same.
//       Greater than zero: bstr1 is greater than bstr2.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
INT
NBSTRCompareNoCase(
      BSTR bstr1
    , BSTR bstr2
    )
{
    return NStringCchCompareNoCase( bstr1, SysStringLen( bstr1 ) + 1, bstr2, SysStringLen( bstr2 ) + 1 );
} //*** NBSTRCompareNoCase
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\citracker.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CITracker.H
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Geoffrey Pease  (gpease)    19-NOV-1999
//
//  Notes:
//      This is X86 specific for now. It can be adapted for other platforms
//      as required. Since today, most of our developement is done on the
//      X86 platform, there is not a need to do this (yet).
//
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// Combine this complex expression in to one simple #define.
//
#if ( DBG==1 || defined( _DEBUG ) ) && !defined( NO_TRACE_INTERFACES )
#define TRACE_INTERFACES_ENABLED
#endif

#if defined( _X86_ ) && defined( TRACE_INTERFACES_ENABLED )
#define FULL_TRACE_INTERFACES_ENABLED
#endif

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//

#pragma message("BUILD: Interface Tracking Enabled")

//
// DLL Interface Table Macros
//
#define BEGIN_INTERFACETABLE const INTERFACE_TABLE g_itTable = {
#define DEFINE_INTERFACE( _iid, _name, _count ) { &_iid, TEXT(_name), _count },
#define END_INTERFACETABLE { NULL, NULL, NULL } };

///////////////////////////////////////
//
// TraceInterface definitions
//
typedef struct {
    const struct _GUID *    riid;
    LPCWSTR                 pszName;
    ULONG                   cFunctions;
} INTERFACE_TABLE[], INTERFACE_TABLE_ENTRY, * LPINTERFACE_TABLE_ENTRY;

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map an name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this).
//
extern const INTERFACE_TABLE g_itTable;

///////////////////////////////////////
//
// IID --> Name lookup stuff
//
#if defined( DEBUG )
static const cchGUID_STRING_SIZE = sizeof("{12345678-1234-1234-1234-123456789012}");

#define PszTraceFindInterface( _riid, _szguid ) \
    ( g_tfModule ? PszDebugFindInterface( _riid, _szguid ) : L"riid" )

LPCWSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPWSTR      pszGuidBufOut
    );
#endif // DEBUG

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

#define BEGIN_INTERFACETABLE
#define DEFINE_INTERFACE( _iid, _name, _count )
#define END_INTERFACETABLE

//
// END DEBUG WITHOUT INTERFACE TRACKING
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED






#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Full Interface Tracking Enabled")

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// _interface *
// TraceInterface(
//      _nameIn,
//      _interface,
//      _punkIn,
//      _addrefIn
//      )
//
// Description:
//      This is the macro wrapper for DebugTrackInterface( ) which is only
//      defined in DEBUG builds. Using the TraceInterface( ) macro eliminates
//      the need for specifying compile time parameters as well as the
//      #ifdef/#endif definitions around the call.
//
//      This "routine" creates a CITracker for the interface specified by
//      _interface and returns a new punk to the interface. You specify the
//      initial ref count on the interface using the _addrefIn parameter. You
//      can assign a name to the object that the interface refereneces in the
//      _nameIn parameter. The returned punk will be cast to the _interface
//      parameter.
//
//      If there is insufficent memory to create the CITracker, the _punkIn
//      will be returned instead. There is no need to check the output for
//      failures as they are all handle internally to provide worry-free use.
//
//      If you are getting an AV after adding tracing to the interface, this
//      usually indicates that the Interface Table entry for that interface
//      is incorrect. Double check the number of methods on the interface
//      against the tables.
//
// Arguments:
//      _nameIn     - Name of the object this interface references (string).
//      _interface  - Name of the interface (typedef).
//      _punkIn     - Pointer to interface to track
//      _addrefIn   - Initial reference count on the interface.
//
// Return Values:
//      a VALID _interface pointer
//          Points to the CITracker that can be used as if it were the
//          orginal _punkIn. If there was insufficent memory, the orginal
//          _punkIn will be returned.
//
//  NOTES:
//      _addrefIn should be 0 if your going to be giving out the interface
//      from your QueryInterface routine if you AddRef( ) before giving it
//      out (typical QueryInterface( ) routines do this ).
//
//////////////////////////////////////////////////////////////////////////////
#define  TraceInterface( _nameIn, _interface, _punkIn, _addrefIn ) \
    reinterpret_cast<_interface*>( \
        DebugTrackInterface( TEXT(__FILE__), \
                             __LINE__, \
                             __MODULE__, \
                             _nameIn, \
                             IID_##_interface, \
                             static_cast<_interface*>( _punkIn), \
                             _addrefIn \
                             ) )

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk,
    REFIID    riid,
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)(
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    ULONG              cRef;
    LPUNKNOWN          punk;
    LPCWSTR            pszInterface;
    DWORD              dwSize;
    LPVTBL             pNewVtbl;
    // These must be last and in this order: QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
    // additional vtbl entries hang off the end
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPUNKNOWN
DebugTrackInterface(
    LPCWSTR   pszFileIn,
    const int nLineIn,
    LPCWSTR   pszModuleIn,
    LPCWSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN pvtblIn,
    LONG      cRefIn
    );

///////////////////////////////////////
//
// interface IUnknownTracker
//
//
class
IUnknownTracker :
    public IUnknown
{
public:
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)( void );
    STDMETHOD_(ULONG, Release)( void );
    STDMETHOD_(void, Stub3 )( void );
    STDMETHOD_(void, Stub4 )( void );
    STDMETHOD_(void, Stub5 )( void );
    STDMETHOD_(void, Stub6 )( void );
    STDMETHOD_(void, Stub7 )( void );
    STDMETHOD_(void, Stub8 )( void );
    STDMETHOD_(void, Stub9 )( void );
    STDMETHOD_(void, Stub10 )( void );
    STDMETHOD_(void, Stub11 )( void );
    STDMETHOD_(void, Stub12 )( void );
    STDMETHOD_(void, Stub13 )( void );
    STDMETHOD_(void, Stub14 )( void );
    STDMETHOD_(void, Stub15 )( void );
    STDMETHOD_(void, Stub16 )( void );
    STDMETHOD_(void, Stub17 )( void );
    STDMETHOD_(void, Stub18 )( void );
    STDMETHOD_(void, Stub19 )( void );
    STDMETHOD_(void, Stub20 )( void );
    STDMETHOD_(void, Stub21 )( void );
    STDMETHOD_(void, Stub22 )( void );
    STDMETHOD_(void, Stub23 )( void );
    STDMETHOD_(void, Stub24 )( void );
    STDMETHOD_(void, Stub25 )( void );
    STDMETHOD_(void, Stub26 )( void );
    STDMETHOD_(void, Stub27 )( void );
    STDMETHOD_(void, Stub28 )( void );
    STDMETHOD_(void, Stub29 )( void );
    STDMETHOD_(void, Stub30 )( void );

}; //*** interface IUnknownTracker

///////////////////////////////////////
//
// interface IDeadObjTracker
//
class
IDeadObjTracker
{
private: // Members
    VTBL2 m_vtbl;

public:
    STDMETHOD( Stub0 )( LPVOID* punk );
    STDMETHOD( Stub1 )( LPVOID* punk );
    STDMETHOD( Stub2 )( LPVOID* punk );
    STDMETHOD( Stub3 )( LPVOID* punk );
    STDMETHOD( Stub4 )( LPVOID* punk );
    STDMETHOD( Stub5 )( LPVOID* punk );
    STDMETHOD( Stub6 )( LPVOID* punk );
    STDMETHOD( Stub7 )( LPVOID* punk );
    STDMETHOD( Stub8 )( LPVOID* punk );
    STDMETHOD( Stub9 )( LPVOID* punk );
    STDMETHOD( Stub10 )( LPVOID* punk );
    STDMETHOD( Stub11 )( LPVOID* punk );
    STDMETHOD( Stub12 )( LPVOID* punk );
    STDMETHOD( Stub13 )( LPVOID* punk );
    STDMETHOD( Stub14 )( LPVOID* punk );
    STDMETHOD( Stub15 )( LPVOID* punk );
    STDMETHOD( Stub16 )( LPVOID* punk );
    STDMETHOD( Stub17 )( LPVOID* punk );
    STDMETHOD( Stub18 )( LPVOID* punk );
    STDMETHOD( Stub19 )( LPVOID* punk );
    STDMETHOD( Stub20 )( LPVOID* punk );
    STDMETHOD( Stub21 )( LPVOID* punk );
    STDMETHOD( Stub22 )( LPVOID* punk );
    STDMETHOD( Stub23 )( LPVOID* punk );
    STDMETHOD( Stub24 )( LPVOID* punk );
    STDMETHOD( Stub25 )( LPVOID* punk );
    STDMETHOD( Stub26 )( LPVOID* punk );
    STDMETHOD( Stub27 )( LPVOID* punk );
    STDMETHOD( Stub28 )( LPVOID* punk );
    STDMETHOD( Stub29 )( LPVOID* punk );
    STDMETHOD( Stub30 )( LPVOID* punk );

}; //*** interface IDeadObject


///////////////////////////////////////
//
// CITracker Class
//
class
CITracker:
    public IUnknownTracker
{
private: // Members
    VTBL2 m_vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPUNKNOWN * ppunkOut,
                     LPUNKNOWN punkIn,
                     const INTERFACE_TABLE_ENTRY * piteIn,
                     LPCWSTR pszNameIn,
                     LONG cRefIn
                     );

public: // Methods
    friend LPUNKNOWN DebugTrackInterface( LPCWSTR    pszFileIn,
                                          const int  nLineIn,
                                          LPCWSTR    pszModuleIn,
                                          LPCWSTR    pszNameIn,
                                          REFIID     riidIn,
                                          LPUNKNOWN  pvtblIn,
                                          LONG      cRefIn
                                          );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

}; //*** class CITracker

//
// END DEBUG WITH FULL INTERFACE TRACKING
//
///////////////////////////////////////
#else // !FULL_TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT FULL INTERFACE TRACKING
//

#ifdef _X86_
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#else
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#endif

//
// END DEBUG WITHOUT FULL INTERFACE TRACKING
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\debug.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Debug.h
//
//  Description:
//      Debugging utilities header.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// KB: USES_SYSALLOCSTRING gpease 8-NOV-1999
//      Turn this on if you are going to use the OLE automation
//      functions: SysAllocString, SysFreeString, etc..
//
// #define USES_SYSALLOCSTRING

//
// Trace Flags
//
typedef enum _TRACEFLAGS
{
    mtfALWAYS           = 0xFFFFFFFF,
    mtfNEVER            = 0x00000000,
    // function entry/exits, call, scoping
    mtfASSERT_HR        = 0x00000001,   // Halt if HRESULT is an error
    mtfQUERYINTERFACE   = 0x00000002,   // Query Interface details and halt on error
    // Asserts
    mtfSHOWASSERTS      = 0x00000004,   // Show assert message box
    //                  = 0x00000008,
    // other
    mtfCALLS            = 0x00000010,   // Function calls that use the TraceMsgDo macro
    mtfFUNC             = 0x00000020,   // Functions entrances w/parameters
    mtfSTACKSCOPE       = 0x00000040,   // if set, debug spew will generate bar/space for level each of the call stack
    mtfPERTHREADTRACE   = 0x00000080,   // Enables per thread tracing, excludes memory tracking.
    // specific
    mtfDLL              = 0x00000100,   // DLL specific
    mtfWM               = 0x00000200,   // Window Messages
    mtfFLOW             = 0x00000400,   // Control flow
    //                  = 0x00000800,
    // citracker spew
    mtfCITRACKERS       = 0x00001000,   // CITrackers will spew entrances and exits
    //                  = 0x00002000,
    //                  = 0x00004000,
    //                  = 0x00008000,
    mtfCOUNT            = 0x00010000,   // Displays count values (e.g. AddRefs and Releases)
    //                  = 0x00020000,
    //                  = 0x00040000,
    //                  = 0x00080000,
    //                  = 0x00100000,
    //                  = 0x00200000,
    //                  = 0x00400000,
    //                  = 0x00800000,
    // memory
    mtfMEMORYLEAKS      = 0x01000000,   // Halts when a memory leak is detected on thread exit
    mtfMEMORYINIT       = 0x02000000,   // Initializes new memory allocations to non-zero value
    mtfMEMORYALLOCS     = 0x04000000,   // Turns on spew to display each de/allocation.
    //                  = 0x08000000,
    // output prefixes
    mtfADDTIMEDATE      = 0x10000000,   // Replaces Filepath(Line) with Date/Time
    mtfBYMODULENAME     = 0x20000000,   // Puts the module name at the beginning of the line
    //                  = 0x40000000,
    mtfOUTPUTTODISK     = 0x80000000,   // Writes output to disk
} TRACEFLAGS;

typedef LONG TRACEFLAG;

#define ASZ_NEWLINE         "\r\n"
#define SZ_NEWLINE          L"\r\n"
#define SIZEOF_ASZ_NEWLINE  ( sizeof( ASZ_NEWLINE ) - sizeof( CHAR ) )
#define SIZEOF_SZ_NEWLINE   ( sizeof( SZ_NEWLINE ) - sizeof( WCHAR ) )
#define FREE_ADDRESS        0xFA
#define FREE_BLOCK          0xFB
#define AVAILABLE_ADDRESS   0xAA

#if defined( DEBUG ) || defined( _DEBUG )

#pragma message( "BUILD: DEBUG macros being built" )

//
// Globals
//
extern DWORD         g_TraceMemoryIndex;    // TLS index for the memory tracking link list
extern DWORD         g_dwCounter;           // Stack depth counter
extern TRACEFLAG     g_tfModule;            // Global tracing flags
extern const LPCWSTR g_pszModuleIn;         // Local module name - use DEFINE_MODULE
extern const WCHAR   g_szTrue[];            // Array "TRUE"
extern const WCHAR   g_szFalse[];           // Array "FALSE"
extern BOOL          g_fGlobalMemoryTacking; // Global memory tracking?

//
// Definition Macros
//
#define DEFINE_MODULE( _module )    const LPCWSTR g_pszModuleIn = TEXT(_module);
#define __MODULE__                  g_pszModuleIn
#define DEFINE_THISCLASS( _class )  static const WCHAR g_szClass[] = TEXT(_class);
#define __THISCLASS__               g_szClass

//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined( IMAGEHLP_ENABLED )
#include <imagehlp.h>
typedef BOOL ( * PFNSYMGETSYMFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL ( * PFNSYMGETLINEFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE );
typedef BOOL ( * PFNSYMGETMODULEINFO )( HANDLE, DWORD, PIMAGEHLP_MODULE );

extern HINSTANCE                g_hImageHlp;                // IMAGEHLP.DLL instance handle
extern PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr;
extern PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr;
extern PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo;
#endif // IMAGEHLP_ENABLED

//****************************************************************************
//
// Trace/Debug Functions - these do not exist in RETAIL.
//
//****************************************************************************

BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      paszFormatIn,
    ...
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCSTR      paszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCSTR      paszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessageDo(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    LPCWSTR     pszFuncIn,
    ...
    );

void
__cdecl
DebugMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMessageDo(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszFormatIn,
    LPCWSTR     pszFuncIn,
    ...
    );

BOOL
AssertMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    BOOL        fTrueIn,
    ...
    );

HRESULT
TraceHR(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn,
    ...
    );

ULONG
TraceWin32(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn,
    ...
    );

//
//  KB: 27 JUN 2001 GalenB
//
//  ifdef'd these functions out since they are not currently being used and
//  are thought to be useful in the future.
//
#if 0

void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR  paszFormatIn,
    ...
    );

void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    );

#endif  // end ifdef'd out code

void
__cdecl
TraceLogWrite(
    LPCWSTR pszTraceLineIn
    );

#if 0
//
// Trying to get the NTSTATUS stuff to play in "user world"
// is just about impossible. This is here in case it is needed
// and one could find the right combination of headers to
// make it work. Inflicting such pain on others is the reason
// why this function is #ifdef'fed.
//
void
DebugFindNTStatusSymbolicName(
      NTSTATUS  dwStatusIn
    , LPWSTR    pszNameOut
    , size_t *  pcchNameInout
    );
#endif  // end ifdef'd out code

void
DebugFindWinerrorSymbolicName(
      DWORD     scErrIn
    , LPWSTR    pszNameOut
    , size_t *  pcchNameInout
    );

void
DebugReturnMessage(
      LPCWSTR   pszFileIn
    , const int nLineIn
    , LPCWSTR   pszModuleIn
    , LPCWSTR   pszMessageIn
    , DWORD     scErrIn
    );

void
DebugIncrementStackDepthCounter( void );

void
DebugDecrementStackDepthCounter( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeProcess
//
//  Description:
//      Should be called in the DLL main on process attach or in the entry
//      routine of an EXE. Initializes debugging globals and TLS. Registers
//      the WMI tracing facilities (if WMI support is enabled).
//
//  Arguments:
//      _rgControl                  - Software tracing control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl              - The sizeof( _rgControl )
//      _fGlobalMemoryTrackingIn    -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceInitializeProcess( _rgControl, _sizeofControl, _fGlobalMemoryTrackingIn ) \
    { \
        DebugInitializeTraceFlags( _fGlobalMemoryTrackingIn ); \
        WMIInitializeTracing( _rgControl, _sizeofControl ); \
    }
#else // ! DEBUG_SW_TRACING_ENABLED
#define TraceInitializeProcess( _fGlobalMemoryTrackingIn ) \
    { \
        DebugInitializeTraceFlags( _fGlobalMemoryTrackingIn ); \
    }
#endif // DEBUG_SW_TRACING_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeThread
//
//  Description:
//      Should be called in the DLL thread attach or when a new thread is
//      created. Sets up the memory tracing for that thread as well as
//      establishing the tfThread for each thread (if mtfPERTHREADTRACE
//      is set in g_tfModule).
//
//  Arguments:
//      _name       NULL or the name of the thread.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeThread( _name ) \
    { \
        if ( g_fGlobalMemoryTacking == FALSE ) \
        { \
            TlsSetValue( g_TraceMemoryIndex, NULL ); \
        } \
        DebugInitializeThreadTraceFlags( _name ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceThreadRundown
//
//  Description:
//      Should be called before a thread terminates. It will check to make
//      sure all memory allocated by the thread was released properly. It
//      will also cleanup any per thread structures.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceThreadRundown() \
    { \
        if ( g_fGlobalMemoryTacking == FALSE ) \
        { \
            DebugMemoryCheck( NULL, NULL ); \
        } \
        DebugThreadRundownTraceFlags(); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceCreateMemoryList
//
//  Description:
//      Creates a thread-independent list to track objects.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceCreateMemoryList( _pmbIn ) \
    DebugCreateMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, &_pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateMemoryList
//
//  Description:
//      Checks to make sure the list is empty before destroying the list.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _pmbIn is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceTerminateMemoryList( _pmbIn ) \
    { \
        DebugMemoryCheck( _pmbIn, TEXT(#_pmbIn) ); \
        DebugDeleteMemoryList( _pmbIn ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveToMemoryList
//
//  Description:
//      Moves an object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMoveToMemoryList( _addr, _pmbIn ) \
//    DebugMoveToMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );
#define TraceMoveToMemoryList( _addr, _pmbIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveFromMemoryList
//
//  Description:
//      Moves an object from a thread independent memory list (_pmbIn) to the
//      per thread tracking list.
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMoveFromMemoryList( _addr, _pmbIn ) \
//    DebugMoveFromMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );
#define TraceMoveFromMemoryList( _addr, _pmbIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMemoryListDelete
//
//  Description:
//      Moves and object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _addr       - Address of object to delete.
//      _pmbIn      - Pointer to store the head of the list.
//      _fClobberIn -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMemoryListDelete( _addr, _pmbIn, _fClobberIn ) \
//    DebugMemoryListDelete( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn), _fClobberIn );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateProcess
//
//  Description:
//      Should be called before a process terminates. It cleans up anything
//      that the Debug APIs created. It will check to make sure all memory
//      allocated by the main thread was released properly. It will also
//      terminate WMI tracing (if WMI support is enabled). It also closes
//      the logging handle.
//
//  Arguments:
//      _rgControl     - WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl - the sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceTerminateProcess( _rgControl, _sizeofControl ) \
    { \
        WMITerminateTracing( _rgControl, _sizeofControl ); \
        if ( g_fGlobalMemoryTacking == FALSE ) \
        { \
            DebugMemoryCheck( NULL, NULL ); \
        } \
        DebugTerminateProcess(); \
    }
#else // ! DEBUG_SW_TRACING_ENABLED
//
//  TODO:   11 DEC 2000 GalenB
//
//  LogTerminateProcess() needs to be available for retail builds.
//  Since it doesn't yet do anything this isn't a problem, but that
//  of course can change...
//
#define TraceTerminateProcess() \
    { \
        if ( g_fGlobalMemoryTacking == FALSE ) \
        { \
            DebugMemoryCheck( NULL, NULL ); \
        } \
        DebugTerminateProcess(); \
    }
#endif // DEBUG_SW_TRACING_ENABLED

//****************************************************************************
//
// Debug initialization routines
//
// Uses should use the TraceInitializeXXX and TraceTerminateXXX macros, not
// these routines.
//
//****************************************************************************
void
DebugInitializeTraceFlags( BOOL fGlobalMemoryTackingIn = TRUE );

void
DebugInitializeThreadTraceFlags(
    LPCWSTR pszThreadNameIn
    );

void
DebugTerminateProcess( void );

void
DebugThreadRundownTraceFlags( void );

void
DebugCreateMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCWSTR     pszListNameIn
    );

void
DebugDeleteMemoryList( LPVOID pvIn );

/*
void
DebugMemoryListDelete(
    LPCWSTR pszFileIn,
    const int nLineIn,
    LPCWSTR pszModuleIn,
    void *  pvMemIn,
    LPVOID  pvListIn,
    LPCWSTR pszListNameIn,
    BOOL    fClobberIn
    );

void
DebugMoveToMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pmbListIn,
    LPCWSTR     pszListNameIn
    );

void
DebugMoveFromMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    HGLOBAL     hGlobal,
    LPVOID      pmbListIn,
    LPCWSTR     pszListNameIn
    );
*/
//****************************************************************************
//
// Memmory Allocation Subsitution Macros
//
// Replaces LocalAlloc/LocalFree, GlobalAlloc/GlobalFree, and malloc/free
//
//****************************************************************************
#define TraceAlloc( _flags, _size )                 DebugAlloc( mmbtHEAPMEMALLOC, TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceFree( _pvmem )                         DebugFree( mmbtHEAPMEMALLOC, _pvmem, TEXT(__FILE__), __LINE__, __MODULE__ )
#define TraceReAlloc( _pvmem, _size, _flags )       DebugReAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _pvmem, _flags, _size, TEXT(#_size) )

#define TraceLocalAlloc( _flags, _size )            DebugAlloc( mmbtLOCALMEMALLOC, TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceLocalFree( _pvmem )                    DebugFree( mmbtLOCALMEMALLOC, _pvmem, TEXT(__FILE__), __LINE__, __MODULE__ )

#define TraceMalloc( _flags, _size )                DebugAlloc( mmbtMALLOCMEMALLOC, TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceMallocFree( _pvmem )                   DebugFree( mmbtMALLOCMEMALLOC, _pvmem, TEXT(__FILE__), __LINE__, __MODULE__ )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceAllocString
//
//  Description:
//      Quick way to allocation a string that is the proper size and that will
//      be tracked by memory tracking.
//
//  Arguments:
//      _flags  - Allocation attributes.
//      _size   - Number of characters in the string to be allocated.
//
//  Return Values:
//      Handle/pointer to memory to be used as a string.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceAllocString( _flags, _size ) \
    (LPWSTR) DebugAlloc( \
          mmbtHEAPMEMALLOC \
        , TEXT(__FILE__) \
        , __LINE__ \
        , __MODULE__ \
        , _flags \
        , (_size) * sizeof( WCHAR ) \
        , TEXT(#_size) \
        )

//****************************************************************************
//
// Code Tracing Macros
//
//****************************************************************************

#if defined( DEBUG_SUPPORT_EXCEPTIONS )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTraceScope
//
//  Description:
//      This class traces entry and exit of a scope. This class is most
//      useful when using exception handling because the constructor will
//      get called automatically when an exception is thrown allowing the
//      exit from the scope to be traced.
//
//      To use this class, define DEBUG_SUPPORT_EXCEPTIONS in the modules
//      where you want this type of scope tracing.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTraceScope
{
public:

    const WCHAR * const m_pszFileName;
    const UINT          m_uiLine;
    const WCHAR * const m_pszModuleName;
    const WCHAR * const m_pszScopeName;
    bool                m_fIsDecremented;

    // Constructor - prints function entry.
    CTraceScope(
          const WCHAR * const   pszFileNameIn
        , const UINT            uiLineIn
        , const WCHAR * const   pszModuleNameIn
        , const WCHAR * const   pszScopeNameIn
        )
        : m_pszFileName( pszFileNameIn )
        , m_uiLine( uiLineIn )
        , m_pszModuleName( pszModuleNameIn   )
        , m_pszScopeName( pszScopeNameIn )
        , m_fIsDecremented( false )
    {
    } //*** CTraceScope::CTraceScope

    void DecrementStackDepthCounter( void )
    {
        m_fIsDecremented = true;
        DebugDecrementStackDepthCounter();

    } //*** CTraceScope::DecrementStackDepthCounter

    // Destructor - prints function exit.
    ~CTraceScope( void )
    {
        if ( g_tfModule != 0 )
        {
            if ( ! m_fIsDecremented )
            {
                TraceMessage(
                      m_pszFileName
                    , m_uiLine
                    , m_pszModuleName
                    , mtfFUNC
                    , L"V %ws"
                    , m_pszScopeName
                    );
                DecrementStackDepthCounter();
            }
        }

    } //*** CTraceScope::~CTraceScope

private:
    // Private copy constructor to prevent copying.
    CTraceScope( const CTraceScope & rtsIn );

    // Private assignment operator to prevent copying.
    const CTraceScope & operator = ( const CTraceScope & rtsIn );

}; //*** class CTraceScope
#define TraceDeclareScope()   \
    CTraceScope __scopeTracker__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) );
#define TraceDecrementStackDepthCounter() __scopeTracker__.DecrementStackDepthCounter()
#else // DEBUG_SUPPORT_EXCEPTIONS
#define TraceDeclareScope()
#define TraceDecrementStackDepthCounter() DebugDecrementStackDepthCounter()
#endif // DEBUG_SUPPORT_EXCEPTIONS

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFunc
//
//  Description:
//      Displays file, line number, module and "_szArgs" only if the mtfFUNC is
//      set in g_tfModule. "_szArgs" is the name of the function just
//      entered. It also increments the stack counter.
//
//  Arguments:
//      _szArgs     - Arguments for the function just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFunc( _szArgs ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )"  ); \
    }

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_szArgs"
// should contain a printf string on how to display the arguments.
//
#define TraceFunc1( _szArgs, _arg1 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1 ); \
    }

#define TraceFunc2( _szArgs, _arg1, _arg2 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1, _arg2 ); \
    }

#define TraceFunc3( _szArgs, _arg1, _arg2, _arg3 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1, _arg2, _arg3 ); \
    }

#define TraceFunc4( _szArgs, _arg1, _arg2, _arg3, _arg4 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1, _arg2, _arg3, _arg4 ); \
    }

#define TraceFunc5( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1, _arg2, _arg3, _arg4, _arg5 ); \
    }

#define TraceFunc6( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"+ " TEXT(__FUNCTION__) L"( " TEXT(_szArgs) L" )", _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceQIFunc
//
//  Description:
//      Just like TraceFunc but customized for QueryInterface.  Specifically,
//      displays the name of the interface and the value of the return pointer.
//
//  Arguments:
//      _riid       - Interface ID.
//      _ppv        - Return pointer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceQIFunc( _riid, _ppv ) \
    HRESULT __MissingTraceFunc; \
    TraceDeclareScope(); \
    if ( g_tfModule != 0 ) \
    { \
        WCHAR szGuid[ cchGUID_STRING_SIZE ]; \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( \
              TEXT(__FILE__) \
            , __LINE__ \
            , __MODULE__ \
            , mtfFUNC \
            , L"+ " TEXT(__FUNCTION__) L"( [IUnknown] %ws, ppv = %#x )" \
            , PszTraceFindInterface( _riid, szGuid ) \
            , _ppv \
            ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFuncExit
//
//  Description:
//      Return macro for TraceFunc() if the return type is void.  It also
//      decrements the stack counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFuncExit() \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            TraceDecrementStackDepthCounter(); \
        } \
        return; \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RETURN
//
//  Description:
//      Return macro for TraceFunc(). The _retval will be returned as the
//      result of the function. It also decrements the stack counter.
//
//  Arguments:
//      _retval - Result of the function.
//
//  Return Values:
//      _retval always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RETURN( _retval ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            TraceDecrementStackDepthCounter(); \
        } \
        return _retval; \
    }


/*
    return ( ( g_tfModule != 0 ) \
                ? ( TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ) \
                    , TraceDecrementStackDepthCounter() \
                    , _retval ) \
                : _retval )
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  CRETURN
//
//  Description:
//      Return macro for TraceFunc(). The _count will be returned as the
//      result of the function. It also decrements the stack counter. This
//      flavor will also display the _count as a count.
//
//  Arguments:
//      _count - Result of the function.
//
//  Return Values:
//      _count always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define CRETURN( _count ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC | mtfCOUNT, L"V Count = %d", _count ); \
            TraceDecrementStackDepthCounter(); \
        } \
        return _count; \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  FRETURN
//
//  Description:
//      This is a fake version of the return macro for TraceFunc().
//      *** This doesn't return. *** It also decrements the stack counter.
//
//  Arguments:
//      _retval - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define FRETURN( _retval ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            TraceDecrementStackDepthCounter(); \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  HRETURN
//
//  Description:
//      Return macro for TraceFunc(). The _hr will be returned as the result
//      of the function. If the value is not S_OK, it will be displayed in
//      the debugger. It also decrements the stack counter.
//
//  Arguments:
//      _hr - Result of the function.
//
//  Return Values:
//      _hr always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define HRETURN( _hr ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _hr != S_OK ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V hr = 0x%08x (%ws)", _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            } \
            TraceDecrementStackDepthCounter(); \
        } \
        return _hr; \
    }

//
// These next macros are just like HRETURN except they allow other
// exceptable values to be passed.back without causing extra spew.
//
#define HRETURN1( _hr, _arg1 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V hr = 0x%08x (%ws)", _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            } \
            TraceDecrementStackDepthCounter(); \
        } \
        return _hr; \
    }

#define HRETURN2( _hr, _arg1, _arg2 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V hr = 0x%08x (%ws)", _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            } \
            TraceDecrementStackDepthCounter(); \
        } \
        return _hr; \
    }

#define HRETURN3( _hr, _arg1, _arg2, _arg3 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) && ( _hr != _arg3 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V hr = 0x%08x (%ws)", _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            } \
            TraceDecrementStackDepthCounter(); \
        } \
        return _hr; \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  W32RETURN
//
//  Description:
//      Warning is display if return value is anything but ERROR_SUCCESS (0).
//
//  Argument:
//      _w32retval - Value to return.
//
//  Return Values:
//      _w32retval always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define W32RETURN( _w32retval ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _w32retval != ERROR_SUCCESS ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V " TEXT(#_w32retval) L" = 0x%08x (%ws)", _w32retval ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"V" ); \
            } \
            TraceDecrementStackDepthCounter(); \
        } \
        return _w32retval; \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0) only if
//      mtfQUERYINTERFACE is set in g_tfModule, otherwise only a debug
//      message will be printed. Note that TraceFunc() must have been called
//      on the call stack counter must be incremented prior to using.
//
//      QIRETURNx will ignore E_NOINTERFACE errors for the interfaces
//      specified.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls RETURN macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN( _hr, _riid ) \
    { \
        if ( _hr != S_OK ) \
        { \
            WCHAR   szGuid[ 40 ]; \
            WCHAR   szSymbolicName[ 64 ]; \
            size_t  cchSymbolicName = 64; \
            DebugFindWinerrorSymbolicName( _hr, szSymbolicName, &cchSymbolicName ); \
            Assert( cchSymbolicName != 64 ); \
            DebugMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          L"*HRESULT* QueryInterface( %ws, ppv ) failed(), hr = 0x%08x (%ws)", \
                          PszDebugFindInterface( _riid, szGuid ), \
                          _hr, \
                          szSymbolicName \
                          ); \
        } \
        if ( g_tfModule & mtfQUERYINTERFACE ) \
        { \
            __MissingTraceFunc = 0; \
            TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, S_OK ); \
        } \
        HRETURN( _hr ); \
    }

#define QIRETURN1( _hr, _riid, _riidIgnored1 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          && IsEqualIID( _riid, _riidIgnored1 ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN2( _hr, _riid, _riidIgnored1, _riidIgnored2 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN3( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN4( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN5( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN6( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN7( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6, _riidIgnored7 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
               || IsEqualIID( _riid, _riidIgnored7 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN8( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6, _riidIgnored7, _riidIgnored8 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
               || IsEqualIID( _riid, _riidIgnored7 ) \
               || IsEqualIID( _riid, _riidIgnored8 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

#define QIRETURN9( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6, _riidIgnored7, _riidIgnored8, _riidIgnored9 ) \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
               || IsEqualIID( _riid, _riidIgnored7 ) \
               || IsEqualIID( _riid, _riidIgnored8 ) \
               || IsEqualIID( _riid, _riidIgnored9 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN_IGNORESTDMARSHALLING
//
//  Description:
//      Works like QIRETURN (see QIRETURN above), but ignores E_NOINTERFACE for
//      the standard marshalling interfaces.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls QIRETURN5 macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN_IGNORESTDMARSHALLING( _hr, _riid ) \
    { \
        const GUID __COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID __IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN6( _hr, _riid, IID_IMarshal, __COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, __IID_IMarshalOptions_ ); \
    }

#define QIRETURN_IGNORESTDMARSHALLING1( _hr, _riid, _riid1 ) \
    { \
        const GUID __COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID __IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN7( _hr, _riid, IID_IMarshal, __COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _riid1, __IID_IMarshalOptions_ ); \
    }

#define QIRETURN_IGNORESTDMARSHALLING2( _hr, _riid, _riid1, _riid2 ) \
    { \
        const GUID __COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID __IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN8( _hr, _riid, IID_IMarshal, __COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _riid1, _riid2, __IID_IMarshalOptions_ ); \
    }

#define QIRETURN_IGNORESTDMARSHALLING3( _hr, _riid, _riid1, _riid2, _riid3 ) \
    { \
        const GUID __COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID __IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN9( _hr, _riid, IID_IMarshal, __COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _riid1, _riid2, _riid3, __IID_IMarshalOptions_ ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFlow
//
//  Description:
//      This macro outputs a string that is indented to the current depth.
//
//  Arguments:
//      _pszFormat - Format string.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFlow( _pszFormat ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat) ); \
        } \
    }

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_pszFormat"
// should contain a printf string on how to display the arguments.
//

#define TraceFlow1( _pszFormat, _arg1 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1 ); \
        } \
    }

#define TraceFlow2( _pszFormat, _arg1, _arg2 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1, _arg2 ); \
        } \
    }
#define TraceFlow3( _pszFormat, _arg1, _arg2, _arg3 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1, _arg2, _arg3 ); \
        } \
    }
#define TraceFlow4( _pszFormat, _arg1, _arg2, _arg3, _arg4 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4 ); \
        } \
    }
#define TraceFlow5( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
        } \
    }

#define TraceFlow6( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, L"| " TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceDo
//
//  Description:
//      Displays the file, line number, module and function call and return
//      from the function call (no return value displayed) for "_szExp" only
//      if the mtfCALLS is set in g_tfModule. Note return value is not
//      displayed. _szExp will be in RETAIL version of the product.
//
//  Arguments:
//      _szExp
//          The expression to be traced including assigment to the return
//          variable.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceDo( _szExp ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_szExp ) ); \
            _szExp; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"V" ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _szExp; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgDo
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgDo( hr = HrDoSomething(), "0x%08.8x" );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgDo( _pszExp, _pszReturnMsg ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

//
// These next macros are just like TraceMsgDo except they take additional
// arguments to display the values passed into the function call. "_pszReturnMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgDo1( _pszExp, _pszReturnMsg, _arg1 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgDo2( _pszExp, _pszReturnMsg, _arg1, _arg2 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgDo3( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgDo4( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgDo5( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgDo6( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgPreDo
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//      Same as TraceMsgDo except it displays the formatted message before
//      executing the expression.  Arguments for TraceMsgPreDo1, etc. are
//      applied to both _pszPreMsg and _pszReturnMsg.  The first substitution
//      string in _pszReturnMsg is for the return value from the function.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//
//      _pszPreMsg
//          A format string for displaying a message before the expression
//          is evaluated.
//
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgPreDo1( hr = HrDoSomething( bstrName ),
//                      "Name = '%ls'",
//                      "0x%08.8x, Name = '%ls'",
//                      bstrName
//                      );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgPreDo( _pszExp, _pszPreMsg, _pszReturnMsg ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

//
// These next macros are just like TraceMsgPreDo except they take additional
// arguments to display the values passed into the function call. "_pszPreMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgPreDo1( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg), _arg1 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgPreDo2( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg), _arg1, _arg2 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgPreDo3( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| " TEXT(_pszPreMsg), _arg1, _arg2, _arg3 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgPreDo4( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgPreDo5( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

#define TraceMsgPreDo6( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"+ " TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, L"| " TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgGUID
//
//  Description:
//      Dumps a GUID to the debugger only if one of the flags in _flags is
//      set in g_tfModule.
//
//  Arguments:
//      _flags   - Flags to check
//      _msg     - msg to print before GUID
//      _guid    - GUID to dump
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _guid is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceMsgGUID( _flags, _msg, _guid ) \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          _flags, \
                          L"%ws {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", \
                          TEXT(_msg), \
                          _guid.Data1, _guid.Data2, _guid.Data3,  \
                          _guid.Data4[ 0 ], _guid.Data4[ 1 ], _guid.Data4[ 2 ], _guid.Data4[ 3 ], \
                          _guid.Data4[ 4 ], _guid.Data4[ 5 ], _guid.Data4[ 6 ], _guid.Data4[ 7 ] ); \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  ErrorMsg
//
//  Description:
//      Print an error out. Can be used to write errors to a file. Note that
//      it will also print the source filename, line number and module name.
//
//  Arguments:
//      _szMsg  - Format string to be displayed.
//      _err    - Error code of the error.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define ErrorMsg( _szMsg, _err ) \
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfALWAYS, TEXT(__FUNCTION__) L": " TEXT(_szMsg), _err );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  WndMsg
//
//  Description:
//      Prints out a message to trace windows messages.
//
//  Arguments:
//      _hwnd   - The HWND
//      _umsg   - The uMsg
//      _wparam - The WPARAM
//      _lparam _ The LPARAM
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _wparam and _lparam are evaluated multiple times but the name
//          of the macro is mixed case.
#define WndMsg( _hwnd, _umsg, _wparam, _lparam ) \
    { \
        if ( g_tfModule & mtfWM ) \
        { \
            DebugMsg( L"%ws: WM   : hWnd = 0x%08x, uMsg = %u, wParam = 0x%08x (%u), lParam = 0x%08x (%u)", __MODULE__, _hwnd, _umsg, _wparam, _wparam, _lparam, _lparam ); \
        } \
    }

//****************************************************************************
//
//  Debug Macros
//
//  These calls are only compiled in DEBUG. They are a NOP in RETAIL
//  (not even compiled in).
//
//****************************************************************************

//
// Same as TraceDo() but only compiled in DEBUG.
//
#define DebugDo( _fn ) \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"+ " TEXT(#_fn ) ); \
        _fn; \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"V" ); \
        DebugDecrementStackDepthCounter(); \
    }


//
// Same as TraceMsgDo() but only compiled in DEBUG.
//
#define DebugMsgDo( _fn, _msg ) \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, L"+ " TEXT(#_fn) ); \
        DebugMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), TEXT(#_fn), _fn ); \
        DebugDecrementStackDepthCounter(); \
    }

//****************************************************************************
//
//  HRESULT testing macros
//
//  These functions check HRESULT return values and display UI if conditions
//  warrant only in DEBUG.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  IsTraceFlagSet
//
//  Description:
//      Checks to see of the flag is set in the global flags or in the per
//      thread flags. If you specify more than one flag and if any of them are
//      set, it will return TRUE.
//
//      In RETAIL this always return FALSE thereby effectively deleting the
//      block of the if statement. Example:
//
//          if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
//          {
//              //
//              // This code only exists in DEBUG.
//              .
//              .
//              .
//          }
//
//  Arguments:
//      _flags  - Flag to check for.
//
//  Return Values:
//      TRUE    - If DEBUG and flag set.
//      FLASE   - If RETAIL or flag not set.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define IsTraceFlagSet( _flag )    ( g_tfModule && IsDebugFlagSet( _flag ) )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  DBHR
//
//  Description:
//      The process will break into the debugg if a failed HRESULT is
//      specified. This can NOT be used in an expression.
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define DBHR( _hr ) \
    { \
        HRESULT hr; \
        hr = _hr; \
        if ( FAILED( hr ) ) \
        { \
            DEBUG_BREAK; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  THR
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0). This can be
//      used in an expression. Example:
//
//      hr = THR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define THR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, S_OK )

#define THRMSG( _hr, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, S_OK )
#define THRMSG1( _hr, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, S_OK, _arg1 )

#define THRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, _hrIgnore )

#define THREMSG( _hr, _hrIgnore, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, _hrIgnore )
#define THREMSG1( _hr, _hrIgnore, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, _hrIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  STHR
//
//  Description:
//      Warning is display if FAILED( _hr ) is TRUE. This can be use in an
//      expression. Example:
//
//      hr = STHR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define STHR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE, S_OK )

#define STHRMSG( _hr, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, S_OK )
#define STHRMSG1( _hr, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, S_OK, _arg1 )

#define STHRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE, _hrIgnore )

#define STHREMSG( _hr, _hrIgnore, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, _hrIgnore )
#define STHREMSG1( _hr, _hrIgnore, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, _hrIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TW32
//
//  Description:
//      Warning is display if result is anything but ERROR_SUCCESS (0). This
//      can be used in an expression. Example:
//
//      dwErr = TW32( RegOpenKey( HKLM, "foobar", &hkey ) );
//
//  Arguments:
//      _w32sc - Function expression to check.
//
//  Return Values:
//      Result of the "_fn" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TW32( _w32sc ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_w32sc), _w32sc, ERROR_SUCCESS )

#define TW32MSG( _w32sc, _msg ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _w32sc, ERROR_SUCCESS )
#define TW32MSG1( _w32sc, _msg, _arg1 ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _w32sc, ERROR_SUCCESS, _arg1 )

#define TW32E( _w32sc, _errIgnore ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_w32sc), _w32sc, _errIgnore )

#define TW32EMSG( _w32sc, _errIgnore, _msg ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _w32sc, _errIgnore )
#define TW32EMSG1( _w32sc, _errIgnore, _msg, _arg1 ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _w32sc, _errIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  BOOLTOSTRING
//
//  Desfription:
//      If _fBool is true, returns address of "TRUE" else returns address of
//      "FALSE".
//
//  Argument:
//      _fBool  - Expression to evaluate.
//
//  Return Values:
//      address of "TRUE" if _fBool is true.
//      address of "FALSE" if _fBool is false.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define BOOLTOSTRING( _fBool ) ( (_fBool) ? g_szTrue : g_szFalse )

//****************************************************************************
//
//  Use the TraceMemoryXXX wrappers, not the DebugMemoryXXX functions.
//  The memory tracking functions do not exist in RETAIL (converted to NOP).
//
//****************************************************************************

typedef enum EMEMORYBLOCKTYPE
{
      mmbtUNKNOWN = 0       // Never used
    , mmbtHEAPMEMALLOC      // HeapAlloc
    , mmbtLOCALMEMALLOC     // LocalAlloc
    , mmbtMALLOCMEMALLOC    // malloc
    , mmbtOBJECT            // Object pointer
    , mmbtHANDLE            // Object handle
    , mmbtPUNK              // IUnknown pointer
#if defined( USES_SYSALLOCSTRING )
    , mmbtSYSALLOCSTRING    // SysAllocString
#endif // USES_SYSALLOCSTRING
} EMEMORYBLOCKTYPE;

#define TraceMemoryAdd( _embtTypeIn, _pvMemIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn ) \
    DebugMemoryAdd( _embtTypeIn, _pvMemIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn )

#define TraceMemoryAddAddress( _pv ) \
    DebugMemoryAdd( mmbtHEAPMEMALLOC, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddLocalAddress( _pv ) \
    DebugMemoryAdd( mmbtLOCALMEMALLOC, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddMallocAddress( _pv ) \
    DebugMemoryAdd( mmbtMALLOCMEMALLOC, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddHandle( _handle ) \
    DebugMemoryAdd( mmbtHANDLE, _handle, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_handle) )

#define TraceMemoryAddObject( _pv ) \
    DebugMemoryAdd( mmbtOBJECT, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddPunk( _punk ) \
    DebugMemoryAdd( mmbtPUNK, _punk, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_punk) )

#define TraceMemoryDelete( _pvMemIn, _fClobberIn ) \
    DebugMemoryDelete( mmbtUNKNOWN, _pvMemIn, TEXT(__FILE__), __LINE__, __MODULE__, _fClobberIn )

#define TraceMemoryDeleteByType( _pvMemIn, _fClobberIn, _embt ) \
    DebugMemoryDelete( _embt, _pvMemIn, TEXT(__FILE__), __LINE__, __MODULE__, _fClobberIn )

#define TraceStrDup( _sz ) \
    (LPWSTR) DebugMemoryAdd( mmbtLOCALMEMALLOC, StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, 0, L"StrDup( " TEXT(#_sz) L" )" )

#if defined( USES_SYSALLOCSTRING )
#define TraceMemoryAddBSTR( _pv ) \
    DebugMemoryAdd( mmbtSYSALLOCSTRING, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocString( _sz ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocString( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, ((DWORD)( (( void *) &_sz[ 0 ]) == NULL ? 0 : wcslen( _sz ) + 1 )), L"SysAllocString( " TEXT(#_sz) L")" )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringByteLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringByteLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len, L"SysAllocStringByteLen( " TEXT(#_sz) L")" )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len + 1, L"SysAllocStringLen( " TEXT(#_sz) L")" )

#define TraceSysReAllocString( _bstrOrg, _bstrNew ) \
    DebugSysReAllocString( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, L"TraceSysReAllocString(" TEXT(#_bstrOrg) L", " TEXT(#_bstrNew) L" )" )

#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch ) \
    DebugSysReAllocStringLen( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, _cch, L"TraceSysReAllocString(" TEXT(#_bstrOrg) L", " TEXT(#_bstrNew) L", " TEXT(#_cch) L" )" )

#define TraceSysFreeString( _bstr ) \
    DebugMemoryDelete( mmbtSYSALLOCSTRING, _bstr, TEXT(__FILE__), __LINE__, __MODULE__, TRUE ); \
    SysFreeString( _bstr )
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Memory tracing functions - these are remapped to the HeapAlloc/HeapFree
//  heap functions when in RETAIL. Use the TraceMemoryXXX wrappers, not the
//  DebugMemoryXXX functions.
//
//****************************************************************************
void *
DebugAlloc(
    EMEMORYBLOCKTYPE    embtTypeIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn,
    UINT                uFlagsIn,
    DWORD               dwBytesIn,
    LPCWSTR             pszCommentIn
    );

void *
DebugReAlloc(
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn,
    void *              pvMemIn,
    UINT                uFlagsIn,
    DWORD               dwBytesIn,
    LPCWSTR             pszCommentIn
    );

BOOL
DebugFree(
    EMEMORYBLOCKTYPE    embtTypeIn,
    void *              pvMemIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn
    );

void *
DebugMemoryAdd(
      EMEMORYBLOCKTYPE  embtTypeIn
    , void *            pvMemIn
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , DWORD             dwBytesIn
    , LPCWSTR           pszCommentIn
    );

void
DebugMemoryDelete(
      EMEMORYBLOCKTYPE  embtTypeIn
    , void *            pvMemIn
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , BOOL              fClobberIn
    );

#if defined( USES_SYSALLOCSTRING )

INT
DebugSysReAllocString(
    LPCWSTR         pszFileIn,
    const int       nLineIn,
    LPCWSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCWSTR         pszCommentIn
    );

INT
DebugSysReAllocStringLen(
    LPCWSTR         pszFileIn,
    const int       nLineIn,
    LPCWSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCWSTR         pszCommentIn
    );

#endif // USES_SYSALLOCSTRING

void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCWSTR pszListNameIn
    );

//****************************************************************************
//
//  operator new() for C++
//
//****************************************************************************
#ifdef __cplusplus
extern
void *
__cdecl
operator new(
    size_t      nSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator new []() for C++
//
//****************************************************************************
extern
void *
__cdecl
operator new [](
    size_t      nSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    );
*/
//****************************************************************************
//
//  operator delete() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete(
    void *      pMemIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator delete []() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete [](
    void *      pMemIn,
    size_t      stSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    );
*/
//
// Remap "new" to our macro so "we" don't have to type anything extra and
// so it magically dissappears in RETAIL.
//
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )
#endif  // ifdef __cplusplus

//****************************************************************************
//
//
#else // it's RETAIL    ******************************************************
//
//
//****************************************************************************

#pragma message("BUILD: RETAIL macros being built")

//
// Debugging -> NOPs
//
#define DEFINE_MODULE( _module )
#define __MODULE__                                  NULL
#define DEFINE_THISCLASS( _class )
#define __THISCLASS__                               NULL
//#define DEFINE_SUPER( _super )
//#define __SUPERCLASS__                              NULL
#define BOOLTOSTRING( _fBool )                      NULL

#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define TraceMsgGUID( _f, _m, _g )

#define AssertMessage( a, b, c, d, e )              TRUE

//
// TODO: gpease 08-NOV-1999
//  We probably want to do something special for ErrorMsg()
//
#define ErrorMsg                    1 ? (void)0 : (void)__noop

#define TraceMsg                    1 ? (void)0 : (void)__noop
#define WndMsg                      1 ? (void)0 : (void)__noop
#define DebugMsg                    1 ? (void)0 : (void)__noop
#define DebugMsgNoNewline           1 ? (void)0 : (void)__noop
#define TraceMessage                1 ? (void)0 : (void)__noop
#define DebugMessage                1 ? (void)0 : (void)__noop
#define TraceHR                     1 ? (void)0 : (void)__noop
#define TraceFunc                   1 ? (void)0 : (void)__noop
#define TraceFunc1                  1 ? (void)0 : (void)__noop
#define TraceFunc2                  1 ? (void)0 : (void)__noop
#define TraceFunc3                  1 ? (void)0 : (void)__noop
#define TraceFunc4                  1 ? (void)0 : (void)__noop
#define TraceFunc5                  1 ? (void)0 : (void)__noop
#define TraceFunc6                  1 ? (void)0 : (void)__noop
#define TraceQIFunc                 1 ? (void)0 : (void)__noop
#define TraceFlow                   1 ? (void)0 : (void)__noop
#define TraceFlow1                  1 ? (void)0 : (void)__noop
#define TraceFlow2                  1 ? (void)0 : (void)__noop
#define TraceFlow3                  1 ? (void)0 : (void)__noop
#define TraceFlow4                  1 ? (void)0 : (void)__noop
#define TraceFlow5                  1 ? (void)0 : (void)__noop
#define TraceFlow6                  1 ? (void)0 : (void)__noop
#define TraceFuncExit()             return
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceInitializeProcess( _rgControl, _sizeofControl, _fGlobalMemoryTackingIn )
#define TraceTerminateProcess( _rgControl, _sizeofControl )
#else // ! DEBUG_SW_TRACING_ENABLED
#define TraceInitializeProcess( _fGlobalMemoryTackingIn )
#define TraceTerminateProcess()
#endif // DEBUG_SW_TRACING_ENABLED
#define TraceInitializeThread( _name )
#define TraceThreadRundown()
#define TraceMemoryAdd( _embtTypeIn, _pvMemIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn ) _pvMemIn
#define TraceMemoryAddHandle( _handle )                         _handle
#define TraceMemoryAddBSTR( _bstr )                             _bstr
#define TraceMemoryAddAddress( _pv )                            _pv
#define TraceMemoryAddLocalAddress( _pv )                       _pv
#define TraceMemoryAddMallocAddress( _pv )                      _pv
#define TraceMemoryAddHandle( _obj )                            _obj
#define TraceMemoryAddPunk( _punk )                             _punk
#define TraceMemoryDelete( _pvMemIn, _fClobberIn )              _pvMemIn
#define TraceMemoryDeleteByType( _pvMemIn, _fClobberIn, _embt ) _pvMemIn
#define TraceMemoryAddObject( _pv )                             _pv
#define IsTraceFlagSet( _flag )                                 FALSE

//
// Tracing -> just do operation
//
#define TraceDo( _fn )  _fn

#define TraceMsgDo( _fn, _msg )                                             _fn
#define TraceMsgDo1( _fn, _msg, _arg1 )                                     _fn
#define TraceMsgDo2( _fn, _msg, _arg1, _arg2 )                              _fn
#define TraceMsgDo3( _fn, _msg, _arg1, _arg2, _arg3 )                       _fn
#define TraceMsgDo4( _fn, _msg, _arg1, _arg2, _arg3, _arg4 )                _fn
#define TraceMsgDo5( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5 )         _fn
#define TraceMsgDo6( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )  _fn

#define TraceMsgPreDo( _fn, _msg1, _msg2 )                                              _fn
#define TraceMsgPreDo1( _fn, _msg1, _msg2, _arg1 )                                      _fn
#define TraceMsgPreDo2( _fn, _msg1, _msg2, _arg1, _arg2 )                               _fn
#define TraceMsgPreDo3( _fn, _msg1, _msg2, _arg1, _arg2, _arg3 )                        _fn
#define TraceMsgPreDo4( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4 )                 _fn
#define TraceMsgPreDo5( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5 )          _fn
#define TraceMsgPreDo6( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )   _fn

#define TraceAssertIfZero( _fn )    _fn

//
// RETURN testing -> do retail
//
#define DBHR( _hr )                                 _hr
#define THR( _hr )                                  _hr
#define THRMSG( _hr, _msg )                         _hr
#define THRMSG1( _hr, _msg, _arg1 )                 _hr
#define THRE( _hr, _hrIgnore )                      _hr
#define THREMSG( _hr, _hrIgnore, _msg )             _hr
#define THREMSG1( _hr, _hrIgnore, _msg, _arg1 )     _hr
#define STHR( _hr )                                 _hr
#define STHRMSG( _hr, _msg )                        _hr
#define STHRMSG1( _hr, _msg, _arg1 )                _hr
#define STHRE( _hr, _hrIgnore )                     _hr
#define STHREMSG( _hr, _hrIgnore, _msg )            _hr
#define STHREMSG1( _hr, _hrIgnore, _msg, _arg1 )    _hr
#define TW32( _fn )                                 _fn
#define TW32MSG( _fn, _msg )                        _fn
#define TW32MSG1( _fn, _msg, _arg1 )                _fn
#define TW32E( _fn, _errIgnore )                    _fn
#define TW32EMSG( _fn, _errIgnore, _msg )           _fn
#define TW32EMSG1( _fn, _errIgnore, _msg, _arg1 )   _fn
#define RETURN( _retval )           return _retval
#define CRETURN( _count )           return _count
#define FRETURN( _fn )
#define W32RETURN( _w32retval )     return _w32retval
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi
#define QIRETURN1( _qi, _riid, _riid1 )      return _qi
#define QIRETURN2( _qi, _riid, _riid1, _riid2 )      return _qi
#define QIRETURN3( _qi, _riid, _riid1, _riid2, _riid3 )      return _qi
#define QIRETURN4( _qi, _riid, _riid1, _riid2, _riid3, _riid4 )      return _qi
#define QIRETURN5( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5 )      return _qi
#define QIRETURN6( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6 )      return _qi
#define QIRETURN7( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6, _riid7 )      return _qi
#define QIRETURN8( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6, _riid7, _riid8 )      return _qi
#define QIRETURN9( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6, _riid7, _riid8, _riid9 )      return _qi
#define QIRETURN_IGNORESTDMARSHALLING( _qi, _riid ) return _qi
#define QIRETURN_IGNORESTDMARSHALLING1( _qi, _riid, _riid1 ) return _qi
#define QIRETURN_IGNORESTDMARSHALLING2( _qi, _riid, _riid1, _riid2 ) return _qi
#define QIRETURN_IGNORESTDMARSHALLING3( _qi, _riid, _riid1, _riid2, _riid3 ) return _qi

//
// Memory Functions -> do retail
//
#define TraceAlloc( _flags, _size )                             HeapAlloc( GetProcessHeap(), _flags, _size )
#define TraceFree( _pv )                                        HeapFree( GetProcessHeap(), 0, _pv )
#define TraceReAlloc( _pvMem, _uBytes, _uFlags )                ( ( _pvMem == NULL ) \
                                                                ? HeapAlloc( GetProcessHeap(), _uFlags, _uBytes ) \
                                                                : HeapReAlloc( GetProcessHeap(), _uFlags, _pvMem, _uBytes ) )

#define TraceLocalAlloc( _flags, _size )                        LocalAlloc( _flags, _size )
#define TraceLocalFree( _pv )                                   LocalFree( _pv )

#define TraceMalloc( _size )                                    malloc( _size )
#define TraceMallocFree( _pv )                                  free( _pv )

#define TraceAllocString( _flags, _size )                       (LPWSTR) HeapAlloc( GetProcessHeap(), flags, (_size) * sizeof( WCHAR ) )
#define TraceStrDup( _sz )                                      StrDup( _sz )

#if defined( USES_SYSALLOCSTRING )
#define TraceSysAllocString( _sz )                              SysAllocString( _sz )
#define TraceSysAllocStringByteLen( _sz, _len )                 SysAllocStringByteLen( _sz, _len )
#define TraceSysAllocStringLen( _sz, _len )                     SysAllocStringLen( _sz, _len )
#define TraceSysReAllocString( _bstrOrg, _bstrNew )             SysReAllocString( _bstrOrg, _bstrNew )
#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch )    SysReAllocStringLen( _bstrOrg, _bstrNew, _cch )
#define TraceSysFreeString( _bstr )                             SysFreeString( _bstr )
#endif // USES_SYSALLOCSTRING

#define TraceCreateMemoryList( _pvIn )
#define TraceMoveToMemoryList( _addr, _pvIn )
//#define TraceMemoryListDelete( _addr, _pvIn, _fClobber )
#define TraceTerminateMemoryList( _pvIn )
#define TraceMoveFromMemoryList( _addr, _pmbIn )

#endif // DEBUG

#if DBG==1 || defined( _DEBUG )
//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and
//      DebugBreak()s, This x86 only macro causes the program to break in the
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ ) && ! defined( DEBUG_SUPPORT_EXCEPTIONS )
#define DEBUG_BREAK         { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} }
#else
#define DEBUG_BREAK         DebugBreak()
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  Assert
//
//  Description:
//      Checks to see if the Expression is TRUE. If not, a message will be
//      displayed to the user on wether the program should break or continue.
//
//  Arguments:
//      _fn     - Expression being asserted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef Assert
#undef Assert
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          __fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define Assert( _fn ) \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertMsg
//
//  Description:
//      Just like an Assert but has an (hopefully) informative message
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - Message to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertMsg
#undef AssertMsg
#undef AssertMsg1
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          _fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define AssertMsg( _fn, _msg ) \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    }
#define AssertMsg1( _fn, _msg, _arg1 ) \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn), _arg1 ) ) \
        { \
            DEBUG_BREAK; \
        } \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertString
//
//  Descrption:
//      Just like an Assert but has a (hopefully) informative string
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - String to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertString
#undef AssertString
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          _fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define AssertString( _fn, _str ) \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, _str, !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    }

#undef VERIFY
#undef VERIFYMSG
#undef VERIFYMSG1
#undef VERIFYSTRING

#define VERIFY( _fn )                   Assert( _fn )
#define VERIFYMSG( _fn, _msg )          AssertMsg( _fn, _msg )
#define VERIFYMSG1( _fn, _msg, _arg1 )  AssertMsg1( _fn, _msg, _arg1 )
#define VERIFYSTRING( _fn, _str )       AssertString( _fn, _str )

#else // DBG!=1 && !_DEBUG

#define DEBUG_BREAK DebugBreak()

#ifndef Assert
#define Assert( _fn )
#endif

#ifndef AssertMsg
#define AssertMsg( _fn, _msg )
#endif

#ifndef AssertMsg1
#define AssertMsg1( _fn, _msg, _arg1 )
#endif

#ifndef AssertString
#define AssertString( _fn, _msg )
#endif

#ifndef VERIFY
#define VERIFY( _fn ) _fn
#endif

#ifndef VERIFYMSG
#define VERIFYMSG( _fn, _msg ) _fn
#endif

#ifndef VERIFYMSG1
#define VERIFYMSG1( _fn, _msg, _arg1 ) _fn
#endif

#ifndef VERIFYSTRING
#define VERIFYSTRING( _fn, _str ) _fn
#endif

#endif // DBG==1 || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\debugsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      DebugSrc.cpp
//
//  Description:
//      Debugging utilities.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//  Note:
//      THRs and TW32s should NOT be used in this module because they
//      could cause an infinite loop.
//
//////////////////////////////////////////////////////////////////////////////

// #include <Pch.h>     // should be included by includer of this file
#include <stdio.h>
#include <StrSafe.h>    // in case it isn't included by header file

#if defined( DEBUG )
//
// Include the WINERROR, HRESULT and NTSTATUS codes
//
#include <winerror.dbg>

//
// Constants
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 1024;
static const int cchFILEPATHLINESIZE         = 85;
static const int TRACE_OUTPUT_BUFFER_SIZE    = 1024;

//
// Globals
//
DWORD       g_TraceMemoryIndex          = (DWORD) -1;
DWORD       g_TraceFlagsIndex           = (DWORD) -1;
DWORD       g_ThreadCounter             = 0;
DWORD       g_dwCounter                 = 0;
TRACEFLAG   g_tfModule                  = mtfNEVER;
LONG        g_lDebugSpinLock            = FALSE;
BOOL        g_fGlobalMemoryTacking      = TRUE;

static CRITICAL_SECTION *   g_pcsTraceLog = NULL;
static HANDLE               g_hTraceLogFile = INVALID_HANDLE_VALUE;

//
// Strings
//
static const WCHAR g_szNULL[]       = L"";
static const WCHAR g_szFileLine[]   = L"%ws(%u):";
static const WCHAR g_szFormat[]     = L"%-60ws  %-10.10ws ";
static const WCHAR g_szUnknown[]    = L"<unknown>";

//
// Exported Strings
//
const WCHAR g_szTrue[]       = L"True";
const WCHAR g_szFalse[]      = L"False";

//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined(IMAGEHLP_ENABLED)
//
// ImageHelp
//
typedef VOID (*PFNRTLGETCALLERSADDRESS)(PVOID*,PVOID*);

HINSTANCE                g_hImageHlp                = NULL;
PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr     = NULL;
PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr    = NULL;
PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo      = NULL;
PFNRTLGETCALLERSADDRESS  g_pfnRtlGetCallersAddress  = NULL;
#endif // IMAGEHLP_ENABLED

//
// Per thread structure.
//
typedef struct _SPERTHREADDEBUG {
    DWORD   dwFlags;
    DWORD   dwStackCounter;
    LPCWSTR pcszName;
} SPerThreadDebug;

//
//  Externs
//
extern LPVOID g_GlobalMemoryList;

//
//  Forward declarations.
//

HRESULT HrTraceLogClose( void );

//****************************************************************************
//
//  Debugging and Tracing Routines
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// DebugIncrementStackDepthCounter
//
// Description:
//      Increases the stack scope depth counter. If "per thread" tracking is
//      on it will increment the "per thread" counter. Otherwise, it will
//      increment the "global" counter.
//
// Arguments:
//      None.
//
// Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
void
DebugIncrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter++;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedIncrement( (LONG*) &g_dwCounter );
    } // else: global

} //*** DebugIncrementStackDepthCounter

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugDecrementStackDepthCounter
//
//  Description:
//      Decreases the stack scope depth counter. If "per thread" tracking is
//      on it will decrement the "per thread" counter. Otherwise, it will
//      decrement the "global" counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDecrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter--;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedDecrement( (LONG*) &g_dwCounter );
    } // else: global

} //*** DebugDecrementStackDepthCounter

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugAcquireSpinLock
//
//  Description:
//      Acquires the spin lock pointed to by pLock.
//
//  Arguments:
//      pLock   - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugAcquireSpinLock(
    LONG * pLock
    )
{
    for(;;)
    {
        LONG lInitialValue;

        lInitialValue = InterlockedCompareExchange( pLock, TRUE, FALSE );
        if ( lInitialValue == FALSE )
        {
            //
            // Lock acquired.
            //
            break;
        } // if: got lock
        else
        {
            //
            // Sleep to give other thread a chance to give up the lock.
            //
            Sleep( 1 );
        } // if: lock not acquired

    } // for: forever

} //*** DebugAcquireSpinLock

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugReleaseSpinLock
//
//  Description:
//      Releases the spin lock pointer to by pLock.
//
//  Arguments:
//      pLock       - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReleaseSpinLock(
    LONG * pLock
    )
{
    *pLock = FALSE;

} //*** DebugReleaseSpinLock

//////////////////////////////////////////////////////////////////////////////
//++
//
//  IsDebugFlagSet
//
//  Description:
//      Checks the global g_tfModule and the "per thread" Trace Flags to
//      determine if the flag (any of the flags) are turned on.
//
//  Arguments:
//      tfIn        - Trace flags to compare.
//
//  Return Values:
//      TRUE        At least of one of the flags are present.
//      FALSE       None of the flags match.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    )
{
    if ( g_tfModule & tfIn )
    {
        return TRUE;
    } // if: global flag set

    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & tfIn
           )
        {
            return TRUE;
        }   // if: per thread flag set

    } // if: per thread settings

    return FALSE;

} //*** IsDebugFlagSet

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugOutputString
//
//  Description:
//      Dumps the spew to the appropriate orifice.
//
//  Arguments:
//      pszIn       Message to dump.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugOutputString(
    LPCWSTR pszIn
    )
{
    if ( IsTraceFlagSet( mtfOUTPUTTODISK ) )
    {
        TraceLogWrite( pszIn );
    } // if: trace to file
    else
    {
        DebugAcquireSpinLock( &g_lDebugSpinLock );
        OutputDebugString( pszIn );
        DebugReleaseSpinLock( &g_lDebugSpinLock );
        Sleep( 1 );
    } // else: debugger

} //*** DebugOutputString

#if 0
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugFindNTStatusSymbolicName
//
//  Description:
//      Uses the NTBUILD generated ntstatusSymbolicNames table to lookup
//      the symbolic name for the status code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      dwStatusIn    - Status code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindNTStatusSymbolicName(
      NTSTATUS  dwStatusIn
    , LPWSTR    pszNameOut
    , size_t *  pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );

    int     idx = 0;
    size_t  cch = 0;

    while ( ntstatusSymbolicNames[ idx ].SymbolicName )
    {
        if ( ntstatusSymbolicNames[ idx ].MessageId == dwStatusIn )
        {
            *pcchNameInout = mbstowcs( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    THR( StringCchCopyExW( pszNameOut, *pcchNameInout, g_szUnknown, NULL, &cch, 0 ) );
    *pcchNameInout -= cch;

} //*** DebugFindNTStatusSymbolicName
*/
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//  DebugFindWinerrorSymbolicName
//
//  Description:
//      Uses the NTBUILD generated winerrorSymbolicNames table to lookup
//      the symbolic name for the error code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      scErrIn       - Error code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindWinerrorSymbolicName(
      DWORD     scErrIn
    , LPWSTR    pszNameOut
    , size_t *  pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );

    int             idx = 0;
    DWORD           scode;
    size_t          cchRemaining = 0;
    static LPCWSTR  s_pszS_FALSE = L"S_FALSE / ERROR_INVALID_FUNCTION";

    //
    // If this is a Win32 wrapped in HRESULT stuff, remove the
    // HRESULT stuff so that the code will be found in the table.
    //
    if ( SCODE_FACILITY( scErrIn ) == FACILITY_WIN32 )
    {
        scode = SCODE_CODE( scErrIn );
    } // if: Win32 error code
    else
    {
        scode = scErrIn;
    } // else: not Win32 error code

    if ( scode == S_FALSE )
    {
        THR( StringCchCopyExW( pszNameOut, *pcchNameInout, s_pszS_FALSE, NULL, &cchRemaining, 0 ) );
        *pcchNameInout -= cchRemaining;
        goto Cleanup;
    }

    while ( winerrorSymbolicNames[ idx ].SymbolicName )
    {
        if ( winerrorSymbolicNames[ idx ].MessageId == scode )
        {
            *pcchNameInout = mbstowcs( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
            goto Cleanup;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    THR( StringCchCopyExW( pszNameOut, *pcchNameInout, g_szUnknown, NULL, &cchRemaining, 0 ) );
    *pcchNameInout -= cchRemaining;

Cleanup:

    return;

} //*** DebugFindWinerrorSymbolicName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugReturnMessage
//
//  Description:
//      Prints the spew for a function return with error code.
//
//      The primary reason for doing this is to isolate the stack from adding
//      the extra size of szSymbolicName to every function.
//
//  Argument:
//      pszFileIn       - File path to insert
//      nLineIn         - Line number to insert
//      pszModuleIn     - Module name to insert
//      pszMessageIn    - Message to display
//      scErrIn         - Error code
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReturnMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszMessageIn,
    DWORD       scErrIn
    )
{
    WCHAR   szSymbolicName[ 64 ]; // random
    size_t  cchSymbolicName;

    cchSymbolicName = RTL_NUMBER_OF( szSymbolicName );
    DebugFindWinerrorSymbolicName( scErrIn, szSymbolicName, &cchSymbolicName );
    Assert( cchSymbolicName != RTL_NUMBER_OF( szSymbolicName ) );
    TraceMessage( pszFileIn, nLineIn, pszModuleIn, mtfFUNC, pszMessageIn, scErrIn, szSymbolicName );

} //*** DebugReturnMessage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugInitializeBuffer
//
//  Description:
//      Intializes the output buffer with "File(Line)  Module  ".
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeBuffer(
      LPCWSTR   pszFileIn
    , const int nLineIn
    , LPCWSTR   pszModuleIn
    , LPWSTR    pszBufIn
    , size_t *  pcchInout
    , LPWSTR *  ppszBufOut
    )
{
    size_t  cchRemaining = *pcchInout;
    LPWSTR  pszBuf = pszBufIn;

    static WCHAR szBarSpace[] =
        L"| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ";
    //                      1                   2                   3                   4                   5
    //    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0

    //
    // Add date/time stamp
    //
    if ( IsTraceFlagSet( mtfADDTIMEDATE ) )
    {
        static WCHAR        s_szTimeBuffer[ 25 ];
        static size_t       s_cchTimeBuffer = 0;
        static SYSTEMTIME   s_OldSystemTime = { 0 };

        SYSTEMTIME  stCurrentSystemTime;
        int         iCmp;

        GetLocalTime( &stCurrentSystemTime );

        //
        // Avoid expensive printf by comparing times
        //
        iCmp = memcmp( (PVOID) &stCurrentSystemTime, (PVOID) &s_OldSystemTime, sizeof( stCurrentSystemTime ) );
        if ( iCmp != 0 )
        {
            size_t  cchTimeBufferRemaining = 0;

            CopyMemory( &s_OldSystemTime, &stCurrentSystemTime, sizeof( stCurrentSystemTime ) );

            DBHR( StringCchPrintfExW(
                              s_szTimeBuffer
                            , RTL_NUMBER_OF( s_szTimeBuffer )
                            , NULL
                            , &cchTimeBufferRemaining
                            , 0
                            , L"%02u/%02u/%04u %02u:%02u:%02u.%03u "
                            , stCurrentSystemTime.wMonth
                            , stCurrentSystemTime.wDay
                            , stCurrentSystemTime.wYear
                            , stCurrentSystemTime.wHour
                            , stCurrentSystemTime.wMinute
                            , stCurrentSystemTime.wSecond
                            , stCurrentSystemTime.wMilliseconds
                            ) );
            s_cchTimeBuffer = RTL_NUMBER_OF( s_szTimeBuffer ) - cchTimeBufferRemaining;

            if ( s_cchTimeBuffer != 24 )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: string length != 24

        } // if: old and current times do not match

        DBHR( StringCchCopyNExW( pszBuf, cchRemaining, s_szTimeBuffer, s_cchTimeBuffer, &pszBuf, &cchRemaining, 0 ) );

    } // if: time/date
    else
    {
        size_t  cch = 0;    // Used to make sure the filepath portion of the string is the right size

        //
        // Add the filepath and line number
        //
        if ( pszFileIn != NULL )
        {
            size_t  cchCurrent = cchRemaining;

            DBHR( StringCchPrintfExW( pszBuf, cchCurrent, &pszBuf, &cchRemaining, 0, g_szFileLine, pszFileIn, nLineIn ) );
            cch = cchCurrent - cchRemaining;
        } // if: filename string specified

        if (    ( IsDebugFlagSet( mtfSTACKSCOPE )
               && IsDebugFlagSet( mtfFUNC )
                )
          || pszFileIn != NULL
           )
        {
            for ( ; cch < cchFILEPATHLINESIZE ; cch++, cchRemaining-- )
            {
                if ( cchRemaining == 0 )
                {
                    DEBUG_BREAK;
                }
                *pszBuf = L' ';
                pszBuf++;
            } // for: cch
            *pszBuf = L'\0';

            if ( cch != cchFILEPATHLINESIZE )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != cchFILEPATHLINESIZE

        } // if: have a filepath or ( scoping and func is on )

    } // else: normal (no time/date)

    //
    // Add module name
    //
    if ( IsTraceFlagSet( mtfBYMODULENAME ) )
    {
        if ( pszModuleIn == NULL )
        {
            DBHR( StringCchCopyExW( pszBuf, cchRemaining, g_szUnknown, &pszBuf, &cchRemaining, 0 ) );
        } // if:
        else
        {
            DBHR( StringCchCopyExW( pszBuf, cchRemaining, pszModuleIn, &pszBuf, &cchRemaining, 0 ) );

        } // else:

        DBHR( StringCchCopyExW( pszBuf, cchRemaining, L": ", &pszBufIn, &cchRemaining, 0 ) );

    } // if: add module name

    //
    // Add the thread id if "per thread" tracing is on.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        //
        // And check the "per thread" to see if this particular thread
        // is supposed to be displaying its ID.
        //
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & mtfPERTHREADTRACE
           )
        {
            DBHR( StringCchPrintfExW( pszBuf, cchRemaining, &pszBuf, &cchRemaining, 0, L"~%08x~ ", GetCurrentThreadId() ) );
        } // if: turned on in the thread

    } // if: tracing by thread

    //
    // Add the "Bar Space" for stack scoping
    //

    // Both flags must be set
    if ( IsDebugFlagSet( mtfSTACKSCOPE )
      && IsDebugFlagSet( mtfFUNC )
       )
    {
        DWORD dwCounter;

        //
        // Choose "per thread" or "global" counter.
        //
        if ( g_tfModule & mtfPERTHREADTRACE )
        {
            SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
            if ( ptd != NULL )
            {
                dwCounter = ptd->dwStackCounter;
            } // if: ptd
            else
            {
                dwCounter = 0;
            } // else: assume its not initialized yet

        } // if: per thread
        else
        {
            dwCounter = g_dwCounter;
        } // else: global counter

        if ( dwCounter >= 50 )
        {
            DEBUG_BREAK;    // can't assert!
        } // if: dwCounter not vaild

        if ( ( dwCounter > 1 ) && ( dwCounter < 50 ) )
        {
            size_t  cchCount = ( dwCounter - 1 ) * 2;
            DBHR( StringCchCopyNExW( pszBuf, cchRemaining, szBarSpace, cchCount, &pszBuf, &cchRemaining, 0 ) );
        } // if: within range

    } // if: stack scoping on

    *ppszBufOut = pszBuf;
    *pcchInout = cchRemaining;

} //*** DebugInitializeBuffer

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugNoOp
//
//  Description:
//      Returns FALSE. Used to replace ImageHlp routines it they weren't
//      loaded or not found.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE, always.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugNoOp( void )
{
    return FALSE;

} //*** DebugNoOp
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugInitializeTraceFlags
//
//  Description:
//      Retrieves the default tracing flags for this module from an INI file
//      that is named the same as the EXE file (e.g. MMC.EXE -> MMC.INI).
//      Typically, this is called from the TraceInitializeProcess() macro.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeTraceFlags( BOOL fGlobalMemoryTackingIn )
{
    WCHAR   szSection[ 64 ];
    WCHAR   szFiles[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    WCHAR   szPath[ MAX_PATH ];
    LPWSTR  psz;
    size_t  cch = 0;

    g_fGlobalMemoryTacking = fGlobalMemoryTackingIn;

    //
    // Allocate TLS for memory tracking
    //
    if ( !g_fGlobalMemoryTacking )
    {
        Assert( g_TraceMemoryIndex == -1 );
        g_TraceMemoryIndex = TlsAlloc();
        TlsSetValue( g_TraceMemoryIndex, NULL);
    } // if:

    //
    // Initialize module trace flags
    //

    //
    // Get the EXEs filename and change the extension to INI.
    //
    cch = GetModuleFileNameW( NULL, szPath, RTL_NUMBER_OF( szPath ) - 4 );
    Assert( cch != 0 ); // error in GetModuleFileName
    THR( StringCchCopyW( &szPath[ cch - 3 ], 4, L"ini" ) );
    g_tfModule = (TRACEFLAG) GetPrivateProfileInt( __MODULE__, L"TraceFlags", 0, szPath );
    DebugMsg( L"DEBUG: Reading %ws" SZ_NEWLINE L"%ws: DEBUG: g_tfModule = 0x%08x", szPath, __MODULE__, g_tfModule );

    //
    // Initialize thread trace flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex == -1 );
        g_TraceFlagsIndex = TlsAlloc();
        DebugInitializeThreadTraceFlags( NULL );
    } // if: per thread tracing

    //
    // Force the loading of certain modules
    //
    GetPrivateProfileStringW( __MODULE__, L"ForcedDLLsSection", g_szNULL, szSection, 64, szPath );
    ZeroMemory( szFiles, sizeof( szFiles ) );
    GetPrivateProfileSectionW( szSection, szFiles, RTL_NUMBER_OF( szFiles ), szPath );
    psz = szFiles;
    while ( *psz )
    {
        WCHAR szExpandedPath[ MAX_PATH ];
        ExpandEnvironmentStringsW( psz, szExpandedPath, RTL_NUMBER_OF( szExpandedPath ) );
        DebugMsg( L"DEBUG: Forcing %ws to be loaded.", szExpandedPath );
        LoadLibraryW( szExpandedPath );
        psz += wcslen( psz ) + 1;
    } // while: entry found

#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // Load symbols for our module
    //
    g_hImageHlp = LoadLibraryExW( L"imagehlp.dll", NULL, 0 );
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMINITIALIZE)(HANDLE, PSTR, BOOL);
        PFNSYMINITIALIZE pfnSymInitialize;
        pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress( g_hImageHlp, "SymInitialize" );
        if ( pfnSymInitialize != NULL )
        {
            pfnSymInitialize( GetCurrentProcess(), NULL, TRUE );
        } // if: got address

        //
        // Grab the other addresses we need. Replace them with a "no op" if they are not found
        //
        g_pfnSymGetSymFromAddr  = (PFNSYMGETSYMFROMADDR)    GetProcAddress( g_hImageHlp, "SymGetSymFromAddr"    );
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR)   GetProcAddress( g_hImageHlp, "SymGetLineFromAddr"   );
        g_pfnSymGetModuleInfo   = (PFNSYMGETMODULEINFO)     GetProcAddress( g_hImageHlp, "SymGetModuleInfo"     );

    } // if: imagehlp loaded

    //
    // If loading IMAGEHLP failed, we need to point these to the "no op" routine.
    //
    if ( g_pfnSymGetSymFromAddr == NULL )
    {
        g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetLineFromAddr == NULL )
    {
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetModuleInfo == NULL )
    {
        g_pfnSymGetModuleInfo = (PFNSYMGETMODULEINFO) &DebugNoOp;
    } // if: failed

    HINSTANCE hMod = LoadLibraryW( L"NTDLL.DLL" );
    g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) GetProcAddress( hMod, "RtlGetCallersAddress" );
    if ( g_pfnRtlGetCallersAddress == NULL )
    {
        g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) &DebugNoOp;
    } // if: failed
    */
#endif // IMAGEHLP_ENABLED

} //*** DebugInitializeTraceFlags

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugTerminateProcess
//
//  Description:
//      Cleans up anything that the debugging routines allocated or
//      initialized. Typically, you should call the TraceTerminateProcess()
//      macro just before your process exits.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminateProcess( void )
{
#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // ImageHlp Cleanup
    //
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMCLEANUP)(HANDLE);
        PFNSYMCLEANUP pfnSymCleanup;
        pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress( g_hImageHlp, "SymCleanup" );
        if ( pfnSymCleanup != NULL )
        {
            pfnSymCleanup( GetCurrentProcess() );
        } // if: found proc

        FreeLibrary( g_hImageHlp );

    } // if: imagehlp loaded
    */
#endif // IMAGEHLP_ENABLED

    //
    // Free the TLS storage
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TlsFree( g_TraceFlagsIndex );
    } // if: per thread tracing

    if ( !g_fGlobalMemoryTacking )
    {
        Assert( g_TraceMemoryIndex != -1 );

        TlsFree( g_TraceMemoryIndex );
    } // if:

    HrTraceLogClose();

} //*** DebugTerminateProcess

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugGetFunctionName
//
//  Description:
//      Retrieves the calling functions name.
//
//  Arguments:
//      paszNameOut - The buffer that will contain the functions name.
//      cchNameIn   - The size of the the out buffer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugGetFunctionName(
      LPSTR     paszNameOut
    , size_t    cchNameIn
    )
{
    PVOID pvCallersAddress;
    PVOID pvCallersCaller;
    BOOL  fSuccess;
    union
    {
        IMAGEHLP_SYMBOL sym;
        BYTE            buf[ 255 ];
    } SymBuf;

    SymBuf.sym.SizeOfStruct = sizeof( SymBuf );

    g_pfnRtlGetCallersAddress( &pvCallersAddress, &pvCallersCaller );

    fSuccess = g_pfnSymGetSymFromAddr( GetCurrentProcess(), (LONG) pvCallersAddress, 0, (PIMAGEHLP_SYMBOL) &SymBuf );
    if ( fSuccess )
    {
        DBHR( StringCchCopyA( paszNameOut, cchNameIn, SymBuf.sym.Name ) );
    } // if: success
    else
    {
        DWORD sc = GetLastError();
        DBHR( StringCchCopyA( paszNameOut, cchNameIn, L"<unknown>" ) );
    } // if: failed

} //*** DebugGetFunctionName
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugInitializeThreadTraceFlags
//
//  Description:
//      If enabled (g_tfModule & mtfPERTHREADTRACE), retrieves the default
//      tracing flags for this thread from an INI file that is named the
//      same as the EXE file (e.g. MMC.EXE -> MMC.INI). The particular
//      TraceFlag level is determined by either the thread name (handed in
//      as a parameter) or by the thread counter ID which is incremented
//      every time a new thread is created and calls this routine. The
//      incremental name is "ThreadTraceFlags%u".
//
//      This routine is called from the TraceInitliazeThread() macro.
//
//  Arguments:
//      pszThreadNameIn
//          - If the thread has an assoc. name with it, use it instead of the
//          incremented version. NULL indicate no naming.
//
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeThreadTraceFlags(
    LPCWSTR pszThreadNameIn
    )
{
    //
    // Read per thread flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        WCHAR               szPath[ MAX_PATH ];
        DWORD               dwTraceFlags;
        size_t              cch;
        SPerThreadDebug *   ptd;
        LPCWSTR             pszThreadTraceFlags;

        //
        // Get the EXEs filename and change the extension to INI.
        //

        cch = GetModuleFileNameW( NULL, szPath, RTL_NUMBER_OF( szPath ) - 4 );
        Assert( cch != 0 ); // error in GetModuleFileName
        THR( StringCchCopyW( &szPath[ cch - 3 ], 4, L"ini" ) );


        if ( pszThreadNameIn == NULL )
        {
            WCHAR szThreadTraceFlags[ 50 ];

            //
            // No name thread - use generic name
            //
            THR( StringCchPrintfW( szThreadTraceFlags, RTL_NUMBER_OF( szThreadTraceFlags ), L"ThreadTraceFlags%u", g_ThreadCounter ) );
            dwTraceFlags = GetPrivateProfileIntW( __MODULE__, szThreadTraceFlags, 0, szPath );
            InterlockedIncrement( (LONG *) &g_ThreadCounter );
            pszThreadTraceFlags = szThreadTraceFlags;

        } // if: no thread name
        else
        {
            //
            // Named thread
            //
            dwTraceFlags = GetPrivateProfileIntW( __MODULE__, pszThreadNameIn, 0, szPath );
            pszThreadTraceFlags = pszThreadNameIn;

        } // else: named thread

        Assert( g_TraceFlagsIndex != 0 );

        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd == NULL )
        {
            // don't track this.
            ptd = (SPerThreadDebug *) HeapAlloc( GetProcessHeap(), 0, sizeof( SPerThreadDebug ) );
            ptd->dwStackCounter = 0;

            TlsSetValue( g_TraceFlagsIndex, ptd );
        } // if: ptd

        if ( ptd != NULL )
        {
            ptd->dwFlags = dwTraceFlags;
            if ( pszThreadNameIn == NULL )
            {
                ptd->pcszName = g_szUnknown;
            } // if: no name
            else
            {
                ptd->pcszName = pszThreadNameIn;
            } // else: give it a name

        } // if: ptd

        DebugMsg(
              L"DEBUG: Starting ThreadId = 0x%08x - %ws = 0x%08x"
            , GetCurrentThreadId()
            , pszThreadTraceFlags
            , dwTraceFlags
            );

    } // if: per thread tracing turned on

} //*** DebugInitializeThreadTraceFlags

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugThreadRundownTraceFlags
//
//  Description:
//      Cleans up the mess create by DebugInitializeThreadTraceFlags(). One
//      should use the TraceThreadRundown() macro instead of calling this
//      directly.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugThreadRundownTraceFlags( void )
{
    //
    // If "per thread" is on, clean up the memory allocation.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex != -1 );

        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            HeapFree( GetProcessHeap(), 0, ptd );
            TlsSetValue( g_TraceFlagsIndex, NULL );
        } // if: ptd

    } // if: per thread

} // DebugThreadRundownTraceFlags

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  TraceMsg
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn            - Flags to be checked.
//      paszFormatIn    - Formatted string to spewed to the debugger.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      paszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPWSTR  pszBuf;
        size_t  cch = RTL_NUMBER_OF( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

        //
        // Convert the format buffer to wide chars
        //
        WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, paszFormatIn, strlen( paszFormatIn ) + 1 );

        va_start( valist, paszFormatIn );
        DBHR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, szFormat, valist ) );
        va_end( valist );
        DBHR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg - ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  TraceMsg
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted string to spewed to the debugger.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPWSTR  pszBuf;
        size_t  cch = RTL_NUMBER_OF( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

        va_start( valist, pszFormatIn );
        DBHR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, pszFormatIn, valist ) );
        va_end( valist );
        DBHR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg - UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMessage
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger
//      along with the filename, line number and module name supplied. This is
//      used by many of the debugging macros.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted message to be printed.
//      ...             - Message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        size_t  cch = RTL_NUMBER_OF( szBuf );
        LPWSTR  psz;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &psz );

        va_start( valist, pszFormatIn );
        DBHR( StringCchVPrintfExW( psz, cch, &psz, &cch, 0, pszFormatIn, valist ) );
        va_end( valist );
        DBHR( StringCchCopyW( psz, cch, SZ_NEWLINE ) );

        DebugOutputString( szBuf );
    } // if: flags set

} //*** TraceMessage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMessageDo
//
//  Description:
//      Works like TraceMessage() but takes has a function argument that is
//      broken into call/result in the debug spew. This is called from the
//      TraceMsgDo macro.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked
//      pszFormatIn     - Formatted return value string
//      pszFuncIn       - The string version of the function call.
//      ...             - Return value from call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessageDo(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    LPCWSTR     pszFuncIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        size_t  cch = RTL_NUMBER_OF( szBuf );
        LPWSTR  pszBuf = NULL;
        LPCWSTR psz = pszFuncIn;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &pszBuf );

        //
        // Prime the buffer
        //
        DBHR( StringCchCopyExW( pszBuf, cch, L"V ", &pszBuf, &cch, 0 ) );

        //
        // Copy the l-var part of the expression
        //
        while ( *psz
             && *psz != L'='
              )
        {
            *pszBuf = *psz;
            psz++;
            pszBuf++;
            cch--;
            if ( cch == 0 )
            {
                DEBUG_BREAK;
            }

        } // while:

        //
        // Add the " = "
        //
        DBHR( StringCchCopyExW( pszBuf, cch, L" = ", &pszBuf, &cch, 0 ) );

        //
        // Add the formatted result
        //
        va_start( valist, pszFuncIn );
        DBHR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, pszFormatIn, valist ) );
        va_end( valist );
        DBHR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMessageDo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMessage
//
//  Description:
//      Displays a message only in CHKed/DEBUG builds. Also appends the source
//      filename, linenumber and module name to the ouput.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted message to be printed.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cchBuf = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszDbgBuf = NULL;
    size_t  cchDbgBuf = cchBuf;
    LPWSTR  pszPrintBuf = NULL;
    size_t  cchPrintBuf = 0;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchDbgBuf, &pszDbgBuf );

    va_start( valist, pszFormatIn );
    DBHR( StringCchVPrintfExW( pszDbgBuf, cchDbgBuf, &pszPrintBuf, &cchPrintBuf, 0, pszFormatIn, valist ) );
    va_end( valist );
    DBHR( StringCchCopyW( pszPrintBuf, cchPrintBuf, SZ_NEWLINE ) );

    DebugOutputString( szBuf );

} //*** DebugMessage

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMessageDo
//
//  Description:
//      Just like TraceMessageDo() except in CHKed/DEBUG version it will
//      always spew. The DebugMsgDo macros uses this function.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted result message.
//      pszFuncIn   - The string version of the function call.
//      ...         - The return value of the function call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessageDo(
    LPCWSTR pszFileIn,
    const int nLineIn,
    LPCWSTR pszModuleIn,
    LPCWSTR pszFormatIn,
    LPCWSTR pszFuncIn,
    ...
    )
{
    va_list valist;

    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cch = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszBuf = NULL;
    LPCWSTR psz = pszFuncIn;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &pszBuf );

    //
    // Prime the buffer
    //
    DBHR( StringCchCopyExW( pszBuf, cch, L"V ", &pszBuf, &cch, 0 ) );

    //
    // Copy the l-var part of the expression
    //
    while ( *psz
         && *psz != L'='
          )
    {
        *pszBuf = *psz;
        psz++;
        pszBuf++;
        cch--;
        if ( cch == 0 )
        {
            DEBUG_BREAK;
        }

    } // while:

    //
    // Add the " = "
    //
    DBHR( StringCchCopyExW( pszBuf, cch, L" = ", &pszBuf, &cch, 0 ) );

    //
    // Add the formatted result
    //
    va_start( valist, pszFuncIn );
    DBHR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, pszFormatIn, valist ) );
    va_end( valist );
    DBHR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

    DebugOutputString( szBuf );

} //*** DebugMessageDo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  DebugMsg
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      paszFormatIn    - Formatted message to be printed.
//      ...             - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
    LPCSTR paszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cch = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszBuf = NULL;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( paszFormatIn != NULL );

    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, paszFormatIn, strlen( paszFormatIn ) + 1 );

    va_start( valist, paszFormatIn );
    THR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, szFormat, valist ) );
    va_end( valist );
    THR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

    DebugOutputString( szBuf );

} //*** DebugMsg - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  DebugMsg
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
      LPCWSTR pszFormatIn
    , ...
    )
{
    va_list valist;
    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cch = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszBuf = NULL;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    THR( StringCchVPrintfExW( pszBuf, cch, &pszBuf, &cch, 0, pszFormatIn, valist ) );
    va_end( valist );
    THR( StringCchCopyW( pszBuf, cch, SZ_NEWLINE ) );

    DebugOutputString( szBuf );

} //*** DebugMsg - UNICODE version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  DebugMsgNoNewline
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cch = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszBuf = NULL;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

    Assert( pszFormatIn != NULL );

    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    THR( StringCchVPrintfW( pszBuf, cch, szFormat, valist ) );
    va_end( valist );

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  DebugMsgNoNewline
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    size_t  cch = RTL_NUMBER_OF( szBuf );
    LPWSTR  pszBuf = NULL;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cch, &pszBuf );

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    THR( StringCchVPrintfW( pszBuf, cch, pszFormatIn, valist ) );
    va_end( valist );

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline - UNICODE version


//////////////////////////////////////////////////////////////////////////////
//++
//
//  AssertMessage
//
//  Description:
//      Displays a dialog box with the failed assertion. User has the option of
//      breaking. The Assert macro calls this to display assertion failures.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the expression to assert.
//      fTrueIn     - Result of the evaluation of the expression.
//      ...         - Message arguments
//
//  Return Values:
//      TRUE    - Caller should call DEBUG_BREAK.
//      FALSE   - Caller should not call DEBUG_BREAK.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
AssertMessage(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    BOOL        fTrueIn,
    ...
    )
{
    BOOL fTrue = fTrueIn;

    if ( ! fTrueIn )
    {
        LRESULT lResult;
        WCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        size_t  cch = RTL_NUMBER_OF( szBuf );
        LPWSTR  pszBuf = NULL;
        va_list valist;

        //
        // Output a debug message.
        //
        va_start( valist, fTrueIn );
        DBHR( StringCchVPrintfW( szBufMsg, RTL_NUMBER_OF( szBufMsg ), pszfnIn, valist ) );
        va_end( valist );
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &pszBuf );
        DBHR( StringCchPrintfW( pszBuf, cch, L"ASSERT: %ws" SZ_NEWLINE, szBufMsg ) );
        DebugOutputString( szBuf );

        //
        // Display an assert message.
        //
        DBHR( StringCchPrintfW(
                  szBuf
                , RTL_NUMBER_OF( szBuf )
                , L"Module:\t%ws\t\n"
                  L"Line:\t%u\t\n"
                  L"File:\t%ws\t\n\n"
                  L"Assertion:\t%ws\t\n\n"
                  L"Do you want to break here?"
                , pszModuleIn
                , nLineIn
                , pszFileIn
                , szBufMsg
                ) );
        LogMsg( SZ_NEWLINE L"Assertion Failed!" SZ_NEWLINE SZ_NEWLINE L"%ws" SZ_NEWLINE, szBuf );

        if ( g_tfModule & mtfSHOWASSERTS )
        {
            lResult = MessageBox( NULL, szBuf, L"Assertion Failed!", MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDNO )
            {
                fTrue = TRUE;   // don't break
            } // if:
        } // if:
        else
        {
            fTrue = TRUE;   // don't break
        } // else:

    } // if: assert false

    return ! fTrue;

} //*** AssertMessage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceHR
//
//  Description:
//      Traces HRESULT errors. A dialog will appear if the hrIn is not equal
//      to S_OK. The dialog will ask if the user wants to break-in or continue
//      execution. This is called from the THR macro.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      hrIn        - HRESULT of the function call.
//      fSuccessIn  - If TRUE, only if FAILED( hr ) is TRUE will it report.
//      hrIgnoreIn  - HRESULT to ignore.
//      ...         - Message arguments
//
//  Return Values:
//      Whatever hrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
TraceHR(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn,
    ...
    )
{
    HRESULT         hr;
    static LPCWSTR  s_szS_FALSE = L"S_FALSE";

    // If ignoring success statuses and no failure occurred, set hrIn to
    // something we always ignore (S_OK).  This simplifies the if condition
    // below.
    if ( fSuccessIn && ! FAILED( hrIn ) )
    {
        hr = S_OK;
    }
    else
    {
        hr = hrIn;
    }

    if ( ( hr != S_OK )
      && ( hr != hrIgnoreIn )
      )
    {
        WCHAR   szSymbolicName[ 64 ]; // random
        size_t  cchSymbolicName;
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        size_t  cch = RTL_NUMBER_OF( szBuf );
        LPWSTR  pszBuf = NULL;
        LPWSTR  pszMsgBuf = NULL;
        LRESULT lResult;
        bool    fAllocatedMsg   = false;

        switch ( hr )
        {
            case S_FALSE:
                pszMsgBuf = (LPWSTR) s_szS_FALSE;

                //
                // Find the symbolic name for this error.
                //
                THR( StringCchCopyW( szSymbolicName, RTL_NUMBER_OF( szSymbolicName ), pszMsgBuf ) );
                break;

            default:
                FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    hr,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                    (LPWSTR) &pszMsgBuf,    // cast required with FORMAT_MESSAGE_ALLOCATE_BUFFER
                    0,
                    NULL
                    );

                //
                // Make sure everything is cool before we blow up somewhere else.
                //
                if ( pszMsgBuf == NULL )
                {
                    pszMsgBuf = L"<unknown error code returned>";
                } // if: status code not found
                else
                {
                    fAllocatedMsg = true;
                } // else: found the status code

                //
                // Find the symbolic name for this error.
                //
                cchSymbolicName = RTL_NUMBER_OF( szSymbolicName );
                DebugFindWinerrorSymbolicName( hr, szSymbolicName, &cchSymbolicName );
                Assert( cchSymbolicName != RTL_NUMBER_OF( szSymbolicName ) );

                break;
        } // switch: hr

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &pszBuf );
        THR( StringCchPrintfW(
                  pszBuf
                , cch
                , L"*HRESULT* hr = 0x%08x (%ws) - %ws" SZ_NEWLINE
                , hr
                , szSymbolicName
                , pszMsgBuf
                ) );
        DebugOutputString( szBuf );

        //
        // If trace flag set, generate a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            WCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
            va_list valist;

            va_start( valist, hrIgnoreIn );
            THR( StringCchVPrintfW( szBufMsg, RTL_NUMBER_OF( szBufMsg ), pszfnIn, valist ) );
            va_end( valist );

            THR( StringCchPrintfW(
                  szBuf
                , RTL_NUMBER_OF( szBuf )
                , L"Module:\t%ws\t\n"
                  L"Line:\t%u\t\n"
                  L"File:\t%ws\t\n\n"
                  L"Function:\t%ws\t\n"
                  L"hr =\t0x%08x (%ws) - %ws\t\n"
                  L"Do you want to break here?"
                , pszModuleIn
                , nLineIn
                , pszFileIn
                , szBufMsg
                , hr
                , szSymbolicName
                , pszMsgBuf
                ) );

            lResult = MessageBoxW( NULL, szBuf, L"Trace HRESULT", MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success HRESULTs

        if ( fAllocatedMsg )
        {
            LocalFree( pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: hr != S_OK

    return hrIn;

} //*** TraceHR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceWin32
//
//  Description:
//      Traces WIN32 errors. A dialog will appear is the ulErrIn is not equal
//      to ERROR_SUCCESS. The dialog will ask if the user wants to break-in or
//      continue execution.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module name.
//      pszfnIn         - String version of the function call.
//      ulErrIn         - Error code to check.
//      ulErrIgnoreIn   - Error code to ignore.
//      ...             - Message arguments
//
//  Return Values:
//      Whatever ulErrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
TraceWin32(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPCWSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn,
    ...
    )
{
    if ( ( ulErrIn != ERROR_SUCCESS )
      && ( ulErrIn != ulErrIgnoreIn ) )
    {
        WCHAR   szSymbolicName[ 64 ]; // random
        size_t  cchSymbolicName;
        WCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        size_t  cch = RTL_NUMBER_OF( szBuf );
        LPWSTR  pszBuf = NULL;
        LPWSTR  pszMsgBuf = NULL;
        LRESULT lResult;
        bool    fAllocatedMsg   = false;

        //
        // Translate the error code to a text message.
        //
        FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            ulErrIn,
            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
            (LPWSTR) &pszMsgBuf,    // cast required with FORMAT_MESSAGE_ALLOCATE_BUFFER
            0,
            NULL
            );

        //
        // Make sure everything is cool before we blow up somewhere else.
        //
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = L"<unknown error code returned>";
        } // if: status code not found
        else
        {
            fAllocatedMsg = true;
        } // else: found the status code

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Find the symbolic name for this error.
        //
        cchSymbolicName = RTL_NUMBER_OF( szSymbolicName );
        DebugFindWinerrorSymbolicName( ulErrIn, szSymbolicName, &cchSymbolicName );
        Assert( cchSymbolicName != RTL_NUMBER_OF( szSymbolicName ) );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cch, &pszBuf );
        THR( StringCchPrintfW(
                  pszBuf
                , cch
                , L"*WIN32Err* ulErr = %u (%ws) - %ws" SZ_NEWLINE
                , ulErrIn
                , szSymbolicName
                , pszMsgBuf
                ) );
        DebugOutputString( szBuf );

        //
        // If trace flag set, invoke a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            WCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
            va_list valist;

            va_start( valist, ulErrIgnoreIn );
            THR( StringCchVPrintfW( szBufMsg, RTL_NUMBER_OF( szBufMsg ), pszfnIn, valist ) );
            va_end( valist );

            THR( StringCchPrintfW(
                      szBuf
                    , RTL_NUMBER_OF( szBuf )
                    , L"Module:\t%ws\t\n"
                      L"Line:\t%u\t\n"
                      L"File:\t%ws\t\n\n"
                      L"Function:\t%ws\t\n"
                      L"ulErr =\t%u (%ws) - %ws\t\n"
                      L"Do you want to break here?"
                    , pszModuleIn
                    , nLineIn
                    , pszFileIn
                    , szBufMsg
                    , ulErrIn
                    , szSymbolicName
                    , pszMsgBuf
                    ) );

            lResult = MessageBoxW( NULL, szBuf, L"Trace Win32", MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success status codes

        if ( fAllocatedMsg )
        {
            LocalFree( pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: ulErrIn != ERROR_SUCCESS && != ulErrIgnoreIn

    return ulErrIn;

} //*** TraceWin32

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrTraceLogOpen
//
//  Description:
//      This function:
//          - initializes the trace log critical section
//          - enters the trace log critical section assuring only one thread is
//            writing to the trace log at a time
//          - creates the directory tree to the trace log file (if needed)
//          - initializes the trace log file by:
//              - creating a new trace log file if one doesn't exist.
//              - opens an existing trace log file (for append)
//              - appends a time/date stamp that the trace log was (re)opened.
//
//      Use HrTraceLogRelease() to exit the log critical section.
//
//      If there is a failure inside this function, the trace log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - log critical section held and trace log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogOpen( void )
{
    WCHAR   szFilePath[ MAX_PATH ];
    CHAR    aszBuffer[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   cbToWrite;
    DWORD   cbWritten;
    BOOL    fReturn;
    HRESULT hr;
    DWORD   sc;
    size_t  cch = 0;

    SYSTEMTIME SystemTime;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( g_pcsTraceLog == NULL )
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL )
        {
            DebugMsg( "DEBUG: Out of Memory. Tracing disabled." );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one trace log critical section
        InterlockedCompareExchangePointer( (PVOID *) &g_pcsTraceLog, pNewCritSect, 0 );
        if ( g_pcsTraceLog != pNewCritSect )
        {
            DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one." );
            DeleteCriticalSection( pNewCritSect );
            HeapFree( GetProcessHeap(), 0, pNewCritSect );
        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( g_pcsTraceLog != NULL );
    EnterCriticalSection( g_pcsTraceLog );

    //
    // Make sure the trace log file is open.
    //
    if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
    {
        cch = RTL_NUMBER_OF( szFilePath );
        hr = HrGetLogFilePath( L"%windir%\\Debug", szFilePath, &cch, NULL );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        // Create it
        //
        g_hTraceLogFile = CreateFile(
                              szFilePath
                            , GENERIC_WRITE
                            , FILE_SHARE_READ | FILE_SHARE_WRITE
                            , NULL
                            , OPEN_ALWAYS
                            , FILE_FLAG_WRITE_THROUGH
                            , NULL
                            );

        if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
        {
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create log at %ws", szFilePath );
            } // if: not tracing to disk

            sc = GetLastError();
            hr = HRESULT_FROM_WIN32( sc );

            //
            // If we can not create the log file, try creating it under the alternate %TEMP% directory
            //
            if ( ( sc == ERROR_ACCESS_DENIED ) || ( sc == ERROR_FILE_NOT_FOUND ) )
            {
                cch = RTL_NUMBER_OF( szFilePath );
                hr = HrGetLogFilePath( L"%TEMP%", szFilePath, &cch, NULL );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                //
                // Create it
                //
                g_hTraceLogFile = CreateFile(
                                      szFilePath
                                    , GENERIC_WRITE
                                    , FILE_SHARE_READ | FILE_SHARE_WRITE
                                    , NULL
                                    , OPEN_ALWAYS
                                    , FILE_FLAG_WRITE_THROUGH
                                    , NULL
                                    );

                if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
                {
                    if ( !( g_tfModule & mtfOUTPUTTODISK ) )
                    {
                        DebugMsg( "*ERROR* Failed to create log at %ws", szFilePath );
                    } // if: not tracing to disk
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto Error;
                } // if: ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
            } // if: ( ( sc == ERROR_ACCESS_DENIED ) || ( sc == ERROR_FILE_NOT_FOUND ) )
            else
            {
                goto Error;
            } // else:
        } // if: ( g_hTraceLogFile == INVALID_HANDLE_VALUE )

        // Seek to the end
        SetFilePointer( g_hTraceLogFile, 0, NULL, FILE_END );

        //
        // Write the time/date the trace log was (re)openned.
        //
        GetLocalTime( &SystemTime );
        DBHR( StringCchPrintfExA(
                      aszBuffer
                    , RTL_NUMBER_OF( aszBuffer )
                    , NULL
                    , &cch
                    , 0
                    , "*" ASZ_NEWLINE
                      "* %02u/%02u/%04u %02u:%02u:%02u.%03u" ASZ_NEWLINE
                      "*" ASZ_NEWLINE
                    , SystemTime.wMonth
                    , SystemTime.wDay
                    , SystemTime.wYear
                    , SystemTime.wHour
                    , SystemTime.wMinute
                    , SystemTime.wSecond
                    , SystemTime.wMilliseconds
                    ) );

        cbToWrite = static_cast< DWORD >( sizeof( aszBuffer ) - cch + 1 );
        fReturn = WriteFile( g_hTraceLogFile, aszBuffer, cbToWrite, &cbWritten, NULL );
        if ( ! fReturn )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Error;
        } // if: failed
        if ( cbWritten != cbToWrite )
        {
            DebugMsg( "HrTraceLogOpen: %d bytes written when %d bytes were requested.", cbWritten, cbToWrite );
        }

        DebugMsg( "DEBUG: Created trace log at %ws", szFilePath );

    } // if: file not already openned

    hr = S_OK;

Cleanup:

    return hr;

Error:

    if ( !( g_tfModule & mtfOUTPUTTODISK ) )
    {
        DebugMsg( "HrTraceLogOpen: Failed hr = 0x%08x", hr );
    }

    if ( g_hTraceLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hTraceLogFile );
        g_hTraceLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    LeaveCriticalSection( g_pcsTraceLog );

    goto Cleanup;

} //*** HrTraceLogOpen

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrTraceLogRelease
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogRelease( void )
{
    Assert( g_pcsTraceLog != NULL );
    LeaveCriticalSection( g_pcsTraceLog );
    return S_OK;

} //*** HrTraceLogRelease

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrTraceLogClose
//
//  Description:
//      Close the file.  This function expects the critical section to have
//      already been released.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogClose( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    if ( g_pcsTraceLog != NULL )
    {
        DeleteCriticalSection( g_pcsTraceLog );
        HeapFree( GetProcessHeap(), 0, g_pcsTraceLog );
        g_pcsTraceLog = NULL;
    } // if:

    if ( g_hTraceLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hTraceLogFile );
        g_hTraceLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    HRETURN( hr );

} //*** HrTraceLogClose

//
//  KB: 27 JUN 2001 GalenB
//
//  ifdef'd these functions out since they are not currently being used and
//  are thought to be useful in the future.
//
#if 0

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  TraceLogMsgNoNewline
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      paszFormatIn    - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR paszFormatIn,
    ...
    )
{
    va_list valist;

    CHAR    aszBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   cbToWrite;
    DWORD   cbWritten;
    HRESULT hr;
    BOOL    fSuccess;

    WCHAR  szFormat[ TRACE_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, paszFormatIn, strlen( paszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    DBHR( StringCchVPrintfW( szTmpBuf, RTL_NUMBER_OF( szTmpBuf ), szFormat, valist ) );
    va_end( valist );

    cbToWrite = wcstombs( aszBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( cbToWrite == - 1 )
    {
        cbToWrite = strlen( aszBuf );
    } // if: bad character found

    hr = DBHR( HrTraceLogOpen() );
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    fSuccess = WriteFile( g_hTraceLogFile, aszBuf, cbToWrite, &cbWritten, NULL );
    if ( fSuccess == FALSE )
    {
        if ( !( g_tfModule & mtfOUTPUTTODISK ) )
        {
            DebugMsg( "TraceLogMsgNoNewline: Failed status = 0x%08x", GetLastError() );
        }
    }
    else
    {
        if ( cbWritten != cbToWrite )
        {
            DebugMsg( "TraceLogMsgNoNewline: %d bytes written when %d bytes were requested.", cbWritten, cbToWrite );
        }
    }

    HrTraceLogRelease();

} //*** TraceLogMsgNoNewline - ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  TraceLogMsgNoNewline
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      pszFormatIn - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;

    CHAR    aszBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   cbToWrite;
    DWORD   cbWritten;
    HRESULT hr;
    BOOL    fSuccess;

    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormatIn );
    DBHR( stringCchVPrintfW( szTmpBuf, RTL_NUMBER_OF( szTmpBuf ), pszFormatIn, valist) );
    va_end( valist );

    cbToWrite = wcstombs( aszBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( cbToWrite == -1 )
    {
        cbToWrite = strlen( aszBuf );
    } // if: bad character found

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    fSuccess = WriteFile( g_hTraceLogFile, aszBuf, cbToWrite, &cbWritten, NULL );
    if ( fSuccess == FALSE )
    {
        if ( !( g_tfModule & mtfOUTPUTTODISK ) )
        {
            DebugMsg( "TraceLogMsgNoNewline: Failed status = 0x%08x", GetLastError() );
        }
    }
    else
    {
        if ( cbWritten != cbToWrite )
        {
            DebugMsg( "TraceLogMsgNoNewline: %d bytes written when %d bytes were requested.", cbWritten, cbToWrite );
        }
    }

    HrTraceLogRelease();

} //*** TraceLogMsgNoNewline - UNICODE

#endif  // end ifdef'd out code

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  TraceLogWrite
//
//  Description:
//      Writes a line to the trace log file.
//
//  Arguments:
//      pszTraceLineIn - The formatted trace line to write.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogWrite(
    LPCWSTR pszTraceLineIn
    )
{
    HRESULT hr;
    DWORD   cbToWrite;
    DWORD   cbWritten;
    BOOL    fSuccess;
    CHAR    aszFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    wcstombs( aszFormat, pszTraceLineIn, wcslen( pszTraceLineIn ) + 1 );

    cbToWrite = static_cast< DWORD >( strlen( aszFormat ) + 1 );
    fSuccess = WriteFile( g_hTraceLogFile, aszFormat, cbToWrite, &cbWritten, NULL );
    if ( fSuccess == FALSE )
    {
        if ( !( g_tfModule & mtfOUTPUTTODISK ) )
        {
            DebugMsg( "TraceLogWrite: Failed status = 0x%08x", GetLastError() );
        }
    }
    else
    {
        if ( cbWritten != cbToWrite )
        {
            DebugMsg( "TraceLogWrite: %d bytes written when %d bytes were requested.", cbWritten, cbToWrite );
        }
    }

    HrTraceLogRelease();

} //*** TraceLogWrite - UNICODE


//****************************************************************************
//****************************************************************************
//
//  Memory allocation and tracking
//
//****************************************************************************
//****************************************************************************


//
// This is a private structure and should not be known to the application.
//
typedef struct MEMORYBLOCK
{
    EMEMORYBLOCKTYPE    embtType;       // What type of memory this is tracking
    union
    {
        void *          pvMem;      // pointer/object to allocated memory to track
        BSTR            bstr;       // BSTR to allocated memory
    };
    DWORD               dwBytes;    // size of the memory
    LPCWSTR             pszFile;    // source filename where memory was allocated
    int                 nLine;      // source line number where memory was allocated
    LPCWSTR             pszModule;  // source module name where memory was allocated
    LPCWSTR             pszComment; // optional comments about the memory
    MEMORYBLOCK *       pNext;      // pointer to next MEMORYBLOCK structure
} MEMORYBLOCK;

//
//  KB: 20-APR-2001 GalenB
//
//  Changing this struct to use a critical section instead of a spin lock.
//  Spin locks are not re-entrant on a thread the way critical sections
//  are.
//
typedef struct MEMORYBLOCKLIST
{
    CRITICAL_SECTION    csList;     // Critical section protecting the list
    MEMORYBLOCK *       pmbList;    // List of MEMORYBLOCKs.
    BOOL                fDeadList;  // The list is dead.
} MEMORYBLOCKLIST;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryBlockIDChar
//
//  Description:
//      Returns a character representing the memory block type.
//
//  Arugments:
//      embtTypeIn  - Type of memory block.
//
//  Return Values:
//      wchID       - Character representing the memory block type.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
WCHAR
DebugMemoryBlockIDChar(
    EMEMORYBLOCKTYPE    embtTypeIn
    )
{
    // Memory block type IDs.
    static WCHAR s_rgwchMemoryBlockTypeID[] =
    {
          L'u'  // mmbtUNKNOWN
        , L'A'  // mmbtHEAPMEMALLOC
        , L'L'  // mmbtLOCALMEMALLOC
        , L'M'  // mmbtMALOCMEMALLOC
        , L'O'  // mmbtOBJECT
        , L'H'  // mmbtHANDLE
        , L'P'  // mmbtPUNK
        , L'S'  // mmbtSYSALLOCSTRING
    };

    WCHAR   wchID;

    if ( embtTypeIn < RTL_NUMBER_OF( s_rgwchMemoryBlockTypeID ) )
    {
        wchID = s_rgwchMemoryBlockTypeID[ embtTypeIn ];
    }
    else
    {
        wchID = L'?';
    }

    return wchID;

} //*** DebugMemoryBlockIDChar

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemorySpew
//
//  Description:
//      Displays a message about the memory block.
//
//  Arugments:
//      pmb         - pointer to MEMORYBLOCK desciptor.
//      pszMessage  - message to display
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
void
DebugMemorySpew(
    MEMORYBLOCK *   pmb,
    LPWSTR          pszMessage
    )
{
    switch ( pmb->embtType )
    {
        case mmbtHEAPMEMALLOC:
        case mmbtLOCALMEMALLOC:
        case mmbtMALLOCMEMALLOC:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , L"[%wc] %ws 0x%08x (%u bytes) - %ws"
                    , DebugMemoryBlockIDChar( pmb->embtType )
                    , pszMessage
                    , pmb->pvMem
                    , pmb->dwBytes
                    , pmb->pszComment
                    );
            break;

#if defined( USES_SYSALLOCSTRING )
        case mmbtSYSALLOCSTRING:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , L"[%wc] %ws 0x%08x - %ws {%ws}"
                    , DebugMemoryBlockIDChar( pmb->embtType )
                    , pszMessage
                    , pmb->pvMem
                    , pmb->pszComment
                    , (LPWSTR) pmb->pvMem
                    );
            break;
#endif // USES_SYSALLOCSTRING

        default:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , L"[%wc] %ws 0x%08x - %ws"
                    , DebugMemoryBlockIDChar( pmb->embtType )
                    , pszMessage
                    , pmb->pvMem
                    , pmb->pszComment
                    );
            break;

    } // switch: pmb->embtType

} //*** DebugMemorySpew

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugRealFree
//
//  Description:
//      Performs the real memory deallocation operation based on the
//      memory block type.
//
//  Arguments:
//      embtTypeIn  - Type of memory block of the memory to deallocate.
//      pvMemIn     - Pointer to memory to deallocate.
//
//  Return Values:
//      TRUE
//          Memory was freed.
//
//      FALSE
//          An error occured.  Use GetLastError() to determine the failure.
//          See HeapFree(), LocalFree(), or free() for more details.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
BOOL
DebugRealFree(
      EMEMORYBLOCKTYPE  embtTypeIn
    , void *            pvMemIn
    )
{
    BOOL    fSuccess = FALSE;

    switch ( embtTypeIn )
    {
        case mmbtLOCALMEMALLOC:
            fSuccess = ( LocalFree( pvMemIn ) == NULL );
            break;
        case mmbtMALLOCMEMALLOC:
            free( pvMemIn );
            fSuccess = TRUE;
            break;
        case mmbtHEAPMEMALLOC:
        case mmbtOBJECT:
        case mmbtUNKNOWN:   // this one is risky
            fSuccess = HeapFree( GetProcessHeap(), 0, pvMemIn );
            break;
        case mmbtHANDLE:
            AssertMsg( FALSE, "Trying to free handle" );
            break;
        case mmbtPUNK:
            AssertMsg( FALSE, "Trying to free COM interface" );
            break;
#if defined( USES_SYSALLOCSTRING )
        case mmbtSYSALLOCSTRING:
            SysFreeString( (BSTR) pvMemIn );
            fSuccess = TRUE;
            break;
#endif // USES_SYSALLOCSTRING
        default:
            AssertMsg( FALSE, "Trying to free unknown memory block type" );
            break;
    } // switch: memory block type

    return fSuccess;

} //*** DebugRealFree

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryAddToList
//
//  Description:
//      Adds memory to be tracked to the thread local memory tracking list.
//
//  Arguments:
//      ppmbHeadInout   - The list to add the memory to.
//      embtTypeIn      - Type of memory block of the memory to track.
//      pvMemIn         - Pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in pvMemIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
void *
DebugMemoryAddToList(
      MEMORYBLOCK **    ppmbHeadInout
    , EMEMORYBLOCKTYPE  embtTypeIn
    , void *            pvMemIn
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , DWORD             dwBytesIn
    , LPCWSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK * pmb = (MEMORYBLOCK *) HeapAlloc( GetProcessHeap(), 0, sizeof( MEMORYBLOCK ) );

        if ( pmb == NULL )
        {
            //
            //  TODO:   23-APR-2001 GalenB
            //
            //  Why are we doing this?  Should we free the tracked allocation simply because we cannot
            //  allocate a tracking object?
            //
            DebugRealFree( embtTypeIn, pvMemIn );
            return NULL;
        } // if: memory block allocation failed

        pmb->embtType   = embtTypeIn;
        pmb->pvMem      = pvMemIn;
        pmb->dwBytes    = dwBytesIn;
        pmb->pszFile    = pszFileIn;
        pmb->nLine      = nLineIn;
        pmb->pszModule  = pszModuleIn;
        pmb->pszComment = pszCommentIn;
        pmb->pNext      = (MEMORYBLOCK *) *ppmbHeadInout;

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmb, L"Alloced" );
        } // if: tracing

        *ppmbHeadInout = pmb;
    } // if: something to trace

    return pvMemIn;

} //*** DebugMemoryAddToList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryAdd
//
//  Description:
//      Adds memory to be tracked to a memory tracking list.
//
//  Arguments:
//      embtType        - Type of memory block of the memory to track.
//      pvMemIn         - Pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in pvMemIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    embtTypeIn,
    void *              pvMemIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn,
    DWORD               dwBytesIn,
    LPCWSTR             pszCommentIn
    )
{
    void *  pv = NULL;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        pv = DebugMemoryAddToList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), embtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pv = DebugMemoryAddToList( &pmbCurrent, embtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return pv;

} //*** DebugMemoryAdd

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryDeleteFromList
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.
//
//  Arguments:
//      ppmbHeadInout   - The list to remove the memory from.
//      embtTypeIn      - Memory block type.
//      pvMemIn         - Pointer to memory block to stop tracking.
//      pszFileIn       - Source file that is deleteing.
//      nLineIn         - Source line number that is deleteing.
//      pszModuleIn     - Source module name that is deleteing.
//      fClobberIn      - True if memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static void
DebugMemoryDeleteFromList(
      MEMORYBLOCK **    ppmbHeadInout
    , EMEMORYBLOCKTYPE  embtTypeIn
    , void *            pvMemIn
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , BOOL              fClobberIn
    )
{
    Assert( ppmbHeadInout != NULL );

    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK *   pmbCurrent = *ppmbHeadInout;
        MEMORYBLOCK *   pmbPrev = NULL;

        //
        // Find the memory in the memory block list
        //
        if ( embtTypeIn == mmbtHEAPMEMALLOC )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->embtType == embtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtLOCALMEMALLOC ), "Should be freed by TraceLocalFree()." );
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtMALLOCMEMALLOC ), "Should be freed by TraceMallocFree()." );
#if defined( USES_SYSALLOCSTRING )
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtSYSALLOCSTRING ), "Should be freed by SysAllocFreeString()." );
#endif // USES_SYSALLOCSTRING
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: heap memory allocation type
        else if ( embtTypeIn == mmbtLOCALMEMALLOC )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->embtType == embtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtHEAPMEMALLOC ), "Should be freed by TraceFree()." );
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtMALLOCMEMALLOC ), "Should be freed by TraceMallocFree()." );
#if defined( USES_SYSALLOCSTRING )
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtSYSALLOCSTRING ), "Should be freed by SysAllocFreeString()." );
#endif // USES_SYSALLOCSTRING
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: local memory allocation type
        else if ( embtTypeIn == mmbtMALLOCMEMALLOC )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->embtType == embtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtHEAPMEMALLOC ), "Should be freed by TraceFree()." );
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtLOCALMEMALLOC ), "Should be freed by TraceLocalFree()." );
#if defined( USES_SYSALLOCSTRING )
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtSYSALLOCSTRING ), "Should be freed by SysAllocFreeString()." );
#endif // USES_SYSALLOCSTRING
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: malloc memory allocation type
#if defined( USES_SYSALLOCSTRING )
        else if ( embtTypeIn == mmbtSYSALLOCSTRING )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->embtType == embtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtHEAPMEMALLOC ), "Should be freed by TraceFree()." );
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtLOCALMEMALLOC ), "Should be freed by TraceLocalFree()." );
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->embtType == mmbtMALLOCMEMALLOC ), "Should be freed by TraceMallocFree()." );
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: SysAllocString type
#endif // USES_SYSALLOCSTRING
        else if ( embtTypeIn == mmbtUNKNOWN )
        {
            while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
            {
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: don't care what type
        else
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->embtType == embtTypeIn ) ) )
            {
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // else: other types, but they must match

        //
        //  Did we find the memory block in question?  pmbCurrent is the
        //  tracking record for the passed in address.
        //
        if ( pmbCurrent != NULL )
        {
            //
            // Remove the memory block from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;
            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"Freeing" );
            } // if: tracing

            //
            // Nuke the memory
            //
            if (    fClobberIn
                &&  (   ( pmbCurrent->embtType == mmbtHEAPMEMALLOC )
                    ||  ( pmbCurrent->embtType == mmbtLOCALMEMALLOC )
                    ||  ( pmbCurrent->embtType == mmbtMALLOCMEMALLOC )
#if defined( USES_SYSALLOCSTRING )
                    ||  ( pmbCurrent->embtType == mmbtSYSALLOCSTRING )
#endif // USES_SYSALLOCSTRING
                    )
                )
            {
                memset( pmbCurrent->pvMem, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: fixed memory

            //
            // Nuke the memory tracking block
            //
            memset( pmbCurrent, FREE_BLOCK, sizeof( MEMORYBLOCK ) );
            HeapFree( GetProcessHeap(), 0, pmbCurrent );
        } // if: found entry
        else
        {
            DebugMessage(
                        pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , L"***** Freeing memory at 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****"
                      , pvMemIn
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found
    } // if: something to delete

} //*** DebugMemoryDeleteFromList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryDelete
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.  The caller is
//      responsible for doing the actual memory deallocation.
//
//  Arguments:
//      embtTypeIn  - Memory block type.
//      pvMemIn     - Pointer to memory block to stop tracking.
//      pszFileIn   - Source file that is deleteing.
//      nLineIn     - Source line number that is deleteing.
//      pszModuleIn - Source module name that is deleteing.
//      fClobberIn  - True is memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    embtTypeIn,
    void *              pvMemIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn,
    BOOL                fClobberIn
    )
{
    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        DebugMemoryDeleteFromList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), embtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        DebugMemoryDeleteFromList( &pmbCurrent, embtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

} //*** DebugMemoryDelete

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugAlloc
//
//  Description:
//      Replacement for LocalAlloc, GlobalAlloc, and malloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      embtTypeIn      - Memory block type.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation. NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugAlloc(
    EMEMORYBLOCKTYPE    embtTypeIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn,
    UINT                uFlagsIn,
    DWORD               dwBytesIn,
    LPCWSTR             pszCommentIn
    )
{
    Assert( ( uFlagsIn & LMEM_MOVEABLE ) == 0 );

    void *  pv = NULL;

    switch ( embtTypeIn )
    {
        case mmbtHEAPMEMALLOC:
            pv = HeapAlloc( GetProcessHeap(), uFlagsIn, dwBytesIn );
            embtTypeIn = mmbtHEAPMEMALLOC;
            break;
        case mmbtLOCALMEMALLOC:
            pv = LocalAlloc( uFlagsIn, dwBytesIn );
            break;
        case mmbtMALLOCMEMALLOC:
            pv = malloc( dwBytesIn );
            break;
        default:
            AssertMsg( FALSE, "DebugAlloc: Unknown block type" );
            return NULL;
    } // switch: block type

    //
    // Initialize the memory if needed
    //
    if ( ( IsTraceFlagSet( mtfMEMORYINIT ) ) && !( uFlagsIn & HEAP_ZERO_MEMORY ) )
    {
        //
        // KB: gpease 8-NOV-1999
        //     Initialize to anything but ZERO. We will use AVAILABLE_ADDRESS to
        //     indicate "Available Address". Initializing to zero
        //     is bad because it usually has meaning.
        //
        memset( pv, AVAILABLE_ADDRESS, dwBytesIn );
    } // if: zero memory requested

    return DebugMemoryAdd( embtTypeIn, pv, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );

} //*** DebugAlloc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugReAllocList
//
//  Description:
//      Replacement for LocalReAlloc, GlobalReAlloc, and realloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      pvMemIn         - Pointer to the source memory.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
void *
DebugReAllocList(
      MEMORYBLOCK **    ppmbHeadInout
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , void *            pvMemIn
    , UINT              uFlagsIn
    , DWORD             dwBytesIn
    , LPCWSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    MEMORYBLOCK *   pmbCurrent = NULL;
    void *          pvOld   = pvMemIn;
    MEMORYBLOCK *   pmbPrev = NULL;
    void *          pv;

    AssertMsg( !( uFlagsIn & GMEM_MODIFY ), "This doesn't handle modified memory blocks, yet." );

    //
    //  To duplicate the behavior of realloc we need to do an alloc when
    //  pvMemIn is NULL.
    //
    if ( pvMemIn == NULL )
    {
        //
        //  Cannot use DebugAlloc() since it will automically add this memory to the tracking list and
        //  we need to use the passed in list.
        //
        pv = HeapAlloc( GetProcessHeap(), uFlagsIn, dwBytesIn );

        //
        // Initialize the memory if needed
        //
        if ( ( IsTraceFlagSet( mtfMEMORYINIT ) ) && !( uFlagsIn & HEAP_ZERO_MEMORY ) )
        {
            //
            // KB: gpease 8-NOV-1999
            //     Initialize to anything but ZERO. We will use AVAILABLE_ADDRESS to
            //     indicate "Available Address". Initializing to zero
            //     is bad because it usually has meaning.
            //
            memset( pv, AVAILABLE_ADDRESS, dwBytesIn );
        } // if: zero memory requested

        //
        //  Cannot call DebugMemoryAdd() since it will get the memory tracking list head from thread local storage
        //  when we are using per thread memory tracking.  We need to use the list that this function was passed.
        //
        pv = DebugMemoryAddToList( ppmbHeadInout, mmbtHEAPMEMALLOC, pv, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        goto Exit;
    } // if:

    pmbCurrent = *ppmbHeadInout;

    //
    // Find the memory in the memory block list
    //
    while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
    {
        pmbPrev = pmbCurrent;
        pmbCurrent = pmbPrev->pNext;
    } // while: finding the entry in the list

    //
    //  Did we find the current memory block?
    //
    if ( pmbCurrent != NULL )
    {
        AssertMsg( pmbCurrent->embtType == mmbtHEAPMEMALLOC, "You can only realloc HeapAlloc memory allocations!" );

        //
        // Remove the memory from the tracking list
        //
        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;
        } // if: not first entry
        else
        {
            *ppmbHeadInout = pmbCurrent->pNext;
        } // else: first entry

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmbCurrent, L"Freeing" );
        } // if: tracing

        //
        // Force the programmer to handle a real realloc by moving the
        // memory first.
        //
        pvOld = HeapAlloc( GetProcessHeap(), uFlagsIn, pmbCurrent->dwBytes );
        if ( pvOld != NULL )
        {
            CopyMemory( pvOld, pvMemIn, pmbCurrent->dwBytes );

            //
            // Nuke the old memory if the allocation is to be smaller.
            //
            if ( dwBytesIn < pmbCurrent->dwBytes )
            {
                LPBYTE pb = (LPBYTE) pvOld + dwBytesIn;
                memset( pb, FREE_ADDRESS, pmbCurrent->dwBytes - dwBytesIn );
            } // if: smaller memory

            pmbCurrent->pvMem = pvOld;
        } // if: got new memory
        else
        {
            pvOld = pvMemIn;
        } // else: allocation failed
    } // if: found entry
    else
    {
        DebugMessage(
                  pszFileIn
                , nLineIn
                , pszModuleIn
                , L"***** Realloc'ing memeory at 0x%08x which was not on the list 0x%08x (ThreadID = 0x%08x) *****"
                , pvMemIn
                , *ppmbHeadInout
                , GetCurrentThreadId()
                );
    } // else: entry not found

    //
    // We do this any way because the flags and input still need to be
    // verified by HeapReAlloc().
    //
    pv = HeapReAlloc( GetProcessHeap(), uFlagsIn, pvOld, dwBytesIn );
    if ( pv == NULL )
    {
        DWORD dwErr = TW32( GetLastError() );
        AssertMsg( dwErr == 0, "HeapReAlloc() failed!" );

        if ( pvMemIn != pvOld )
        {
            HeapFree( GetProcessHeap(), 0, pvOld );
        } // if: forced a move

        SetLastError( dwErr );

        if ( pmbCurrent != NULL )
        {
            //
            // Continue tracking the memory by re-adding it to the tracking list.
            //
            pmbCurrent->pvMem = pvMemIn;
            pmbCurrent->pNext = *ppmbHeadInout;
            *ppmbHeadInout    = pmbCurrent;
        } // if: reuse the old entry
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtHEAPMEMALLOC, pvOld, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        } // else: make new entry

    } // if: allocation failed
    else
    {
        if ( pv != pvMemIn )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                memset( pvMemIn, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            HeapFree( GetProcessHeap(), 0, pvMemIn );

        } // if: new memory location

        //
        // Add the allocation to the tracking table.
        //
        if ( pmbCurrent != NULL )
        {
            //
            // If the block is bigger, initialize the "new" memory
            //
            if ( IsTraceFlagSet( mtfMEMORYINIT ) && ( dwBytesIn > pmbCurrent->dwBytes ) )
            {
                //
                // Initialize the expaned memory block
                //
                LPBYTE pb = (LPBYTE) pv + pmbCurrent->dwBytes;
                memset( pb, AVAILABLE_ADDRESS, dwBytesIn - pmbCurrent->dwBytes );
            } // if: initialize memory

            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->pvMem      = pv;
            pmbCurrent->dwBytes    = dwBytesIn;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"ReAlloced" );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtHEAPMEMALLOC, pvOld, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        } // else: make new entry
    } // else: allocation succeeded

Exit:

    return pv;

} //*** DebugReallocList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugReAlloc
//
//  Description:
//      Replacement for LocalReAlloc, GlobalReAlloc, and realloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      pvMemIn         - Pointer to the source memory.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugReAlloc(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    void *      pvMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCWSTR     pszCommentIn
    )
{
    void * pv;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        pv = DebugReAllocList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pvMemIn, uFlagsIn, dwBytesIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pv = DebugReAllocList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pvMemIn, uFlagsIn, dwBytesIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return pv;

} //*** DebugRealloc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugFree
//
//  Description:
//      Replacement for LocalFree for CHKed/DEBUG builds. Removes the
//      memory allocation for the memory tracking list. Use the TraceFree
//      macro to make memory allocation switch in RETAIL. The memory of the
//      freed block will be set to 0xFE.
//
//  Arguments:
//      embtTypeIn      - Memory block type.
//      pvMemIn         - Pointer to memory block to free.
//      pszFileIn       - Source file path to the caller
//      nLineIn         - Line number of the caller in the source file
//      pszModuleIn     - Source module name of the caller
//
//  Return Values:
//      TRUE
//          Memory was freed.
//
//      FALSE
//          An Error occured.  Use GetLastError() to determine the failure.
//          See HeapAlloc(), LocalAlloc(), or free() for more details.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugFree(
    EMEMORYBLOCKTYPE    embtTypeIn,
    void *              pvMemIn,
    LPCWSTR             pszFileIn,
    const int           nLineIn,
    LPCWSTR             pszModuleIn
    )
{
    Assert( embtTypeIn != mmbtOBJECT );

    DebugMemoryDelete( embtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, TRUE );

    return DebugRealFree( embtTypeIn, pvMemIn );

} //*** DebugFree

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryCheck
//
//  Description:
//      Called just before a thread/process dies to verify that all the memory
//      allocated by the thread/process was properly freed. Anything that was
//      not freed will be listed in the debugger.
//
//      If pmbListIn is NULL, it will check the current threads tracking list.
//      The list is destroyed as it is checked.
//
//  Arguments:
//      pvListIn      - The list to check.
//      pszListNameIn - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryCheck( LPVOID pvListIn, LPCWSTR pszListNameIn )
{
    //
    //  We are either doing global memory tracking or we are doing
    //  per thread memory tracking...
    //
    Assert( ( ( g_TraceMemoryIndex == -1 ) && ( g_fGlobalMemoryTacking ) )
        ||  ( ( g_TraceMemoryIndex != -1 ) && ( !g_fGlobalMemoryTacking ) ) );

    BOOL                fFoundLeak = FALSE;
    MEMORYBLOCK *       pmb;
    SPerThreadDebug *   ptd = NULL;

    if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
    {
        Assert( g_TraceFlagsIndex != -1 );
        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
    } // if: per thread tracing

    //
    // Determine which list to use.
    //
    if ( pvListIn == NULL )
    {
        pmb = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
    } // if: use the thread list
    else
    {
        MEMORYBLOCKLIST * pmbl = (MEMORYBLOCKLIST *) pvListIn;

        Assert( pszListNameIn != NULL );

        //
        // Make sure nobody tries to use the list again.
        //
        EnterCriticalSection( &pmbl->csList );
        pmbl->fDeadList = TRUE;
        LeaveCriticalSection( &pmbl->csList );

        pmb = pmbl->pmbList;
    } // else: use the given list

    //
    // Print banner if needed.
    //
    if ( pmb != NULL )
    {
        if ( pvListIn == NULL )
        {
            if ( ptd != NULL && ptd->pcszName != NULL )
            {
                DebugMsg( L"DEBUG: ******** Memory leak detected ***** %ws, ThreadID = %#x ********", ptd->pcszName, GetCurrentThreadId() );

            } // if: named thread
            else
            {
                DebugMsg( "DEBUG: ******** Memory leak detected ******************* ThreadID = 0x%08x ********", GetCurrentThreadId() );

            } // else: unnamed thread

            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // if: thread leak
        else
        {
            DebugMsg( L"DEBUG: ******** Memory leak detected ******************* %ws ********", pszListNameIn );
            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // else: list leak
        fFoundLeak = TRUE;

    } // if: leak found

    //
    // Dump the entries.
    //
    while ( pmb != NULL )
    {
        LPCWSTR pszFormat;

        switch ( pmb->embtType )
        {
            case mmbtHEAPMEMALLOC:
            case mmbtLOCALMEMALLOC:
            case mmbtMALLOCMEMALLOC:
            case mmbtOBJECT:
            case mmbtHANDLE:
            case mmbtPUNK:
#if defined( USES_SYSALLOCSTRING )
            case mmbtSYSALLOCSTRING:
#endif // USES_SYSALLOCSTRING
                pszFormat = L"%10ws %wc 0x%08x  %-5u  \"%ws\"";
                break;

            default:
                AssertMsg( 0, "Unknown memory block type!" );
                pszFormat = g_szNULL;
                break;
        } // switch: pmb->embtType

        DebugMessage(
              pmb->pszFile
            , pmb->nLine
            , pmb->pszModule
            , pszFormat
            , pmb->pszModule
            , DebugMemoryBlockIDChar( pmb->embtType )
            , pmb->pvMem
            , pmb->dwBytes
            , pmb->pszComment
            );

        pmb = pmb->pNext;

    } // while: something in the list

    //
    // Print trailer if needed.
    //
    if ( fFoundLeak == TRUE )
    {
        // Add an extra newline to the end of this message.
        DebugMsg( L"DEBUG: ***************************** Memory leak detected *****************************" SZ_NEWLINE );

    } // if: leaking

    //
    // Assert if needed.
    //
    if ( IsDebugFlagSet( mtfMEMORYLEAKS ) )
    {
        Assert( !fFoundLeak );

    } // if: yell at leaks

} //*** DebugMemoryCheck

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugCreateMemoryList
//
//  Description:
//      Creates a memory block list for tracking possible "global" scope
//      memory allocations.
//
//  Arguments:
//      pszFileIn     - Source file of caller.
//      nLineIn       - Source line number of caller.
//      pszModuleIn   - Source module name of caller.
//      ppvListOut    - Location to the store address of the list head.
//      pszListNameIn - Name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugCreateMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCWSTR     pszListNameIn
    )
{
    MEMORYBLOCKLIST * pmbl;

    Assert( ppvListOut != NULL );
    Assert( *ppvListOut == NULL );

    *ppvListOut = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( MEMORYBLOCKLIST ) );
    AssertMsg( *ppvListOut != NULL, "Low memory situation." );

    pmbl = (MEMORYBLOCKLIST*) *ppvListOut;

    InitializeCriticalSection( &(pmbl->csList) );

    Assert( pmbl->pmbList == NULL );
    Assert( pmbl->fDeadList == FALSE );

    if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
    {
        DebugMessage( pszFileIn, nLineIn, pszModuleIn, L"Created new memory list %ws", pszListNameIn );
    } // if: tracing

} //*** DebugCreateMemoryList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugDeleteMemoryList
//
//  Description:
//      Deletes the global memory block list for tracking possible "global" scope
//      memory allocations.
//
//  Arguments:
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDeleteMemoryList( LPVOID pvIn )
{
    MEMORYBLOCKLIST * pmbl;

    pmbl = (MEMORYBLOCKLIST *) pvIn;

    DeleteCriticalSection( &(pmbl->csList) );

    HeapFree( GetProcessHeap(), 0, pmbl );

} //*** DebugDeleteMemoryList

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMemoryListDelete
//
//  Description:
//      Removes the memory from the tracking list and adds it back to the
//      "per thread" tracking list in order to called DebugMemoryDelete()
//      to do the proper destruction of the memory. Not highly efficent, but
//      reduces code maintenance by having "destroy" code in one (the most
//      used) location.
//
//  Arguments:
//      pszFileIn    - Source file of caller.
//      nLineIn      - Source line number of caller.
//      pszModuleIn  - Source module name of caller.
//      pvMemIn      - Memory to be freed.
//      pvListIn     - List from which the memory is to be freed.
//      pvListNameIn - Name of the list.
//      fClobberIn   - TRUE - destroys memory; FALSE just removes from list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryListDelete(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCWSTR     pszListNameIn,
    BOOL        fClobberIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        MEMORYBLOCK *   pmbCurrent;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        EnterCriticalSection( &pmbl->csList );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbCurrent = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbCurrent != NULL )
        {
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;

            } // if: not first entry
            else
            {
                pmbl->pmbList = pmbCurrent->pNext;

            } // else: first entry

        } // if: got entry

        LeaveCriticalSection( &pmbl->csList );

        if ( pmbCurrent != NULL )
        {
            //
            // Add it back to the per thread list.
            //

            Assert( g_TraceMemoryIndex != -1 );
            pmbPrev = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            pmbCurrent->pNext = pmbPrev;
            TlsSetValue( g_TraceMemoryIndex, pmbCurrent );

            //
            // Finally delete it.
            //

            DebugMemoryDelete( pmbCurrent->embtType, pmbCurrent->pvMem, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }
        else
        {
            //
            //  Not from the provided list. Try a thread delete any way.
            //

            DebugMemoryDelete( mmbtUNKNOWN, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }

    } // if: pvIn != NULL

} //*** DebugMemoryListDelete

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMoveToMemoryList
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCWSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCWSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveToMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCWSTR     pszListNameIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbCurrent != NULL, "Memory not in list. Check your code." );

        //
        // Remove the memory block from the "per thread" tracking list.
        //
        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;

        } // if: not first entry
        else
        {
            TlsSetValue( g_TraceMemoryIndex, pmbCurrent->pNext );

        } // else: first entry

        //
        // Update the "source" data.
        //
        pmbCurrent->pszFile   = pszFileIn;
        pmbCurrent->nLine     = nLineIn;
        pmbCurrent->pszModule = pszModuleIn;

        //
        // Spew if needed.
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            WCHAR szMessage[ 128 ]; // random

            DBHR( StringCchPrintfW( szMessage, RTL_NUMBER_OF( szMessage ), L"Transferring to %ws", pszListNameIn ) );
            DebugMemorySpew( pmbCurrent, szMessage );
        } // if: tracing

        //
        // Add to list.
        //
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        EnterCriticalSection( &pmbl->csList );
        pmbCurrent->pNext = pmbl->pmbList;
        pmbl->pmbList  = pmbCurrent;
        LeaveCriticalSection( &pmbl->csList );

    } // if: pvIn != NULL

} //*** DebugMoveToMemoryList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugMoveFromMemoryList
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCWSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCWSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveFromMemoryList(
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn,
    LPVOID      pvMemIn,
    LPVOID      pvListIn,
    LPCWSTR     pszListNameIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        MEMORYBLOCK *   pmbCurrent;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        EnterCriticalSection( &pmbl->csList );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbCurrent = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( pmbCurrent != NULL
             && pmbCurrent->pvMem != pvMemIn
              )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbCurrent != NULL, "Memory not in tracking list. Use TraceMemoryAddxxxx() or add it to the memory list." );

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;

        } // if: not first entry
        else
        {
            pmbl->pmbList = pmbCurrent->pNext;

        } // else: first entry

        LeaveCriticalSection( &pmbl->csList );

        //
        // Add it back to the per thread list.
        //

        Assert( g_TraceMemoryIndex != -1 );

        pmbPrev = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pmbCurrent->pNext = pmbPrev;
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );

    } // if: pvIn != NULL

} //*** DebugMoveFromMemoryList
*/
#if defined( USES_SYSALLOCSTRING )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugSysReAllocStringList
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout      - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
INT
DebugSysReAllocStringList(
      MEMORYBLOCK **  ppmbHeadInout
    , LPCWSTR         pszFileIn
    , const int       nLineIn
    , LPCWSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , LPCWSTR         pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    BSTR            bstrOld;
    MEMORYBLOCK *   pmbCurrent = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocString() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrInout != NULL );
    Assert( pszIn != NULL );
    Assert( *pbstrInout == NULL || ( pszIn < *pbstrInout || pszIn > *pbstrInout + wcslen( *pbstrInout ) + 1 ) );

    bstrOld = *pbstrInout;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbPrev = NULL;

        pmbCurrent = *ppmbHeadInout;

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->bstr != bstrOld ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        //  Did we find the tracked addresses record?
        //
        if ( pmbCurrent != NULL )
        {
            AssertMsg( pmbCurrent->embtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;
            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"Freeing" );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrInout );
            if ( bstrOld != NULL )
            {
                pmbCurrent->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrInout;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage(
                        pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , L"***** SysReAlloc'ing memory at 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****"
                      , bstrOld
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found

    } // if: something to delete

    //
    // We do this anyway because the flags and input still need to be
    // verified by SysReAllocString().
    //
    fReturn = SysReAllocString( &bstrOld, pszIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocString() failed!" );

        if ( *pbstrInout != bstrOld )
        {
            SysFreeString( bstrOld );
        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else
    {
        if ( bstrOld != *pbstrInout )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbCurrent->dwBytes != 0 ); // invalid string
                memset( *pbstrInout, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrInout );

        } // if: new memory location

        if ( pmbCurrent != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->bstr       = bstrOld;
            pmbCurrent->dwBytes    = ( DWORD ) wcslen( pszIn ) + 1;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"SysReAlloced" );
            } // if: tracing
        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we
            //  need to pass it the list that was passed into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtSYSALLOCSTRING, bstrOld, pszFileIn, nLineIn, pszModuleIn, ( DWORD ) wcslen( pszIn ) + 1, pszCommentIn );
        } // else: make new entry

    } // else: allocation succeeded

    *pbstrInout = bstrOld;

    return fReturn;

} //*** DebugSysReAllocStringList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugSysReAllocString
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocString(
      LPCWSTR         pszFileIn
    , const int       nLineIn
    , LPCWSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , LPCWSTR         pszCommentIn
    )
{
    BOOL fReturn = FALSE;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        fReturn = DebugSysReAllocStringList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        fReturn = DebugSysReAllocStringList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return fReturn;

} //*** DebugSysReAllocString

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugSysReAllocStringLenList
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout      - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLenList(
      MEMORYBLOCK **    ppmbHeadInout
    , LPCWSTR           pszFileIn
    , const int         nLineIn
    , LPCWSTR           pszModuleIn
    , BSTR *            pbstrInout
    , const OLECHAR *   pszIn
    , unsigned int      ucchIn
    , LPCWSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    BSTR            bstrOld  = NULL;
    BSTR            bstrTemp = NULL;
    MEMORYBLOCK *   pmbCurrent = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocStringLen() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrInout != NULL );
    Assert( pszIn != NULL );
    Assert( ( *pbstrInout == NULL ) || ( pszIn == *pbstrInout ) || ( pszIn < *pbstrInout ) || ( pszIn > *pbstrInout + SysStringLen( *pbstrInout ) + 1 ) );

    bstrOld = *pbstrInout;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbPrev = NULL;

        pmbCurrent = *ppmbHeadInout;

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->bstr != bstrOld ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        //  Did we find the tracking record?
        //
        if ( pmbCurrent != NULL )
        {
            AssertMsg( pmbCurrent->embtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;

            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"Freeing" );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrTemp = SysAllocString( *pbstrInout );
            if ( bstrTemp != NULL )
            {
                pmbCurrent->bstr = bstrTemp;
            } // if: success
            else
            {
                //
                //  REVIEW:   26-MAR-2001 GalenB
                //
                //  Hmmm...  If the alloc above ever fails then isn't memory low?
                //
                bstrTemp = *pbstrInout;
            } // else: failed
        } // if: found entry
        else
        {
            DebugMessage(
                        pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , L"***** SysReAlloc'ing memory 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****"
                      , bstrOld
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found
    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be
    // verified by SysReAllocString().
    //
    bstrOld = bstrTemp;
    fReturn = SysReAllocStringLen( &bstrTemp, pszIn, ucchIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocStringLen() failed!" );

        if ( bstrTemp != *pbstrInout  )
        {
            //
            //  We made a copy of the old string, but fail to realloc the new string.
            //  So SysReAllocStrinLen() returns the old pointer. We need to free our
            //  new temp memory and point it to the old incoming memory.
            //
            SysFreeString( bstrTemp );
            bstrTemp = *pbstrInout;
        } // if: forced a move

        SetLastError( dwErr );
    } // if: allocation failed
    else
    {
        if ( bstrTemp != bstrOld )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbCurrent->dwBytes != 0 ); // invalid string
                memset( *pbstrInout, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrInout );
        } // if: new memory location

        if ( pmbCurrent != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->bstr       = bstrTemp;
            pmbCurrent->dwBytes    = ucchIn;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, L"SysReAlloced" );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtSYSALLOCSTRING, bstrTemp, pszFileIn, nLineIn, pszModuleIn, ucchIn + 1, pszCommentIn );
        } // else: make new entry

    } // else: allocation succeeded

    *pbstrInout = bstrTemp;
    return fReturn;

} //*** DebugSysReAllocStringLenList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DebugSysReAllocStringLen
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLen(
      LPCWSTR         pszFileIn
    , const int       nLineIn
    , LPCWSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , unsigned int    ucchIn
    , LPCWSTR         pszCommentIn
    )
{
    BOOL    fReturn = FALSE;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        fReturn = DebugSysReAllocStringLenList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, ucchIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        fReturn = DebugSysReAllocStringLenList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, ucchIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return fReturn;

} //*** DebugSysReAllocStringLen

#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Global Management Functions -
//
//  These are in debug and retail but internally they change
//  depending on the build.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  operator new
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
#undef new
void *
__cdecl
operator new(
    size_t      stSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, static_cast< DWORD >( stSizeIn ), L" new() " );

} //*** operator new( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  operator new
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( pv != NULL, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT, pv, g_szUnknown, 0, g_szUnknown, static_cast< DWORD >( stSizeIn ), L" new() " );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new - DEBUG

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  operator new []
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t      stSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, stSizeIn, L" new []() " );

} //*** operator new []( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  operator new []
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( pv != NULL, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT, pv, g_szUnknown, 0, g_szUnknown, stSizeIn, L" new() " );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new [] - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  operator delete
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  operator delete
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete - DEBUG
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  operator delete []
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn,
    size_t      stSizeIn,
    LPCWSTR     pszFileIn,
    const int   nLineIn,
    LPCWSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  operator delete []
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete [] - DEBUG

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  _purecall
//
//  Description:
//      Stub for purecall functions. It will always Assert.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    AssertMsg( 0, "Purecall" );
    return E_UNEXPECTED;

} //*** _purecall - DEBUG
#endif // !defined(ENTRY_PREFIX)

#else // ! DEBUG -- It's retail

//****************************************************************************
//
//  Global Management Functions -
//
//  These are the retail version.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  operator new
//
//  Description:
//      Replacment for the operator new() in the CRTs. Simply allocates a
//      block of memory for the object to use.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
    return HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

} //*** operator new - RETAIL

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  operator delete
//
//  Description:
//      Replacment for the operator delete() in the CRTs. Simply frees the
//      memory.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void * pv
    )
{
    HeapFree( GetProcessHeap(), 0, pv );

} //*** operator delete - RETAIL

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  _purecall
//
//  Description:
//      Stub for purecall functions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    AssertMsg( 0, "Purecall" );
    return E_UNEXPECTED;

} //*** _purecall - RETAIL
#endif // !defined(ENTRY_PREFIX)

#define __MODULE__  NULL


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\cfactorysrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CFactory.cpp
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CFactory")
//#define THISCLASS CFactory


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::S_HrCreateInstance(
//        LPCREATEINST lpfn
//      , CFactory** ppFactoryInstanceOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CFactory::S_HrCreateInstance(
      PFN_FACTORY_METHOD    lpfn
    , CFactory **           ppFactoryInstanceOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    CFactory *  pInstance = NULL;

    if ( ppFactoryInstanceOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppFactoryInstanceOut = NULL;

    if ( lpfn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pInstance = new CFactory;
    if ( pInstance == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pInstance->HrInit( lpfn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *ppFactoryInstanceOut = pInstance;
    pInstance = NULL;
    
Cleanup:

    if ( pInstance != NULL )
    {
        delete pInstance;
    }
    HRETURN( hr );

} //*** CFactory::S_HrCreateInstance

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
//////////////////////////////////////////////////////////////////////////////
CFactory::CFactory( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CFactory::CFactory

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::HrInit(
    PFN_FACTORY_METHOD lpfnCreateIn
    )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();  // Add one count

    // IClassFactory
    m_pfnCreateInstance = lpfnCreateIn; 

    HRETURN( S_OK );

} //*** CFactory::HrInit

//////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////
CFactory::~CFactory( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CFactory::~CFactory

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CFactory::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        //
        // Can't track IUnknown as they must be equal the same address
        // for every QI.
        //
        *ppvOut = static_cast< IClassFactory * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClassFactory ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClassFactory, this, 0 );
    } // else if: IClassFactory
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN( hr, riidIn );

} //*** CFactory::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CFactory::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CFactory::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CFactory::AddRef

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CFactory::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CFactory::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CFactory::Release

// ************************************************************************
//
// IClassFactory
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CFactory::CreateInstance
//
//  Description:
//      Create the CFactory instance.
//
//  Arguments:
//      pUnkOuterIn
//      riidIn
//      ppvOut
//
//  Return Values:
//      S_OK
//      E_POINTER
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::CreateInstance(
    IUnknown *  pUnkOuterIn,
    REFIID      riidIn,
    void **     ppvOut
    )
{
    TraceFunc( "[IClassFactory]" );

    HRESULT     hr  = E_NOINTERFACE;
    IUnknown *  pUnk = NULL; 

    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppvOut = NULL;

    if ( NULL != pUnkOuterIn )
    {
        hr = THR( CLASS_E_NOAGGREGATION );
        goto Cleanup;
    }

    Assert( m_pfnCreateInstance != NULL );
    hr = THR( m_pfnCreateInstance( &pUnk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Can't safe type.
    TraceMsgDo( hr = pUnk->QueryInterface( riidIn, ppvOut ), "0x%08x" );

Cleanup:
    if ( pUnk != NULL )
    {
        ULONG cRef;
        //
        // Release the created instance, not the punk
        //
        TraceMsgDo( cRef = ((IUnknown*) pUnk)->Release(), "%u" );
    }

    HRETURN( hr );

} //*** CFactory::CreateInstance

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::[IClassFactory] LockServer(
//      BOOL fLock
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::LockServer(
    BOOL fLock
    )
{
    TraceFunc( "[IClassFactory]" );

    if ( fLock )
    {
        InterlockedIncrement( &g_cLock );
    }
    else
    {
        InterlockedDecrement( &g_cLock );
    }

    HRETURN( S_OK );

} //*** CFactory::LockServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\interfacetablesrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      InterfaceTableSrc.cpp
//
//  Maintained By:
//      Galen Barbee    (GalenB)    30-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#pragma warning( disable : 4995 ) // deprecated functions
#include <comdef.h>
#pragma warning( pop )

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map a name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this). To improve speed, put the most
// used interfaces first such as IUnknown (the search routine is a simple
// linear search).
//
// Format: IID, Name, Number of methods

BEGIN_INTERFACETABLE
    // most used interfaces
DEFINE_INTERFACE( IID_IUnknown,                             "IUnknown",                             0   )   // unknwn.idl
    // internally used interfaces
DEFINE_INTERFACE( IID_IServiceProvider,                     "IServiceProvider",                     1   )   // serprov.idl
DEFINE_INTERFACE( IID_INotificationManager,                 "INotificationManager",                 1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IObjectManager,                       "IObjectManager",                       4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IExtendObjectManager,                 "IExtendObjectManager",                 1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_ITaskManager,                         "ITaskManager",                         2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ILogManager,                          "ILogManager",                          3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IDoTask,                              "IDoTask",                              2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConnectionManager,                   "IConnectionManager",                   1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConnectionPoint,                     "IConnectionPoint",                     5   )   // objidl.idl
DEFINE_INTERFACE( IID_IConnectionPointContainer,            "IConnectionPointContainer",            2   )   // objidl.idl
DEFINE_INTERFACE( IID_IConnectionInfo,                      "IConnectionInfo",                      3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IStandardInfo,                        "IStandardInfo",                        6   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IGatherData,                          "IGatherData",                          1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGatherNodeInfo,                  "ITaskGatherNodeInfo",                  5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConfigurationConnection,             "IConfigurationConnection",             2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IEnumNodes,                           "IEnumNodes",                           5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_INotifyUI,                            "INotifyUI",                            1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskAnalyzeCluster,                  "ITaskAnalyzeCluster",                  5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskCommitClusterChanges,            "ITaskCommitClusterChanges",            5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskCompareAndPushInformation,       "ITaskCompareAndPushInformation",       4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGatherInformation,               "ITaskGatherInformation",               6   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgWbemServices,                 "IClusCfgWbemServices",                 1   )   // Guids.h
DEFINE_INTERFACE( IID_IEnumClusCfgPartitions,               "IEnumClusCfgPartitions",               5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgPartitionInfo,                "IClusCfgPartitionInfo",                8   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgSetWbemObject,                "IClusCfgSetWbemObject",                1   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgIPAddressInfo,                "IClusCfgIPAddressInfo",                5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgSetClusterNodeInfo,           "IClusCfgSetClusterNodeInfo",           1   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskGatherClusterInfo,               "ITaskGatherClusterInfo",               4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgSetClusterHandles,            "IClusCfgSetClusterHandles",            2   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskGetDomains,                      "ITaskGetDomains",                      4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IDispatch,                            "IDispatch",                            4   )   // oaidl.idl
DEFINE_INTERFACE( IID_IClusCfgCreateClusterWizard,          "IClusCfgCreateClusterWizard",          22  )   // ClusCfgWizard.idl -- 18 + IDispatch
DEFINE_INTERFACE( IID_IClusCfgAddNodesWizard,               "IClusCfgAddNodesWizard",               15  )   // ClusCfgWizard.idl -- 11 + IDispatch
DEFINE_INTERFACE( IID_IClusCfgPhysicalDiskProperties,       "IClusCfgPhysicalDiskProperties",       11  )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgPartitionProperties,          "IClusCfgPartitionProperties",          3   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgSetCredentials,               "IClusCfgSetCredentials",               1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgLoadResource,                 "IClusCfgLoadResource",                 1   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgSetPollingCallback,           "IClusCfgSetPollingCallback",           1   )   // Guids.h
DEFINE_INTERFACE( IID_IEnumCookies,                         "IEnumCookies",                         5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGetDomains,                      "ITaskGetDomains",                      3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGetDomainsCallback,              "ITaskGetDomainsCallback",              2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IPrivatePostCfgResource,              "IPrivatePostCfgResource",              1   )   // Guids.h
DEFINE_INTERFACE( IID_IPostCfgManager,                      "IPostCfgManager",                      1   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskPollingCallback,                 "ITaskPollingCallback",                 3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskVerifyIPAddress,                 "ITaskVerifyIPAddress",                 4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgEvictCleanup,                 "IClusCfgEvictCleanup",                 2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgEvictCleanup,            "AsyncIClusCfgEvictCleanup",            2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgAsyncEvictCleanup,            "IClusCfgAsyncEvictCleanup",            1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgStartupListener,              "IClusCfgStartupListener",              1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgStartupListener,         "AsyncIClusCfgStartupListener",         1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgStartupNotify,                "IClusCfgStartupNotify",                1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgStartupNotify,           "AsyncIClusCfgStartupNotify",           1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResTypeServicesInitialize,    "IClusCfgResTypeServicesInitialize",    1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgClusterNetworkInfo,           "IClusCfgClusterNetworkInfo",           3   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgEvictListener,                "IClusCfgEvictListener",                1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgEvictNotify,                  "IClusCfgEvictNotify",                  1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_ITaskCancelCleanup,                   "ITaskCancelCleanup",                   4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgClusterInfoEx,                "IClusCfgClusterInfoEx",                2   )   // ClusCfgPrivate.idl

    // mixed use interfaces
DEFINE_INTERFACE( IID_IClusCfgServer,                       "IClusCfgServer",                       6   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgNodeInfo,                     "IClusCfgNodeInfo",                     9   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgManagedResources,         "IEnumClusCfgManagedResources",         5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgManagedResourceInfo,          "IClusCfgManagedResourceInfo",          13  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgNetworks,                 "IEnumClusCfgNetworks",                 5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgNetworkInfo,                  "IClusCfgNetworkInfo",                  12  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgCallback,                     "IClusCfgCallback",                     1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgInitialize,                   "IClusCfgInitialize",                   1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgClusterInfo,                  "IClusCfgClusterInfo",                  14  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgBaseCluster,                  "IClusCfgBaseCluster",                  5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgIPAddresses,              "IEnumClusCfgIPAddresses",              5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgCredentials,                  "IClusCfgCredentials",                  6   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgManagedResourceCfg,           "IClusCfgManagedResourceCfg",           4   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourcePreCreate,            "IClusCfgResourcePreCreate",            3   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceCreate,               "IClusCfgResourceCreate",               11  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourcePostCreate,           "IClusCfgResourcePostCreate",           1   )   // ClusCfgServer.idl
// DEFINE_INTERFACE( IID_IClusCfgResourceEvict,                "IClusCfgResourceEvict",                1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceTypeInfo,             "IClusCfgResourceTypeInfo",             3   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceTypeCreate,           "IClusCfgResourceTypeCreate",           2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgMemberSetChangeListener,      "IClusCfgMemberSetChangeListener",      1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgPollingCallback,              "IClusCfgPollingCallback",              2   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgPollingCallbackInfo,          "IClusCfgPollingCallbackInfo",          2   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgCapabilities,                 "IClusCfgCapabilities",                 1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgVerify,                       "IClusCfgVerify",                       3   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgClusterConnection,            "IClusCfgClusterConnection",            1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_ILogger,                              "ILogger",                              1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgManagedResourceData,          "IClusCfgManagedResourceData",          2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgVerifyQuorum,                 "IClusCfgVerifyQuorum",                 4   )   // ClusCfgServer.idl

    // rarely used interfaces
DEFINE_INTERFACE( IID_IClassFactory,                        "IClassFactory",                        2   )   // unknwn.idl
DEFINE_INTERFACE( IID_ICallFactory,                         "ICallFactory",                         2   )   // objidl.idl
DEFINE_INTERFACE( IID_IPersist,                             "IPersist",                             1   )   // objidl.idl
DEFINE_INTERFACE( IID_IPersistStream,                       "IPersistStream",                       5   )   // objidl.idl -- 4 + IPersist
DEFINE_INTERFACE( IID_IPersistStreamInit,                   "IPersistStreamInit",                   6   )   // ocidl.idl -- 5 + IPersist
DEFINE_INTERFACE( IID_IPersistStorage,                      "IPersistStorage",                      7   )   // objidl.idl -- 6 + IPersist
DEFINE_INTERFACE( IID_ISequentialStream,                    "ISequentialStream",                    4   )   // objidl.idl
DEFINE_INTERFACE( IID_IStream,                              "IStream",                              15  )   // objidl.idl -- 11 + ISequentialStream
DEFINE_INTERFACE( IID_IMarshal,                             "IMarshal",                             6   )   // objidl.idl
DEFINE_INTERFACE( IID_IStdMarshalInfo,                      "IStdMarshalInfo",                      1   )   // objidl.idl
DEFINE_INTERFACE( IID_IExternalConnection,                  "IExternalConnection",                  2   )   // objidl.idl
DEFINE_INTERFACE( __uuidof( IdentityUnmarshal ),            "IdentityUnmarshal",                    0   )   // comdef.h (CoClass - no known methods)
DEFINE_INTERFACE( __uuidof( IEnumConnections ),             "IEnumConnections",                     4   )   // comdef.h

END_INTERFACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\loadstring.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoadString.h
//
//  Description:
//      LoadStringIntoBSTR implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    01-FEB-2001
//      Galen Barbee    (GalenB)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Load string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    );

inline
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    return HrLoadStringIntoBSTR(
                          hInstanceIn
                        , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                        , idsIn
                        , pbstrInout
                        );

} //*** HrLoadStringIntoBSTR()

//////////////////////////////////////////////////////////////////////////////
// Format string ID routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

inline
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valist
                );

    va_end( valist );

    return hr;

} //*** HrFormatStringIntoBSTR( idsIn )

inline
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    return HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valistIn
                );

} //*** HrFormatStringWithVAListIntoBSTR( idsIn )

//////////////////////////////////////////////////////////////////////////////
// Format string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

// This is obsolete.  Use HrFormatStringIntoBSTR intead.
HRESULT
HrFormatMessageIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      uIDIn
    , BSTR *    pbstrInout
    , ...
    );

//////////////////////////////////////////////////////////////////////////////
// Format error routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , HRESULT * phrStatusOut
    , ...
    );

HRESULT
HrFormatErrorWithVAListIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

//////////////////////////////////////////////////////////////////////////////
// String conversion routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrAnsiStringToBSTR(
      LPCSTR    pcszAnsiIn
    , BSTR *    pbstrOut
    );

HRESULT
HrConcatenateBSTRs(
      BSTR *    pbstrDstInout
    , BSTR      bstrSrcIn
    );

HRESULT
HrFormatGuidIntoBSTR(
      GUID *    pguidIn
    , BSTR *    pbstrInout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\getcomputernamesrc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      GetComputerNameSrc.cpp
//
//  Description:
//      Getting and setting the computer name.
//
//  Maintained By:
//      Galen Barbee (GalenB)   31-MAR-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

// #include <Pch.h>     // should be included by includer of this file
#include <StrSafe.h>    // in case it isn't included by header file

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetComputerName
//
//  Description:
//      Get name of the computer on which this object is present.
//
//  Arguments:
//      cnfIn
//          Code representing type of information to return.
//
//      pbstrComputerNameOut
//          Buffer pointer for returning the computer or domain name.
//          Caller must deallocate this buffer using TraceSysFreeString.
//
//      fBestEffortIn
//          TRUE  = Attempt to return something even if DC is unavailable.
//          FALSE = Return all failures.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      DsGetDCName is used to get the domain name instead of just letting
//      GetComputerNameEx get it so that pre-Windows 2000 domains can be
//      supported.  In a pre-Windows 2000 domain, GetComputerNameEx will not
//      return an FQDN or a domain name if that is what has been request.
//      To support this scenario, this routine gets the domain name using
//      DsGetDCName, gets the hostname label, then constructs the final name
//      using <computername>.<DomainName>.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
HrGetComputerName(
      COMPUTER_NAME_FORMAT  cnfIn
    , BSTR *                pbstrComputerNameOut
    , BOOL                  fBestEffortIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    size_t                  cchComputerName = 0;
    size_t                  cchBuffer = 0;
    BSTR                    bstrComputerName = NULL;
    BOOL                    fAppendDomain = FALSE;
    BOOL                    fSuccess;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;

    if ( pbstrComputerNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pbstrComputerNameOut = NULL;

    //
    //  Only get the domain name when there is a reason to get the domain name.
    //

    if (   ( cnfIn == ComputerNameDnsFullyQualified )
        || ( cnfIn == ComputerNamePhysicalDnsFullyQualified )
        || ( cnfIn == ComputerNameDnsDomain )
        || ( cnfIn == ComputerNamePhysicalDnsDomain )
        )
    {
        //
        //  DsGetDcName will give us access to a usable domain name, regardless of whether we are
        //  currently in a W2k or a NT4 domain. On W2k and above, it will return a DNS domain name,
        //  on NT4 it will return a NetBIOS name.
        //

        sc = DsGetDcName(
                      NULL  // ComputerName
                    , NULL  // DomainName
                    , NULL  // DomainGuid
                    , NULL  // SiteName
                    , DS_DIRECTORY_SERVICE_PREFERRED
                    , &pdci
                    );
        if (    ( sc == ERROR_NO_SUCH_DOMAIN )
            &&  ( fBestEffortIn )
            )
        {
            fAppendDomain = FALSE;
        } // if: can't reach a DC
        else if ( sc != ERROR_SUCCESS )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // else if: DsGetDcName failed
        else
        {
            //
            //  This handles the case when we are a member of a legacy (pre-W2k) Domain.
            //  In this case, both FQDN and DnsDomain will not receive useful data from GetComputerNameEx.
            //  What we actually want to get is <computername>.<DomainName> in every case.
            //
            switch ( cnfIn )
            {
                case ComputerNameDnsFullyQualified:
                    cnfIn = ComputerNameDnsHostname;
                    break;

                case ComputerNamePhysicalDnsFullyQualified:
                    cnfIn = ComputerNamePhysicalDnsHostname;
                    break;

                case ComputerNameDnsDomain:
                case ComputerNamePhysicalDnsDomain:
                    *pbstrComputerNameOut = TraceSysAllocString( pdci->DomainName );
                    if ( *pbstrComputerNameOut == NULL )
                    {
                        hr = THR( E_OUTOFMEMORY );
                        goto Cleanup;
                    } // if:

                    goto Cleanup;
            } // switch: computer name format

            fAppendDomain = TRUE;

        } // else: DC contacted successfully
    } // if: computer name format requires domain name
    else
    {
        fAppendDomain = FALSE;
    } // else: computer name format does not require domain name

    //
    //  Get the computer name.  First get the size of the output buffer,
    //  allocate a buffer, then get the name itself.
    //

    cchComputerName = 0;
    fSuccess = GetComputerNameExW( cnfIn, NULL, reinterpret_cast< DWORD * >( &cchComputerName ) );
    if ( fSuccess == FALSE )
    {
        cchBuffer = cchComputerName + 1;

        //
        //  If error not buffer to small, we're done.
        //

        sc = GetLastError();
        if ( sc != ERROR_MORE_DATA )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "GetComputerNameEx failed. sc = %1!#08x!", sc );
            goto Cleanup;
        } // if: error other than buffer too small

        //
        //  Add on size of domain name and period separator.
        //

        if ( fAppendDomain )
        {
            // Add space for the domain name and the period separator.
            cchBuffer += wcslen( pdci->DomainName ) + 1;
        } // if: appending domain name to computer name

        //
        //  Allocate the output buffer.
        //

        bstrComputerName = TraceSysAllocStringLen( L"", static_cast< unsigned int >( cchBuffer ) );
        if ( bstrComputerName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: error allocating buffer for name

        //
        //  Get the computer name into the output buffer.
        //

        fSuccess = GetComputerNameExW( cnfIn, bstrComputerName, reinterpret_cast< DWORD * >( &cchComputerName ) );
        if ( fSuccess == FALSE )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "GetComputerNameEx failed. sc = %1!#08x!", sc );
            goto Cleanup;
        } // if: error getting the computer name

        //
        //  Append the period separator and domain name onto the computer name.
        //

        if ( fAppendDomain )
        {
            // Append a dot (.) and the domain name after the computer name.
            hr = THR( StringCchCatW( bstrComputerName, cchBuffer, L"." ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( StringCchCatW( bstrComputerName, cchBuffer, pdci->DomainName ) );
            }
            if ( FAILED( hr ) )
            {
                LogMsg( "Error concatenating domain name, hr = %1!#08x!", hr );
                goto Cleanup;
            }
        } // if: appending domain name to computer name

        //
        // Set output buffer pointer.
        //

        *pbstrComputerNameOut = bstrComputerName;
        bstrComputerName = NULL;

    } // if: error getting computer name
    else
    {
        AssertMsg( fSuccess == FALSE, "Expected GetComputerNameEx to fail with null buffer" );
    } // else: GetComputerNameEx didn't fail as expected


Cleanup:

    TraceSysFreeString( bstrComputerName );

    if ( pdci != NULL )
    {
        NetApiBufferFree( pdci );
    } // if:

    HRETURN( hr );

} //*** HrGetComputerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\dll.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Dll.h
//
//  Description:
//      DLL globals definitions and macros.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern WCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list

//
// Application ID (AppID) Macros
//
#define BEGIN_APPIDS const SAppIDInfo g_AppIDs[] = {
#define DEFINE_APPID( _name, _rappid, _idslaunch, _idsaccess, _nauthlevel, _nrunas ) { &_rappid, _name, ( RTL_NUMBER_OF( _name ) - 1 ), _idslaunch, _idsaccess, _nauthlevel, _nrunas },
#define END_APPIDS { NULL } };
extern const SAppIDInfo g_AppIDs[];


//
// Class Table Macros
//
#define BEGIN_DLL_PUBLIC_CLASSES const SPublicClassInfo g_DllPublicClasses[] = {
#define PUBLIC_CLASS( _name, _rclsid, _pfnCreator, _threading ) { _pfnCreator, &_rclsid, _name, ( RTL_NUMBER_OF( _name ) - 1 ), NULL, 0, _threading, NULL, NULL },
#define CLASS_WITH_APPID( _name, _rclsid, _pfnCreator, _threading, _rappid ) { _pfnCreator, &_rclsid, _name, ( RTL_NUMBER_OF( _name ) - 1 ), NULL, 0, _threading, &_rappid, NULL },
#define CLASS_WITH_CATID( _name, _rclsid, _pfnCreator, _threading, _pfncatreg ) { _pfnCreator, &_rclsid, _name, ( RTL_NUMBER_OF( _name ) - 1 ), NULL, 0, _threading, NULL, _pfncatreg },
#define CLASS_WITH_PROGID( _name, _rclsid, _pfnCreator, _threading, _progid ) { _pfnCreator, &_rclsid, _name, ( RTL_NUMBER_OF( _name ) - 1 ), _progid, ( RTL_NUMBER_OF( _progid ) - 1 ), _threading, NULL, NULL },
#define END_DLL_PUBLIC_CLASSES { NULL } };
extern const SPublicClassInfo g_DllPublicClasses[];

#define BEGIN_PRIVATE_CLASSES const SPrivateClassInfo g_PrivateClasses[] = { 
#define PRIVATE_CLASS( _name, _rclsid, _pfnCreator ) { _pfnCreator, &_rclsid, _name, ( RTL_NUMBER_OF( _name ) - 1 ) },
#define END_PRIVATE_CLASSES { NULL } };
extern const SPrivateClassInfo g_PrivateClasses[];

//
// Category ID (CATID) Macros
//
#define BEGIN_CATIDTABLE const SCatIDInfo g_DllCatIds[] = {
#define DEFINE_CATID( _rcatid, _name ) { &_rcatid, _name },
#define END_CATIDTABLE { NULL } }; const size_t g_cDllCatIds = RTL_NUMBER_OF( g_DllCatIds ) - 1;

extern const SCatIDInfo g_DllCatIds[];
extern const size_t g_cDllCatIds;
//
//  Type Library Macros
//
#define BEGIN_TYPELIBS const STypeLibInfo g_DllTypeLibs[] = {
#define DEFINE_TYPELIB( _idlibres ) { _idlibres, FALSE },
#define END_TYPELIBS { 0, TRUE } };

extern const STypeLibInfo g_DllTypeLibs[];


//
// DLL Global Function Prototypes
//
HRESULT
HrCoCreateInternalInstance(
    REFCLSID    rclsidIn,
    LPUNKNOWN   pUnkOuterIn,
    DWORD       dwClsContextIn,
    REFIID      riidIn,
    LPVOID *    ppvOut
    );

HRESULT
HrCoCreateInternalInstanceEx(
    REFCLSID        rclsidIn,
    LPUNKNOWN       pUnkOuterIn,
    DWORD           dwClsContextIn,
    COSERVERINFO *  pServerInfoIn,
    ULONG           cMultiQIsIn,
    MULTI_QI *      prgmqiInOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\loadstringsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      LoadStringSrc.cpp
//
//  Description:
//      LoadStringIntoBSTR implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    01-FEB-2001
//      Geoffrey Pease  (GPease)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

// #include <Pch.h>     // should be included by includer of this file
#include <StrSafe.h>    // in case it isn't included by header file

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

const WCHAR g_szWbemClientDLL[] = L"\\WBEM\\WMIUTILS.DLL";

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadStringIntoBSTR
//
//  Description:
//      Retrieves the string resource idsIn from the string table and makes it
//      into a BSTR. If the BSTR is not NULL coming it, it will assume that
//      you are trying reuse an existing BSTR.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.  If not specified, defaults to
//          g_hInstance.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//  Remarks:
//      This routine uses LoadResource so that it can get the actual length
//      of the string resource.  If we didn't do this, we would need to call
//      LoadString and allocate memory in a loop.  Very inefficient!
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    TraceFunc1( "idsIn = %d", idsIn );

    HRESULT hr              = S_OK;
    HRSRC   hrsrc           = NULL;
    HGLOBAL hgbl            = NULL;
    int     cch             = 0;
    PBYTE   pbStringData;
    PBYTE   pbStringDataMax;
    PBYTE   pbStringTable;
    int     cbStringTable;
    int     nTable;
    int     nOffset;
    int     idxString;

    Assert( idsIn != 0 );
    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    if ( hInstanceIn == NULL )
    {
        hInstanceIn = g_hInstance;
    }

    // The resource Id specified must be converted to an index into
    // a Windows StringTable.
    nTable = idsIn / 16;
    nOffset = idsIn - (nTable * 16);

    // Internal Table Id's start at 1 not 0.
    nTable++;

    //
    // Find the part of the string table where the string resides.
    //

    // Find the table containing the string.
    // First try to load the language specified.  If we can't find it we
    // try the "neutral" language.
    hrsrc = FindResourceEx( hInstanceIn, RT_STRING, MAKEINTRESOURCE( nTable ), langidIn );
    if ( ( hrsrc == NULL ) && ( GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND ) )
    {
        hrsrc = FindResourceEx(
                      hInstanceIn
                    , RT_STRING
                    , MAKEINTRESOURCE( nTable )
                    , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                    );
    }
    if ( hrsrc == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    // Load the table.
    hgbl = LoadResource( hInstanceIn, hrsrc );
    if ( hgbl == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    // Lock the table so we access its data.
    pbStringTable = reinterpret_cast< PBYTE >( LockResource( hgbl ) );
    if ( pbStringTable == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    cbStringTable = SizeofResource( hInstanceIn, hrsrc );
    Assert( cbStringTable != 0 );

    TraceFlow3( "HrLoadStringIntoBSTR() - Table = %#.08x, cb = %d, offset = %d", pbStringTable, cbStringTable, nOffset );

    // Set the data pointer to the beginning of the table.
    pbStringData = pbStringTable;
    pbStringDataMax = pbStringTable + cbStringTable;

    //
    // Skip strings in the block of 16 which are before the desired string.
    //

    for ( idxString = 0 ; idxString <= nOffset ; idxString++ )
    {
        Assert( pbStringData != NULL );
        Assert( pbStringData < pbStringDataMax );

        // Get the number of characters excluding the '\0'.
        cch = * ( (USHORT *) pbStringData );

        TraceFlow3( "HrLoadStringIntoBSTR() - pbStringData[ %d ] = %#.08x, cch = %d", idxString, pbStringData, cch );

        // Found the string.
        if ( idxString == nOffset )
        {
            if ( cch == 0 )
            {
                hr = HRESULT_FROM_WIN32( TW32( ERROR_RESOURCE_NAME_NOT_FOUND ) );
                goto Cleanup;
            }

            // Skip over the string length to get the string.
            pbStringData += sizeof( WCHAR );

            break;
        } // if: found the string

        // Add one to account for the string length.
        // A string length of 0 still takes 1 WCHAR for the length portion.
        cch++;

        // Skip over this string to get to the next string.
        pbStringData += ( cch * sizeof( WCHAR ) );

    } // for: each string in the block of 16 strings in the table

    // Note: nStringLen is the number of characters in the string not including the '\0'.
    AssertMsg( cch > 0, "Length of string in resource file cannot be zero." );

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if: string was allocated previously

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = TraceSysAllocStringLen( (OLECHAR *) pbStringData, cch );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceFlow1( "HrLoadStringIntoBSTR() - Loaded string = '%ws'", *pbstrInout );

Cleanup:

    HRETURN( hr );

} //*** HrLoadStringIntoBSTR( langidIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "ids = %d", idsIn );

    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                          hInstanceIn
                        , langidIn
                        , idsIn
                        , pbstrInout
                        , valist
                        );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatStringIntoBSTR( langidIn, idsIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "ids = %d", idsIn );

    HRESULT hr = S_OK;
    BSTR    bstrStringResource = NULL;
    DWORD   cch;
    LPWSTR  psz = NULL;

    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Load the string resource.
    //

    hr = HrLoadStringIntoBSTR( hInstanceIn, langidIn, idsIn, &bstrStringResource );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Format the message with the arguments.
    //

    cch = FormatMessageW(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , bstrStringResource
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = TraceSysAllocStringLen( psz, cch );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrStringResource );
    LocalFree( psz );

    HRETURN( hr );

} //*** HrFormatStringWithVAListIntoBSTR( langidIn, idsIn, valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "pcwszFmtIn = %ws", pcwszFmtIn );

    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR( pcwszFmtIn, pbstrInout, valist );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatStringIntoBSTR( pcwszFmtIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pcwszFmtIn or pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "pcwszFmtIn = %ws", pcwszFmtIn );

    HRESULT hr = S_OK;
    DWORD   cch;
    LPWSTR  psz = NULL;

    if (    ( pbstrInout == NULL )
        ||  ( pcwszFmtIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Format the message with the arguments.
    //

    cch = FormatMessageW(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , pcwszFmtIn
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = TraceSysAllocStringLen( psz, cch );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

Cleanup:

    LocalFree( psz );

    HRETURN( hr );

} //*** HrFormatStringWithVAListIntoBSTR( pcwszFmtIn, valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrFormatMessageIntoBSTR(
//      HINSTANCE   hInstanceIn,
//      UINT        uIDIn,
//      BSTR *      pbstrInout,
//      ...
//      )
//
//  Description:
//      Retrieves the format string from the string resource uIDIn using
//      FormatMessage.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      uIDIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatMessageIntoBSTR(
    HINSTANCE   hInstanceIn,
    UINT        uIDIn,
    BSTR *      pbstrInout,
    ...
    )
{
    TraceFunc( "" );

    va_list valist;

    DWORD   cch;

    LPWSTR  psz = NULL;
    HRESULT hr  = S_OK;

    DWORD   dw;
    WCHAR   szBuf[ 255 ];

    if ( pbstrInout == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    va_start( valist, pbstrInout );

    dw = LoadStringW( hInstanceIn, uIDIn, szBuf, RTL_NUMBER_OF( szBuf ) );

    AssertMsg( dw != 0, "Missing string??" );

    cch = FormatMessageW(
                  ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                  | FORMAT_MESSAGE_FROM_STRING )
                , szBuf
                , 0
                , 0
                , (LPWSTR) &psz
                , 0
                , &valist
                );
    va_end( valist );

    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = TraceSysAllocStringLen( psz, cch );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

Cleanup:

    LocalFree( psz );

    HRETURN( hr );

} //*** HrFormatMessageIntoBSTR


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatErrorIntoBSTR
//
//  Description:
//      Retrieves the system error message associated with the HRESULT. If
//      additional arguments are specified, it will use them in the formatting
//      of the error string.
//
//  Arguments:
//      hrIn
//          Error code to lookup the message for.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    HRESULT hr  = S_OK;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatErrorWithVAListIntoBSTR( hrIn, pbstrInout, valist );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatErrorIntoBSTR


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatErrorIntoBSTR
//
//  Description:
//      Retrieves the system error message associated with the HRESULT. If
//      additional arguments are specified, it will use them in the formatting
//      of the error string.
//
//  Arguments:
//      hrIn
//          Error code to lookup the message for.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      phrStatusOut
//          We may fix up the passed in error code to find better error
//          message text.  If we do that then we send the fixed up status
//          code back to the caller using this argument.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , HRESULT * phrStatusOut
    , ...
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );
    Assert( pbstrInout != NULL );
    Assert( phrStatusOut != NULL );

    HRESULT hr  = S_OK;
    HRESULT hrTemp = S_OK;
    va_list valist;

    *phrStatusOut = hrIn;

    va_start( valist, phrStatusOut );

    hr = HrFormatErrorWithVAListIntoBSTR( hrIn, pbstrInout, valist );
    if (   ( hr == HRESULT_FROM_WIN32( ERROR_MR_MID_NOT_FOUND ) )
        && ( HRESULT_SEVERITY( hrIn ) == SEVERITY_SUCCESS ) )
    {
        //
        //  If the passed in status is a successful failure and we were unable
        //  to look up the error message text then it may be one that we cleared
        //  off the SEVERITY_ERROR bit to make it a warning instead of an error
        //  in the UI.  If that's the case then set the SEVERITY_ERROR bit and
        //  try to lookup the error message text again.
        //

        hrTemp = MAKE_HRESULT( SEVERITY_ERROR, HRESULT_FACILITY( hrIn ), HRESULT_CODE( hrIn ) );

        hr = HrFormatErrorWithVAListIntoBSTR( hrTemp, pbstrInout, valist );
        if ( SUCCEEDED( hr ) )
        {
            //
            //  If the new status succeeded in finding error message text then
            //  send it back to the caller.
            //

            *phrStatusOut = hrTemp;
        } // if:
    } // if:

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatErrorIntoBSTR


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatErrorWithVAListIntoBSTR
//
//  Description:
//      Retrieves the system error message associated with the HRESULT. If
//      additional arguments are specified, it will use them in the formatting
//      of the error string.
//
//  Arguments:
//      hrIn
//          Error code to lookup the message for.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatErrorWithVAListIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    HRESULT hr  = S_OK;
    HRESULT hrTemp;
    DWORD   sc = 0;
    size_t  cch;
    LPWSTR  psz = NULL;
    LPWSTR  pszBuf = NULL;

    HMODULE hModule = NULL;
    LPWSTR  pszSysDir = NULL;
    size_t  cchSysDir = MAX_PATH + 1;

    LPWSTR  pszModule = NULL;
    size_t  cchModule = 0;

    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  Look at the HRESULT coming in and see if we need to modify it a little
    //  to ensure that we get the best possible error message text.
    //

    if ( HRESULT_FACILITY( hrIn ) == FACILITY_WIN32 )
    {
        //
        //  If this is a Win32 wrapped in an HRESULT then remove the
        //  HRESULT stuff so that the Win32 error code will be formatted
        //  into the message correctly.
        //

        hrTemp = HRESULT_CODE( hrIn );
    } // if: Win32 error code
    else
    {
        hrTemp = hrIn;
    } // else:

    cch = FormatMessageW(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM
                      /*| FORMAT_MESSAGE_IGNORE_INSERTS*/ )
                    , NULL
                    , hrTemp
                    , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );

    //
    // If the error message was not found then try WMIUtils since we know
    // that their error messages are not propertly located for a system lookup.
    //
    if ( cch == 0 )
    {
        pszSysDir = new WCHAR[ cchSysDir ];
        if ( pszSysDir == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        sc = GetSystemDirectoryW( pszSysDir, static_cast< UINT >( cchSysDir ) );
        if ( sc > ( cchSysDir - 1 ) )
        {
            delete [] pszSysDir;
            pszSysDir = NULL;

            cchSysDir = sc + 1;

            pszSysDir = new WCHAR[ cchSysDir ];
            if ( pszSysDir == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            sc = GetSystemDirectoryW( pszSysDir, static_cast< UINT >( cchSysDir ) );
        } // if:

        if ( sc == 0 )
        {
            sc = TW32( GetLastError() );
            goto Win32Error;
        } // if:

        cchModule = wcslen( pszSysDir ) + wcslen( g_szWbemClientDLL ) + 1;

        pszModule = new WCHAR[ cchModule ];
        if ( pszModule == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        THR( StringCchCopyExW( pszModule, cchModule, pszSysDir, &pszBuf, &cch, 0 ) );
        THR( StringCchCopyW( pszBuf, cch, g_szWbemClientDLL ) );

        hModule = LoadLibraryExW( pszModule, NULL, DONT_RESOLVE_DLL_REFERENCES );
        if ( hModule == NULL )
        {
            sc = TW32( GetLastError() );
            goto Win32Error;
        } // if:

        cch = FormatMessageW(
                          ( FORMAT_MESSAGE_FROM_HMODULE
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER
                          /*| FORMAT_MESSAGE_IGNORE_INSERTS*/ )
                        , hModule
                        , hrTemp
                        , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                        , (LPWSTR) &psz
                        , 0
                        , &valistIn
                        );
        if ( cch == 0 )
        {
            sc = TW32( GetLastError() );
        } // if:
    } // if:

    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        goto Win32Error;
    }

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = TraceSysAllocStringLen( psz, static_cast< UINT >( cch ) );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    // Remove CR's and LF's since they aren't printable and usually mess up
    // the text when displayed.
    //
    for( cch = 0 ; cch < SysStringLen( *pbstrInout ) ; cch ++ )
    {
        if (    ( (*pbstrInout)[ cch ] == L'\n' )
            ||  ( (*pbstrInout)[ cch ] == L'\r' ) )
        {
            (*pbstrInout)[ cch ] = L' ';
        } // if:
    } // for:

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz );
    } // if:

    delete [] pszModule;
    delete [] pszSysDir;

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    } // if:

    HRETURN( hr );

} //*** HrFormatErrorWithVAListIntoBSTR( valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAnsiStringToBSTR
//
//  Description:
//      Convert and ANSI string into a BSTR.
//
//  Arguments:
//      pcszAnsiIn
//          Pointer to the ANSI string to convert.
//
//      pbstrOut
//          Pointer to the BSTR to receive the string.HrAnsiStringToBSTR
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      S_FALSE
//          The input string was NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrOut is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAnsiStringToBSTR( LPCSTR pcszAnsiIn, BSTR * pbstrOut )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;
    DWORD   cch;
    DWORD   sc;
    int     nRet;

    if ( pbstrOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( pcszAnsiIn == NULL )
    {
        *pbstrOut = NULL;
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Determine number of wide characters to be allocated for the
    //  Unicode string.
    //
    cch = (DWORD) strlen( pcszAnsiIn ) + 1;

    bstr = TraceSysAllocStringLen( NULL, cch );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    nRet = MultiByteToWideChar( CP_ACP, 0, pcszAnsiIn, cch, bstr, cch );
    if ( nRet == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    *pbstrOut = bstr;

Cleanup:

    HRETURN( hr );

} //*** HrAnsiStringToBSTR


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConcatenateBSTRs
//
//  Description:
//      Concatenate one BSTR onto another one.
//
//  Arguments:
//      pbstrDstInout
//          Specifies the destination BSTR.
//
//      bstrSrcIn
//          Specifies the source BSTR whose contents will be concatenated
//          onto pbstrDstInout.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConcatenateBSTRs(
      BSTR *    pbstrDstInout
    , BSTR      bstrSrcIn
    )
{
    TraceFunc1( "bstrSrcIn = %ws", bstrSrcIn );

    HRESULT hr = S_OK;

    Assert( pbstrDstInout != NULL );
    Assert( bstrSrcIn != NULL );

    if ( *pbstrDstInout == NULL )
    {
        *pbstrDstInout = TraceSysAllocString( bstrSrcIn );
        if ( pbstrDstInout == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    } // if: no destination string specified
    else
    {
        size_t  cchSrc;
        size_t  cchDst;
        size_t  cchTotal;
        BSTR    bstr = NULL;
        LPWSTR  pszBuf = NULL;

        cchSrc = SysStringLen( bstrSrcIn );
        cchDst = SysStringLen( *pbstrDstInout );
        cchTotal = cchSrc + cchDst + 1;

        bstr = TraceSysAllocStringLen( NULL, static_cast< UINT >( cchTotal ) );
        if ( bstr == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( StringCchCopyExW( bstr, cchTotal, *pbstrDstInout, &pszBuf, &cchTotal, 0 ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( StringCchCopyW( pszBuf, cchTotal, bstrSrcIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:


        TraceSysFreeString( *pbstrDstInout );
        *pbstrDstInout = bstr;
    } // else: destination string was specified

Cleanup:

    HRETURN( hr );

} //*** HrConcatenateBSTRs


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatGuidIntoBSTR
//
//  Description:
//      Format a GUID into a BSTR.  If the BSTR is not NULL on entry,
//      the BSTR will be reused.
//
//  Arguments:
//      pguidIn
//          Specifies the GUID to format into a string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatGuidIntoBSTR(
      GUID *    pguidIn
    , BSTR *    pbstrInout
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR   wszGuid[ 64 ];
    size_t  cch = 0;
    size_t  cchRemaining = 0;

    if (    ( pbstrInout == NULL )
        ||  ( pguidIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( StringCchPrintfExW(
              wszGuid
            , RTL_NUMBER_OF( wszGuid )
            , NULL
            , &cchRemaining
            , 0
            , L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"
            , pguidIn->Data1
            , pguidIn->Data2
            , pguidIn->Data3
            , pguidIn->Data4[ 0 ]
            , pguidIn->Data4[ 1 ]
            , pguidIn->Data4[ 2 ]
            , pguidIn->Data4[ 3 ]
            , pguidIn->Data4[ 4 ]
            , pguidIn->Data4[ 5 ]
            , pguidIn->Data4[ 6 ]
            , pguidIn->Data4[ 7 ]
            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cch = RTL_NUMBER_OF( wszGuid ) - cchRemaining;

    if ( *pbstrInout != NULL )
    {
        TraceSysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    *pbstrInout = TraceSysAllocStringLen( wszGuid, static_cast< UINT >( cch ) );
    if ( *pbstrInout == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** HrFormatGuidIntoBSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\dllsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      DllSrc.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    18-OCT-1999
//
//  Notes:
//      Switches:
//      - ENTRY_PREFIX
//          If defined, include proxy/stub code into the DLL that is
//          generated by the MIDL compiler.
//      - USE_FUSION
//          If defined, initialize and uninitialize Fusion on process
//          attach and detach respectively.  The constant IDR_MANIFEST
//          must be defined with a value that represents the resource ID
//          for the manifest resource.
//      - NO_DLL_MAIN
//          If defined, don't implement DllMain.
//      - DEBUG_SW_TRACING_ENABLED
//          If defined, initialize and uninitialize software tracing on
//          process attach and detach respectively.
//      - THREAD_OPTIMIZATIONS
//          If defined, disable the thread notification calls when a thread
//          starts up or goes away.
//      - IMPLEMENT_COM_SERVER_DLL
//          If defined, defines entry points necessary for COM servers.
//
//////////////////////////////////////////////////////////////////////////////

//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

#if defined( ENTRY_PREFIX )
extern "C"
{
    extern HINSTANCE hProxyDll;
}
#endif

//
//  Macros to generate RPC entry points
//
#define __rpc_macro_expand2( a, b ) a##b
#define __rpc_macro_expand( a, b ) __rpc_macro_expand2( a, b )

#if ! defined( NO_DLL_MAIN ) || defined( ENTRY_PREFIX ) || defined( DEBUG )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      Dll entry point.
//
//  Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HINSTANCE   hInstIn,
    ULONG       ulReasonIn,
    LPVOID      // lpReservedIn
    )
{
    //
    // KB: THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By defining this you can prevent the linker
    // from calling your DllEntry for every new thread.
    // This makes creating new threads significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if ! defined( DEBUG )
    #define THREAD_OPTIMIZATIONS
#endif // DEBUG

    switch( ulReasonIn )
    {
        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_ATTACH:
        {
#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceInitializeProcess( g_rgTraceControlGuidList, RTL_NUMBER_OF( g_rgTraceControlGuidList ), TRUE );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceInitializeProcess( TRUE );
#endif // DEBUG_SW_TRACING_ENABLED

            TraceFunc( "" );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"
                , GetCurrentThreadId()
                );

            g_hInstance = hInstIn;

#if defined( ENTRY_PREFIX )
            hProxyDll = g_hInstance;
#endif // ENTRY_PREFIX
            {
                BOOL fResult = GetModuleFileName( g_hInstance, g_szDllFilename, RTL_NUMBER_OF( g_szDllFilename ) );
                if ( ! fResult )
                {
                    TW32MSG( GetLastError(), "GetModuleFileName()" );
                }
            }

            //
            // Create a global memory list so that memory allocated by one
            // thread and handed to another can be tracked without causing
            // unnecessary trace messages.
            //
            TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( THREAD_OPTIMIZATIONS )
            {
                //
                // Disable thread library calls so that we don't get called
                // on thread attach and detach.
                //
                BOOL fResult = DisableThreadLibraryCalls( g_hInstance );
                if ( ! fResult )
                {
                    TW32MSG( GetLastError(), "DisableThreadLibraryCalls()" );
                }
            }
#endif // THREAD_OPTIMIZATIONS

#if defined( USE_FUSION )
            {
                //
                // Initialize Fusion.
                //
                // The value of IDR_MANIFEST in the call to
                // SHFusionInitializeFromModuleID() must match the value specified in the
                // sources file for SXS_MANIFEST_RESOURCE_ID.
                //
                BOOL fResult = SHFusionInitializeFromModuleID( hInstIn, IDR_MANIFEST );
                if ( ! fResult )
                {
                    TW32MSG( GetLastError(), "SHFusionInitializeFromModuleID()" );
                }
            }
#endif // USE_FUSION

#if defined( DO_MODULE_INIT )
            THR( HrLocalProcessInit() );
#endif

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_PROCESS_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_DETACH:
        {
            TraceFunc( "" );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"
                , GetCurrentThreadId()
                , g_cLock
                , g_cObjects
                );

#if defined( DO_MODULE_UNINIT )
            THR( HrLocalProcessUninit() );
#endif

            //
            // Cleanup the global memory list used to track memory allocated
            // in one thread and then handed to another.
            //
            TraceTerminateMemoryList( g_GlobalMemoryList );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceTerminateProcess( g_rgTraceControlGuidList, RTL_NUMBER_OF( g_rgTraceControlGuidList ) );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceTerminateProcess();
#endif // DEBUG_SW_TRACING_ENABLED

#if defined( USE_FUSION )
            SHFusionUninitialize();
#endif // USE_FUSION

            break;
        } // case: DLL_PROCESS_DETACH

#if ! defined( THREAD_OPTIMIZATIONS )
        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"Thread %#x has started."
                , GetCurrentThreadId()
                );
            TraceFunc( "" );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"
                , GetCurrentThreadId()
                , g_cLock
                , g_cObjects
                );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_THREAD_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_DETACH:
        {
            TraceFunc( "" );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"
                , GetCurrentThreadId()
                , g_cLock
                , g_cObjects
                );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            TraceThreadRundown();

            break;
        } // case: DLL_THREAD_DETACH
#endif // ! THREAD_OPTIMIZATIONS

        default:
        {
            TraceFunc( "" );
            TraceMessage(
                  TEXT(__FILE__)
                , __LINE__
                , __MODULE__
                , mtfDLL
                , L"DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"
                , GetCurrentThreadId()
                , g_cLock
                , g_cObjects
                );

#if defined( THREAD_OPTIMIZATIONS )
            Assert( ( ulReasonIn != DLL_THREAD_ATTACH )
                &&  ( ulReasonIn != DLL_THREAD_DETACH ) );
#endif // THREAD_OPTIMIZATIONS

            //
            // This is necessary here because TraceFunc defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after TraceFunc.
            //
            FRETURN( TRUE );

            break;
        } // default case
    } // switch on reason code

    return TRUE;

} //*** DllMain
#endif // ! defined( NO_DLL_MAIN ) && ! defined( ENTRY_PREFIX ) && ! defined( DEBUG )

#ifdef IMPLEMENT_COM_SERVER_DLL
//
// The following functions are only required by COM server DLLs.
//

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllGetClassObject
//
//  Description:
//      OLE calls this to get the class factory from the DLL.
//
//  Arguments:
//      rclsidIn
//          - Class ID of the object that the class factory should create.
//      riidIn
//          - Interface of the class factory
//      ppvOut
//          - The interface pointer to the class factory.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_POINTER       - Required output parameter was specified as NULL.
//      CLASS_E_CLASSNOTAVAILABLE
//                      - Class ID not supported by this DLL.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    void **     ppvOut
    )
{
    TraceFunc( "rclsidIn, riidIn, ppvOut" );

    CFactory *                  pClassFactory = NULL;
    HRESULT                     hr = CLASS_E_CLASSNOTAVAILABLE;
    const SPublicClassInfo *    pClassInfo = g_DllPublicClasses;

    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if: bad argument

    *ppvOut = NULL;

    //
    // Search the public class table for a matching CLSID.
    //
    while ( pClassInfo->pClassID != NULL )
    {
        if ( *( pClassInfo->pClassID ) == rclsidIn )
        {
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"rclsidIn = %s", pClassInfo->pcszName );
            hr = S_OK;
            break;

        } // if: class found
        ++pClassInfo;
    } // while: finding class

    // Didn't find the class ID.
    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        TraceMsgGUID( mtfFUNC, "rclsidIn = ", rclsidIn );
#if defined( ENTRY_PREFIX )
        //
        //  See if the MIDL generated code can create it.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllGetClassObject )( rclsidIn, riidIn, ppvOut ) );
#endif // defined( ENTRY_PREFIX )
        goto Cleanup;
    } // if: class not found

    Assert( pClassInfo->pfnCreateInstance != NULL );

    hr = THR( CFactory::S_HrCreateInstance( pClassInfo->pfnCreateInstance, &pClassFactory ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;

    } // if: initialization failed

    // Can't safe type.
    hr = pClassFactory->QueryInterface( riidIn, ppvOut );

Cleanup:

    if ( pClassFactory != NULL )
    {
        pClassFactory->Release();
    }

    HRETURN( hr );

} //*** DllGetClassObject


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Description:
//      OLE's register entry point.
//
//  Argument:
//      None.
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllRegisterServer( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( HrRegisterDll() );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllRegisterServer )() );
    } // if: register proxy/stub
#endif // defined( ENTRY_PREFIX )

    HRETURN( hr );

} //*** DllRegisterServer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterServer
//
//  Description:
//      OLE's unregister entry point.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Operation completed successful.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllUnregisterServer( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( HrUnregisterDll() );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllUnregisterServer )() );
    } // if: unregister proxy/stub
#endif // defined( ENTRY_PREFIX )

    if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        hr = S_OK;
    }
    
    HRETURN( hr );

} //*** DllUnregisterServer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllCanUnloadNow
//
//  Description:
//      OLE calls this entry point to see if it can unload the DLL.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Can unload the DLL.
//      S_FALSE - Can not unload the DLL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllCanUnloadNow( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( ( g_cLock != 0 ) || ( g_cObjects != 0 ) )
    {
        TraceMsg( mtfDLL, "DLL: Can't unload - g_cLock=%u, g_cObjects=%u", g_cLock, g_cObjects );
        hr = S_FALSE;

    } // if: any object or locks
#if defined( ENTRY_PREFIX )
    else
    {
        //
        //  Check with the MIDL generated proxy/stubs.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllCanUnloadNow )() );
    }
#endif

    HRETURN( hr );

} //*** DllCanUnloadNow

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCoCreateInternalInstance
//
//  Description:
//      Mimic CoCreateInstance() except that it looks into the DLL table
//      to see if we can shortcut the CoCreate with a simple CreateInstance
//      call.
//
//  Arguments: (matches CoCreateInstance)
//      rclsidIn        -   Class identifier (CLSID) of the object
//      pUnkOuterIn     -   Pointer to controlling IUnknown
//      dwClsContext    -   Context for running executable code
//      riidIn          -   Reference to the identifier of the interface
//      ppvOut          -   Address of output variable that receives
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Out of memory.
//      other HRESULT values
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCoCreateInternalInstance(
    REFCLSID    rclsidIn,
    LPUNKNOWN   pUnkOuterIn,
    DWORD       dwClsContextIn,
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceFunc( "" );

    Assert( ppvOut != NULL );

    HRESULT     hr = S_OK;
    MULTI_QI    mqi;

    mqi.hr = S_OK;
    mqi.pItf = NULL;
    mqi.pIID = &riidIn;

    hr = HrCoCreateInternalInstanceEx( rclsidIn, pUnkOuterIn, dwClsContextIn, NULL, 1, &mqi );
    *ppvOut = mqi.pItf;
    
    HRETURN( hr );

} //*** HrCoCreateInternalInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCoCreateInternalInstanceEx
//
//  Description:
//      Mimic CoCreateInstanceEx() except that it looks into the DLL table
//      to see if we can shortcut the CoCreate with a simple CreateInstance
//      call.
//
//  Arguments: (matches CoCreateInstanceEx)
//      rclsidIn        -   Class identifier (CLSID) of the object
//      pUnkOuterIn     -   Pointer to controlling IUnknown
//      dwClsContext    -   Context for running executable code
//      pServerInfoIn   -   Object location; can be NULL
//      cMultiQIsIn     -   Number of MULTI_QI structs in prgmqiInOut array
//      prgmqiInOut     -   Array to hold queried interfaces on object
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_NOINTERFACE
//          Object created, but supports no requested interfaces.
//
//      CO_S_NOTALLINTERFACES
//          Object created and supports some, but not all, requested
//          interfaces.
//
//      CLASS_E_CLASSNOTAVAILABLE
//          Unknown class ID.
//
//      Other HRESULTs.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCoCreateInternalInstanceEx(
    REFCLSID        rclsidIn,
    LPUNKNOWN       pUnkOuterIn,
    DWORD           dwClsContextIn,
    COSERVERINFO *  pServerInfoIn,
    ULONG           cMultiQIsIn,
    MULTI_QI *      prgmqiInOut
    )
{
    TraceFunc( "" );

    Assert( ( prgmqiInOut != NULL ) || ( cMultiQIsIn == 0 ) );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    //
    // Limit simple CoCreate() only works to INPROC and non-aggregatable objects.
    //

    if (    ( dwClsContextIn & ( CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER ) )  // inproc only
        &&  ( pServerInfoIn == NULL )                  // local machine only
        &&  ( pUnkOuterIn == NULL )                     // no aggregation
       )
    {
        PFN_FACTORY_METHOD        pfnCreateInstance = NULL;
        const SPrivateClassInfo * pPrivateInfo = g_PrivateClasses;
        const SPublicClassInfo *  pPublicInfo = g_DllPublicClasses;
        
        //
        // Look up the class ID in the private class table first.
        //
        while ( ( pfnCreateInstance == NULL ) && ( pPrivateInfo->pClassID != NULL ) )
        {
            if ( *( pPrivateInfo->pClassID ) == rclsidIn )
            {
                pfnCreateInstance = pPrivateInfo->pfnCreateInstance;
            }
            ++pPrivateInfo;
        }
        
        //
        // If that didn't find it, try the public table.
        //
        while ( ( pfnCreateInstance == NULL ) && ( pPublicInfo->pClassID != NULL ) )
        {
            if ( *( pPublicInfo->pClassID ) == rclsidIn )
            {
                pfnCreateInstance = pPublicInfo->pfnCreateInstance;
            }
            ++pPublicInfo;
        }

        //
        //  If either found a match, use its factory method to create an object.
        //
        if ( pfnCreateInstance != NULL )
        {
            IUnknown *  punkInstance = NULL;
            ULONG       idxInterface = 0;
            BOOL        fQISucceeded = FALSE;
            BOOL        fQIFailed = FALSE;

            hr = THR( ( *pfnCreateInstance )( &punkInstance ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            
            //
            //  Query for each requested interface.
            //

            while ( idxInterface < cMultiQIsIn )
            {
                MULTI_QI * pmqi = prgmqiInOut + idxInterface;

                //
                //  No THR around the following QI because client might expect some failures.
                //
                pmqi->hr = punkInstance->QueryInterface( *( pmqi->pIID ), reinterpret_cast< void** >( &( pmqi->pItf ) ) );
                if ( SUCCEEDED( pmqi->hr ) )
                {
                    fQISucceeded = TRUE;
                }
                else
                {
                    fQIFailed = TRUE;
                }
                idxInterface += 1;
            } // for each requested interface

            //
            //  Mimic return values from CoCreateInstanceEx.
            //
            if ( fQIFailed )
            {
                if ( fQISucceeded )
                {
                    //  At least one QI succeeded, and at least one failed.
                    hr = CO_S_NOTALLINTERFACES;
                }
                else
                {
                    //  At least one QI failed, and none succeeded.
                    hr = E_NOINTERFACE;
                }
            }
            // Otherwise, leave hr as is.

            punkInstance->Release();
        } // if: creating internal class
    } // if: simple CoCreate()


    //
    // If not found or asking for something we do not support,
    // use the COM version.
    //

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        //
        // Try it the old fashion way...
        //
        hr = STHR( CoCreateInstanceEx( rclsidIn, pUnkOuterIn, dwClsContextIn, pServerInfoIn, cMultiQIsIn, prgmqiInOut ) );

    } // if: class not found

Cleanup:

    HRETURN( hr );

} //*** HrCoCreateInternalInstanceEx


//
// TODO:    gpease 27-NOV-1999
//          While perusing around the MIDL SDK, I foud that
//          RPC creates the same type of class table we do. Maybe
//          we can leverage the MIDL code to create our objects(??).
//

#endif // IMPLEMENT_COM_SERVER_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\log.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Log.h
//
//  Description:
//      Log file functions.
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
//  Log entry types for displaying text at the beginning of each line.
//
#define LOGTYPE_NONE    ( (DWORD) -1 )
#define LOGTYPE_DEBUG   ( (DWORD) -2 )
#define LOGTYPE_INFO    ( (DWORD) -3 )
#define LOGTYPE_WARNING ( (DWORD) -4 )
#define LOGTYPE_ERROR   ( (DWORD) -5 )

HRESULT
HrLogOpen( void );

HRESULT
HrLogClose( void );

HRESULT
HrLogRelease( void );

HRESULT
HrGetLogFilePath(
      const WCHAR * pszPathIn
    , WCHAR *       pszFilePathOut
    , size_t *      pcchFilePathInout
    , HINSTANCE     hInstanceIn
    );

LPCWSTR
PszLogFilePath( void );

void
__cdecl
LogMsg(
      DWORD     nLogEntryTypeIn
    , LPCSTR    paszFormatIn
    , ...
    );

void
__cdecl
LogMsg(
      DWORD     nLogEntryTypeIn
    , LPCWSTR   pszFormatIn
    , ...
    );

void
__cdecl
LogMsg(
    LPCSTR  paszFormatIn,
    ...
    );

void
__cdecl
LogMsg(
    LPCWSTR pszFormatIn,
    ...
    );

void
__cdecl
LogMsgNoNewline(
      DWORD     nLogEntryTypeIn
    , LPCSTR    paszFormatIn
    , ...
    );

void
__cdecl
LogMsgNoNewline(
      DWORD     nLogEntryTypeIn
    , LPCWSTR   pszFormatIn
    , ...
    );

void
__cdecl
LogMsgNoNewline(
    LPCSTR  paszFormatIn,
    ...
    );

void
__cdecl
LogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    );

void
LogStatusReport(
      SYSTEMTIME *  pstTimeIn
    , const WCHAR * pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , const WCHAR * pcszDescriptionIn
    , const WCHAR * pcszUrlIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\sources.inc ===
!INCLUDE $(PROJECT_ROOT)\cluster\sources.inc

C_DEFINES=$(C_DEFINES) -DSTRSAFE_LIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\logsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      LogSrc.cpp
//
//  Description:
//      Logging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//  Note:
//      THRs and TW32s should NOT be used in this module because they
//      could cause an infinite loop.
//
//////////////////////////////////////////////////////////////////////////////

// #include <Pch.h>     // should be included by includer of this file
#include <stdio.h>
#include <StrSafe.h>    // in case it isn't included by header file
#include <windns.h>
#include "Common.h"

//****************************************************************************
//****************************************************************************
//
//  Logging Functions
//
//  These are in both DEBUG and RETAIL.
//
//****************************************************************************
//****************************************************************************

//
// Constants
//
static const int LOG_OUTPUT_BUFFER_SIZE = 1024;
static const int TIMESTAMP_BUFFER_SIZE = 25;

//
// Globals
//
static CRITICAL_SECTION * g_pcsLogging = NULL;

static HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
static WCHAR  g_szLogFilePath[ MAX_PATH ];

//////////////////////////////////////////////////////////////////////////////
//++
//
//  PszLogFilePath
//
//  Description:
//      Returns the log file path that is currently used by the wizard.
//
//  Arguments:
//      None.
//
//  Return Values:
//      LPCWSTR             - The log file path that is currently used by the wizard
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
PszLogFilePath( void )
{
    return g_szLogFilePath;

} //*** PszLogFilePath

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetLogFilePath
//
//  Description:
//      Takes in a directory path and appends module log file name to it and
//      returns the full log file path.
//
//  Arguments:
//      pszPathIn           - The directory where the log file will be created.
//      pszFilePathOut      - Log file path.
//      pcchFilePathInout   - Size of the log file path buffer.
//
//  Return Values:
//      S_OK                - Success
//      ERROR_MORE_DATA     - If the output buffer is too small.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetLogFilePath(
      const WCHAR * pszPathIn
    , WCHAR *       pszFilePathOut
    , size_t *      pcchFilePathInout
    , HINSTANCE     hInstanceIn
    )
{
    HRESULT hr = S_OK;
    WCHAR   szModulePath[ MAX_PATH ];
    DWORD   dwLen;
    LPWSTR  psz;

    //
    // Create the directory tree.
    //
    dwLen = ExpandEnvironmentStringsW( pszPathIn, pszFilePathOut, static_cast< DWORD >( *pcchFilePathInout ) );
    if ( dwLen > *pcchFilePathInout )
    {
        hr = HRESULT_FROM_WIN32( ERROR_MORE_DATA );
        *pcchFilePathInout = dwLen;
        goto Cleanup;
    }

    hr = HrCreateDirectoryPath( pszFilePathOut );
    if ( FAILED( hr ) )
    {
#if defined( DEBUG )
        if ( !( g_tfModule & mtfOUTPUTTODISK ) )
        {
            DebugMsg( "*ERROR* Failed to create directory tree %s", pszFilePathOut );
        } // if: not logging to disk
#endif
        goto Cleanup;
    } // if: failed

    //
    // Add filename.
    //
    dwLen = GetModuleFileNameW( hInstanceIn, szModulePath, ARRAYSIZE( szModulePath ) );
    Assert( dwLen != 0 );

    // Replace extension.
    psz = wcsrchr( szModulePath, L'.' );
    Assert( psz != NULL );
    if ( psz == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    THR( StringCchCopyW( psz, ( psz - szModulePath ) / sizeof( *psz ), L".log" ) );

    // Copy resulting filename to output buffer.
    psz = wcsrchr( szModulePath, L'\\' );
    Assert( psz != NULL );
    if ( psz == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    THR( StringCchCatW( pszFilePathOut, *pcchFilePathInout, psz ) );

Cleanup:

    return hr;

} //*** HrGetLogFilePath

//////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatTimeStamp
//
//  Description:
//      Format a string from the given time stamp.
//
//  Arguments:
//      pTimeStampIn
//          The time stamp to format.
//
//      pszTextOut
//          A pointer to a buffer that receives the text.  The caller must
//          provide this buffer--the argument may not be null.
//
//      cchTextIn
//          The size of pszTextOut in characters.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
inline
void
FormatTimeStamp(
      const SYSTEMTIME *    pTimeStampIn
    , LPWSTR                pszTextOut
    , size_t                cchTextIn
    )
{
    Assert( pTimeStampIn != NULL );
    Assert( pszTextOut != NULL );

    THR( StringCchPrintfW(
                      pszTextOut
                    , cchTextIn
                    , L"%04u-%02u-%02u %02u:%02u:%02u.%03u"
                    , pTimeStampIn->wYear
                    , pTimeStampIn->wMonth
                    , pTimeStampIn->wDay
                    , pTimeStampIn->wHour
                    , pTimeStampIn->wMinute
                    , pTimeStampIn->wSecond
                    , pTimeStampIn->wMilliseconds
                    ) );

} //*** FormatTimeStamp

//////////////////////////////////////////////////////////////////////////////
//++
//
//  WideCharToUTF8
//
//  Description:
//      Convert a wide character string to a UTF-8 encoded narrow string.
//
//  Arguments:
//      pwszSourceIn    - The string to convert.
//      cchDestIn       - The maximum number of characters the destination can hold.
//      paszDestOut     - The destination for the converted string.
//
//  Return Values:
//      The number of characters in the converted string.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
inline
size_t
WideCharToUTF8(
      LPCWSTR   pwszSourceIn
    , size_t    cchDestIn
    , LPSTR     paszDestOut
    )
{
    Assert( pwszSourceIn != NULL );
    Assert( paszDestOut != NULL );

    size_t cchUTF8 = 0;

    cchUTF8 = WideCharToMultiByte(
                      CP_UTF8
                    , 0 // flags, must be zero for utf8
                    , pwszSourceIn
                    , -1 // calculate length automatically
                    , paszDestOut
                    , static_cast< int >( cchDestIn )
                    , NULL // default character, must be null for utf8
                    , NULL // default character used flag, must be null for utf8
                    );
    return cchUTF8;

} //*** WideCharToUTF8


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrInitializeLogLock
//
//  Description:
//      Create the spin lock that protects the log file from concurrent writes.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrInitializeLogLock( void )
{
    HRESULT hr = S_OK;

    PCRITICAL_SECTION pNewCritSect =
        (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
    if ( pNewCritSect == NULL )
    {
        DebugMsg( "DEBUG: Out of Memory. Logging disabled." );
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if: creation failed

    if ( InitializeCriticalSectionAndSpinCount( pNewCritSect, 4000 ) == 0 ) // MSDN recommends 4000.
    {
        DWORD scError = GetLastError();
        hr = HRESULT_FROM_WIN32( scError );
        goto Cleanup;
    }

    // Make sure we only have one log critical section
    InterlockedCompareExchangePointer( (PVOID *) &g_pcsLogging, pNewCritSect, 0 );
    if ( g_pcsLogging != pNewCritSect )
    {
        DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one." );
        DeleteCriticalSection( pNewCritSect );
    } // if: already have another critical section
    else
    {
        pNewCritSect = NULL;
    }

Cleanup:

    if ( pNewCritSect != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pNewCritSect );
    }

    return hr;

} //*** HrInitializeLogLock


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScGetTokenInformation
//
//  Description:
//      Get the requested information from the passed in client token.
//
//  Arguments:
//      hClientTokenIn
//          The client token to dump.
//
//      ticRequestIn
//
//      ppbOut
//
//  Return Value:
//      ERROR_SUCCESS for success.
//
//      Other error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScGetTokenInformation(
      HANDLE                    hClientTokenIn
    , TOKEN_INFORMATION_CLASS   ticRequestIn
    , PBYTE *                   ppbOut
    )
{
    Assert( ppbOut != NULL );

    PBYTE   pb = NULL;
    DWORD   cb = 64;
    DWORD   sc = ERROR_SUCCESS;
    int     idx;

    //
    // Get the user information from the client token.
    //

    for ( idx = 0; idx < 10; idx++ )
    {
        pb = (PBYTE) TraceAlloc( 0, cb );
        if ( pb == NULL )
        {
            sc = TW32( ERROR_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        if ( !GetTokenInformation( hClientTokenIn, ticRequestIn, pb, cb, &cb ) )
        {
            sc = GetLastError();

            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pb );
                pb = NULL;

                 continue;
            } // if:

            TW32( sc );
            goto Cleanup;
        } // if:
        else
        {
            *ppbOut = pb;
            pb = NULL;       // give away ownership

            sc = ERROR_SUCCESS;

            break;
        } // else:
    } // for:

    //
    //  The loop should not exit because of idx == 10!
    //

    Assert( idx <= 9 );

Cleanup:

    TraceFree( pb );

    return sc;

}  // *** ScGetTokenInformation


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScGetDomainAndUserName
//
//  Description:
//      Get the domain user name for the logged on user.
//
//  Arguments:
//      pwszDomainAndUserNameOut
//          This string should be at least DNS_MAX_NAME_BUFFER_LENGTH + 128 characters long.
//
//      cchDomainAndUserNameIn
//
//  Return Value:
//      ERROR_SUCCESS for success.
//
//      Other error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScGetDomainAndUserName(
      LPWSTR   pwszDomainAndUserNameOut
    , size_t  cchDomainAndUserNameIn
    )
{
    WCHAR *         pwszUserName = pwszDomainAndUserNameOut + DNS_MAX_NAME_BUFFER_LENGTH;
    WCHAR *         pwszDomainName = pwszDomainAndUserNameOut;
    DWORD           cchUser = 128;
    DWORD           cchDomain = DNS_MAX_NAME_BUFFER_LENGTH;
    HANDLE          hClientToken = NULL;
    DWORD           sc = ERROR_SUCCESS;
    TOKEN_USER *    pTokenBuf = NULL;
    WCHAR *         pwszOperation;
    SID_NAME_USE    snuSidType;

    if (cchDomainAndUserNameIn < cchUser + cchDomain)
    {
        pwszOperation = L"BufferTooSmall";
        sc = TW32(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    pwszOperation = L"OpenThreadToken";
    if ( !OpenThreadToken( GetCurrentThread(), TOKEN_READ, FALSE, &hClientToken ) )
    {
        sc= GetLastError();
        if ( sc == ERROR_NO_TOKEN )
        {
            pwszOperation = L"OpenProcessToken";
            if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hClientToken ) )
            {
                sc = TW32( GetLastError() );
                goto Cleanup;
            } // if: OpenProcessToken failed
        } // if: OpenThreadToken failed with ERROR_NO_TOKEN
        else
        {
            TW32( sc );
            goto Cleanup;
        } // else:
    } // if: OpenThreadToken failed

    pwszOperation = L"GetTokenInformation";
    sc = TW32( ScGetTokenInformation( hClientToken, TokenUser, (PBYTE *) &pTokenBuf ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: failed to get token information

    pwszOperation = L"LookupAccoundSid";
    if ( !LookupAccountSidW( NULL, pTokenBuf->User.Sid, pwszUserName, &cchUser, pwszDomainName, &cchDomain, &snuSidType ) )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    } // if: failed to lookup accound name

    pwszDomainName[ cchDomain ] = L'\\';
    MoveMemory( pwszDomainAndUserNameOut + cchDomain + 1, pwszUserName, ( cchUser + 1 ) * sizeof ( pwszUserName[0] ) );

Cleanup:

    if ( hClientToken != NULL )
    {
        CloseHandle( hClientToken );
    } // if: needed to close hClientToken

    TraceFree( pTokenBuf );

    if ( sc != ERROR_SUCCESS )
    {
        HRESULT hr;

        hr = THR( StringCchPrintfW( pwszDomainAndUserNameOut, cchDomainAndUserNameIn,  L"%ws failed with error %d", pwszOperation, sc ) );
        if ( FAILED( hr ) )
        {
            ; // the secondary error is not really interesting!
        } // if:
    } // else: report failure

    return sc;

}  //*** ScGetDomainAndUserName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrInitializeLogFile
//
//  Description:
//      Open the log file and prepare it for writing.
//
//  Arguments:
//      None.
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrInitializeLogFile( void )
{
    WCHAR       szFilePath[ MAX_PATH ];
    size_t      cchPath = MAX_PATH - 1;
    CHAR        aszBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR       wszBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR       wszDomainAndUserName[ DNS_MAX_NAME_BUFFER_LENGTH + 128 ];
    DWORD       cbWritten = 0;
    DWORD       cbBytesToWrite = 0;
    BOOL        fReturn;
    HRESULT     hr = S_OK;
    DWORD       sc = ERROR_SUCCESS;
    size_t      cch;
    SYSTEMTIME  SystemTime;

    hr = HrGetLogFilePath( L"%windir%\\system32\\LogFiles\\Cluster", szFilePath, &cchPath, g_hInstance );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Create it
    //
    g_hLogFile = CreateFile(
                          szFilePath
                        , GENERIC_WRITE
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , NULL
                        , OPEN_ALWAYS
                        , FILE_FLAG_WRITE_THROUGH
                        , NULL
                        );

    if ( g_hLogFile == INVALID_HANDLE_VALUE )
    {
#if defined( DEBUG )
        if ( !( g_tfModule & mtfOUTPUTTODISK ) )
        {
            DebugMsg( "*ERROR* Failed to create log at %s", szFilePath );
        } // if: not logging to disk
#endif
        sc = GetLastError();
        hr = HRESULT_FROM_WIN32( sc );

        //
        // If we can not create the log file, try creating it under the alternate %TEMP% directory.
        //
        if ( ( sc == ERROR_ACCESS_DENIED ) || ( sc == ERROR_FILE_NOT_FOUND ) )
        {
            cch = ARRAYSIZE( szFilePath );
            hr = HrGetLogFilePath( TEXT("%TEMP%"), szFilePath, &cch, g_hInstance );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            // Create it
            //
            g_hLogFile = CreateFile(
                                  szFilePath
                                , GENERIC_WRITE
                                , FILE_SHARE_READ | FILE_SHARE_WRITE
                                , NULL
                                , OPEN_ALWAYS
                                , FILE_FLAG_WRITE_THROUGH
                                , NULL
                                );

            if ( g_hLogFile == INVALID_HANDLE_VALUE )
            {
#if defined( DEBUG )
                if ( !( g_tfModule & mtfOUTPUTTODISK ) )
                {
                    DebugMsg( "*ERROR* Failed to create log at %s", szFilePath );
                } // if: not logging to disk
#endif
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Error;
            } // if: ( g_hLogFile == INVALID_HANDLE_VALUE )
        } // if: ( ( sc == ERROR_ACCESS_DENIED ) || ( sc == ERROR_FILE_NOT_FOUND ) )
        else
        {
            goto Error;
        } // else:
    } // if: ( g_hLogFile == INVALID_HANDLE_VALUE )

    //
    // Copy which log file path we are using to g_szLogFilePath.
    //
    THR( StringCchCopyW( g_szLogFilePath, ARRAYSIZE( g_szLogFilePath ), szFilePath ) );

    //  If the file is empty, begin with UTF-8 byte-order mark.
    {
        LARGE_INTEGER liFileSize = { 0, 0 };
#if defined( DEBUG_SUPPORT_NT4 )
        liFileSize.LowPart = GetFileSize( g_hLogFile, (LPDWORD) &liFileSize.HighPart );
        if ( liFileSize.LowPart == INVALID_FILE_SIZE )
#else
        fReturn = GetFileSizeEx( g_hLogFile, &liFileSize );
        if ( fReturn == FALSE )
#endif
        {
            DWORD scError = GetLastError();
            hr = HRESULT_FROM_WIN32( scError );
            goto Error;
        } // if: GetFileSizeEx failed

        if ( liFileSize.QuadPart == 0 )
        {
            const char *    aszUTF8ByteOrderMark = "\x0EF\x0BB\x0BF";
            const size_t    cchByteOrderMark = 3;

            cbBytesToWrite = cchByteOrderMark * sizeof( aszUTF8ByteOrderMark[ 0 ] );
            fReturn = WriteFile( g_hLogFile, aszUTF8ByteOrderMark, cbBytesToWrite, &cbWritten, NULL );
            if ( fReturn == FALSE )
            {
                DWORD scError = GetLastError();
                hr = HRESULT_FROM_WIN32( scError );
                goto Error;
            } // if: WriteFile failed
            Assert( cbWritten == cbBytesToWrite );
        } // if starting log file
        else
        {
            // Seek to the end
            SetFilePointer( g_hLogFile, 0, NULL, FILE_END );
        }
    } // put utf-8 mark at beginning of file

    //
    //  When an error occurs a formatted error string is placed in wszDomainAndUserName.
    //

    TW32( ScGetDomainAndUserName( wszDomainAndUserName, RTL_NUMBER_OF( wszDomainAndUserName ) ) );

    //
    // Write the time/date the log was (re)openned.
    //

    GetLocalTime( &SystemTime );
    THR( StringCchPrintfW(
              wszBuffer
            , ARRAYSIZE( wszBuffer )
            , L"*\r\n* %04u-%02u-%02u %02u:%02u:%02u.%03u (%ws)\r\n*\r\n"
            , SystemTime.wYear
            , SystemTime.wMonth
            , SystemTime.wDay
            , SystemTime.wHour
            , SystemTime.wMinute
            , SystemTime.wSecond
            , SystemTime.wMilliseconds
            , wszDomainAndUserName
            ) );

    WideCharToUTF8( wszBuffer, ARRAYSIZE( aszBuffer), aszBuffer );
    cbBytesToWrite = static_cast< DWORD >( strlen( aszBuffer ) * sizeof( aszBuffer[ 0 ] ) );
    
    fReturn = WriteFile( g_hLogFile, aszBuffer, cbBytesToWrite, &cbWritten, NULL );
    if ( ! fReturn )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Error;
    } // if: failed
    Assert( cbWritten == cbBytesToWrite );

    DebugMsg( "DEBUG: Created log at %s", szFilePath );

Cleanup:

    return hr;

Error:

    DebugMsg( "HrInitializeLogFile: Failed hr = 0x%08x", hr );

    if ( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    goto Cleanup;

} //*** HrInitializeLogFile


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLogOpen
//
//  Description:
//      This function:
//          - initializes the log critical section
//          - enters the log critical section assuring only one thread is
//            writing to the log at a time
//          - creates the directory tree to the log file (if needed)
//          - initializes the log file by:
//              - creating a new log file if one doesn't exist.
//              - opens an existing log file (for append)
//              - appends a time/date stamp that the log was (re)opened.
//
//      Use LogClose() to exit the log critical section.
//
//      If there is a failure inside this function, the log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - log critical section held and log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
HRESULT
HrLogOpen( void )
{
    HRESULT hr = S_OK;

    //  If lock has not been initialized, initialize it.
    if ( g_pcsLogging == NULL )
    {
        hr = HrInitializeLogLock();
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //  Grab lock.
    Assert( g_pcsLogging != NULL );
    EnterCriticalSection( g_pcsLogging );

    //  If file has not been initialized, initialize it.
    if ( g_hLogFile == INVALID_HANDLE_VALUE )
    {
        hr = HrInitializeLogFile();
    }

Cleanup:

    return hr;

} //*** HrLogOpen


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLogRelease
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
HRESULT
HrLogRelease( void )
{
    if ( g_pcsLogging != NULL )
    {
        LeaveCriticalSection( g_pcsLogging );
    }
    return S_OK;

} //*** HrLogRelease

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LogFormattedText
//
//  Description:
//      Convert a wide string to UTF-8 and write it to the log file.
//
//  Arguments:
//      fTimeStampIn
//      fNewlineIn
//      nLogEntryTypeIn
//      pwszTextIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
void
LogFormattedText(
      BOOL      fTimeStampIn
    , BOOL      fNewlineIn
    , DWORD     nLogEntryTypeIn
    , LPCWSTR   pwszTextIn
    )
{
    char    aszTimeStamp[ TIMESTAMP_BUFFER_SIZE ];
    char    aszLogText[ LOG_OUTPUT_BUFFER_SIZE ];
    char *  paszLogEntryType;
    size_t  cchTimeStamp = 0;
    size_t  cchLogText = 0;
    DWORD   cbWritten;
    DWORD   cbToWrite;
    HRESULT hr = S_OK;
    BOOL    fSuccess;

    Assert( pwszTextIn != NULL );

    //  Format time stamp (and convert to UTF-8) if requested.
    if ( fTimeStampIn )
    {
        WCHAR           szCurrentTime[ TIMESTAMP_BUFFER_SIZE ];
        SYSTEMTIME      stCurrentTime;
        GetLocalTime( &stCurrentTime );
        FormatTimeStamp( &stCurrentTime, szCurrentTime, ARRAYSIZE( szCurrentTime ) );
        cchTimeStamp = WideCharToUTF8( szCurrentTime, ARRAYSIZE( aszTimeStamp ), aszTimeStamp );
    } // if: time stamp requested

    //  Convert formatted text to UTF-8.
    cchLogText = WideCharToUTF8( pwszTextIn, ARRAYSIZE( aszLogText ), aszLogText );

    //  Grab file.
    hr = THR( HrLogOpen() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Write time stamp to log if requested.
    if ( fTimeStampIn )
    {
        cbToWrite = static_cast< DWORD >( cchTimeStamp * sizeof( aszTimeStamp[ 0 ] ) );
        fSuccess = WriteFile( g_hLogFile, aszTimeStamp, cbToWrite, &cbWritten, NULL );
        if ( fSuccess == FALSE )
        {
            TW32( GetLastError() );
        }
        else
        {
            Assert( cbWritten == cbToWrite );
        }
    } // if: timestamp requested

    //  Write the log entry type.
    if ( nLogEntryTypeIn != LOGTYPE_NONE )
    {
        if ( nLogEntryTypeIn == LOGTYPE_DEBUG )
        {
            paszLogEntryType = "[DBG ] ";
        }
        else if ( ( nLogEntryTypeIn == LOGTYPE_INFO ) || ( nLogEntryTypeIn == S_OK ) )
        {
            paszLogEntryType = "[INFO] ";
        }
        else if ( ( nLogEntryTypeIn == LOGTYPE_WARNING ) )
        {
            paszLogEntryType = "[WARN] ";
        }
        else if ( ( nLogEntryTypeIn == LOGTYPE_ERROR ) || FAILED( nLogEntryTypeIn ) )
        {
            paszLogEntryType = "[ERR ] ";
        }
        else
        {
            // Can't do the other warning test here because LOGTYPE_WARNING would
            // cause the FAILED() macro to return TRUE, and therefore the code
            // would be treated as an error type.
            paszLogEntryType = "[WARN] ";
        }

        cbToWrite = static_cast< DWORD >( strlen( paszLogEntryType ) );
        fSuccess = WriteFile( g_hLogFile, paszLogEntryType, cbToWrite, &cbWritten, NULL );
        if ( fSuccess == FALSE )
        {
            TW32( GetLastError() );
        }
        else
        {
            Assert( cbWritten == cbToWrite );
        }
    } // if: log entry type requested

    //  Write UTF-8 to log.
    cbToWrite = static_cast< DWORD >( cchLogText );
    fSuccess = WriteFile( g_hLogFile, aszLogText, cbToWrite, &cbWritten, NULL );
    if ( fSuccess == FALSE )
    {
        TW32( GetLastError() );
    }
    else
    {
        Assert( cbWritten == cbToWrite );
    }

    //  Write newline to log if requested.
    if ( fNewlineIn )
    {
        cbToWrite = SIZEOF_ASZ_NEWLINE;
        fSuccess = WriteFile( g_hLogFile, ASZ_NEWLINE, cbToWrite, &cbWritten, NULL );
        if ( fSuccess == FALSE )
        {
            TW32( GetLastError() );
        }
        else
        {
            Assert( cbWritten == cbToWrite );
        }
    }

Cleanup:

    //  Release file.
    hr = THR( HrLogRelease() );

    return;

} //*** LogFormattedText



//////////////////////////////////////////////////////////////////////////////
//++
//
//  LogUnformattedText
//
//  Description:
//      Format a string and pass it on to LogFormattedText.
//
//  Arguments:
//      fTimeStampIn
//      fNewlineIn
//      nLogEntryTypeIn
//      pwszFormatIn
//      pvlFormatArgsIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
inline
void
LogUnformattedText(
      BOOL      fTimeStampIn
    , BOOL      fNewlineIn
    , DWORD     nLogEntryTypeIn
    , LPCWSTR   pwszFormatIn
    , va_list * pvlFormatArgsIn
    )
{
    WCHAR wszFormatted[ LOG_OUTPUT_BUFFER_SIZE ];

    Assert( pwszFormatIn != NULL );
    Assert( pvlFormatArgsIn != NULL );

    //  Format string.
    THR( StringCchVPrintfW( wszFormatted, ARRAYSIZE( wszFormatted ), pwszFormatIn, *pvlFormatArgsIn ) );

    //  Pass formatted string through to LogFormattedText.
    LogFormattedText( fTimeStampIn, fNewlineIn, nLogEntryTypeIn, wszFormatted );

} //*** LogUnformattedText


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLogClose
//
//  Description:
//      Close the file.  This function expects the critical section to have
//      already been released.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogClose( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    if ( g_pcsLogging != NULL )
    {
        DeleteCriticalSection( g_pcsLogging );
        HeapFree( GetProcessHeap(), 0, g_pcsLogging );
        g_pcsLogging = NULL;
    } // if:

    if ( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    HRETURN( hr );

} //*** HrLogClose

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  LogMsgNoNewline
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      paszFormatIn    - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
    LPCSTR paszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   wszFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    Assert( paszFormatIn != NULL );

    size_t cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , MB_PRECOMPOSED
                            , paszFormatIn
                            , -1
                            , wszFormat
                            , ARRAYSIZE( wszFormat )
                            );
    if ( cchWideFormat > 0 )
    {
        va_start( valist, paszFormatIn );
        LogUnformattedText( FALSE, FALSE, LOGTYPE_NONE, wszFormat, &valist );
        va_end( valist );
    }

} //*** LogMsgNoNewline ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  LogMsgNoNewline
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      nLogEntryTypeIn - Log entry type.
//      paszFormatIn    - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
      DWORD     nLogEntryTypeIn
    , LPCSTR    paszFormatIn
    , ...
    )
{
    va_list valist;
    WCHAR   wszFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    Assert( paszFormatIn != NULL );

    size_t cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , MB_PRECOMPOSED
                            , paszFormatIn
                            , -1
                            , wszFormat
                            , ARRAYSIZE( wszFormat )
                            );
    if ( cchWideFormat > 0 )
    {
        va_start( valist, paszFormatIn );
        LogUnformattedText( FALSE, FALSE, nLogEntryTypeIn, wszFormat, &valist );
        va_end( valist );
    }

} //*** LogMsgNoNewline ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  LogMsgNoNewline
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      pszFormatIn - A printf format string to be printed.
//      ,,,         - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    LogUnformattedText( FALSE, FALSE, LOGTYPE_NONE, pszFormatIn, &valist );
    va_end( valist );

} //*** LogMsgNoNewline UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  LogMsgNoNewline
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      nLogEntryTypeIn - Log entry type.
//      pszFormatIn     - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
      DWORD     nLogEntryTypeIn
    , LPCWSTR   pszFormatIn
    , ...
    )
{
    va_list valist;

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    LogUnformattedText( FALSE, FALSE, nLogEntryTypeIn, pszFormatIn, &valist );
    va_end( valist );

} //*** LogMsgNoNewline UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  LogMsg
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      paszFormatIn    - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
    LPCSTR paszFormatIn,
    ...
    )
{
    va_list valist;
    WCHAR   wszFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    size_t  cchWideFormat = 0;

    Assert( paszFormatIn != NULL );

    cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , MB_PRECOMPOSED
                            , paszFormatIn
                            , -1
                            , wszFormat
                            , ARRAYSIZE( wszFormat )
                            );
    if ( cchWideFormat > 0 )
    {
        va_start( valist, paszFormatIn );
        LogUnformattedText( TRUE, TRUE, LOGTYPE_INFO, wszFormat, &valist );
        va_end( valist );
    }

} //*** LogMsg ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  LogMsg
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      nLogEntryTypeIn - Log entry type.
//      paszFormatIn    - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
      DWORD     nLogEntryTypeIn
    , LPCSTR    paszFormatIn
    , ...
    )
{
    va_list valist;
    WCHAR   wszFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    size_t  cchWideFormat = 0;

    Assert( paszFormatIn != NULL );

    cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , MB_PRECOMPOSED
                            , paszFormatIn
                            , -1
                            , wszFormat
                            , ARRAYSIZE( wszFormat )
                            );
    if ( cchWideFormat > 0 )
    {
        va_start( valist, paszFormatIn );
        LogUnformattedText( TRUE, TRUE, nLogEntryTypeIn, wszFormat, &valist );
        va_end( valist );
    }

} //*** LogMsg ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  LogMsg
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      pszFormatIn - A printf format string to be printed.
//      ,,,         - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
      LPCWSTR pszFormatIn
    , ...
    )
{
    va_list valist;

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    LogUnformattedText( TRUE, TRUE, LOGTYPE_INFO, pszFormatIn, &valist );
    va_end( valist );

} //*** LogMsg UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  LogMsg
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      nLogEntryTypeIn - Log entry type.
//      pszFormatIn     - A printf format string to be printed.
//      ,,,             - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
      DWORD     nLogENtryTypeIn
    , LPCWSTR   pszFormatIn
    , ...
    )
{
    va_list valist;

    Assert( pszFormatIn != NULL );

    va_start( valist, pszFormatIn );
    LogUnformattedText( TRUE, TRUE, nLogENtryTypeIn, pszFormatIn, &valist );
    va_end( valist );

} //*** LogMsg UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LogStatusReport
//
//  Description:
//      Writes a status report to the log file.
//
//  Arugments:
//      pstTimeIn         -
//      pcszNodeNameIn    -
//      clsidTaskMajorIn  -
//      clsidTaskMinorIn  -
//      ulMinIn           -
//      ulMaxIn           -
//      ulCurrentIn       -
//      hrStatusIn        -
//      pcszDescriptionIn -
//      pcszUrlIn         -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogStatusReport(
    SYSTEMTIME  *   pstTimeIn,
    const WCHAR *   pcszNodeNameIn,
    CLSID           clsidTaskMajorIn,
    CLSID           clsidTaskMinorIn,
    ULONG           ulMinIn,
    ULONG           ulMaxIn,
    ULONG           ulCurrentIn,
    HRESULT         hrStatusIn,
    const WCHAR *   pcszDescriptionIn,
    const WCHAR *   pcszUrlIn
    )
{
    SYSTEMTIME      stCurrent;
    SYSTEMTIME      stReport;
    WCHAR           szCurrent[ TIMESTAMP_BUFFER_SIZE ];
    WCHAR           szReport[ TIMESTAMP_BUFFER_SIZE ];
    const size_t    cchGuid = 40;
    WCHAR           wszMajorGuid[ cchGuid ];
    WCHAR           wszMinorGuid[ cchGuid ];
    WCHAR           wszFormattedReport[ LOG_OUTPUT_BUFFER_SIZE ];

    GetLocalTime( &stCurrent );
    if ( pstTimeIn )
    {
        memcpy( &stReport, pstTimeIn, sizeof( stReport ) );
    }
    else
    {
        memset( &stReport, 0, sizeof( stReport) );
    }

    FormatTimeStamp( &stCurrent, szCurrent, ARRAYSIZE( szCurrent ) );
    FormatTimeStamp( &stReport, szReport, ARRAYSIZE( szReport ) );

    StringFromGUID2( clsidTaskMajorIn, wszMajorGuid, cchGuid );
    StringFromGUID2( clsidTaskMinorIn, wszMinorGuid, cchGuid );

    THR( StringCchPrintfW(
                  wszFormattedReport
                , ARRAYSIZE( wszFormattedReport )
                , L"%ws - %ws  %ws, %ws (%2d / %2d .. %2d ) <%ws> hr=%08X %ws %ws"
                , szCurrent
                , szReport
                , wszMajorGuid
                , wszMinorGuid
                , ulCurrentIn
                , ulMinIn
                , ulMaxIn
                , pcszNodeNameIn
                , hrStatusIn
                , pcszDescriptionIn
                , pcszUrlIn
                ) );

    LogFormattedText( FALSE, TRUE, hrStatusIn, wszFormattedReport );

} //*** LogStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\register.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Register.h
//
//  Description:
//      Registering the COM classes implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#if defined(MMC_SNAPIN_REGISTRATION)
//
//  These tables are for registering the Snap-ins in the MMC Snapin/Node 
//  registration area of the registry.
//
struct SExtensionTable
{
    const CLSID *           rclsid;                     // CLSID of the Snap-in Extension COM Object
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
};

struct SNodeTypesTable
{
    const CLSID *           rclsid;                     // CLSID of the Node Type (this doesn't need to be a COM Object)
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
    const SExtensionTable * pNameSpace;                 // Namespace extension table
    const SExtensionTable * pPropertySheet;             // Property Page extension table
    const SExtensionTable * pContextMenu;               // Context menu extension table
    const SExtensionTable * pToolBar;                   // Toolbar extension table
    const SExtensionTable * pTask;                      // Taskpad extension table
};

struct SSnapInTable
{
    const CLSID *           rclsid;                     // CLSID of the Snap-in COM Object
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
    LPCWSTR                 pszDisplayName;             // TODO: make it internationalizable.
    BOOL                    fStandAlone;                // Marks the Snap-in as StandAlone if TRUE in the registry.
    const SNodeTypesTable * pntt;                       // Node type extension table.
};

extern const SNodeTypesTable g_SNodeTypesTable[ ];
#endif // defined(MMC_SNAPIN_REGISTRATION)

HRESULT
HrRegisterDll( void );

HRESULT
HrUnregisterDll( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\pragmas.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Pragmas.h
//
//  Description:
//      Project level pragmas.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Disable some warnings
//////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4100 ) // unreferenced formal parameter
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4509 ) // nonstandard extension used: 'function' uses SEH and 'object' has destructor

//////////////////////////////////////////////////////////////////////////////
// Enable some warnings
//////////////////////////////////////////////////////////////////////////////

#pragma warning( error : 4706 ) // assignment within conditional expression
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\smartclasses.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SmartClasses.h
//
//  Description:
//      Definitions of "smart" classes used to make sure resources such as
//      memory and handles are deallocated or closed properly.
//
//  Maintained By:
//      David Potter (DavidP)   08-SEP-1999
//      Vij Vasu     (Vvasu)    16-SEP-1999
//
//  Notes:
//      1. These classes are functionally identical to version 3 of the
//      standard library's auto_ptr class. They are redefined here since this
//      version of auto_ptr has not yet found it's way into our build
//      environment.
//
//      2. These classes are not intended to be used as a base class. They are
//      meant to be space and time efficient wrappers. Using these as base
//      classes may require the use of virtual functions which will only make
//      their memory footprint larger.
//
//
/////////////////////////////////////////////////////////////////////////////

// Make sure that this header is included only once
#pragma once


/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////
#include <unknwn.h>


/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

// Store the warning state.
#pragma warning( push )

// Disable warning 4284. The text of the warning is below:
// Return type for 'identifier::operator ->' is not a UDT or reference to a UDT.
// Will produce errors if applied using infix notation
#pragma warning( disable : 4284 )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartResource
//
//  Description:
//      Automatically releases a resource.
//
//  Template Arguments:
//      t_ResourceTrait
//          A class that provides functions and types needed this class. For example,
//          this class may have a function that is used to release the resource.
//          It must define the type of the resource.
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_ResourceTrait >
class CSmartResource
{
private:
    //
    // Private Types
    //
    typedef typename t_ResourceTrait::ResourceType ResourceType;

    //
    // Private Data
    //
    ResourceType m_hResource;


public:
    //
    // Constructors & Destructors
    //

    // Default constructor
    explicit CSmartResource( ResourceType hResource = t_ResourceTrait::HGetNullValue() ) throw()
        : m_hResource( hResource )
    {
    } //*** CSmartResource( ResourceType )

    // Copy constructor
    CSmartResource( CSmartResource & rsrSourceInout ) throw()
        : m_hResource( rsrSourceInout.HRelinquishOwnership() )
    {
    } //*** CSmartResource( CSmartResource & )

    // Destructor
    ~CSmartResource() throw()
    { 
        CloseRoutineInternal();

    } //*** ~CSmartResource()


    //
    // Operators
    //

    // Assignment operator
    CSmartResource & operator=( CSmartResource & rsrRHSInout ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( &rsrRHSInout != this )
        {
            CloseRoutineInternal();
            m_hResource = rsrRHSInout.HRelinquishOwnership();
        } // if: not assigning to self

        return *this;

    } //*** operator=()

    // Operator to cast to underlying resource type
    operator ResourceType( void ) const throw()
    {
        return m_hResource;

    } //*** operator ResourceType()


    //
    // Lightweight Access Methods
    //

    // Get the handle to the resource
    ResourceType HHandle( void ) const throw()
    {
        return m_hResource;

    } //*** HResource()


    //
    // Class Methods
    //

    // Determine if the resource handle is valid
    bool FIsInvalid( void ) const throw()
    {
        return ( m_hResource == t_ResourceTrait::HGetNullValue() );

    } //*** FIsInvalid()


    // Assignment function
    CSmartResource & Assign( ResourceType hResource ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( m_hResource != hResource )
        {
            CloseRoutineInternal();
            m_hResource = hResource;
        } // if: not assigning to self

        return *this;

    } //*** Assign()

    // Free the resource.
    void Free( void ) throw()
    {
        CloseRoutineInternal();
        m_hResource = t_ResourceTrait::HGetNullValue();

    } //*** Free()

    // Relinquish ownership of the resouce without freeing it.
    ResourceType HRelinquishOwnership( void ) throw()
    {
        ResourceType hHandle = m_hResource;
        m_hResource = t_ResourceTrait::HGetNullValue();

        return hHandle;

    } //*** HRelinquishOwnership()


private:
    //
    //
    // Private operators
    //

    // The address-of operator
    CSmartResource * operator &() throw()
    {
        return this;
    }


    //
    // Private Class Methods
    //

    // Check and release the resource
    void CloseRoutineInternal( void ) throw()
    {
        if ( m_hResource != t_ResourceTrait::HGetNullValue() )
        {
            t_ResourceTrait::CloseRoutine( m_hResource );
        } // if: resource handle isn't invalid

    } //*** CloseRoutineInternal()

}; //*** class CSmartResource


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPtrTrait
//
//  Description:
//      Encapsulates the traits of pointers.
//
//  Template Arguments:
//      t_Ty        Type of memory to be managed (e.g. BYTE or int).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CPtrTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty *  ResourceType;
    typedef t_Ty    DataType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to release a resource.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        delete hResourceIn;
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()
}; //*** class CPtrTrait


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CArrayPtrTrait
//
//  Description:
//      Encapsulates the traits of pointers.
//
//  Template Arguments:
//      t_Ty        Type of memory to be managed (e.g. BYTE or int).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CArrayPtrTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty * ResourceType;
    typedef t_Ty   DataType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to release a resource
    static void CloseRoutine( ResourceType hResourceIn )
    {
        delete [] hResourceIn;
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()

}; //*** class CArrayPtrTrait


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CHandleTrait
//
//  Description:
//      The class is a handle trait class that can be used with handles whose
//      close routines take only one argument.
//
//      t_Ty
//          Type of handle to be managed (e.g. HWND).
//
//      t_CloseRoutineReturnType
//          The return type of the routine used to close the handle.
//
//      t_CloseRoutine
//          The routine used to close the handle. This function cannot throw
//          exceptions.
//
//      t_hNULL_VALUE
//          Null handle value.  Defaults to NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
template <
      class t_Ty
    , class t_CloseRoutineReturnType
    , t_CloseRoutineReturnType (*t_CloseRoutine)( t_Ty hHandleIn ) throw()
    , t_Ty t_hNULL_VALUE = NULL
    >
class CHandleTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty ResourceType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to close a handle.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        t_CloseRoutine( hResourceIn );
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return t_hNULL_VALUE;
    } //*** HGetNullValue()

}; //*** class CHandleTrait


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartGenericPtr
//
//  Description:
//      Automatically handles deallocation of memory.
//
//  Template Arguments:
//      t_PtrTrait
//      Trait class for the memory to be managed (e.g. CPtrTrait< int > ).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//      It is ok for this class to derive from CSmartResource since the
//      derivation is private and the lack of virtual functions will
//      therefore not cause any problems.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_PtrTrait >
class CSmartGenericPtr : private CSmartResource< t_PtrTrait >
{
private:
    //
    // Private Types
    //
    typedef CSmartResource< t_PtrTrait > BaseClass;


public:
    //
    // Public Types
    //
    typedef typename t_PtrTrait::DataType         DataType;

    //
    // Constructors & Destructors
    //

    // Default and memory pointer constructor
    explicit CSmartGenericPtr( DataType * pMemIn = NULL ) throw()
        : BaseClass( pMemIn )
    {
    } //*** CSmartGenericPtr( DataType * )

    // Copy constructor
    CSmartGenericPtr( CSmartGenericPtr & rsrSourceInout ) throw()
        : m_pMem( rsrSourceInout.HRelinquishOwnership() )
    {
    } //*** CSmartGenericPtr( CSmartGenericPtr & )

    // Destructor
    ~CSmartGenericPtr( void ) throw()
    { 
    } //*** ~CSmartGenericPtr()


    //
    // Operators
    //

    // Assignment operator
    CSmartGenericPtr & operator=( CSmartGenericPtr & rapRHSInout ) throw()
    {
        return static_cast< CSmartGenericPtr & >( BaseClass::operator=( rapRHSInout ) );
    } //*** operator=()

    // Assign a pointer
    CSmartGenericPtr & Assign( DataType * pMemIn ) throw()
    {
        return static_cast< CSmartGenericPtr & >( BaseClass::Assign( pMemIn ) );
    } //*** Assign()

    // Pointer dereference operator*
    DataType & operator*( void ) const throw()
    {
        return *HHandle();

    } //*** operator*()

    // Pointer dereference operator->
    DataType * operator->( void ) const throw()
    {
        return HHandle();

    } //*** operator->()


    //
    // Lightweight Access Methods
    //

    // Get the memory pointer
    DataType * PMem( void ) const throw()
    {
        return HHandle();

    } //*** PMem()


    //
    // Class Methods
    //

    // Determine if memory pointer is valid
    bool FIsEmpty( void ) const throw()
    {
        return FIsInvalid();

    } //*** FIsEmpty()


    // Relinquish our ownership of the memory pointer
    DataType * PRelease( void ) throw()
    {
        return HRelinquishOwnership();
    } //*** PRelease()

}; //*** class CSmartGenericPtr


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartIfacePtr
//
//  Description:
//      Automatically calls AddRef on creation and Release on destruction.
//
//  Template Arguments:
//      t_Ty        Type of pointer to be managed (e.g. IUnknown *).
//
//  Remarks:
//      This class does not have the destructive copy semantics. That is,
//      when a CSmartIfacePtr object is copied, the source is still valid.
//
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CSmartIfacePtr
{
private:
    //
    // Private Data
    //
    t_Ty * m_pUnk;


public:

    // Class to prevent explicit calls to AddRef() and Release
    class INoAddRefRelease : public t_Ty
    {
    private:
        virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
        virtual ULONG STDMETHODCALLTYPE Release() = 0;
    };

    //
    // Constructors & Destructors
    //

    // Default and pointer constructor
    CSmartIfacePtr( t_Ty * pUnkIn = NULL ) throw()
        : m_pUnk( pUnkIn )
    {
        AddRefInternal();
    } //*** CSmartIfacePtr( t_Ty * )

    // Copy constructor
    CSmartIfacePtr( const CSmartIfacePtr & rsrSourceIn ) throw()
        : m_pUnk( rsrSourceIn.PUnk() )
    {
        AddRefInternal();
    } //*** CSmartIfacePtr( CSmartIfacePtr & )

    // Destructor
    ~CSmartIfacePtr( void ) throw()
    { 
        ReleaseInternal();
    } //*** ~CSmartIfacePtr()


    //
    // Operators
    //

    // Assignment operator
    INoAddRefRelease & operator=( const CSmartIfacePtr & rapRHSIn ) throw()
    {
        return Assign( rapRHSIn.PUnk() );

    } //*** operator=()

    // Pointer dereference operator*
    INoAddRefRelease & operator*( void ) const throw()
    {
        return *( static_cast< INoAddRefRelease * >( m_pUnk ) );

    } //*** operator*()

    // Pointer dereference operator->
    INoAddRefRelease * operator->( void ) const throw()
    {
        return static_cast< INoAddRefRelease * >( m_pUnk );

    } //*** operator->()


    //
    // Lightweight Access Methods
    //

    // Get the pointer
    INoAddRefRelease * PUnk( void ) const throw()
    {
        return static_cast< INoAddRefRelease * >( m_pUnk );

    } //*** PUnk()


    //
    // Class Methods
    //

    // Assignment function.
    INoAddRefRelease & Assign( t_Ty * pRHSIn ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( pRHSIn != m_pUnk ) 
        {
            ReleaseInternal();
            m_pUnk = pRHSIn;
            AddRefInternal();
        } // if: not assigning to self

        return *( static_cast< INoAddRefRelease * >( m_pUnk ) );

    } //*** Assign()

    // Attach ( assign without AddRef() )
    void Attach( t_Ty * pRHSIn ) throw()
    {
        // Only perform the attachment if not attaching to self
        if ( pRHSIn != m_pUnk ) 
        {
            ReleaseInternal();
            m_pUnk = pRHSIn;
        } // if: not attaching to self

    } //*** Attach()

    // Release this interface pointer.
    void Release() throw()
    {
        ReleaseInternal();
        m_pUnk = NULL;
    }

    // Query punkSrc for __uuidof( m_pUnk ) and store the result.
    HRESULT HrQueryAndAssign( IUnknown * punkSrc ) throw()
    {
        ReleaseInternal();
        return punkSrc->QueryInterface< t_Ty >( &m_pUnk );

    } ///*** HrQueryAndAssign()


    // Determine if pointer is valid
    bool FIsEmpty( void ) const throw()
    {
        return ( m_pUnk == NULL );

    } //*** FIsEmpty()


private:
    //
    //
    // Private operators
    //

    // The address-of operator
    CSmartIfacePtr * operator &()
    {
        return this;
    }

    //
    // Private Class Methods
    //

    // Increment the reference count on the pointer
    void AddRefInternal( void ) throw()
    {
        if ( m_pUnk != NULL )
        {
            m_pUnk->AddRef();
        }
    } //*** PRelease()

    // Release the pointer.
    // A call to this function is usually be followed by a reassignment, or else
    // this will object may contain an invalid pointer.
    void ReleaseInternal( void ) throw()
    {
        if ( m_pUnk != NULL )
        {
            m_pUnk->Release();
        }
    } //*** PRelease()

}; //*** class CSmartIfacePtr


// Restore the warning state.
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\inc\registersrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      RegisterSrc.cpp
//
//  Description:
//      This file provides registration for the DLL.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    18-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

// #include <Pch.h>     // should be included by includer of this file
#include <StrSafe.h>    // in case it isn't included by header file

#if defined(MMC_SNAPIN_REGISTRATION)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterNodeType(
//      SNodeTypesTable * pnttIn,
//      BOOL              fCreateIn
//      )
//
//  Description:
//      Registers the Node Type extensions for MMC Snapins using the table in
//      pnttIn as a guide.
//
//  Arguments:
//      pnttIn      - Table of node types to register.
//      fCreateIn   - TRUE == Create; FALSE == Delete
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterNodeType(
    const SNodeTypesTable * pnttIn,
    BOOL                    fCreateIn
    )
{
    TraceFunc1( "pnttIn = 0x%08x", pnttIn );
    Assert( pnttIn != NULL );

    LRESULT sc;
    DWORD   dwDisposition;  // placeholder
    size_t  cbSize;

    HRESULT hr = S_OK;

    const SNodeTypesTable * pntt  = pnttIn;

    HKEY    hkeyNodeTypes   = NULL;
    HKEY    hkeyCLSID       = NULL;
    HKEY    hkeyExtension   = NULL;
    HKEY    hkey   = NULL;
    LPWSTR  pszCLSID        = NULL;

    //
    // Open the MMC NodeTypes' key.
    //
    sc = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                     L"Software\\Microsoft\\MMC\\NodeTypes",
                     &hkeyNodeTypes
                     );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if: error opening the key

    while ( pntt->rclsid != NULL )
    {
        //
        // Create the NODEID's CLSID key.
        //
        hr = THR( StringFromCLSID( *pntt->rclsid, &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( ! fCreateIn )
        {
            sc = SHDeleteKey( hkeyNodeTypes, pszCLSID );
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                // nop
            } // if: key not found
            else if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // else if: error deleting the key

            CoTaskMemFree( pszCLSID );
            pszCLSID = NULL;
            pntt++;
            continue;
        } // if: deleting

        sc = RegCreateKeyExW( hkeyNodeTypes,
                             pszCLSID,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_WRITE,
                             NULL,
                             &hkeyCLSID,
                             &dwDisposition
                             );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error creating the key

        CoTaskMemFree( pszCLSID );
        pszCLSID = NULL;

        //
        // Set the node type's internal reference name.
        //
        cbSize = ( wcslen( pntt->pszInternalName ) + 1 ) * sizeof( *pntt->pszInternalName );
        sc = RegSetValueExW( hkeyCLSID, NULL, 0, REG_SZ, (LPBYTE) pntt->pszInternalName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error setting the value

        if ( pntt->pContextMenu != NULL
          || pntt->pNameSpace != NULL
          || pntt->pPropertySheet != NULL
          || pntt->pTask != NULL
          || pntt->pToolBar != NULL
           )
        {
            //
            // Create the "Extensions" key.
            //
            sc = RegCreateKeyExW( hkeyCLSID,
                                 L"Extensions",
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkeyExtension,
                                 &dwDisposition
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            //
            // Create the "NameSpace" key if needed.
            //
            if ( pntt->pNameSpace != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyExW( hkeyExtension,
                                     L"NameSpace",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pNameSpace;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( *pet->pszInternalName );
                    sc = RegSetValueExW( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

                RegCloseKey( hkey );
                hkey = NULL;

            } // if: name space list

            //
            // Create the "ContextMenu" key if needed.
            //
            if ( pntt->pContextMenu != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyExW( hkeyExtension,
                                     L"ContextMenu",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pContextMenu;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( *pet->pszInternalName );
                    sc = RegSetValueExW( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

                RegCloseKey( hkey );
                hkey = NULL;

            } // if: context menu list

            //
            // Create the "ToolBar" key if needed.
            //
            if ( pntt->pToolBar != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyExW( hkeyExtension,
                                     L"ToolBar",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pToolBar;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( *pet->pszInternalName );
                    sc = RegSetValueExW( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

            //
            // Create the "PropertySheet" key if needed.
            //
            if ( pntt->pPropertySheet != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyExW( hkeyExtension,
                                     L"PropertySheet",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pPropertySheet;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( *pet->pszInternalName );
                    sc = RegSetValueExW( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

            //
            // Create the "Task" key if needed.
            //
            if ( pntt->pTask != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyExW( hkeyExtension,
                                     L"Task",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pTask;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( *pet->pszInternalName );
                    sc = RegSetValueExW( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

        } // if: extensions present

        pntt++;

    } // while: pet->rclsid

    //
    // If we made it here, then obviously we were successful.
    //
    hr = S_OK;

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkey != NULL )
    {
        RegCloseKey( hkey );
    } // if: hkey

    if ( hkeyCLSID != NULL )
    {
        RegCloseKey( hkeyCLSID );
    } // if: hkeyCLSID

    if ( hkeyExtension != NULL)
    {
        RegCloseKey( hkeyExtension );
    } // if: hkeyExtension

    if ( hkey != NULL )
    {
        RegCloseKey( hkey );
    } // if: hkey

    if ( hkeyNodeTypes != NULL )
    {
        RegCloseKey( hkeyNodeTypes );
    } // if: hkeyNodeTypes

    HRETURN( hr );

} //*** HrRegisterNodeType

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterSnapins(
//      const SSnapInTable * psitIn
//      BOOL                 fCreateIn
//      )
//
//  Description:
//      Registers the Snap-Ins for MMC using the table in psitIn as a guide.
//
//  Arguments:
//      psitIn      - Table of snap-ins to register.
//      fCreateIn   - TRUE == Create; FALSE == Delete
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterSnapins(
    const SSnapInTable * psitIn,
    BOOL                 fCreateIn
    )
{
    TraceFunc1( "psitIn = 0x%08x", psitIn );
    Assert( psitIn != NULL );

    LRESULT sc;
    DWORD   dwDisposition;  // placeholder
    size_t  cbSize;

    HRESULT hr = S_OK;

    const SSnapInTable *  psit = psitIn;

    LPWSTR  pszCLSID        = NULL;
    HKEY    hkeySnapins     = NULL;
    HKEY    hkeyCLSID       = NULL;
    HKEY    hkeyNodeTypes   = NULL;
    HKEY    hkeyTypes       = NULL;

    //
    // Register the class id of the snapin
    //
    sc = RegOpenKeyW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\Snapins", &hkeySnapins );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if: error opening the key

    while ( psit->rclsid )
    {
        hr = THR( StringFromCLSID( *psit->rclsid, &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( ! fCreateIn )
        {
            sc = SHDeleteKey( hkeySnapins, pszCLSID );
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                // nop
            } // if: key not found
            else if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // else if: error deleting the key

            CoTaskMemFree( pszCLSID );
            pszCLSID = NULL;
            psit++;
            continue;
        } // if: deleting

        sc = RegCreateKeyExW( hkeySnapins,
                             pszCLSID,
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_WRITE,
                             NULL,
                             &hkeyCLSID,
                             NULL
                             );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error creating the key

        CoTaskMemFree( pszCLSID );
        pszCLSID = NULL;

        //
        // Set the (default) to a helpful description
        //
        cbSize = ( wcslen( psit->pszInternalName ) + 1 ) * sizeof( *psit->pszInternalName );
        sc = RegSetValueExW( hkeyCLSID, NULL, 0, REG_SZ, (LPBYTE) psit->pszInternalName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: setting the value

        //
        // Set the Snapin's display name
        //
        cbSize = ( wcslen( psit->pszDisplayName ) + 1 ) * sizeof( *psit->pszDisplayName );
        sc = RegSetValueExW( hkeyCLSID, L"NameString", 0, REG_SZ, (LPBYTE) psit->pszDisplayName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error setting the value

        if ( psit->fStandAlone )
        {
            HKEY hkey;
            sc = RegCreateKeyExW( hkeyCLSID,
                                 L"StandAlone",
                                 0,
                                 0,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkey,
                                 NULL
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            RegCloseKey( hkey );

        } // if: stand alone

        if ( psit->pntt != NULL )
        {
            int     nTypes;

            sc = RegCreateKeyExW( hkeyCLSID,
                                 L"NodeTypes",
                                 0,
                                 0,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkeyNodeTypes,
                                 NULL
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            for ( nTypes = 0; psit->pntt[ nTypes ].rclsid; nTypes++ )
            {
                hr = THR( StringFromCLSID( *psit->pntt[ nTypes ].rclsid, &pszCLSID ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                sc = RegCreateKeyExW( hkeyNodeTypes,
                                     pszCLSID,
                                     0,
                                     0,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkeyTypes,
                                     NULL
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                CoTaskMemFree( pszCLSID );
                pszCLSID = NULL;

                //
                // Set the (default) to a helpful description
                //
                cbSize = ( wcslen( psit->pntt[ nTypes ].pszInternalName ) + 1 ) * sizeof( *psit->pntt[ nTypes ].pszInternalName );
                sc = RegSetValueExW( hkeyTypes, NULL, 0, REG_SZ, (LPBYTE) psit->pntt[ nTypes ].pszInternalName, cbSize );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error setting the value

                RegCloseKey( hkeyTypes );
                hkeyTypes = NULL;

                hr = THR( HrRegisterNodeType( psit->pntt, fCreateIn ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

            } // for: each node type

            RegCloseKey( hkeyNodeTypes );
            hkeyNodeTypes = NULL;

        } // if: node types

        RegCloseKey( hkeyCLSID );
        hkeyCLSID = NULL;

        psit++;

    } // while: psit->rclsid

    //
    // If we made it here, then obviously we were successful.
    //
    hr = S_OK;

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkeySnapins != NULL )
    {
        RegCloseKey( hkeySnapins );
    } // if: hkeySnapins

    if ( hkeyNodeTypes != NULL )
    {
        RegCloseKey( hkeyNodeTypes );
    } // if: hkeyNodeTypes

    if ( hkeyTypes != NULL )
    {
        RegCloseKey( hkeyTypes );
    } // if: hkeyTypes

    HRETURN( hr );

} //*** HrRegisterSnapins

#endif // defined(MMC_SNAPIN_REGISTRATION)



///////////////////////////////////////////////////////////////////////////////
//
//  Registry helper functions, to make other code easier to read.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateRegKey
//
//  Description:
//      Create a registry key with a given name and parent key and return
//      a handle to it, or return a handle to an existing key if one already exists.
//
//  Arguments:
//      hkeyParentIn        - The parent key.
//      pcwszKeyNameIn      - The child key's name.
//      phkeyCreatedKeyOut  - The returned key handle.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrCreateRegKey(
      HKEY      hkeyParentIn
    , PCWSTR    pcwszKeyNameIn
    , PHKEY     phkeyCreatedKeyOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    LONG    scKeyCreate = ERROR_SUCCESS;

    if ( phkeyCreatedKeyOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *phkeyCreatedKeyOut = NULL;

    if ( ( hkeyParentIn == NULL ) || ( pcwszKeyNameIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scKeyCreate = TW32( RegCreateKeyExW(
                              hkeyParentIn
                            , pcwszKeyNameIn
                            , 0         // reserved
                            , NULL      // class string--unused
                            , REG_OPTION_NON_VOLATILE
                            , KEY_WRITE // desired access
                            , NULL      // use default security
                            , phkeyCreatedKeyOut
                            , NULL      // don't care whether it already exists
                            ) );
    if ( scKeyCreate != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scKeyCreate );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrCreateRegKey


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrOpenRegKey
//
//  Description:
//      Open a registry key with a given name and parent key and return
//      a handle to it, and fail if none already exists.
//
//  Arguments:
//      hkeyParentIn        - The parent key.
//      pcwszKeyNameIn      - The child key's name.
//      phkeyOpenedKeyOut   - The returned key handle.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrOpenRegKey(
      HKEY      hkeyParentIn
    , PCWSTR    pcwszKeyNameIn
    , PHKEY     phkeyOpenedKeyOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    LONG    scKeyOpen = ERROR_SUCCESS;

    if ( phkeyOpenedKeyOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *phkeyOpenedKeyOut = NULL;

    if ( ( hkeyParentIn == NULL ) || ( pcwszKeyNameIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scKeyOpen = TW32( RegOpenKeyExW(
                              hkeyParentIn
                            , pcwszKeyNameIn
                            , 0         // reserved, must be zero
                            , KEY_WRITE // desired access
                            , phkeyOpenedKeyOut
                            ) );
    if ( scKeyOpen != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scKeyOpen );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrOpenRegKey



///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrDeleteRegKey
//
//  Description:
//      Given a handle to a registry key and the name of a child key, delete
//      the child key.  If the child key does not currently exist, do nothing.
//
//  Arguments:
//      hkeyParentIn        - The parent key.
//      pcwszKeyNameIn      - The child key's name.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrDeleteRegKey(
      HKEY      hkeyParentIn
    , PCWSTR    pcwszKeyNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   scKeyDelete = ERROR_SUCCESS;

    if ( ( hkeyParentIn == NULL ) || ( pcwszKeyNameIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scKeyDelete = TW32E( SHDeleteKey( hkeyParentIn, pcwszKeyNameIn ), ERROR_FILE_NOT_FOUND );
    if ( ( scKeyDelete != ERROR_SUCCESS ) && ( scKeyDelete != ERROR_FILE_NOT_FOUND ) )
    {
        hr = HRESULT_FROM_WIN32( scKeyDelete );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrDeleteRegKey


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetRegStringValue
//
//  Description:
//      Create a new string value under a registry key, or overwrite one that
//      already exists.
//
//  Arguments:
//      hkeyIn              - The parent key.
//      pcwszValueNameIn    - The value name; can be null, which means write key's default value.
//      pcwszValueIn        - The string to put in the value.
//      cchValueIn          - The number of characters in the string, NOT including the terminating null.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrSetRegStringValue(
      HKEY      hkeyIn
    , PCWSTR    pcwszValueNameIn
    , PCWSTR    pcwszValueIn
    , size_t    cchValueIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    LONG            scValueSet = ERROR_SUCCESS;
    DWORD           cbValue = ( DWORD ) ( cchValueIn + 1 ) * sizeof( *pcwszValueIn );
    CONST BYTE *    pbValue = reinterpret_cast< CONST BYTE * >( pcwszValueIn );

    if ( ( hkeyIn == NULL ) || ( pcwszValueIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scValueSet = TW32( RegSetValueExW(
                              hkeyIn
                            , pcwszValueNameIn
                            , 0         // reserved
                            , REG_SZ
                            , pbValue
                            , cbValue
                            ) );
    if ( scValueSet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scValueSet );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrSetRegStringValue


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetRegDWORDValue
//
//  Description:
//      Create a new DWORD value under a registry key, or overwrite one that
//      already exists.
//
//  Arguments:
//      hkeyIn              - The parent key.
//      pcwszValueNameIn    - The value name; can be null, which means write key's default value.
//      dwValueIn           - The DWORD to put in the value.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrSetRegDWORDValue(
      HKEY      hkeyIn
    , PCWSTR    pcwszValueNameIn
    , DWORD     dwValueIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    LONG            scValueSet = ERROR_SUCCESS;
    DWORD           cbValue = ( DWORD ) sizeof( dwValueIn );
    CONST BYTE *    pbValue = reinterpret_cast< CONST BYTE * >( &dwValueIn );

    if ( hkeyIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scValueSet = TW32( RegSetValueExW(
                              hkeyIn
                            , pcwszValueNameIn
                            , 0         // reserved
                            , REG_DWORD
                            , pbValue
                            , cbValue
                            ) );
    if ( scValueSet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scValueSet );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrSetRegDWORDValue


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetRegBinaryValue
//
//  Description:
//      Create a new binary value under a registry key, or overwrite one that
//      already exists.
//
//  Arguments:
//      hkeyIn              - The parent key.
//      pcwszValueNameIn    - The value name; can be null, which means write key's default value.
//      pbValueIn           - The bits to put in the value.
//      cbValueIn           - The length of the value, in bytes.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
inline
HRESULT
HrSetRegBinaryValue(
      HKEY          hkeyIn
    , PCWSTR        pcwszValueNameIn
    , CONST BYTE*   pbValueIn
    , size_t        cbValueIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    LONG            scValueSet = ERROR_SUCCESS;

    if ( ( hkeyIn == NULL ) || ( ( pbValueIn == NULL ) && ( cbValueIn > 0 ) ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    scValueSet = TW32( RegSetValueExW(
                              hkeyIn
                            , pcwszValueNameIn
                            , 0         // reserved
                            , REG_BINARY
                            , pbValueIn
                            , ( DWORD ) cbValueIn
                            ) );
    if ( scValueSet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scValueSet );
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrSetRegBinaryValue


#if defined( COMPONENT_HAS_CATIDS )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterComponentCategories
//
//  Description:
//      Register this dll's component categories, duh.
//
//  Arguments:
//      pcrIn   - The standard category manager.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterComponentCategories( ICatRegister* pcrIn )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CATEGORYINFO *      prgci = NULL;
    const SCatIDInfo *  pCatIDInfo = g_DllCatIds;

    if ( pcrIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( g_cDllCatIds > 0 )
    {
        CATEGORYINFO* pciCurrent = NULL;
        
        // Allocate the category info array.
        prgci = new CATEGORYINFO[ g_cDllCatIds ];
        if ( prgci == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: error allocating category info array
        pciCurrent = prgci;

        // Fill the category info array.
        for ( pCatIDInfo = g_DllCatIds; pCatIDInfo->pcatid != NULL; ++pCatIDInfo, ++pciCurrent )
        {
            pciCurrent->catid = *( pCatIDInfo->pcatid );
            pciCurrent->lcid = LOCALE_NEUTRAL;
            THR( StringCchCopyW(
                      pciCurrent->szDescription
                    , RTL_NUMBER_OF( pciCurrent->szDescription )
                    , pCatIDInfo->pcszName
                    ) );
        } // for: each CATID

        hr = THR( pcrIn->RegisterCategories( ( ULONG ) g_cDllCatIds, prgci ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: category count is greater than zero
    
Cleanup:

    if ( prgci != NULL )
    {
        delete [] prgci;
    }

    HRETURN( hr );

} //*** HrRegisterComponentCategories


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterComponentCategories
//
//  Description:
//      Unregister this dll's component categories, duh.
//
//  Arguments:
//      pcrIn   - The standard category manager.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrUnregisterComponentCategories( ICatRegister* pcrIn )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CATID *             prgcatid = NULL;
    const SCatIDInfo *  pCatIDInfo = g_DllCatIds;

    if ( g_cDllCatIds > 0 )
    {
        CATID * pcatidCurrent = NULL;
        
        // Allocate the array of CATIDs.
        prgcatid = new CATID[ g_cDllCatIds ];
        if ( prgcatid == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: error allocating CATID array
        pcatidCurrent = prgcatid;
        
        // Fill the category info array.
        for ( pCatIDInfo = g_DllCatIds; pCatIDInfo->pcatid != NULL; ++pCatIDInfo, ++pcatidCurrent )
        {
            *pcatidCurrent = *( pCatIDInfo->pcatid );
        } // for: each CATID

        THR( pcrIn->UnRegisterCategories( ( ULONG ) g_cDllCatIds, prgcatid ) );
    } // if: category count is greater than zero

Cleanup:

    if ( prgcatid != NULL )
    {
        delete [] prgcatid;
    }

    HRETURN( hr );

} //*** HrUnregisterComponentCategories
      
#endif // defined( COMPONENT_HAS_CATIDS )


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrStoreAppIDPassword
//
//  Description:
//      Install (or remove) the password for an AppID's identity.
//
//  Arguments:
//      pcwszAppIDIn
//          The AppID's guid in the curly bracket-enclosed string format;
//          must not be null.
//
//      plsastrPasswordIn
//          The password; set this to null to erase the password.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrStoreAppIDPassword(
      PCWSTR                pcwszAppIDIn
    , LSA_UNICODE_STRING*   plsastrPasswordIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    HANDLE                  hLSAPolicy = NULL;
    LSA_OBJECT_ATTRIBUTES   lsaAttributes;
    LSA_UNICODE_STRING      lsastrKeyName;
    WCHAR                   szKeyName[ ( RTL_NUMBER_OF( L"SCM:" ) - 1 ) + MAX_COM_GUID_STRING_LEN ] = L"SCM:";
    NTSTATUS                ntsError = 0;

    if ( pcwszAppIDIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Format for AppID password key name is SCM:{guid}
    hr = THR( StringCchCatW( szKeyName, RTL_NUMBER_OF( szKeyName ), pcwszAppIDIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // LSA_UNICODE_STRING.Length is in bytes, and does NOT include terminating null.
    lsastrKeyName.Length = ( USHORT ) sizeof( szKeyName ) - sizeof( *szKeyName );
    lsastrKeyName.MaximumLength = lsastrKeyName.Length;
    lsastrKeyName.Buffer = szKeyName;

    ZeroMemory( &lsaAttributes, sizeof( lsaAttributes ) );
    ntsError = LsaOpenPolicy( NULL, &lsaAttributes, POLICY_CREATE_SECRET, &hLSAPolicy );
    if ( ntsError != 0 )
    {
        ULONG scLastError = TW32( LsaNtStatusToWinError( ntsError ) );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

    ntsError = LsaStorePrivateData( hLSAPolicy, &lsastrKeyName, plsastrPasswordIn );
    if ( ntsError != 0 )
    {
        ULONG scLastError = TW32( LsaNtStatusToWinError( ntsError ) );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

Cleanup:

    if ( hLSAPolicy != NULL )
    {
        LsaClose( hLSAPolicy );
    }

    HRETURN( hr );

} //*** HrStoreAppIDPassword


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAddBatchLogonRight
//
//  Description:
//      Add SE_BATCH_LOGON_NAME to the rights of an account.
//
//  Arguments:
//      pcwszIdentitySIDIn
//          The account's security identifier in S-n-n-n... format.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrAddBatchLogonRight( PCWSTR pcwszIdentitySIDIn )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    HANDLE                  hLSAPolicy = NULL;
    LSA_OBJECT_ATTRIBUTES   lsaAttributes;
    SID *                   psid = NULL;
    NTSTATUS                ntsError = 0;
    LSA_UNICODE_STRING      lsastrBatchLogonRight;
    WCHAR                   wszBatchLogonRight[] = SE_BATCH_LOGON_NAME;

    if ( pcwszIdentitySIDIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( ConvertStringSidToSid( pcwszIdentitySIDIn, reinterpret_cast< void** >( &psid ) ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

    ZeroMemory( &lsaAttributes, sizeof( lsaAttributes ) );
    ntsError = LsaOpenPolicy( NULL, &lsaAttributes, POLICY_LOOKUP_NAMES, &hLSAPolicy );
    if ( ntsError != 0 )
    {
        ULONG scLastError = TW32( LsaNtStatusToWinError( ntsError ) );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

    // LSA_UNICODE_STRING.Length is in bytes, and does NOT include terminating null.
    lsastrBatchLogonRight.Length = ( USHORT ) sizeof( wszBatchLogonRight ) - sizeof( *wszBatchLogonRight ); 
    lsastrBatchLogonRight.MaximumLength = lsastrBatchLogonRight.Length;
    lsastrBatchLogonRight.Buffer = wszBatchLogonRight;

    ntsError = LsaAddAccountRights( hLSAPolicy, psid, &lsastrBatchLogonRight, 1 );
    if ( ntsError != 0 )
    {
        ULONG scLastError = TW32( LsaNtStatusToWinError( ntsError ) );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

Cleanup:

    if ( hLSAPolicy != NULL )
    {
        LsaClose( hLSAPolicy );
    }

    if ( psid != NULL )
    {
        LocalFree( psid );
    }
    
    HRETURN( hr );

} //*** HrAddBatchLogonRight


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterRunAsIdentity
//
//  Description:
//      Given an AppID and a value of the ClusCfgRunAsIdentity enumeration,
//      set up the AppID's RunAs registry named value and any other parts of the
//      system appropriately.
//
//  Arguments:
//      hkeyAppIDIn
//          The registry key for the AppID under HKCR\AppID.
//
//      pcwszAppIDIn
//          The curly bracket-enclosed string representation of the AppID's guid.
//
//      eairaiIn
//          The identity to register.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterRunAsIdentity(
      HKEY                 hkeyAppIDIn
    , PCWSTR               pcwszAppIDIn
    , EAppIDRunAsIdentity  eairaiIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HANDLE  hLSAPolicy = NULL;

    if ( ( hkeyAppIDIn == NULL ) || ( pcwszAppIDIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Launching user: do nothing.
    if ( eairaiIn != airaiLaunchingUser )
    {
        //  Create RunAs value with appropriate identity name.
        static const WCHAR  wszInteractiveUserName[]    = L"Interactive User";
        static const WCHAR  wszNetServiceName[]         = L"NT AUTHORITY\\NETWORK SERVICE";
        static const PCWSTR pcwszNetServiceSID          = L"S-1-5-20";
        static const WCHAR  wszLocalServiceName[]       = L"NT AUTHORITY\\LOCAL SERVICE";
        static const PCWSTR pcwszLocalServiceSID        = L"S-1-5-19";

        PCWSTR              pcwszIdentityName = NULL;
        size_t              cchIdentityName = 0;

        PCWSTR              pcwszIdentitySID = NULL;
        LSA_UNICODE_STRING  lsastrPassword = { 0, 0, L"" };

        if ( eairaiIn == airaiLocalService )
        {
            pcwszIdentityName = wszLocalServiceName;
            cchIdentityName = RTL_NUMBER_OF( wszLocalServiceName ) - 1;
            pcwszIdentitySID = pcwszLocalServiceSID;
        }
        else if ( eairaiIn == airaiNetworkService )
        {
            pcwszIdentityName = wszNetServiceName;
            cchIdentityName = RTL_NUMBER_OF( wszNetServiceName ) - 1;
            pcwszIdentitySID = pcwszNetServiceSID;
        }
        else // eairaiIn == airaiInteractiveUser
        {
            pcwszIdentityName = wszInteractiveUserName;
            cchIdentityName = RTL_NUMBER_OF( wszInteractiveUserName ) - 1;
        }

        hr = THR( HrSetRegStringValue( hkeyAppIDIn, L"RunAs", pcwszIdentityName, cchIdentityName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( pcwszIdentitySID != NULL )
        {
            //  Running as a fixed identity; set password and rights.
            hr = THR( HrStoreAppIDPassword( pcwszAppIDIn, &lsastrPassword ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( HrAddBatchLogonRight( pcwszIdentitySID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: running as fixed identity
    } // if: not running as launching user
    
Cleanup:

    if ( hLSAPolicy != NULL )
    {
        LsaClose( hLSAPolicy );
    }

    HRETURN( hr );

} //*** HrRegisterRunAsIdentity


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterSecurityDescriptor
//
//  Description:
//      Given a registry key, a value name, and the resource ID of an SDDL string,
//      write the security descriptor described by the string to a value having
//      the given name under the registry key.
//
//  Arguments:
//      hkeyParentIn
//          The registry key under which to create the named value.
//
//      pcwszValueNameIn
//          The name of the value to create.
//
//      idsDescriptorIn
//          The resource ID of a string in Security Descriptor Description Language.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterSecurityDescriptor(
      HKEY      hkeyParentIn
    , PCWSTR    pcwszValueNameIn
    , DWORD     idsDescriptorIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    BSTR                    bstrDescriptor = NULL;
    PSECURITY_DESCRIPTOR    psd = NULL;
    ULONG                   cbsd = 0;

    if ( ( hkeyParentIn == NULL ) || ( pcwszValueNameIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Load descriptor string.
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsDescriptorIn, &bstrDescriptor ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Convert string to binary descriptor.
    if ( ConvertStringSecurityDescriptorToSecurityDescriptor(
          bstrDescriptor
        , SDDL_REVISION_1
        , &psd
        , &cbsd
        ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }
    
    //  Write binary descriptor to named value.
    hr = THR( HrSetRegBinaryValue(
          hkeyParentIn
        , pcwszValueNameIn
        , reinterpret_cast< CONST BYTE* >( psd )
        , cbsd
        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    TraceSysFreeString( bstrDescriptor );
    LocalFree( psd );
    HRETURN( hr );

} //*** HrRegisterSecurityDescriptor


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterAppID
//
//  Description:
//      Given a registry key (presumably HKCR\AppID) and a ClusCfgAppIDInfo
//      struct, write appropriate settings for the AppID to the registry.
//
//  Arguments:
//      hkeyParentIn
//          The registry key under which to create the AppID's key.
//
//      pAppIDInfoIn
//          The settings for the AppID.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterAppID(
      HKEY                hkeyParentIn
    , const SAppIDInfo*   pAppIDInfoIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HKEY    hkCurrentAppID = NULL;
    OLECHAR szAppID[ MAX_COM_GUID_STRING_LEN ];
    
    if ( ( hkeyParentIn == NULL ) || ( pAppIDInfoIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    Assert( pAppIDInfoIn->pAppID != NULL );

    //  Create AppID guid subkey.
    if ( StringFromGUID2( *( pAppIDInfoIn->pAppID ), szAppID, ( int ) RTL_NUMBER_OF( szAppID ) ) == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( HrCreateRegKey( hkeyParentIn, szAppID, &hkCurrentAppID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Write AppID name to guid key's default value.
    hr = THR( HrSetRegStringValue( hkCurrentAppID, NULL, pAppIDInfoIn->pcszName, pAppIDInfoIn->cchName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    //  Under AppID guid subkey,

    //  -- Create LaunchPermission value.
    hr = THR( HrRegisterSecurityDescriptor( hkCurrentAppID, L"LaunchPermission", pAppIDInfoIn->idsLaunchPermission ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Create AccessPermission value.
    hr = THR( HrRegisterSecurityDescriptor( hkCurrentAppID, L"AccessPermission", pAppIDInfoIn->idsAccessPermission ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Create AuthenticationLevel value.
    hr = THR( HrSetRegDWORDValue( hkCurrentAppID, L"AuthenticationLevel", pAppIDInfoIn->nAuthenticationLevel ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Create RunAs value.
    hr = THR( HrRegisterRunAsIdentity( hkCurrentAppID, szAppID, pAppIDInfoIn->eairai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Create DllSurrogate value; empty string says to use dllhost.
    hr = THR( HrSetRegStringValue( hkCurrentAppID, L"DllSurrogate", L"", 0 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    if ( hkCurrentAppID != NULL )
    {
        TW32( RegCloseKey( hkCurrentAppID ) );
    }

    HRETURN( hr );

} //*** HrRegisterAppID


///////////////////////////////////////////////////////////////////////////////
//++
//  HrRegisterAppIDs
//
//
//  Description:
//      Write registry settings for every populated element of the global
//      g_AppIDs array under HKCR\AppID.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterAppIDs( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    HKEY                hkAppID = NULL;
    const SAppIDInfo *  pAppIDInfo = g_AppIDs;    
    
    //  Open AppID key.
    hr = THR( HrOpenRegKey( HKEY_CLASSES_ROOT, L"AppID", &hkAppID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //  Register each AppID.
    while ( pAppIDInfo->pAppID != NULL )
    {
        hr = THR( HrRegisterAppID( hkAppID, pAppIDInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        ++pAppIDInfo;
    }
    
Cleanup:

    if ( hkAppID != NULL )
    {
        TW32( RegCloseKey( hkAppID ) );
    }

    HRETURN( hr );

} //*** HrRegisterAppIDs


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterPublicClass
//
//  Description:
//      Given a registry key (presumably HKCR\CLSID), a ClusCfgPublicClassInfo
//      struct, and an instance of the standard component category manager,
//      write appropriate settings for the class to the registry.
//
//  Arguments:
//      pClassInfoIn
//          The settings for the class.
//
//      hkeyCLSIDIn
//          The registry key under which to create the clsid key class guid.
//
//      pcrIn
//          An instance of the standard component category manager.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterPublicClass(
      const SPublicClassInfo *  pClassInfoIn
    , HKEY                      hkeyCLSIDIn
    , ICatRegister *            pcrIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HKEY    hkCurrentCLSID = NULL;
    HKEY    hkInprocServer32 = NULL;
    HKEY    hkProgIDunderCLSID = NULL;
    HKEY    hkProgIDunderHKCR = NULL;
    HKEY    hkCLSIDunderProgID = NULL;
    OLECHAR szCLSID[ MAX_COM_GUID_STRING_LEN ];
    OLECHAR szAppID[ MAX_COM_GUID_STRING_LEN ];
    
    static const WCHAR   szApartment[]  = L"Apartment";
    static const WCHAR   szFree[]       = L"Free";
    static const WCHAR   szCaller[]     = L"Both";
    PCWSTR  pszModelName = NULL;
    size_t  cchModelName = 0;
    
    if ( ( pClassInfoIn == NULL ) || ( hkeyCLSIDIn == NULL ) || ( pcrIn == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    Assert( pClassInfoIn->pClassID != NULL );

    //  Create CLSID guid subkey.
    if ( StringFromGUID2( *( pClassInfoIn->pClassID ), szCLSID, ( int ) RTL_NUMBER_OF( szCLSID ) ) == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    TraceMsg( mtfALWAYS, L"Registering %ws - %ws", szCLSID, pClassInfoIn->pcszName );
    hr = THR( HrCreateRegKey( hkeyCLSIDIn, szCLSID, &hkCurrentCLSID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Write class name as default value for clsid guid key.
    hr = THR( HrSetRegStringValue( hkCurrentCLSID, NULL, pClassInfoIn->pcszName, pClassInfoIn->cchName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    //  Under CLSID guid subkey,

    //  -- Create InprocServer32 key.
    hr = THR( HrCreateRegKey( hkCurrentCLSID, L"InprocServer32", &hkInprocServer32 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Set dll path as default value for InprocServer32 key.
    hr = THR( HrSetRegStringValue( hkInprocServer32, NULL, g_szDllFilename, wcslen( g_szDllFilename ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  -- Set ThreadingModel value for InprocServer32.
    switch ( pClassInfoIn->ectm )
    {
        case ctmFree:
            pszModelName = szFree;
            cchModelName = RTL_NUMBER_OF( szFree ) - 1;
        break;

        case ctmApartment:
            pszModelName = szApartment;
            cchModelName = RTL_NUMBER_OF( szApartment ) - 1;
        break;

        default:
            pszModelName = szCaller;
            cchModelName = RTL_NUMBER_OF( szCaller ) - 1;
    } // switch: pClassInfoIn->ectm

    hr = THR( HrSetRegStringValue( hkInprocServer32, L"ThreadingModel", pszModelName, cchModelName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //  -- Create ProgID key if class has a ProgID.
    if ( pClassInfoIn->pcszProgID != NULL )
    {
        hr = THR( HrCreateRegKey( hkCurrentCLSID, L"ProgID", &hkProgIDunderCLSID ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  -- Set ProgID text as default value for HKCR\CLSID\[clsid]\ProgID key.
        hr = THR( HrSetRegStringValue( hkProgIDunderCLSID, NULL, pClassInfoIn->pcszProgID, pClassInfoIn->cchProgID ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  Create ProgID key under HKCR.
        hr = THR( HrCreateRegKey( HKEY_CLASSES_ROOT, pClassInfoIn->pcszProgID, &hkProgIDunderHKCR ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  -- Set ProgID text as default value for HKCR\[ProgID] key.
        hr = THR( HrSetRegStringValue( hkProgIDunderHKCR, NULL, pClassInfoIn->pcszName, pClassInfoIn->cchName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  Create CLSID subkey under ProgID key.
        hr = THR( HrCreateRegKey( hkProgIDunderHKCR, L"CLSID", &hkCLSIDunderProgID ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  -- Set CLSID string as default value for HKCR\[ProgID]\CLSID key.
        hr = THR( HrSetRegStringValue( hkCLSIDunderProgID, NULL, szCLSID, RTL_NUMBER_OF( szCLSID ) - 1 ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: class has a ProgID

    //  -- If class has an AppID, create AppID value.
    if ( pClassInfoIn->pAppID != NULL )
    {
        if ( StringFromGUID2( *( pClassInfoIn->pAppID ), szAppID, ( int ) RTL_NUMBER_OF( szAppID ) ) == 0 )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        }

        hr = THR( HrSetRegStringValue( hkCurrentCLSID, L"AppID", szAppID, RTL_NUMBER_OF( szAppID ) - 1 ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: class has an AppID
    
    //  If class implements categories, call category registrar with TRUE to create.
    if ( pClassInfoIn->pfnRegisterCatID != NULL )
    {
        hr = THR( pClassInfoIn->pfnRegisterCatID( pcrIn, TRUE ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    
Cleanup:

    if ( hkCurrentCLSID != NULL )
    {
        TW32( RegCloseKey( hkCurrentCLSID ) );
    }

    if ( hkInprocServer32 != NULL )
    {
        TW32( RegCloseKey( hkInprocServer32 ) );
    }

    if ( hkProgIDunderCLSID != NULL )
    {
        TW32( RegCloseKey( hkProgIDunderCLSID ) );
    }
    
    if ( hkProgIDunderHKCR != NULL )
    {
        TW32( RegCloseKey( hkProgIDunderHKCR ) );
    }
    
    if ( hkCLSIDunderProgID != NULL )
    {
        TW32( RegCloseKey( hkCLSIDunderProgID ) );
    }
    
    HRETURN( hr );

} //*** HrRegisterPublicClass


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterPublicClasses
//
//  Description:
//      Write registry settings for every populated element of the global
//      g_DllPublicClasses array under HKCR and HKCR\CLSID.
//
//  Arguments:
//      pcrIn
//          An instance of the standard component category manager.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterPublicClasses( ICatRegister * pcrIn )
{
    TraceFunc( "" );

    HRESULT                   hr = S_OK;
    HKEY                      hkCLSID = NULL;
    const SPublicClassInfo*   pClassInfo = g_DllPublicClasses;    
    
    if ( pcrIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Open CLSID key.
    hr = THR( HrOpenRegKey( HKEY_CLASSES_ROOT, L"CLSID", &hkCLSID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //  Register each public class.
    while ( pClassInfo->pClassID != NULL )
    {
        hr = THR( HrRegisterPublicClass( pClassInfo, hkCLSID, pcrIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        ++pClassInfo;
    } // while: more classis in the public class table
    
Cleanup:

    if ( hkCLSID != NULL )
    {
        TW32( RegCloseKey( hkCLSID ) );
    }
    
    HRETURN( hr );

} //*** HrRegisterPublicClasses


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadTypeLibrary
//
//  Description:
//      Given an STypeLibInfo struct describing a type library resource
//      in this executable's file and a value from the REGKIND enumeration,
//      call LoadTypeLibEx with a string formatted to refer to the specified
//      resource and return the resulting type library instance.
//
//  Arguments:
//      pTypeLibInfoIn
//          A struct describing the desired type library resource.
//
//      rkRegFlagsIn
//          A value from the REGKIND enumeration specifying whether to
//          register the library after loading it.
//
//      pptlOut
//          The loaded type library instance.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrLoadTypeLibrary(
      const STypeLibInfo *  pTypeLibInfoIn
    , REGKIND               rkRegFlagsIn
    , ITypeLib **           pptlOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    WCHAR       wszLibraryPath[ MAX_PATH + 12 ]; // path + slash + decimal integer

    if ( pptlOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pptlOut = NULL;

    if ( pTypeLibInfoIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR ( StringCchPrintfW(
                      wszLibraryPath
                    , RTL_NUMBER_OF( wszLibraryPath )
                    , L"%ws\\%d"
                    , g_szDllFilename
                    , pTypeLibInfoIn->idTypeLibResource
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( LoadTypeLibEx( wszLibraryPath, rkRegFlagsIn, pptlOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    HRETURN( hr );

} //*** HrLoadTypeLibrary


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterTypeLibrary
//
//  Description:
//      Given an STypeLibInfo struct describing a type library resource
//      in this executable's file, register the corresponding type library.
//
//  Arguments:
//      pTypeLibInfoIn
//          A struct describing the desired type library resource.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterTypeLibrary( const STypeLibInfo *  pTypeLibInfoIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    ITypeLib *  ptl = NULL;

    hr = THR( HrLoadTypeLibrary( pTypeLibInfoIn, REGKIND_REGISTER, &ptl ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ptl != NULL )
    {
        ptl->Release();
    }
    
    HRETURN( hr );

} //*** HrRegisterTypeLibrary


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterTypeLibrary
//
//  Description:
//      Write registry settings for every populated element of the global
//      g_DllTypeLibs array.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrRegisterTypeLibraries( void )
{
    TraceFunc( "" );

    HRESULT               hr = S_OK;
    const STypeLibInfo *  pTypeLibInfo = g_DllTypeLibs;

    while ( !pTypeLibInfo->fAtEnd  )
    {
        hr = THR( HrRegisterTypeLibrary( pTypeLibInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        ++pTypeLibInfo;
    } // while: more type libraries to register
    
Cleanup:

    HRETURN( hr );

} //*** HrRegisterTypeLibraries


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterAppIDs
//
//  Description:
//      Remove registry settings for every populated element of the global
//      g_AppIDs array from under HKCR\AppID.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//  Remarks:
//      The registry manipulation functions return failure codes when a
//      given key doesn't exist, but because unregistration has that as its
//      goal, the function's failure is not fatal.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrUnregisterAppIDs( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    HKEY                hkAppID = NULL;
    const SAppIDInfo *  pAppIDInfo = g_AppIDs;    
    
    //  Open AppID subkey under HKCR.
    hr = THR( HrOpenRegKey( HKEY_CLASSES_ROOT, L"AppID", &hkAppID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //  For each AppID,
    while ( pAppIDInfo->pAppID != NULL )
    {
        OLECHAR szAppID[ MAX_COM_GUID_STRING_LEN ];

        if ( StringFromGUID2( *( pAppIDInfo->pAppID ), szAppID, ( int ) RTL_NUMBER_OF( szAppID ) ) == 0 )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        }
        
        //  Delete key for guid under AppID.
        hr = THR( HrDeleteRegKey( hkAppID, szAppID ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  If identity is LocalService or NetworkService, delete password from registry.
        if ( ( pAppIDInfo->eairai == airaiLocalService )
            || ( pAppIDInfo->eairai == airaiNetworkService ) )
        {
            THR( HrStoreAppIDPassword( szAppID, NULL ) );
        }
        ++pAppIDInfo;
    } // for each AppID
    
Cleanup:

    if ( hkAppID != NULL )
    {
        TW32( RegCloseKey( hkAppID ) );
    }

    HRETURN( hr );

} //*** HrUnregisterAppIDs


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterPublicClasses
//
//  Description:
//      Remove registry settings for every populated element of the global
//      g_DllPublicClasses array from under HKCR and HKCR\CLSID.
//
//  Arguments:
//      pcrIn
//          An instance of the standard component category manager.
//
//  Return Values:
//      S_OK, or not.
//
//  Remarks:
//      The registry manipulation functions return failure codes when a
//      given key doesn't exist, but because unregistration has that as its
//      goal, the function's failure is not fatal.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrUnregisterPublicClasses( ICatRegister* pcrIn )
{
    TraceFunc( "" );

    HRESULT                   hr = S_OK;
    HKEY                      hkCLSID = NULL;
    const SPublicClassInfo *  pClassInfo = g_DllPublicClasses;    

    if ( pcrIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  Open the CLSID key.
    hr = THR( HrOpenRegKey( HKEY_CLASSES_ROOT, L"CLSID", &hkCLSID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //  For each public class,
    while ( pClassInfo->pClassID != NULL )
    {
        OLECHAR szCLSID[ MAX_COM_GUID_STRING_LEN ];
        if ( StringFromGUID2( *( pClassInfo->pClassID ), szCLSID, ( int ) RTL_NUMBER_OF( szCLSID ) ) == 0 )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        }
        
        //  Delete the CLSID guid subkey under CLSID.
        hr = THR( HrDeleteRegKey( hkCLSID, szCLSID ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        
        //  Delete the ProgID key under HKCR.
        if ( pClassInfo->pcszProgID != NULL )
        {
            hr = THR( HrDeleteRegKey( HKEY_CLASSES_ROOT, pClassInfo->pcszProgID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        //  If class implements categories, call category registrar with FALSE to delete.
        if ( pClassInfo->pfnRegisterCatID != NULL )
        {
            THR( pClassInfo->pfnRegisterCatID( pcrIn, FALSE ) );
        }
        ++pClassInfo;
    } // while: more public classes
    
Cleanup:

    if ( hkCLSID != NULL )
    {
        TW32( RegCloseKey( hkCLSID ) );
    }
    
    HRETURN( hr );

} //*** HrUnregisterPublicClasses


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterTypeLibrary
//
//  Description:
//      Given an STypeLibInfo struct describing a type library resource
//      in this executable's file, unregister the corresponding type library.
//
//  Arguments:
//      pTypeLibInfoIn
//          A struct describing the desired type library resource.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrUnregisterTypeLibrary( const STypeLibInfo *  pTypeLibInfoIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    ITypeLib *  ptl = NULL;
    TLIBATTR *  ptla = NULL;

    hr = THR( HrLoadTypeLibrary( pTypeLibInfoIn, REGKIND_NONE, &ptl ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptl->GetLibAttr( &ptla ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    THR( UnRegisterTypeLib( ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind ) );

Cleanup:

    if ( ptl != NULL )
    {
        if ( ptla != NULL )
        {
            ptl->ReleaseTLibAttr( ptla );
        }        
        ptl->Release();
    }
    
    HRETURN( hr );

} //*** HrUnregisterTypeLibrary


///////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterTypeLibraries
//
//  Description:
//      Remove from the registry type library entries for each type library
//      resource described in g_DllTypeLibs.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//--
///////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrUnregisterTypeLibraries( void )
{
    TraceFunc( "" );

    HRESULT               hr = S_OK;
    const STypeLibInfo *  pTypeLibInfo = g_DllTypeLibs;

    while ( !pTypeLibInfo->fAtEnd  )
    {
        THR( HrUnregisterTypeLibrary( pTypeLibInfo ) );
        ++pTypeLibInfo;
    }

    HRETURN( hr );

} //*** HrUnregisterTypeLibraries




//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRegisterDll
//
//  Description:
//      Create this dll's COM registration entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterDll( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    ICatRegister *  picr = NULL;
    
    //  Get category manager.
    hr = THR( CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_ICatRegister
                    , reinterpret_cast< void **>( &picr )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Register public classes.
    hr = THR( HrRegisterPublicClasses( picr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Register app ids.
    hr = THR( HrRegisterAppIDs() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
#if defined( COMPONENT_HAS_CATIDS )
    //  Register categories.
    hr = THR( HrRegisterComponentCategories( picr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
#endif // defined( COMPONENT_HAS_CATIDS )
    
#if defined( MMC_SNAPIN_REGISTRATION )
    //
    // Register the "Snapins".
    //
    hr = THR( HrRegisterSnapins( g_SnapInTable, fCreateIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Register "other" NodeTypes (those not associated with a Snapin).
    //
    hr = THR( HrRegisterNodeType( g_SNodeTypesTable, fCreateIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // defined( MMC_SNAPIN_REGISTRATION )


    //  Register type libraries.
    hr = THR( HrRegisterTypeLibraries() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    if ( picr != NULL )
    {
        picr->Release();
    }
    
    HRETURN( hr );

} //*** HrRegisterDll



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrUnregisterDll
//
//  Description:
//      Erase this dll's COM registration entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK, or not.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrUnregisterDll( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    ICatRegister *  picr = NULL;
    
    //  Get category manager.
    hr = THR( CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_ICatRegister
                    , reinterpret_cast< void ** >( &picr )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //  Delete public classes.
    THR( HrUnregisterPublicClasses( picr ) );

    //  Delete app ids.
    THR( HrUnregisterAppIDs() );

#if defined( COMPONENT_HAS_CATIDS )
    //  Delete categories.
    THR( HrUnregisterComponentCategories( picr ) );
#endif // defined( COMPONENT_HAS_CATIDS )

    //  Unregister type libraries.
    THR( HrUnregisterTypeLibraries() );

Cleanup:

    if ( picr != NULL )
    {
        picr->Release();
    }
    
    HRETURN( hr );

} //*** HrUnregisterDll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetres\clnetres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClNetRes.cpp
//
//  Description:
//      Resource DLL for DHCP and WINS Services (ClNetRes).
//
//  Maintained By:
//      David Potter (DavidP) March 17, 1999
//      George Potts (GPotts) April 19, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "clusres.h"
#include "ClNetRes.h"
#include "clusrtl.h"

//
// Global data.
//

// Event Logging routine.

PLOG_EVENT_ROUTINE g_pfnLogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus = NULL;

// Handle to Service Control Manager set by the first Open resource call.

SC_HANDLE g_schSCMHandle = NULL;


//
// Function prototypes.
//

BOOLEAN WINAPI DllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );

DWORD ConfigureRegistryCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );

DWORD ConfigureCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );

DWORD ConfigureDomesticCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    BOOLEAN bSuccess = TRUE;

    //
    // Perform global initialization.
    //
    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hDllHandle );
            break;

        case DLL_PROCESS_DETACH:
            break;

    } // switch: nReason

    //
    // Pass this request off to the resource type-specific routines.
    //
    if ( ! DhcpDllMain( hDllHandle, nReason, Reserved ) )
    {
        bSuccess = FALSE;
    } // if: error calling DHCP Service routine
    else if ( ! WinsDllMain( hDllHandle, nReason, Reserved ) )
    {
        bSuccess = FALSE;
    } // else if: error calling WINS Service routine

    if ( bSuccess )
    {
        if ( nReason == DLL_PROCESS_ATTACH )
        {
            ClRtlInitialize( TRUE, NULL );
            ClRtlInitWmi(NULL);
        }
        else if ( nReason == DLL_PROCESS_DETACH )
        {
            ClRtlCleanup();
        }
    }

    return bSuccess;

} //*** DllMain()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  Startup
//
//  Description:
//      Startup the resource DLL. This routine verifies that at least one
//      currently supported version of the resource DLL is between
//      nMinVersionSupported and nMaxVersionSupported. If not, then the
//      resource DLL should return ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus;

    //
    // Save callbackup function pointers if they haven't been saved yet.
    //
    if ( g_pfnLogEvent == NULL )
    {
        g_pfnLogEvent = pfnLogEvent;
        g_pfnSetResourceStatus = pfnSetResourceStatus;
    } // if: function pointers specified

    //
    // Call the resource type-specific Startup routine.
    //
    if ( ClRtlStrNICmp( pszResourceType, DHCP_RESNAME, RTL_NUMBER_OF( DHCP_RESNAME ) ) == 0 )
    {
        nStatus = DhcpStartup(
                        pszResourceType,
                        nMinVersionSupported,
                        nMaxVersionSupported,
                        pfnSetResourceStatus,
                        pfnLogEvent,
                        pFunctionTable
                        );
    } // if: DHCP Service resource type
    else if ( ClRtlStrNICmp( pszResourceType, WINS_RESNAME, RTL_NUMBER_OF( WINS_RESNAME ) ) == 0 )
    {
        nStatus = WinsStartup(
                        pszResourceType,
                        nMinVersionSupported,
                        nMaxVersionSupported,
                        pfnSetResourceStatus,
                        pfnLogEvent,
                        pFunctionTable
                        );
    } // if: WINS Service resource type
    else
    {
        nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported

    return nStatus;

} //*** Startup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureRegistryCheckpoints
//
//  Description:
//      Configure registry key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureRegistryCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;

    //
    // Set registry key checkpoints if we need them.
    //
    for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
    {
        nStatus = ClusterResourceControl(
                        hResource,
                        NULL,
                        CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                        reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                        (DWORD) (wcslen( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                        NULL,
                        0,
                        &cbReturn
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            if ( nStatus == ERROR_ALREADY_EXISTS )
            {
                nStatus = ERROR_SUCCESS;
            } // if: checkpoint already exists
            else
            {
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ConfigureRegistryCheckpoints: Failed to set registry checkpoint '%1'. Error: %2!u! (%2!#08x!).\n",
                    *ppszCurrent,
                    nStatus
                    );
                break;
            } // else: other error occurred
        } // if: error adding the checkpoint
    } // for: each checkpoint

    return nStatus;

} //*** ConfigureRegistryCheckpoints()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureCryptoKeyCheckpoints
//
//  Description:
//      Configure crypto key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;

    //
    // Set crypto key checkpoints if we need them.
    //
    for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
    {
        nStatus = ClusterResourceControl(
                        hResource,
                        NULL,
                        CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                        reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                        (DWORD) (wcslen( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                        NULL,
                        0,
                        &cbReturn
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            if ( nStatus == ERROR_ALREADY_EXISTS )
            {
                nStatus = ERROR_SUCCESS;
            } // if: checkpoint already exists
            else
            {
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ConfigureCryptoKeyCheckpoints: Failed to set crypto key checkpoint '%1'. Error: %2!u! (%2!#08x!).\n",
                    *ppszCurrent,
                    nStatus
                    );
                break;
            } // else: other error occurred
        } // if: error adding the checkpoint
    } // for: each checkpoint

    return nStatus;

} //*** ConfigureCryptoKeyCheckpoints()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureDomesticCryptoKeyCheckpoints
//
//  Description:
//      Configure domestic (128-bit) crypto key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureDomesticCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;
    HCRYPTPROV  hProv = NULL;

    //
    // Set crypto key checkpoints if we need them.
    //
    if ( *ppszKeys != NULL )
    {
        if ( CryptAcquireContextA(
                    &hProv,
                    NULL,
                    MS_ENHANCED_PROV_A,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                    ) )
        {
            CryptReleaseContext( hProv, 0 );
            for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
            {
                nStatus = ClusterResourceControl(
                                hResource,
                                NULL,
                                CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                                (DWORD) (wcslen( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                                NULL,
                                0,
                                &cbReturn
                                );
                if ( nStatus != ERROR_SUCCESS )
                {
                    if ( nStatus == ERROR_ALREADY_EXISTS )
                    {
                        nStatus = ERROR_SUCCESS;
                    } // if: checkpoint already exists
                    else
                    {
                        (g_pfnLogEvent)(
                            hResourceHandle,
                            LOG_ERROR,
                            L"ConfigurDomesticCryptoKeyCheckpoints: Failed to set domestic crypto key checkpoint '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
                            *ppszCurrent,
                            nStatus
                            );
                        break;
                    } // else: other error occurred
                } // if: error adding the checkpoint
            } // for: each checkpoint
        } // if: acquired domestic crypto context
        else
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ConfigurDomesticCryptoKeyCheckpoints: Failed to acquire a domest crypto context. Error: %2!u! (%2!#08x!).\n",
                nStatus
                );
        } // else: error acquiring domestic crypto context
    } // if: domestic crypto keys need to be checkpointed

    return nStatus;

} //*** ConfigureDomesticCryptoKeyCheckpoints()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClNetResLogSystemEvent1
//
//  Description:
//      Log Event to the system event log.
//
//  Arguments:
//      LogLevel [IN]
//          Level of logging desired.
//
//      MessageId [IN]
//          The message ID of the error to be logged.
//
//      ErrorCode [IN]
//          The error code to be added for this error message.
//
//      Component [IN]
//          The name of the component reporting the error - e.g. "WINS" or
//          "DHCP"
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////

VOID
ClNetResLogSystemEvent1(
    IN DWORD LogLevel,
    IN DWORD MessageId,
    IN DWORD ErrorCode,
    IN LPCWSTR Component
    )
{
    DWORD Error = ErrorCode;

    UNREFERENCED_PARAMETER( LogLevel );

    ClusterLogEvent1(
        LOG_CRITICAL,
        0,
        0,
        0,
        MessageId,
        4,
        &Error,
        Component
    );

} //*** ClNetResLogSystemEvent1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetres\dhcp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Dhcp.cpp
//
//  Description:
//      Resource DLL for DHCP Services (ClNetRes).
//
//  Author:
//      David Potter (DavidP) March 17, 1999
//      George Potts (GPotts) April 19, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClNetRes.h"
#include "clusvmsg.h"
#include "clusrtl.h"

//
// Type and constant definitions.
//

#define DHCP_PARAMS_REGKEY          L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define DHCP_BIND_REGVALUE          L"Bind"
#define DHCP_DATABASEPATH_REGVALUE  L"DatabasePath"
#define DHCP_LOGFILEPATH_REGVALUE   L"DhcpLogFilePath"
#define DHCP_BACKUPPATH_REGVALUE    L"BackupDatabasePath"
#define DHCP_CLUSRESNAME_REGVALUE   L"ClusterResourceName"

#define CLUSREG_NAME_RES_TYPE   L"Type"

//
// Allow for the following number of IP address/SubnetMask for expansion.
// In this case (2 new entries, since it takes 2 slots for each).
//
#define IP_BLOCK_SIZE  4


// ADDPARAM: Add new properties here.
#define PROP_NAME__DATABASEPATH L"DatabasePath"
#define PROP_NAME__LOGFILEPATH  L"LogFilePath"
#define PROP_NAME__BACKUPPATH   L"BackupPath"

#define PROP_DEFAULT__DATABASEPATH  L"%SystemRoot%\\system32\\dhcp\\"
#define PROP_DEFAULT__BACKUPPATH    L"%SystemRoot%\\system32\\dhcp\\backup\\"

// ADDPARAM: Add new properties here.
typedef struct _DHCP_PROPS
{
    PWSTR           pszDatabasePath;
    PWSTR           pszLogFilePath;
    PWSTR           pszBackupPath;
} DHCP_PROPS, * PDHCP_PROPS;

typedef struct _DHCP_RESOURCE
{
    RESID                   resid; // for validation
    DHCP_PROPS              props;
    HCLUSTER                hCluster;
    HRESOURCE               hResource;
    SC_HANDLE               hService;
    DWORD                   dwServicePid;
    HKEY                    hkeyParameters;
    RESOURCE_HANDLE         hResourceHandle;
    LPWSTR                  pwszResourceName;
    CLUS_WORKER             cwWorkerThread;
    CLUSTER_RESOURCE_STATE  state;
} DHCP_RESOURCE, * PDHCP_RESOURCE;


//
// Global data.
//

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_DhcpFunctionTable;

// Single instance semaphore.

#define DHCP_SINGLE_INSTANCE_SEMAPHORE L"Cluster$DHCP$Semaphore"
static HANDLE g_hSingleInstanceSemaphoreDhcp = NULL;
static PDHCP_RESOURCE g_pSingleInstanceResourceDhcp = NULL;

//
// DHCP Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
DhcpResourcePrivateProperties[] =
{
    { PROP_NAME__DATABASEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszDatabasePath ) },
    { PROP_NAME__LOGFILEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszLogFilePath ) },
    { PROP_NAME__BACKUPPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszBackupPath ) },
    { 0 }
};

//
// Registry key checkpoints.
//
LPCWSTR g_pszRegKeysDhcp[] =
{
    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters",
    L"Software\\Microsoft\\DHCPServer\\Configuration",
    NULL
};

//
// Function prototypes.
//

RESID WINAPI DhcpOpen(
    IN  LPCWSTR         pwszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    );

void WINAPI DhcpClose( IN RESID resid );

DWORD WINAPI DhcpOnline(
    IN      RESID   resid,
    IN OUT  PHANDLE phEventHandle
    );

DWORD WINAPI DhcpOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    );

DWORD DhcpBuildBindings(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT PVOID *         ppOutBuffer,
    OUT size_t *        pcbOutBufferSize
    );

DWORD DhcpGetIPList(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT LPWSTR **       pppszIPList,
    OUT size_t *        pcszIPAddrs
    );

DWORD DhcpGetIpAndSubnet(
    IN  HRESOURCE   hres,
    OUT LPWSTR *    ppszIPAddress,
    OUT LPWSTR *    ppszSubnetMask
    );

DWORD WINAPI DhcpOffline( IN RESID resid );

DWORD WINAPI DhcpOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    );

void WINAPI DhcpTerminate( IN RESID resid );

BOOL WINAPI DhcpLooksAlive( IN RESID resid );

BOOL WINAPI DhcpIsAlive( IN RESID resid );

BOOL DhcpCheckIsAlive(
    IN PDHCP_RESOURCE   pResourceEntry,
    IN BOOL             fFullCheck
    );

DWORD WINAPI DhcpResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );
DWORD WINAPI DhcpResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD DhcpGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD DhcpReadParametersToParameterBlock(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    );

DWORD DhcpGetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    );

DWORD DhcpValidatePrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PDHCP_PROPS     pProps
    );

DWORD DhcpValidateParameters(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps
    );

DWORD DhcpSetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize
    );

DWORD DhcpZapSystemRegistry(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    );

DWORD DhcpGetDefaultPropertyValues(
    IN      PDHCP_RESOURCE  pResourceEntry,
    IN OUT  PDHCP_PROPS     pProps
    );

DWORD DhcpDeleteResourceHandler( IN OUT PDHCP_RESOURCE pResourceEntry );

DWORD DhcpSetNameHandler(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpDllMain
//
//  Description:
//      Main DLL entry point for the DHCP Service resource type.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DhcpDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    DWORD   sc;
    BOOLEAN fSuccess = FALSE;

    UNREFERENCED_PARAMETER( hDllHandle );
    UNREFERENCED_PARAMETER( Reserved );

    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            g_hSingleInstanceSemaphoreDhcp = CreateSemaphoreW(
                NULL,
                0,
                1,
                DHCP_SINGLE_INSTANCE_SEMAPHORE
                );
            sc = GetLastError();
            if ( g_hSingleInstanceSemaphoreDhcp == NULL )
            {
                fSuccess = FALSE;
                goto Cleanup;
            } // if: error creating semaphore
            if ( sc != ERROR_ALREADY_EXISTS )
            {
                // If the semaphore didnt exist, set its initial count to 1.
                ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1, NULL );
            } // if: semaphore didn't already exist
            break;

        case DLL_PROCESS_DETACH:
            if ( g_hSingleInstanceSemaphoreDhcp != NULL )
            {
                CloseHandle( g_hSingleInstanceSemaphoreDhcp );
                g_hSingleInstanceSemaphoreDhcp = NULL;
            } // if: single instance semaphore was created
            break;

    } // switch: nReason

    fSuccess = TRUE;

Cleanup:

    return fSuccess;

} //*** DhcpDllMain


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpStartup
//
//  Description:
//      Startup the resource DLL for the DHCP Service resource type.
//      This routine verifies that at least one currently supported version
//      of the resource DLL is between nMinVersionSupported and
//      nMaxVersionSupported. If not, then the resource DLL should return
//      ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD sc;

    // These are stored to globals in the exported DLL Startup.
    UNREFERENCED_PARAMETER( pfnSetResourceStatus );
    UNREFERENCED_PARAMETER( pfnLogEvent );

    if (   (nMinVersionSupported > CLRES_VERSION_V1_00)
        || (nMaxVersionSupported < CLRES_VERSION_V1_00) )
    {
        sc = ERROR_REVISION_MISMATCH;
    } // if: version not supported
    else if ( ClRtlStrNICmp( pszResourceType, DHCP_RESNAME, RTL_NUMBER_OF( DHCP_RESNAME ) ) != 0 )
    {
        sc = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported
    else
    {
        *pFunctionTable = &g_DhcpFunctionTable;
        sc = ERROR_SUCCESS;
    } // else: we support this type of resource

    return sc;

} //*** DhcpStartup


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOpen
//
//  Description:
//      Open routine for DHCP Service resources.
//
//      Open the specified resource (create an instance of the resource).
//      Allocate all structures necessary to bring the specified resource
//      online.
//
//  Arguments:
//      pwszResourceName [IN]
//          Supplies the name of the resource to open.
//
//      hkeyResourceKey [IN]
//                  Supplies handle to the resource's cluster database key.
//
//      hResourceHandle [IN]
//          A handle that is passed back to the Resource Monitor when the
//          SetResourceStatus or LogEvent method is called.  See the
//          description of the pfnSetResourceStatus and pfnLogEvent arguments
//          to the DhcpStartup routine.  This handle should never be
//          closed or used for any purpose other than passing it as an
//          argument back to the Resource Monitor in the SetResourceStatus or
//          LogEvent callbacks.
//
//  Return Value:
//      resid
//          RESID of opened resource.
//
//      NULL
//          Error occurred opening the resource.  Resource Monitor may call
//          GetLastError() to get more details on the error.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI DhcpOpen(
    IN  LPCWSTR         pwszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    )
{
    DWORD           sc;
    size_t          cch;
    RESID           resid = 0;
    HKEY            hkeyParameters = NULL;
    PDHCP_RESOURCE  pResourceEntry = NULL;
    DWORD           fSemaphoreAcquired = FALSE;
    HRESULT         hr = S_OK;

    //
    //  Add a log entry for our resource to establish a tid -> res name relationship.  By 
    //  doing this we avoid having to add the resource name to each failure entry below.
    //  This won't generate much noise because Open is only called when the cluster service
    //  comes online or when the resource is created.
    //
    (g_pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"Open called.\n"
        );

    //
    // Check if there is more than one resource of this type.
    //
    sc = WaitForSingleObject( g_hSingleInstanceSemaphoreDhcp, 0 );
    if ( sc != WAIT_OBJECT_0 )
    {
        //
        // A version of this service is already running or the wait failed.
        //
        if ( sc == WAIT_TIMEOUT )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Another DHCP Service resource is already open.\n"
                );
            sc = ERROR_SERVICE_ALREADY_RUNNING;
        }
        else
        {
            if ( sc == WAIT_FAILED ) 
            {
                sc = GetLastError();
            }
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: wait failed: %1!d!.\n",
                sc
                );
        }
        goto Cleanup;
    } // if: semaphore for resources of this type already already locked

    sc = ERROR_SUCCESS;
    fSemaphoreAcquired = TRUE;

    if ( g_pSingleInstanceResourceDhcp != NULL )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Service resource info non-null!\n"
            );
        sc = ERROR_DUPLICATE_SERVICE_NAME;
        goto Cleanup;
    } // if: resource of this type already exists

    //
    // Get a global handle to the Service Control Manager (SCM).
    // There is no call to CloseSCManager(), since the only time we will
    // need to close this handle is if we are shutting down.
    //
    if ( g_schSCMHandle == NULL )
    {
        g_schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
        if ( g_schSCMHandle == NULL )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Failed to open Service Control Manager. Error: %1!u! (%1!#08x!).\n",
                sc
                );
            goto Cleanup;
        } // if: error opening the Service Control Manager
    } // if: Service Control Manager not open yet

    //
    // Make sure the service has been stopped.
    //
    sc = ResUtilStopResourceService( DHCP_SVCNAME );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Failed to stop the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
            DHCP_SVCNAME,
            sc
            );
        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_STOP_ERROR,
            sc,
            L"DHCP" );
    } // if: error stopping the service

    //
    // Open the Parameters registry key for this resource.
    //
    sc = ClusterRegOpenKey(
                    hkeyResourceKey,
                    L"Parameters",
                    KEY_ALL_ACCESS,
                    &hkeyParameters
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open Parameters key. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error creating the Parameters key for the resource

    //
    // Allocate a resource entry.
    //
    pResourceEntry = new DHCP_RESOURCE;
    if ( pResourceEntry == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to allocate resource entry structure. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error allocating memory for the resource

    //
    // Initialize the resource entry..
    //
    ZeroMemory( pResourceEntry, sizeof( *pResourceEntry ) );

    pResourceEntry->resid = static_cast< RESID >( pResourceEntry ); // for validation
    pResourceEntry->hResourceHandle = hResourceHandle;
    pResourceEntry->hkeyParameters = hkeyParameters;
    hkeyParameters = NULL;
    pResourceEntry->state = ClusterResourceOffline;

    //
    // Save the name of the resource.
    //
    cch = wcslen( pwszResourceName ) + 1;
    pResourceEntry->pwszResourceName = new WCHAR[ cch ];
    if ( pResourceEntry->pwszResourceName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if: error allocating memory for the name.

    hr = StringCchCopyW( pResourceEntry->pwszResourceName, cch, pwszResourceName );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    //
    // Open the cluster.
    //
    pResourceEntry->hCluster = OpenCluster( NULL );
    if ( pResourceEntry->hCluster == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the cluster. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the cluster

    //
    // Open the resource.
    //
    pResourceEntry->hResource = OpenClusterResource( pResourceEntry->hCluster, pwszResourceName );
    if ( pResourceEntry->hResource == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the resource. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the resource

    //
    // Configure registry key checkpoints.
    //
    sc = ConfigureRegistryCheckpoints(
                    pResourceEntry->hResource,
                    hResourceHandle,
                    g_pszRegKeysDhcp
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error configuring registry key checkpoints

    //
    // Startup for the resource.
    //
    // TODO: Add your resource startup code here.

    resid = static_cast< RESID >( pResourceEntry );
    g_pSingleInstanceResourceDhcp = pResourceEntry; // bug #274612
    pResourceEntry = NULL;

    sc = ERROR_SUCCESS;

Cleanup:

    if ( hkeyParameters != NULL )
    {
        ClusterRegCloseKey( hkeyParameters );
    } // if: registry key was opened

    if ( pResourceEntry != NULL )
    {
        if ( pResourceEntry->hResource != NULL )
        {
            CloseClusterResource( pResourceEntry->hResource );
        }

        if ( pResourceEntry->hCluster != NULL )
        {
            CloseCluster( pResourceEntry->hCluster );
        }

        delete [] pResourceEntry->pwszResourceName;
        delete pResourceEntry;
    } // if: resource entry allocated

    if ( sc != ERROR_SUCCESS && fSemaphoreAcquired ) 
    { 
        ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1 , NULL );
    } 

    SetLastError( sc );

    return resid;

} //*** DhcpOpen


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpClose
//
//  Description:
//      Close routine for DHCP Service resources.
//
//      Close the specified resource and deallocate all structures, etc.,
//      allocated in the Open call.  If the resource is not in the offline
//      state, then the resource should be taken offline (by calling
//      Terminate) before the close operation is performed.
//
//  Arguments:
//      resid       [IN] Supplies the resource ID  of the resource to close.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DhcpClose( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Close request for a NULL resource id.\n" );
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Close: Resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Close request for resource '%1!ws!'.\n",
        pResourceEntry->pwszResourceName
        );
#endif // LOG_VERBOSE

    //
    // Close the Parameters key.
    //
    if ( pResourceEntry->hkeyParameters )
    {
        ClusterRegCloseKey( pResourceEntry->hkeyParameters );
    } // if: parameters key is open

    //
    // Clean up the semaphore if this is the single resource instance.
    //
    if ( pResourceEntry == g_pSingleInstanceResourceDhcp )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"Close: Releasing semaphore '%1!ws!'.\n",
            DHCP_SINGLE_INSTANCE_SEMAPHORE
            );
        g_pSingleInstanceResourceDhcp = NULL;
        ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1 , NULL );
    } // if: this is the single resource instance

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new propertiess here.
    LocalFree( pResourceEntry->props.pszDatabasePath );
    LocalFree( pResourceEntry->props.pszLogFilePath );
    LocalFree( pResourceEntry->props.pszBackupPath );
    delete [] pResourceEntry->pwszResourceName;
    delete pResourceEntry;

Cleanup:

    SetLastError( ERROR_SUCCESS );

    return;

} //*** DhcpClose


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOnline
//
//  Description:
//      Online routine for DHCP Service resources.
//
//      Bring the specified resource online (available for use).  The resource
//      DLL should attempt to arbitrate for the resource if it is present on
//      a shared medium, like a shared SCSI bus.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be brought online
//          (available for use).
//
//      phEventHandle [IN OUT]
//          Returns a signalable handle that is signaled when the resource DLL
//          detects a failure on the resource.  This argument is NULL on
//          input, and the resource DLL returns NULL if asynchronous
//          notification of failurs is not supported.  Otherwise this must be
//          the address of a handle that is signaled on resource failures.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now online.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is pending.  A thread has been activated to process
//          the online request.  The thread that is processing the online
//          request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOnline state (or the resource monitor
//          decides to timeout the online request and Terminate the resource.
//          This pending timeout value is settable and has a default value of
//          3 minutes.).
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOnline(
    IN      RESID       resid,
    IN OUT  PHANDLE     phEventHandle
    )
{
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           sc;

    UNREFERENCED_PARAMETER( phEventHandle );

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Online request for a NULL resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Service sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n"
        );
#endif // LOG_VERBOSE

    //
    // Start the Online thread to perform the online operation.
    //
    pResourceEntry->state = ClusterResourceOffline;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    sc = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( DhcpOnlineThread ),
                pResourceEntry
                );
    if ( sc != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread. Error: %1!u! (%1!#08x!).\n",
            sc
            );
    } // if: error creating the worker thread
    else
    {
        sc = ERROR_IO_PENDING;
        goto Cleanup;
    } // if: worker thread created successfully

Cleanup:

    return sc;

} //*** DhcpOnline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOnlineThread
//
//  Description:
//      Worker function which brings a resource online.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS         resourceStatus;
    DWORD                   sc = ERROR_SUCCESS;
    DWORD                   cbBytesNeeded;
    HKEY                    hkeyParamsKey = NULL;
    PVOID                   pvBindings = NULL;
    size_t                  cbBindings;
    SERVICE_STATUS_PROCESS  ServiceStatus = { 0 };
    RESOURCE_EXIT_STATE     resExitState;
    DWORD                   nRetryCount = 1200; // 10 min max

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // Create the new environment with the simulated net name when the
    // services queries GetComputerName.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) == FALSE )
    {
        sc = ResUtilSetResourceServiceEnvironment(
                        DHCP_SVCNAME,
                        pResourceEntry->hResource,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: error setting the environment for the service
    } // if: not terminating
    else
    {
        goto Cleanup;
    } // else: terminating

    //
    // Make sure the service is ready to be controlled by the cluster.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) == FALSE )
    {
        sc = ResUtilSetResourceServiceStartParameters(
                        DHCP_SVCNAME,
                        g_schSCMHandle,
                        &pResourceEntry->hService,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:  error setting service start parameters
    } // if: not terminating
    else
    {
        goto Cleanup;
    } // else: terminating

    //
    // Perform resource-specific initialization before starting the service.
    //
    // TODO: Add code to initialize the resource before starting the service.

    //
    // Stop the service if it's running since we are about to change
    // its parameters.
    //
    sc = ResUtilStopResourceService( DHCP_SVCNAME );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Failed to stop the '%1!ws!' service. Error %2!u! (%2!#08x!).\n",
            DHCP_SVCNAME,
            sc
            );
        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_STOP_ERROR,
            sc,
            L"DHCP" );
        goto Cleanup;
    } // if: error stopping the service

    //
    // Find IP Address bindings to give to DHCPServer.
    //
    sc =  DhcpBuildBindings(
                    pResourceEntry,
                    &pvBindings,
                    &cbBindings
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Failed to get bindings. Error %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error building bindings

    //
    // Open the DHCPServer\Parameters key.
    //
    sc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DHCP_PARAMS_REGKEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeyParamsKey
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Unable to open the '%1!ws!' key. Error %2!u! (%2!#08x!).\n",
            DHCP_PARAMS_REGKEY,
            sc
            );
        goto Cleanup;
    } // if: error opening the DHCP Server Parameters key

    //
    // Write bindings to DHCPServer\Parameters\Bind.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_BIND_REGVALUE,
                    0,
                    REG_MULTI_SZ,
                    static_cast< PBYTE >( pvBindings ),
                    (DWORD)cbBindings
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Unable to set the '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            DHCP_BIND_REGVALUE,
            sc
            );
        goto Cleanup;
    } // if: error writing the bindings

    //
    // Read our properties.
    //
    sc = DhcpReadParametersToParameterBlock( pResourceEntry, TRUE /* bCheckForRequiredProperties */ );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error reading parameters

    //
    // Validate our properties.
    //
    sc = DhcpValidateParameters( pResourceEntry, &pResourceEntry->props );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error validating parameters

    //
    // Write cluster properties to the system registry.
    //
    sc = DhcpZapSystemRegistry( pResourceEntry, &pResourceEntry->props, hkeyParamsKey );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error zapping the DHCP registry

    //
    // Start the service.
    //
    if ( StartServiceW( pResourceEntry->hService, 0, NULL ) == FALSE  )
    {
        sc = GetLastError();
        if ( sc != ERROR_SERVICE_ALREADY_RUNNING )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to start the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
                DHCP_SVCNAME,
                sc
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_START_ERROR,
                sc,
                L"DHCP" );
            goto Cleanup;
        } // if: error other than service already running occurred
        else
        {
            sc = ERROR_SUCCESS;
        } // if: service is already running
    } // if: error starting the service

    //
    // Query the status of the service in a loop until it leaves
    // the pending state.
    //
    while ( ( ClusWorkerCheckTerminate( pWorker ) == FALSE ) && ( nRetryCount-- != 0 ) )
    {
        //
        // Query the service status.
        //
        if ( FALSE == QueryServiceStatusEx(
                        pResourceEntry->hService,
                        SC_STATUS_PROCESS_INFO,
                        reinterpret_cast< LPBYTE >( &ServiceStatus ),
                        sizeof( SERVICE_STATUS_PROCESS ),
                        &cbBytesNeeded
                        ) )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to query service status for the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
                DHCP_SVCNAME,
                sc
                );

            resourceStatus.ResourceState = ClusterResourceFailed;
            goto Cleanup;
        } // if: error querying service status

        //
        // If the service is in any pending state continue waiting, otherwise we are done.
        //
        if (    ServiceStatus.dwCurrentState == SERVICE_START_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING )
        {
            resourceStatus.ResourceState = ClusterResourceOnlinePending;
        } // if: service state is pending
        else
        {
            break;
        } // else: service state is not pending

        resourceStatus.CheckPoint++;

        //
        // Notify the Resource Monitor of our current state.
        //
        resExitState = static_cast< RESOURCE_EXIT_STATE >(
            (g_pfnSetResourceStatus)(
                            pResourceEntry->hResourceHandle,
                            &resourceStatus
                            ) );
        if ( resExitState == ResourceExitStateTerminate )
        {
            break;
        } // if: resource is being terminated

        //
        // Check again in 1/2 second.
        //
        Sleep( 500 );

    } // while: not terminating while querying the status of the service

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error querying the status of the service

    //
    // Assume that we failed.
    //
    resourceStatus.ResourceState = ClusterResourceFailed;

    //
    // If we exited the loop before setting ServiceStatus, then return now.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Asked to terminate.\n"
        );
        goto Cleanup;
    } // if: being terminated

    if ( nRetryCount == (DWORD) -1 )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Retry period expired.\n"
        );
        goto Cleanup;
    } // if: being terminated

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING )
    {
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR )
        {
            sc = ServiceStatus.dwServiceSpecificExitCode;
        }
        else
        {
            sc = ServiceStatus.dwWin32ExitCode;
        }

        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_START_ERROR,
            sc,
            L"DHCP" );
        (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: The '%1!ws!' service failed during initialization. Error: %2!u! (%2!#08x!).\n",
                DHCP_SVCNAME,
                sc
                );
        goto Cleanup;
    } // if: service not running when loop exited

    //
    // Set status to online and save process ID of the service.
    // This is used to enable us to terminate the resource more
    // effectively.
    //
    resourceStatus.ResourceState = ClusterResourceOnline;
    if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) )
    {
        pResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    } // if: not running in the system process

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"OnlineThread: The '%1!ws!' service is now on line.\n",
        DHCP_SVCNAME
        );

    sc = ERROR_SUCCESS;

Cleanup:

    //
    // Cleanup.
    //
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Error %1!u! (%1!#08x!) bringing resource online.\n",
            sc
            );
        if ( pResourceEntry->hService != NULL )
        {
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
        } // if: service handle was opened
    } // if: error occurred

    delete [] pvBindings;
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: DHCP Server Parameters key is open

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return sc;

} //*** DhcpOnlineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpBuildBindings
//
//  Description:
//      Build bindings for the DHCP resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//      ppOutBuffer [OUT]
//          Pointer in which to return a buffer containing the bindings.
//
//      pcbOutBufferSize [OUT]
//          Number of bytes returned in ppOutBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpBuildBindings(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT PVOID *         ppOutBuffer,
    OUT size_t *        pcbOutBufferSize
    )
{
    DWORD       sc;
    LPWSTR *    ppszIpList = NULL;
    size_t      cpszAddrs;
    size_t      idx;
    size_t      cchAddr;
    size_t      cchAddrRemaining;
    size_t      cchAddrTotal = 1;   // Space for the terminating NULL
    LPWSTR      pszBuffer = NULL;
    LPWSTR      pszNextChar;
    HRESULT     hr = S_OK;

    //
    // Initialize out params to null.
    //
    *ppOutBuffer = NULL;
    *pcbOutBufferSize = 0;

    //
    // Get our list of provider IP Addresses and Subnet Masks.
    //
    sc = DhcpGetIPList( pResourceEntry, &ppszIpList, &cpszAddrs );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error getting IP list

    //
    // Count the total number of bytes required for the binding list.
    //
    for ( idx = 0 ; idx < cpszAddrs ; idx++ )
    {
        cchAddr = wcslen( ppszIpList[ idx ] ) + 1;
        cchAddrTotal += cchAddr;
    } // for: each IP address in the list

    pszBuffer = new WCHAR[ cchAddrTotal ];
    if ( pszBuffer == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if: error allocating memory

    ZeroMemory( pszBuffer, cchAddrTotal * sizeof( WCHAR ) );

    pszNextChar = pszBuffer;
    cchAddrRemaining = cchAddrTotal;
    for ( idx = 0 ; idx < cpszAddrs ; idx++ )
    {
        hr = StringCchCopyExW( pszNextChar, cchAddrRemaining, ppszIpList[ idx ], &pszNextChar, &cchAddrRemaining, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        if ( (idx & 1) == 0 )
        {
            *pszNextChar = L' ';
        } // if: on IP address entry
        pszNextChar++;
        cchAddrRemaining--; 

        delete [] ppszIpList[ idx ];
        ppszIpList[ idx ] = NULL;
    } // for: each IP address in the list

Cleanup:

    //
    // Cleanup.
    //
    if ( sc != ERROR_SUCCESS )
    {
        while ( cpszAddrs > 0 )
        {
            delete [] ppszIpList[ --cpszAddrs ];
        } // while: more entries in the list
        cchAddrTotal = 0;
    } // if: error occurred
    delete [] ppszIpList;

    *ppOutBuffer = (PVOID) pszBuffer;
    *pcbOutBufferSize = cchAddrTotal * sizeof( WCHAR );

    return sc;

} //*** DhcpBuildBindings


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetIPList
//
//  Description:
//      Get the list of IP addresses by enumerating all IP Address resources
//      upon which we are dependent and extract the Address and SubnetMask
//      properties from each.
//
//  Arguments:
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//      pppszIPList [OUT]
//          Pointer in which to return a pointer to an array of pointers to
//          IP address strings.
//
//      pcszAddrs [OUT]
//          Number of addresses returned in pppszIPList.  This will include
//          a combined total of all IP addresses and subnet masks, which means
//          it will be a multiple of 2.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetIPList(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT LPWSTR **       pppszIPList,
    OUT size_t *        pcszIPAddrs
    )
{
    DWORD               sc = ERROR_SUCCESS;
    HRESOURCE           hresProvider = NULL;
    HKEY                hkeyProvider = NULL;
    HRESENUM            hresenum = NULL;
    size_t              idx;
    DWORD               objectType;
    size_t              cchProviderResName = 32;
    LPWSTR              pszProviderResName;
    LPWSTR              pszProviderResType = NULL;
    size_t              cFreeEntries = 0;
    LPWSTR *            ppszIPList = NULL;
    size_t              cszIPAddrs = 0;

    //
    // Allocate a buffer for the provider resource name.
    //
    pszProviderResName = new WCHAR[ cchProviderResName ];
    if ( pszProviderResName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetIPLIst: Unable to allocate memory.\n"
            );
        goto Cleanup;
    } // if: error allocating memory for provider name

    //
    // Enumerate all resources upon which this resource is dependent.
    //
    hresenum = ClusterResourceOpenEnum( pResourceEntry->hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hresenum == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetIPLIst: Unable to open enum handle for this resource, status %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the enumeration

    //
    // Loop through each resource looking for IP Address resource.
    // For each IP Address resource found, extract the IP address and
    // subnet mask and add it to the list.
    //
    for ( idx = 0 ; ; idx++ )
    {
        //
        // Get the next resource upon which we are dependent.
        //
        sc = ClusterResourceEnum(
                                        hresenum,
                                        (DWORD) idx,
                                        &objectType,
                                        pszProviderResName,
                                        (LPDWORD) &cchProviderResName
                                     );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            sc = ERROR_SUCCESS;
            break;
        } // if: no more items in the enumeration

        //
        // If our name buffer isn't big enough, allocate a bigger one
        // and try again.
        //
        if ( sc == ERROR_MORE_DATA )
        {
            //
            // Allocate a bigger name buffer.
            //
            delete [] pszProviderResName;
            cchProviderResName++; // add space for terminating NULL
            pszProviderResName = new WCHAR[ cchProviderResName ];
            if ( pszProviderResName == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetIPLIst: Unable to allocate memory.\n"
                    );
                break;
            } // if: error allocating memory for provider name

            //
            // Try to get the resource name again.
            //
            sc = ClusterResourceEnum(
                                            hresenum,
                                            (DWORD) idx,
                                            &objectType,
                                            pszProviderResName,
                                            (LPDWORD) &cchProviderResName
                                         );

            // ASSERT( sc != ERROR_MORE_DATA );
        } // if: buffer was too small

        if ( sc != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetIPLIst: Unable to enumerate resource dependencies, status %1!u! (%1!#08x!).\n",
                sc
                );
            break;
        } // if: error enumerating next item

        //
        // Open the resource
        //
        hresProvider = OpenClusterResource( pResourceEntry->hCluster, pszProviderResName );
        if ( hresProvider == NULL )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetIPLIst: Unable to open handle to provider resource %1!ws!, status %2!u! (%2!#08x!).\n",
                pszProviderResName,
                sc
                );
            break;
        } // if: error opening the resource

        //
        // Figure out what type it is.
        //
        hkeyProvider = GetClusterResourceKey( hresProvider, KEY_READ );
        if ( hkeyProvider == NULL )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetIPLIst: Unable to open provider resource key, status %1!u! (%1!#08x!).\n",
                sc
                );
            break;
        } // if: error getting registry key

        //
        // Get the resource type name.
        //
        pszProviderResType = ResUtilGetSzValue( hkeyProvider, CLUSREG_NAME_RES_TYPE );
        if ( pszProviderResType == NULL )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetIPLIst: Unable to get provider resource type, status %1!u! (%1!#08x!).\n",
                sc
                );
            break;
        } // if: error getting value

        //
        // If this is an IP Address resource, get it's Address and
        // SubnetMask properties.
        //
        if ( ClRtlStrNICmp( pszProviderResType, RESOURCE_TYPE_IP_ADDRESS, RTL_NUMBER_OF( RESOURCE_TYPE_IP_ADDRESS ) ) == 0 )
        {
            LPWSTR  pszIPAddress;
            LPWSTR  pszSubnetMask;

            //
            // Get the IP Address and SubNet mask.
            // Always allocate two full entries at a time.
            //
            if ( cFreeEntries < 2 )
            {
                LPWSTR * ppwszBuffer;

                //
                // Allocate a bigger buffer.
                //
                ppwszBuffer = new LPWSTR[ cszIPAddrs + IP_BLOCK_SIZE ];
                if ( ppwszBuffer == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"GetIPLIst: Unable to allocate memory.\n"
                        );
                    break;
                } // if: error allocating memory

                //
                // If there already was a list, copy it to the new buffer.
                //
                if ( ppszIPList != NULL )
                {
                    CopyMemory( ppwszBuffer, ppszIPList, cszIPAddrs * sizeof( LPWSTR ));
                    delete [] ppszIPList;
                } // if: list already existed

                //
                // We are now using the newly allocated buffer.
                //
                ppszIPList = ppwszBuffer;
                cFreeEntries += IP_BLOCK_SIZE;
            } // if: # available entries below threshold

            //
            // Get the IP address and SubNet mask.
            //
            sc = DhcpGetIpAndSubnet(
                            hresProvider,
                            &pszIPAddress,
                            &pszSubnetMask
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if: error getting IP address and subnet mask
            ppszIPList[ cszIPAddrs ] = pszIPAddress;
            ppszIPList[ cszIPAddrs + 1 ] = pszSubnetMask;
            cszIPAddrs += 2;
            cFreeEntries -= 2;
        } // if: IP Address resource found

        CloseClusterResource( hresProvider );
        hresProvider = NULL;

        ClusterRegCloseKey( hkeyProvider );
        hkeyProvider = NULL;

        LocalFree( pszProviderResType );
        pszProviderResType = NULL;
    } // for: each dependency

Cleanup:

    //
    // Cleanup.
    //
    delete [] pszProviderResName;
    LocalFree( pszProviderResType );
    if ( hkeyProvider != NULL )
    {
        ClusterRegCloseKey( hkeyProvider );
    } // if: provider resource key was opened
    if ( hresProvider != NULL )
    {
        CloseClusterResource( hresProvider );
    } // if: provider resource was opened
    if ( hresenum != NULL )
    {
        ClusterResourceCloseEnum( hresenum );
    } // if: resource enumeration was opened

    if ( sc != ERROR_SUCCESS )
    {
        while ( cszIPAddrs > 0 )
        {
            delete [] ppszIPList[ --cszIPAddrs ];
        } // while: more entries in the list
        delete [] ppszIPList;
        ppszIPList = NULL;
    } // if: error occurred

    //
    // Return the list to the caller.
    //
    *pppszIPList = ppszIPList;
    *pcszIPAddrs = cszIPAddrs;

    return sc;

} //*** DhcpGetIPList


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetIpAndSubnet
//
//  Description:
//      Get the IP Address and Subnet Mask for the given IP Address resource.
//      Note that this will cause a deadlock if called from any of the
//      standard entry points (e.g. ResourceControl() or Online()).
//
//  Arguments:
//      hres [IN]
//          The Cluster resource handle for accessing the resource.
//
//      ppszIPAddress [OUT]
//          Returns the IP Address string.
//
//      ppszSubnetMask [OUT]
//          Returns the Subnet Mask.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      ERROR_INVALID_DATA
//          No properties available.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetIpAndSubnet(
    IN  HRESOURCE   hres,
    OUT LPWSTR *    ppszIPAddress,
    OUT LPWSTR *    ppszSubnetMask
    )
{
    HRESULT     hr;
    DWORD       sc;
    DWORD       cbProps;
    PVOID       pvProps = NULL;
    LPWSTR      pszIPAddress = NULL;
    LPWSTR      pszSubnetMask = NULL;
    size_t      cch;

    *ppszIPAddress = NULL;
    *ppszSubnetMask = NULL;

    //
    // Get the size of the private properties from the resource.
    //
    sc = ClusterResourceControl(
                    hres,
                    NULL,
                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                    NULL,
                    0,
                    NULL,
                    0,
                    &cbProps
                    );
    if ( (sc != ERROR_SUCCESS) || (cbProps == 0) ) 
    {
        if ( sc == ERROR_SUCCESS )
        {
            sc = ERROR_INVALID_DATA;
        } // if: no properties available
        goto Cleanup;
    } // if: error getting size of properties or no properties available

    //
    // Allocate the property buffer.
    //
    pvProps = (PVOID) new BYTE[ cbProps ];
    if ( pvProps == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if: error allocating memory

    //
    // Get the private properties from the resource.
    //
    sc = ClusterResourceControl(
                    hres,
                    NULL,
                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                    NULL,
                    0,
                    pvProps,
                    cbProps,
                    &cbProps
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error getting private properties

    //
    // Find the Address property.
    //
    sc = ResUtilFindSzProperty(
                        pvProps,
                        cbProps,
                        L"Address",
                        &pszIPAddress
                        );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error finding the Address property

    sc = ResUtilFindSzProperty(
                    pvProps,
                    cbProps,
                    L"SubnetMask",
                    &pszSubnetMask
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error finding the SubnetMask property

    //
    // Allocate using new and copy the strings over.
    //
    cch = wcslen( pszIPAddress ) + 1; 
    *ppszIPAddress = new WCHAR[ cch ];
    if ( *ppszIPAddress == NULL )
    {
        sc = ERROR_OUTOFMEMORY;
        goto Cleanup;
    } // if: error allocating memory

    hr = StringCchCopyW( *ppszIPAddress, cch, pszIPAddress );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if: copy failed

    cch = wcslen( pszSubnetMask ) + 1; 
    *ppszSubnetMask = new WCHAR[ cch ];
    if ( *ppszSubnetMask == NULL )
    {
        sc = ERROR_OUTOFMEMORY;
        goto Cleanup;
    } // if: error allocating memory

    hr = StringCchCopyW( *ppszSubnetMask, cch, pszSubnetMask );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if: copy failed

Cleanup:

    //
    // Cleanup.
    //
    LocalFree( pszIPAddress );
    LocalFree( pszSubnetMask );

    if ( sc != ERROR_SUCCESS )
    {
        delete [] *ppszIPAddress;
        *ppszIPAddress = NULL;
        delete [] *ppszSubnetMask;
        *ppszSubnetMask = NULL;
    } // if: error occurred

    delete [] pvProps;

    return sc;

} //*** DhcpGetIpAndSubnet


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOffline
//
//  Description:
//      Offline routine for DHCP Service resources.
//
//      Take the specified resource offline (unavailable for use).  Wait
//      for any cleanup operations to complete before returning.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          gracefully.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now offline.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is still pending.  A thread has been activated to
//          process the offline request.  The thread that is processing the
//          offline request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOffline state (or the resource monitor
//          decides  to timeout the offline request and Terminate the
//          resource).
//
//      Win32 error code
//          The operation failed.  This will cause the Resource Monitor to
//          log an event and call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOffline( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           sc;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Offline request for a NULL resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n"
        );

    //
    // Start the Offline thread to perform the offline operation.
    //
    pResourceEntry->state = ClusterResourceOfflinePending;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    sc = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( DhcpOfflineThread ),
                pResourceEntry
                );
    if ( sc != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread. Error: %1!u! (%1!#08x!).\n",
            sc
            );
    } // if: error creating the worker thread
    else
    {
        sc = ERROR_IO_PENDING;
        goto Cleanup;
    } // if: worker thread created successfully

Cleanup:

    return sc;

} //*** DhcpOffline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOfflineThread
//
//  Description:
//      Worker function which takes a resource offline.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS     resourceStatus;
    DWORD               sc = ERROR_SUCCESS;
    DWORD               nRetryTime = 300;   // 300 msec at a time
    DWORD               nRetryCount = 2000; // Try 10 min max
    BOOL                bDidStop = FALSE;
    SERVICE_STATUS      ServiceStatus;
    RESOURCE_EXIT_STATE resExitState;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // If the service has gone offline or was never brought online,
    // we're done.
    //
    if ( pResourceEntry->hService == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto Cleanup;
    }

    //
    // Try to stop the service.  Wait for it to terminate as long
    // as we're not asked to terminate.
    //
    while ( ( ClusWorkerCheckTerminate( pWorker ) == FALSE ) && ( nRetryCount-- != 0 ) )
    {
        //
        // Tell the Resource Monitor we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOfflinePending;
        resourceStatus.CheckPoint++;
        resExitState = static_cast< RESOURCE_EXIT_STATE >(
            g_pfnSetResourceStatus(
                            pResourceEntry->hResourceHandle,
                            &resourceStatus
                            ) );
        if ( resExitState == ResourceExitStateTerminate )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Asked to terminate by call to SetResourceStatus callback.\n"
                );
            break;
        } // if: resource is being terminated

        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // Request that the service be stopped, or if we already did that,
        // request the current status of the service.
        //
        sc = (ControlService(
                        pResourceEntry->hService,
                        (bDidStop
                            ? SERVICE_CONTROL_INTERROGATE
                            : SERVICE_CONTROL_STOP),
                        &ServiceStatus
                        )
                    ? ERROR_SUCCESS
                    : GetLastError()
                    );

        if ( sc == ERROR_SUCCESS )
        {
            bDidStop = TRUE;

            if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: The '%1!ws!' service stopped.\n",
                    DHCP_SVCNAME
                    );

                //
                // Set the status.
                //
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: Service is now offline.\n"
                    );
                break;
            } // if: current service state is STOPPED
        } // if: ControlService completed successfully

        else if (   ( sc == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( sc == ERROR_PROCESS_ABORTED )
                ||  ( sc == ERROR_SERVICE_NOT_ACTIVE ) )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: The '%1!ws!' service died or is not active any more; status = %2!u! (%2!#08x!).\n",
                DHCP_SVCNAME,
                sc
                );

            //
            // Set the status.
            //
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
            pResourceEntry->dwServicePid = 0;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: Service is now offline.\n"
                );
            break;
        } // else if: service stopped abnormally

        //
        // Handle the case in which SCM refuses to accept control
        // requests sine windows is shutting down.
        //
        if ( sc == ERROR_SHUTDOWN_IN_PROGRESS )
        {
            DWORD dwResourceState;

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: System shutting down. Attempting to terminate service process %1!u! (%1!#08x!)...\n",
                pResourceEntry->dwServicePid
                );

            sc = ResUtilTerminateServiceProcessFromResDll(
                        pResourceEntry->dwServicePid,
                        TRUE,   // bOffline
                        &dwResourceState,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
            if ( sc == ERROR_SUCCESS )
            {
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                pResourceEntry->state = ClusterResourceOffline;
            } // if: process terminated successfully
            resourceStatus.ResourceState = (CLUSTER_RESOURCE_STATE) dwResourceState;
            break;
        } // if: Windows is shutting down

        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"OfflineThread: retrying...\n"
            );

        Sleep( nRetryTime );

    } // while: not asked to terminate

Cleanup:

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return sc;

} //*** DhcpOfflineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpTerminate
//
//  Description:
//      Terminate routine for DHCP Service resources.
//
//      Take the specified resource offline immediately (the resource is
//      unavailable for use).
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          ungracefully.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DhcpTerminate( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Terminate request for a NULL resource id.\n" );
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Terminate: Resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        goto Cleanup;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n"
        );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );

    if ( pResourceEntry->hService != NULL )
    {
        DWORD           nTotalRetryTime = 30*1000;  // Wait 30 secs for shutdown
        DWORD           nRetryTime = 300;           // 300 msec at a time
        DWORD           sc;
        BOOL            bDidStop = FALSE;
        SERVICE_STATUS  ServiceStatus;

        for (;;)
        {
            sc = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( sc == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"Terminate: The '%1!ws!' service stopped.\n",
                        DHCP_SVCNAME
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            //
            // Since SCM doesn't accept any control requests during Windows
            // shutdown, don't send any more control requests.  Just exit
            // from this loop and terminate the process by brute force.
            //
            if ( sc == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: System shutdown in progress. Will try to terminate process by brute force...\n"
                    );
                break;
            } // if: Windows is shutting down

            if (    ( sc == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( sc == ERROR_PROCESS_ABORTED )
                ||  ( sc == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: Service died; status = %1!u! (%1!#08x!).\n",
                    sc
                    );
                break;
            } // if: service stopped abnormally

            if ( (nTotalRetryTime -= nRetryTime) <= 0 )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Terminate: Service did not stop; giving up.\n" );

                break;
            } // if: retried too many times

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: retrying...\n"
                );

            Sleep( nRetryTime );

        } // forever

        //
        // Declare the service offline.  It may not truly be offline, so
        // if there is a pid for this service, try and terminate that process.
        // Note that terminating a process doesnt terminate all the child
        // processes.
        //
        if ( pResourceEntry->dwServicePid != 0 )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: Attempting to terminate process with pid=%1!u! (%1!#08x!)...\n",
                pResourceEntry->dwServicePid
                );
            ResUtilTerminateServiceProcessFromResDll(
                pResourceEntry->dwServicePid,
                FALSE,  // bOffline
                NULL,   // pdwResourceState
                g_pfnLogEvent,
                pResourceEntry->hResourceHandle
                );
        } // if: service process ID available

        CloseServiceHandle( pResourceEntry->hService );
        pResourceEntry->hService = NULL;
        pResourceEntry->dwServicePid = 0;

    } // if: service was started

    pResourceEntry->state = ClusterResourceOffline;

Cleanup:

    return;

} //*** DhcpTerminate


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpLooksAlive
//
//  Description:
//      LooksAlive routine for DHCP Service resources.
//
//      Perform a quick check to determine if the specified resource is
//      probably online (available for use).  This call should not block for
//      more than 300 ms, preferably less than 50 ms.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is probably online and available for use.
//
//      FALSE
//          The specified resource is not functioning normally.  The IsAlive
//          function will be called to perform a more thorough check.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DhcpLooksAlive( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;
    BOOL            fSuccess = FALSE;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "LooksAlive request for a NULL resource id.\n" );
        fSuccess = FALSE;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        fSuccess = FALSE;
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n"
        );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    fSuccess = DhcpCheckIsAlive( pResourceEntry, FALSE /* fFullCheck */ );

Cleanup:

    return fSuccess;

} //*** DhcpLooksAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpIsAlive
//
//  Description:
//      IsAlive routine for DHCP Service resources.
//
//      Perform a thorough check to determine if the specified resource is
//      online (available for use).  This call should not block for more
//      more than 300 ms, preferably less than 50 ms.  If it must block for
//      longer than this, create a separate thread dedicated to polling for
//      this information and have this routine return the status of the last
//      poll performed.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is online and functioning normally.
//
//      FALSE
//          The specified resource is not functioning normally.  The resource
//          will be terminated and then Online will be called.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DhcpIsAlive( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;
    BOOL            fSuccess = FALSE;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "IsAlive request for a NULL resource id.\n" );
        fSuccess = FALSE;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        fSuccess = FALSE;
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n"
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    fSuccess = DhcpCheckIsAlive( pResourceEntry, TRUE /* fFullCheck */ );

Cleanup:

    return fSuccess;

} //*** DhcpIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpCheckIsAlive
//
//  Description:
//      Check to see if the resource is alive for DHCP Service
//      resources.
//
//  Arguments:
//      pResourceEntry  [IN]
//          Supplies the resource entry for the resource to polled.
//
//      fFullCheck [IN]
//          TRUE = Perform a full check.
//          FALSE = Perform a cursory check.
//
//  Return Value:
//      TRUE    The specified resource is online and functioning normally.
//      FALSE   The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DhcpCheckIsAlive(
    IN PDHCP_RESOURCE   pResourceEntry,
    IN BOOL             fFullCheck
    )
{
    BOOL    bIsAlive = TRUE;
    DWORD   sc;

    //
    // Check to see if the resource is alive.
    //
    sc = ResUtilVerifyService( pResourceEntry->hService );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"CheckIsAlive: Verification of the '%1!ws!' service failed. Error: %2!u! (%2!#08x!).\n",
            DHCP_SVCNAME,
            sc
            );
        bIsAlive = FALSE;
        goto Cleanup;
    } // if: error verifying service

    if ( fFullCheck )
    {
        // TODO: Add code to perform a full check.
    } // if: performing a full check

Cleanup:

    return bIsAlive;

} //*** DhcpCheckIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpResourceControl
//
//  Description:
//      ResourceControl routine for DHCP Service resources.
//
//      Perform the control request specified by nControlCode on the specified
//      resource.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID for the specific resource.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD           sc;
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           cbRequired = 0;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "ResourceControl request for a nonexistent resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ResourceControl: Sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: invalid resource ID

    switch ( nControlCode )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            sc = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            sc = ResUtilGetPropertyFormats(
                                DhcpResourcePrivateProperties,
                                static_cast< LPWSTR> (pOutBuffer),
                                cbOutBufferSize,
                                pcbBytesReturned,
                                &cbRequired );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            sc = ResUtilEnumProperties(
                            DhcpResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            sc = DhcpGetPrivateResProperties(
                            pResourceEntry,
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            sc = DhcpValidatePrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize,
                            NULL
                            );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            sc = DhcpSetPrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize
                            );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            sc = DhcpGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            sc = DhcpDeleteResourceHandler( pResourceEntry );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            sc = DhcpSetNameHandler(
                            pResourceEntry,
                            static_cast< LPWSTR >( pInBuffer )
                            );
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
        case CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:
        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
        default:
            sc = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

Cleanup:

    return sc;

} //*** DhcpResourceControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpResourceTypeControl
//
//  Description:
//      ResourceTypeControl routine for DHCP Service resources.
//
//      Perform the control request specified by nControlCode.
//
//  Arguments:
//      pszResourceTypeName [IN]
//          Supplies the name of the resource type.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD   sc;
    DWORD   cbRequired = 0;

    UNREFERENCED_PARAMETER( pszResourceTypeName );
    UNREFERENCED_PARAMETER( pInBuffer );
    UNREFERENCED_PARAMETER( cbInBufferSize );

    switch ( nControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *pcbBytesReturned = 0;
            sc = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            sc = ResUtilGetPropertyFormats(
                                    DhcpResourcePrivateProperties,
                                    static_cast< LPWSTR> (pOutBuffer),
                                    cbOutBufferSize,
                                    pcbBytesReturned,
                                    &cbRequired );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            sc = ResUtilEnumProperties(
                            DhcpResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            sc = DhcpGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
        case CLUSCTL_RESOURCE_TYPE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_TYPE_EVICT_NODE:
        default:
            sc = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return sc;

} //*** DhcpResourceTypeControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetRequiredDependencies
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    // TODO: Specify your resource's required dependencies here.
    //   The default is that the resource requires a dependency on a
    //   storage class resource (e.g. Physical Disk) and an IP Address
    //   resource.
    struct DEP_DATA
    {
        CLUSPROP_RESOURCE_CLASS rcStorage;
        CLUSPROP_SZ_DECLARE( ipaddrEntry, RTL_NUMBER_OF( RESOURCE_TYPE_IP_ADDRESS ) );
        CLUSPROP_SZ_DECLARE( netnameEntry, RTL_NUMBER_OF( RESOURCE_TYPE_NETWORK_NAME ) );
        CLUSPROP_SYNTAX         endmark;
    };
    DEP_DATA *  pdepdata = static_cast< DEP_DATA * >( pOutBuffer );
    DWORD       sc;
    HRESULT     hr = S_OK;

    *pcbBytesReturned = sizeof( DEP_DATA );
    if ( cbOutBufferSize < sizeof( DEP_DATA ) )
    {
        if ( pOutBuffer == NULL )
        {
            sc = ERROR_SUCCESS;
        } // if: no buffer specified
        else
        {
            sc = ERROR_MORE_DATA;
        } // if: buffer specified
    } // if: output buffer is too small
    else
    {
        ZeroMemory( pdepdata, sizeof( *pdepdata ) );

        //
        // Add the Storage class entry.
        //
        pdepdata->rcStorage.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->rcStorage.cbLength = sizeof( pdepdata->rcStorage.rc );
        pdepdata->rcStorage.rc = CLUS_RESCLASS_STORAGE;

        //
        // Add the IP Address entry.
        //
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof( RESOURCE_TYPE_IP_ADDRESS );
        hr = StringCchCopyNW( 
                  pdepdata->ipaddrEntry.sz
                , RTL_NUMBER_OF( pdepdata->ipaddrEntry.sz )
                , RESOURCE_TYPE_IP_ADDRESS
                , RTL_NUMBER_OF( RESOURCE_TYPE_IP_ADDRESS )
                );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        //
        // Add the Network Name entry.
        //
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof( RESOURCE_TYPE_NETWORK_NAME );
        hr = StringCchCopyNW( 
                  pdepdata->netnameEntry.sz 
                , RTL_NUMBER_OF( pdepdata->netnameEntry.sz )
                , RESOURCE_TYPE_NETWORK_NAME
                , RTL_NUMBER_OF( RESOURCE_TYPE_NETWORK_NAME ) 
                );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }


        //
        // Add the endmark.
        //
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;

        sc = ERROR_SUCCESS;
    } // else: output buffer is large enough

Cleanup:

    return sc;

} //*** DhcpGetRequiredDependencies


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpReadParametersToParameterBlock
//
//  Description:
//      Reads all the parameters for a specied DHCP resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      bCheckForRequiredProperties [IN]
//          Determines whether an error should be generated if a required
//          property hasn't been specified.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpReadParametersToParameterBlock(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    )
{
    DWORD       sc;
    LPWSTR      pszNameOfPropInError;

    //
    // Read our parameters.
    //
    sc = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->hkeyParameters,
                    DhcpResourcePrivateProperties,
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ws!' property. Error: %2!u! (%2!#08x!).\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            sc
            );
    } // if: error getting properties

    return sc;

} //*** DhcpReadParametersToParameterBlock


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    )
{
    DWORD   sc;
    DWORD   nRetStatus = ERROR_SUCCESS;
    DWORD   cbRequired = 0;
    DWORD   cbLocalOutBufferSize = cbOutBufferSize;

    //
    // Read our parameters.
    //
    sc = DhcpReadParametersToParameterBlock(
                        pResourceEntry,
                        FALSE /* bCheckForRequiredProperties */
                        );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        goto Cleanup;
    } // if: error reading parameters

    //
    // If the properties aren't set yet, retrieve the values from
    // the system registry.
    //
    sc = DhcpGetDefaultPropertyValues( pResourceEntry, &pResourceEntry->props );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        goto Cleanup;
    } // if: error getting default properties

    //
    // Construct a property list from the parameter block.
    //
    sc = ResUtilPropertyListFromParameterBlock(
                    DhcpResourcePrivateProperties,
                    pOutBuffer,
                    &cbLocalOutBufferSize,
                    reinterpret_cast< const LPBYTE >( &pResourceEntry->props ),
                    pcbBytesReturned,
                    &cbRequired
                    );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetPrivateResProperties: Error constructing property list from parameter block. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        //
        // Don't exit the loop if buffer is too small.
        //
        if ( sc != ERROR_MORE_DATA )
        {
            goto Cleanup;
        } // if: buffer is too small
    } // if: error getting properties

    //
    // Add unknown properties.
    //
    sc = ResUtilAddUnknownProperties(
                    pResourceEntry->hkeyParameters,
                    DhcpResourcePrivateProperties,
                    pOutBuffer,
                    cbOutBufferSize,
                    pcbBytesReturned,
                    &cbRequired
                    );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetPrivateResProperties: Error adding unknown properties to the property list. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error adding unknown properties

Cleanup:

    if ( nRetStatus == ERROR_MORE_DATA )
    {
        *pcbBytesReturned = cbRequired;
    } // if: output buffer is too small

    return nRetStatus;

} //*** DhcpGetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpValidatePrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pProps [OUT]
//          Supplies the parameter block to fill in (optional).
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpValidatePrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PDHCP_PROPS     pProps
    )
{
    DWORD       sc = ERROR_SUCCESS;
    DHCP_PROPS  propsCurrent;
    DHCP_PROPS  propsNew;
    PDHCP_PROPS pLocalProps = NULL;
    LPWSTR      pszNameOfPropInError;
    BOOL        bRetrievedProps = FALSE;

    //
    // Check if there is input data.
    //
    if ( ( pInBuffer == NULL ) || ( cbInBufferSize < sizeof( DWORD ) ) )
    {
        sc = ERROR_INVALID_DATA;
        goto Cleanup;
    } // if: no input buffer or input buffer not big enough to contain property list

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

    sc = ResUtilGetPropertiesToParameterBlock(
                 pResourceEntry->hkeyParameters,
                 DhcpResourcePrivateProperties,
                 reinterpret_cast< LPBYTE >( &propsCurrent ),
                 FALSE, /*CheckForRequiredProperties*/
                 &pszNameOfPropInError
                 );

    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidatePrivateResProperties: Unable to read the '%1!ws!' property. Error: %2!u! (%2!#08x!).\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            sc
            );
        goto Cleanup;
    } // if: error getting properties
    bRetrievedProps = TRUE;

    //
    // Duplicate the resource parameter block.
    //
    if ( pProps == NULL )
    {
        pLocalProps = &propsNew;
    } // if: no parameter block passed in
    else
    {
        pLocalProps = pProps;
    } // else: parameter block passed in
    ZeroMemory( pLocalProps, sizeof( *pLocalProps ) );
    sc = ResUtilDupParameterBlock(
                    reinterpret_cast< LPBYTE >( pLocalProps ),
                    reinterpret_cast< LPBYTE >( &propsCurrent ),
                    DhcpResourcePrivateProperties
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error duplicating the parameter block

    //
    // Parse and validate the properties.
    //
    sc = ResUtilVerifyPropertyTable(
                    DhcpResourcePrivateProperties,
                    NULL,
                    TRUE, // AllowUnknownProperties
                    pInBuffer,
                    cbInBufferSize,
                    reinterpret_cast< LPBYTE >( pLocalProps )
                    );
    if ( sc == ERROR_SUCCESS )
    {
        //
        // Validate the property values.
        //
        sc = DhcpValidateParameters( pResourceEntry, pLocalProps );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: error validating parameters
    } // if: property list validated successfully

Cleanup:

    //
    // Cleanup our parameter block.
    //
    if (    ( pLocalProps == &propsNew ) 
         || ( (sc != ERROR_SUCCESS) && (pLocalProps != NULL) )  )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( pLocalProps ),
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            DhcpResourcePrivateProperties
            );
    } // if: we duplicated the parameter block

    if ( bRetrievedProps )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            NULL,
            DhcpResourcePrivateProperties
            );
    } // if: properties were retrieved

    return sc;

} // DhcpValidatePrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpValidateParameters
//
//  Description:
//      Validate the parameters of a DHCP Service resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Supplies the parameter block to validate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_BAD_PATHNAME
//          Invalid path specified.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpValidateParameters(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps
    )
{
    DWORD   sc;

    //
    // Verify that the service is installed.
    //
    sc = ResUtilVerifyResourceService( DHCP_SVCNAME );
    if (    ( sc != ERROR_SUCCESS )
        &&  ( sc != ERROR_SERVICE_NOT_ACTIVE )
        )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Error verifying the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
            DHCP_SVCNAME,
            sc
            );
        goto Cleanup;
    } // if: error verifying service
    else
    {
        sc = ERROR_SUCCESS;
    } // else: service verified successfully

    //
    // Validate the DatabasePath.
    //
    if (  ( pProps->pszDatabasePath == NULL ) || ( *pProps->pszDatabasePath == L'\0' )  )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Database path property must be specified.\n"
            );
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if: no database path specified

    //
    // Path must not begin with %SystemRoot% and must be of valid form.
    //
    if (    ( ClRtlStrNICmp( pProps->pszDatabasePath, L"%SystemRoot%", RTL_NUMBER_OF( L"%SystemRoot%" ) ) == 0 )
         || ( ResUtilIsPathValid( pProps->pszDatabasePath ) == FALSE ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Database path property is invalid: '%1!ws!'.\n",
            pProps->pszDatabasePath
            );
        sc = ERROR_BAD_PATHNAME;
        goto Cleanup;
    } // if: database path is malformed

    //
    // Validate the LogFilePath.
    //
    if ( ( pProps->pszLogFilePath == NULL ) || ( *pProps->pszLogFilePath == L'\0' ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Log file path must be specified: '%1!ws!'.\n",
            pProps->pszBackupPath
            );
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if: no log file path specified

    //
    // Path must not begin with %SystemRoot% and must be of valid form.
    //
    if (    ( ClRtlStrNICmp( pProps->pszLogFilePath, L"%SystemRoot%", RTL_NUMBER_OF( L"%SystemRoot%" ) ) == 0 )
         || ( ResUtilIsPathValid( pProps->pszLogFilePath ) == FALSE ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Log file path property is invalid: '%1!ws!'.\n",
            pProps->pszLogFilePath
            );
        sc = ERROR_BAD_PATHNAME;
        goto Cleanup;
    } // if: log file path is malformed

    //
    // Validate the BackupPath.
    //
    if ( ( pProps->pszBackupPath == NULL ) || ( *pProps->pszBackupPath == L'\0' ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Backup database path must be specified.\n"
            );
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if: no backup path specified

    //
    // Path must not begin with %SystemRoot% and must be of valid form.
    //
    if (    ( ClRtlStrNICmp( pProps->pszBackupPath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) - 1 /*NULL*/) == 0 )
         || ( ResUtilIsPathValid( pProps->pszBackupPath ) == FALSE )
       )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Backup database path property is invalid: '%1!ws!'.\n",
            pProps->pszBackupPath
            );
        sc = ERROR_BAD_PATHNAME;
        goto Cleanup;
    } // if: backup path is malformed

Cleanup:

    return sc;

} //*** DhcpValidateParameters


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpSetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpSetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize
    )
{
    DWORD       sc = ERROR_SUCCESS;
    LPWSTR      pszExpandedPath = NULL;
    DHCP_PROPS  props;

    ZeroMemory( &props, sizeof( props ) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    sc = DhcpValidatePrivateResProperties( pResourceEntry, pInBuffer, cbInBufferSize, &props );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error validating properties

    //
    // Expand any environment variables in the database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszDatabasePath );
    if ( pszExpandedPath == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error expanding the database path '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            props.pszDatabasePath,
            sc
            );
        goto Cleanup;
    } // if: error expanding database path

    //
    // Create the database directory.
    //
    sc = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error creating the database path directory '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            pszExpandedPath,
            sc
            );
    } // if: error creating the database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Expand any environment variables in the log file path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszLogFilePath );
    if ( pszExpandedPath == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error expanding the log file path '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            props.pszLogFilePath,
            sc
            );
        goto Cleanup;
    } // if: error expanding log file path

    //
    // Create the log file path directory.
    //
    sc = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error creating the log file path directory '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            pszExpandedPath,
            sc
            );
        goto Cleanup;
    } // if: error creating the log file path directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Expand any environment variables in the backup database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszBackupPath );
    if ( pszExpandedPath == NULL ) 
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error expanding the backup database path '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            props.pszBackupPath,
            sc
            );
        goto Cleanup;
    } // if: error expanding backup database path

    //
    // Create the backup directory.
    //
    sc = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error creating the backup database path directory '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            pszExpandedPath,
            sc
            );
        goto Cleanup;
    } // if: error creating the backup database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Set the entries in the system registry.
    //
    sc = DhcpZapSystemRegistry( pResourceEntry, &props, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error zapping the registry

    //
    // Save the property values.
    //
    sc = ResUtilSetPropertyParameterBlockEx(
                    pResourceEntry->hkeyParameters,
                    DhcpResourcePrivateProperties,
                    NULL,
                    reinterpret_cast< LPBYTE >( &props ),
                    pInBuffer,
                    cbInBufferSize,
                    TRUE, // bForceWrite
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props )
                    );

    //
    // If the resource is online, return a non-success status.
    //
    // TODO: Modify the code below if your resource can handle
    // changes to properties while it is still online.
    if ( sc == ERROR_SUCCESS )
    {
        if ( pResourceEntry->state == ClusterResourceOnline )
        {
            sc = ERROR_RESOURCE_PROPERTIES_STORED;
        } // if: resource is currently online
        else if ( pResourceEntry->state == ClusterResourceOnlinePending )
        {
            sc = ERROR_RESOURCE_PROPERTIES_STORED;
        } // else if: resource is currently in online pending
        else
        {
            sc = ERROR_SUCCESS;
        } // else: resource is in some other state
    } // if: properties set successfully

Cleanup:

    LocalFree( pszExpandedPath );

    ResUtilFreeParameterBlock(
        reinterpret_cast< LPBYTE >( &props ),
        reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
        DhcpResourcePrivateProperties
        );

    return sc;

} //*** DhcpSetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpZapSystemRegistry
//
//  Description:
//      Zap the values in the system registry used by the service with
//      cluster properties.
//
//  Arguments:
//
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Parameter block containing properties with which to zap the
//          registry.
//
//      hkeyParametersKey [IN]
//          Service Parameters key.  Can be specified as NULL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpZapSystemRegistry(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    )
{
    DWORD   sc;
    size_t  cch;
    HKEY    hkeyParamsKey = hkeyParametersKey;
    LPWSTR  pszValue = NULL;
    HRESULT hr = S_OK;

    if ( hkeyParametersKey == NULL )
    {
        //
        // Open the service Parameters key
        //
        sc = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        DHCP_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( sc != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"ZapSystemRegistry: Unable to open the DHCPServer Parameters key. Error %1!u! (%1!#08x!).\n",
                sc
                );
            goto Cleanup;
        } // if: error opening the registry key
    } // if: no registry key specified

    //
    // Make sure the path has a trailing backslash
    //
    cch = wcslen( pProps->pszDatabasePath );
    if ( pProps->pszDatabasePath[ cch - 1 ] != L'\\' )
    {
        WCHAR * pwch = NULL;

        cch += 2;   //  Add one for NULL and one for the backslash.
        pszValue = new WCHAR[ cch ];
        if ( pszValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        } // if: alloc failed

        hr = StringCchCopyExW( pszValue, cch - 1, pProps->pszDatabasePath, &pwch, NULL, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        *pwch++ = L'\\';
        *pwch = L'\0';

    } // if: missing backslash

    //
    // Set the database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_DATABASEPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ) ),
                    (DWORD) ( wcslen( ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ) ) + 1) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_DATABASEPATH_REGVALUE,
            ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ),
            sc
            );
        goto Cleanup;
    } // if: error setting the database path in the registry

    delete [] pszValue;
    pszValue = NULL;

    //
    // Make sure the path has a trailing backslash
    //
    cch = wcslen( pProps->pszLogFilePath );
    if ( pProps->pszLogFilePath[ cch - 1 ] != L'\\' )
    {
        WCHAR * pwch = NULL;

        cch += 2;   //  Add one for the NULL and one for the backslash.
        pszValue = new WCHAR[ cch ];
        if ( pszValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        } // if: alloc failed

        hr = StringCchCopyExW( pszValue, cch - 1, pProps->pszLogFilePath, &pwch, NULL, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        *pwch++ = L'\\';
        *pwch = L'\0';

    } // if: missing backslash

    //
    // Set the log file path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_LOGFILEPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ) ),
                    (DWORD) (wcslen( ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ) ) + 1) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_LOGFILEPATH_REGVALUE,
            ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ),
            sc
            );
        goto Cleanup;
    } // if: error setting the log file path in the registry

    delete [] pszValue;
    pszValue = NULL;

    //
    // Make sure the path has a trailing backslash
    //
    cch = wcslen( pProps->pszBackupPath );
    if ( pProps->pszBackupPath[ cch - 1 ] != L'\\' )
    {
        WCHAR * pwch = NULL;

        cch += 2;   //  Add one for the NULL and one for the backslash.
        pszValue = new WCHAR[ cch ];
        if ( pszValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        } // if: alloc failed

        hr = StringCchCopyExW( pszValue, cch - 1, pProps->pszBackupPath, &pwch, NULL, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        *pwch++ = L'\\';
        *pwch = L'\0';
    } // if: missing backslash

    //
    // Set the backup database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_BACKUPPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ),
                    (DWORD) ( wcslen( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ) + 1) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_BACKUPPATH_REGVALUE,
            ( pszValue != NULL ? pszValue : pProps->pszBackupPath ),
            sc
            );
        goto Cleanup;
    } // if: error setting the backup database path in the registry

    delete [] pszValue;
    pszValue = NULL;

    //
    // Set the cluster resource name in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_CLUSRESNAME_REGVALUE,
                    0,
                    REG_SZ,
                    reinterpret_cast< PBYTE >( pResourceEntry->pwszResourceName ),
                    (DWORD) (wcslen( pResourceEntry->pwszResourceName ) + 1) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_CLUSRESNAME_REGVALUE,
            pResourceEntry->pwszResourceName,
            sc
            );
        goto Cleanup;
    } // if: error setting the cluster resource name in the registry

Cleanup:

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != hkeyParametersKey )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    delete [] pszValue;

    return sc;

} //*** DhcpZapSystemRegistry


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetDefaultPropertyValues
//
//  Description:
//      If any of the properties are not set, use the values from the
//      system registry as default values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN OUT]
//          Parameter block containing properties to set defaults in.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetDefaultPropertyValues(
    IN      PDHCP_RESOURCE  pResourceEntry,
    IN OUT  PDHCP_PROPS     pProps
    )
{
    DWORD   sc = ERROR_SUCCESS;
    DWORD   nType;
    DWORD   cbValue = 0;
    HKEY    hkeyParamsKey = NULL;
    LPWSTR  pszValue = NULL;

    if (    ( pProps->pszDatabasePath == NULL )
        ||  ( *pProps->pszDatabasePath == L'\0' )
        ||  ( pProps->pszBackupPath == NULL )
        ||  ( *pProps->pszBackupPath == L'\0' )
        )
    {
        //
        // Open the service Parameters key
        //
        sc = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        DHCP_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( sc != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetDefaultPropertyValues: Unable to open the DHCPServer Parameters key. Error %1!u! (%1!#08x!).\n",
                sc
                );
            goto Cleanup;
        } // if: error opening the Parameters key

        ///////////////////
        // DATABASE PATH //
        ///////////////////
        if ( ( pProps->pszDatabasePath == NULL ) || ( *pProps->pszDatabasePath == L'\0' ) )
        {
            //
            // Get the database path from the system registry.
            //
            sc = RegQueryValueExW(
                            hkeyParamsKey,
                            DHCP_DATABASEPATH_REGVALUE,
                            NULL,               // Reserved
                            &nType,
                            NULL,               // lpbData
                            &cbValue
                            );
            if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
            {
                //
                // Value was found.
                //
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory
                sc = RegQueryValueExW(
                                hkeyParamsKey,
                                DHCP_DATABASEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                reinterpret_cast< PUCHAR >( pszValue ),
                                &cbValue
                                );
            } // if: value size read successfully

            if ( sc != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: Unable to get the DHCPServer '%1!ws!' value from the system registry. Error %2!u! (%2!#08x!).\n",
                    DHCP_DATABASEPATH_REGVALUE,
                    sc
                    );

                //
                // If value not found, don't exit so we can look for the
                // backup database path value.
                //
                if ( sc != ERROR_FILE_NOT_FOUND )
                {
                    goto Cleanup;
                } // if: error other than value not found occurred
                LocalFree( pszValue );
                pszValue = NULL;
            } // if: error reading the value
            else
            {
                LocalFree( pProps->pszDatabasePath );
                pProps->pszDatabasePath = pszValue;
                pszValue = NULL;
            } // else: no error reading the value
        } // if: value for DatabasePath not found yet

        ///////////////////
        // LOG FILE PATH //
        ///////////////////
        if ( ( pProps->pszLogFilePath == NULL ) || ( *pProps->pszLogFilePath == L'\0' ) )
        {
            //
            // Get the log file path from the system registry.
            //
            sc = RegQueryValueExW(
                            hkeyParamsKey,
                            DHCP_LOGFILEPATH_REGVALUE,
                            NULL,               // Reserved
                            &nType,
                            NULL,               // lpbData
                            &cbValue
                            );
            if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
            {
                //
                // Value was found.
                //
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory
                sc = RegQueryValueExW(
                                hkeyParamsKey,
                                DHCP_LOGFILEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                reinterpret_cast< PUCHAR >( pszValue ),
                                &cbValue
                                );
            } // if: value size read successfully

            if ( sc != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: Unable to get the DHCPServer '%1!ws!' value from the system registry. Error %2!u! (%2!#08x!).\n",
                    DHCP_LOGFILEPATH_REGVALUE,
                    sc
                    );
                //
                // If value not found, don't exit so we can look for the
                // backup database path value.
                //
                if ( sc != ERROR_FILE_NOT_FOUND )
                {
                    goto Cleanup;
                } // if: error other than value not found occurred
            } // if: error reading the value
            LocalFree( pProps->pszLogFilePath );
            pProps->pszLogFilePath = pszValue;
            pszValue = NULL;
        } // if: value for LogFilePath not found yet

        /////////////////
        // BACKUP PATH //
        /////////////////
        if ( ( pProps->pszBackupPath == NULL ) || ( *pProps->pszBackupPath == L'\0' ) )
        {
            //
            // Get the backup database path from the system registry.
            //
            sc = RegQueryValueExW(
                            hkeyParamsKey,
                            DHCP_BACKUPPATH_REGVALUE,
                            NULL,               // Reserved
                            &nType,
                            NULL,               // lpbData
                            &cbValue
                            );
            if (    ( sc == ERROR_SUCCESS )
                ||  ( sc == ERROR_MORE_DATA )
                )
            {
                //
                // Value was found.
                //
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory
                sc = RegQueryValueExW(
                                hkeyParamsKey,
                                DHCP_BACKUPPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                reinterpret_cast< PUCHAR >( pszValue ),
                                &cbValue
                                );
            } // if: value size read successfully

            if ( sc != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: Unable to get the DHCPServer '%1!ws!' value from the system registry. Error %2!u! (%2!#08x!).\n",
                    DHCP_BACKUPPATH_REGVALUE,
                    sc
                    );
                goto Cleanup;
            } // if: error reading the value
            LocalFree( pProps->pszBackupPath );
            pProps->pszBackupPath = pszValue;
            pszValue = NULL;
        } // if: value for BackupPath not found yet
    } // if: some value not found yet

Cleanup:

    LocalFree( pszValue );

    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the Parameters key

    //
    // If a key or value wasn't found, treat it as a success.
    //
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        sc = ERROR_SUCCESS;
    } // if: couldn't find one of the values

    return sc;

} //*** DhcpGetDefaultPropertyValues


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpDeleteResourceHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_DELETE control code by restoring the
//      system registry parameters to their former values.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpDeleteResourceHandler( IN OUT PDHCP_RESOURCE pResourceEntry )
{
    DWORD   nRetStatus;
    DWORD   sc;
    HKEY    hkeyParamsKey = NULL;

    //
    // Open the service Parameters key
    //
    nRetStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DHCP_PARAMS_REGKEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeyParamsKey
                    );
    if ( nRetStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to open the DHCPServer Parameters key. Error %1!u! (%1!#08x!).\n",
            nRetStatus
            );
        goto Cleanup;
    } // if: error opening the registry key

    //
    // Set the database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_DATABASEPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( PROP_DEFAULT__DATABASEPATH ),
                    sizeof( PROP_DEFAULT__DATABASEPATH )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_DATABASEPATH_REGVALUE,
            PROP_DEFAULT__DATABASEPATH,
            sc
            );
        if ( nRetStatus == ERROR_SUCCESS )
        {
            nRetStatus = sc;
        }
    } // if: error setting the database path in the registry

    //
    // Delete the log file path in the system registry.
    //
    sc = RegDeleteValue(
                    hkeyParamsKey,
                    DHCP_LOGFILEPATH_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the DHCPServer '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            DHCP_LOGFILEPATH_REGVALUE,
            sc
            );
        if ( nRetStatus == ERROR_SUCCESS )
        {
            nRetStatus = sc;
        }
    } // if: error deleting the log file path in the registry

    //
    // Set the backup database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    DHCP_BACKUPPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( PROP_DEFAULT__BACKUPPATH ),
                    sizeof( PROP_DEFAULT__BACKUPPATH )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to set the DHCPServer '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            DHCP_BACKUPPATH_REGVALUE,
            PROP_DEFAULT__BACKUPPATH,
            sc
            );
        if ( nRetStatus == ERROR_SUCCESS )
        {
            nRetStatus = sc;
        }
    } // if: error setting the backup database path in the registry

    //
    // Delete the cluster resource name in the system registry.
    //
    sc = RegDeleteValue(
                    hkeyParamsKey,
                    DHCP_CLUSRESNAME_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the DHCPServer '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            DHCP_LOGFILEPATH_REGVALUE,
            sc
            );
        if ( nRetStatus == ERROR_SUCCESS )
        {
            nRetStatus = sc;
        }
    } // if: error deleting the cluster resource name in the registry

Cleanup:

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    return nRetStatus;

} //*** DhcpDeleteResourceHandler


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpSetNameHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_NAME control code by saving the new
//      name of the resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pwszName [IN]
//          The new name of the resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpSetNameHandler(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      LPWSTR          pwszName
    )
{
    DWORD   sc = ERROR_SUCCESS;
    size_t  cch;
    HRESULT hr = S_OK;
    LPWSTR pwszNewName = NULL;

    //
    // Save the name of the resource.
    //
    cch = wcslen( pwszName ) + 1;
    pwszNewName = new WCHAR[ cch ];
    if ( pwszNewName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetNameHandler: Failed to allocate memory for the new resource name '%1!ws!'. Error %2!u! (%2!#08x!).\n",
            pwszName,
            sc
            );
        goto Cleanup;
    } // if: error allocating memory for the name.

    //
    //  Copy the new name to our new buffer.
    //
    hr = StringCchCopyW( pwszNewName, cch, pwszName );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

    //
    //  Now free the old one and update pResourceEntry.
    //
    delete [] pResourceEntry->pwszResourceName;
    pResourceEntry->pwszResourceName = pwszNewName;
    pwszNewName = NULL;

    //
    // Write cluster properties to the system registry.
    //
    sc = DhcpZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        //
        //  Not much that we can do here.  According to the docs, the name
        //  has already been changed in the clusdb by the time we're called,
        //  so I guess we should reflect that.
        //
        goto Cleanup;
    } // if: error zapping the WINS registry

Cleanup:

    delete [] pwszNewName;

    return sc;

} //*** DhcpSetNameHandler

/////////////////////////////////////////////////////////////////////////////
//
// Define Function Table
//
/////////////////////////////////////////////////////////////////////////////

CLRES_V1_FUNCTION_TABLE(
    g_DhcpFunctionTable,    // Name
    CLRES_VERSION_V1_00,    // Version
    Dhcp,                   // Prefix
    NULL,                   // Arbitrate
    NULL,                   // Release
    DhcpResourceControl,    // ResControl
    DhcpResourceTypeControl // ResTypeControl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetres\clnetres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClNetRes.h
//
//  Implementation File:
//      ClNetRes.cpp
//
//  Description:
//      Resource DLL for DHCP and WINS Services (ClNetRes).
//
//  Maintained By:
//      David Potter (DavidP) March 18, 1999
//      George Potts (GPotts) April 19, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLNETRES_H__
#define __CLNETRES_H__
#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#pragma comment( lib, "clusapi.lib" )
#pragma comment( lib, "resutils.lib" )
#pragma comment( lib, "advapi32.lib" )

#define UNICODE 1
#define _UNICODE 1

#pragma warning( push )
#pragma warning( disable : 4115 )   // named type definition in parentheses
#pragma warning( disable : 4201 )   // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )   // nonstandard extension used : bit field types other than int
#include <windows.h>
#pragma warning( pop )


#pragma warning( push )
#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>
#include <wchar.h>
#include <wincrypt.h>
#include <stdlib.h>

#include <strsafe.h>
#pragma warning( pop )

/////////////////////////////////////////////////////////////////////////////
// DHCP Definitions
/////////////////////////////////////////////////////////////////////////////

#define DHCP_RESNAME  L"DHCP Service"
#define DHCP_SVCNAME  TEXT("DHCPServer")

BOOLEAN WINAPI DhcpDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI DhcpStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );

/////////////////////////////////////////////////////////////////////////////
// WINS Definitions
/////////////////////////////////////////////////////////////////////////////

#define WINS_RESNAME  L"WINS Service"
#define WINS_SVCNAME  TEXT("WINS")

BOOLEAN WINAPI WinsDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI WinsStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );

/////////////////////////////////////////////////////////////////////////////
// General Definitions
/////////////////////////////////////////////////////////////////////////////

#define RESOURCE_TYPE_IP_ADDRESS    L"IP Address"
#define RESOURCE_TYPE_NETWORK_NAME  L"Network Name"

#define DBG_PRINT printf

/////////////////////////////////////////////////////////////////////////////
// Global Variables and Prototypes
/////////////////////////////////////////////////////////////////////////////

// Event Logging routine.

extern PLOG_EVENT_ROUTINE g_pfnLogEvent;

// Resource Status routine for pending Online and Offline calls.

extern PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus;

// Handle to Service Control Manager set by the first Open resource call.

extern SC_HANDLE g_schSCMHandle;


VOID
ClNetResLogSystemEvent1(
    IN DWORD LogLevel,
    IN DWORD MessageId,
    IN DWORD ErrorCode,
    IN LPCWSTR Component
    );

DWORD ConfigureRegistryCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );

/////////////////////////////////////////////////////////////////////////////

#endif // __CLNETRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetres\wins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Wins.cpp
//
//  Description:
//      Resource DLL for WINS Services (ClNetRes).
//
//  Author:
//      David Potter (DavidP) March 17, 1999
//      George Potts (GPotts) April 19, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClNetRes.h"
#include "clusvmsg.h"
#include "clusrtl.h"

//
// Type and constant definitions.
//

#define WINS_PARAMS_REGKEY          L"System\\CurrentControlSet\\Services\\WINS\\Parameters"
#define WINS_DATABASEPATH_REGVALUE  L"DbFileNm"
#define WINS_DATABASEPATH2_REGVALUE L"LogFilePath"
#define WINS_BACKUPPATH_REGVALUE    L"BackupDirPath"
#define WINS_CLUSRESNAME_REGVALUE   L"ClusterResourceName"
#define WINS_DATABASE_FILE_NAME     L"wins.mdb"


// ADDPARAM: Add new properties here.
#define PROP_NAME__DATABASEPATH L"DatabasePath"
#define PROP_NAME__BACKUPPATH   L"BackupPath"


#define PROP_DEFAULT__DATABASEPATH  L"%SystemRoot%\\system32\\wins\\"
#define PROP_DEFAULT__BACKUPPATH    L"%SystemRoot%\\system32\\wins\\backup\\"


// ADDPARAM: Add new properties here.
typedef struct _WINS_PROPS
{
    PWSTR           pszDatabasePath;
    PWSTR           pszBackupPath;
} WINS_PROPS, * PWINS_PROPS;

typedef struct _WINS_RESOURCE
{
    RESID                   resid; // for validation
    WINS_PROPS              props;
    HCLUSTER                hCluster;
    HRESOURCE               hResource;
    SC_HANDLE               hService;
    DWORD                   dwServicePid;
    HKEY                    hkeyParameters;
    RESOURCE_HANDLE         hResourceHandle;
    LPWSTR                  pwszResourceName;
    CLUS_WORKER             cwWorkerThread;
    CLUSTER_RESOURCE_STATE  state;
} WINS_RESOURCE, * PWINS_RESOURCE;


//
// Global data.
//

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_WinsFunctionTable;

// Single instance semaphore.

#define WINS_SINGLE_INSTANCE_SEMAPHORE L"Cluster$WINS$Semaphore"
static HANDLE g_hSingleInstanceSemaphoreWins = NULL;
static PWINS_RESOURCE g_pSingleInstanceResourceWins = NULL;

//
// WINS Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
WinsResourcePrivateProperties[] =
{
    { PROP_NAME__DATABASEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( WINS_PROPS, pszDatabasePath ) },
    { PROP_NAME__BACKUPPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( WINS_PROPS, pszBackupPath ) },
    { 0 }
};

//
// Registry key checkpoints.
//
LPCWSTR g_pszRegKeysWins[] =
{
    L"System\\CurrentControlSet\\Services\\WINS\\Parameters",
    L"System\\CurrentControlSet\\Services\\WINS\\Partners",
    NULL
};

//
// Function prototypes.
//

RESID WINAPI WinsOpen(
    IN  LPCWSTR         pwszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    );

void WINAPI WinsClose( IN RESID resid );

DWORD WINAPI WinsOnline(
    IN      RESID   resid,
    IN OUT  PHANDLE phEventHandle
    );

DWORD WINAPI WinsOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    );

DWORD WINAPI WinsOffline( IN RESID resid );

DWORD WINAPI WinsOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    );

void WINAPI WinsTerminate( IN RESID resid );

BOOL WINAPI WinsLooksAlive( IN RESID resid );

BOOL WINAPI WinsIsAlive( IN RESID resid );

BOOL WinsCheckIsAlive(
    IN PWINS_RESOURCE   pResourceEntry,
    IN BOOL             fFullCheck
    );

DWORD WINAPI WinsResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD WINAPI WinsResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD WinsGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD WinsReadParametersToParameterBlock(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    );

DWORD WinsGetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    );

DWORD WinsValidatePrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PWINS_PROPS     pProps
    );

DWORD WinsValidateParameters(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps
    );

DWORD WinsSetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize
    );

DWORD WinsZapSystemRegistry(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    );

DWORD WinsGetDefaultPropertyValues(
    IN      PWINS_RESOURCE  pResourceEntry,
    IN OUT  PWINS_PROPS     pProps
    );

DWORD WinsDeleteResourceHandler( IN PWINS_RESOURCE pResourceEntry );

DWORD WinsSetNameHandler(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsDllMain
//
//  Description:
//      Main DLL entry point for the WINS Service resource type.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI WinsDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    DWORD   sc;
    BOOLEAN fRetVal = FALSE;

    UNREFERENCED_PARAMETER( hDllHandle );
    UNREFERENCED_PARAMETER( Reserved );

    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            g_hSingleInstanceSemaphoreWins = CreateSemaphoreW(
                NULL,
                0,
                1,
                WINS_SINGLE_INSTANCE_SEMAPHORE
                );
            sc = GetLastError();
            if ( g_hSingleInstanceSemaphoreWins == NULL )
            {
                fRetVal = FALSE;
                goto Cleanup;
            } // if: error creating semaphore

            if ( sc != ERROR_ALREADY_EXISTS )
            {
                // If the semaphore didnt exist, set its initial count to 1.
                ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1, NULL );
            } // if: semaphore didn't already exist
            break;

        case DLL_PROCESS_DETACH:
            if ( g_hSingleInstanceSemaphoreWins != NULL )
            {
                CloseHandle( g_hSingleInstanceSemaphoreWins );
                g_hSingleInstanceSemaphoreWins = NULL;
            } // if: single instance semaphore was created
            break;

    } // switch: nReason

    fRetVal = TRUE;

Cleanup:

    return fRetVal;

} //*** WinsDllMain


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsStartup
//
//  Description:
//      Startup the resource DLL for the WINS Service resource type.
//      This routine verifies that at least one currently supported version
//      of the resource DLL is between nMinVersionSupported and
//      nMaxVersionSupported. If not, then the resource DLL should return
//      ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD sc;

    // These are stored to globals in the exported DLL Startup.
    UNREFERENCED_PARAMETER( pfnSetResourceStatus );
    UNREFERENCED_PARAMETER( pfnLogEvent );

    if (   (nMinVersionSupported > CLRES_VERSION_V1_00)
        || (nMaxVersionSupported < CLRES_VERSION_V1_00) )
    {
        sc = ERROR_REVISION_MISMATCH;
    } // if: version not supported
    else if ( ClRtlStrNICmp( pszResourceType, WINS_RESNAME, RTL_NUMBER_OF( WINS_RESNAME ) ) != 0 )
    {
        sc = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported
    else
    {
        *pFunctionTable = &g_WinsFunctionTable;
        sc = ERROR_SUCCESS;
    } // else: we support this type of resource

    return sc;

} //*** WinsStartup


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOpen
//
//  Description:
//      Open routine for WINS Service resources.
//
//      Open the specified resource (create an instance of the resource).
//      Allocate all structures necessary to bring the specified resource
//      online.
//
//  Arguments:
//      pwszResourceName [IN]
//          Supplies the name of the resource to open.
//
//      hkeyResourceKey [IN]
//                  Supplies handle to the resource's cluster database key.
//
//      hResourceHandle [IN]
//          A handle that is passed back to the Resource Monitor when the
//          SetResourceStatus or LogEvent method is called.  See the
//          description of the pfnSetResourceStatus and pfnLogEvent arguments
//          to the WinsStartup routine.  This handle should never be
//          closed or used for any purpose other than passing it as an
//          argument back to the Resource Monitor in the SetResourceStatus or
//          LogEvent callbacks.
//
//  Return Value:
//      resid
//          RESID of opened resource.
//
//      NULL
//          Error occurred opening the resource.  Resource Monitor may call
//          GetLastError() to get more details on the error.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI WinsOpen(
    IN  LPCWSTR         pwszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    )
{
    DWORD           sc;
    RESID           resid = 0;
    HKEY            hkeyParameters = NULL;
    PWINS_RESOURCE  pResourceEntry = NULL;
    DWORD           fSemaphoreAcquired = FALSE; 
    size_t          cch;
    HRESULT         hr = S_OK;

    //
    //  Add a log entry for our resource to establish a tid -> res name relationship.  By 
    //  doing this we avoid having to add the resource name to each failure entry below.
    //  This won't generate much noise because Open is only called when the cluster service
    //  comes online or when the resource is created.
    //
    (g_pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"Open called.\n"
        );

    //
    // Check if there is more than one resource of this type.
    //
    sc = WaitForSingleObject( g_hSingleInstanceSemaphoreWins, 0 );
    if ( sc != WAIT_OBJECT_0 )
    {
        //
        // A version of this service is already running or the wait failed.
        //
        if ( sc == WAIT_TIMEOUT )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Another WINS Service resource is already open.\n"
                );
            sc = ERROR_SERVICE_ALREADY_RUNNING;
        }
        else
        {
            if ( sc == WAIT_FAILED )
            {
                sc = GetLastError();
            }
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Wait failed: %1!d!.\n",
                sc
                );
        }
        goto Cleanup;
    } // if: semaphore for resources of this type already already locked

    sc = ERROR_SUCCESS;
    fSemaphoreAcquired = TRUE;
    
    if ( g_pSingleInstanceResourceWins != NULL )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Service resource info non-null!\n"
            );
        sc = ERROR_DUPLICATE_SERVICE_NAME;
        goto Cleanup;
    } // if: resource of this type already exists

    //
    // Get a global handle to the Service Control Manager (SCM).
    // There is no call to CloseSCManager(), since the only time we will
    // need to close this handle is if we are shutting down.
    //
    if ( g_schSCMHandle == NULL )
    {
        g_schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
        if ( g_schSCMHandle == NULL )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Failed to open Service Control Manager. Error: %1!u! (%1!#08x!).\n",
                sc
                );
            goto Cleanup;
        } // if: error opening the Service Control Manager
    } // if: Service Control Manager not open yet

    //
    // Make sure the service has been stopped.
    //
    sc = ResUtilStopResourceService( WINS_SVCNAME );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Failed to stop the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
            WINS_SVCNAME,
            sc
            );
        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_STOP_ERROR,
            sc,
            L"WINS" );
        // Don't goto Cleanup here if we fail since we retry to stop it in WinsOnlineThread 
    } // if: resource of this type already exists

    //
    // Open the Parameters registry key for this resource.
    //
    sc = ClusterRegOpenKey(
                    hkeyResourceKey,
                    L"Parameters",
                    KEY_ALL_ACCESS,
                    &hkeyParameters
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open Parameters key. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error creating the Parameters key for the resource

    //
    // Allocate a resource entry.
    //
    pResourceEntry = new WINS_RESOURCE;
    if ( pResourceEntry == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to allocate resource entry structure. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error allocating memory for the resource

    //
    // Initialize the resource entry..
    //
    ZeroMemory( pResourceEntry, sizeof( *pResourceEntry ) );

    pResourceEntry->resid = static_cast< RESID >( pResourceEntry ); // for validation
    pResourceEntry->hResourceHandle = hResourceHandle;
    pResourceEntry->hkeyParameters = hkeyParameters;
    hkeyParameters = NULL;
    pResourceEntry->state = ClusterResourceOffline;

    //
    // Save the name of the resource.
    //
    cch = wcslen( pwszResourceName ) + 1;
    pResourceEntry->pwszResourceName = new WCHAR[ cch ];
    if ( pResourceEntry->pwszResourceName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if: error allocating memory for the name.

    hr = StringCchCopyW( pResourceEntry->pwszResourceName, cch, pwszResourceName );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

    //
    // Open the cluster.
    //
    pResourceEntry->hCluster = OpenCluster( NULL );
    if ( pResourceEntry->hCluster == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the cluster. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the cluster

    //
    // Open the resource.
    //
    pResourceEntry->hResource = OpenClusterResource( pResourceEntry->hCluster, pwszResourceName );
    if ( pResourceEntry->hResource == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the resource. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the resource

    //
    // Configure registry key checkpoints.
    //
    sc = ConfigureRegistryCheckpoints(
                    pResourceEntry->hResource,
                    hResourceHandle,
                    g_pszRegKeysWins
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error configuring registry key checkpoints

    //
    // Startup for the resource.
    //
    // TODO: Add your resource startup code here.

    resid = static_cast< RESID >( pResourceEntry );
    g_pSingleInstanceResourceWins = pResourceEntry; // bug #274612
    pResourceEntry = NULL;
    sc = ERROR_SUCCESS;

Cleanup:

    if ( hkeyParameters != NULL )
    {
        ClusterRegCloseKey( hkeyParameters );
    } // if: registry key was opened

    if ( pResourceEntry != NULL )
    {
        if ( pResourceEntry->hResource != NULL )
        {
            CloseClusterResource( pResourceEntry->hResource );
        }

        if ( pResourceEntry->hCluster != NULL )
        {
            CloseCluster( pResourceEntry->hCluster );
        }

        delete [] pResourceEntry->pwszResourceName;
        delete pResourceEntry;
    } // if: resource entry allocated

    if ( sc != ERROR_SUCCESS && fSemaphoreAcquired )
    {
        ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1 , NULL );
    }

    SetLastError( sc );

    return resid;

} //*** WinsOpen


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsClose
//
//  Description:
//      Close routine for WINS Service resources.
//
//      Close the specified resource and deallocate all structures, etc.,
//      allocated in the Open call.  If the resource is not in the offline
//      state, then the resource should be taken offline (by calling
//      Terminate) before the close operation is performed.
//
//  Arguments:
//      resid       [IN] Supplies the resource ID  of the resource to close.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI WinsClose( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: Close request for a NULL resource id\n" );
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Close: Resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        goto Cleanup;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n"
        );

    //
    // Close the Parameters key.
    //
    if ( pResourceEntry->hkeyParameters )
    {
        ClusterRegCloseKey( pResourceEntry->hkeyParameters );
    } // if: parameters key is open

    //
    // Clean up the semaphore if this is the single resource instance.
    //
    if ( pResourceEntry == g_pSingleInstanceResourceWins )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"Close: Releasing semaphore %1!ws!.\n",
            WINS_SINGLE_INSTANCE_SEMAPHORE
            );
        g_pSingleInstanceResourceWins = NULL;
        ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1 , NULL );
    } // if: this is the single resource instance

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new propertiess here.
    //
    // Note: props.* members need to be deallocated with LocalFree because
    //       they were retrieved with ResUtil functions which use LocalAlloc.
    //
    LocalFree( pResourceEntry->props.pszDatabasePath );
    LocalFree( pResourceEntry->props.pszBackupPath );
    delete [] pResourceEntry->pwszResourceName;
    delete pResourceEntry;

Cleanup:

    SetLastError( ERROR_SUCCESS );

    return;

} //*** WinsClose


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOnline
//
//  Description:
//      Online routine for WINS Service resources.
//
//      Bring the specified resource online (available for use).  The resource
//      DLL should attempt to arbitrate for the resource if it is present on
//      a shared medium, like a shared SCSI bus.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be brought online
//          (available for use).
//
//      phEventHandle [IN OUT]
//          Returns a signalable handle that is signaled when the resource DLL
//          detects a failure on the resource.  This argument is NULL on
//          input, and the resource DLL returns NULL if asynchronous
//          notification of failurs is not supported.  Otherwise this must be
//          the address of a handle that is signaled on resource failures.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now online.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is pending.  A thread has been activated to process
//          the online request.  The thread that is processing the online
//          request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOnline state (or the resource monitor
//          decides to timeout the online request and Terminate the resource.
//          This pending timeout value is settable and has a default value of
//          3 minutes.).
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOnline(
    IN      RESID       resid,
    IN OUT  PHANDLE     phEventHandle
    )
{
    PWINS_RESOURCE  pResourceEntry;
    DWORD           sc;

    UNREFERENCED_PARAMETER( phEventHandle );

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: Online request for a NULL resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n"
        );

    //
    // Start the Online thread to perform the online operation.
    //
    pResourceEntry->state = ClusterResourceOffline;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    sc = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( WinsOnlineThread ),
                pResourceEntry
                );
    if ( sc != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread. Error: %1!u! (%1!#08x!).\n",
            sc
            );
    } // if: error creating the worker thread
    else
    {
        sc = ERROR_IO_PENDING;
        goto Cleanup;
    } // if: worker thread created successfully

Cleanup:

    return sc;

} //*** WinsOnline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOnlineThread
//
//  Description:
//      Worker function which brings a resource online.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the WINS_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS         resourceStatus;
    DWORD                   sc = ERROR_SUCCESS;
    DWORD                   cbBytesNeeded;
    SERVICE_STATUS_PROCESS  ServiceStatus = { 0 };
    RESOURCE_EXIT_STATE     resExitState;
    DWORD                   nRetryCount = 1200; // 10 min max

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // Create the new environment with the simulated net name when the
    // services queries GetComputerName.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) == FALSE )
    {
        sc = ResUtilSetResourceServiceEnvironment(
                        WINS_SVCNAME,
                        pResourceEntry->hResource,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: error setting the environment for the service
    } // if: not terminating
    else
    {
        goto Cleanup;
    } // else: terminating

    //
    // Make sure the service is ready to be controlled by the cluster.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) == FALSE )
    {
        sc = ResUtilSetResourceServiceStartParameters(
                        WINS_SVCNAME,
                        g_schSCMHandle,
                        &pResourceEntry->hService,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:  error setting service start parameters
    } // if: not terminating
    else
    {
        goto Cleanup;
    } // else: terminating

    //
    // Perform resource-specific initialization before starting the service.
    //
    // TODO: Add code to initialize the resource before starting the service.

    //
    // Stop the service if it's running since we are about to change
    // its parameters.
    //
    sc = ResUtilStopResourceService( WINS_SVCNAME );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Failed to stop the '%1!ws!' service. Error %2!u! (%2!#08x!).\n",
            WINS_SVCNAME,
            sc
            );
        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_STOP_ERROR,
            sc,
            L"WINS" );
        goto Cleanup;
    } // if: error stopping the service

    //
    // Read our properties.
    //
    sc = WinsReadParametersToParameterBlock( pResourceEntry, TRUE /* bCheckForRequiredProperties */ );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error reading parameters

    //
    // Validate our properties.
    //
    sc = WinsValidateParameters( pResourceEntry, &pResourceEntry->props );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error validating parameters

    //
    // Write cluster properties to the system registry.
    //
    sc = WinsZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error zapping the WINS registry

    //
    // Start the service.
    //
    if ( StartServiceW( pResourceEntry->hService, 0, NULL ) == FALSE )
    {
        sc = GetLastError();
        if ( sc != ERROR_SERVICE_ALREADY_RUNNING )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to start the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
                WINS_SVCNAME,
                sc
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_START_ERROR,
                sc,
                L"WINS" );
            goto Cleanup;
        } // if: error other than service already running occurred
        else
        {
            sc = ERROR_SUCCESS;
        } // if: service is already running
    } // if: error starting the service

    //
    // Query the status of the service in a loop until it leaves
    // the pending state.
    //
    while ( ( ClusWorkerCheckTerminate( pWorker ) == FALSE ) && ( nRetryCount-- != 0 ) )
    {
        //
        // Query the service status.
        //
        if ( FALSE == QueryServiceStatusEx(
                        pResourceEntry->hService,
                        SC_STATUS_PROCESS_INFO,
                        reinterpret_cast< LPBYTE >( &ServiceStatus ),
                        sizeof( SERVICE_STATUS_PROCESS ),
                        &cbBytesNeeded
                        ) )
        {
            sc = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to query service status for the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
                WINS_SVCNAME,
                sc
                );          
            resourceStatus.ResourceState = ClusterResourceFailed;
            break;
        } // if: error querying service status

        //
        // If the service is in any pending state continue waiting, otherwise we are done.
        //
        if (    ServiceStatus.dwCurrentState == SERVICE_START_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING
            ||  ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING )
        {
            resourceStatus.ResourceState = ClusterResourceOnlinePending;
        } // if: service state is pending
        else
        {
            break;
        } // else: service state is not pending

        resourceStatus.CheckPoint++;

        //
        // Notify the Resource Monitor of our current state.
        //
        resExitState = static_cast< RESOURCE_EXIT_STATE >(
            (g_pfnSetResourceStatus)(
                            pResourceEntry->hResourceHandle,
                            &resourceStatus
                            ) );
        if ( resExitState == ResourceExitStateTerminate )
        {
            break;
        } // if: resource is being terminated

        //
        // Check again in 1/2 second.
        //
        Sleep( 500 );

    } // while: not terminating while querying the status of the service

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error querying the status of the service

    //
    // Assume that we failed.
    //
    resourceStatus.ResourceState = ClusterResourceFailed;

    //
    // If we exited the loop before setting ServiceStatus, then return now.
    //
    if ( ClusWorkerCheckTerminate( pWorker ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Asked to terminate.\n"
            );
        goto Cleanup;
    } // if: being terminated

    if ( nRetryCount == (DWORD) -1 )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Retry period expired.\n"
            );
        goto Cleanup;
    } // if: being terminated

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING )
    {
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR )
        {
            sc = ServiceStatus.dwServiceSpecificExitCode;
        } else {
            sc = ServiceStatus.dwWin32ExitCode;
        }

        ClNetResLogSystemEvent1(
            LOG_CRITICAL,
            NETRES_RESOURCE_START_ERROR,
            sc,
            L"WINS" );
        (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: The '%1!ws!' service failed during initialization. Error: %2!u! (%2!#08x!).\n",
                WINS_SVCNAME,
                sc
                );
        goto Cleanup;
    } // if: service not running when loop exited

    //
    // Set status to online and save process ID of the service.
    // This is used to enable us to terminate the resource more
    // effectively.
    //
    resourceStatus.ResourceState = ClusterResourceOnline;
    if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) )
    {
        pResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    } // if: not running in the system process

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"The '%1!ws!' service is now on line.\n",
        WINS_SVCNAME
        );

Cleanup:

    //
    // Cleanup.
    //
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Error %1!u! (%1!#08x!) bringing resource online.\n",
            sc
            );
        if ( pResourceEntry->hService != NULL )
        {
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
        } // if: service handle was opened
    } // if: error occurred

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return sc;

} //*** WinsOnlineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOffline
//
//  Description:
//      Offline routine for WINS Service resources.
//
//      Take the specified resource offline (unavailable for use).  Wait
//      for any cleanup operations to complete before returning.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          gracefully.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now offline.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is still pending.  A thread has been activated to
//          process the offline request.  The thread that is processing the
//          offline request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOffline state (or the resource monitor
//          decides  to timeout the offline request and Terminate the
//          resource).
//
//      Win32 error code
//          The operation failed.  This will cause the Resource Monitor to
//          log an event and call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOffline( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;
    DWORD           sc;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: Offline request for a NULL resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n"
        );

    //
    // Start the Offline thread to perform the offline operation.
    //
    pResourceEntry->state = ClusterResourceOfflinePending;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    sc = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( WinsOfflineThread ),
                pResourceEntry
                );
    if ( sc != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread. Error: %1!u! (%1!#08x!).\n",
            sc
            );
    } // if: error creating the worker thread
    else
    {
        sc = ERROR_IO_PENDING;
        goto Cleanup;
    } // if: worker thread created successfully

Cleanup:

    return sc;

} //*** WinsOffline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOfflineThread
//
//  Description:
//      Worker function which takes a resource offline.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the WINS_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS     resourceStatus;
    DWORD               sc = ERROR_SUCCESS;
    DWORD               nRetryTime = 300;   // 300 msec at a time
    DWORD               nRetryCount = 2000; // Try 10 min max
    BOOL                bDidStop = FALSE;
    SERVICE_STATUS      ServiceStatus;
    RESOURCE_EXIT_STATE resExitState;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // If the service has gone offline or was never brought online,
    // we're done.
    //
    if ( pResourceEntry->hService == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto Cleanup;
    }

    //
    // Try to stop the service.  Wait for it to terminate as long
    // as we're not asked to terminate.
    //
    while ( ( ClusWorkerCheckTerminate( pWorker ) == FALSE ) && ( nRetryCount-- != 0 ) )
    {
        //
        // Tell the Resource Monitor we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOfflinePending;
        resourceStatus.CheckPoint++;
        resExitState = static_cast< RESOURCE_EXIT_STATE >(
            g_pfnSetResourceStatus(
                            pResourceEntry->hResourceHandle,
                            &resourceStatus
                            ) );
        if ( resExitState == ResourceExitStateTerminate )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Asked to terminate by call to SetResourceStatus callback.\n"
                );
            break;
        } // if: resource is being terminated

        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // Request that the service be stopped, or if we already did that,
        // request the current status of the service.
        //
        sc = (ControlService(
                        pResourceEntry->hService,
                        (bDidStop
                            ? SERVICE_CONTROL_INTERROGATE
                            : SERVICE_CONTROL_STOP),
                        &ServiceStatus
                        )
                    ? ERROR_SUCCESS
                    : GetLastError()
                    );

        if ( sc == ERROR_SUCCESS )
        {
            bDidStop = TRUE;

            if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: The '%1!ws!' service stopped.\n",
                    WINS_SVCNAME
                    );

                //
                // Set the status.
                //
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: Service is now offline.\n"
                    );
                break;
            } // if: current service state is STOPPED
        } // if: ControlService completed successfully

        else if (   ( sc == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( sc == ERROR_PROCESS_ABORTED )
                ||  ( sc == ERROR_SERVICE_NOT_ACTIVE ) )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: The '%1!ws!' service died or is not active any more; status = %2!u! (%2!#08x!).\n",
                WINS_SVCNAME,
                sc
                );

            //
            // Set the status.
            //
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
            pResourceEntry->dwServicePid = 0;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: Service is now offline.\n"
                );
            break;
        } // else if: service stopped abnormally

        //
        // Handle the case in which SCM refuses to accept control
        // requests sine windows is shutting down.
        //
        if ( sc == ERROR_SHUTDOWN_IN_PROGRESS )
        {
            DWORD dwResourceState;

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: System shutting down. Attempting to terminate service process %1!u! (%1!#08x!)...\n",
                pResourceEntry->dwServicePid
                );

            sc = ResUtilTerminateServiceProcessFromResDll(
                        pResourceEntry->dwServicePid,
                        TRUE,   // bOffline
                        &dwResourceState,
                        g_pfnLogEvent,
                        pResourceEntry->hResourceHandle
                        );
            if ( sc == ERROR_SUCCESS )
            {
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                pResourceEntry->state = ClusterResourceOffline;
            } // if: process terminated successfully
            resourceStatus.ResourceState = (CLUSTER_RESOURCE_STATE) dwResourceState;
            break;
        } // if: Windows is shutting down

        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"OfflineThread: Retrying...\n"
            );

        Sleep( nRetryTime );

    } // while: not asked to terminate

Cleanup:

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return sc;

} //*** WinsOfflineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsTerminate
//
//  Description:
//      Terminate routine for WINS Service resources.
//
//      Take the specified resource offline immediately (the resource is
//      unavailable for use).
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          ungracefully.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI WinsTerminate( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: Terminate request for a NULL resource id.\n" );
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        goto Cleanup;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" 
        );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );

    if ( pResourceEntry->hService != NULL )
    {
        DWORD           nTotalRetryTime = 30*1000;  // Wait 30 secs for shutdown
        DWORD           nRetryTime = 300;           // 300 msec at a time
        DWORD           sc;
        BOOL            bDidStop = FALSE;
        SERVICE_STATUS  ServiceStatus;

        for (;;)
        {
            sc = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( sc == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"Terminate: The '%1!ws!' service stopped.\n",
                        WINS_SVCNAME
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            //
            // Since SCM doesn't accept any control requests during Windows
            // shutdown, don't send any more control requests.  Just exit
            // from this loop and terminate the process by brute force.
            //
            if ( sc == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: System shutdown in progress. Will try to terminate process by brute force...\n"
                    );
                break;
            } // if: Windows is shutting down

            if (    ( sc == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( sc == ERROR_PROCESS_ABORTED )
                ||  ( sc == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: Service died; status = %1!u! (%1!#08x!).\n",
                    sc
                    );
                break;
            } // if: service stopped abnormally

            if ( (nTotalRetryTime -= nRetryTime) <= 0 )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Terminate: Service did not stop; giving up.\n" );

                break;
            } // if: retried too many times

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: Retrying...\n"
                );

            Sleep( nRetryTime );

        } // forever

        //
        // Declare the service offline.  It may not truly be offline, so
        // if there is a pid for this service, try and terminate that process.
        // Note that terminating a process doesnt terminate all the child
        // processes.
        //
        if ( pResourceEntry->dwServicePid != 0 )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: Attempting to terminate process with pid=%1!u! (%1!#08x!)...\n",
                pResourceEntry->dwServicePid
                );
            ResUtilTerminateServiceProcessFromResDll(
                pResourceEntry->dwServicePid,
                FALSE,  // bOffline
                NULL,   // pdwResourceState
                g_pfnLogEvent,
                pResourceEntry->hResourceHandle
                );
        } // if: service process ID available

        CloseServiceHandle( pResourceEntry->hService );
        pResourceEntry->hService = NULL;
        pResourceEntry->dwServicePid = 0;

    } // if: service was started

    pResourceEntry->state = ClusterResourceOffline;

Cleanup:

    return;

} //*** WinsTerminate


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsLooksAlive
//
//  Description:
//      LooksAlive routine for WINS Service resources.
//
//      Perform a quick check to determine if the specified resource is
//      probably online (available for use).  This call should not block for
//      more than 300 ms, preferably less than 50 ms.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is probably online and available for use.
//
//      FALSE
//          The specified resource is not functioning normally.  The IsAlive
//          function will be called to perform a more thorough check.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI WinsLooksAlive( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;
    BOOL            fRetVal = FALSE;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: LooksAlive request for a NULL resource id.\n" );
        fRetVal = FALSE;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        fRetVal = FALSE;
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n"
        );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    fRetVal = WinsCheckIsAlive( pResourceEntry, FALSE /* fFullCheck */ );

Cleanup:

    return fRetVal;

} //*** WinsLooksAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsIsAlive
//
//  Description:
//      IsAlive routine for WINS Service resources.
//
//      Perform a thorough check to determine if the specified resource is
//      online (available for use).  This call should not block for more
//      more than 300 ms, preferably less than 50 ms.  If it must block for
//      longer than this, create a separate thread dedicated to polling for
//      this information and have this routine return the status of the last
//      poll performed.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is online and functioning normally.
//
//      FALSE
//          The specified resource is not functioning normally.  The resource
//          will be terminated and then Online will be called.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI WinsIsAlive( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;
    BOOL            fRetVal = FALSE;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: IsAlive request for a NULL resource id.\n" );
        fRetVal = FALSE;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        fRetVal = FALSE;
        goto Cleanup;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" 
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    fRetVal = WinsCheckIsAlive( pResourceEntry, TRUE /* fFullCheck */ );

Cleanup:

    return fRetVal;

} //*** WinsIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsCheckIsAlive
//
//  Description:
//      Check to see if the resource is alive for WINS Service
//      resources.
//
//  Arguments:
//      pResourceEntry  [IN]
//          Supplies the resource entry for the resource to polled.
//
//      fFullCheck [IN]
//          TRUE = Perform a full check.
//          FALSE = Perform a cursory check.
//
//  Return Value:
//      TRUE    The specified resource is online and functioning normally.
//      FALSE   The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WinsCheckIsAlive(
    IN PWINS_RESOURCE   pResourceEntry,
    IN BOOL             fFullCheck
    )
{
    BOOL    bIsAlive = TRUE;
    DWORD   sc;

    //
    // Check to see if the resource is alive.
    //
    sc = ResUtilVerifyService( pResourceEntry->hService );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"CheckIsAlive: Verification of the '%1!ws!' service failed. Error: %2!u! (%2!#08x!).\n",
            WINS_SVCNAME,
            sc
            );
        bIsAlive = FALSE;
        goto Cleanup;
    } // if: error verifying service

    if ( fFullCheck )
    {
        // TODO: Add code to perform a full check.
    } // if: performing a full check

Cleanup:

    return bIsAlive;

} //*** WinsCheckIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsResourceControl
//
//  Description:
//      ResourceControl routine for WINS Service resources.
//
//      Perform the control request specified by nControlCode on the specified
//      resource.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID for the specific resource.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD           sc;
    PWINS_RESOURCE  pResourceEntry;
    DWORD           cbRequired = 0;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT( "Wins: ResourceControl request for a NULL resource id.\n" );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! resid = %1!u! (%1!#08x!).\n",
            resid
            );
        sc = ERROR_RESOURCE_NOT_FOUND;
        goto Cleanup;
    } // if: invalid resource ID

    switch ( nControlCode )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            sc = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            sc = ResUtilGetPropertyFormats(
                                        WinsResourcePrivateProperties,
                                        static_cast< LPWSTR >( pOutBuffer ),
                                        cbOutBufferSize,
                                        pcbBytesReturned,
                                        &cbRequired );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            sc = ResUtilEnumProperties(
                            WinsResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            sc = WinsGetPrivateResProperties(
                            pResourceEntry,
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            sc = WinsValidatePrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize,
                            NULL
                            );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            sc = WinsSetPrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize
                            );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            sc = WinsGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            sc = WinsDeleteResourceHandler( pResourceEntry );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            sc = WinsSetNameHandler(
                            pResourceEntry,
                            static_cast< LPWSTR >( pInBuffer )
                            );
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
        case CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:
        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
        default:
            sc = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

Cleanup:

    return sc;

} //*** WinsResourceControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsResourceTypeControl
//
//  Description:
//      ResourceTypeControl routine for WINS Service resources.
//
//      Perform the control request specified by nControlCode.
//
//  Arguments:
//      pszResourceTypeName [IN]
//          Supplies the name of the resource type.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD   sc;
    DWORD   cbRequired = 0;

    UNREFERENCED_PARAMETER( pszResourceTypeName );
    UNREFERENCED_PARAMETER( pInBuffer );
    UNREFERENCED_PARAMETER( cbInBufferSize );

    switch ( nControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *pcbBytesReturned = 0;
            sc = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            sc = ResUtilGetPropertyFormats(
                                WinsResourcePrivateProperties,
                                static_cast< LPWSTR >( pOutBuffer ),
                                cbOutBufferSize,
                                pcbBytesReturned,
                                &cbRequired );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            sc = ResUtilEnumProperties(
                            WinsResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            sc = WinsGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
        case CLUSCTL_RESOURCE_TYPE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_TYPE_EVICT_NODE:
        default:
            sc = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return sc;

} //*** WinsResourceTypeControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetRequiredDependencies
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    // TODO: Specify your resource's required dependencies here.
    //   The default is that the resource requires a dependency on a
    //   storage class resource (e.g. Physical Disk) and an IP Address
    //   resource.
    struct DEP_DATA
    {
        CLUSPROP_RESOURCE_CLASS rcStorage;
        CLUSPROP_SZ_DECLARE( ipaddrEntry, RTL_NUMBER_OF( RESOURCE_TYPE_IP_ADDRESS ) );
        CLUSPROP_SZ_DECLARE( netnameEntry, RTL_NUMBER_OF( RESOURCE_TYPE_NETWORK_NAME ) );
        CLUSPROP_SYNTAX         endmark;
    };
    DEP_DATA *  pdepdata = static_cast< DEP_DATA * >( pOutBuffer );
    DWORD       sc;
    HRESULT     hr = S_OK;

    *pcbBytesReturned = sizeof( DEP_DATA );
    if ( cbOutBufferSize < sizeof( DEP_DATA ) )
    {
        if ( pOutBuffer == NULL )
        {
            sc = ERROR_SUCCESS;
        } // if: no buffer specified
        else
        {
            sc = ERROR_MORE_DATA;
        } // if: buffer specified
    } // if: output buffer is too small
    else
    {
        ZeroMemory( pdepdata, sizeof( *pdepdata ) );

        //
        // Add the Storage class entry.
        //
        pdepdata->rcStorage.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->rcStorage.cbLength = sizeof( pdepdata->rcStorage.rc );
        pdepdata->rcStorage.rc = CLUS_RESCLASS_STORAGE;

        //
        // Add the IP Address name entry.
        //
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof( RESOURCE_TYPE_IP_ADDRESS );
        hr = StringCchCopyNW( 
                  pdepdata->ipaddrEntry.sz
                , RTL_NUMBER_OF( pdepdata->ipaddrEntry.sz )
                , RESOURCE_TYPE_IP_ADDRESS 
                , RTL_NUMBER_OF( RESOURCE_TYPE_IP_ADDRESS )
                );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        //
        // Add the Network Name name entry.
        //
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof( RESOURCE_TYPE_NETWORK_NAME );
        hr = StringCchCopyNW( 
                  pdepdata->netnameEntry.sz
                , RTL_NUMBER_OF( pdepdata->netnameEntry.sz )
                , RESOURCE_TYPE_NETWORK_NAME 
                , RTL_NUMBER_OF( RESOURCE_TYPE_NETWORK_NAME )
                );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        //
        // Add the endmark.
        //
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;

        sc = ERROR_SUCCESS;
    } // else: output buffer is large enough

Cleanup:

    return sc;

} //*** WinsGetRequiredDependencies


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsReadParametersToParameterBlock
//
//  Description:
//      Reads all the parameters for a specied WINS resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      bCheckForRequiredProperties [IN]
//          Determines whether an error should be generated if a required
//          property hasn't been specified.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsReadParametersToParameterBlock(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    )
{
    DWORD       sc;
    LPWSTR      pszNameOfPropInError;

    //
    // Read our parameters.
    //
    sc = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->hkeyParameters,
                    WinsResourcePrivateProperties,
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ReadParametersToParameterBlock: Unable to read the '%1!ws!' property. Error: %2!u! (%2!#08x!).\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            sc
            );
    } // if: error getting properties

    return sc;

} //*** WinsReadParametersToParameterBlock


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    )
{
    DWORD   sc;
    DWORD   nRetStatus = ERROR_SUCCESS;
    DWORD   cbRequired = 0;
    DWORD   cbLocalOutBufferSize = cbOutBufferSize;

    //
    // Read our parameters.
    //
    sc = WinsReadParametersToParameterBlock(
                        pResourceEntry,
                        FALSE /* bCheckForRequiredProperties */
                        );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        goto Cleanup;
    } // if: error reading parameters

    //
    // If the properties aren't set yet, retrieve the values from
    // the system registry.
    //
    sc = WinsGetDefaultPropertyValues( pResourceEntry, &pResourceEntry->props );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        goto Cleanup;
    } // if: error getting default properties

    //
    // Construct a property list from the parameter block.
    //
    sc = ResUtilPropertyListFromParameterBlock(
                    WinsResourcePrivateProperties,
                    pOutBuffer,
                    &cbLocalOutBufferSize,
                    reinterpret_cast< const LPBYTE >( &pResourceEntry->props ),
                    pcbBytesReturned,
                    &cbRequired
                    );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetPrivateResProperies: Error constructing property list from parameter block. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        //
        // Don't exit the loop if buffer is too small.
        //
        if ( sc != ERROR_MORE_DATA )
        {
            goto Cleanup;
        } // if: buffer is too small
    } // if: error getting properties

    //
    // Add unknown properties.
    //
    sc = ResUtilAddUnknownProperties(
                    pResourceEntry->hkeyParameters,
                    WinsResourcePrivateProperties,
                    pOutBuffer,
                    cbOutBufferSize,
                    pcbBytesReturned,
                    &cbRequired
                    );
    if ( sc != ERROR_SUCCESS )
    {
        nRetStatus = sc;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"GetPrivateResProperties: Error adding unknown properties to the property list. Error: %1!u! (%1!#08x!).\n",
            sc
            );
        goto Cleanup;
    } // if: error adding unknown properties

Cleanup:

    if ( nRetStatus == ERROR_MORE_DATA )
    {
        *pcbBytesReturned = cbRequired;
    } // if: output buffer is too small

    return nRetStatus;

} //*** WinsGetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsValidatePrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pProps [OUT]
//          Supplies the parameter block to fill in (optional).
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsValidatePrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PWINS_PROPS     pProps
    )
{
    DWORD       sc = ERROR_SUCCESS;
    WINS_PROPS  propsCurrent;
    WINS_PROPS  propsNew;
    PWINS_PROPS pLocalProps = NULL;
    LPWSTR      pszNameOfPropInError;
    BOOL        bRetrievedProps = FALSE;

    //
    // Check if there is input data.
    //
    if ( ( pInBuffer == NULL ) || ( cbInBufferSize < sizeof( DWORD ) ) )
    {
        sc = ERROR_INVALID_DATA;
        goto Cleanup;
    } // if: no input buffer or input buffer not big enough to contain property list

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

    sc = ResUtilGetPropertiesToParameterBlock(
                 pResourceEntry->hkeyParameters,
                 WinsResourcePrivateProperties,
                 reinterpret_cast< LPBYTE >( &propsCurrent ),
                 FALSE, /*CheckForRequiredProperties*/
                 &pszNameOfPropInError
                 );

    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidatePrivateResProperties: Unable to read the '%1!ws!' property. Error: %2!u! (%2!#08x!).\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            sc
            );
        goto Cleanup;
    } // if: error getting properties
    bRetrievedProps = TRUE;

    //
    // Duplicate the resource parameter block.
    //
    if ( pProps == NULL )
    {
        pLocalProps = &propsNew;
    } // if: no parameter block passed in
    else
    {
        pLocalProps = pProps;
    } // else: parameter block passed in
    ZeroMemory( pLocalProps, sizeof( *pLocalProps ) );
    sc = ResUtilDupParameterBlock(
                    reinterpret_cast< LPBYTE >( pLocalProps ),
                    reinterpret_cast< LPBYTE >( &propsCurrent ),
                    WinsResourcePrivateProperties
                    );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error duplicating the parameter block

    //
    // Parse and validate the properties.
    //
    sc = ResUtilVerifyPropertyTable(
                    WinsResourcePrivateProperties,
                    NULL,
                    TRUE, // AllowUnknownProperties
                    pInBuffer,
                    cbInBufferSize,
                    reinterpret_cast< LPBYTE >( pLocalProps )
                    );
    if ( sc == ERROR_SUCCESS )
    {
        //
        // Validate the property values.
        //
        sc = WinsValidateParameters( pResourceEntry, pLocalProps );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: error validating parameters
        } // if: property list validated successfully

Cleanup:

    //
    // Cleanup our parameter block.
    //
    if ( ( pLocalProps == &propsNew ) || ( ( sc != ERROR_SUCCESS ) && ( pLocalProps != NULL ) ) )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( pLocalProps ),
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            WinsResourcePrivateProperties
            );
    } // if: we duplicated the parameter block

    if ( bRetrievedProps )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            NULL,
            WinsResourcePrivateProperties
            );
    } // if: properties were retrieved

    return sc;

} //*** WinsValidatePrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsValidateParameters
//
//  Description:
//      Validate the parameters of a WINS Service resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Supplies the parameter block to validate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_BAD_PATHNAME
//          Invalid path specified.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsValidateParameters(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps
    )
{
    DWORD   sc;

    //
    // Verify that the service is installed.
    //
    sc = ResUtilVerifyResourceService( WINS_SVCNAME );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_SERVICE_NOT_ACTIVE ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Error verifying the '%1!ws!' service. Error: %2!u! (%2!#08x!).\n",
            WINS_SVCNAME,
            sc
            );
        goto Cleanup;
    } // if: error verifying service
    else
    {
        sc = ERROR_SUCCESS;
    } // else: service verified successfully

    //
    // Validate the DatabasePath.
    //
    if ( ( pProps->pszDatabasePath == NULL ) || ( *pProps->pszDatabasePath == L'\0' ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Database path property must be specified: '%1!ws!'.\n",
            pProps->pszDatabasePath
            );
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if: no database path specified

    //
    // Path must not begin with %SystemRoot% and must be of valid form.
    //
    if (    ( ClRtlStrNICmp( pProps->pszDatabasePath, L"%SystemRoot%", RTL_NUMBER_OF( L"%SystemRoot%" ) ) == 0 )
         || ( ResUtilIsPathValid( pProps->pszDatabasePath ) == FALSE ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Database path property is invalid: '%1!ws!'.\n",
            pProps->pszDatabasePath
            );
        sc = ERROR_BAD_PATHNAME;
        goto Cleanup;
    } // if: database path is malformed

    //
    // Validate the BackupPath.
    //
    if ( ( pProps->pszBackupPath == NULL ) || ( *pProps->pszBackupPath == L'\0' ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Backup database path must be specified: '%1!ws!'.\n",
            pProps->pszBackupPath
            );
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if: no backup path specified

    //
    // Path must not begin with %SystemRoot% and must be of valid form.
    //
    if (    ( ClRtlStrNICmp( pProps->pszBackupPath, L"%SystemRoot%", RTL_NUMBER_OF( L"%SystemRoot%" ) ) == 0 )
         || ( ResUtilIsPathValid( pProps->pszBackupPath ) == FALSE ) )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ValidateParameters: Backup database path property is invalid: '%1!ws!'.\n",
            pProps->pszBackupPath
            );
        sc = ERROR_BAD_PATHNAME;
        goto Cleanup;
    } // if: backup path is malformed

Cleanup:

    return sc;

} //*** WinsValidateParameters


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsSetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsSetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize
    )
{
    DWORD       sc = ERROR_SUCCESS;
    LPWSTR      pszExpandedPath = NULL;
    WINS_PROPS  props;

    ZeroMemory( &props, sizeof( props ) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    sc = WinsValidatePrivateResProperties( pResourceEntry, pInBuffer, cbInBufferSize, &props );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error validating properties

    //
    // Expand any environment variables in the database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszDatabasePath );
    if ( pszExpandedPath == NULL )
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error expanding the database path '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            props.pszDatabasePath,
            sc
            );
        goto Cleanup;
    } // if: error expanding database path        

    //
    // Create the database directory.
    //
    sc = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error creating the database path directory '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            pszExpandedPath,
            sc
            );
        goto Cleanup;
    } // if: error creating the database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Expand any environment variables in the backup database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszBackupPath );
    if ( pszExpandedPath == NULL ) 
    {
        sc = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error expanding the backup database path '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            props.pszBackupPath,
            sc
            );
        goto Cleanup;
    } // if: error expanding backup database path

    //
    // Create the backup directory.
    //
    sc = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error creating the backup database path directory '%1!ws!'. Error: %2!u! (%2!#08x!).\n",
            pszExpandedPath,
            sc
            );
        goto Cleanup;
    } // if: error creating the backup database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Set the entries in the system registry.
    //
    sc = WinsZapSystemRegistry( pResourceEntry, &props, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error zapping the registry

    //
    // Save the property values.
    //
    sc = ResUtilSetPropertyParameterBlockEx(
                    pResourceEntry->hkeyParameters,
                    WinsResourcePrivateProperties,
                    NULL,
                    reinterpret_cast< LPBYTE >( &props ),
                    pInBuffer,
                    cbInBufferSize,
                    TRUE, // bForceWrite
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props )
                    );

    //
    // If the resource is online, return a non-success status.
    //
    // TODO: Modify the code below if your resource can handle
    // changes to properties while it is still online.
    if ( sc == ERROR_SUCCESS )
    {
        if ( pResourceEntry->state == ClusterResourceOnline )
        {
            sc = ERROR_RESOURCE_PROPERTIES_STORED;
        } // if: resource is currently online
        else if ( pResourceEntry->state == ClusterResourceOnlinePending )
        {
            sc = ERROR_RESOURCE_PROPERTIES_STORED;
        } // else if: resource is currently in online pending
        else
        {
            sc = ERROR_SUCCESS;
        } // else: resource is in some other state

        goto Cleanup;
    } // if: properties set successfully

Cleanup:
    LocalFree( pszExpandedPath );
    ResUtilFreeParameterBlock(
        reinterpret_cast< LPBYTE >( &props ),
        reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
        WinsResourcePrivateProperties
        );

    return sc;

} //*** WinsSetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsZapSystemRegistry
//
//  Description:
//      Zap the values in the system registry used by the service with
//      cluster properties.
//
//  Arguments:
//
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Parameter block containing properties with which to zap the
//          registry.
//
//      hkeyParametersKey [IN]
//          Service Parameters key.  Can be specified as NULL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsZapSystemRegistry(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    )
{
    DWORD   sc;
    size_t  cch;
    LPWSTR  pszValue = NULL;
    HKEY    hkeyParamsKey = hkeyParametersKey;
    BOOL    fAddBackslash;
    HRESULT hr = S_OK;

    if ( hkeyParametersKey == NULL )
    {
        //
        // Open the service Parameters key
        //
        sc = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        WINS_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( sc != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"ZapSystemRegistry: Unable to open the '%1!ws!' key. Error %2!u! (%2!#08x!).\n",
                WINS_PARAMS_REGKEY,
                sc
                );
            goto Cleanup;
        } // if: error opening the registry key
    } // if: no registry key specified

    //
    // Add the database file name.
    //
    cch = wcslen( pProps->pszDatabasePath );
    if ( pProps->pszDatabasePath[ cch - 1 ] != L'\\' )
    {
        fAddBackslash = TRUE;
        cch++;
    } // if: missing backslash
    else
    {
        fAddBackslash = FALSE;

    } // else: not missing backslash
    cch++;  // Add one for NULL
    cch += RTL_NUMBER_OF( WINS_DATABASE_FILE_NAME );

    pszValue = new WCHAR[ cch ];
    if ( pszValue == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;

    } // if: error allocating memory

    hr = StringCchPrintfW( pszValue, cch, ( fAddBackslash ? L"%ws\\%ws" : L"%ws%ws" ), pProps->pszDatabasePath, WINS_DATABASE_FILE_NAME );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

    //
    // Set the database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    WINS_DATABASEPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( pszValue ),
                    (DWORD) ( cch * sizeof( WCHAR ) )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the WINS '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            WINS_DATABASEPATH_REGVALUE,
            pszValue,
            sc
            );
        goto Cleanup;
    } // if: error setting the database path in the registry

    // Truncate the path to remove the WINS_DATABASE_FILE_NAME
    {
        LPWSTR psz = wcsrchr( pszValue, L'\\' ) + 1;
        *psz = L'\0';
    } // end truncate

    //
    // Set the second database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    WINS_DATABASEPATH2_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( pszValue ),
                    (DWORD) ( wcslen( pszValue ) + 1 ) * sizeof( *pszValue )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the WINS '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            WINS_DATABASEPATH2_REGVALUE,
            pszValue,
            sc
            );
        goto Cleanup;
    } // if: error setting the second database path in the registry

    delete [] pszValue;
    pszValue = NULL;

    //
    // Add a backslash if needed.
    //
    cch = wcslen( pProps->pszBackupPath );
    if ( pProps->pszBackupPath[ cch - 1 ] != L'\\' )
    {
        WCHAR * pwch = NULL;

        cch += 2;   //  Add one for NULL and one for the backslash
        pszValue = new WCHAR[ cch ];
        if ( pszValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        } // if: error allocating memory

        hr = StringCchCopyExW( pszValue, cch - 1, pProps->pszBackupPath, &pwch, NULL, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        *pwch++ = L'\\';
        *pwch = L'\0';

    } // if: missing backslash

    //
    // Set the backup database path in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    WINS_BACKUPPATH_REGVALUE,
                    0,
                    REG_EXPAND_SZ,
                    reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ),
                    (DWORD) ( wcslen( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ) + 1 ) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ZapSystemRegistry: Unable to set the WINS '%1!ws!' value in the system registry to '%2!ws!'. Error %3!u! (%3!#08x!).\n",
            WINS_BACKUPPATH_REGVALUE,
            ( pszValue != NULL ? pszValue : pProps->pszBackupPath ),
            sc
            );
        goto Cleanup;
    } // if: error setting the backup database path in the registry

    delete [] pszValue;
    pszValue = NULL;

    //
    // Set the cluster resource name in the system registry.
    //
    sc = RegSetValueExW(
                    hkeyParamsKey,
                    WINS_CLUSRESNAME_REGVALUE,
                    0,
                    REG_SZ,
                    reinterpret_cast< PBYTE >( pResourceEntry->pwszResourceName ),
                    (DWORD) (wcslen( pResourceEntry->pwszResourceName ) + 1) * sizeof( WCHAR )
                    );
    if ( sc != ERROR_SUCCESS )
    {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"ZapSystemRegistry: Unable to set the WINS '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
                WINS_CLUSRESNAME_REGVALUE,
                sc
                );
            goto Cleanup;
        } // if: error setting the cluster resource name in the registry

Cleanup:

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != hkeyParametersKey )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    delete [] pszValue;

    return sc;

} //*** WinsZapSystemRegistry


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetDefaultPropertyValues
//
//  Description:
//      If any of the properties are not set, use the values from the
//      system registry as default values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN OUT]
//          Parameter block containing properties to set defaults in.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetDefaultPropertyValues(
    IN      PWINS_RESOURCE  pResourceEntry,
    IN OUT  PWINS_PROPS     pProps
    )
{
    DWORD   sc = ERROR_SUCCESS;
    DWORD   nType;
    DWORD   cbValue = 0;
    size_t  cch;
    HKEY    hkeyParamsKey = NULL;
    LPWSTR  pszValue = NULL;
    LPWSTR  pszValue2 = NULL;
    WCHAR   szDrive[ _MAX_PATH ];
    WCHAR   szDir[ _MAX_PATH ];
    HRESULT hr = S_OK;

    if (    ( pProps->pszDatabasePath == NULL )
        ||  ( *pProps->pszDatabasePath == L'\0' )
        ||  ( pProps->pszBackupPath == NULL )
        ||  ( *pProps->pszBackupPath == L'\0' )
        )
    {
        //
        // Open the service Parameters key
        //
        sc = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        WINS_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( sc != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"GetDefaultPropertyValues: Unable to open the '%1!ws!' key. Error %2!u! (%2!#08x!).\n",
                WINS_PARAMS_REGKEY,
                sc
                );
            goto Cleanup;
        } // if: error opening the Parameters key

        ///////////////////
        // DATABASE PATH //
        ///////////////////
        if ( ( pProps->pszDatabasePath == NULL ) || ( *pProps->pszDatabasePath == L'\0' ) )
        {
            //
            // Get the database path from the system registry.
            //
            sc = RegQueryValueExW(
                            hkeyParamsKey,
                            WINS_DATABASEPATH_REGVALUE,
                            NULL,               // Reserved
                            &nType,
                            NULL,               // lpbData
                            &cbValue
                            );
            if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
            {
                //
                // Value was found.
                //
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory

                sc = RegQueryValueExW(
                                hkeyParamsKey,
                                WINS_DATABASEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                reinterpret_cast< PUCHAR >( pszValue ),
                                &cbValue
                                );
            } // if: value size read successfully
            else if ( sc == ERROR_FILE_NOT_FOUND )
            {
                //
                // Value was not found.  Use default value.
                //
                cch = RTL_NUMBER_OF( PROP_DEFAULT__DATABASEPATH );
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cch * sizeof( WCHAR ) ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory

                hr = StringCchCopyW( pszValue, cch, PROP_DEFAULT__DATABASEPATH );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

                sc = ERROR_SUCCESS;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: The WINS '%1!ws!' value from the system registry was not found. Using default value '%2!ws!'.\n",
                    WINS_DATABASEPATH_REGVALUE,
                    PROP_DEFAULT__DATABASEPATH
                    );
            } // else if: value not found

            if ( sc != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: Unable to get the WINS '%1!ws!' value from the system registry. Error %2!u! (%2!#08x!).\n",
                    WINS_DATABASEPATH_REGVALUE,
                    sc
                    );
                LocalFree( pszValue );
                pszValue = NULL;
            } // if: error reading the value
            else
            {
                //
                // Remove the file name from the database path.
                //
                _wsplitpath( pszValue, szDrive, szDir, NULL, NULL );

                LocalFree( pszValue );
                pszValue = NULL;

                cch = wcslen( szDrive ) + wcslen( szDir ) + 1;
                pszValue2 = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cch * sizeof( WCHAR ) ) );
                if ( pszValue2 == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory

                hr = StringCchPrintfW( pszValue2, cch, L"%ws%ws", szDrive, szDir );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

                LocalFree( pProps->pszDatabasePath );
                pProps->pszDatabasePath = pszValue2;
                pszValue2 = NULL;
            } // else: no error reading the value
        } // if: value for DatabasePath not found yet

        /////////////////
        // BACKUP PATH //
        /////////////////
        if ( ( pProps->pszBackupPath == NULL ) || ( *pProps->pszBackupPath == L'\0' ) )
        {
            //
            // Get the backup database path from the system registry.
            //
            sc = RegQueryValueExW(
                            hkeyParamsKey,
                            WINS_BACKUPPATH_REGVALUE,
                            NULL,               // Reserved
                            &nType,
                            NULL,               // lpbData
                            &cbValue
                            );
            if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
            {
                //
                // Value was found.
                //
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory

                sc = RegQueryValueExW(
                                hkeyParamsKey,
                                WINS_BACKUPPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                reinterpret_cast< PUCHAR >( pszValue ),
                                &cbValue
                                );
            } // if: value size read successfully
            else if ( sc == ERROR_FILE_NOT_FOUND )
            {
                //
                // Value was not found.  Use default value.
                //
                cch = RTL_NUMBER_OF( PROP_DEFAULT__BACKUPPATH );
                pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cch * sizeof( WCHAR ) ) );
                if ( pszValue == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                } // if: error allocating memory

                hr = StringCchCopyW( pszValue, cch, PROP_DEFAULT__BACKUPPATH );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

                sc = ERROR_SUCCESS;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: The WINS '%1!ws!' value from the system registry was not found. Using default value '%2!ws!'.\n",
                    WINS_BACKUPPATH_REGVALUE,
                    PROP_DEFAULT__BACKUPPATH
                    );
            } // else if: value not found
            if ( sc != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"GetDefaultPropertyValues: Unable to get the WINS '%1!ws!' value from the system registry. Error %2!u! (%2!#08x!).\n",
                    WINS_BACKUPPATH_REGVALUE,
                    sc
                    );
                goto Cleanup;
            } // if: error reading the value

            LocalFree( pProps->pszBackupPath );
            pProps->pszBackupPath = pszValue;
            pszValue = NULL;
        } // if: value for BackupPath not found yet
    } // if: some value not found yet

Cleanup:

    LocalFree( pszValue );
    LocalFree( pszValue2 );

    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the Parameters key

    //
    // If a key or value wasn't found, treat it as a success.
    //
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        sc = ERROR_SUCCESS;
    } // if: couldn't find one of the values

    return sc;

} //*** WinsGetDefaultPropertyValues


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsDeleteResourceHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_DELETE control code by restoring the
//      system registry parameters to their former values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsDeleteResourceHandler( IN PWINS_RESOURCE pResourceEntry )
{
    DWORD   sc = ERROR_SUCCESS;
    HKEY    hkeyParamsKey = NULL;

    //
    // Open the service Parameters key
    //
    sc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    WINS_PARAMS_REGKEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeyParamsKey
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to open the '%1!ws!' key. Error %2!u! (%2!#08x!).\n",
            WINS_PARAMS_REGKEY,
            sc
            );
        goto Cleanup;
    } // if: error opening the registry key

    //
    // Delete the database path in the system registry.
    //
    sc = RegDeleteValueW(
                    hkeyParamsKey,
                    WINS_DATABASEPATH_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the WINS '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            WINS_DATABASEPATH_REGVALUE,
            sc
            );
        goto Cleanup;
    } // if: error deleting the database path in the registry

    //
    // Delete the second database path in the system registry.
    //
    sc = RegDeleteValueW(
                    hkeyParamsKey,
                    WINS_DATABASEPATH2_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the WINS '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            WINS_DATABASEPATH2_REGVALUE,
            sc
            );
        goto Cleanup;
    } // if: error deleting the second database path in the registry

    //
    // Delete the backup database path in the system registry.
    //
    sc = RegDeleteValueW(
                    hkeyParamsKey,
                    WINS_BACKUPPATH_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the WINS '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            WINS_BACKUPPATH_REGVALUE,
            sc
            );
        goto Cleanup;
    } // if: error deleting the backup database path in the registry

    //
    // Delete the cluster resource name in the system registry.
    //
    sc = RegDeleteValueW(
                    hkeyParamsKey,
                    WINS_CLUSRESNAME_REGVALUE
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"DeleteResourceHandler: Unable to delete the WINS '%1!ws!' value in the system registry. Error %2!u! (%2!#08x!).\n",
            WINS_CLUSRESNAME_REGVALUE,
            sc
            );
        goto Cleanup;
    } // if: error deleting the cluster resource name in the registry

Cleanup:

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    return sc;

} //*** WinsDeleteResourceHandler


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsSetNameHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_NAME control code by saving the new
//      name of the resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pwszName [IN]
//          The new name of the resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsSetNameHandler(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      LPWSTR          pwszName
    )
{
    DWORD   sc = ERROR_SUCCESS;
    size_t  cch;
    HRESULT hr = S_OK;
    LPWSTR  pwszNewName = NULL;

    //
    //  Save the name of the resource.
    //
    cch = wcslen( pwszName ) + 1;
    pwszNewName = new WCHAR[ cch ];
    if ( pwszNewName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"SetNameHandler: Failed to allocate memory for the new resource name '%1!ws!'. Error %2!u! (%2!#08x!).\n",
            pwszName,
            sc
            );
        goto Cleanup;
    } // if: error allocating memory for the name.

    //
    //  Copy the new name to our new buffer.
    //
    hr = StringCchCopyW( pwszNewName, cch, pwszName );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

    //
    //  Now free the old one and update pResourceEntry.
    //
    delete [] pResourceEntry->pwszResourceName;
    pResourceEntry->pwszResourceName = pwszNewName;
    pwszNewName = NULL;

    //
    // Write cluster properties to the system registry.
    //
    sc = WinsZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        //
        //  Not much that we can do here.  According to the docs, the name
        //  has already been changed in the clusdb by the time we're called,
        //  so I guess we should reflect that.
        //
        goto Cleanup;
    } // if: error zapping the WINS registry

Cleanup:

    delete [] pwszNewName;

    return sc;

} //*** WinsSetNameHandler


/////////////////////////////////////////////////////////////////////////////
//
// Define Function Table
//
/////////////////////////////////////////////////////////////////////////////

CLRES_V1_FUNCTION_TABLE(
    g_WinsFunctionTable,    // Name
    CLRES_VERSION_V1_00,    // Version
    Wins,                   // Prefix
    NULL,                   // Arbitrate
    NULL,                   // Release
    WinsResourceControl,    // ResControl
    WinsResourceTypeControl // ResTypeControl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_INL__
#define __BASEPAGE_INL__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

inline IWCWizardCallback * CBasePropertyPage::PiWizardCallback( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->PiWizardCallback();

} //*** CBasePropertyPage::PiWizardCallback()

inline BOOL CBasePropertyPage::BWizard( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->BWizard();

} //*** CBasePropertyPage::BWizard()

inline HCLUSTER CBasePropertyPage::Hcluster( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Hcluster();

} //*** CBasePropertyPage::Hcluster()

inline CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Cot();

} //*** CBasePropertyPage::Cot()

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Description:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CBasePropertyPage, CPropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBasePropertyPage, CPropertyPage )
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage( void )
{
    CommonConstruct();

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap
    )
    : m_dlghelp( pdwHelpMap, 0 )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      idd                 [IN] Dialog template resource ID.
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//      nIDCaption          [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap,
    IN UINT             nIDCaption
    )
    : CPropertyPage( idd, nIDCaption )
    , m_dlghelp( pdwHelpMap, idd )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

} //*** CBasePropertyPage::CBasePropertyPage( UINT, UINT )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct( void )
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
    m_bSaved = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idsCaption = NULL;

    m_pdwWizardHelpMap = NULL;

    m_bDoDetach = FALSE;

} //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrInit
//
//  Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrInit( IN OUT CExtObject * peo )
{
    ASSERT( peo != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT         _hr = S_FALSE;
    CWaitCursor     _wc;
    DWORD           _sc = ERROR_SUCCESS;
    CClusPropList   _cpl;

    m_peo = peo;

    // Change the help map if this is a wizard page.
    if ( Peo()->BWizard() )
    {
        m_dlghelp.SetMap( m_pdwWizardHelpMap );
    } // if: in a wizard

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if ( Peo()->BWizard() )
    {
        ASSERT( IddWizardPage() != NULL);
        Construct( IddWizardPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddWizardPage() );
    } // if: adding page to wizard
    else
    {
        ASSERT( IddPropertyPage() != NULL );
        Construct( IddPropertyPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddPropertyPage() );
    } // else: adding page to property sheet

    // Read the properties private to this resource and parse them.
    {
        ASSERT( Peo() != NULL );
        ASSERT( Peo()->PodObjData() );

        // Read the properties.
        switch ( Cot() )
        {
            case CLUADMEX_OT_NODE:
                ASSERT( Peo()->PndNodeData()->m_hnode != NULL );
                _sc = _cpl.ScGetNodeProperties(
                                        Peo()->PndNodeData()->m_hnode,
                                        CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
                                        );
                break;

            case CLUADMEX_OT_GROUP:
                ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );
                _sc = _cpl.ScGetGroupProperties(
                                        Peo()->PgdGroupData()->m_hgroup,
                                        CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
                                        );
                break;

            case CLUADMEX_OT_RESOURCE:
                ASSERT( Peo()->PrdResData()->m_hresource != NULL );
                _sc = _cpl.ScGetResourceProperties(
                                        Peo()->PrdResData()->m_hresource,
                                        CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                        );
                break;

            case CLUADMEX_OT_RESOURCETYPE:
                ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );
                _sc = _cpl.ScGetResourceTypeProperties(
                                        Hcluster(),
                                        Peo()->PodObjData()->m_strName,
                                        CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
                                        );
                break;

            case CLUADMEX_OT_NETWORK:
                ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );
                _sc = _cpl.ScGetNetworkProperties(
                                        Peo()->PndNetworkData()->m_hnetwork,
                                        CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
                                        );
                break;

            case CLUADMEX_OT_NETINTERFACE:
                ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );
                _sc = _cpl.ScGetNetInterfaceProperties(
                                        Peo()->PndNetInterfaceData()->m_hnetinterface,
                                        CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
                                        );
                break;

            default:
                ASSERT( 0 );
        } // switch: object type

        // Parse the properties.
        if ( _sc == ERROR_SUCCESS )
        {
            // Parse the properties.
            try
            {
                _sc = ScParseProperties( _cpl );
            } // try
            catch ( CMemoryException * _pme )
            {
                _hr = E_OUTOFMEMORY;
                _pme->Delete();
            } // catch: CMemoryException
        } // if: properties read successfully

        if ( _sc != ERROR_SUCCESS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
            goto Cleanup;
        } // if: error parsing getting or parsing properties
    } // Read the properties private to this resource and parse them

Cleanup:

    return _hr;

} //*** CBasePropertyPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrCreatePage
//
//  Description:
//      Create the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        Page created successfully.
//      hr          Error creating the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrCreatePage( void )
{
    ASSERT( m_hpage == NULL );

    HRESULT _hr = S_OK;

    m_hpage = CreatePropertySheetPage( &m_psp );
    if ( m_hpage == NULL )
    {
        _hr = HRESULT_FROM_WIN32( GetLastError() );
    } // if: error creating the page

    return _hr;

} //*** CBasePropertyPage::HrCreatePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScParseProperties
//
//  Description:
//      Parse the properties of the resource.  This is in a separate function
//      from HrInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Values:
//      ERROR_SUCCESS   Properties were parsed successfully.
//      Any error returns from ScParseUnknownProperty().
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScParseProperties( IN CClusPropList & rcpl )
{
    DWORD                   _sc;
    DWORD                   _cprop;
    const CObjectProperty * _pprop;

    ASSERT( rcpl.PbPropList() != NULL );

    _sc = rcpl.ScMoveToFirstProperty();
    while ( _sc == ERROR_SUCCESS )
    {
        //
        // Parse known properties.
        //
        for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
        {
            if ( lstrcmpiW( rcpl.PszCurrentPropertyName(), _pprop->m_pwszName ) == 0 )
            {
                if ( rcpl.CpfCurrentValueFormat() == _pprop->m_propFormat )
                {
                    switch ( _pprop->m_propFormat )
                    {
                        case CLUSPROP_FORMAT_SZ:
                        case CLUSPROP_FORMAT_EXPAND_SZ:
                            ASSERT(     (rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
                                    ||  (   (rcpl.CbCurrentValueLength() == 0)
                                        &&  (rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
                            *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                            *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                            // See if we need to find an expanded version
                            if ( _pprop->m_valueEx.pstr != NULL )
                            {
                                // Copy the non-expanded one just in case there isn't an expanded version
                                *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                                // See if they included an expanded version
                                rcpl.ScMoveToNextPropertyValue( );
                                if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_EXPANDED_SZ )
                                {
                                    *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;        
                                } // if: found expanded version

                            } // if: *_pprop->m_valueEx.pstr is present
                            break;
                        case CLUSPROP_FORMAT_EXPANDED_SZ:
                            ASSERT(     (rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
                                    ||  (   (rcpl.CbCurrentValueLength() == 0)
                                        &&  (rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
                            *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                            *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                            // See if we need to find an expanded version
                            if ( _pprop->m_valueEx.pstr != NULL )
                            {
                                // Copy the expanded version
                                *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                                // See if they included a non-expanded version
                                rcpl.ScMoveToNextPropertyValue( );
                                if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_SZ )
                                {
                                    *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                                    *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                                } // if: found non-expanded version

                            } // if: *_pprop->m_valueEx.pstr is present
                            break;
                        case CLUSPROP_FORMAT_DWORD:
                        case CLUSPROP_FORMAT_LONG:
                            ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
                            *_pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                            *_pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                            break;
                        case CLUSPROP_FORMAT_BINARY:
                        case CLUSPROP_FORMAT_MULTI_SZ:
                            *_pprop->m_value.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
                            *_pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                            *_pprop->m_valuePrev.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
                            *_pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                            break;
                        default:
                            ASSERT(0);  // don't know how to deal with this type
                    } // switch: property format

                    // Exit the loop since we found the parameter.
                    break;
                }// if: found a type match

            } // if: found a string match

        } // for: each property that we know about

        //
        // If the property wasn't known, ask the derived class to parse it.
        //
        if ( _cprop == 0 )
        {
            _sc = ScParseUnknownProperty(
                        rcpl.CbhCurrentPropertyName().pName->sz,
                        rcpl.CbhCurrentValue(),
                        static_cast< DWORD >( rcpl.RPvlPropertyValue().CbDataLeft() )
                        );
            if ( _sc != ERROR_SUCCESS )
            {
                return _sc;
            } // if: error parsing the unknown property
        } // if: property not parsed

        //
        // Advance the buffer pointer past the value in the value list.
        //
        _sc = rcpl.ScMoveToNextProperty();
    } // while: more properties to parse

    //
    // If we reached the end of the properties, fix the return code.
    //
    if ( _sc == ERROR_NO_MORE_ITEMS )
    {
        _sc = ERROR_SUCCESS;
    } // if: ended loop after parsing all properties

    return _sc;

} //*** CBasePropertyPage::ScParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCreate
//
//  Description:
//      Handler for the WM_CREATE message.
//
//  Arguments:
//      lpCreateStruct  [IN OUT] Window create structure.
//
//  Return Value:
//      -1      Error.
//      0       Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Attach the window to the property page structure.
    // This has been done once already in the main application, since the
    // main application owns the property sheet.  It needs to be done here
    // so that the window handle can be found in the DLL's handle map.
    if ( FromHandlePermanent( m_hWnd ) == NULL ) // is the window handle already in the handle map
    {
        HWND _hWnd = m_hWnd;
        m_hWnd = NULL;
        Attach( _hWnd );
        m_bDoDetach = TRUE;
    } // if: is the window handle in the handle map

    return CPropertyPage::OnCreate( lpCreateStruct );

} //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnDestroy
//
//  Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Detach the window from the property page structure.
    // This will be done again by the main application, since it owns the
    // property sheet.  It needs to be done here so that the window handle
    // can be removed from the DLL's handle map.
    if ( m_bDoDetach )
    {
        if ( m_hWnd != NULL )
        {
            HWND _hWnd = m_hWnd;

            Detach();
            m_hWnd = _hWnd;
        } // if: do we have a window handle?
    } // if: do we need to balance the attach we did with a detach?

    CPropertyPage::OnDestroy();

} //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //{{AFX_DATA_MAP(CBasePropertyPage)
            // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
        DDX_Control( pDX, IDC_PP_ICON, m_staticIcon );
        DDX_Control( pDX, IDC_PP_TITLE, m_staticTitle );

        if ( pDX->m_bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CWaitCursor _wc;

                // Validate the data.
                if ( ! BSetPrivateProps( TRUE /*bValidateOnly*/ ) )
                {
                    pDX->Fail();
                } // if: error setting private properties
            } // if: Back button not pressed
        } // if: saving data from dialog
        else
        {
            // Set the title.
            DDX_Text( pDX, IDC_PP_TITLE, m_strTitle );
        } // if: not saving data
    }  // if: not saving or haven't saved yet

    // Call the base class method.
    CPropertyPage::DoDataExchange( pDX );

} //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog( void )
{
    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PodObjData() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if ( Peo()->Hicon() != NULL )
    {
        m_staticIcon.SetIcon( Peo()->Hicon() );
    } // if: an icon was specified

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

} //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive( void )
{
    HRESULT     _hr;

    ASSERT( Peo() != NULL);
    ASSERT( Peo()->PodObjData() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Reread the data.
    _hr = Peo()->HrGetObjectInfo();
    if ( _hr != NOERROR )
    {
        return FALSE;
    } // if: error getting object info

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    m_bBackPressed = FALSE;
    m_bSaved = FALSE;
    return CPropertyPage::OnSetActive();

} //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply( void )
{
    ASSERT( ! BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnApply();

} //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack( void )
{
    LRESULT     _lResult;

    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _lResult = CPropertyPage::OnWizardBack();
    if ( _lResult != -1 )
    {
        m_bBackPressed = TRUE;
    } // if: no error occurred

    return _lResult;

} //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // Update the data in the class from the page.
    // This necessary because, while OnKillActive() will call UpdateData(),
    // it is called after this method is called, and we need to be sure that
    // data has been saved before we apply them.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return -1;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return -1;
    } // if: error applying changes

    // Create the object.

    return CPropertyPage::OnWizardNext();

} //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // BUG! There should be no need to call UpdateData in this function.
    // See BUG: Finish Button Fails Data Transfer from Page to Variables
    // KB Article ID: Q150349

    // Update the data in the class from the page.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return FALSE;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnWizardFinish();

} //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    SetModified( TRUE );

} //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext( IN BOOL bEnable /*TRUE*/ )
{
    ASSERT( BWizard() );
    ASSERT( PiWizardCallback() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    PiWizardCallback()->EnableNext( reinterpret_cast< LONG * >( Hpage() ), bEnable );

} //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // Save data.
    return BSetPrivateProps();

} //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BBuildPropList
//
//  Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      TRUE        Property list built successfully.
//      FALSE       Error building property list.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL                    _bNewPropsFound = FALSE;
    DWORD                   _cprop;
    const CObjectProperty * _pprop;

    for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
    {
        if ( bNoNewProps && (_pprop->m_fFlags & CObjectProperty::opfNew) )
        {
            _bNewPropsFound = TRUE;
            continue;
        } // if: no new props allowed and this is a new property

        switch ( _pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pstr,
                        *_pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_EXPAND_SZ:
                rcpl.ScAddExpandSzProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pstr,
                        *_pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pdw,
                        *_pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_LONG:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pl,
                        *_pprop->m_valuePrev.pl
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.ppb,
                        *_pprop->m_value.pcb,
                        *_pprop->m_valuePrev.ppb,
                        *_pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 ); // don't know how to deal with this type
                return FALSE;
        } // switch: property format
    } // for: each property

    return ( ! bNoNewProps || _bNewPropsFound );

} //*** CBasePropertyPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BSetPrivateProps
//
//  Description:
//      Set the private properties for this object.
//
//  Arguments:
//      bValidateOnly   [IN] TRUE = only validate the data.
//      bNoNewProps     [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(
    IN BOOL bValidateOnly,  // = FALSE
    IN BOOL bNoNewProps     // = FALSE
    )
{
    BOOL            _fSuccess   = TRUE;
    CClusPropList   _cpl( BWizard() /*bAlwaysAddProp*/ );

    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PrdResData() );
    ASSERT( Peo()->PrdResData()->m_hresource );

    // Build the property list.
    try
    {
        _fSuccess = BBuildPropList( _cpl, bNoNewProps );
    } // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        _fSuccess = FALSE;
    } // catch: CException

    // Set the data.
    if ( _fSuccess )
    {
        if ( (_cpl.PbPropList() != NULL) && (_cpl.CbPropList() > 0) )
        {
            DWORD       _sc = ERROR_SUCCESS;
            DWORD       _dwControlCode;
            DWORD       _cbProps;

            switch ( Cot() )
            {
                case CLUADMEX_OT_NODE:
                    ASSERT( Peo()->PndNodeData() != NULL );
                    ASSERT( Peo()->PndNodeData()->m_hnode != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNodeControl(
                                    Peo()->PndNodeData()->m_hnode,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_GROUP:
                    ASSERT( Peo()->PgdGroupData() != NULL );
                    ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterGroupControl(
                                    Peo()->PgdGroupData()->m_hgroup,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_RESOURCE:
                    ASSERT( Peo()->PrdResData() != NULL );
                    ASSERT( Peo()->PrdResData()->m_hresource != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterResourceControl(
                                    Peo()->PrdResData()->m_hresource,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_RESOURCETYPE:
                    ASSERT( Peo()->PodObjData() != NULL );
                    ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterResourceTypeControl(
                                    Hcluster(),
                                    Peo()->PodObjData()->m_strName,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_NETWORK:
                    ASSERT( Peo()->PndNetworkData() != NULL );
                    ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNetworkControl(
                                    Peo()->PndNetworkData()->m_hnetwork,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_NETINTERFACE:
                    ASSERT( Peo()->PndNetInterfaceData() != NULL );
                    ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNetInterfaceControl(
                                    Peo()->PndNetInterfaceData()->m_hnetinterface,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    static_cast< DWORD >( _cpl.CbPropList() ),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                default:
                    ASSERT( 0 );
            } // switch: object type

            // Handle errors.
            if ( _sc != ERROR_SUCCESS )
            {
                if ( _sc == ERROR_INVALID_PARAMETER )
                {
                    if ( ! bNoNewProps )
                    {
                        _fSuccess = BSetPrivateProps( bValidateOnly, TRUE /*bNoNewProps*/ );
                    } // if: new props are allowed
                    else
                        _fSuccess = FALSE;
                } // if: invalid parameter error occurred
                else if (   bValidateOnly
                        ||  (_sc != ERROR_RESOURCE_PROPERTIES_STORED) )
                {
                    _fSuccess = FALSE;
                } // else if: only validating and error other than properties only stored

                //
                // If an error occurred, display an error message.
                //
                if ( ! _fSuccess )
                {
                    DisplaySetPropsError( _sc, bValidateOnly ? IDS_ERROR_VALIDATING_PROPERTIES : IDS_ERROR_SETTING_PROPERTIES );
                    if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
                    {
                        _fSuccess = TRUE;
                    } // if: properties only stored
                } // if: error occurred
            } // if: error setting/validating data
        } // if: there is data to set
    } // if: no errors building the property list

    // Save data locally.
    if ( ! bValidateOnly && _fSuccess )
    {
        // Save new values as previous values.
        try
        {
            DWORD                   _cprop;
            const CObjectProperty * _pprop;

            for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
            {
                switch ( _pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT(_pprop->m_value.pstr != NULL);
                        ASSERT(_pprop->m_valuePrev.pstr != NULL);
                        *_pprop->m_valuePrev.pstr = *_pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( _pprop->m_value.pdw != NULL );
                        ASSERT( _pprop->m_valuePrev.pdw != NULL );
                        *_pprop->m_valuePrev.pdw = *_pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( _pprop->m_value.ppb != NULL );
                        ASSERT( *_pprop->m_value.ppb != NULL );
                        ASSERT( _pprop->m_value.pcb != NULL );
                        ASSERT( _pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *_pprop->m_valuePrev.ppb != NULL );
                        ASSERT( _pprop->m_valuePrev.pcb != NULL );
                        delete [] *_pprop->m_valuePrev.ppb;
                        *_pprop->m_valuePrev.ppb = new BYTE[ *_pprop->m_value.pcb ];
                        CopyMemory( *_pprop->m_valuePrev.ppb, *_pprop->m_value.ppb, *_pprop->m_value.pcb );
                        *_pprop->m_valuePrev.pcb = *_pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 ); // don't know how to deal with this type
                } // switch: property format
            } // for: each property
        } // try
        catch ( CException * _pe )
        {
            _pe->ReportError();
            _pe->Delete();
            _fSuccess = FALSE;
        } // catch: CException
    } // if: not just validating and successful so far

    //
    // Indicate we successfully saved the properties.
    //
    if ( ! bValidateOnly && _fSuccess )
    {
        m_bSaved = TRUE;
    } // if: successfully saved data

    return _fSuccess;

} //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DisplaySetPropsError
//
//  Routine Description:
//      Display an error caused by setting or validating properties.
//
//  Arguments:
//      sc      [IN] Status to display error on.
//      idsOper [IN] Operation message.
//
//  Return Value:
//      nStatus ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DisplaySetPropsError(
    IN DWORD    sc,
    IN UINT     idsOper
    ) const
{
    CString _strErrorMsg;
    CString _strOperMsg;
    CString _strMsgIdFmt;
    CString _strMsgId;
    CString _strMsg;

    UNREFERENCED_PARAMETER( idsOper );

    _strOperMsg.LoadString( IDS_ERROR_SETTING_PROPERTIES );
    FormatError( _strErrorMsg, sc );
    _strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
    _strMsgId.Format( _strMsgIdFmt, sc, sc );
    _strMsg.Format( _T("%s\n\n%s%s"), _strOperMsg, _strErrorMsg, _strMsgId );
    AfxMessageBox( _strMsg );

}  //*** CBasePropertyPage::DisplaySetPropsError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    m_dlghelp.OnContextMenu( pWnd, point );

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo( HELPINFO * pHelpInfo )
{
    BOOL    _bProcessed;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _bProcessed = m_dlghelp.OnHelpInfo( pHelpInfo );
    if ( ! _bProcessed )
    {
        _bProcessed = CPropertyPage::OnHelpInfo( pHelpInfo );
    } // if: message not processed yet
    return _bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
    LRESULT _bProcessed;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _bProcessed = m_dlghelp.OnCommandHelp( wParam, lParam );
    if ( ! _bProcessed )
    {
        _bProcessed = CPropertyPage::OnCommandHelp( wParam, lParam );
    } // if: message not processed yet

    return _bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\clnetresex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClNetResEx.cpp
//
//  Description:
//      Implementation of the CClNetResApp class and DLL initialization
//      routines.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Maintained by:
//      George Potts (GPotts)   April 19, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning( push )
#pragma warning( disable : 4701 ) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning( pop )

BEGIN_OBJECT_MAP( ObjectMap )
    OBJECT_ENTRY( CLSID_CoClNetResEx, CExtObject )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow( void );
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv );
STDAPI DllRegisterServer( void );
STDAPI DllUnregisterServer( void );
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hcluster );
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hcluster );

/////////////////////////////////////////////////////////////////////////////
// class CClNetResApp
/////////////////////////////////////////////////////////////////////////////

class CClNetResApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();

}; //*** class CClNetResApp

/////////////////////////////////////////////////////////////////////////////
// The one and only CClNetResApp object

CClNetResApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClNetResApp::InitInstance
//
//  Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClNetResApp::InitInstance( void )
{
    BOOL    fSuccess = TRUE;
    BOOL    fEnable;
    HRESULT hr = S_OK;

    // Construct the help path.
    {
        TCHAR szPath[_MAX_PATH];
        TCHAR szDrive[_MAX_PATH];
        TCHAR szDir[_MAX_DIR];
        size_t cchPath;
        VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
        hr = StringCchLength( szPath, RTL_NUMBER_OF( szPath ), &cchPath );
        if ( hr != S_OK )
        {
            fSuccess = FALSE;
            goto Cleanup;
        }
        if (szPath[cchPath - 1] != _T('\\'))
        {
            szPath[cchPath++] = _T('\\');
            szPath[cchPath] = _T('\0');
        } // if: no backslash on the end of the path
        hr = StringCchCopy(&szPath[cchPath], RTL_NUMBER_OF( szPath ) - cchPath, _T("Help\\"));
        if ( hr != S_OK )
        {
            fSuccess = FALSE;
            goto Cleanup;
        }
        _tsplitpath(szPath, szDrive, szDir, NULL, NULL);
        _tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
        free((void *) m_pszHelpFilePath);
        fEnable = AfxEnableMemoryTracking(FALSE);
        m_pszHelpFilePath = _tcsdup(szPath);
        AfxEnableMemoryTracking(fEnable);
    }  // Construct the help path

    _Module.Init( ObjectMap, m_hInstance );
    fSuccess = CWinApp::InitInstance();

Cleanup:

    return fSuccess;

}  //*** CClNetResApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClNetResApp::ExitInstance
//
//  Description:
//      Deinitialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClNetResApp::ExitInstance( void )
{
    _Module.Term();
    return CWinApp::ExitInstance();

}  //*** CClNetResApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatError
//
//  Description:
//      Format an error.
//
//  Arguments:
//      rstrError   [OUT] String in which to return the error message.
//      dwError     [IN] Error code to format.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError( CString & rstrError, DWORD dwError )
{
    DWORD       _cch;
    TCHAR       _szError[ 512 ];

    _cch = ::FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof( _szError ) / sizeof( TCHAR ),
                    0
                    );
    if ( _cch == 0 )
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ::GetModuleHandle( _T("NTDLL.DLL") ),
                        dwError,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                        _szError,
                        sizeof( _szError ) / sizeof( TCHAR ),
                        0
                        );
    }  // if:  error formatting status code from system

    if ( _cch != 0 )
    {
        rstrError = _szError;
    } // if:  error occurred
    else
    {

#ifdef _DEBUG

        DWORD _sc = GetLastError();

        TRACE( _T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError );

#endif

        rstrError.Format( _T("Error 0x%08.8x"), dwError );

    }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );
    return ( AfxDllCanUnloadNow() && _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv )
{
    return _Module.GetClassObject( rclsid, riid, ppv );

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void )
{
    HRESULT hRes = S_OK;
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.RegisterServer( FALSE /*bRegTypeLib*/ );
    return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer( void )
{
    HRESULT hRes = S_OK;
    _Module.UnregisterServer();
    return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterCluAdminExtension
//
//  Description:
//      Register the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hCluster )
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    while ( *pwszResTypes != L'\0' )
    {
        wprintf( L"  %s\n", pwszResTypes );
        hr = RegisterCluAdminResourceTypeExtension(
                    hCluster,
                    pwszResTypes,
                    &CLSID_CoClNetResEx
                    );
        if ( hr != S_OK )
        {
            hrReturn = hr;
        } // if:  error registering the extension
        pwszResTypes += lstrlenW( pwszResTypes ) + 1;
    }  // while:  more resource types

    return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterCluAdminExtension
//
//  Description:
//      Unregister the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hCluster )
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    while ( *pwszResTypes != L'\0' )
    {
        wprintf( L"  %s\n", pwszResTypes );
        hr = UnregisterCluAdminResourceTypeExtension(
                    hCluster,
                    pwszResTypes,
                    &CLSID_CoClNetResEx
                    );
        if ( hr != S_OK )
        {
            hrReturn = hr;
        } // if:  error unregistering the extension
        pwszResTypes += lstrlenW( pwszResTypes ) + 1;
    }  // while:  more resource types

    return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\clnetresex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClNetResEx.h
//
//	Implementation File:
//		ClNetResEx.cpp
//
//	Description:
//		Global definitions across the DLL.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLNETRESEX_H__
#define __CLNETRESEX_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_DHCP_DATABASEPATH L"DatabasePath"
#define REGPARAM_DHCP_LOGFILEPATH L"LogFilePath"
#define REGPARAM_DHCP_BACKUPPATH L"BackupPath"

#define REGPARAM_WINS_DATABASEPATH L"DatabasePath"
#define REGPARAM_WINS_BACKUPPATH L"BackupPath"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError( CString & rstrError, DWORD dwError );

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // __CLNETRESEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Description:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_H__
#define __BASEPAGE_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef __DLGHELP_H__
#include "DlgHelp.h"    // for CDialogHelp
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"     // for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE( CBasePropertyPage )

// Construction
public:
    CBasePropertyPage( void );
    CBasePropertyPage(
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap
        );
    CBasePropertyPage(
        IN UINT             idd,
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap,
        IN UINT             nIDCaption = 0
        );
    virtual ~CBasePropertyPage( void )
    {
    } //*** ~CBasePropertyPage

    // Second phase construction.
    virtual HRESULT         HrInit( IN OUT CExtObject * peo );
    HRESULT                 HrCreatePage( void );

protected:
    void                    CommonConstruct( void );

// Attributes
protected:
    CExtObject *            m_peo;
    HPROPSHEETPAGE          m_hpage;

    IDD                     m_iddPropertyPage;
    IDD                     m_iddWizardPage;
    IDS                     m_idsCaption;

    CExtObject *            Peo( void ) const               { return m_peo; }

    IDD                     IddPropertyPage( void ) const   { return m_iddPropertyPage; }
    IDD                     IddWizardPage( void ) const     { return m_iddWizardPage; }
    IDS                     IdsCaption( void ) const        { return m_idsCaption; }

public:
    HPROPSHEETPAGE          Hpage( void ) const             { return m_hpage; }
    CLUADMEX_OBJECT_TYPE    Cot( void ) const;

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           ScParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                IN size_t                           cbBuf
                                )
    {
        UNREFERENCED_PARAMETER( pwszName );
        UNREFERENCED_PARAMETER( rvalue );
        UNREFERENCED_PARAMETER( cbBuf );
        return ERROR_SUCCESS;

    } //*** ScParseUnknownProperty

    virtual BOOL            BApplyChanges( void );
    virtual BOOL            BBuildPropList( IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE );
    virtual void            DisplaySetPropsError( IN DWORD sc, IN UINT idsOper ) const;

    virtual const CObjectProperty * Pprops( void ) const    { return NULL; }
    virtual DWORD                   Cprops( void ) const    { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL                    m_bSaved;
    const DWORD *           m_pdwWizardHelpMap;
    BOOL                    m_bDoDetach;

    BOOL                    BBackPressed( void ) const      { return m_bBackPressed; }
    BOOL                    BSaved( void ) const            { return m_bSaved; }
    IWCWizardCallback *     PiWizardCallback( void ) const;
    BOOL                    BWizard( void ) const;
    HCLUSTER                Hcluster( void ) const;
    void                    EnableNext( IN BOOL bEnable = TRUE );

    DWORD                   ScParseProperties( IN CClusPropList & rcpl );
    BOOL                    BSetPrivateProps(
                                IN BOOL bValidateOnly = FALSE,
                                IN BOOL bNoNewProps = FALSE
                                );

    void                    SetHelpMask( IN DWORD dwMask )  { m_dlghelp.SetHelpMask( dwMask ); }
    CDialogHelp             m_dlghelp;

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu( CWnd * pWnd, CPoint point );
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2002 Microsoft Corporation
//
//  Module Name:
//      DDxDDv.cpp
//
//  Description:
//      Implementation of custom dialog data exchange/dialog data validation
//      routines.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Maintained by:
//      George Potts (GPotts)   April 19, 2002
//
//  Revision History:
//
//  Notes:
//      The IDS_REQUIRED_FIELD_EMPTY string resource must be defined in
//      the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_Number
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      dwValue     [IN OUT] Value to set or get.
//      dwMin       [IN] Minimum value.
//      dwMax       [IN] Maximum value.
//      bSigned     [IN] TRUE = value is signed, FALSE = value is unsigned
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN OUT DWORD &          rdwValue,
    IN DWORD                dwMin,
    IN DWORD                dwMax,
    IN BOOL                 bSigned
    )
{
    HWND    hwndCtrl;
    DWORD   dwValue;
    HRESULT hr = S_OK;

    ASSERT( pDX != NULL );
#ifdef _DEBUG
    if ( bSigned )
    {
        ASSERT( static_cast< LONG >( dwMin ) < static_cast< LONG >( dwMax ) );
    }
    else
    {
        ASSERT( dwMin < dwMax );
    }
#endif // _DEBUG

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Get the control window handle.
    hwndCtrl = pDX->PrepareEditCtrl( nIDC );

    if ( pDX->m_bSaveAndValidate )
    {
        BOOL    bTranslated;

        // Get the number from the control.
        dwValue = GetDlgItemInt( pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned );

        // If the retrival failed, it is a signed number, and the minimum
        // value is the smallest negative value possible, check the string itself.
        if ( ! bTranslated && bSigned && (dwMin == 0x80000000) )
        {
            UINT    cch;
            TCHAR   szNumber[ 20 ];

            // See if it is the smallest negative number.
            cch = GetDlgItemText( pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, RTL_NUMBER_OF( szNumber ) );
            if ( (cch != 0) && (ClRtlStrNICmp( szNumber, _T("-2147483648"), RTL_NUMBER_OF( szNumber ) ) == 0) )
            {
                dwValue = 0x80000000;
                bTranslated = TRUE;
            } // if:  text retrieved successfully and is highest negative number
        } // if:  error translating number and getting signed number

        // If the retrieval failed or the specified number is
        // out of range, display an error.
        if (    ! bTranslated
            ||  (bSigned
                && (    (static_cast< LONG >( dwValue ) < static_cast< LONG >( dwMin ))
                    ||  (static_cast< LONG >( dwValue ) > static_cast< LONG >( dwMax ))
                    )
                )
            ||  (!  bSigned
                &&  (   (dwValue < dwMin)
                    ||  (dwValue > dwMax)
                    )
                )
            )
        {
            TCHAR szMin[ 32 ];
            TCHAR szMax[ 32 ];
            CString strPrompt;

            if ( bSigned )
            {
                hr = StringCchPrintf( szMin, RTL_NUMBER_OF( szMin ), _T("%d%"), dwMin );
                hr = StringCchPrintf( szMax, RTL_NUMBER_OF( szMax ), _T("%d%"), dwMax );
            } // if:  signed number
            else
            {
                hr = StringCchPrintf( szMin, RTL_NUMBER_OF( szMin ), _T("%u%"), dwMin );
                hr = StringCchPrintf( szMax, RTL_NUMBER_OF( szMax ), _T("%u%"), dwMax );
            } // else:  unsigned number
            AfxFormatString2( strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax );
            AfxMessageBox( strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE );
            strPrompt.Empty(); // exception prep
            pDX->Fail();
        } // if:  invalid string
        else
        {
            rdwValue = dwValue;
        } // if:  number is in range
    } // if:  saving data
    else
    {
        CString     strMinValue;
        CString     strMaxValue;
        UINT        cchMax;

        // Set the maximum number of characters that can be entered.
        if ( bSigned )
        {
            strMinValue.Format( _T("%d"), dwMin );
            strMaxValue.Format( _T("%d"), dwMax );
        } // if:  signed value
        else
        {
            strMinValue.Format( _T("%u"), dwMin );
            strMaxValue.Format( _T("%u"), dwMax );
        } // else:  unsigned value
        cchMax = max( strMinValue.GetLength(), strMaxValue.GetLength() );
        SendMessage( hwndCtrl, EM_LIMITTEXT, cchMax, 0 );

        // Set the value into the control.
        if ( bSigned )
        {
            LONG lValue = static_cast< LONG >( rdwValue );
            DDX_Text( pDX, nIDC, lValue );
        } // if:  signed value
        else
            DDX_Text( pDX, nIDC, rdwValue );
    } // else:  setting data onto the dialog

} //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_RequiredText
//
//  Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      nIDCLabel   [IN] Label control ID.
//      rstrValue   [IN] Value to set or get.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN int                  nIDCLabel,
    IN const CString &      rstrValue
    )
{
    ASSERT( pDX != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    if ( pDX->m_bSaveAndValidate )
    {
        if ( rstrValue.GetLength() == 0 )
        {
            HWND        hwndLabel;
            TCHAR       szLabel[ 1024 ];
            CString     strPrompt;

            // Get the label window handle
            hwndLabel = pDX->PrepareEditCtrl( nIDCLabel );

            // Get the text of the label.
            GetWindowText( hwndLabel, szLabel, RTL_NUMBER_OF( szLabel ) );

            // Remove ampersands (&) and colons (:).
            CleanupLabel( szLabel );

            // Format and display a message.
            strPrompt.FormatMessage( IDS_REQUIRED_FIELD_EMPTY, szLabel );
            AfxMessageBox( strPrompt, MB_ICONEXCLAMATION );

            // Do this so that the control receives focus.
            (void) pDX->PrepareEditCtrl( nIDC );

            // Fail the call.
            strPrompt.Empty();  // exception prep
            pDX->Fail();
        } // if:  field not specified
    } // if:  saving data

} //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupLabel
//
//  Description:
//      Prepare a label read from a dialog to be used as a string in a
//      message by removing ampersands (&) and colons (:).
//
//  Arguments:
//      pszLabel    [IN OUT] Label to be cleaned up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel( LPTSTR pszLabel )
{
    LPTSTR  pIn, pOut;
    LANGID  langid;
    WORD    primarylangid;
    BOOL    bFELanguage;

    // Get the language ID.
    langid = GetUserDefaultLangID();
    primarylangid = static_cast< WORD >( PRIMARYLANGID( langid ) );
    bFELanguage = ((primarylangid == LANG_JAPANESE)
                || (primarylangid == LANG_CHINESE)
                || (primarylangid == LANG_KOREAN) );

    //
    // Copy the name sans '&' and ':' chars
    //

    pIn = pOut = pszLabel;
    do
    {
        //
        // Strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
        //
        if (    bFELanguage
            &&  (pIn[ 0 ] == _T('('))
            &&  (pIn[ 1 ] == _T('&'))
            &&  (pIn[ 2 ] != _T('\0'))
            &&  (pIn[ 3 ] == _T(')')) )
        {
            pIn += 3;
        } // if:  Far East language with accelerator
        else if ( (*pIn != _T('&')) && (*pIn != _T(':')) )
        {
            *pOut++ = *pIn;
        } // else if:  accelerator found
    } while ( *pIn++ != _T('\0') );

} //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\dhcp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Dhcp.cpp
//
//  Description:
//      Implementation of the DHCP Service resource extension property page classes.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "Dhcp.h"
#include "BasePage.inl"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CDhcpParamsPage, CBasePropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CDhcpParamsPage, CBasePropertyPage )
    //{{AFX_MSG_MAP(CDhcpParamsPage)
    ON_EN_CHANGE( IDC_PP_DHCP_DATABASEPATH, OnChangeRequiredField )
    ON_EN_CHANGE( IDC_PP_DHCP_LOGFILEPATH, OnChangeRequiredField )
    ON_EN_CHANGE( IDC_PP_DHCP_BACKUPPATH, OnChangeRequiredField )
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::CDhcpParamsPage
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDhcpParamsPage::CDhcpParamsPage( void )
    : CBasePropertyPage(
            CDhcpParamsPage::IDD,
            g_aHelpIDs_IDD_PP_DHCP_PARAMETERS,
            g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS
            )
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CDhcpParamsPage)
    m_strDatabasePath = _T("");
    m_strLogFilePath = _T("");
    m_strBackupPath = _T("");
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[ epropDatabasePath ].Set( REGPARAM_DHCP_DATABASEPATH, m_strDatabasePath, m_strPrevDatabasePath, m_strDatabaseExpandedPath );
        m_rgProps[ epropLogFilePath ].Set( REGPARAM_DHCP_LOGFILEPATH, m_strLogFilePath, m_strPrevLogFilePath, m_strLogFileExpandedPath );
        m_rgProps[ epropBackupPath ].Set( REGPARAM_DHCP_BACKUPPATH, m_strBackupPath, m_strPrevBackupPath, m_strBackupExpandedPath );
    } // Setup the property array

    m_iddPropertyPage = IDD_PP_DHCP_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_DHCP_PARAMETERS;

} //*** CDhcpParamsPage::CDhcpParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDhcpParamsPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CDhcpParamsPage)
        DDX_Control( pDX, IDC_PP_DHCP_DATABASEPATH, m_editDatabasePath );
        DDX_Control( pDX, IDC_PP_DHCP_LOGFILEPATH, m_editLogFilePath );
        DDX_Control( pDX, IDC_PP_DHCP_BACKUPPATH, m_editBackupPath );
        DDX_Text( pDX, IDC_PP_DHCP_DATABASEPATH, m_strDatabasePath );
        DDX_Text( pDX, IDC_PP_DHCP_LOGFILEPATH, m_strLogFilePath );
        DDX_Text( pDX, IDC_PP_DHCP_BACKUPPATH, m_strBackupPath );
        //}}AFX_DATA_MAP

        // Handle numeric parameters.
        if ( ! BBackPressed() )
        {
        } // if: back button not pressed

        if ( pDX->m_bSaveAndValidate )
        {
            // Make sure all required fields are present.
            if ( ! BBackPressed() )
            {
                DDV_RequiredText( pDX, IDC_PP_DHCP_DATABASEPATH, IDC_PP_DHCP_DATABASEPATH_LABEL, m_strDatabasePath );
                DDV_RequiredText( pDX, IDC_PP_DHCP_LOGFILEPATH, IDC_PP_DHCP_LOGFILEPATH_LABEL, m_strLogFilePath );
                DDV_RequiredText( pDX, IDC_PP_DHCP_BACKUPPATH, IDC_PP_DHCP_BACKUPPATH_LABEL, m_strBackupPath );

            } // if: back button not pressed
        } // if: saving data from dialog
    } // if: not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange( pDX );

} //*** CDhcpParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::OnInitDialog( void )
{
    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CBasePropertyPage::OnInitDialog();

    // Limit the size of the text that can be entered in edit controls.
    m_editDatabasePath.SetLimitText( _MAX_PATH );
    m_editLogFilePath.SetLimitText( _MAX_PATH );
    m_editBackupPath.SetLimitText( _MAX_PATH );

    // If this is a wizard, make sure the default values are something legal.
    if ( BWizard( ) )
    {
        DWORD    status;
        WCHAR    szValidDevice[ 3 ]; // "X:" + NULL
        DWORD    dwSize = RTL_NUMBER_OF( szValidDevice );

        szValidDevice[ 0 ] = L'\0';
        
        status = ResUtilFindDependentDiskResourceDriveLetter( Peo( )->Hcluster( ), 
                                                              Peo( )->PrdResData( )->m_hresource, 
                                                              szValidDevice, 
                                                              &dwSize 
                                                              );
        szValidDevice[ 2 ] = L'\0';  // Make sure it's valid.

        // Did we find a disk resource in the the dependency list?
        if ( status == ERROR_SUCCESS
          && szValidDevice[ 0 ] != L'\0' )
        {
            WCHAR szFilePath[ MAX_PATH ];

            // If the default is "%SystemRoot%\<something>" then change it to match the
            // dependent resource
            if ( m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
              && ClRtlStrNICmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
            {
                // Start with the new drive letter
                hr = StringCchCopyNW( szFilePath, RTL_NUMBER_OF( szFilePath ), szValidDevice, 3 );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                // Is the expanded string really expanded?
                if ( m_strDatabaseExpandedPath[0] != L'%'  )
                {   // yes, then just copy the expanded string minus the drive letter.
                    LPCWSTR psz = m_strDatabaseExpandedPath;
                    psz = wcschr( psz, L':' );
                    if ( psz )
                    {
                        psz++;  // move to next character
                    }
                    else // if: psz
                    {
                        psz = m_strDatabaseExpandedPath;
                    } // else: just cat the whole thing, let the user figure it out.
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                }
                else
                {   // no, then strip the %SystemRoot%
                    // find the ending '%'... this must be there because of the strcmp above!
                    LPCWSTR psz = m_strDatabaseExpandedPath;
                    psz = wcschr( psz + 1, L'%' );
                    ASSERT( psz );
                    psz++; // move past the '%'
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                }

                m_editDatabasePath.SetWindowText( szFilePath );
            } // if: m_editDatabasePath == %SystemRoot%

            // If the default is "%SystemRoot%\<something>" then change it to match the
            // dependent resource
            if ( m_editLogFilePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
              && ClRtlStrNICmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
            {
                // Start with the new drive letter
                hr = StringCchCopyNW( szFilePath, RTL_NUMBER_OF( szFilePath ), szValidDevice, 3 );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                // Is the expanded string really expanded?
                if ( m_strLogFileExpandedPath[0] != L'%'  )
                {   // yes, then just copy the expanded string minus the drive letter.
                    LPCWSTR psz = m_strLogFileExpandedPath;
                    psz = wcschr( psz, L':' );
                    if ( psz )
                    {
                        psz++;  // move to next character
                    }
                    else // if: psz
                    {
                        psz = m_strLogFileExpandedPath;
                    } // else: just cat the whole thing, let the user figure it out.
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                }
                else
                {   // no, then strip the %SystemRoot%
                    // find the ending '%'... this must be there because of the strcmp above!
                    LPCWSTR psz = m_strLogFileExpandedPath;
                    psz = wcschr( psz + 1, L'%' );
                    ASSERT( psz );
                    psz++; // move past the '%'
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }

                }

                m_editLogFilePath.SetWindowText( szFilePath );
            } // if: m_editLogFilePath == %SystemRoot%
            else if ( szFilePath[0] == L'\0' )
            { // no path found - default to the same as the database path
                m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH );
                m_editLogFilePath.SetWindowText( szFilePath );
            } // else: no log path found

            // If the default is "%SystemRoot%\<something>" then change it to match the
            // dependent resource
            if ( m_editBackupPath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
              && ClRtlStrNICmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
            {
                // Start with the new drive letter
                hr = StringCchCopyNW( szFilePath, RTL_NUMBER_OF( szFilePath ), szValidDevice, 3 );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                // Is the expanded string really expanded?
                if ( m_strBackupExpandedPath[0] != L'%'  )
                {   // yes, then just copy the expanded string minus the drive letter.
                    LPCWSTR psz = m_strBackupExpandedPath;
                    psz = wcschr( psz, L':' );
                    if ( psz )
                    {
                        psz++;  // move to next character
                    }
                    else // if: psz
                    {
                        psz = m_strBackupExpandedPath;
                    } // else: just cat the whole thing, let the user figure it out.
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                }
                else
                {   // no, then strip the %SystemRoot%
                    // find the ending '%'... this must be there because of the strcmp above!
                    LPCWSTR psz = m_strBackupExpandedPath;
                    psz = wcschr( psz + 1, L'%' );
                    ASSERT( psz );
                    psz++; // move past the '%'
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                }

                m_editBackupPath.SetWindowText( szFilePath );
            } // if: m_editBackupPath == %SystemRoot%

        } // if: found a disk resource

    } // if: in a wizard

Cleanup:

    return TRUE;        // return TRUE unless you set the focus to a control
                        // EXCEPTION: OCX Property Pages should return FALSE

} //*** CDhcpParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::OnSetActive
//
//  Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::OnSetActive( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Enable/disable the Next/Finish button.
    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

    return CBasePropertyPage::OnSetActive();

} //*** CDhcpParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::OnChangeRequiredField
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDhcpParamsPage::OnChangeRequiredField( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    OnChangeCtrl();

    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

} //*** CDhcpParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDhcpParamsPage::BAllRequiredFieldsPresent
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::BAllRequiredFieldsPresent( void ) const
{
    BOOL    _bPresent;

    if ( 0
        || (m_editDatabasePath.GetWindowTextLength() == 0)
        || (m_editLogFilePath.GetWindowTextLength() == 0)
        || (m_editBackupPath.GetWindowTextLength() == 0)
        )
    {
        _bPresent = FALSE;
    } // if: required field not present
    else
    {
        _bPresent = TRUE;
    } // else: all required fields are present

    return _bPresent;

} //*** CDhcpParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Description:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DDXDDV_H__
#define __DDXDDV_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(
		pDX,
		nIDC,
		reinterpret_cast< DWORD & >( rnValue ),
		static_cast< DWORD >( nMin ),
		static_cast< DWORD >( nMax ),
		bSigned
		);

} //*** DDXNumber( LONG )

void CleanupLabel( LPTSTR psz );

/////////////////////////////////////////////////////////////////////////////

#endif // __DDXDDV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\dhcp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Dhcp.h
//
//	Implementation File:
//		Dhcp.cpp
//
//	Description:
//		Definition of the DHCP Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DHCP_H__
#define __DHCP_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDhcpParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDhcpParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDhcpParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE( CDhcpParamsPage )

// Construction
public:
	CDhcpParamsPage( void );

// Dialog Data
	//{{AFX_DATA(CDhcpParamsPage)
	enum { IDD = IDD_PP_DHCP_PARAMETERS };
	CEdit	m_editDatabasePath;
	CEdit	m_editLogFilePath;
	CEdit	m_editBackupPath;
	CString	m_strDatabasePath;
	CString	m_strLogFilePath;
	CString	m_strBackupPath;
	//}}AFX_DATA
	CString	m_strPrevDatabasePath;
	CString	m_strPrevLogFilePath;
	CString	m_strPrevBackupPath;
	CString m_strDatabaseExpandedPath;
	CString m_strLogFileExpandedPath;
	CString m_strBackupExpandedPath;

protected:
	enum
	{
		epropDatabasePath,
		epropLogFilePath,
		epropBackupPath,
		epropMAX
	};
	CObjectProperty		m_rgProps[ epropMAX ];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDhcpParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops( void ) const	{ return m_rgProps; }
	virtual DWORD					Cprops( void ) const	{ return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent( void ) const;

	// Generated message map functions
	//{{AFX_MSG(CDhcpParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDhcpParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // __DHCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DLGHELP_H__
#define __DLGHELP_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC( CDialogHelp )

// Construction
public:
	CDialogHelp( void ) { CommonConstruct(); }
	CDialogHelp( const DWORD * pdwHelpMap, DWORD dwMask );

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap( void ) const		{ return m_pmap; }
	DWORD						DwMask( void ) const	{ return m_dwMask; }
	DWORD						NHelpID( void ) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID( IN DWORD nCtrlID ) const;
	void						SetMap( IN const DWORD * pdwHelpMap )
	{
		ASSERT( pdwHelpMap != NULL );
		m_pmap = (const CMapCtrlToHelpID *) pdwHelpMap;
	} //*** SetMap()

// Operations
public:
	void		SetHelpMask( IN DWORD dwMask )	{ ASSERT( dwMask != 0 ); m_dwMask = dwMask; }

	void		OnContextMenu( CWnd * pWnd, CPoint point );
	BOOL		OnHelpInfo( HELPINFO * pHelpInfo );
	LRESULT		OnCommandHelp( WPARAM wParam, LPARAM lParam );

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // __DLGHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Description:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "Dhcp.h"
#include "Wins.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
        L"DHCP Service\0"
        L"WINS Service\0"
        ;
const DWORD g_cchResourceTypeNames  = sizeof( g_wszResourceTypeNames ) / sizeof( WCHAR );

static CRuntimeClass * g_rgprtcDhcpResPSPages[] = {
    RUNTIME_CLASS( CDhcpParamsPage ),
    NULL
    };
static CRuntimeClass * g_rgprtcWinsResPSPages[] = {
    RUNTIME_CLASS( CWinsParamsPage ),
    NULL
    };
static CRuntimeClass ** g_rgpprtcResPSPages[]   = {
    g_rgprtcDhcpResPSPages,
    g_rgprtcWinsResPSPages,
    };
static CRuntimeClass ** g_rgpprtcResWizPages[]  = {
    g_rgprtcDhcpResPSPages,
    g_rgprtcWinsResPSPages,
    };

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject( void )
{
    m_piData = NULL;
    m_piWizardCallback = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_hcluster = NULL;
    m_cobj = 0;
    m_podObjData = NULL;

} //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject( void )
{
    // Release the data interface.
    if ( PiData() != NULL )
    {
        PiData()->Release();
        m_piData = NULL;
    } // if:  we have a data interface pointer

    // Release the wizard callback interface.
    if ( PiWizardCallback() != NULL )
    {
        PiWizardCallback()->Release();
        m_piWizardCallback = NULL;
    } // if:  we have a wizard callback interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while ( pos != NULL )
        {
            delete Lpg().GetNext(pos);
        } // while:  more pages in the list
    } // Delete the pages

    delete m_podObjData;

} //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * _rgiid[] =
    {
        &IID_IWEExtendPropertySheet,
        &IID_IWEExtendWizard,
    };
    int     _iiid;

    for ( _iiid = 0 ; _iiid < sizeof( _rgiid ) / sizeof( _rgiid[ 0 ] ) ; _iiid++ )
    {
        if ( ::InlineIsEqualGUID( *_rgiid[ _iiid ], riid ) )
        {
            return S_OK;
        } // if:  found a matching IID
    }
    return S_FALSE;

} //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the sheet is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CException          _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResPSPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddPropertySheetPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    piCallback->Release();
    return _hr;

} //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreateWizardPages (IWEExtendWizard)
//
//  Description:
//      Create property sheet pages and add them to the wizard.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the wizard is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
    IN IUnknown *           piData,
    IN IWCWizardCallback *  piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CException          _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        m_piWizardCallback = piCallback;
        m_bWizard = TRUE;

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResWizPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddWizardPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piCallback->Release();
        if ( m_piWizardCallback == piCallback )
        {
            m_piWizardCallback = NULL;
        } // if: already saved interface pointer
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    return _hr;

} //*** CExtObject::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo( IN IUnknown * piData )
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * _pi;

        _hr = piData->QueryInterface( IID_IGetClusterUIInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_lcid = _pi->GetLocale();
        m_hfont = _pi->GetFont();
        m_hicon = _pi->GetIcon();

        _pi->Release();
    } // Save info about all types of objects

    return _hr;

} //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData( IN IUnknown * piData )
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    if ( piData != m_piData )
    {
        if ( m_piData != NULL )
        {
            m_piData->Release();
        } // if:  interface queried for previously
        m_piData = piData;
    } // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   _pi;

        _hr = piData->QueryInterface( IID_IGetClusterDataInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_hcluster = _pi->GetClusterHandle();
        m_cobj = _pi->GetObjectCount();
        if ( Cobj() != 1 )  // Only have support for one selected object.
        {
            _hr = E_NOTIMPL;
        } // if:  too many objects for us to handle

        _pi->Release();
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred before here
    } // Save info about all types of objects

    // Save info about this object.
    _hr = HrGetObjectInfo();

    return _hr;

} //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
///         Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo( void )
{
    HRESULT                     _hr = NOERROR;
    IGetClusterObjectInfo *     _piGcoi;
    CLUADMEX_OBJECT_TYPE        _cot = CLUADMEX_OT_NONE;
    CException                  _exc( FALSE /*bAutoDelete*/ );
    const CString *             _pstrResTypeName = NULL;

    ASSERT( PiData() != NULL );

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        _hr = PiData()->QueryInterface( IID_IGetClusterObjectInfo, reinterpret_cast< LPVOID * >( &_piGcoi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            _cot = _piGcoi->GetObjectType( 0 );
            switch ( _cot )
            {
                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   _pi;

                        m_podObjData = new CResData;
                        if ( m_podObjData == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                            throw &_exc;
                        } // if: error allocating memory

                        // Get an IGetClusterResourceInfo interface pointer.
                        _hr = PiData()->QueryInterface( IID_IGetClusterResourceInfo, reinterpret_cast< LPVOID * >( &_pi ) );
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if:  error querying for interface

                        PrdResDataRW()->m_hresource = _pi->GetResourceHandle( 0 );
                        ASSERT( PrdResDataRW()->m_hresource != NULL );
                        if ( PrdResDataRW()->m_hresource == NULL )
                        {
                            _hr = E_INVALIDARG;
                        } // if  invalid resource handle
                        else
                        {
                            _hr = HrGetResourceTypeName( _pi );
                        } // else:  resource handle is valid
                        _pi->Release();
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if: error occurred above

                        _pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
                    } // if:  object is a resource
                    break;

                case CLUADMEX_OT_RESOURCETYPE:
                    {
                        m_podObjData = new CObjData;
                        if ( m_podObjData == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                            throw &_exc;
                        }
                        _pstrResTypeName = &PodObjDataRW()->m_strName;
                    } // if: object is a resource type
                    break;

                default:
                    _hr = E_NOTIMPL;
                    throw &_exc;
                    break;
            } // switch:  object type

            PodObjDataRW()->m_cot = _cot;
            _hr = HrGetObjectName( _piGcoi );
        } // try
        catch ( CException * _pe )
        {
            if ( !FAILED (_hr) )
            {
                _hr = E_FAIL;
            }
            _pe->Delete();
        } // catch:  CException

        _piGcoi->Release();

        // If we failed to initialize _pstrResTypeName, then bail.
        // We are doing this because of PREFIX, which assumes that the
        // new operator for OT_RESOURCETYPE above can fail - 
        // but it should never happen that the new should perform a throw.
        if ( _pstrResTypeName == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }

        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred above
    } // Get object info

    // If this is a resource or resource type, see if we know about this type.
    if (    (   (_cot == CLUADMEX_OT_RESOURCE)
            ||  (_cot == CLUADMEX_OT_RESOURCETYPE) )
        && (_hr == NOERROR) )
    {
        LPCWSTR _pwszResTypeName;

        // Find the resource type name in our list.
        // Save the index for use in other arrays.
        for ( m_istrResTypeName = 0, _pwszResTypeName = g_wszResourceTypeNames
            ; *_pwszResTypeName != L'\0'
            ; m_istrResTypeName++, _pwszResTypeName += lstrlenW( _pwszResTypeName ) + 1
            )
        {
            if ( _pstrResTypeName->CompareNoCase( _pwszResTypeName ) == 0 )
            {
                break;
            } // if:  found resource type name
        } // for:  each resource type in the list
        if ( *_pwszResTypeName == L'\0' )
        {
            _hr = E_NOTIMPL;
        } // if:  resource type name not found
    } // See if we know about this resource type

    return _hr;

} //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Description:
//      Get the name of the object.
//
//  Arguments:
//      piData [IN]
//          IGetClusterObjectInfo interface pointer for getting the object
//          name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName( IN IGetClusterObjectInfo * pi )
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;
    BSTR        _bstr        = NULL;

    ASSERT( pi != NULL );

    _hr = pi->GetObjectName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        goto Cleanup;
    } // if:  error getting object name

    _bstr = SysAllocStringLen( NULL, _cchName );
    if ( _bstr != NULL )
    {
        try
        {
            _hr = pi->GetObjectName( 0, _bstr, &_cchName );
            if ( _hr == NOERROR )
            {
                _pwszName = new WCHAR[_cchName];
                _hr = StringCchCopyW( _pwszName, _cchName, _bstr );
                if ( FAILED( _hr ) )
                {
                    goto Cleanup;
                }
                _pwszName[ _cchName - 1 ] = L'\0';
            }

            PodObjDataRW()->m_strName = _pwszName;
        } // try
        catch ( CMemoryException * _pme )
        {
            _pme->Delete();
            _hr = E_OUTOFMEMORY;
        } // catch:  CMemoryException
        SysFreeString( _bstr );
    } // if: ( _bstr != NULL )
    else
    {
        _hr = E_OUTOFMEMORY;
    }

Cleanup:

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData [IN]
//          IGetClusterResourceInfo interface pointer for getting the resource
//          type name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterResourceInfo
//          ::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName( IN IGetClusterResourceInfo * pi )
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;
    BSTR        _bstr        = NULL;

    ASSERT( pi != NULL );

    _hr = pi->GetResourceTypeName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        goto Cleanup;
    } // if:  error getting resource type name

    _bstr = SysAllocStringLen( NULL, _cchName );
    if ( _bstr != NULL )
    {
        try
        {
            _hr = pi->GetResourceTypeName( 0, _bstr, &_cchName );
            if ( _hr == NOERROR )
            {
                _pwszName = new WCHAR[_cchName];
                _hr = StringCchCopyW( _pwszName, _cchName, _bstr );
                if ( FAILED( _hr ) )
                {
                    goto Cleanup;
                }
                _pwszName[ _cchName - 1 ] = L'\0';
            }

            PrdResDataRW()->m_strResTypeName = _pwszName;
        } // try
        catch ( CMemoryException * _pme )
        {
            _pme->Delete();
            _hr = E_OUTOFMEMORY;
        } // catch:  CMemoryException
        SysFreeString( _bstr );
    } // if: ( _bstr != NULL )
    else
    {
        _hr = E_OUTOFMEMORY;
    }

Cleanup:

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2002 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.cpp
//
//	Abstract:
//		Implementation of the CDialogHelp class.
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CDialogHelp, CObject )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CDialogHelp
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pmap		[IN] Map array mapping control IDs to help IDs.
//		dwMask		[IN] Mask to use for the low word of the help ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp( IN const DWORD * pdwHelpMap, IN DWORD dwMask )
{
	ASSERT( pdwHelpMap != NULL );

	CommonConstruct();
	SetMap( pdwHelpMap );
	m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CommonConstruct
//
//	Routine Description:
//		Do common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct( void )
{
	m_pmap = NULL;
	m_dwMask = 0;
	m_nHelpID = 0;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::NHelpFromCtrlID
//
//	Routine Description:
//		Return the help ID from a control ID.
//
//	Arguments:
//		nCtrlID		[IN] ID of control to search for.
//
//	Return Value:
//		nHelpID		Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID( IN DWORD nCtrlID ) const
{
	DWORD						nHelpID = 0;
	const CMapCtrlToHelpID *	pmap = Pmap();

	ASSERT( pmap != NULL );
	ASSERT( nCtrlID != 0 );

	for ( ; pmap->m_nCtrlID != 0 ; pmap++ )
	{
		if ( pmap->m_nCtrlID == nCtrlID )
		{
			nHelpID = pmap->m_nHelpCtrlID;
			break;
		}  // if:  found a match
	}  // for:  each control

	TRACE( _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID );

	return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu( CWnd * pWnd, CPoint point )
{
	CWnd *	pwndChild;
	CPoint	ptDialog;
	DWORD	nHelpID = 0;

	ASSERT( pWnd != NULL );

	m_nHelpID = 0;

	// Convert the point into dialog coordinates.
	ptDialog = point;
	pWnd->ScreenToClient( &ptDialog );

	// Find the control the cursor is over.
	{
		DWORD	nCtrlID;

		pwndChild = pWnd->ChildWindowFromPoint( ptDialog );
		if ( ( pwndChild != NULL ) && ( pwndChild->GetStyle() & WS_VISIBLE ) )
		{
			nCtrlID = pwndChild->GetDlgCtrlID();
			if ( nCtrlID != 0 )
			{
				nHelpID = NHelpFromCtrlID( nCtrlID );
			} // if: control ID found
		}  // if:  over a child window
	}  // Find the control the cursor is over

	// Display a popup menu.
	if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
	{
		CString	strMenu;
		CMenu	menu;

		try
		{
			strMenu.LoadString( IDS_MENU_WHATS_THIS );
		}  // try
		catch ( CMemoryException * pme )
		{
			pme->Delete();
			return;
		}  // catch:  CMemoryException

		if ( menu.CreatePopupMenu() )
		{
			if ( menu.AppendMenu( MF_STRING | MF_ENABLED, ID_HELP, strMenu ) )
			{
				DWORD	nCmd;
				m_nHelpID = nHelpID;
				nCmd = menu.TrackPopupMenu(
					TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
					point.x,
					point.y,
					AfxGetMainWnd()
					);
				if ( nCmd != 0 )
				{
					AfxGetApp()->WinHelp( m_nHelpID, HELP_CONTEXTPOPUP );
				} // if: menu item selected
			}  // if:  menu item added successfully
			menu.DestroyMenu();
		}  // if:  popup menu created successfully
	}  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo( HELPINFO * pHelpInfo )
{
	// If this is for a control, display control-specific help.
	if (	( pHelpInfo->iContextType == HELPINFO_WINDOW )
		&&	( pHelpInfo->iCtrlId != 0 ) )
	{
		DWORD	nHelpID = NHelpFromCtrlID( pHelpInfo->iCtrlId );
		if ( nHelpID != 0 )
		{
			if ( nHelpID != -1 )
			{
				AfxGetApp()->WinHelp( nHelpID, HELP_CONTEXTPOPUP );
			} // if: valid help ID found
			return TRUE;
		}  // if:  found the control in the list
	}  // if:  need help on a specific control

	// Display dialog help.
	return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		WPARAM		[IN] Passed on to base class method.
//		lParam		[IN] Help ID.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

	return TRUE;

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\helparr.h ===
// Copyright (c) 1996-1999, Microsoft Corporation, all rights reserved.
//
// cnetharr.h is used by ClNetResEx.rc
// Cluster Admin DHCP and WINs Dialogs
// Help constants & DWORD arrays
//
// 04/29/99 Melissa Simmons
//
//

#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_DHCP_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_DHCP_DATABASEPATH_LABEL, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_DATABASEPATH, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_LOGFILEPATH_LABEL, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_LOGFILEPATH, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_BACKUPPATH_LABEL, IDH_PP_DHCP_BACKUPPATH,
	IDC_PP_DHCP_BACKUPPATH, IDH_PP_DHCP_BACKUPPATH, 
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_WINS_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_WINS_DATABASEPATH_LABEL, IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_DATABASEPATH,IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_BACKUPPATH_LABEL, IDH_PP_WINS_BACKUPPATH,
	IDC_PP_WINS_BACKUPPATH, IDH_PP_WINS_BACKUPPATH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_DHCP_DATABASEPATH_LABEL, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_DATABASEPATH, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_LOGFILEPATH_LABEL, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_LOGFILEPATH, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_BACKUPPATH_LABEL,	IDH_PP_DHCP_BACKUPPATH,
	IDC_PP_DHCP_BACKUPPATH, IDH_PP_DHCP_BACKUPPATH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_WINS_DATABASEPATH_LABEL, IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_DATABASEPATH,IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_BACKUPPATH_LABEL, IDH_PP_WINS_BACKUPPATH,
	IDC_PP_WINS_BACKUPPATH, IDH_PP_WINS_BACKUPPATH,
	0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_PP_DHCP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_WINS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS[];


#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Implementation File:
//		ExtObj.cpp
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __EXTOBJ_H__
#define __EXTOBJ_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoClNetResEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CNodeData
/////////////////////////////////////////////////////////////////////////////

class CNodeData : public CObjData
{
public:
	HNODE		m_hnode;

};  //*** class CNodeData

/////////////////////////////////////////////////////////////////////////////
// class CGroupData
/////////////////////////////////////////////////////////////////////////////

class CGroupData : public CObjData
{
public:
	HGROUP		m_hgroup;

};  //*** class CGroupData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CNetworkData
/////////////////////////////////////////////////////////////////////////////

class CNetworkData : public CObjData
{
public:
	HNETWORK	m_hnetwork;

};  //*** class CNetworkData

/////////////////////////////////////////////////////////////////////////////
// class CNetInterfaceData
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceData : public CObjData
{
public:
	HNETINTERFACE	m_hnetinterface;

};  //*** class CNetInterfaceData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass< CExtObject, &CLSID_CoClNetResEx >
{
public:
	CExtObject( void );
BEGIN_COM_MAP( CExtObject )
	COM_INTERFACE_ENTRY( IWEExtendPropertySheet )
	COM_INTERFACE_ENTRY( IWEExtendWizard )
	COM_INTERFACE_ENTRY( ISupportErrorInfo )
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE( CExtObject ) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY( CExtObject, _T("CLUADMEX.ClNetResEx"), _T("CLUADMEX.ClNetResEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT )

// ISupportsErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

// IWEExtendPropertySheet
public:
	STDMETHOD( CreatePropertySheetPages )(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD( CreateWizardPages )(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW( void ) const			{ return m_podObjData; }
	CResData *					PrdResDataRW( void ) const			{ return static_cast< CResData * >( m_podObjData ); }

public:
	IUnknown *					PiData( void ) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback( void ) const		{ return m_piWizardCallback; }
	BOOL						BWizard( void ) const				{ return m_bWizard; }
	DWORD						IstrResTypeName( void ) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid( void ) const					{ return m_lcid; }
	HFONT						Hfont( void ) const					{ return m_hfont; }
	HICON						Hicon( void ) const					{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster( void ) const				{ return m_hcluster; }
	LONG						Cobj( void ) const					{ return m_cobj; }

	const CObjData *			PodObjData( void ) const			{ return m_podObjData; }
	const CNodeData *			PndNodeData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_NODE ); return static_cast< CNodeData * >( m_podObjData ); }
	const CGroupData *			PgdGroupData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_GROUP ); return static_cast< CGroupData * >( m_podObjData ); }
	const CResData *			PrdResData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_RESOURCE ); return static_cast< CResData * >( m_podObjData ); }
	const CNetworkData *		PndNetworkData( void ) const		{ ASSERT( Cot() == CLUADMEX_OT_NETWORK ); return static_cast< CNetworkData * >( m_podObjData ); }
	const CNetInterfaceData *	PndNetInterfaceData( void ) const	{ ASSERT( Cot() == CLUADMEX_OT_NETINTERFACE ); return static_cast< CNetInterfaceData * >( m_podObjData ); }

	CLUADMEX_OBJECT_TYPE		Cot( void ) const					{ ASSERT( PodObjData() != NULL ); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo( IN IUnknown * piData );
	HRESULT						HrSaveData( IN IUnknown * piData );
	HRESULT						HrGetObjectInfo( void );
	HRESULT						HrGetObjectName( IN IGetClusterObjectInfo * pi );
	HRESULT						HrGetResourceTypeName( IN IGetClusterResourceInfo * pi );

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg( void )							{ return m_lpg; }

}; //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // __EXTOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __HELPDATA_H__
#define __HELPDATA_H__

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // __HELPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\proplist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      PropList.cpp
//
//  Description:
//      Sucks in the CClusPropList library.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\helpids.h ===
#define	IDH_PP_DHCP_DATABASEPATH	700000075
#define	IDH_PP_DHCP_BACKUPPATH	700000076
#define IDH_PP_DHCP_LOGFILEPATH_CLNR	700005001
#define	IDH_PP_WINS_DATABASEPATH	700000300
#define	IDH_PP_WINS_BACKUPPATH	700000301
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClNetResEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClNetResEx.rc
//
#define IDD_PP_DHCP_PARAMETERS          250
#define IDD_PP_WINS_PARAMETERS          251
#define IDD_WIZ_DHCP_PARAMETERS         260
#define IDD_WIZ_WINS_PARAMETERS         261
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DHCP_DATABASEPATH_LABEL  1010
#define IDC_PP_DHCP_DATABASEPATH        1011
#define IDC_PP_DHCP_LOGFILEPATH_LABEL   1012
#define IDC_PP_DHCP_LOGFILEPATH         1013
#define IDC_PP_DHCP_BACKUPPATH_LABEL    1014
#define IDC_PP_DHCP_BACKUPPATH          1015
#define IDC_PP_WINS_DATABASEPATH_LABEL  1020
#define IDC_PP_WINS_DATABASEPATH        1021
#define IDC_PP_WINS_BACKUPPATH_LABEL    1022
#define IDC_PP_WINS_BACKUPPATH          1023
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_ERROR_MSG_ID                31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_ERROR_SETTING_PROPERTIES    31103
#define IDS_ERROR_VALIDATING_PROPERTIES 31104
#define IDS_ERROR_NO_ENDING_BACKSLASH   31105
#define IDS_APPLY_PARAM_CHANGES_ERROR   31200
#define IDS_MENU_WHATS_THIS             31201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1200
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE            // Microsoft Windows NT Cluster Administrator
                            //   Extension DLLs need to be Unicode
                            //   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment( lib, "clusapi.lib" )

// Link against the Cluster Administrator Extensions library.
#pragma comment( lib, "uuid.lib" )

// Link against Resource Utilities library.
#pragma comment( lib, "resutils.lib" )

// Link against String Safe library.
#pragma comment( lib, "strsafe.lib" )

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <clusapi.h>
#include <resapi.h>

#include <strsafe.h>
#include "clstrcmp.h"

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT    IDS;
typedef UINT    IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2002 Microsoft Corporation
//
//  Module Name:
//      RegExt.cpp
//
//  Description:
//      Implementation of routines for extension registration.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//      George Potts (GPotts)   April 7, 2002
//
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT DWORD *     pcbSize
    );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminClusterExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterKey succeeded

    return hr;

} //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNodesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

    return hr;

} //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllGroupsExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

    return hr;

} //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourcesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

    return hr;

} //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourceTypesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

    return hr;

} //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetworksExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

    return hr;

} //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetInterfacesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

    return hr;

} //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminResourceTypeExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting resource type key
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterResourceTypeKey succeeded

    return hr;

} //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminClusterExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterKey succeeded

    return hr;

} //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNodesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllGroupsExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

    return hr;

} //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourcesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

    return hr;

} //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourceTypesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

    return hr;

} //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetworksExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetInterfacesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminResourceTypeExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting resource type key
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterResourceTypeKey succeeded

    return hr;

} //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkeyCluster == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( hr == ERROR_SUCCESS )
        {
            // Register the extension.
            hr = RegisterAnyCluAdminExtension( hkey, pClsid );

            ClusterRegCloseKey( hkey );
        } // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key retrieved successfully

    return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    LPOLESTR    pwszClsid;
    DWORD       cbSize;
    size_t      cbNewSize;
    LPWSTR      pwszValue       = NULL;
    LPWSTR      pwszNewValue    = NULL;
    BOOL        bAlreadyRegistered;

    LPCWSTR     pwszValueBuf    = NULL;
    LPWSTR      pwszNewValueBuf = NULL;
    size_t      cch;
    size_t      cchBuf;
    DWORD       dwType;

    // Convert the CLSID to a string.
    hr = StringFromCLSID( *pClsid, &pwszClsid );
    if ( hr != S_OK )
    {
        goto Cleanup;
    }

    // Read the current value.
    hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
    if ( hr != S_OK )
    {
        goto Cleanup;
    }

    // Check to see if the extension has been registered yet.
    if ( pwszValue == NULL )
    {
        bAlreadyRegistered = FALSE;
    } // if:  empty value found
    else
    {
        pwszValueBuf = pwszValue;

        while ( *pwszValueBuf != L'\0' )
        {
            if ( ClRtlStrICmp( pwszClsid, pwszValueBuf ) == 0 )
            {
                break;
            } // if:  CLSID for this extension already in list
            pwszValueBuf += wcslen(pwszValueBuf) + 1;
        } // while:  more strings in the extension list
        bAlreadyRegistered = (*pwszValueBuf != L'\0');
    } // else:  extension value exists

    // Register the extension.
    if ( ! bAlreadyRegistered )
    {
        // Allocate a new buffer.
        cbNewSize = cbSize + (wcslen( pwszClsid ) + 1) * sizeof( WCHAR );
        if ( cbSize == 0 ) // Add size of final NULL if first entry.
        {
            cbNewSize += sizeof( WCHAR );
        } // if:  no previous value
        pwszNewValue = new WCHAR[ cbNewSize / sizeof( *pwszNewValue ) ];
        if ( pwszNewValue == NULL )
        {
            hr = GetLastError();
            goto Cleanup;
        } // if:  error allocating memory

        pwszValueBuf    = pwszValue;
        pwszNewValueBuf = pwszNewValue;
        cchBuf = cbNewSize / sizeof( *pwszNewValueBuf );   // Buffer size of pwszNewValueBuf

        // Copy the existing extensions to the new buffer.
        if ( pwszValue != NULL)
        {
            while ( *pwszValueBuf != L'\0' )
            {
                hr = StringCchCopyW( pwszNewValueBuf, cchBuf, pwszValueBuf );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                cch = wcslen( pwszValueBuf ) + 1;
                pwszValueBuf += cch;
                pwszNewValueBuf += cch;
                cchBuf -= cch;          // Decrement the amount of the remaining buffer.
            } // while:  more strings in the extension list
        } // if:  previous value buffer existed

        // Add the new CLSID to the list.
        hr = StringCchCopyW( pwszNewValueBuf, cchBuf, pwszClsid );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        pwszNewValueBuf += wcslen( pwszClsid ) + 1;

        // Write the value to the cluster database.
        dwType = REG_MULTI_SZ;
        hr = ClusterRegSetValue(
                        hkey,
                        REG_VALUE_ADMIN_EXTENSIONS,
                        dwType,
                        reinterpret_cast< LPBYTE >( pwszNewValue ),
                        (DWORD) cbNewSize
                        );

    } // if:  extension not registered yet

Cleanup:

    delete [] pwszNewValue;
    delete [] pwszValue;
    CoTaskMemFree( pwszClsid );

    return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
IN HCLUSTER         hCluster,
IN LPCWSTR          pwszKeyName,
IN const CLSID *    pClsid
)
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkeyCluster == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( hr == ERROR_SUCCESS )
        {
            // Unregister the extension.
            hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

            ClusterRegCloseKey( hkey );
        } // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key retrieved successfully

    return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    LPOLESTR    pwszClsid;
    DWORD       cbSize;
    size_t      cbNewSize;
    LPWSTR      pwszValue       = NULL;
    LPWSTR      pwszNewValue    = NULL;
    BOOL        bAlreadyUnregistered;

    LPCWSTR     pwszValueBuf    = NULL;
    LPWSTR      pwszNewValueBuf = NULL;
    size_t      cch;
    size_t      cchBuf;
    DWORD       dwType;

    // Convert the CLSID to a string.
    hr = StringFromCLSID( *pClsid, &pwszClsid );
    if ( hr != S_OK )
    {
        goto Cleanup;
    }

    // Read the current value.
    hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
    if ( hr == S_OK )
    {
        goto Cleanup;
    }

    // Check to see if the extension has been unregistered yet.
    if ( pwszValue == NULL )
    {
        bAlreadyUnregistered = TRUE;
    } // if:  empty value found
    else
    {
        pwszValueBuf = pwszValue;

        while ( *pwszValueBuf != L'\0' )
        {
            if ( ClRtlStrICmp( pwszClsid, pwszValueBuf ) == 0 )
            {
                break;
            } // if:  CLSID for this extension found in list
            pwszValueBuf += wcslen( pwszValueBuf ) + 1;
        } // while:  more strings in the extension list
        bAlreadyUnregistered = (*pwszValueBuf == L'\0');
    } // else:  extension value exists

    // Unregister the extension.
    if ( ! bAlreadyUnregistered )
    {
        // Allocate a new buffer.
        cbNewSize = cbSize - (wcslen( pwszClsid ) + 1) * sizeof( WCHAR );
        if ( cbNewSize == sizeof( WCHAR ) )
        {
            cbNewSize = 0;
        } // if:  no previous value
        pwszNewValue = new WCHAR[ cbNewSize / sizeof( *pwszNewValue ) ];
        if ( pwszNewValue == NULL )
        {
            hr = GetLastError();
            goto Cleanup;
        } // if:  error allocating memory

        pwszValueBuf    = pwszValue;
        pwszNewValueBuf = pwszNewValue;
        cchBuf = cbNewSize / sizeof( *pwszNewValueBuf );

        // Copy the existing extensions to the new buffer.
        if ( (cbNewSize > 0) && (pwszValue != NULL) )
        {
            while ( *pwszValueBuf != L'\0' )
            {
                if ( ClRtlStrICmp( pwszClsid, pwszValueBuf ) != 0 )
                {
                    hr = StringCchCopyW( pwszNewValueBuf, cchBuf, pwszValueBuf );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    cch = wcslen( pwszNewValueBuf ) + 1;
                    pwszNewValueBuf += cch;
                    cchBuf -= cch;          // Decrement the remaining buffer size.
                } // if:  not CLSID being removed
                pwszValueBuf += wcslen( pwszValueBuf ) + 1;
            } // while:  more strings in the extension list
        } // if:  previous value buffer existed

        // Write the value to the cluster database.
        dwType = REG_MULTI_SZ;
        hr = ClusterRegSetValue(
                        hkey,
                        REG_VALUE_ADMIN_EXTENSIONS,
                        dwType,
                        reinterpret_cast< LPBYTE >( pwszNewValue ),
                        (DWORD) cbNewSize
                        );

    } // if:  extension not unregistered yet

Cleanup:

    delete [] pwszNewValue;
    delete [] pwszValue;
    CoTaskMemFree( pwszClsid );

    return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ReadValue
//
//  Description:
//      Reads a value from the cluster database.
//
//  Arguments:
//      hkey [IN]
//          Handle for the key to read from.
//
//      pwszValueName [IN]
//          Name of value to read.
//
//      ppwszValue [OUT]
//          Address of pointer in which to return data.  The string is
//          allocated using new and must be deallocated by the calling
//          delete [].
//
//      pcbSize [OUT]
//          Size in bytes of the allocated value buffer.
//
//  Return Value:
//      Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT DWORD *     pcbSize
    )
{
    DWORD       dwStatus;
    DWORD       cbSize;
    DWORD       dwType;
    LPWSTR      pwszValue;

    *ppwszValue = NULL;
    *pcbSize = 0;

    // Get the length of the value.
    dwSt